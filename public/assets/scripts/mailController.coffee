(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);throw new Error("Cannot find module '"+o+"'")}var f=n[o]={exports:{}};t[o][0].call(f.exports,function(e){var n=t[o][1][e];return s(n?n:e)},f,f.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
(function (process){
nodemailer = require('nodemailer')

transporter = nodemailer.createTransport
  service: 'Mailgun'
  auth:
    user: 'postmaster@sandbox3e9738d7b6824f119ff9fde62edd7d42.mailgun.org'
    pass: process.env.MAILGUN_PASSWORD

sendEmail = 'hello'


module.exports = {sendEmail}

}).call(this,require("7YKIPe"))
},{"7YKIPe":17,"nodemailer":38}],2:[function(require,module,exports){
;(function () {

  var object = typeof exports != 'undefined' ? exports : this; // #8: web workers
  var chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=';

  function InvalidCharacterError(message) {
    this.message = message;
  }
  InvalidCharacterError.prototype = new Error;
  InvalidCharacterError.prototype.name = 'InvalidCharacterError';

  // encoder
  // [https://gist.github.com/999166] by [https://github.com/nignag]
  object.btoa || (
  object.btoa = function (input) {
    for (
      // initialize result and counter
      var block, charCode, idx = 0, map = chars, output = '';
      // if the next input index does not exist:
      //   change the mapping table to "="
      //   check if d has no fractional digits
      input.charAt(idx | 0) || (map = '=', idx % 1);
      // "8 - idx % 1 * 8" generates the sequence 2, 4, 6, 8
      output += map.charAt(63 & block >> 8 - idx % 1 * 8)
    ) {
      charCode = input.charCodeAt(idx += 3/4);
      if (charCode > 0xFF) {
        throw new InvalidCharacterError("'btoa' failed: The string to be encoded contains characters outside of the Latin1 range.");
      }
      block = block << 8 | charCode;
    }
    return output;
  });

  // decoder
  // [https://gist.github.com/1020396] by [https://github.com/atk]
  object.atob || (
  object.atob = function (input) {
    input = input.replace(/=+$/, '');
    if (input.length % 4 == 1) {
      throw new InvalidCharacterError("'atob' failed: The string to be decoded is not correctly encoded.");
    }
    for (
      // initialize result and counters
      var bc = 0, bs, buffer, idx = 0, output = '';
      // get next character
      buffer = input.charAt(idx++);
      // character found in table? initialize bit storage and add its ascii value;
      ~buffer && (bs = bc % 4 ? bs * 64 + buffer : buffer,
        // and if not first of each 4 characters,
        // convert the first 8 bits to one ascii character
        bc++ % 4) ? output += String.fromCharCode(255 & bs >> (-2 * bc & 6)) : 0
    ) {
      // try to find character in table (0-63, not found => -1)
      buffer = chars.indexOf(buffer);
    }
    return output;
  });

}());

},{}],3:[function(require,module,exports){
(function (process,Buffer){
var msg = require('pako/lib/zlib/messages');
var zstream = require('pako/lib/zlib/zstream');
var zlib_deflate = require('pako/lib/zlib/deflate.js');
var zlib_inflate = require('pako/lib/zlib/inflate.js');
var constants = require('pako/lib/zlib/constants');

for (var key in constants) {
  exports[key] = constants[key];
}

// zlib modes
exports.NONE = 0;
exports.DEFLATE = 1;
exports.INFLATE = 2;
exports.GZIP = 3;
exports.GUNZIP = 4;
exports.DEFLATERAW = 5;
exports.INFLATERAW = 6;
exports.UNZIP = 7;

/**
 * Emulate Node's zlib C++ layer for use by the JS layer in index.js
 */
function Zlib(mode) {
  if (mode < exports.DEFLATE || mode > exports.UNZIP)
    throw new TypeError("Bad argument");
    
  this.mode = mode;
  this.init_done = false;
  this.write_in_progress = false;
  this.pending_close = false;
  this.windowBits = 0;
  this.level = 0;
  this.memLevel = 0;
  this.strategy = 0;
  this.dictionary = null;
}

Zlib.prototype.init = function(windowBits, level, memLevel, strategy, dictionary) {
  this.windowBits = windowBits;
  this.level = level;
  this.memLevel = memLevel;
  this.strategy = strategy;
  // dictionary not supported.
  
  if (this.mode === exports.GZIP || this.mode === exports.GUNZIP)
    this.windowBits += 16;
    
  if (this.mode === exports.UNZIP)
    this.windowBits += 32;
    
  if (this.mode === exports.DEFLATERAW || this.mode === exports.INFLATERAW)
    this.windowBits = -this.windowBits;
    
  this.strm = new zstream();
  
  switch (this.mode) {
    case exports.DEFLATE:
    case exports.GZIP:
    case exports.DEFLATERAW:
      var status = zlib_deflate.deflateInit2(
        this.strm,
        this.level,
        exports.Z_DEFLATED,
        this.windowBits,
        this.memLevel,
        this.strategy
      );
      break;
    case exports.INFLATE:
    case exports.GUNZIP:
    case exports.INFLATERAW:
    case exports.UNZIP:
      var status  = zlib_inflate.inflateInit2(
        this.strm,
        this.windowBits
      );
      break;
    default:
      throw new Error("Unknown mode " + this.mode);
  }
  
  if (status !== exports.Z_OK) {
    this._error(status);
    return;
  }
  
  this.write_in_progress = false;
  this.init_done = true;
};

Zlib.prototype.params = function() {
  throw new Error("deflateParams Not supported");
};

Zlib.prototype._writeCheck = function() {
  if (!this.init_done)
    throw new Error("write before init");
    
  if (this.mode === exports.NONE)
    throw new Error("already finalized");
    
  if (this.write_in_progress)
    throw new Error("write already in progress");
    
  if (this.pending_close)
    throw new Error("close is pending");
};

Zlib.prototype.write = function(flush, input, in_off, in_len, out, out_off, out_len) {    
  this._writeCheck();
  this.write_in_progress = true;
  
  var self = this;
  process.nextTick(function() {
    self.write_in_progress = false;
    var res = self._write(flush, input, in_off, in_len, out, out_off, out_len);
    self.callback(res[0], res[1]);
    
    if (self.pending_close)
      self.close();
  });
  
  return this;
};

// set method for Node buffers, used by pako
function bufferSet(data, offset) {
  for (var i = 0; i < data.length; i++) {
    this[offset + i] = data[i];
  }
}

Zlib.prototype.writeSync = function(flush, input, in_off, in_len, out, out_off, out_len) {
  this._writeCheck();
  return this._write(flush, input, in_off, in_len, out, out_off, out_len);
};

Zlib.prototype._write = function(flush, input, in_off, in_len, out, out_off, out_len) {
  this.write_in_progress = true;
  
  if (flush !== exports.Z_NO_FLUSH &&
      flush !== exports.Z_PARTIAL_FLUSH &&
      flush !== exports.Z_SYNC_FLUSH &&
      flush !== exports.Z_FULL_FLUSH &&
      flush !== exports.Z_FINISH &&
      flush !== exports.Z_BLOCK) {
    throw new Error("Invalid flush value");
  }
  
  if (input == null) {
    input = new Buffer(0);
    in_len = 0;
    in_off = 0;
  }
  
  if (out._set)
    out.set = out._set;
  else
    out.set = bufferSet;
  
  var strm = this.strm;
  strm.avail_in = in_len;
  strm.input = input;
  strm.next_in = in_off;
  strm.avail_out = out_len;
  strm.output = out;
  strm.next_out = out_off;
  
  switch (this.mode) {
    case exports.DEFLATE:
    case exports.GZIP:
    case exports.DEFLATERAW:
      var status = zlib_deflate.deflate(strm, flush);
      break;
    case exports.UNZIP:
    case exports.INFLATE:
    case exports.GUNZIP:
    case exports.INFLATERAW:
      var status = zlib_inflate.inflate(strm, flush);
      break;
    default:
      throw new Error("Unknown mode " + this.mode);
  }
  
  if (status !== exports.Z_STREAM_END && status !== exports.Z_OK) {
    this._error(status);
  }
  
  this.write_in_progress = false;
  return [strm.avail_in, strm.avail_out];
};

Zlib.prototype.close = function() {
  if (this.write_in_progress) {
    this.pending_close = true;
    return;
  }
  
  this.pending_close = false;
  
  if (this.mode === exports.DEFLATE || this.mode === exports.GZIP || this.mode === exports.DEFLATERAW) {
    zlib_deflate.deflateEnd(this.strm);
  } else {
    zlib_inflate.inflateEnd(this.strm);
  }
  
  this.mode = exports.NONE;
};

Zlib.prototype.reset = function() {
  switch (this.mode) {
    case exports.DEFLATE:
    case exports.DEFLATERAW:
      var status = zlib_deflate.deflateReset(this.strm);
      break;
    case exports.INFLATE:
    case exports.INFLATERAW:
      var status = zlib_inflate.inflateReset(this.strm);
      break;
  }
  
  if (status !== exports.Z_OK) {
    this._error(status);
  }
};

Zlib.prototype._error = function(status) {
  this.onerror(msg[status] + ': ' + this.strm.msg, status);
  
  this.write_in_progress = false;
  if (this.pending_close)
    this.close();
};

exports.Zlib = Zlib;

}).call(this,require("7YKIPe"),require("buffer").Buffer)
},{"7YKIPe":17,"buffer":9,"pako/lib/zlib/constants":94,"pako/lib/zlib/deflate.js":96,"pako/lib/zlib/inflate.js":98,"pako/lib/zlib/messages":100,"pako/lib/zlib/zstream":102}],4:[function(require,module,exports){
(function (process,Buffer){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

var Transform = require('_stream_transform');

var binding = require('./binding');
var util = require('util');
var assert = require('assert').ok;

// zlib doesn't provide these, so kludge them in following the same
// const naming scheme zlib uses.
binding.Z_MIN_WINDOWBITS = 8;
binding.Z_MAX_WINDOWBITS = 15;
binding.Z_DEFAULT_WINDOWBITS = 15;

// fewer than 64 bytes per chunk is stupid.
// technically it could work with as few as 8, but even 64 bytes
// is absurdly low.  Usually a MB or more is best.
binding.Z_MIN_CHUNK = 64;
binding.Z_MAX_CHUNK = Infinity;
binding.Z_DEFAULT_CHUNK = (16 * 1024);

binding.Z_MIN_MEMLEVEL = 1;
binding.Z_MAX_MEMLEVEL = 9;
binding.Z_DEFAULT_MEMLEVEL = 8;

binding.Z_MIN_LEVEL = -1;
binding.Z_MAX_LEVEL = 9;
binding.Z_DEFAULT_LEVEL = binding.Z_DEFAULT_COMPRESSION;

// expose all the zlib constants
Object.keys(binding).forEach(function(k) {
  if (k.match(/^Z/)) exports[k] = binding[k];
});

// translation table for return codes.
exports.codes = {
  Z_OK: binding.Z_OK,
  Z_STREAM_END: binding.Z_STREAM_END,
  Z_NEED_DICT: binding.Z_NEED_DICT,
  Z_ERRNO: binding.Z_ERRNO,
  Z_STREAM_ERROR: binding.Z_STREAM_ERROR,
  Z_DATA_ERROR: binding.Z_DATA_ERROR,
  Z_MEM_ERROR: binding.Z_MEM_ERROR,
  Z_BUF_ERROR: binding.Z_BUF_ERROR,
  Z_VERSION_ERROR: binding.Z_VERSION_ERROR
};

Object.keys(exports.codes).forEach(function(k) {
  exports.codes[exports.codes[k]] = k;
});

exports.Deflate = Deflate;
exports.Inflate = Inflate;
exports.Gzip = Gzip;
exports.Gunzip = Gunzip;
exports.DeflateRaw = DeflateRaw;
exports.InflateRaw = InflateRaw;
exports.Unzip = Unzip;

exports.createDeflate = function(o) {
  return new Deflate(o);
};

exports.createInflate = function(o) {
  return new Inflate(o);
};

exports.createDeflateRaw = function(o) {
  return new DeflateRaw(o);
};

exports.createInflateRaw = function(o) {
  return new InflateRaw(o);
};

exports.createGzip = function(o) {
  return new Gzip(o);
};

exports.createGunzip = function(o) {
  return new Gunzip(o);
};

exports.createUnzip = function(o) {
  return new Unzip(o);
};


// Convenience methods.
// compress/decompress a string or buffer in one step.
exports.deflate = function(buffer, opts, callback) {
  if (typeof opts === 'function') {
    callback = opts;
    opts = {};
  }
  return zlibBuffer(new Deflate(opts), buffer, callback);
};

exports.deflateSync = function(buffer, opts) {
  return zlibBufferSync(new Deflate(opts), buffer);
};

exports.gzip = function(buffer, opts, callback) {
  if (typeof opts === 'function') {
    callback = opts;
    opts = {};
  }
  return zlibBuffer(new Gzip(opts), buffer, callback);
};

exports.gzipSync = function(buffer, opts) {
  return zlibBufferSync(new Gzip(opts), buffer);
};

exports.deflateRaw = function(buffer, opts, callback) {
  if (typeof opts === 'function') {
    callback = opts;
    opts = {};
  }
  return zlibBuffer(new DeflateRaw(opts), buffer, callback);
};

exports.deflateRawSync = function(buffer, opts) {
  return zlibBufferSync(new DeflateRaw(opts), buffer);
};

exports.unzip = function(buffer, opts, callback) {
  if (typeof opts === 'function') {
    callback = opts;
    opts = {};
  }
  return zlibBuffer(new Unzip(opts), buffer, callback);
};

exports.unzipSync = function(buffer, opts) {
  return zlibBufferSync(new Unzip(opts), buffer);
};

exports.inflate = function(buffer, opts, callback) {
  if (typeof opts === 'function') {
    callback = opts;
    opts = {};
  }
  return zlibBuffer(new Inflate(opts), buffer, callback);
};

exports.inflateSync = function(buffer, opts) {
  return zlibBufferSync(new Inflate(opts), buffer);
};

exports.gunzip = function(buffer, opts, callback) {
  if (typeof opts === 'function') {
    callback = opts;
    opts = {};
  }
  return zlibBuffer(new Gunzip(opts), buffer, callback);
};

exports.gunzipSync = function(buffer, opts) {
  return zlibBufferSync(new Gunzip(opts), buffer);
};

exports.inflateRaw = function(buffer, opts, callback) {
  if (typeof opts === 'function') {
    callback = opts;
    opts = {};
  }
  return zlibBuffer(new InflateRaw(opts), buffer, callback);
};

exports.inflateRawSync = function(buffer, opts) {
  return zlibBufferSync(new InflateRaw(opts), buffer);
};

function zlibBuffer(engine, buffer, callback) {
  var buffers = [];
  var nread = 0;

  engine.on('error', onError);
  engine.on('end', onEnd);

  engine.end(buffer);
  flow();

  function flow() {
    var chunk;
    while (null !== (chunk = engine.read())) {
      buffers.push(chunk);
      nread += chunk.length;
    }
    engine.once('readable', flow);
  }

  function onError(err) {
    engine.removeListener('end', onEnd);
    engine.removeListener('readable', flow);
    callback(err);
  }

  function onEnd() {
    var buf = Buffer.concat(buffers, nread);
    buffers = [];
    callback(null, buf);
    engine.close();
  }
}

function zlibBufferSync(engine, buffer) {
  if (typeof buffer === 'string')
    buffer = new Buffer(buffer);
  if (!Buffer.isBuffer(buffer))
    throw new TypeError('Not a string or buffer');

  var flushFlag = binding.Z_FINISH;

  return engine._processChunk(buffer, flushFlag);
}

// generic zlib
// minimal 2-byte header
function Deflate(opts) {
  if (!(this instanceof Deflate)) return new Deflate(opts);
  Zlib.call(this, opts, binding.DEFLATE);
}

function Inflate(opts) {
  if (!(this instanceof Inflate)) return new Inflate(opts);
  Zlib.call(this, opts, binding.INFLATE);
}



// gzip - bigger header, same deflate compression
function Gzip(opts) {
  if (!(this instanceof Gzip)) return new Gzip(opts);
  Zlib.call(this, opts, binding.GZIP);
}

function Gunzip(opts) {
  if (!(this instanceof Gunzip)) return new Gunzip(opts);
  Zlib.call(this, opts, binding.GUNZIP);
}



// raw - no header
function DeflateRaw(opts) {
  if (!(this instanceof DeflateRaw)) return new DeflateRaw(opts);
  Zlib.call(this, opts, binding.DEFLATERAW);
}

function InflateRaw(opts) {
  if (!(this instanceof InflateRaw)) return new InflateRaw(opts);
  Zlib.call(this, opts, binding.INFLATERAW);
}


// auto-detect header.
function Unzip(opts) {
  if (!(this instanceof Unzip)) return new Unzip(opts);
  Zlib.call(this, opts, binding.UNZIP);
}


// the Zlib class they all inherit from
// This thing manages the queue of requests, and returns
// true or false if there is anything in the queue when
// you call the .write() method.

function Zlib(opts, mode) {
  this._opts = opts = opts || {};
  this._chunkSize = opts.chunkSize || exports.Z_DEFAULT_CHUNK;

  Transform.call(this, opts);

  if (opts.flush) {
    if (opts.flush !== binding.Z_NO_FLUSH &&
        opts.flush !== binding.Z_PARTIAL_FLUSH &&
        opts.flush !== binding.Z_SYNC_FLUSH &&
        opts.flush !== binding.Z_FULL_FLUSH &&
        opts.flush !== binding.Z_FINISH &&
        opts.flush !== binding.Z_BLOCK) {
      throw new Error('Invalid flush flag: ' + opts.flush);
    }
  }
  this._flushFlag = opts.flush || binding.Z_NO_FLUSH;

  if (opts.chunkSize) {
    if (opts.chunkSize < exports.Z_MIN_CHUNK ||
        opts.chunkSize > exports.Z_MAX_CHUNK) {
      throw new Error('Invalid chunk size: ' + opts.chunkSize);
    }
  }

  if (opts.windowBits) {
    if (opts.windowBits < exports.Z_MIN_WINDOWBITS ||
        opts.windowBits > exports.Z_MAX_WINDOWBITS) {
      throw new Error('Invalid windowBits: ' + opts.windowBits);
    }
  }

  if (opts.level) {
    if (opts.level < exports.Z_MIN_LEVEL ||
        opts.level > exports.Z_MAX_LEVEL) {
      throw new Error('Invalid compression level: ' + opts.level);
    }
  }

  if (opts.memLevel) {
    if (opts.memLevel < exports.Z_MIN_MEMLEVEL ||
        opts.memLevel > exports.Z_MAX_MEMLEVEL) {
      throw new Error('Invalid memLevel: ' + opts.memLevel);
    }
  }

  if (opts.strategy) {
    if (opts.strategy != exports.Z_FILTERED &&
        opts.strategy != exports.Z_HUFFMAN_ONLY &&
        opts.strategy != exports.Z_RLE &&
        opts.strategy != exports.Z_FIXED &&
        opts.strategy != exports.Z_DEFAULT_STRATEGY) {
      throw new Error('Invalid strategy: ' + opts.strategy);
    }
  }

  if (opts.dictionary) {
    if (!Buffer.isBuffer(opts.dictionary)) {
      throw new Error('Invalid dictionary: it should be a Buffer instance');
    }
  }

  this._binding = new binding.Zlib(mode);

  var self = this;
  this._hadError = false;
  this._binding.onerror = function(message, errno) {
    // there is no way to cleanly recover.
    // continuing only obscures problems.
    self._binding = null;
    self._hadError = true;

    var error = new Error(message);
    error.errno = errno;
    error.code = exports.codes[errno];
    self.emit('error', error);
  };

  var level = exports.Z_DEFAULT_COMPRESSION;
  if (typeof opts.level === 'number') level = opts.level;

  var strategy = exports.Z_DEFAULT_STRATEGY;
  if (typeof opts.strategy === 'number') strategy = opts.strategy;

  this._binding.init(opts.windowBits || exports.Z_DEFAULT_WINDOWBITS,
                     level,
                     opts.memLevel || exports.Z_DEFAULT_MEMLEVEL,
                     strategy,
                     opts.dictionary);

  this._buffer = new Buffer(this._chunkSize);
  this._offset = 0;
  this._closed = false;
  this._level = level;
  this._strategy = strategy;

  this.once('end', this.close);
}

util.inherits(Zlib, Transform);

Zlib.prototype.params = function(level, strategy, callback) {
  if (level < exports.Z_MIN_LEVEL ||
      level > exports.Z_MAX_LEVEL) {
    throw new RangeError('Invalid compression level: ' + level);
  }
  if (strategy != exports.Z_FILTERED &&
      strategy != exports.Z_HUFFMAN_ONLY &&
      strategy != exports.Z_RLE &&
      strategy != exports.Z_FIXED &&
      strategy != exports.Z_DEFAULT_STRATEGY) {
    throw new TypeError('Invalid strategy: ' + strategy);
  }

  if (this._level !== level || this._strategy !== strategy) {
    var self = this;
    this.flush(binding.Z_SYNC_FLUSH, function() {
      self._binding.params(level, strategy);
      if (!self._hadError) {
        self._level = level;
        self._strategy = strategy;
        if (callback) callback();
      }
    });
  } else {
    process.nextTick(callback);
  }
};

Zlib.prototype.reset = function() {
  return this._binding.reset();
};

// This is the _flush function called by the transform class,
// internally, when the last chunk has been written.
Zlib.prototype._flush = function(callback) {
  this._transform(new Buffer(0), '', callback);
};

Zlib.prototype.flush = function(kind, callback) {
  var ws = this._writableState;

  if (typeof kind === 'function' || (kind === void 0 && !callback)) {
    callback = kind;
    kind = binding.Z_FULL_FLUSH;
  }

  if (ws.ended) {
    if (callback)
      process.nextTick(callback);
  } else if (ws.ending) {
    if (callback)
      this.once('end', callback);
  } else if (ws.needDrain) {
    var self = this;
    this.once('drain', function() {
      self.flush(callback);
    });
  } else {
    this._flushFlag = kind;
    this.write(new Buffer(0), '', callback);
  }
};

Zlib.prototype.close = function(callback) {
  if (callback)
    process.nextTick(callback);

  if (this._closed)
    return;

  this._closed = true;

  this._binding.close();

  var self = this;
  process.nextTick(function() {
    self.emit('close');
  });
};

Zlib.prototype._transform = function(chunk, encoding, cb) {
  var flushFlag;
  var ws = this._writableState;
  var ending = ws.ending || ws.ended;
  var last = ending && (!chunk || ws.length === chunk.length);

  if (!chunk === null && !Buffer.isBuffer(chunk))
    return cb(new Error('invalid input'));

  // If it's the last chunk, or a final flush, we use the Z_FINISH flush flag.
  // If it's explicitly flushing at some other time, then we use
  // Z_FULL_FLUSH. Otherwise, use Z_NO_FLUSH for maximum compression
  // goodness.
  if (last)
    flushFlag = binding.Z_FINISH;
  else {
    flushFlag = this._flushFlag;
    // once we've flushed the last of the queue, stop flushing and
    // go back to the normal behavior.
    if (chunk.length >= ws.length) {
      this._flushFlag = this._opts.flush || binding.Z_NO_FLUSH;
    }
  }

  var self = this;
  this._processChunk(chunk, flushFlag, cb);
};

Zlib.prototype._processChunk = function(chunk, flushFlag, cb) {
  var availInBefore = chunk && chunk.length;
  var availOutBefore = this._chunkSize - this._offset;
  var inOff = 0;

  var self = this;

  var async = typeof cb === 'function';

  if (!async) {
    var buffers = [];
    var nread = 0;

    var error;
    this.on('error', function(er) {
      error = er;
    });

    do {
      var res = this._binding.writeSync(flushFlag,
                                        chunk, // in
                                        inOff, // in_off
                                        availInBefore, // in_len
                                        this._buffer, // out
                                        this._offset, //out_off
                                        availOutBefore); // out_len
    } while (!this._hadError && callback(res[0], res[1]));

    if (this._hadError) {
      throw error;
    }

    var buf = Buffer.concat(buffers, nread);
    this.close();

    return buf;
  }

  var req = this._binding.write(flushFlag,
                                chunk, // in
                                inOff, // in_off
                                availInBefore, // in_len
                                this._buffer, // out
                                this._offset, //out_off
                                availOutBefore); // out_len

  req.buffer = chunk;
  req.callback = callback;

  function callback(availInAfter, availOutAfter) {
    if (self._hadError)
      return;

    var have = availOutBefore - availOutAfter;
    assert(have >= 0, 'have should not go down');

    if (have > 0) {
      var out = self._buffer.slice(self._offset, self._offset + have);
      self._offset += have;
      // serve some output to the consumer.
      if (async) {
        self.push(out);
      } else {
        buffers.push(out);
        nread += out.length;
      }
    }

    // exhausted the output buffer, or used all the input create a new one.
    if (availOutAfter === 0 || self._offset >= self._chunkSize) {
      availOutBefore = self._chunkSize;
      self._offset = 0;
      self._buffer = new Buffer(self._chunkSize);
    }

    if (availOutAfter === 0) {
      // Not actually done.  Need to reprocess.
      // Also, update the availInBefore to the availInAfter value,
      // so that if we have to hit it a third (fourth, etc.) time,
      // it'll have the correct byte counts.
      inOff += (availInBefore - availInAfter);
      availInBefore = availInAfter;

      if (!async)
        return true;

      var newReq = self._binding.write(flushFlag,
                                       chunk,
                                       inOff,
                                       availInBefore,
                                       self._buffer,
                                       self._offset,
                                       self._chunkSize);
      newReq.callback = callback; // this same function
      newReq.buffer = chunk;
      return;
    }

    if (!async)
      return false;

    // finished with the chunk.
    cb();
  }
};

util.inherits(Deflate, Zlib);
util.inherits(Inflate, Zlib);
util.inherits(Gzip, Zlib);
util.inherits(Gunzip, Zlib);
util.inherits(DeflateRaw, Zlib);
util.inherits(InflateRaw, Zlib);
util.inherits(Unzip, Zlib);

}).call(this,require("7YKIPe"),require("buffer").Buffer)
},{"./binding":3,"7YKIPe":17,"_stream_transform":27,"assert":5,"buffer":9,"util":104}],5:[function(require,module,exports){
// http://wiki.commonjs.org/wiki/Unit_Testing/1.0
//
// THIS IS NOT TESTED NOR LIKELY TO WORK OUTSIDE V8!
//
// Originally from narwhal.js (http://narwhaljs.org)
// Copyright (c) 2009 Thomas Robinson <280north.com>
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the 'Software'), to
// deal in the Software without restriction, including without limitation the
// rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
// sell copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED 'AS IS', WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
// ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

// when used in node, this will actually load the util module we depend on
// versus loading the builtin util module as happens otherwise
// this is a bug in node module loading as far as I am concerned
var util = require('util/');

var pSlice = Array.prototype.slice;
var hasOwn = Object.prototype.hasOwnProperty;

// 1. The assert module provides functions that throw
// AssertionError's when particular conditions are not met. The
// assert module must conform to the following interface.

var assert = module.exports = ok;

// 2. The AssertionError is defined in assert.
// new assert.AssertionError({ message: message,
//                             actual: actual,
//                             expected: expected })

assert.AssertionError = function AssertionError(options) {
  this.name = 'AssertionError';
  this.actual = options.actual;
  this.expected = options.expected;
  this.operator = options.operator;
  if (options.message) {
    this.message = options.message;
    this.generatedMessage = false;
  } else {
    this.message = getMessage(this);
    this.generatedMessage = true;
  }
  var stackStartFunction = options.stackStartFunction || fail;

  if (Error.captureStackTrace) {
    Error.captureStackTrace(this, stackStartFunction);
  }
  else {
    // non v8 browsers so we can have a stacktrace
    var err = new Error();
    if (err.stack) {
      var out = err.stack;

      // try to strip useless frames
      var fn_name = stackStartFunction.name;
      var idx = out.indexOf('\n' + fn_name);
      if (idx >= 0) {
        // once we have located the function frame
        // we need to strip out everything before it (and its line)
        var next_line = out.indexOf('\n', idx + 1);
        out = out.substring(next_line + 1);
      }

      this.stack = out;
    }
  }
};

// assert.AssertionError instanceof Error
util.inherits(assert.AssertionError, Error);

function replacer(key, value) {
  if (util.isUndefined(value)) {
    return '' + value;
  }
  if (util.isNumber(value) && (isNaN(value) || !isFinite(value))) {
    return value.toString();
  }
  if (util.isFunction(value) || util.isRegExp(value)) {
    return value.toString();
  }
  return value;
}

function truncate(s, n) {
  if (util.isString(s)) {
    return s.length < n ? s : s.slice(0, n);
  } else {
    return s;
  }
}

function getMessage(self) {
  return truncate(JSON.stringify(self.actual, replacer), 128) + ' ' +
         self.operator + ' ' +
         truncate(JSON.stringify(self.expected, replacer), 128);
}

// At present only the three keys mentioned above are used and
// understood by the spec. Implementations or sub modules can pass
// other keys to the AssertionError's constructor - they will be
// ignored.

// 3. All of the following functions must throw an AssertionError
// when a corresponding condition is not met, with a message that
// may be undefined if not provided.  All assertion methods provide
// both the actual and expected values to the assertion error for
// display purposes.

function fail(actual, expected, message, operator, stackStartFunction) {
  throw new assert.AssertionError({
    message: message,
    actual: actual,
    expected: expected,
    operator: operator,
    stackStartFunction: stackStartFunction
  });
}

// EXTENSION! allows for well behaved errors defined elsewhere.
assert.fail = fail;

// 4. Pure assertion tests whether a value is truthy, as determined
// by !!guard.
// assert.ok(guard, message_opt);
// This statement is equivalent to assert.equal(true, !!guard,
// message_opt);. To test strictly for the value true, use
// assert.strictEqual(true, guard, message_opt);.

function ok(value, message) {
  if (!value) fail(value, true, message, '==', assert.ok);
}
assert.ok = ok;

// 5. The equality assertion tests shallow, coercive equality with
// ==.
// assert.equal(actual, expected, message_opt);

assert.equal = function equal(actual, expected, message) {
  if (actual != expected) fail(actual, expected, message, '==', assert.equal);
};

// 6. The non-equality assertion tests for whether two objects are not equal
// with != assert.notEqual(actual, expected, message_opt);

assert.notEqual = function notEqual(actual, expected, message) {
  if (actual == expected) {
    fail(actual, expected, message, '!=', assert.notEqual);
  }
};

// 7. The equivalence assertion tests a deep equality relation.
// assert.deepEqual(actual, expected, message_opt);

assert.deepEqual = function deepEqual(actual, expected, message) {
  if (!_deepEqual(actual, expected)) {
    fail(actual, expected, message, 'deepEqual', assert.deepEqual);
  }
};

function _deepEqual(actual, expected) {
  // 7.1. All identical values are equivalent, as determined by ===.
  if (actual === expected) {
    return true;

  } else if (util.isBuffer(actual) && util.isBuffer(expected)) {
    if (actual.length != expected.length) return false;

    for (var i = 0; i < actual.length; i++) {
      if (actual[i] !== expected[i]) return false;
    }

    return true;

  // 7.2. If the expected value is a Date object, the actual value is
  // equivalent if it is also a Date object that refers to the same time.
  } else if (util.isDate(actual) && util.isDate(expected)) {
    return actual.getTime() === expected.getTime();

  // 7.3 If the expected value is a RegExp object, the actual value is
  // equivalent if it is also a RegExp object with the same source and
  // properties (`global`, `multiline`, `lastIndex`, `ignoreCase`).
  } else if (util.isRegExp(actual) && util.isRegExp(expected)) {
    return actual.source === expected.source &&
           actual.global === expected.global &&
           actual.multiline === expected.multiline &&
           actual.lastIndex === expected.lastIndex &&
           actual.ignoreCase === expected.ignoreCase;

  // 7.4. Other pairs that do not both pass typeof value == 'object',
  // equivalence is determined by ==.
  } else if (!util.isObject(actual) && !util.isObject(expected)) {
    return actual == expected;

  // 7.5 For all other Object pairs, including Array objects, equivalence is
  // determined by having the same number of owned properties (as verified
  // with Object.prototype.hasOwnProperty.call), the same set of keys
  // (although not necessarily the same order), equivalent values for every
  // corresponding key, and an identical 'prototype' property. Note: this
  // accounts for both named and indexed properties on Arrays.
  } else {
    return objEquiv(actual, expected);
  }
}

function isArguments(object) {
  return Object.prototype.toString.call(object) == '[object Arguments]';
}

function objEquiv(a, b) {
  if (util.isNullOrUndefined(a) || util.isNullOrUndefined(b))
    return false;
  // an identical 'prototype' property.
  if (a.prototype !== b.prototype) return false;
  //~~~I've managed to break Object.keys through screwy arguments passing.
  //   Converting to array solves the problem.
  if (isArguments(a)) {
    if (!isArguments(b)) {
      return false;
    }
    a = pSlice.call(a);
    b = pSlice.call(b);
    return _deepEqual(a, b);
  }
  try {
    var ka = objectKeys(a),
        kb = objectKeys(b),
        key, i;
  } catch (e) {//happens when one is a string literal and the other isn't
    return false;
  }
  // having the same number of owned properties (keys incorporates
  // hasOwnProperty)
  if (ka.length != kb.length)
    return false;
  //the same set of keys (although not necessarily the same order),
  ka.sort();
  kb.sort();
  //~~~cheap key test
  for (i = ka.length - 1; i >= 0; i--) {
    if (ka[i] != kb[i])
      return false;
  }
  //equivalent values for every corresponding key, and
  //~~~possibly expensive deep test
  for (i = ka.length - 1; i >= 0; i--) {
    key = ka[i];
    if (!_deepEqual(a[key], b[key])) return false;
  }
  return true;
}

// 8. The non-equivalence assertion tests for any deep inequality.
// assert.notDeepEqual(actual, expected, message_opt);

assert.notDeepEqual = function notDeepEqual(actual, expected, message) {
  if (_deepEqual(actual, expected)) {
    fail(actual, expected, message, 'notDeepEqual', assert.notDeepEqual);
  }
};

// 9. The strict equality assertion tests strict equality, as determined by ===.
// assert.strictEqual(actual, expected, message_opt);

assert.strictEqual = function strictEqual(actual, expected, message) {
  if (actual !== expected) {
    fail(actual, expected, message, '===', assert.strictEqual);
  }
};

// 10. The strict non-equality assertion tests for strict inequality, as
// determined by !==.  assert.notStrictEqual(actual, expected, message_opt);

assert.notStrictEqual = function notStrictEqual(actual, expected, message) {
  if (actual === expected) {
    fail(actual, expected, message, '!==', assert.notStrictEqual);
  }
};

function expectedException(actual, expected) {
  if (!actual || !expected) {
    return false;
  }

  if (Object.prototype.toString.call(expected) == '[object RegExp]') {
    return expected.test(actual);
  } else if (actual instanceof expected) {
    return true;
  } else if (expected.call({}, actual) === true) {
    return true;
  }

  return false;
}

function _throws(shouldThrow, block, expected, message) {
  var actual;

  if (util.isString(expected)) {
    message = expected;
    expected = null;
  }

  try {
    block();
  } catch (e) {
    actual = e;
  }

  message = (expected && expected.name ? ' (' + expected.name + ').' : '.') +
            (message ? ' ' + message : '.');

  if (shouldThrow && !actual) {
    fail(actual, expected, 'Missing expected exception' + message);
  }

  if (!shouldThrow && expectedException(actual, expected)) {
    fail(actual, expected, 'Got unwanted exception' + message);
  }

  if ((shouldThrow && actual && expected &&
      !expectedException(actual, expected)) || (!shouldThrow && actual)) {
    throw actual;
  }
}

// 11. Expected to throw an error:
// assert.throws(block, Error_opt, message_opt);

assert.throws = function(block, /*optional*/error, /*optional*/message) {
  _throws.apply(this, [true].concat(pSlice.call(arguments)));
};

// EXTENSION! This is annoying to write outside this module.
assert.doesNotThrow = function(block, /*optional*/message) {
  _throws.apply(this, [false].concat(pSlice.call(arguments)));
};

assert.ifError = function(err) { if (err) {throw err;}};

var objectKeys = Object.keys || function (obj) {
  var keys = [];
  for (var key in obj) {
    if (hasOwn.call(obj, key)) keys.push(key);
  }
  return keys;
};

},{"util/":104}],6:[function(require,module,exports){
var lookup = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';

;(function (exports) {
	'use strict';

  var Arr = (typeof Uint8Array !== 'undefined')
    ? Uint8Array
    : Array

	var PLUS   = '+'.charCodeAt(0)
	var SLASH  = '/'.charCodeAt(0)
	var NUMBER = '0'.charCodeAt(0)
	var LOWER  = 'a'.charCodeAt(0)
	var UPPER  = 'A'.charCodeAt(0)
	var PLUS_URL_SAFE = '-'.charCodeAt(0)
	var SLASH_URL_SAFE = '_'.charCodeAt(0)

	function decode (elt) {
		var code = elt.charCodeAt(0)
		if (code === PLUS ||
		    code === PLUS_URL_SAFE)
			return 62 // '+'
		if (code === SLASH ||
		    code === SLASH_URL_SAFE)
			return 63 // '/'
		if (code < NUMBER)
			return -1 //no match
		if (code < NUMBER + 10)
			return code - NUMBER + 26 + 26
		if (code < UPPER + 26)
			return code - UPPER
		if (code < LOWER + 26)
			return code - LOWER + 26
	}

	function b64ToByteArray (b64) {
		var i, j, l, tmp, placeHolders, arr

		if (b64.length % 4 > 0) {
			throw new Error('Invalid string. Length must be a multiple of 4')
		}

		// the number of equal signs (place holders)
		// if there are two placeholders, than the two characters before it
		// represent one byte
		// if there is only one, then the three characters before it represent 2 bytes
		// this is just a cheap hack to not do indexOf twice
		var len = b64.length
		placeHolders = '=' === b64.charAt(len - 2) ? 2 : '=' === b64.charAt(len - 1) ? 1 : 0

		// base64 is 4/3 + up to two characters of the original data
		arr = new Arr(b64.length * 3 / 4 - placeHolders)

		// if there are placeholders, only get up to the last complete 4 chars
		l = placeHolders > 0 ? b64.length - 4 : b64.length

		var L = 0

		function push (v) {
			arr[L++] = v
		}

		for (i = 0, j = 0; i < l; i += 4, j += 3) {
			tmp = (decode(b64.charAt(i)) << 18) | (decode(b64.charAt(i + 1)) << 12) | (decode(b64.charAt(i + 2)) << 6) | decode(b64.charAt(i + 3))
			push((tmp & 0xFF0000) >> 16)
			push((tmp & 0xFF00) >> 8)
			push(tmp & 0xFF)
		}

		if (placeHolders === 2) {
			tmp = (decode(b64.charAt(i)) << 2) | (decode(b64.charAt(i + 1)) >> 4)
			push(tmp & 0xFF)
		} else if (placeHolders === 1) {
			tmp = (decode(b64.charAt(i)) << 10) | (decode(b64.charAt(i + 1)) << 4) | (decode(b64.charAt(i + 2)) >> 2)
			push((tmp >> 8) & 0xFF)
			push(tmp & 0xFF)
		}

		return arr
	}

	function uint8ToBase64 (uint8) {
		var i,
			extraBytes = uint8.length % 3, // if we have 1 byte left, pad 2 bytes
			output = "",
			temp, length

		function encode (num) {
			return lookup.charAt(num)
		}

		function tripletToBase64 (num) {
			return encode(num >> 18 & 0x3F) + encode(num >> 12 & 0x3F) + encode(num >> 6 & 0x3F) + encode(num & 0x3F)
		}

		// go through the array every three bytes, we'll deal with trailing stuff later
		for (i = 0, length = uint8.length - extraBytes; i < length; i += 3) {
			temp = (uint8[i] << 16) + (uint8[i + 1] << 8) + (uint8[i + 2])
			output += tripletToBase64(temp)
		}

		// pad the end with zeros, but make sure to not forget the extra bytes
		switch (extraBytes) {
			case 1:
				temp = uint8[uint8.length - 1]
				output += encode(temp >> 2)
				output += encode((temp << 4) & 0x3F)
				output += '=='
				break
			case 2:
				temp = (uint8[uint8.length - 2] << 8) + (uint8[uint8.length - 1])
				output += encode(temp >> 10)
				output += encode((temp >> 4) & 0x3F)
				output += encode((temp << 2) & 0x3F)
				output += '='
				break
		}

		return output
	}

	exports.toByteArray = b64ToByteArray
	exports.fromByteArray = uint8ToBase64
}(typeof exports === 'undefined' ? (this.base64js = {}) : exports))

},{}],7:[function(require,module,exports){

},{}],8:[function(require,module,exports){
module.exports=require(7)
},{}],9:[function(require,module,exports){
/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>
 * @license  MIT
 */

var base64 = require('base64-js')
var ieee754 = require('ieee754')

exports.Buffer = Buffer
exports.SlowBuffer = Buffer
exports.INSPECT_MAX_BYTES = 50
Buffer.poolSize = 8192

/**
 * If `Buffer._useTypedArrays`:
 *   === true    Use Uint8Array implementation (fastest)
 *   === false   Use Object implementation (compatible down to IE6)
 */
Buffer._useTypedArrays = (function () {
  // Detect if browser supports Typed Arrays. Supported browsers are IE 10+, Firefox 4+,
  // Chrome 7+, Safari 5.1+, Opera 11.6+, iOS 4.2+. If the browser does not support adding
  // properties to `Uint8Array` instances, then that's the same as no `Uint8Array` support
  // because we need to be able to add all the node Buffer API methods. This is an issue
  // in Firefox 4-29. Now fixed: https://bugzilla.mozilla.org/show_bug.cgi?id=695438
  try {
    var buf = new ArrayBuffer(0)
    var arr = new Uint8Array(buf)
    arr.foo = function () { return 42 }
    return 42 === arr.foo() &&
        typeof arr.subarray === 'function' // Chrome 9-10 lack `subarray`
  } catch (e) {
    return false
  }
})()

/**
 * Class: Buffer
 * =============
 *
 * The Buffer constructor returns instances of `Uint8Array` that are augmented
 * with function properties for all the node `Buffer` API functions. We use
 * `Uint8Array` so that square bracket notation works as expected -- it returns
 * a single octet.
 *
 * By augmenting the instances, we can avoid modifying the `Uint8Array`
 * prototype.
 */
function Buffer (subject, encoding, noZero) {
  if (!(this instanceof Buffer))
    return new Buffer(subject, encoding, noZero)

  var type = typeof subject

  // Workaround: node's base64 implementation allows for non-padded strings
  // while base64-js does not.
  if (encoding === 'base64' && type === 'string') {
    subject = stringtrim(subject)
    while (subject.length % 4 !== 0) {
      subject = subject + '='
    }
  }

  // Find the length
  var length
  if (type === 'number')
    length = coerce(subject)
  else if (type === 'string')
    length = Buffer.byteLength(subject, encoding)
  else if (type === 'object')
    length = coerce(subject.length) // assume that object is array-like
  else
    throw new Error('First argument needs to be a number, array or string.')

  var buf
  if (Buffer._useTypedArrays) {
    // Preferred: Return an augmented `Uint8Array` instance for best performance
    buf = Buffer._augment(new Uint8Array(length))
  } else {
    // Fallback: Return THIS instance of Buffer (created by `new`)
    buf = this
    buf.length = length
    buf._isBuffer = true
  }

  var i
  if (Buffer._useTypedArrays && typeof subject.byteLength === 'number') {
    // Speed optimization -- use set if we're copying from a typed array
    buf._set(subject)
  } else if (isArrayish(subject)) {
    // Treat array-ish objects as a byte array
    for (i = 0; i < length; i++) {
      if (Buffer.isBuffer(subject))
        buf[i] = subject.readUInt8(i)
      else
        buf[i] = subject[i]
    }
  } else if (type === 'string') {
    buf.write(subject, 0, encoding)
  } else if (type === 'number' && !Buffer._useTypedArrays && !noZero) {
    for (i = 0; i < length; i++) {
      buf[i] = 0
    }
  }

  return buf
}

// STATIC METHODS
// ==============

Buffer.isEncoding = function (encoding) {
  switch (String(encoding).toLowerCase()) {
    case 'hex':
    case 'utf8':
    case 'utf-8':
    case 'ascii':
    case 'binary':
    case 'base64':
    case 'raw':
    case 'ucs2':
    case 'ucs-2':
    case 'utf16le':
    case 'utf-16le':
      return true
    default:
      return false
  }
}

Buffer.isBuffer = function (b) {
  return !!(b !== null && b !== undefined && b._isBuffer)
}

Buffer.byteLength = function (str, encoding) {
  var ret
  str = str + ''
  switch (encoding || 'utf8') {
    case 'hex':
      ret = str.length / 2
      break
    case 'utf8':
    case 'utf-8':
      ret = utf8ToBytes(str).length
      break
    case 'ascii':
    case 'binary':
    case 'raw':
      ret = str.length
      break
    case 'base64':
      ret = base64ToBytes(str).length
      break
    case 'ucs2':
    case 'ucs-2':
    case 'utf16le':
    case 'utf-16le':
      ret = str.length * 2
      break
    default:
      throw new Error('Unknown encoding')
  }
  return ret
}

Buffer.concat = function (list, totalLength) {
  assert(isArray(list), 'Usage: Buffer.concat(list, [totalLength])\n' +
      'list should be an Array.')

  if (list.length === 0) {
    return new Buffer(0)
  } else if (list.length === 1) {
    return list[0]
  }

  var i
  if (typeof totalLength !== 'number') {
    totalLength = 0
    for (i = 0; i < list.length; i++) {
      totalLength += list[i].length
    }
  }

  var buf = new Buffer(totalLength)
  var pos = 0
  for (i = 0; i < list.length; i++) {
    var item = list[i]
    item.copy(buf, pos)
    pos += item.length
  }
  return buf
}

// BUFFER INSTANCE METHODS
// =======================

function _hexWrite (buf, string, offset, length) {
  offset = Number(offset) || 0
  var remaining = buf.length - offset
  if (!length) {
    length = remaining
  } else {
    length = Number(length)
    if (length > remaining) {
      length = remaining
    }
  }

  // must be an even number of digits
  var strLen = string.length
  assert(strLen % 2 === 0, 'Invalid hex string')

  if (length > strLen / 2) {
    length = strLen / 2
  }
  for (var i = 0; i < length; i++) {
    var byte = parseInt(string.substr(i * 2, 2), 16)
    assert(!isNaN(byte), 'Invalid hex string')
    buf[offset + i] = byte
  }
  Buffer._charsWritten = i * 2
  return i
}

function _utf8Write (buf, string, offset, length) {
  var charsWritten = Buffer._charsWritten =
    blitBuffer(utf8ToBytes(string), buf, offset, length)
  return charsWritten
}

function _asciiWrite (buf, string, offset, length) {
  var charsWritten = Buffer._charsWritten =
    blitBuffer(asciiToBytes(string), buf, offset, length)
  return charsWritten
}

function _binaryWrite (buf, string, offset, length) {
  return _asciiWrite(buf, string, offset, length)
}

function _base64Write (buf, string, offset, length) {
  var charsWritten = Buffer._charsWritten =
    blitBuffer(base64ToBytes(string), buf, offset, length)
  return charsWritten
}

function _utf16leWrite (buf, string, offset, length) {
  var charsWritten = Buffer._charsWritten =
    blitBuffer(utf16leToBytes(string), buf, offset, length)
  return charsWritten
}

Buffer.prototype.write = function (string, offset, length, encoding) {
  // Support both (string, offset, length, encoding)
  // and the legacy (string, encoding, offset, length)
  if (isFinite(offset)) {
    if (!isFinite(length)) {
      encoding = length
      length = undefined
    }
  } else {  // legacy
    var swap = encoding
    encoding = offset
    offset = length
    length = swap
  }

  offset = Number(offset) || 0
  var remaining = this.length - offset
  if (!length) {
    length = remaining
  } else {
    length = Number(length)
    if (length > remaining) {
      length = remaining
    }
  }
  encoding = String(encoding || 'utf8').toLowerCase()

  var ret
  switch (encoding) {
    case 'hex':
      ret = _hexWrite(this, string, offset, length)
      break
    case 'utf8':
    case 'utf-8':
      ret = _utf8Write(this, string, offset, length)
      break
    case 'ascii':
      ret = _asciiWrite(this, string, offset, length)
      break
    case 'binary':
      ret = _binaryWrite(this, string, offset, length)
      break
    case 'base64':
      ret = _base64Write(this, string, offset, length)
      break
    case 'ucs2':
    case 'ucs-2':
    case 'utf16le':
    case 'utf-16le':
      ret = _utf16leWrite(this, string, offset, length)
      break
    default:
      throw new Error('Unknown encoding')
  }
  return ret
}

Buffer.prototype.toString = function (encoding, start, end) {
  var self = this

  encoding = String(encoding || 'utf8').toLowerCase()
  start = Number(start) || 0
  end = (end !== undefined)
    ? Number(end)
    : end = self.length

  // Fastpath empty strings
  if (end === start)
    return ''

  var ret
  switch (encoding) {
    case 'hex':
      ret = _hexSlice(self, start, end)
      break
    case 'utf8':
    case 'utf-8':
      ret = _utf8Slice(self, start, end)
      break
    case 'ascii':
      ret = _asciiSlice(self, start, end)
      break
    case 'binary':
      ret = _binarySlice(self, start, end)
      break
    case 'base64':
      ret = _base64Slice(self, start, end)
      break
    case 'ucs2':
    case 'ucs-2':
    case 'utf16le':
    case 'utf-16le':
      ret = _utf16leSlice(self, start, end)
      break
    default:
      throw new Error('Unknown encoding')
  }
  return ret
}

Buffer.prototype.toJSON = function () {
  return {
    type: 'Buffer',
    data: Array.prototype.slice.call(this._arr || this, 0)
  }
}

// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)
Buffer.prototype.copy = function (target, target_start, start, end) {
  var source = this

  if (!start) start = 0
  if (!end && end !== 0) end = this.length
  if (!target_start) target_start = 0

  // Copy 0 bytes; we're done
  if (end === start) return
  if (target.length === 0 || source.length === 0) return

  // Fatal error conditions
  assert(end >= start, 'sourceEnd < sourceStart')
  assert(target_start >= 0 && target_start < target.length,
      'targetStart out of bounds')
  assert(start >= 0 && start < source.length, 'sourceStart out of bounds')
  assert(end >= 0 && end <= source.length, 'sourceEnd out of bounds')

  // Are we oob?
  if (end > this.length)
    end = this.length
  if (target.length - target_start < end - start)
    end = target.length - target_start + start

  var len = end - start

  if (len < 100 || !Buffer._useTypedArrays) {
    for (var i = 0; i < len; i++)
      target[i + target_start] = this[i + start]
  } else {
    target._set(this.subarray(start, start + len), target_start)
  }
}

function _base64Slice (buf, start, end) {
  if (start === 0 && end === buf.length) {
    return base64.fromByteArray(buf)
  } else {
    return base64.fromByteArray(buf.slice(start, end))
  }
}

function _utf8Slice (buf, start, end) {
  var res = ''
  var tmp = ''
  end = Math.min(buf.length, end)

  for (var i = start; i < end; i++) {
    if (buf[i] <= 0x7F) {
      res += decodeUtf8Char(tmp) + String.fromCharCode(buf[i])
      tmp = ''
    } else {
      tmp += '%' + buf[i].toString(16)
    }
  }

  return res + decodeUtf8Char(tmp)
}

function _asciiSlice (buf, start, end) {
  var ret = ''
  end = Math.min(buf.length, end)

  for (var i = start; i < end; i++)
    ret += String.fromCharCode(buf[i])
  return ret
}

function _binarySlice (buf, start, end) {
  return _asciiSlice(buf, start, end)
}

function _hexSlice (buf, start, end) {
  var len = buf.length

  if (!start || start < 0) start = 0
  if (!end || end < 0 || end > len) end = len

  var out = ''
  for (var i = start; i < end; i++) {
    out += toHex(buf[i])
  }
  return out
}

function _utf16leSlice (buf, start, end) {
  var bytes = buf.slice(start, end)
  var res = ''
  for (var i = 0; i < bytes.length; i += 2) {
    res += String.fromCharCode(bytes[i] + bytes[i+1] * 256)
  }
  return res
}

Buffer.prototype.slice = function (start, end) {
  var len = this.length
  start = clamp(start, len, 0)
  end = clamp(end, len, len)

  if (Buffer._useTypedArrays) {
    return Buffer._augment(this.subarray(start, end))
  } else {
    var sliceLen = end - start
    var newBuf = new Buffer(sliceLen, undefined, true)
    for (var i = 0; i < sliceLen; i++) {
      newBuf[i] = this[i + start]
    }
    return newBuf
  }
}

// `get` will be removed in Node 0.13+
Buffer.prototype.get = function (offset) {
  console.log('.get() is deprecated. Access using array indexes instead.')
  return this.readUInt8(offset)
}

// `set` will be removed in Node 0.13+
Buffer.prototype.set = function (v, offset) {
  console.log('.set() is deprecated. Access using array indexes instead.')
  return this.writeUInt8(v, offset)
}

Buffer.prototype.readUInt8 = function (offset, noAssert) {
  if (!noAssert) {
    assert(offset !== undefined && offset !== null, 'missing offset')
    assert(offset < this.length, 'Trying to read beyond buffer length')
  }

  if (offset >= this.length)
    return

  return this[offset]
}

function _readUInt16 (buf, offset, littleEndian, noAssert) {
  if (!noAssert) {
    assert(typeof littleEndian === 'boolean', 'missing or invalid endian')
    assert(offset !== undefined && offset !== null, 'missing offset')
    assert(offset + 1 < buf.length, 'Trying to read beyond buffer length')
  }

  var len = buf.length
  if (offset >= len)
    return

  var val
  if (littleEndian) {
    val = buf[offset]
    if (offset + 1 < len)
      val |= buf[offset + 1] << 8
  } else {
    val = buf[offset] << 8
    if (offset + 1 < len)
      val |= buf[offset + 1]
  }
  return val
}

Buffer.prototype.readUInt16LE = function (offset, noAssert) {
  return _readUInt16(this, offset, true, noAssert)
}

Buffer.prototype.readUInt16BE = function (offset, noAssert) {
  return _readUInt16(this, offset, false, noAssert)
}

function _readUInt32 (buf, offset, littleEndian, noAssert) {
  if (!noAssert) {
    assert(typeof littleEndian === 'boolean', 'missing or invalid endian')
    assert(offset !== undefined && offset !== null, 'missing offset')
    assert(offset + 3 < buf.length, 'Trying to read beyond buffer length')
  }

  var len = buf.length
  if (offset >= len)
    return

  var val
  if (littleEndian) {
    if (offset + 2 < len)
      val = buf[offset + 2] << 16
    if (offset + 1 < len)
      val |= buf[offset + 1] << 8
    val |= buf[offset]
    if (offset + 3 < len)
      val = val + (buf[offset + 3] << 24 >>> 0)
  } else {
    if (offset + 1 < len)
      val = buf[offset + 1] << 16
    if (offset + 2 < len)
      val |= buf[offset + 2] << 8
    if (offset + 3 < len)
      val |= buf[offset + 3]
    val = val + (buf[offset] << 24 >>> 0)
  }
  return val
}

Buffer.prototype.readUInt32LE = function (offset, noAssert) {
  return _readUInt32(this, offset, true, noAssert)
}

Buffer.prototype.readUInt32BE = function (offset, noAssert) {
  return _readUInt32(this, offset, false, noAssert)
}

Buffer.prototype.readInt8 = function (offset, noAssert) {
  if (!noAssert) {
    assert(offset !== undefined && offset !== null,
        'missing offset')
    assert(offset < this.length, 'Trying to read beyond buffer length')
  }

  if (offset >= this.length)
    return

  var neg = this[offset] & 0x80
  if (neg)
    return (0xff - this[offset] + 1) * -1
  else
    return this[offset]
}

function _readInt16 (buf, offset, littleEndian, noAssert) {
  if (!noAssert) {
    assert(typeof littleEndian === 'boolean', 'missing or invalid endian')
    assert(offset !== undefined && offset !== null, 'missing offset')
    assert(offset + 1 < buf.length, 'Trying to read beyond buffer length')
  }

  var len = buf.length
  if (offset >= len)
    return

  var val = _readUInt16(buf, offset, littleEndian, true)
  var neg = val & 0x8000
  if (neg)
    return (0xffff - val + 1) * -1
  else
    return val
}

Buffer.prototype.readInt16LE = function (offset, noAssert) {
  return _readInt16(this, offset, true, noAssert)
}

Buffer.prototype.readInt16BE = function (offset, noAssert) {
  return _readInt16(this, offset, false, noAssert)
}

function _readInt32 (buf, offset, littleEndian, noAssert) {
  if (!noAssert) {
    assert(typeof littleEndian === 'boolean', 'missing or invalid endian')
    assert(offset !== undefined && offset !== null, 'missing offset')
    assert(offset + 3 < buf.length, 'Trying to read beyond buffer length')
  }

  var len = buf.length
  if (offset >= len)
    return

  var val = _readUInt32(buf, offset, littleEndian, true)
  var neg = val & 0x80000000
  if (neg)
    return (0xffffffff - val + 1) * -1
  else
    return val
}

Buffer.prototype.readInt32LE = function (offset, noAssert) {
  return _readInt32(this, offset, true, noAssert)
}

Buffer.prototype.readInt32BE = function (offset, noAssert) {
  return _readInt32(this, offset, false, noAssert)
}

function _readFloat (buf, offset, littleEndian, noAssert) {
  if (!noAssert) {
    assert(typeof littleEndian === 'boolean', 'missing or invalid endian')
    assert(offset + 3 < buf.length, 'Trying to read beyond buffer length')
  }

  return ieee754.read(buf, offset, littleEndian, 23, 4)
}

Buffer.prototype.readFloatLE = function (offset, noAssert) {
  return _readFloat(this, offset, true, noAssert)
}

Buffer.prototype.readFloatBE = function (offset, noAssert) {
  return _readFloat(this, offset, false, noAssert)
}

function _readDouble (buf, offset, littleEndian, noAssert) {
  if (!noAssert) {
    assert(typeof littleEndian === 'boolean', 'missing or invalid endian')
    assert(offset + 7 < buf.length, 'Trying to read beyond buffer length')
  }

  return ieee754.read(buf, offset, littleEndian, 52, 8)
}

Buffer.prototype.readDoubleLE = function (offset, noAssert) {
  return _readDouble(this, offset, true, noAssert)
}

Buffer.prototype.readDoubleBE = function (offset, noAssert) {
  return _readDouble(this, offset, false, noAssert)
}

Buffer.prototype.writeUInt8 = function (value, offset, noAssert) {
  if (!noAssert) {
    assert(value !== undefined && value !== null, 'missing value')
    assert(offset !== undefined && offset !== null, 'missing offset')
    assert(offset < this.length, 'trying to write beyond buffer length')
    verifuint(value, 0xff)
  }

  if (offset >= this.length) return

  this[offset] = value
}

function _writeUInt16 (buf, value, offset, littleEndian, noAssert) {
  if (!noAssert) {
    assert(value !== undefined && value !== null, 'missing value')
    assert(typeof littleEndian === 'boolean', 'missing or invalid endian')
    assert(offset !== undefined && offset !== null, 'missing offset')
    assert(offset + 1 < buf.length, 'trying to write beyond buffer length')
    verifuint(value, 0xffff)
  }

  var len = buf.length
  if (offset >= len)
    return

  for (var i = 0, j = Math.min(len - offset, 2); i < j; i++) {
    buf[offset + i] =
        (value & (0xff << (8 * (littleEndian ? i : 1 - i)))) >>>
            (littleEndian ? i : 1 - i) * 8
  }
}

Buffer.prototype.writeUInt16LE = function (value, offset, noAssert) {
  _writeUInt16(this, value, offset, true, noAssert)
}

Buffer.prototype.writeUInt16BE = function (value, offset, noAssert) {
  _writeUInt16(this, value, offset, false, noAssert)
}

function _writeUInt32 (buf, value, offset, littleEndian, noAssert) {
  if (!noAssert) {
    assert(value !== undefined && value !== null, 'missing value')
    assert(typeof littleEndian === 'boolean', 'missing or invalid endian')
    assert(offset !== undefined && offset !== null, 'missing offset')
    assert(offset + 3 < buf.length, 'trying to write beyond buffer length')
    verifuint(value, 0xffffffff)
  }

  var len = buf.length
  if (offset >= len)
    return

  for (var i = 0, j = Math.min(len - offset, 4); i < j; i++) {
    buf[offset + i] =
        (value >>> (littleEndian ? i : 3 - i) * 8) & 0xff
  }
}

Buffer.prototype.writeUInt32LE = function (value, offset, noAssert) {
  _writeUInt32(this, value, offset, true, noAssert)
}

Buffer.prototype.writeUInt32BE = function (value, offset, noAssert) {
  _writeUInt32(this, value, offset, false, noAssert)
}

Buffer.prototype.writeInt8 = function (value, offset, noAssert) {
  if (!noAssert) {
    assert(value !== undefined && value !== null, 'missing value')
    assert(offset !== undefined && offset !== null, 'missing offset')
    assert(offset < this.length, 'Trying to write beyond buffer length')
    verifsint(value, 0x7f, -0x80)
  }

  if (offset >= this.length)
    return

  if (value >= 0)
    this.writeUInt8(value, offset, noAssert)
  else
    this.writeUInt8(0xff + value + 1, offset, noAssert)
}

function _writeInt16 (buf, value, offset, littleEndian, noAssert) {
  if (!noAssert) {
    assert(value !== undefined && value !== null, 'missing value')
    assert(typeof littleEndian === 'boolean', 'missing or invalid endian')
    assert(offset !== undefined && offset !== null, 'missing offset')
    assert(offset + 1 < buf.length, 'Trying to write beyond buffer length')
    verifsint(value, 0x7fff, -0x8000)
  }

  var len = buf.length
  if (offset >= len)
    return

  if (value >= 0)
    _writeUInt16(buf, value, offset, littleEndian, noAssert)
  else
    _writeUInt16(buf, 0xffff + value + 1, offset, littleEndian, noAssert)
}

Buffer.prototype.writeInt16LE = function (value, offset, noAssert) {
  _writeInt16(this, value, offset, true, noAssert)
}

Buffer.prototype.writeInt16BE = function (value, offset, noAssert) {
  _writeInt16(this, value, offset, false, noAssert)
}

function _writeInt32 (buf, value, offset, littleEndian, noAssert) {
  if (!noAssert) {
    assert(value !== undefined && value !== null, 'missing value')
    assert(typeof littleEndian === 'boolean', 'missing or invalid endian')
    assert(offset !== undefined && offset !== null, 'missing offset')
    assert(offset + 3 < buf.length, 'Trying to write beyond buffer length')
    verifsint(value, 0x7fffffff, -0x80000000)
  }

  var len = buf.length
  if (offset >= len)
    return

  if (value >= 0)
    _writeUInt32(buf, value, offset, littleEndian, noAssert)
  else
    _writeUInt32(buf, 0xffffffff + value + 1, offset, littleEndian, noAssert)
}

Buffer.prototype.writeInt32LE = function (value, offset, noAssert) {
  _writeInt32(this, value, offset, true, noAssert)
}

Buffer.prototype.writeInt32BE = function (value, offset, noAssert) {
  _writeInt32(this, value, offset, false, noAssert)
}

function _writeFloat (buf, value, offset, littleEndian, noAssert) {
  if (!noAssert) {
    assert(value !== undefined && value !== null, 'missing value')
    assert(typeof littleEndian === 'boolean', 'missing or invalid endian')
    assert(offset !== undefined && offset !== null, 'missing offset')
    assert(offset + 3 < buf.length, 'Trying to write beyond buffer length')
    verifIEEE754(value, 3.4028234663852886e+38, -3.4028234663852886e+38)
  }

  var len = buf.length
  if (offset >= len)
    return

  ieee754.write(buf, value, offset, littleEndian, 23, 4)
}

Buffer.prototype.writeFloatLE = function (value, offset, noAssert) {
  _writeFloat(this, value, offset, true, noAssert)
}

Buffer.prototype.writeFloatBE = function (value, offset, noAssert) {
  _writeFloat(this, value, offset, false, noAssert)
}

function _writeDouble (buf, value, offset, littleEndian, noAssert) {
  if (!noAssert) {
    assert(value !== undefined && value !== null, 'missing value')
    assert(typeof littleEndian === 'boolean', 'missing or invalid endian')
    assert(offset !== undefined && offset !== null, 'missing offset')
    assert(offset + 7 < buf.length,
        'Trying to write beyond buffer length')
    verifIEEE754(value, 1.7976931348623157E+308, -1.7976931348623157E+308)
  }

  var len = buf.length
  if (offset >= len)
    return

  ieee754.write(buf, value, offset, littleEndian, 52, 8)
}

Buffer.prototype.writeDoubleLE = function (value, offset, noAssert) {
  _writeDouble(this, value, offset, true, noAssert)
}

Buffer.prototype.writeDoubleBE = function (value, offset, noAssert) {
  _writeDouble(this, value, offset, false, noAssert)
}

// fill(value, start=0, end=buffer.length)
Buffer.prototype.fill = function (value, start, end) {
  if (!value) value = 0
  if (!start) start = 0
  if (!end) end = this.length

  if (typeof value === 'string') {
    value = value.charCodeAt(0)
  }

  assert(typeof value === 'number' && !isNaN(value), 'value is not a number')
  assert(end >= start, 'end < start')

  // Fill 0 bytes; we're done
  if (end === start) return
  if (this.length === 0) return

  assert(start >= 0 && start < this.length, 'start out of bounds')
  assert(end >= 0 && end <= this.length, 'end out of bounds')

  for (var i = start; i < end; i++) {
    this[i] = value
  }
}

Buffer.prototype.inspect = function () {
  var out = []
  var len = this.length
  for (var i = 0; i < len; i++) {
    out[i] = toHex(this[i])
    if (i === exports.INSPECT_MAX_BYTES) {
      out[i + 1] = '...'
      break
    }
  }
  return '<Buffer ' + out.join(' ') + '>'
}

/**
 * Creates a new `ArrayBuffer` with the *copied* memory of the buffer instance.
 * Added in Node 0.12. Only available in browsers that support ArrayBuffer.
 */
Buffer.prototype.toArrayBuffer = function () {
  if (typeof Uint8Array !== 'undefined') {
    if (Buffer._useTypedArrays) {
      return (new Buffer(this)).buffer
    } else {
      var buf = new Uint8Array(this.length)
      for (var i = 0, len = buf.length; i < len; i += 1)
        buf[i] = this[i]
      return buf.buffer
    }
  } else {
    throw new Error('Buffer.toArrayBuffer not supported in this browser')
  }
}

// HELPER FUNCTIONS
// ================

function stringtrim (str) {
  if (str.trim) return str.trim()
  return str.replace(/^\s+|\s+$/g, '')
}

var BP = Buffer.prototype

/**
 * Augment a Uint8Array *instance* (not the Uint8Array class!) with Buffer methods
 */
Buffer._augment = function (arr) {
  arr._isBuffer = true

  // save reference to original Uint8Array get/set methods before overwriting
  arr._get = arr.get
  arr._set = arr.set

  // deprecated, will be removed in node 0.13+
  arr.get = BP.get
  arr.set = BP.set

  arr.write = BP.write
  arr.toString = BP.toString
  arr.toLocaleString = BP.toString
  arr.toJSON = BP.toJSON
  arr.copy = BP.copy
  arr.slice = BP.slice
  arr.readUInt8 = BP.readUInt8
  arr.readUInt16LE = BP.readUInt16LE
  arr.readUInt16BE = BP.readUInt16BE
  arr.readUInt32LE = BP.readUInt32LE
  arr.readUInt32BE = BP.readUInt32BE
  arr.readInt8 = BP.readInt8
  arr.readInt16LE = BP.readInt16LE
  arr.readInt16BE = BP.readInt16BE
  arr.readInt32LE = BP.readInt32LE
  arr.readInt32BE = BP.readInt32BE
  arr.readFloatLE = BP.readFloatLE
  arr.readFloatBE = BP.readFloatBE
  arr.readDoubleLE = BP.readDoubleLE
  arr.readDoubleBE = BP.readDoubleBE
  arr.writeUInt8 = BP.writeUInt8
  arr.writeUInt16LE = BP.writeUInt16LE
  arr.writeUInt16BE = BP.writeUInt16BE
  arr.writeUInt32LE = BP.writeUInt32LE
  arr.writeUInt32BE = BP.writeUInt32BE
  arr.writeInt8 = BP.writeInt8
  arr.writeInt16LE = BP.writeInt16LE
  arr.writeInt16BE = BP.writeInt16BE
  arr.writeInt32LE = BP.writeInt32LE
  arr.writeInt32BE = BP.writeInt32BE
  arr.writeFloatLE = BP.writeFloatLE
  arr.writeFloatBE = BP.writeFloatBE
  arr.writeDoubleLE = BP.writeDoubleLE
  arr.writeDoubleBE = BP.writeDoubleBE
  arr.fill = BP.fill
  arr.inspect = BP.inspect
  arr.toArrayBuffer = BP.toArrayBuffer

  return arr
}

// slice(start, end)
function clamp (index, len, defaultValue) {
  if (typeof index !== 'number') return defaultValue
  index = ~~index;  // Coerce to integer.
  if (index >= len) return len
  if (index >= 0) return index
  index += len
  if (index >= 0) return index
  return 0
}

function coerce (length) {
  // Coerce length to a number (possibly NaN), round up
  // in case it's fractional (e.g. 123.456) then do a
  // double negate to coerce a NaN to 0. Easy, right?
  length = ~~Math.ceil(+length)
  return length < 0 ? 0 : length
}

function isArray (subject) {
  return (Array.isArray || function (subject) {
    return Object.prototype.toString.call(subject) === '[object Array]'
  })(subject)
}

function isArrayish (subject) {
  return isArray(subject) || Buffer.isBuffer(subject) ||
      subject && typeof subject === 'object' &&
      typeof subject.length === 'number'
}

function toHex (n) {
  if (n < 16) return '0' + n.toString(16)
  return n.toString(16)
}

function utf8ToBytes (str) {
  var byteArray = []
  for (var i = 0; i < str.length; i++) {
    var b = str.charCodeAt(i)
    if (b <= 0x7F)
      byteArray.push(str.charCodeAt(i))
    else {
      var start = i
      if (b >= 0xD800 && b <= 0xDFFF) i++
      var h = encodeURIComponent(str.slice(start, i+1)).substr(1).split('%')
      for (var j = 0; j < h.length; j++)
        byteArray.push(parseInt(h[j], 16))
    }
  }
  return byteArray
}

function asciiToBytes (str) {
  var byteArray = []
  for (var i = 0; i < str.length; i++) {
    // Node's code seems to be doing this and not & 0x7F..
    byteArray.push(str.charCodeAt(i) & 0xFF)
  }
  return byteArray
}

function utf16leToBytes (str) {
  var c, hi, lo
  var byteArray = []
  for (var i = 0; i < str.length; i++) {
    c = str.charCodeAt(i)
    hi = c >> 8
    lo = c % 256
    byteArray.push(lo)
    byteArray.push(hi)
  }

  return byteArray
}

function base64ToBytes (str) {
  return base64.toByteArray(str)
}

function blitBuffer (src, dst, offset, length) {
  var pos
  for (var i = 0; i < length; i++) {
    if ((i + offset >= dst.length) || (i >= src.length))
      break
    dst[i + offset] = src[i]
  }
  return i
}

function decodeUtf8Char (str) {
  try {
    return decodeURIComponent(str)
  } catch (err) {
    return String.fromCharCode(0xFFFD) // UTF 8 invalid char
  }
}

/*
 * We have to make sure that the value is a valid integer. This means that it
 * is non-negative. It has no fractional component and that it does not
 * exceed the maximum allowed value.
 */
function verifuint (value, max) {
  assert(typeof value === 'number', 'cannot write a non-number as a number')
  assert(value >= 0, 'specified a negative value for writing an unsigned value')
  assert(value <= max, 'value is larger than maximum value for type')
  assert(Math.floor(value) === value, 'value has a fractional component')
}

function verifsint (value, max, min) {
  assert(typeof value === 'number', 'cannot write a non-number as a number')
  assert(value <= max, 'value larger than maximum allowed value')
  assert(value >= min, 'value smaller than minimum allowed value')
  assert(Math.floor(value) === value, 'value has a fractional component')
}

function verifIEEE754 (value, max, min) {
  assert(typeof value === 'number', 'cannot write a non-number as a number')
  assert(value <= max, 'value larger than maximum allowed value')
  assert(value >= min, 'value smaller than minimum allowed value')
}

function assert (test, message) {
  if (!test) throw new Error(message || 'Failed assertion')
}

},{"base64-js":6,"ieee754":35}],10:[function(require,module,exports){
var Buffer = require('buffer').Buffer;
var intSize = 4;
var zeroBuffer = new Buffer(intSize); zeroBuffer.fill(0);
var chrsz = 8;

function toArray(buf, bigEndian) {
  if ((buf.length % intSize) !== 0) {
    var len = buf.length + (intSize - (buf.length % intSize));
    buf = Buffer.concat([buf, zeroBuffer], len);
  }

  var arr = [];
  var fn = bigEndian ? buf.readInt32BE : buf.readInt32LE;
  for (var i = 0; i < buf.length; i += intSize) {
    arr.push(fn.call(buf, i));
  }
  return arr;
}

function toBuffer(arr, size, bigEndian) {
  var buf = new Buffer(size);
  var fn = bigEndian ? buf.writeInt32BE : buf.writeInt32LE;
  for (var i = 0; i < arr.length; i++) {
    fn.call(buf, arr[i], i * 4, true);
  }
  return buf;
}

function hash(buf, fn, hashSize, bigEndian) {
  if (!Buffer.isBuffer(buf)) buf = new Buffer(buf);
  var arr = fn(toArray(buf, bigEndian), buf.length * chrsz);
  return toBuffer(arr, hashSize, bigEndian);
}

module.exports = { hash: hash };

},{"buffer":9}],11:[function(require,module,exports){
var Buffer = require('buffer').Buffer
var sha = require('./sha')
var sha256 = require('./sha256')
var rng = require('./rng')
var md5 = require('./md5')

var algorithms = {
  sha1: sha,
  sha256: sha256,
  md5: md5
}

var blocksize = 64
var zeroBuffer = new Buffer(blocksize); zeroBuffer.fill(0)
function hmac(fn, key, data) {
  if(!Buffer.isBuffer(key)) key = new Buffer(key)
  if(!Buffer.isBuffer(data)) data = new Buffer(data)

  if(key.length > blocksize) {
    key = fn(key)
  } else if(key.length < blocksize) {
    key = Buffer.concat([key, zeroBuffer], blocksize)
  }

  var ipad = new Buffer(blocksize), opad = new Buffer(blocksize)
  for(var i = 0; i < blocksize; i++) {
    ipad[i] = key[i] ^ 0x36
    opad[i] = key[i] ^ 0x5C
  }

  var hash = fn(Buffer.concat([ipad, data]))
  return fn(Buffer.concat([opad, hash]))
}

function hash(alg, key) {
  alg = alg || 'sha1'
  var fn = algorithms[alg]
  var bufs = []
  var length = 0
  if(!fn) error('algorithm:', alg, 'is not yet supported')
  return {
    update: function (data) {
      if(!Buffer.isBuffer(data)) data = new Buffer(data)
        
      bufs.push(data)
      length += data.length
      return this
    },
    digest: function (enc) {
      var buf = Buffer.concat(bufs)
      var r = key ? hmac(fn, key, buf) : fn(buf)
      bufs = null
      return enc ? r.toString(enc) : r
    }
  }
}

function error () {
  var m = [].slice.call(arguments).join(' ')
  throw new Error([
    m,
    'we accept pull requests',
    'http://github.com/dominictarr/crypto-browserify'
    ].join('\n'))
}

exports.createHash = function (alg) { return hash(alg) }
exports.createHmac = function (alg, key) { return hash(alg, key) }
exports.randomBytes = function(size, callback) {
  if (callback && callback.call) {
    try {
      callback.call(this, undefined, new Buffer(rng(size)))
    } catch (err) { callback(err) }
  } else {
    return new Buffer(rng(size))
  }
}

function each(a, f) {
  for(var i in a)
    f(a[i], i)
}

// the least I can do is make error messages for the rest of the node.js/crypto api.
each(['createCredentials'
, 'createCipher'
, 'createCipheriv'
, 'createDecipher'
, 'createDecipheriv'
, 'createSign'
, 'createVerify'
, 'createDiffieHellman'
, 'pbkdf2'], function (name) {
  exports[name] = function () {
    error('sorry,', name, 'is not implemented yet')
  }
})

},{"./md5":12,"./rng":13,"./sha":14,"./sha256":15,"buffer":9}],12:[function(require,module,exports){
/*
 * A JavaScript implementation of the RSA Data Security, Inc. MD5 Message
 * Digest Algorithm, as defined in RFC 1321.
 * Version 2.1 Copyright (C) Paul Johnston 1999 - 2002.
 * Other contributors: Greg Holt, Andrew Kepert, Ydnar, Lostinet
 * Distributed under the BSD License
 * See http://pajhome.org.uk/crypt/md5 for more info.
 */

var helpers = require('./helpers');

/*
 * Perform a simple self-test to see if the VM is working
 */
function md5_vm_test()
{
  return hex_md5("abc") == "900150983cd24fb0d6963f7d28e17f72";
}

/*
 * Calculate the MD5 of an array of little-endian words, and a bit length
 */
function core_md5(x, len)
{
  /* append padding */
  x[len >> 5] |= 0x80 << ((len) % 32);
  x[(((len + 64) >>> 9) << 4) + 14] = len;

  var a =  1732584193;
  var b = -271733879;
  var c = -1732584194;
  var d =  271733878;

  for(var i = 0; i < x.length; i += 16)
  {
    var olda = a;
    var oldb = b;
    var oldc = c;
    var oldd = d;

    a = md5_ff(a, b, c, d, x[i+ 0], 7 , -680876936);
    d = md5_ff(d, a, b, c, x[i+ 1], 12, -389564586);
    c = md5_ff(c, d, a, b, x[i+ 2], 17,  606105819);
    b = md5_ff(b, c, d, a, x[i+ 3], 22, -1044525330);
    a = md5_ff(a, b, c, d, x[i+ 4], 7 , -176418897);
    d = md5_ff(d, a, b, c, x[i+ 5], 12,  1200080426);
    c = md5_ff(c, d, a, b, x[i+ 6], 17, -1473231341);
    b = md5_ff(b, c, d, a, x[i+ 7], 22, -45705983);
    a = md5_ff(a, b, c, d, x[i+ 8], 7 ,  1770035416);
    d = md5_ff(d, a, b, c, x[i+ 9], 12, -1958414417);
    c = md5_ff(c, d, a, b, x[i+10], 17, -42063);
    b = md5_ff(b, c, d, a, x[i+11], 22, -1990404162);
    a = md5_ff(a, b, c, d, x[i+12], 7 ,  1804603682);
    d = md5_ff(d, a, b, c, x[i+13], 12, -40341101);
    c = md5_ff(c, d, a, b, x[i+14], 17, -1502002290);
    b = md5_ff(b, c, d, a, x[i+15], 22,  1236535329);

    a = md5_gg(a, b, c, d, x[i+ 1], 5 , -165796510);
    d = md5_gg(d, a, b, c, x[i+ 6], 9 , -1069501632);
    c = md5_gg(c, d, a, b, x[i+11], 14,  643717713);
    b = md5_gg(b, c, d, a, x[i+ 0], 20, -373897302);
    a = md5_gg(a, b, c, d, x[i+ 5], 5 , -701558691);
    d = md5_gg(d, a, b, c, x[i+10], 9 ,  38016083);
    c = md5_gg(c, d, a, b, x[i+15], 14, -660478335);
    b = md5_gg(b, c, d, a, x[i+ 4], 20, -405537848);
    a = md5_gg(a, b, c, d, x[i+ 9], 5 ,  568446438);
    d = md5_gg(d, a, b, c, x[i+14], 9 , -1019803690);
    c = md5_gg(c, d, a, b, x[i+ 3], 14, -187363961);
    b = md5_gg(b, c, d, a, x[i+ 8], 20,  1163531501);
    a = md5_gg(a, b, c, d, x[i+13], 5 , -1444681467);
    d = md5_gg(d, a, b, c, x[i+ 2], 9 , -51403784);
    c = md5_gg(c, d, a, b, x[i+ 7], 14,  1735328473);
    b = md5_gg(b, c, d, a, x[i+12], 20, -1926607734);

    a = md5_hh(a, b, c, d, x[i+ 5], 4 , -378558);
    d = md5_hh(d, a, b, c, x[i+ 8], 11, -2022574463);
    c = md5_hh(c, d, a, b, x[i+11], 16,  1839030562);
    b = md5_hh(b, c, d, a, x[i+14], 23, -35309556);
    a = md5_hh(a, b, c, d, x[i+ 1], 4 , -1530992060);
    d = md5_hh(d, a, b, c, x[i+ 4], 11,  1272893353);
    c = md5_hh(c, d, a, b, x[i+ 7], 16, -155497632);
    b = md5_hh(b, c, d, a, x[i+10], 23, -1094730640);
    a = md5_hh(a, b, c, d, x[i+13], 4 ,  681279174);
    d = md5_hh(d, a, b, c, x[i+ 0], 11, -358537222);
    c = md5_hh(c, d, a, b, x[i+ 3], 16, -722521979);
    b = md5_hh(b, c, d, a, x[i+ 6], 23,  76029189);
    a = md5_hh(a, b, c, d, x[i+ 9], 4 , -640364487);
    d = md5_hh(d, a, b, c, x[i+12], 11, -421815835);
    c = md5_hh(c, d, a, b, x[i+15], 16,  530742520);
    b = md5_hh(b, c, d, a, x[i+ 2], 23, -995338651);

    a = md5_ii(a, b, c, d, x[i+ 0], 6 , -198630844);
    d = md5_ii(d, a, b, c, x[i+ 7], 10,  1126891415);
    c = md5_ii(c, d, a, b, x[i+14], 15, -1416354905);
    b = md5_ii(b, c, d, a, x[i+ 5], 21, -57434055);
    a = md5_ii(a, b, c, d, x[i+12], 6 ,  1700485571);
    d = md5_ii(d, a, b, c, x[i+ 3], 10, -1894986606);
    c = md5_ii(c, d, a, b, x[i+10], 15, -1051523);
    b = md5_ii(b, c, d, a, x[i+ 1], 21, -2054922799);
    a = md5_ii(a, b, c, d, x[i+ 8], 6 ,  1873313359);
    d = md5_ii(d, a, b, c, x[i+15], 10, -30611744);
    c = md5_ii(c, d, a, b, x[i+ 6], 15, -1560198380);
    b = md5_ii(b, c, d, a, x[i+13], 21,  1309151649);
    a = md5_ii(a, b, c, d, x[i+ 4], 6 , -145523070);
    d = md5_ii(d, a, b, c, x[i+11], 10, -1120210379);
    c = md5_ii(c, d, a, b, x[i+ 2], 15,  718787259);
    b = md5_ii(b, c, d, a, x[i+ 9], 21, -343485551);

    a = safe_add(a, olda);
    b = safe_add(b, oldb);
    c = safe_add(c, oldc);
    d = safe_add(d, oldd);
  }
  return Array(a, b, c, d);

}

/*
 * These functions implement the four basic operations the algorithm uses.
 */
function md5_cmn(q, a, b, x, s, t)
{
  return safe_add(bit_rol(safe_add(safe_add(a, q), safe_add(x, t)), s),b);
}
function md5_ff(a, b, c, d, x, s, t)
{
  return md5_cmn((b & c) | ((~b) & d), a, b, x, s, t);
}
function md5_gg(a, b, c, d, x, s, t)
{
  return md5_cmn((b & d) | (c & (~d)), a, b, x, s, t);
}
function md5_hh(a, b, c, d, x, s, t)
{
  return md5_cmn(b ^ c ^ d, a, b, x, s, t);
}
function md5_ii(a, b, c, d, x, s, t)
{
  return md5_cmn(c ^ (b | (~d)), a, b, x, s, t);
}

/*
 * Add integers, wrapping at 2^32. This uses 16-bit operations internally
 * to work around bugs in some JS interpreters.
 */
function safe_add(x, y)
{
  var lsw = (x & 0xFFFF) + (y & 0xFFFF);
  var msw = (x >> 16) + (y >> 16) + (lsw >> 16);
  return (msw << 16) | (lsw & 0xFFFF);
}

/*
 * Bitwise rotate a 32-bit number to the left.
 */
function bit_rol(num, cnt)
{
  return (num << cnt) | (num >>> (32 - cnt));
}

module.exports = function md5(buf) {
  return helpers.hash(buf, core_md5, 16);
};

},{"./helpers":10}],13:[function(require,module,exports){
// Original code adapted from Robert Kieffer.
// details at https://github.com/broofa/node-uuid
(function() {
  var _global = this;

  var mathRNG, whatwgRNG;

  // NOTE: Math.random() does not guarantee "cryptographic quality"
  mathRNG = function(size) {
    var bytes = new Array(size);
    var r;

    for (var i = 0, r; i < size; i++) {
      if ((i & 0x03) == 0) r = Math.random() * 0x100000000;
      bytes[i] = r >>> ((i & 0x03) << 3) & 0xff;
    }

    return bytes;
  }

  if (_global.crypto && crypto.getRandomValues) {
    whatwgRNG = function(size) {
      var bytes = new Uint8Array(size);
      crypto.getRandomValues(bytes);
      return bytes;
    }
  }

  module.exports = whatwgRNG || mathRNG;

}())

},{}],14:[function(require,module,exports){
/*
 * A JavaScript implementation of the Secure Hash Algorithm, SHA-1, as defined
 * in FIPS PUB 180-1
 * Version 2.1a Copyright Paul Johnston 2000 - 2002.
 * Other contributors: Greg Holt, Andrew Kepert, Ydnar, Lostinet
 * Distributed under the BSD License
 * See http://pajhome.org.uk/crypt/md5 for details.
 */

var helpers = require('./helpers');

/*
 * Calculate the SHA-1 of an array of big-endian words, and a bit length
 */
function core_sha1(x, len)
{
  /* append padding */
  x[len >> 5] |= 0x80 << (24 - len % 32);
  x[((len + 64 >> 9) << 4) + 15] = len;

  var w = Array(80);
  var a =  1732584193;
  var b = -271733879;
  var c = -1732584194;
  var d =  271733878;
  var e = -1009589776;

  for(var i = 0; i < x.length; i += 16)
  {
    var olda = a;
    var oldb = b;
    var oldc = c;
    var oldd = d;
    var olde = e;

    for(var j = 0; j < 80; j++)
    {
      if(j < 16) w[j] = x[i + j];
      else w[j] = rol(w[j-3] ^ w[j-8] ^ w[j-14] ^ w[j-16], 1);
      var t = safe_add(safe_add(rol(a, 5), sha1_ft(j, b, c, d)),
                       safe_add(safe_add(e, w[j]), sha1_kt(j)));
      e = d;
      d = c;
      c = rol(b, 30);
      b = a;
      a = t;
    }

    a = safe_add(a, olda);
    b = safe_add(b, oldb);
    c = safe_add(c, oldc);
    d = safe_add(d, oldd);
    e = safe_add(e, olde);
  }
  return Array(a, b, c, d, e);

}

/*
 * Perform the appropriate triplet combination function for the current
 * iteration
 */
function sha1_ft(t, b, c, d)
{
  if(t < 20) return (b & c) | ((~b) & d);
  if(t < 40) return b ^ c ^ d;
  if(t < 60) return (b & c) | (b & d) | (c & d);
  return b ^ c ^ d;
}

/*
 * Determine the appropriate additive constant for the current iteration
 */
function sha1_kt(t)
{
  return (t < 20) ?  1518500249 : (t < 40) ?  1859775393 :
         (t < 60) ? -1894007588 : -899497514;
}

/*
 * Add integers, wrapping at 2^32. This uses 16-bit operations internally
 * to work around bugs in some JS interpreters.
 */
function safe_add(x, y)
{
  var lsw = (x & 0xFFFF) + (y & 0xFFFF);
  var msw = (x >> 16) + (y >> 16) + (lsw >> 16);
  return (msw << 16) | (lsw & 0xFFFF);
}

/*
 * Bitwise rotate a 32-bit number to the left.
 */
function rol(num, cnt)
{
  return (num << cnt) | (num >>> (32 - cnt));
}

module.exports = function sha1(buf) {
  return helpers.hash(buf, core_sha1, 20, true);
};

},{"./helpers":10}],15:[function(require,module,exports){

/**
 * A JavaScript implementation of the Secure Hash Algorithm, SHA-256, as defined
 * in FIPS 180-2
 * Version 2.2-beta Copyright Angel Marin, Paul Johnston 2000 - 2009.
 * Other contributors: Greg Holt, Andrew Kepert, Ydnar, Lostinet
 *
 */

var helpers = require('./helpers');

var safe_add = function(x, y) {
  var lsw = (x & 0xFFFF) + (y & 0xFFFF);
  var msw = (x >> 16) + (y >> 16) + (lsw >> 16);
  return (msw << 16) | (lsw & 0xFFFF);
};

var S = function(X, n) {
  return (X >>> n) | (X << (32 - n));
};

var R = function(X, n) {
  return (X >>> n);
};

var Ch = function(x, y, z) {
  return ((x & y) ^ ((~x) & z));
};

var Maj = function(x, y, z) {
  return ((x & y) ^ (x & z) ^ (y & z));
};

var Sigma0256 = function(x) {
  return (S(x, 2) ^ S(x, 13) ^ S(x, 22));
};

var Sigma1256 = function(x) {
  return (S(x, 6) ^ S(x, 11) ^ S(x, 25));
};

var Gamma0256 = function(x) {
  return (S(x, 7) ^ S(x, 18) ^ R(x, 3));
};

var Gamma1256 = function(x) {
  return (S(x, 17) ^ S(x, 19) ^ R(x, 10));
};

var core_sha256 = function(m, l) {
  var K = new Array(0x428A2F98,0x71374491,0xB5C0FBCF,0xE9B5DBA5,0x3956C25B,0x59F111F1,0x923F82A4,0xAB1C5ED5,0xD807AA98,0x12835B01,0x243185BE,0x550C7DC3,0x72BE5D74,0x80DEB1FE,0x9BDC06A7,0xC19BF174,0xE49B69C1,0xEFBE4786,0xFC19DC6,0x240CA1CC,0x2DE92C6F,0x4A7484AA,0x5CB0A9DC,0x76F988DA,0x983E5152,0xA831C66D,0xB00327C8,0xBF597FC7,0xC6E00BF3,0xD5A79147,0x6CA6351,0x14292967,0x27B70A85,0x2E1B2138,0x4D2C6DFC,0x53380D13,0x650A7354,0x766A0ABB,0x81C2C92E,0x92722C85,0xA2BFE8A1,0xA81A664B,0xC24B8B70,0xC76C51A3,0xD192E819,0xD6990624,0xF40E3585,0x106AA070,0x19A4C116,0x1E376C08,0x2748774C,0x34B0BCB5,0x391C0CB3,0x4ED8AA4A,0x5B9CCA4F,0x682E6FF3,0x748F82EE,0x78A5636F,0x84C87814,0x8CC70208,0x90BEFFFA,0xA4506CEB,0xBEF9A3F7,0xC67178F2);
  var HASH = new Array(0x6A09E667, 0xBB67AE85, 0x3C6EF372, 0xA54FF53A, 0x510E527F, 0x9B05688C, 0x1F83D9AB, 0x5BE0CD19);
    var W = new Array(64);
    var a, b, c, d, e, f, g, h, i, j;
    var T1, T2;
  /* append padding */
  m[l >> 5] |= 0x80 << (24 - l % 32);
  m[((l + 64 >> 9) << 4) + 15] = l;
  for (var i = 0; i < m.length; i += 16) {
    a = HASH[0]; b = HASH[1]; c = HASH[2]; d = HASH[3]; e = HASH[4]; f = HASH[5]; g = HASH[6]; h = HASH[7];
    for (var j = 0; j < 64; j++) {
      if (j < 16) {
        W[j] = m[j + i];
      } else {
        W[j] = safe_add(safe_add(safe_add(Gamma1256(W[j - 2]), W[j - 7]), Gamma0256(W[j - 15])), W[j - 16]);
      }
      T1 = safe_add(safe_add(safe_add(safe_add(h, Sigma1256(e)), Ch(e, f, g)), K[j]), W[j]);
      T2 = safe_add(Sigma0256(a), Maj(a, b, c));
      h = g; g = f; f = e; e = safe_add(d, T1); d = c; c = b; b = a; a = safe_add(T1, T2);
    }
    HASH[0] = safe_add(a, HASH[0]); HASH[1] = safe_add(b, HASH[1]); HASH[2] = safe_add(c, HASH[2]); HASH[3] = safe_add(d, HASH[3]);
    HASH[4] = safe_add(e, HASH[4]); HASH[5] = safe_add(f, HASH[5]); HASH[6] = safe_add(g, HASH[6]); HASH[7] = safe_add(h, HASH[7]);
  }
  return HASH;
};

module.exports = function sha256(buf) {
  return helpers.hash(buf, core_sha256, 32, true);
};

},{"./helpers":10}],16:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

function EventEmitter() {
  this._events = this._events || {};
  this._maxListeners = this._maxListeners || undefined;
}
module.exports = EventEmitter;

// Backwards-compat with node 0.10.x
EventEmitter.EventEmitter = EventEmitter;

EventEmitter.prototype._events = undefined;
EventEmitter.prototype._maxListeners = undefined;

// By default EventEmitters will print a warning if more than 10 listeners are
// added to it. This is a useful default which helps finding memory leaks.
EventEmitter.defaultMaxListeners = 10;

// Obviously not all Emitters should be limited to 10. This function allows
// that to be increased. Set to zero for unlimited.
EventEmitter.prototype.setMaxListeners = function(n) {
  if (!isNumber(n) || n < 0 || isNaN(n))
    throw TypeError('n must be a positive number');
  this._maxListeners = n;
  return this;
};

EventEmitter.prototype.emit = function(type) {
  var er, handler, len, args, i, listeners;

  if (!this._events)
    this._events = {};

  // If there is no 'error' event listener then throw.
  if (type === 'error') {
    if (!this._events.error ||
        (isObject(this._events.error) && !this._events.error.length)) {
      er = arguments[1];
      if (er instanceof Error) {
        throw er; // Unhandled 'error' event
      }
      throw TypeError('Uncaught, unspecified "error" event.');
    }
  }

  handler = this._events[type];

  if (isUndefined(handler))
    return false;

  if (isFunction(handler)) {
    switch (arguments.length) {
      // fast cases
      case 1:
        handler.call(this);
        break;
      case 2:
        handler.call(this, arguments[1]);
        break;
      case 3:
        handler.call(this, arguments[1], arguments[2]);
        break;
      // slower
      default:
        len = arguments.length;
        args = new Array(len - 1);
        for (i = 1; i < len; i++)
          args[i - 1] = arguments[i];
        handler.apply(this, args);
    }
  } else if (isObject(handler)) {
    len = arguments.length;
    args = new Array(len - 1);
    for (i = 1; i < len; i++)
      args[i - 1] = arguments[i];

    listeners = handler.slice();
    len = listeners.length;
    for (i = 0; i < len; i++)
      listeners[i].apply(this, args);
  }

  return true;
};

EventEmitter.prototype.addListener = function(type, listener) {
  var m;

  if (!isFunction(listener))
    throw TypeError('listener must be a function');

  if (!this._events)
    this._events = {};

  // To avoid recursion in the case that type === "newListener"! Before
  // adding it to the listeners, first emit "newListener".
  if (this._events.newListener)
    this.emit('newListener', type,
              isFunction(listener.listener) ?
              listener.listener : listener);

  if (!this._events[type])
    // Optimize the case of one listener. Don't need the extra array object.
    this._events[type] = listener;
  else if (isObject(this._events[type]))
    // If we've already got an array, just append.
    this._events[type].push(listener);
  else
    // Adding the second element, need to change to array.
    this._events[type] = [this._events[type], listener];

  // Check for listener leak
  if (isObject(this._events[type]) && !this._events[type].warned) {
    var m;
    if (!isUndefined(this._maxListeners)) {
      m = this._maxListeners;
    } else {
      m = EventEmitter.defaultMaxListeners;
    }

    if (m && m > 0 && this._events[type].length > m) {
      this._events[type].warned = true;
      console.error('(node) warning: possible EventEmitter memory ' +
                    'leak detected. %d listeners added. ' +
                    'Use emitter.setMaxListeners() to increase limit.',
                    this._events[type].length);
      if (typeof console.trace === 'function') {
        // not supported in IE 10
        console.trace();
      }
    }
  }

  return this;
};

EventEmitter.prototype.on = EventEmitter.prototype.addListener;

EventEmitter.prototype.once = function(type, listener) {
  if (!isFunction(listener))
    throw TypeError('listener must be a function');

  var fired = false;

  function g() {
    this.removeListener(type, g);

    if (!fired) {
      fired = true;
      listener.apply(this, arguments);
    }
  }

  g.listener = listener;
  this.on(type, g);

  return this;
};

// emits a 'removeListener' event iff the listener was removed
EventEmitter.prototype.removeListener = function(type, listener) {
  var list, position, length, i;

  if (!isFunction(listener))
    throw TypeError('listener must be a function');

  if (!this._events || !this._events[type])
    return this;

  list = this._events[type];
  length = list.length;
  position = -1;

  if (list === listener ||
      (isFunction(list.listener) && list.listener === listener)) {
    delete this._events[type];
    if (this._events.removeListener)
      this.emit('removeListener', type, listener);

  } else if (isObject(list)) {
    for (i = length; i-- > 0;) {
      if (list[i] === listener ||
          (list[i].listener && list[i].listener === listener)) {
        position = i;
        break;
      }
    }

    if (position < 0)
      return this;

    if (list.length === 1) {
      list.length = 0;
      delete this._events[type];
    } else {
      list.splice(position, 1);
    }

    if (this._events.removeListener)
      this.emit('removeListener', type, listener);
  }

  return this;
};

EventEmitter.prototype.removeAllListeners = function(type) {
  var key, listeners;

  if (!this._events)
    return this;

  // not listening for removeListener, no need to emit
  if (!this._events.removeListener) {
    if (arguments.length === 0)
      this._events = {};
    else if (this._events[type])
      delete this._events[type];
    return this;
  }

  // emit removeListener for all listeners on all events
  if (arguments.length === 0) {
    for (key in this._events) {
      if (key === 'removeListener') continue;
      this.removeAllListeners(key);
    }
    this.removeAllListeners('removeListener');
    this._events = {};
    return this;
  }

  listeners = this._events[type];

  if (isFunction(listeners)) {
    this.removeListener(type, listeners);
  } else {
    // LIFO order
    while (listeners.length)
      this.removeListener(type, listeners[listeners.length - 1]);
  }
  delete this._events[type];

  return this;
};

EventEmitter.prototype.listeners = function(type) {
  var ret;
  if (!this._events || !this._events[type])
    ret = [];
  else if (isFunction(this._events[type]))
    ret = [this._events[type]];
  else
    ret = this._events[type].slice();
  return ret;
};

EventEmitter.listenerCount = function(emitter, type) {
  var ret;
  if (!emitter._events || !emitter._events[type])
    ret = 0;
  else if (isFunction(emitter._events[type]))
    ret = 1;
  else
    ret = emitter._events[type].length;
  return ret;
};

function isFunction(arg) {
  return typeof arg === 'function';
}

function isNumber(arg) {
  return typeof arg === 'number';
}

function isObject(arg) {
  return typeof arg === 'object' && arg !== null;
}

function isUndefined(arg) {
  return arg === void 0;
}

},{}],17:[function(require,module,exports){
// shim for using process in browser

var process = module.exports = {};

process.nextTick = (function () {
    var canSetImmediate = typeof window !== 'undefined'
    && window.setImmediate;
    var canPost = typeof window !== 'undefined'
    && window.postMessage && window.addEventListener
    ;

    if (canSetImmediate) {
        return function (f) { return window.setImmediate(f) };
    }

    if (canPost) {
        var queue = [];
        window.addEventListener('message', function (ev) {
            var source = ev.source;
            if ((source === window || source === null) && ev.data === 'process-tick') {
                ev.stopPropagation();
                if (queue.length > 0) {
                    var fn = queue.shift();
                    fn();
                }
            }
        }, true);

        return function nextTick(fn) {
            queue.push(fn);
            window.postMessage('process-tick', '*');
        };
    }

    return function nextTick(fn) {
        setTimeout(fn, 0);
    };
})();

process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;

process.binding = function (name) {
    throw new Error('process.binding is not supported');
}

// TODO(shtylman)
process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};

},{}],18:[function(require,module,exports){
(function (global){
/*! http://mths.be/punycode v1.2.4 by @mathias */
;(function(root) {

	/** Detect free variables */
	var freeExports = typeof exports == 'object' && exports;
	var freeModule = typeof module == 'object' && module &&
		module.exports == freeExports && module;
	var freeGlobal = typeof global == 'object' && global;
	if (freeGlobal.global === freeGlobal || freeGlobal.window === freeGlobal) {
		root = freeGlobal;
	}

	/**
	 * The `punycode` object.
	 * @name punycode
	 * @type Object
	 */
	var punycode,

	/** Highest positive signed 32-bit float value */
	maxInt = 2147483647, // aka. 0x7FFFFFFF or 2^31-1

	/** Bootstring parameters */
	base = 36,
	tMin = 1,
	tMax = 26,
	skew = 38,
	damp = 700,
	initialBias = 72,
	initialN = 128, // 0x80
	delimiter = '-', // '\x2D'

	/** Regular expressions */
	regexPunycode = /^xn--/,
	regexNonASCII = /[^ -~]/, // unprintable ASCII chars + non-ASCII chars
	regexSeparators = /\x2E|\u3002|\uFF0E|\uFF61/g, // RFC 3490 separators

	/** Error messages */
	errors = {
		'overflow': 'Overflow: input needs wider integers to process',
		'not-basic': 'Illegal input >= 0x80 (not a basic code point)',
		'invalid-input': 'Invalid input'
	},

	/** Convenience shortcuts */
	baseMinusTMin = base - tMin,
	floor = Math.floor,
	stringFromCharCode = String.fromCharCode,

	/** Temporary variable */
	key;

	/*--------------------------------------------------------------------------*/

	/**
	 * A generic error utility function.
	 * @private
	 * @param {String} type The error type.
	 * @returns {Error} Throws a `RangeError` with the applicable error message.
	 */
	function error(type) {
		throw RangeError(errors[type]);
	}

	/**
	 * A generic `Array#map` utility function.
	 * @private
	 * @param {Array} array The array to iterate over.
	 * @param {Function} callback The function that gets called for every array
	 * item.
	 * @returns {Array} A new array of values returned by the callback function.
	 */
	function map(array, fn) {
		var length = array.length;
		while (length--) {
			array[length] = fn(array[length]);
		}
		return array;
	}

	/**
	 * A simple `Array#map`-like wrapper to work with domain name strings.
	 * @private
	 * @param {String} domain The domain name.
	 * @param {Function} callback The function that gets called for every
	 * character.
	 * @returns {Array} A new string of characters returned by the callback
	 * function.
	 */
	function mapDomain(string, fn) {
		return map(string.split(regexSeparators), fn).join('.');
	}

	/**
	 * Creates an array containing the numeric code points of each Unicode
	 * character in the string. While JavaScript uses UCS-2 internally,
	 * this function will convert a pair of surrogate halves (each of which
	 * UCS-2 exposes as separate characters) into a single code point,
	 * matching UTF-16.
	 * @see `punycode.ucs2.encode`
	 * @see <http://mathiasbynens.be/notes/javascript-encoding>
	 * @memberOf punycode.ucs2
	 * @name decode
	 * @param {String} string The Unicode input string (UCS-2).
	 * @returns {Array} The new array of code points.
	 */
	function ucs2decode(string) {
		var output = [],
		    counter = 0,
		    length = string.length,
		    value,
		    extra;
		while (counter < length) {
			value = string.charCodeAt(counter++);
			if (value >= 0xD800 && value <= 0xDBFF && counter < length) {
				// high surrogate, and there is a next character
				extra = string.charCodeAt(counter++);
				if ((extra & 0xFC00) == 0xDC00) { // low surrogate
					output.push(((value & 0x3FF) << 10) + (extra & 0x3FF) + 0x10000);
				} else {
					// unmatched surrogate; only append this code unit, in case the next
					// code unit is the high surrogate of a surrogate pair
					output.push(value);
					counter--;
				}
			} else {
				output.push(value);
			}
		}
		return output;
	}

	/**
	 * Creates a string based on an array of numeric code points.
	 * @see `punycode.ucs2.decode`
	 * @memberOf punycode.ucs2
	 * @name encode
	 * @param {Array} codePoints The array of numeric code points.
	 * @returns {String} The new Unicode string (UCS-2).
	 */
	function ucs2encode(array) {
		return map(array, function(value) {
			var output = '';
			if (value > 0xFFFF) {
				value -= 0x10000;
				output += stringFromCharCode(value >>> 10 & 0x3FF | 0xD800);
				value = 0xDC00 | value & 0x3FF;
			}
			output += stringFromCharCode(value);
			return output;
		}).join('');
	}

	/**
	 * Converts a basic code point into a digit/integer.
	 * @see `digitToBasic()`
	 * @private
	 * @param {Number} codePoint The basic numeric code point value.
	 * @returns {Number} The numeric value of a basic code point (for use in
	 * representing integers) in the range `0` to `base - 1`, or `base` if
	 * the code point does not represent a value.
	 */
	function basicToDigit(codePoint) {
		if (codePoint - 48 < 10) {
			return codePoint - 22;
		}
		if (codePoint - 65 < 26) {
			return codePoint - 65;
		}
		if (codePoint - 97 < 26) {
			return codePoint - 97;
		}
		return base;
	}

	/**
	 * Converts a digit/integer into a basic code point.
	 * @see `basicToDigit()`
	 * @private
	 * @param {Number} digit The numeric value of a basic code point.
	 * @returns {Number} The basic code point whose value (when used for
	 * representing integers) is `digit`, which needs to be in the range
	 * `0` to `base - 1`. If `flag` is non-zero, the uppercase form is
	 * used; else, the lowercase form is used. The behavior is undefined
	 * if `flag` is non-zero and `digit` has no uppercase form.
	 */
	function digitToBasic(digit, flag) {
		//  0..25 map to ASCII a..z or A..Z
		// 26..35 map to ASCII 0..9
		return digit + 22 + 75 * (digit < 26) - ((flag != 0) << 5);
	}

	/**
	 * Bias adaptation function as per section 3.4 of RFC 3492.
	 * http://tools.ietf.org/html/rfc3492#section-3.4
	 * @private
	 */
	function adapt(delta, numPoints, firstTime) {
		var k = 0;
		delta = firstTime ? floor(delta / damp) : delta >> 1;
		delta += floor(delta / numPoints);
		for (/* no initialization */; delta > baseMinusTMin * tMax >> 1; k += base) {
			delta = floor(delta / baseMinusTMin);
		}
		return floor(k + (baseMinusTMin + 1) * delta / (delta + skew));
	}

	/**
	 * Converts a Punycode string of ASCII-only symbols to a string of Unicode
	 * symbols.
	 * @memberOf punycode
	 * @param {String} input The Punycode string of ASCII-only symbols.
	 * @returns {String} The resulting string of Unicode symbols.
	 */
	function decode(input) {
		// Don't use UCS-2
		var output = [],
		    inputLength = input.length,
		    out,
		    i = 0,
		    n = initialN,
		    bias = initialBias,
		    basic,
		    j,
		    index,
		    oldi,
		    w,
		    k,
		    digit,
		    t,
		    /** Cached calculation results */
		    baseMinusT;

		// Handle the basic code points: let `basic` be the number of input code
		// points before the last delimiter, or `0` if there is none, then copy
		// the first basic code points to the output.

		basic = input.lastIndexOf(delimiter);
		if (basic < 0) {
			basic = 0;
		}

		for (j = 0; j < basic; ++j) {
			// if it's not a basic code point
			if (input.charCodeAt(j) >= 0x80) {
				error('not-basic');
			}
			output.push(input.charCodeAt(j));
		}

		// Main decoding loop: start just after the last delimiter if any basic code
		// points were copied; start at the beginning otherwise.

		for (index = basic > 0 ? basic + 1 : 0; index < inputLength; /* no final expression */) {

			// `index` is the index of the next character to be consumed.
			// Decode a generalized variable-length integer into `delta`,
			// which gets added to `i`. The overflow checking is easier
			// if we increase `i` as we go, then subtract off its starting
			// value at the end to obtain `delta`.
			for (oldi = i, w = 1, k = base; /* no condition */; k += base) {

				if (index >= inputLength) {
					error('invalid-input');
				}

				digit = basicToDigit(input.charCodeAt(index++));

				if (digit >= base || digit > floor((maxInt - i) / w)) {
					error('overflow');
				}

				i += digit * w;
				t = k <= bias ? tMin : (k >= bias + tMax ? tMax : k - bias);

				if (digit < t) {
					break;
				}

				baseMinusT = base - t;
				if (w > floor(maxInt / baseMinusT)) {
					error('overflow');
				}

				w *= baseMinusT;

			}

			out = output.length + 1;
			bias = adapt(i - oldi, out, oldi == 0);

			// `i` was supposed to wrap around from `out` to `0`,
			// incrementing `n` each time, so we'll fix that now:
			if (floor(i / out) > maxInt - n) {
				error('overflow');
			}

			n += floor(i / out);
			i %= out;

			// Insert `n` at position `i` of the output
			output.splice(i++, 0, n);

		}

		return ucs2encode(output);
	}

	/**
	 * Converts a string of Unicode symbols to a Punycode string of ASCII-only
	 * symbols.
	 * @memberOf punycode
	 * @param {String} input The string of Unicode symbols.
	 * @returns {String} The resulting Punycode string of ASCII-only symbols.
	 */
	function encode(input) {
		var n,
		    delta,
		    handledCPCount,
		    basicLength,
		    bias,
		    j,
		    m,
		    q,
		    k,
		    t,
		    currentValue,
		    output = [],
		    /** `inputLength` will hold the number of code points in `input`. */
		    inputLength,
		    /** Cached calculation results */
		    handledCPCountPlusOne,
		    baseMinusT,
		    qMinusT;

		// Convert the input in UCS-2 to Unicode
		input = ucs2decode(input);

		// Cache the length
		inputLength = input.length;

		// Initialize the state
		n = initialN;
		delta = 0;
		bias = initialBias;

		// Handle the basic code points
		for (j = 0; j < inputLength; ++j) {
			currentValue = input[j];
			if (currentValue < 0x80) {
				output.push(stringFromCharCode(currentValue));
			}
		}

		handledCPCount = basicLength = output.length;

		// `handledCPCount` is the number of code points that have been handled;
		// `basicLength` is the number of basic code points.

		// Finish the basic string - if it is not empty - with a delimiter
		if (basicLength) {
			output.push(delimiter);
		}

		// Main encoding loop:
		while (handledCPCount < inputLength) {

			// All non-basic code points < n have been handled already. Find the next
			// larger one:
			for (m = maxInt, j = 0; j < inputLength; ++j) {
				currentValue = input[j];
				if (currentValue >= n && currentValue < m) {
					m = currentValue;
				}
			}

			// Increase `delta` enough to advance the decoder's <n,i> state to <m,0>,
			// but guard against overflow
			handledCPCountPlusOne = handledCPCount + 1;
			if (m - n > floor((maxInt - delta) / handledCPCountPlusOne)) {
				error('overflow');
			}

			delta += (m - n) * handledCPCountPlusOne;
			n = m;

			for (j = 0; j < inputLength; ++j) {
				currentValue = input[j];

				if (currentValue < n && ++delta > maxInt) {
					error('overflow');
				}

				if (currentValue == n) {
					// Represent delta as a generalized variable-length integer
					for (q = delta, k = base; /* no condition */; k += base) {
						t = k <= bias ? tMin : (k >= bias + tMax ? tMax : k - bias);
						if (q < t) {
							break;
						}
						qMinusT = q - t;
						baseMinusT = base - t;
						output.push(
							stringFromCharCode(digitToBasic(t + qMinusT % baseMinusT, 0))
						);
						q = floor(qMinusT / baseMinusT);
					}

					output.push(stringFromCharCode(digitToBasic(q, 0)));
					bias = adapt(delta, handledCPCountPlusOne, handledCPCount == basicLength);
					delta = 0;
					++handledCPCount;
				}
			}

			++delta;
			++n;

		}
		return output.join('');
	}

	/**
	 * Converts a Punycode string representing a domain name to Unicode. Only the
	 * Punycoded parts of the domain name will be converted, i.e. it doesn't
	 * matter if you call it on a string that has already been converted to
	 * Unicode.
	 * @memberOf punycode
	 * @param {String} domain The Punycode domain name to convert to Unicode.
	 * @returns {String} The Unicode representation of the given Punycode
	 * string.
	 */
	function toUnicode(domain) {
		return mapDomain(domain, function(string) {
			return regexPunycode.test(string)
				? decode(string.slice(4).toLowerCase())
				: string;
		});
	}

	/**
	 * Converts a Unicode string representing a domain name to Punycode. Only the
	 * non-ASCII parts of the domain name will be converted, i.e. it doesn't
	 * matter if you call it with a domain that's already in ASCII.
	 * @memberOf punycode
	 * @param {String} domain The domain name to convert, as a Unicode string.
	 * @returns {String} The Punycode representation of the given domain name.
	 */
	function toASCII(domain) {
		return mapDomain(domain, function(string) {
			return regexNonASCII.test(string)
				? 'xn--' + encode(string)
				: string;
		});
	}

	/*--------------------------------------------------------------------------*/

	/** Define the public API */
	punycode = {
		/**
		 * A string representing the current Punycode.js version number.
		 * @memberOf punycode
		 * @type String
		 */
		'version': '1.2.4',
		/**
		 * An object of methods to convert from JavaScript's internal character
		 * representation (UCS-2) to Unicode code points, and back.
		 * @see <http://mathiasbynens.be/notes/javascript-encoding>
		 * @memberOf punycode
		 * @type Object
		 */
		'ucs2': {
			'decode': ucs2decode,
			'encode': ucs2encode
		},
		'decode': decode,
		'encode': encode,
		'toASCII': toASCII,
		'toUnicode': toUnicode
	};

	/** Expose `punycode` */
	// Some AMD build optimizers, like r.js, check for specific condition patterns
	// like the following:
	if (
		typeof define == 'function' &&
		typeof define.amd == 'object' &&
		define.amd
	) {
		define('punycode', function() {
			return punycode;
		});
	} else if (freeExports && !freeExports.nodeType) {
		if (freeModule) { // in Node.js or RingoJS v0.8.0+
			freeModule.exports = punycode;
		} else { // in Narwhal or RingoJS v0.7.0-
			for (key in punycode) {
				punycode.hasOwnProperty(key) && (freeExports[key] = punycode[key]);
			}
		}
	} else { // in Rhino or a web browser
		root.punycode = punycode;
	}

}(this));

}).call(this,typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{}],19:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

'use strict';

// If obj.hasOwnProperty has been overridden, then calling
// obj.hasOwnProperty(prop) will break.
// See: https://github.com/joyent/node/issues/1707
function hasOwnProperty(obj, prop) {
  return Object.prototype.hasOwnProperty.call(obj, prop);
}

module.exports = function(qs, sep, eq, options) {
  sep = sep || '&';
  eq = eq || '=';
  var obj = {};

  if (typeof qs !== 'string' || qs.length === 0) {
    return obj;
  }

  var regexp = /\+/g;
  qs = qs.split(sep);

  var maxKeys = 1000;
  if (options && typeof options.maxKeys === 'number') {
    maxKeys = options.maxKeys;
  }

  var len = qs.length;
  // maxKeys <= 0 means that we should not limit keys count
  if (maxKeys > 0 && len > maxKeys) {
    len = maxKeys;
  }

  for (var i = 0; i < len; ++i) {
    var x = qs[i].replace(regexp, '%20'),
        idx = x.indexOf(eq),
        kstr, vstr, k, v;

    if (idx >= 0) {
      kstr = x.substr(0, idx);
      vstr = x.substr(idx + 1);
    } else {
      kstr = x;
      vstr = '';
    }

    k = decodeURIComponent(kstr);
    v = decodeURIComponent(vstr);

    if (!hasOwnProperty(obj, k)) {
      obj[k] = v;
    } else if (isArray(obj[k])) {
      obj[k].push(v);
    } else {
      obj[k] = [obj[k], v];
    }
  }

  return obj;
};

var isArray = Array.isArray || function (xs) {
  return Object.prototype.toString.call(xs) === '[object Array]';
};

},{}],20:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

'use strict';

var stringifyPrimitive = function(v) {
  switch (typeof v) {
    case 'string':
      return v;

    case 'boolean':
      return v ? 'true' : 'false';

    case 'number':
      return isFinite(v) ? v : '';

    default:
      return '';
  }
};

module.exports = function(obj, sep, eq, name) {
  sep = sep || '&';
  eq = eq || '=';
  if (obj === null) {
    obj = undefined;
  }

  if (typeof obj === 'object') {
    return map(objectKeys(obj), function(k) {
      var ks = encodeURIComponent(stringifyPrimitive(k)) + eq;
      if (isArray(obj[k])) {
        return obj[k].map(function(v) {
          return ks + encodeURIComponent(stringifyPrimitive(v));
        }).join(sep);
      } else {
        return ks + encodeURIComponent(stringifyPrimitive(obj[k]));
      }
    }).join(sep);

  }

  if (!name) return '';
  return encodeURIComponent(stringifyPrimitive(name)) + eq +
         encodeURIComponent(stringifyPrimitive(obj));
};

var isArray = Array.isArray || function (xs) {
  return Object.prototype.toString.call(xs) === '[object Array]';
};

function map (xs, f) {
  if (xs.map) return xs.map(f);
  var res = [];
  for (var i = 0; i < xs.length; i++) {
    res.push(f(xs[i], i));
  }
  return res;
}

var objectKeys = Object.keys || function (obj) {
  var res = [];
  for (var key in obj) {
    if (Object.prototype.hasOwnProperty.call(obj, key)) res.push(key);
  }
  return res;
};

},{}],21:[function(require,module,exports){
'use strict';

exports.decode = exports.parse = require('./decode');
exports.encode = exports.stringify = require('./encode');

},{"./decode":19,"./encode":20}],22:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// a duplex stream is just a stream that is both readable and writable.
// Since JS doesn't have multiple prototypal inheritance, this class
// prototypally inherits from Readable, and then parasitically from
// Writable.

module.exports = Duplex;
var inherits = require('inherits');
var setImmediate = require('process/browser.js').nextTick;
var Readable = require('./readable.js');
var Writable = require('./writable.js');

inherits(Duplex, Readable);

Duplex.prototype.write = Writable.prototype.write;
Duplex.prototype.end = Writable.prototype.end;
Duplex.prototype._write = Writable.prototype._write;

function Duplex(options) {
  if (!(this instanceof Duplex))
    return new Duplex(options);

  Readable.call(this, options);
  Writable.call(this, options);

  if (options && options.readable === false)
    this.readable = false;

  if (options && options.writable === false)
    this.writable = false;

  this.allowHalfOpen = true;
  if (options && options.allowHalfOpen === false)
    this.allowHalfOpen = false;

  this.once('end', onend);
}

// the no-half-open enforcer
function onend() {
  // if we allow half-open state, or if the writable side ended,
  // then we're ok.
  if (this.allowHalfOpen || this._writableState.ended)
    return;

  // no more data can be written.
  // But allow more writes to happen in this tick.
  var self = this;
  setImmediate(function () {
    self.end();
  });
}

},{"./readable.js":26,"./writable.js":28,"inherits":36,"process/browser.js":24}],23:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

module.exports = Stream;

var EE = require('events').EventEmitter;
var inherits = require('inherits');

inherits(Stream, EE);
Stream.Readable = require('./readable.js');
Stream.Writable = require('./writable.js');
Stream.Duplex = require('./duplex.js');
Stream.Transform = require('./transform.js');
Stream.PassThrough = require('./passthrough.js');

// Backwards-compat with node 0.4.x
Stream.Stream = Stream;



// old-style streams.  Note that the pipe method (the only relevant
// part of this class) is overridden in the Readable class.

function Stream() {
  EE.call(this);
}

Stream.prototype.pipe = function(dest, options) {
  var source = this;

  function ondata(chunk) {
    if (dest.writable) {
      if (false === dest.write(chunk) && source.pause) {
        source.pause();
      }
    }
  }

  source.on('data', ondata);

  function ondrain() {
    if (source.readable && source.resume) {
      source.resume();
    }
  }

  dest.on('drain', ondrain);

  // If the 'end' option is not supplied, dest.end() will be called when
  // source gets the 'end' or 'close' events.  Only dest.end() once.
  if (!dest._isStdio && (!options || options.end !== false)) {
    source.on('end', onend);
    source.on('close', onclose);
  }

  var didOnEnd = false;
  function onend() {
    if (didOnEnd) return;
    didOnEnd = true;

    dest.end();
  }


  function onclose() {
    if (didOnEnd) return;
    didOnEnd = true;

    if (typeof dest.destroy === 'function') dest.destroy();
  }

  // don't leave dangling pipes when there are errors.
  function onerror(er) {
    cleanup();
    if (EE.listenerCount(this, 'error') === 0) {
      throw er; // Unhandled stream error in pipe.
    }
  }

  source.on('error', onerror);
  dest.on('error', onerror);

  // remove all the event listeners that were added.
  function cleanup() {
    source.removeListener('data', ondata);
    dest.removeListener('drain', ondrain);

    source.removeListener('end', onend);
    source.removeListener('close', onclose);

    source.removeListener('error', onerror);
    dest.removeListener('error', onerror);

    source.removeListener('end', cleanup);
    source.removeListener('close', cleanup);

    dest.removeListener('close', cleanup);
  }

  source.on('end', cleanup);
  source.on('close', cleanup);

  dest.on('close', cleanup);

  dest.emit('pipe', source);

  // Allow for unix-like usage: A.pipe(B).pipe(C)
  return dest;
};

},{"./duplex.js":22,"./passthrough.js":25,"./readable.js":26,"./transform.js":27,"./writable.js":28,"events":16,"inherits":36}],24:[function(require,module,exports){
// shim for using process in browser

var process = module.exports = {};

process.nextTick = (function () {
    var canSetImmediate = typeof window !== 'undefined'
    && window.setImmediate;
    var canPost = typeof window !== 'undefined'
    && window.postMessage && window.addEventListener
    ;

    if (canSetImmediate) {
        return function (f) { return window.setImmediate(f) };
    }

    if (canPost) {
        var queue = [];
        window.addEventListener('message', function (ev) {
            var source = ev.source;
            if ((source === window || source === null) && ev.data === 'process-tick') {
                ev.stopPropagation();
                if (queue.length > 0) {
                    var fn = queue.shift();
                    fn();
                }
            }
        }, true);

        return function nextTick(fn) {
            queue.push(fn);
            window.postMessage('process-tick', '*');
        };
    }

    return function nextTick(fn) {
        setTimeout(fn, 0);
    };
})();

process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];

process.binding = function (name) {
    throw new Error('process.binding is not supported');
}

// TODO(shtylman)
process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};

},{}],25:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// a passthrough stream.
// basically just the most minimal sort of Transform stream.
// Every written chunk gets output as-is.

module.exports = PassThrough;

var Transform = require('./transform.js');
var inherits = require('inherits');
inherits(PassThrough, Transform);

function PassThrough(options) {
  if (!(this instanceof PassThrough))
    return new PassThrough(options);

  Transform.call(this, options);
}

PassThrough.prototype._transform = function(chunk, encoding, cb) {
  cb(null, chunk);
};

},{"./transform.js":27,"inherits":36}],26:[function(require,module,exports){
(function (process){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

module.exports = Readable;
Readable.ReadableState = ReadableState;

var EE = require('events').EventEmitter;
var Stream = require('./index.js');
var Buffer = require('buffer').Buffer;
var setImmediate = require('process/browser.js').nextTick;
var StringDecoder;

var inherits = require('inherits');
inherits(Readable, Stream);

function ReadableState(options, stream) {
  options = options || {};

  // the point at which it stops calling _read() to fill the buffer
  // Note: 0 is a valid value, means "don't call _read preemptively ever"
  var hwm = options.highWaterMark;
  this.highWaterMark = (hwm || hwm === 0) ? hwm : 16 * 1024;

  // cast to ints.
  this.highWaterMark = ~~this.highWaterMark;

  this.buffer = [];
  this.length = 0;
  this.pipes = null;
  this.pipesCount = 0;
  this.flowing = false;
  this.ended = false;
  this.endEmitted = false;
  this.reading = false;

  // In streams that never have any data, and do push(null) right away,
  // the consumer can miss the 'end' event if they do some I/O before
  // consuming the stream.  So, we don't emit('end') until some reading
  // happens.
  this.calledRead = false;

  // a flag to be able to tell if the onwrite cb is called immediately,
  // or on a later tick.  We set this to true at first, becuase any
  // actions that shouldn't happen until "later" should generally also
  // not happen before the first write call.
  this.sync = true;

  // whenever we return null, then we set a flag to say
  // that we're awaiting a 'readable' event emission.
  this.needReadable = false;
  this.emittedReadable = false;
  this.readableListening = false;


  // object stream flag. Used to make read(n) ignore n and to
  // make all the buffer merging and length checks go away
  this.objectMode = !!options.objectMode;

  // Crypto is kind of old and crusty.  Historically, its default string
  // encoding is 'binary' so we have to make this configurable.
  // Everything else in the universe uses 'utf8', though.
  this.defaultEncoding = options.defaultEncoding || 'utf8';

  // when piping, we only care about 'readable' events that happen
  // after read()ing all the bytes and not getting any pushback.
  this.ranOut = false;

  // the number of writers that are awaiting a drain event in .pipe()s
  this.awaitDrain = 0;

  // if true, a maybeReadMore has been scheduled
  this.readingMore = false;

  this.decoder = null;
  this.encoding = null;
  if (options.encoding) {
    if (!StringDecoder)
      StringDecoder = require('string_decoder').StringDecoder;
    this.decoder = new StringDecoder(options.encoding);
    this.encoding = options.encoding;
  }
}

function Readable(options) {
  if (!(this instanceof Readable))
    return new Readable(options);

  this._readableState = new ReadableState(options, this);

  // legacy
  this.readable = true;

  Stream.call(this);
}

// Manually shove something into the read() buffer.
// This returns true if the highWaterMark has not been hit yet,
// similar to how Writable.write() returns true if you should
// write() some more.
Readable.prototype.push = function(chunk, encoding) {
  var state = this._readableState;

  if (typeof chunk === 'string' && !state.objectMode) {
    encoding = encoding || state.defaultEncoding;
    if (encoding !== state.encoding) {
      chunk = new Buffer(chunk, encoding);
      encoding = '';
    }
  }

  return readableAddChunk(this, state, chunk, encoding, false);
};

// Unshift should *always* be something directly out of read()
Readable.prototype.unshift = function(chunk) {
  var state = this._readableState;
  return readableAddChunk(this, state, chunk, '', true);
};

function readableAddChunk(stream, state, chunk, encoding, addToFront) {
  var er = chunkInvalid(state, chunk);
  if (er) {
    stream.emit('error', er);
  } else if (chunk === null || chunk === undefined) {
    state.reading = false;
    if (!state.ended)
      onEofChunk(stream, state);
  } else if (state.objectMode || chunk && chunk.length > 0) {
    if (state.ended && !addToFront) {
      var e = new Error('stream.push() after EOF');
      stream.emit('error', e);
    } else if (state.endEmitted && addToFront) {
      var e = new Error('stream.unshift() after end event');
      stream.emit('error', e);
    } else {
      if (state.decoder && !addToFront && !encoding)
        chunk = state.decoder.write(chunk);

      // update the buffer info.
      state.length += state.objectMode ? 1 : chunk.length;
      if (addToFront) {
        state.buffer.unshift(chunk);
      } else {
        state.reading = false;
        state.buffer.push(chunk);
      }

      if (state.needReadable)
        emitReadable(stream);

      maybeReadMore(stream, state);
    }
  } else if (!addToFront) {
    state.reading = false;
  }

  return needMoreData(state);
}



// if it's past the high water mark, we can push in some more.
// Also, if we have no data yet, we can stand some
// more bytes.  This is to work around cases where hwm=0,
// such as the repl.  Also, if the push() triggered a
// readable event, and the user called read(largeNumber) such that
// needReadable was set, then we ought to push more, so that another
// 'readable' event will be triggered.
function needMoreData(state) {
  return !state.ended &&
         (state.needReadable ||
          state.length < state.highWaterMark ||
          state.length === 0);
}

// backwards compatibility.
Readable.prototype.setEncoding = function(enc) {
  if (!StringDecoder)
    StringDecoder = require('string_decoder').StringDecoder;
  this._readableState.decoder = new StringDecoder(enc);
  this._readableState.encoding = enc;
};

// Don't raise the hwm > 128MB
var MAX_HWM = 0x800000;
function roundUpToNextPowerOf2(n) {
  if (n >= MAX_HWM) {
    n = MAX_HWM;
  } else {
    // Get the next highest power of 2
    n--;
    for (var p = 1; p < 32; p <<= 1) n |= n >> p;
    n++;
  }
  return n;
}

function howMuchToRead(n, state) {
  if (state.length === 0 && state.ended)
    return 0;

  if (state.objectMode)
    return n === 0 ? 0 : 1;

  if (isNaN(n) || n === null) {
    // only flow one buffer at a time
    if (state.flowing && state.buffer.length)
      return state.buffer[0].length;
    else
      return state.length;
  }

  if (n <= 0)
    return 0;

  // If we're asking for more than the target buffer level,
  // then raise the water mark.  Bump up to the next highest
  // power of 2, to prevent increasing it excessively in tiny
  // amounts.
  if (n > state.highWaterMark)
    state.highWaterMark = roundUpToNextPowerOf2(n);

  // don't have that much.  return null, unless we've ended.
  if (n > state.length) {
    if (!state.ended) {
      state.needReadable = true;
      return 0;
    } else
      return state.length;
  }

  return n;
}

// you can override either this method, or the async _read(n) below.
Readable.prototype.read = function(n) {
  var state = this._readableState;
  state.calledRead = true;
  var nOrig = n;

  if (typeof n !== 'number' || n > 0)
    state.emittedReadable = false;

  // if we're doing read(0) to trigger a readable event, but we
  // already have a bunch of data in the buffer, then just trigger
  // the 'readable' event and move on.
  if (n === 0 &&
      state.needReadable &&
      (state.length >= state.highWaterMark || state.ended)) {
    emitReadable(this);
    return null;
  }

  n = howMuchToRead(n, state);

  // if we've ended, and we're now clear, then finish it up.
  if (n === 0 && state.ended) {
    if (state.length === 0)
      endReadable(this);
    return null;
  }

  // All the actual chunk generation logic needs to be
  // *below* the call to _read.  The reason is that in certain
  // synthetic stream cases, such as passthrough streams, _read
  // may be a completely synchronous operation which may change
  // the state of the read buffer, providing enough data when
  // before there was *not* enough.
  //
  // So, the steps are:
  // 1. Figure out what the state of things will be after we do
  // a read from the buffer.
  //
  // 2. If that resulting state will trigger a _read, then call _read.
  // Note that this may be asynchronous, or synchronous.  Yes, it is
  // deeply ugly to write APIs this way, but that still doesn't mean
  // that the Readable class should behave improperly, as streams are
  // designed to be sync/async agnostic.
  // Take note if the _read call is sync or async (ie, if the read call
  // has returned yet), so that we know whether or not it's safe to emit
  // 'readable' etc.
  //
  // 3. Actually pull the requested chunks out of the buffer and return.

  // if we need a readable event, then we need to do some reading.
  var doRead = state.needReadable;

  // if we currently have less than the highWaterMark, then also read some
  if (state.length - n <= state.highWaterMark)
    doRead = true;

  // however, if we've ended, then there's no point, and if we're already
  // reading, then it's unnecessary.
  if (state.ended || state.reading)
    doRead = false;

  if (doRead) {
    state.reading = true;
    state.sync = true;
    // if the length is currently zero, then we *need* a readable event.
    if (state.length === 0)
      state.needReadable = true;
    // call internal read method
    this._read(state.highWaterMark);
    state.sync = false;
  }

  // If _read called its callback synchronously, then `reading`
  // will be false, and we need to re-evaluate how much data we
  // can return to the user.
  if (doRead && !state.reading)
    n = howMuchToRead(nOrig, state);

  var ret;
  if (n > 0)
    ret = fromList(n, state);
  else
    ret = null;

  if (ret === null) {
    state.needReadable = true;
    n = 0;
  }

  state.length -= n;

  // If we have nothing in the buffer, then we want to know
  // as soon as we *do* get something into the buffer.
  if (state.length === 0 && !state.ended)
    state.needReadable = true;

  // If we happened to read() exactly the remaining amount in the
  // buffer, and the EOF has been seen at this point, then make sure
  // that we emit 'end' on the very next tick.
  if (state.ended && !state.endEmitted && state.length === 0)
    endReadable(this);

  return ret;
};

function chunkInvalid(state, chunk) {
  var er = null;
  if (!Buffer.isBuffer(chunk) &&
      'string' !== typeof chunk &&
      chunk !== null &&
      chunk !== undefined &&
      !state.objectMode &&
      !er) {
    er = new TypeError('Invalid non-string/buffer chunk');
  }
  return er;
}


function onEofChunk(stream, state) {
  if (state.decoder && !state.ended) {
    var chunk = state.decoder.end();
    if (chunk && chunk.length) {
      state.buffer.push(chunk);
      state.length += state.objectMode ? 1 : chunk.length;
    }
  }
  state.ended = true;

  // if we've ended and we have some data left, then emit
  // 'readable' now to make sure it gets picked up.
  if (state.length > 0)
    emitReadable(stream);
  else
    endReadable(stream);
}

// Don't emit readable right away in sync mode, because this can trigger
// another read() call => stack overflow.  This way, it might trigger
// a nextTick recursion warning, but that's not so bad.
function emitReadable(stream) {
  var state = stream._readableState;
  state.needReadable = false;
  if (state.emittedReadable)
    return;

  state.emittedReadable = true;
  if (state.sync)
    setImmediate(function() {
      emitReadable_(stream);
    });
  else
    emitReadable_(stream);
}

function emitReadable_(stream) {
  stream.emit('readable');
}


// at this point, the user has presumably seen the 'readable' event,
// and called read() to consume some data.  that may have triggered
// in turn another _read(n) call, in which case reading = true if
// it's in progress.
// However, if we're not ended, or reading, and the length < hwm,
// then go ahead and try to read some more preemptively.
function maybeReadMore(stream, state) {
  if (!state.readingMore) {
    state.readingMore = true;
    setImmediate(function() {
      maybeReadMore_(stream, state);
    });
  }
}

function maybeReadMore_(stream, state) {
  var len = state.length;
  while (!state.reading && !state.flowing && !state.ended &&
         state.length < state.highWaterMark) {
    stream.read(0);
    if (len === state.length)
      // didn't get any data, stop spinning.
      break;
    else
      len = state.length;
  }
  state.readingMore = false;
}

// abstract method.  to be overridden in specific implementation classes.
// call cb(er, data) where data is <= n in length.
// for virtual (non-string, non-buffer) streams, "length" is somewhat
// arbitrary, and perhaps not very meaningful.
Readable.prototype._read = function(n) {
  this.emit('error', new Error('not implemented'));
};

Readable.prototype.pipe = function(dest, pipeOpts) {
  var src = this;
  var state = this._readableState;

  switch (state.pipesCount) {
    case 0:
      state.pipes = dest;
      break;
    case 1:
      state.pipes = [state.pipes, dest];
      break;
    default:
      state.pipes.push(dest);
      break;
  }
  state.pipesCount += 1;

  var doEnd = (!pipeOpts || pipeOpts.end !== false) &&
              dest !== process.stdout &&
              dest !== process.stderr;

  var endFn = doEnd ? onend : cleanup;
  if (state.endEmitted)
    setImmediate(endFn);
  else
    src.once('end', endFn);

  dest.on('unpipe', onunpipe);
  function onunpipe(readable) {
    if (readable !== src) return;
    cleanup();
  }

  function onend() {
    dest.end();
  }

  // when the dest drains, it reduces the awaitDrain counter
  // on the source.  This would be more elegant with a .once()
  // handler in flow(), but adding and removing repeatedly is
  // too slow.
  var ondrain = pipeOnDrain(src);
  dest.on('drain', ondrain);

  function cleanup() {
    // cleanup event handlers once the pipe is broken
    dest.removeListener('close', onclose);
    dest.removeListener('finish', onfinish);
    dest.removeListener('drain', ondrain);
    dest.removeListener('error', onerror);
    dest.removeListener('unpipe', onunpipe);
    src.removeListener('end', onend);
    src.removeListener('end', cleanup);

    // if the reader is waiting for a drain event from this
    // specific writer, then it would cause it to never start
    // flowing again.
    // So, if this is awaiting a drain, then we just call it now.
    // If we don't know, then assume that we are waiting for one.
    if (!dest._writableState || dest._writableState.needDrain)
      ondrain();
  }

  // if the dest has an error, then stop piping into it.
  // however, don't suppress the throwing behavior for this.
  // check for listeners before emit removes one-time listeners.
  var errListeners = EE.listenerCount(dest, 'error');
  function onerror(er) {
    unpipe();
    if (errListeners === 0 && EE.listenerCount(dest, 'error') === 0)
      dest.emit('error', er);
  }
  dest.once('error', onerror);

  // Both close and finish should trigger unpipe, but only once.
  function onclose() {
    dest.removeListener('finish', onfinish);
    unpipe();
  }
  dest.once('close', onclose);
  function onfinish() {
    dest.removeListener('close', onclose);
    unpipe();
  }
  dest.once('finish', onfinish);

  function unpipe() {
    src.unpipe(dest);
  }

  // tell the dest that it's being piped to
  dest.emit('pipe', src);

  // start the flow if it hasn't been started already.
  if (!state.flowing) {
    // the handler that waits for readable events after all
    // the data gets sucked out in flow.
    // This would be easier to follow with a .once() handler
    // in flow(), but that is too slow.
    this.on('readable', pipeOnReadable);

    state.flowing = true;
    setImmediate(function() {
      flow(src);
    });
  }

  return dest;
};

function pipeOnDrain(src) {
  return function() {
    var dest = this;
    var state = src._readableState;
    state.awaitDrain--;
    if (state.awaitDrain === 0)
      flow(src);
  };
}

function flow(src) {
  var state = src._readableState;
  var chunk;
  state.awaitDrain = 0;

  function write(dest, i, list) {
    var written = dest.write(chunk);
    if (false === written) {
      state.awaitDrain++;
    }
  }

  while (state.pipesCount && null !== (chunk = src.read())) {

    if (state.pipesCount === 1)
      write(state.pipes, 0, null);
    else
      forEach(state.pipes, write);

    src.emit('data', chunk);

    // if anyone needs a drain, then we have to wait for that.
    if (state.awaitDrain > 0)
      return;
  }

  // if every destination was unpiped, either before entering this
  // function, or in the while loop, then stop flowing.
  //
  // NB: This is a pretty rare edge case.
  if (state.pipesCount === 0) {
    state.flowing = false;

    // if there were data event listeners added, then switch to old mode.
    if (EE.listenerCount(src, 'data') > 0)
      emitDataEvents(src);
    return;
  }

  // at this point, no one needed a drain, so we just ran out of data
  // on the next readable event, start it over again.
  state.ranOut = true;
}

function pipeOnReadable() {
  if (this._readableState.ranOut) {
    this._readableState.ranOut = false;
    flow(this);
  }
}


Readable.prototype.unpipe = function(dest) {
  var state = this._readableState;

  // if we're not piping anywhere, then do nothing.
  if (state.pipesCount === 0)
    return this;

  // just one destination.  most common case.
  if (state.pipesCount === 1) {
    // passed in one, but it's not the right one.
    if (dest && dest !== state.pipes)
      return this;

    if (!dest)
      dest = state.pipes;

    // got a match.
    state.pipes = null;
    state.pipesCount = 0;
    this.removeListener('readable', pipeOnReadable);
    state.flowing = false;
    if (dest)
      dest.emit('unpipe', this);
    return this;
  }

  // slow case. multiple pipe destinations.

  if (!dest) {
    // remove all.
    var dests = state.pipes;
    var len = state.pipesCount;
    state.pipes = null;
    state.pipesCount = 0;
    this.removeListener('readable', pipeOnReadable);
    state.flowing = false;

    for (var i = 0; i < len; i++)
      dests[i].emit('unpipe', this);
    return this;
  }

  // try to find the right one.
  var i = indexOf(state.pipes, dest);
  if (i === -1)
    return this;

  state.pipes.splice(i, 1);
  state.pipesCount -= 1;
  if (state.pipesCount === 1)
    state.pipes = state.pipes[0];

  dest.emit('unpipe', this);

  return this;
};

// set up data events if they are asked for
// Ensure readable listeners eventually get something
Readable.prototype.on = function(ev, fn) {
  var res = Stream.prototype.on.call(this, ev, fn);

  if (ev === 'data' && !this._readableState.flowing)
    emitDataEvents(this);

  if (ev === 'readable' && this.readable) {
    var state = this._readableState;
    if (!state.readableListening) {
      state.readableListening = true;
      state.emittedReadable = false;
      state.needReadable = true;
      if (!state.reading) {
        this.read(0);
      } else if (state.length) {
        emitReadable(this, state);
      }
    }
  }

  return res;
};
Readable.prototype.addListener = Readable.prototype.on;

// pause() and resume() are remnants of the legacy readable stream API
// If the user uses them, then switch into old mode.
Readable.prototype.resume = function() {
  emitDataEvents(this);
  this.read(0);
  this.emit('resume');
};

Readable.prototype.pause = function() {
  emitDataEvents(this, true);
  this.emit('pause');
};

function emitDataEvents(stream, startPaused) {
  var state = stream._readableState;

  if (state.flowing) {
    // https://github.com/isaacs/readable-stream/issues/16
    throw new Error('Cannot switch to old mode now.');
  }

  var paused = startPaused || false;
  var readable = false;

  // convert to an old-style stream.
  stream.readable = true;
  stream.pipe = Stream.prototype.pipe;
  stream.on = stream.addListener = Stream.prototype.on;

  stream.on('readable', function() {
    readable = true;

    var c;
    while (!paused && (null !== (c = stream.read())))
      stream.emit('data', c);

    if (c === null) {
      readable = false;
      stream._readableState.needReadable = true;
    }
  });

  stream.pause = function() {
    paused = true;
    this.emit('pause');
  };

  stream.resume = function() {
    paused = false;
    if (readable)
      setImmediate(function() {
        stream.emit('readable');
      });
    else
      this.read(0);
    this.emit('resume');
  };

  // now make it start, just in case it hadn't already.
  stream.emit('readable');
}

// wrap an old-style stream as the async data source.
// This is *not* part of the readable stream interface.
// It is an ugly unfortunate mess of history.
Readable.prototype.wrap = function(stream) {
  var state = this._readableState;
  var paused = false;

  var self = this;
  stream.on('end', function() {
    if (state.decoder && !state.ended) {
      var chunk = state.decoder.end();
      if (chunk && chunk.length)
        self.push(chunk);
    }

    self.push(null);
  });

  stream.on('data', function(chunk) {
    if (state.decoder)
      chunk = state.decoder.write(chunk);
    if (!chunk || !state.objectMode && !chunk.length)
      return;

    var ret = self.push(chunk);
    if (!ret) {
      paused = true;
      stream.pause();
    }
  });

  // proxy all the other methods.
  // important when wrapping filters and duplexes.
  for (var i in stream) {
    if (typeof stream[i] === 'function' &&
        typeof this[i] === 'undefined') {
      this[i] = function(method) { return function() {
        return stream[method].apply(stream, arguments);
      }}(i);
    }
  }

  // proxy certain important events.
  var events = ['error', 'close', 'destroy', 'pause', 'resume'];
  forEach(events, function(ev) {
    stream.on(ev, function (x) {
      return self.emit.apply(self, ev, x);
    });
  });

  // when we try to consume some more bytes, simply unpause the
  // underlying stream.
  self._read = function(n) {
    if (paused) {
      paused = false;
      stream.resume();
    }
  };

  return self;
};



// exposed for testing purposes only.
Readable._fromList = fromList;

// Pluck off n bytes from an array of buffers.
// Length is the combined lengths of all the buffers in the list.
function fromList(n, state) {
  var list = state.buffer;
  var length = state.length;
  var stringMode = !!state.decoder;
  var objectMode = !!state.objectMode;
  var ret;

  // nothing in the list, definitely empty.
  if (list.length === 0)
    return null;

  if (length === 0)
    ret = null;
  else if (objectMode)
    ret = list.shift();
  else if (!n || n >= length) {
    // read it all, truncate the array.
    if (stringMode)
      ret = list.join('');
    else
      ret = Buffer.concat(list, length);
    list.length = 0;
  } else {
    // read just some of it.
    if (n < list[0].length) {
      // just take a part of the first list item.
      // slice is the same for buffers and strings.
      var buf = list[0];
      ret = buf.slice(0, n);
      list[0] = buf.slice(n);
    } else if (n === list[0].length) {
      // first list is a perfect match
      ret = list.shift();
    } else {
      // complex case.
      // we have enough to cover it, but it spans past the first buffer.
      if (stringMode)
        ret = '';
      else
        ret = new Buffer(n);

      var c = 0;
      for (var i = 0, l = list.length; i < l && c < n; i++) {
        var buf = list[0];
        var cpy = Math.min(n - c, buf.length);

        if (stringMode)
          ret += buf.slice(0, cpy);
        else
          buf.copy(ret, c, 0, cpy);

        if (cpy < buf.length)
          list[0] = buf.slice(cpy);
        else
          list.shift();

        c += cpy;
      }
    }
  }

  return ret;
}

function endReadable(stream) {
  var state = stream._readableState;

  // If we get here before consuming all the bytes, then that is a
  // bug in node.  Should never happen.
  if (state.length > 0)
    throw new Error('endReadable called on non-empty stream');

  if (!state.endEmitted && state.calledRead) {
    state.ended = true;
    setImmediate(function() {
      // Check that we didn't get one last unshift.
      if (!state.endEmitted && state.length === 0) {
        state.endEmitted = true;
        stream.readable = false;
        stream.emit('end');
      }
    });
  }
}

function forEach (xs, f) {
  for (var i = 0, l = xs.length; i < l; i++) {
    f(xs[i], i);
  }
}

function indexOf (xs, x) {
  for (var i = 0, l = xs.length; i < l; i++) {
    if (xs[i] === x) return i;
  }
  return -1;
}

}).call(this,require("7YKIPe"))
},{"./index.js":23,"7YKIPe":17,"buffer":9,"events":16,"inherits":36,"process/browser.js":24,"string_decoder":29}],27:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// a transform stream is a readable/writable stream where you do
// something with the data.  Sometimes it's called a "filter",
// but that's not a great name for it, since that implies a thing where
// some bits pass through, and others are simply ignored.  (That would
// be a valid example of a transform, of course.)
//
// While the output is causally related to the input, it's not a
// necessarily symmetric or synchronous transformation.  For example,
// a zlib stream might take multiple plain-text writes(), and then
// emit a single compressed chunk some time in the future.
//
// Here's how this works:
//
// The Transform stream has all the aspects of the readable and writable
// stream classes.  When you write(chunk), that calls _write(chunk,cb)
// internally, and returns false if there's a lot of pending writes
// buffered up.  When you call read(), that calls _read(n) until
// there's enough pending readable data buffered up.
//
// In a transform stream, the written data is placed in a buffer.  When
// _read(n) is called, it transforms the queued up data, calling the
// buffered _write cb's as it consumes chunks.  If consuming a single
// written chunk would result in multiple output chunks, then the first
// outputted bit calls the readcb, and subsequent chunks just go into
// the read buffer, and will cause it to emit 'readable' if necessary.
//
// This way, back-pressure is actually determined by the reading side,
// since _read has to be called to start processing a new chunk.  However,
// a pathological inflate type of transform can cause excessive buffering
// here.  For example, imagine a stream where every byte of input is
// interpreted as an integer from 0-255, and then results in that many
// bytes of output.  Writing the 4 bytes {ff,ff,ff,ff} would result in
// 1kb of data being output.  In this case, you could write a very small
// amount of input, and end up with a very large amount of output.  In
// such a pathological inflating mechanism, there'd be no way to tell
// the system to stop doing the transform.  A single 4MB write could
// cause the system to run out of memory.
//
// However, even in such a pathological case, only a single written chunk
// would be consumed, and then the rest would wait (un-transformed) until
// the results of the previous transformed chunk were consumed.

module.exports = Transform;

var Duplex = require('./duplex.js');
var inherits = require('inherits');
inherits(Transform, Duplex);


function TransformState(options, stream) {
  this.afterTransform = function(er, data) {
    return afterTransform(stream, er, data);
  };

  this.needTransform = false;
  this.transforming = false;
  this.writecb = null;
  this.writechunk = null;
}

function afterTransform(stream, er, data) {
  var ts = stream._transformState;
  ts.transforming = false;

  var cb = ts.writecb;

  if (!cb)
    return stream.emit('error', new Error('no writecb in Transform class'));

  ts.writechunk = null;
  ts.writecb = null;

  if (data !== null && data !== undefined)
    stream.push(data);

  if (cb)
    cb(er);

  var rs = stream._readableState;
  rs.reading = false;
  if (rs.needReadable || rs.length < rs.highWaterMark) {
    stream._read(rs.highWaterMark);
  }
}


function Transform(options) {
  if (!(this instanceof Transform))
    return new Transform(options);

  Duplex.call(this, options);

  var ts = this._transformState = new TransformState(options, this);

  // when the writable side finishes, then flush out anything remaining.
  var stream = this;

  // start out asking for a readable event once data is transformed.
  this._readableState.needReadable = true;

  // we have implemented the _read method, and done the other things
  // that Readable wants before the first _read call, so unset the
  // sync guard flag.
  this._readableState.sync = false;

  this.once('finish', function() {
    if ('function' === typeof this._flush)
      this._flush(function(er) {
        done(stream, er);
      });
    else
      done(stream);
  });
}

Transform.prototype.push = function(chunk, encoding) {
  this._transformState.needTransform = false;
  return Duplex.prototype.push.call(this, chunk, encoding);
};

// This is the part where you do stuff!
// override this function in implementation classes.
// 'chunk' is an input chunk.
//
// Call `push(newChunk)` to pass along transformed output
// to the readable side.  You may call 'push' zero or more times.
//
// Call `cb(err)` when you are done with this chunk.  If you pass
// an error, then that'll put the hurt on the whole operation.  If you
// never call cb(), then you'll never get another chunk.
Transform.prototype._transform = function(chunk, encoding, cb) {
  throw new Error('not implemented');
};

Transform.prototype._write = function(chunk, encoding, cb) {
  var ts = this._transformState;
  ts.writecb = cb;
  ts.writechunk = chunk;
  ts.writeencoding = encoding;
  if (!ts.transforming) {
    var rs = this._readableState;
    if (ts.needTransform ||
        rs.needReadable ||
        rs.length < rs.highWaterMark)
      this._read(rs.highWaterMark);
  }
};

// Doesn't matter what the args are here.
// _transform does all the work.
// That we got here means that the readable side wants more data.
Transform.prototype._read = function(n) {
  var ts = this._transformState;

  if (ts.writechunk && ts.writecb && !ts.transforming) {
    ts.transforming = true;
    this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);
  } else {
    // mark that we need a transform, so that any data that comes in
    // will get processed, now that we've asked for it.
    ts.needTransform = true;
  }
};


function done(stream, er) {
  if (er)
    return stream.emit('error', er);

  // if there's nothing in the write buffer, then that means
  // that nothing more will ever be provided
  var ws = stream._writableState;
  var rs = stream._readableState;
  var ts = stream._transformState;

  if (ws.length)
    throw new Error('calling transform done when ws.length != 0');

  if (ts.transforming)
    throw new Error('calling transform done when still transforming');

  return stream.push(null);
}

},{"./duplex.js":22,"inherits":36}],28:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// A bit simpler than readable streams.
// Implement an async ._write(chunk, cb), and it'll handle all
// the drain event emission and buffering.

module.exports = Writable;
Writable.WritableState = WritableState;

var isUint8Array = typeof Uint8Array !== 'undefined'
  ? function (x) { return x instanceof Uint8Array }
  : function (x) {
    return x && x.constructor && x.constructor.name === 'Uint8Array'
  }
;
var isArrayBuffer = typeof ArrayBuffer !== 'undefined'
  ? function (x) { return x instanceof ArrayBuffer }
  : function (x) {
    return x && x.constructor && x.constructor.name === 'ArrayBuffer'
  }
;

var inherits = require('inherits');
var Stream = require('./index.js');
var setImmediate = require('process/browser.js').nextTick;
var Buffer = require('buffer').Buffer;

inherits(Writable, Stream);

function WriteReq(chunk, encoding, cb) {
  this.chunk = chunk;
  this.encoding = encoding;
  this.callback = cb;
}

function WritableState(options, stream) {
  options = options || {};

  // the point at which write() starts returning false
  // Note: 0 is a valid value, means that we always return false if
  // the entire buffer is not flushed immediately on write()
  var hwm = options.highWaterMark;
  this.highWaterMark = (hwm || hwm === 0) ? hwm : 16 * 1024;

  // object stream flag to indicate whether or not this stream
  // contains buffers or objects.
  this.objectMode = !!options.objectMode;

  // cast to ints.
  this.highWaterMark = ~~this.highWaterMark;

  this.needDrain = false;
  // at the start of calling end()
  this.ending = false;
  // when end() has been called, and returned
  this.ended = false;
  // when 'finish' is emitted
  this.finished = false;

  // should we decode strings into buffers before passing to _write?
  // this is here so that some node-core streams can optimize string
  // handling at a lower level.
  var noDecode = options.decodeStrings === false;
  this.decodeStrings = !noDecode;

  // Crypto is kind of old and crusty.  Historically, its default string
  // encoding is 'binary' so we have to make this configurable.
  // Everything else in the universe uses 'utf8', though.
  this.defaultEncoding = options.defaultEncoding || 'utf8';

  // not an actual buffer we keep track of, but a measurement
  // of how much we're waiting to get pushed to some underlying
  // socket or file.
  this.length = 0;

  // a flag to see when we're in the middle of a write.
  this.writing = false;

  // a flag to be able to tell if the onwrite cb is called immediately,
  // or on a later tick.  We set this to true at first, becuase any
  // actions that shouldn't happen until "later" should generally also
  // not happen before the first write call.
  this.sync = true;

  // a flag to know if we're processing previously buffered items, which
  // may call the _write() callback in the same tick, so that we don't
  // end up in an overlapped onwrite situation.
  this.bufferProcessing = false;

  // the callback that's passed to _write(chunk,cb)
  this.onwrite = function(er) {
    onwrite(stream, er);
  };

  // the callback that the user supplies to write(chunk,encoding,cb)
  this.writecb = null;

  // the amount that is being written when _write is called.
  this.writelen = 0;

  this.buffer = [];
}

function Writable(options) {
  // Writable ctor is applied to Duplexes, though they're not
  // instanceof Writable, they're instanceof Readable.
  if (!(this instanceof Writable) && !(this instanceof Stream.Duplex))
    return new Writable(options);

  this._writableState = new WritableState(options, this);

  // legacy.
  this.writable = true;

  Stream.call(this);
}

// Otherwise people can pipe Writable streams, which is just wrong.
Writable.prototype.pipe = function() {
  this.emit('error', new Error('Cannot pipe. Not readable.'));
};


function writeAfterEnd(stream, state, cb) {
  var er = new Error('write after end');
  // TODO: defer error events consistently everywhere, not just the cb
  stream.emit('error', er);
  setImmediate(function() {
    cb(er);
  });
}

// If we get something that is not a buffer, string, null, or undefined,
// and we're not in objectMode, then that's an error.
// Otherwise stream chunks are all considered to be of length=1, and the
// watermarks determine how many objects to keep in the buffer, rather than
// how many bytes or characters.
function validChunk(stream, state, chunk, cb) {
  var valid = true;
  if (!Buffer.isBuffer(chunk) &&
      'string' !== typeof chunk &&
      chunk !== null &&
      chunk !== undefined &&
      !state.objectMode) {
    var er = new TypeError('Invalid non-string/buffer chunk');
    stream.emit('error', er);
    setImmediate(function() {
      cb(er);
    });
    valid = false;
  }
  return valid;
}

Writable.prototype.write = function(chunk, encoding, cb) {
  var state = this._writableState;
  var ret = false;

  if (typeof encoding === 'function') {
    cb = encoding;
    encoding = null;
  }

  if (!Buffer.isBuffer(chunk) && isUint8Array(chunk))
    chunk = new Buffer(chunk);
  if (isArrayBuffer(chunk) && typeof Uint8Array !== 'undefined')
    chunk = new Buffer(new Uint8Array(chunk));
  
  if (Buffer.isBuffer(chunk))
    encoding = 'buffer';
  else if (!encoding)
    encoding = state.defaultEncoding;

  if (typeof cb !== 'function')
    cb = function() {};

  if (state.ended)
    writeAfterEnd(this, state, cb);
  else if (validChunk(this, state, chunk, cb))
    ret = writeOrBuffer(this, state, chunk, encoding, cb);

  return ret;
};

function decodeChunk(state, chunk, encoding) {
  if (!state.objectMode &&
      state.decodeStrings !== false &&
      typeof chunk === 'string') {
    chunk = new Buffer(chunk, encoding);
  }
  return chunk;
}

// if we're already writing something, then just put this
// in the queue, and wait our turn.  Otherwise, call _write
// If we return false, then we need a drain event, so set that flag.
function writeOrBuffer(stream, state, chunk, encoding, cb) {
  chunk = decodeChunk(state, chunk, encoding);
  var len = state.objectMode ? 1 : chunk.length;

  state.length += len;

  var ret = state.length < state.highWaterMark;
  state.needDrain = !ret;

  if (state.writing)
    state.buffer.push(new WriteReq(chunk, encoding, cb));
  else
    doWrite(stream, state, len, chunk, encoding, cb);

  return ret;
}

function doWrite(stream, state, len, chunk, encoding, cb) {
  state.writelen = len;
  state.writecb = cb;
  state.writing = true;
  state.sync = true;
  stream._write(chunk, encoding, state.onwrite);
  state.sync = false;
}

function onwriteError(stream, state, sync, er, cb) {
  if (sync)
    setImmediate(function() {
      cb(er);
    });
  else
    cb(er);

  stream.emit('error', er);
}

function onwriteStateUpdate(state) {
  state.writing = false;
  state.writecb = null;
  state.length -= state.writelen;
  state.writelen = 0;
}

function onwrite(stream, er) {
  var state = stream._writableState;
  var sync = state.sync;
  var cb = state.writecb;

  onwriteStateUpdate(state);

  if (er)
    onwriteError(stream, state, sync, er, cb);
  else {
    // Check if we're actually ready to finish, but don't emit yet
    var finished = needFinish(stream, state);

    if (!finished && !state.bufferProcessing && state.buffer.length)
      clearBuffer(stream, state);

    if (sync) {
      setImmediate(function() {
        afterWrite(stream, state, finished, cb);
      });
    } else {
      afterWrite(stream, state, finished, cb);
    }
  }
}

function afterWrite(stream, state, finished, cb) {
  if (!finished)
    onwriteDrain(stream, state);
  cb();
  if (finished)
    finishMaybe(stream, state);
}

// Must force callback to be called on nextTick, so that we don't
// emit 'drain' before the write() consumer gets the 'false' return
// value, and has a chance to attach a 'drain' listener.
function onwriteDrain(stream, state) {
  if (state.length === 0 && state.needDrain) {
    state.needDrain = false;
    stream.emit('drain');
  }
}


// if there's something in the buffer waiting, then process it
function clearBuffer(stream, state) {
  state.bufferProcessing = true;

  for (var c = 0; c < state.buffer.length; c++) {
    var entry = state.buffer[c];
    var chunk = entry.chunk;
    var encoding = entry.encoding;
    var cb = entry.callback;
    var len = state.objectMode ? 1 : chunk.length;

    doWrite(stream, state, len, chunk, encoding, cb);

    // if we didn't call the onwrite immediately, then
    // it means that we need to wait until it does.
    // also, that means that the chunk and cb are currently
    // being processed, so move the buffer counter past them.
    if (state.writing) {
      c++;
      break;
    }
  }

  state.bufferProcessing = false;
  if (c < state.buffer.length)
    state.buffer = state.buffer.slice(c);
  else
    state.buffer.length = 0;
}

Writable.prototype._write = function(chunk, encoding, cb) {
  cb(new Error('not implemented'));
};

Writable.prototype.end = function(chunk, encoding, cb) {
  var state = this._writableState;

  if (typeof chunk === 'function') {
    cb = chunk;
    chunk = null;
    encoding = null;
  } else if (typeof encoding === 'function') {
    cb = encoding;
    encoding = null;
  }

  if (typeof chunk !== 'undefined' && chunk !== null)
    this.write(chunk, encoding);

  // ignore unnecessary end() calls.
  if (!state.ending && !state.finished)
    endWritable(this, state, cb);
};


function needFinish(stream, state) {
  return (state.ending &&
          state.length === 0 &&
          !state.finished &&
          !state.writing);
}

function finishMaybe(stream, state) {
  var need = needFinish(stream, state);
  if (need) {
    state.finished = true;
    stream.emit('finish');
  }
  return need;
}

function endWritable(stream, state, cb) {
  state.ending = true;
  finishMaybe(stream, state);
  if (cb) {
    if (state.finished)
      setImmediate(cb);
    else
      stream.once('finish', cb);
  }
  state.ended = true;
}

},{"./index.js":23,"buffer":9,"inherits":36,"process/browser.js":24}],29:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

var Buffer = require('buffer').Buffer;

function assertEncoding(encoding) {
  if (encoding && !Buffer.isEncoding(encoding)) {
    throw new Error('Unknown encoding: ' + encoding);
  }
}

var StringDecoder = exports.StringDecoder = function(encoding) {
  this.encoding = (encoding || 'utf8').toLowerCase().replace(/[-_]/, '');
  assertEncoding(encoding);
  switch (this.encoding) {
    case 'utf8':
      // CESU-8 represents each of Surrogate Pair by 3-bytes
      this.surrogateSize = 3;
      break;
    case 'ucs2':
    case 'utf16le':
      // UTF-16 represents each of Surrogate Pair by 2-bytes
      this.surrogateSize = 2;
      this.detectIncompleteChar = utf16DetectIncompleteChar;
      break;
    case 'base64':
      // Base-64 stores 3 bytes in 4 chars, and pads the remainder.
      this.surrogateSize = 3;
      this.detectIncompleteChar = base64DetectIncompleteChar;
      break;
    default:
      this.write = passThroughWrite;
      return;
  }

  this.charBuffer = new Buffer(6);
  this.charReceived = 0;
  this.charLength = 0;
};


StringDecoder.prototype.write = function(buffer) {
  var charStr = '';
  var offset = 0;

  // if our last write ended with an incomplete multibyte character
  while (this.charLength) {
    // determine how many remaining bytes this buffer has to offer for this char
    var i = (buffer.length >= this.charLength - this.charReceived) ?
                this.charLength - this.charReceived :
                buffer.length;

    // add the new bytes to the char buffer
    buffer.copy(this.charBuffer, this.charReceived, offset, i);
    this.charReceived += (i - offset);
    offset = i;

    if (this.charReceived < this.charLength) {
      // still not enough chars in this buffer? wait for more ...
      return '';
    }

    // get the character that was split
    charStr = this.charBuffer.slice(0, this.charLength).toString(this.encoding);

    // lead surrogate (D800-DBFF) is also the incomplete character
    var charCode = charStr.charCodeAt(charStr.length - 1);
    if (charCode >= 0xD800 && charCode <= 0xDBFF) {
      this.charLength += this.surrogateSize;
      charStr = '';
      continue;
    }
    this.charReceived = this.charLength = 0;

    // if there are no more bytes in this buffer, just emit our char
    if (i == buffer.length) return charStr;

    // otherwise cut off the characters end from the beginning of this buffer
    buffer = buffer.slice(i, buffer.length);
    break;
  }

  var lenIncomplete = this.detectIncompleteChar(buffer);

  var end = buffer.length;
  if (this.charLength) {
    // buffer the incomplete character bytes we got
    buffer.copy(this.charBuffer, 0, buffer.length - lenIncomplete, end);
    this.charReceived = lenIncomplete;
    end -= lenIncomplete;
  }

  charStr += buffer.toString(this.encoding, 0, end);

  var end = charStr.length - 1;
  var charCode = charStr.charCodeAt(end);
  // lead surrogate (D800-DBFF) is also the incomplete character
  if (charCode >= 0xD800 && charCode <= 0xDBFF) {
    var size = this.surrogateSize;
    this.charLength += size;
    this.charReceived += size;
    this.charBuffer.copy(this.charBuffer, size, 0, size);
    this.charBuffer.write(charStr.charAt(charStr.length - 1), this.encoding);
    return charStr.substring(0, end);
  }

  // or just emit the charStr
  return charStr;
};

StringDecoder.prototype.detectIncompleteChar = function(buffer) {
  // determine how many bytes we have to check at the end of this buffer
  var i = (buffer.length >= 3) ? 3 : buffer.length;

  // Figure out if one of the last i bytes of our buffer announces an
  // incomplete char.
  for (; i > 0; i--) {
    var c = buffer[buffer.length - i];

    // See http://en.wikipedia.org/wiki/UTF-8#Description

    // 110XXXXX
    if (i == 1 && c >> 5 == 0x06) {
      this.charLength = 2;
      break;
    }

    // 1110XXXX
    if (i <= 2 && c >> 4 == 0x0E) {
      this.charLength = 3;
      break;
    }

    // 11110XXX
    if (i <= 3 && c >> 3 == 0x1E) {
      this.charLength = 4;
      break;
    }
  }

  return i;
};

StringDecoder.prototype.end = function(buffer) {
  var res = '';
  if (buffer && buffer.length)
    res = this.write(buffer);

  if (this.charReceived) {
    var cr = this.charReceived;
    var buf = this.charBuffer;
    var enc = this.encoding;
    res += buf.slice(0, cr).toString(enc);
  }

  return res;
};

function passThroughWrite(buffer) {
  return buffer.toString(this.encoding);
}

function utf16DetectIncompleteChar(buffer) {
  var incomplete = this.charReceived = buffer.length % 2;
  this.charLength = incomplete ? 2 : 0;
  return incomplete;
}

function base64DetectIncompleteChar(buffer) {
  var incomplete = this.charReceived = buffer.length % 3;
  this.charLength = incomplete ? 3 : 0;
  return incomplete;
}

},{"buffer":9}],30:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

var punycode = require('punycode');

exports.parse = urlParse;
exports.resolve = urlResolve;
exports.resolveObject = urlResolveObject;
exports.format = urlFormat;

exports.Url = Url;

function Url() {
  this.protocol = null;
  this.slashes = null;
  this.auth = null;
  this.host = null;
  this.port = null;
  this.hostname = null;
  this.hash = null;
  this.search = null;
  this.query = null;
  this.pathname = null;
  this.path = null;
  this.href = null;
}

// Reference: RFC 3986, RFC 1808, RFC 2396

// define these here so at least they only have to be
// compiled once on the first module load.
var protocolPattern = /^([a-z0-9.+-]+:)/i,
    portPattern = /:[0-9]*$/,

    // RFC 2396: characters reserved for delimiting URLs.
    // We actually just auto-escape these.
    delims = ['<', '>', '"', '`', ' ', '\r', '\n', '\t'],

    // RFC 2396: characters not allowed for various reasons.
    unwise = ['{', '}', '|', '\\', '^', '`'].concat(delims),

    // Allowed by RFCs, but cause of XSS attacks.  Always escape these.
    autoEscape = ['\''].concat(unwise),
    // Characters that are never ever allowed in a hostname.
    // Note that any invalid chars are also handled, but these
    // are the ones that are *expected* to be seen, so we fast-path
    // them.
    nonHostChars = ['%', '/', '?', ';', '#'].concat(autoEscape),
    hostEndingChars = ['/', '?', '#'],
    hostnameMaxLen = 255,
    hostnamePartPattern = /^[a-z0-9A-Z_-]{0,63}$/,
    hostnamePartStart = /^([a-z0-9A-Z_-]{0,63})(.*)$/,
    // protocols that can allow "unsafe" and "unwise" chars.
    unsafeProtocol = {
      'javascript': true,
      'javascript:': true
    },
    // protocols that never have a hostname.
    hostlessProtocol = {
      'javascript': true,
      'javascript:': true
    },
    // protocols that always contain a // bit.
    slashedProtocol = {
      'http': true,
      'https': true,
      'ftp': true,
      'gopher': true,
      'file': true,
      'http:': true,
      'https:': true,
      'ftp:': true,
      'gopher:': true,
      'file:': true
    },
    querystring = require('querystring');

function urlParse(url, parseQueryString, slashesDenoteHost) {
  if (url && isObject(url) && url instanceof Url) return url;

  var u = new Url;
  u.parse(url, parseQueryString, slashesDenoteHost);
  return u;
}

Url.prototype.parse = function(url, parseQueryString, slashesDenoteHost) {
  if (!isString(url)) {
    throw new TypeError("Parameter 'url' must be a string, not " + typeof url);
  }

  var rest = url;

  // trim before proceeding.
  // This is to support parse stuff like "  http://foo.com  \n"
  rest = rest.trim();

  var proto = protocolPattern.exec(rest);
  if (proto) {
    proto = proto[0];
    var lowerProto = proto.toLowerCase();
    this.protocol = lowerProto;
    rest = rest.substr(proto.length);
  }

  // figure out if it's got a host
  // user@server is *always* interpreted as a hostname, and url
  // resolution will treat //foo/bar as host=foo,path=bar because that's
  // how the browser resolves relative URLs.
  if (slashesDenoteHost || proto || rest.match(/^\/\/[^@\/]+@[^@\/]+/)) {
    var slashes = rest.substr(0, 2) === '//';
    if (slashes && !(proto && hostlessProtocol[proto])) {
      rest = rest.substr(2);
      this.slashes = true;
    }
  }

  if (!hostlessProtocol[proto] &&
      (slashes || (proto && !slashedProtocol[proto]))) {

    // there's a hostname.
    // the first instance of /, ?, ;, or # ends the host.
    //
    // If there is an @ in the hostname, then non-host chars *are* allowed
    // to the left of the last @ sign, unless some host-ending character
    // comes *before* the @-sign.
    // URLs are obnoxious.
    //
    // ex:
    // http://a@b@c/ => user:a@b host:c
    // http://a@b?@c => user:a host:c path:/?@c

    // v0.12 TODO(isaacs): This is not quite how Chrome does things.
    // Review our test case against browsers more comprehensively.

    // find the first instance of any hostEndingChars
    var hostEnd = -1;
    for (var i = 0; i < hostEndingChars.length; i++) {
      var hec = rest.indexOf(hostEndingChars[i]);
      if (hec !== -1 && (hostEnd === -1 || hec < hostEnd))
        hostEnd = hec;
    }

    // at this point, either we have an explicit point where the
    // auth portion cannot go past, or the last @ char is the decider.
    var auth, atSign;
    if (hostEnd === -1) {
      // atSign can be anywhere.
      atSign = rest.lastIndexOf('@');
    } else {
      // atSign must be in auth portion.
      // http://a@b/c@d => host:b auth:a path:/c@d
      atSign = rest.lastIndexOf('@', hostEnd);
    }

    // Now we have a portion which is definitely the auth.
    // Pull that off.
    if (atSign !== -1) {
      auth = rest.slice(0, atSign);
      rest = rest.slice(atSign + 1);
      this.auth = decodeURIComponent(auth);
    }

    // the host is the remaining to the left of the first non-host char
    hostEnd = -1;
    for (var i = 0; i < nonHostChars.length; i++) {
      var hec = rest.indexOf(nonHostChars[i]);
      if (hec !== -1 && (hostEnd === -1 || hec < hostEnd))
        hostEnd = hec;
    }
    // if we still have not hit it, then the entire thing is a host.
    if (hostEnd === -1)
      hostEnd = rest.length;

    this.host = rest.slice(0, hostEnd);
    rest = rest.slice(hostEnd);

    // pull out port.
    this.parseHost();

    // we've indicated that there is a hostname,
    // so even if it's empty, it has to be present.
    this.hostname = this.hostname || '';

    // if hostname begins with [ and ends with ]
    // assume that it's an IPv6 address.
    var ipv6Hostname = this.hostname[0] === '[' &&
        this.hostname[this.hostname.length - 1] === ']';

    // validate a little.
    if (!ipv6Hostname) {
      var hostparts = this.hostname.split(/\./);
      for (var i = 0, l = hostparts.length; i < l; i++) {
        var part = hostparts[i];
        if (!part) continue;
        if (!part.match(hostnamePartPattern)) {
          var newpart = '';
          for (var j = 0, k = part.length; j < k; j++) {
            if (part.charCodeAt(j) > 127) {
              // we replace non-ASCII char with a temporary placeholder
              // we need this to make sure size of hostname is not
              // broken by replacing non-ASCII by nothing
              newpart += 'x';
            } else {
              newpart += part[j];
            }
          }
          // we test again with ASCII char only
          if (!newpart.match(hostnamePartPattern)) {
            var validParts = hostparts.slice(0, i);
            var notHost = hostparts.slice(i + 1);
            var bit = part.match(hostnamePartStart);
            if (bit) {
              validParts.push(bit[1]);
              notHost.unshift(bit[2]);
            }
            if (notHost.length) {
              rest = '/' + notHost.join('.') + rest;
            }
            this.hostname = validParts.join('.');
            break;
          }
        }
      }
    }

    if (this.hostname.length > hostnameMaxLen) {
      this.hostname = '';
    } else {
      // hostnames are always lower case.
      this.hostname = this.hostname.toLowerCase();
    }

    if (!ipv6Hostname) {
      // IDNA Support: Returns a puny coded representation of "domain".
      // It only converts the part of the domain name that
      // has non ASCII characters. I.e. it dosent matter if
      // you call it with a domain that already is in ASCII.
      var domainArray = this.hostname.split('.');
      var newOut = [];
      for (var i = 0; i < domainArray.length; ++i) {
        var s = domainArray[i];
        newOut.push(s.match(/[^A-Za-z0-9_-]/) ?
            'xn--' + punycode.encode(s) : s);
      }
      this.hostname = newOut.join('.');
    }

    var p = this.port ? ':' + this.port : '';
    var h = this.hostname || '';
    this.host = h + p;
    this.href += this.host;

    // strip [ and ] from the hostname
    // the host field still retains them, though
    if (ipv6Hostname) {
      this.hostname = this.hostname.substr(1, this.hostname.length - 2);
      if (rest[0] !== '/') {
        rest = '/' + rest;
      }
    }
  }

  // now rest is set to the post-host stuff.
  // chop off any delim chars.
  if (!unsafeProtocol[lowerProto]) {

    // First, make 100% sure that any "autoEscape" chars get
    // escaped, even if encodeURIComponent doesn't think they
    // need to be.
    for (var i = 0, l = autoEscape.length; i < l; i++) {
      var ae = autoEscape[i];
      var esc = encodeURIComponent(ae);
      if (esc === ae) {
        esc = escape(ae);
      }
      rest = rest.split(ae).join(esc);
    }
  }


  // chop off from the tail first.
  var hash = rest.indexOf('#');
  if (hash !== -1) {
    // got a fragment string.
    this.hash = rest.substr(hash);
    rest = rest.slice(0, hash);
  }
  var qm = rest.indexOf('?');
  if (qm !== -1) {
    this.search = rest.substr(qm);
    this.query = rest.substr(qm + 1);
    if (parseQueryString) {
      this.query = querystring.parse(this.query);
    }
    rest = rest.slice(0, qm);
  } else if (parseQueryString) {
    // no query string, but parseQueryString still requested
    this.search = '';
    this.query = {};
  }
  if (rest) this.pathname = rest;
  if (slashedProtocol[lowerProto] &&
      this.hostname && !this.pathname) {
    this.pathname = '/';
  }

  //to support http.request
  if (this.pathname || this.search) {
    var p = this.pathname || '';
    var s = this.search || '';
    this.path = p + s;
  }

  // finally, reconstruct the href based on what has been validated.
  this.href = this.format();
  return this;
};

// format a parsed object into a url string
function urlFormat(obj) {
  // ensure it's an object, and not a string url.
  // If it's an obj, this is a no-op.
  // this way, you can call url_format() on strings
  // to clean up potentially wonky urls.
  if (isString(obj)) obj = urlParse(obj);
  if (!(obj instanceof Url)) return Url.prototype.format.call(obj);
  return obj.format();
}

Url.prototype.format = function() {
  var auth = this.auth || '';
  if (auth) {
    auth = encodeURIComponent(auth);
    auth = auth.replace(/%3A/i, ':');
    auth += '@';
  }

  var protocol = this.protocol || '',
      pathname = this.pathname || '',
      hash = this.hash || '',
      host = false,
      query = '';

  if (this.host) {
    host = auth + this.host;
  } else if (this.hostname) {
    host = auth + (this.hostname.indexOf(':') === -1 ?
        this.hostname :
        '[' + this.hostname + ']');
    if (this.port) {
      host += ':' + this.port;
    }
  }

  if (this.query &&
      isObject(this.query) &&
      Object.keys(this.query).length) {
    query = querystring.stringify(this.query);
  }

  var search = this.search || (query && ('?' + query)) || '';

  if (protocol && protocol.substr(-1) !== ':') protocol += ':';

  // only the slashedProtocols get the //.  Not mailto:, xmpp:, etc.
  // unless they had them to begin with.
  if (this.slashes ||
      (!protocol || slashedProtocol[protocol]) && host !== false) {
    host = '//' + (host || '');
    if (pathname && pathname.charAt(0) !== '/') pathname = '/' + pathname;
  } else if (!host) {
    host = '';
  }

  if (hash && hash.charAt(0) !== '#') hash = '#' + hash;
  if (search && search.charAt(0) !== '?') search = '?' + search;

  pathname = pathname.replace(/[?#]/g, function(match) {
    return encodeURIComponent(match);
  });
  search = search.replace('#', '%23');

  return protocol + host + pathname + search + hash;
};

function urlResolve(source, relative) {
  return urlParse(source, false, true).resolve(relative);
}

Url.prototype.resolve = function(relative) {
  return this.resolveObject(urlParse(relative, false, true)).format();
};

function urlResolveObject(source, relative) {
  if (!source) return relative;
  return urlParse(source, false, true).resolveObject(relative);
}

Url.prototype.resolveObject = function(relative) {
  if (isString(relative)) {
    var rel = new Url();
    rel.parse(relative, false, true);
    relative = rel;
  }

  var result = new Url();
  Object.keys(this).forEach(function(k) {
    result[k] = this[k];
  }, this);

  // hash is always overridden, no matter what.
  // even href="" will remove it.
  result.hash = relative.hash;

  // if the relative url is empty, then there's nothing left to do here.
  if (relative.href === '') {
    result.href = result.format();
    return result;
  }

  // hrefs like //foo/bar always cut to the protocol.
  if (relative.slashes && !relative.protocol) {
    // take everything except the protocol from relative
    Object.keys(relative).forEach(function(k) {
      if (k !== 'protocol')
        result[k] = relative[k];
    });

    //urlParse appends trailing / to urls like http://www.example.com
    if (slashedProtocol[result.protocol] &&
        result.hostname && !result.pathname) {
      result.path = result.pathname = '/';
    }

    result.href = result.format();
    return result;
  }

  if (relative.protocol && relative.protocol !== result.protocol) {
    // if it's a known url protocol, then changing
    // the protocol does weird things
    // first, if it's not file:, then we MUST have a host,
    // and if there was a path
    // to begin with, then we MUST have a path.
    // if it is file:, then the host is dropped,
    // because that's known to be hostless.
    // anything else is assumed to be absolute.
    if (!slashedProtocol[relative.protocol]) {
      Object.keys(relative).forEach(function(k) {
        result[k] = relative[k];
      });
      result.href = result.format();
      return result;
    }

    result.protocol = relative.protocol;
    if (!relative.host && !hostlessProtocol[relative.protocol]) {
      var relPath = (relative.pathname || '').split('/');
      while (relPath.length && !(relative.host = relPath.shift()));
      if (!relative.host) relative.host = '';
      if (!relative.hostname) relative.hostname = '';
      if (relPath[0] !== '') relPath.unshift('');
      if (relPath.length < 2) relPath.unshift('');
      result.pathname = relPath.join('/');
    } else {
      result.pathname = relative.pathname;
    }
    result.search = relative.search;
    result.query = relative.query;
    result.host = relative.host || '';
    result.auth = relative.auth;
    result.hostname = relative.hostname || relative.host;
    result.port = relative.port;
    // to support http.request
    if (result.pathname || result.search) {
      var p = result.pathname || '';
      var s = result.search || '';
      result.path = p + s;
    }
    result.slashes = result.slashes || relative.slashes;
    result.href = result.format();
    return result;
  }

  var isSourceAbs = (result.pathname && result.pathname.charAt(0) === '/'),
      isRelAbs = (
          relative.host ||
          relative.pathname && relative.pathname.charAt(0) === '/'
      ),
      mustEndAbs = (isRelAbs || isSourceAbs ||
                    (result.host && relative.pathname)),
      removeAllDots = mustEndAbs,
      srcPath = result.pathname && result.pathname.split('/') || [],
      relPath = relative.pathname && relative.pathname.split('/') || [],
      psychotic = result.protocol && !slashedProtocol[result.protocol];

  // if the url is a non-slashed url, then relative
  // links like ../.. should be able
  // to crawl up to the hostname, as well.  This is strange.
  // result.protocol has already been set by now.
  // Later on, put the first path part into the host field.
  if (psychotic) {
    result.hostname = '';
    result.port = null;
    if (result.host) {
      if (srcPath[0] === '') srcPath[0] = result.host;
      else srcPath.unshift(result.host);
    }
    result.host = '';
    if (relative.protocol) {
      relative.hostname = null;
      relative.port = null;
      if (relative.host) {
        if (relPath[0] === '') relPath[0] = relative.host;
        else relPath.unshift(relative.host);
      }
      relative.host = null;
    }
    mustEndAbs = mustEndAbs && (relPath[0] === '' || srcPath[0] === '');
  }

  if (isRelAbs) {
    // it's absolute.
    result.host = (relative.host || relative.host === '') ?
                  relative.host : result.host;
    result.hostname = (relative.hostname || relative.hostname === '') ?
                      relative.hostname : result.hostname;
    result.search = relative.search;
    result.query = relative.query;
    srcPath = relPath;
    // fall through to the dot-handling below.
  } else if (relPath.length) {
    // it's relative
    // throw away the existing file, and take the new path instead.
    if (!srcPath) srcPath = [];
    srcPath.pop();
    srcPath = srcPath.concat(relPath);
    result.search = relative.search;
    result.query = relative.query;
  } else if (!isNullOrUndefined(relative.search)) {
    // just pull out the search.
    // like href='?foo'.
    // Put this after the other two cases because it simplifies the booleans
    if (psychotic) {
      result.hostname = result.host = srcPath.shift();
      //occationaly the auth can get stuck only in host
      //this especialy happens in cases like
      //url.resolveObject('mailto:local1@domain1', 'local2@domain2')
      var authInHost = result.host && result.host.indexOf('@') > 0 ?
                       result.host.split('@') : false;
      if (authInHost) {
        result.auth = authInHost.shift();
        result.host = result.hostname = authInHost.shift();
      }
    }
    result.search = relative.search;
    result.query = relative.query;
    //to support http.request
    if (!isNull(result.pathname) || !isNull(result.search)) {
      result.path = (result.pathname ? result.pathname : '') +
                    (result.search ? result.search : '');
    }
    result.href = result.format();
    return result;
  }

  if (!srcPath.length) {
    // no path at all.  easy.
    // we've already handled the other stuff above.
    result.pathname = null;
    //to support http.request
    if (result.search) {
      result.path = '/' + result.search;
    } else {
      result.path = null;
    }
    result.href = result.format();
    return result;
  }

  // if a url ENDs in . or .., then it must get a trailing slash.
  // however, if it ends in anything else non-slashy,
  // then it must NOT get a trailing slash.
  var last = srcPath.slice(-1)[0];
  var hasTrailingSlash = (
      (result.host || relative.host) && (last === '.' || last === '..') ||
      last === '');

  // strip single dots, resolve double dots to parent dir
  // if the path tries to go above the root, `up` ends up > 0
  var up = 0;
  for (var i = srcPath.length; i >= 0; i--) {
    last = srcPath[i];
    if (last == '.') {
      srcPath.splice(i, 1);
    } else if (last === '..') {
      srcPath.splice(i, 1);
      up++;
    } else if (up) {
      srcPath.splice(i, 1);
      up--;
    }
  }

  // if the path is allowed to go above the root, restore leading ..s
  if (!mustEndAbs && !removeAllDots) {
    for (; up--; up) {
      srcPath.unshift('..');
    }
  }

  if (mustEndAbs && srcPath[0] !== '' &&
      (!srcPath[0] || srcPath[0].charAt(0) !== '/')) {
    srcPath.unshift('');
  }

  if (hasTrailingSlash && (srcPath.join('/').substr(-1) !== '/')) {
    srcPath.push('');
  }

  var isAbsolute = srcPath[0] === '' ||
      (srcPath[0] && srcPath[0].charAt(0) === '/');

  // put the host back
  if (psychotic) {
    result.hostname = result.host = isAbsolute ? '' :
                                    srcPath.length ? srcPath.shift() : '';
    //occationaly the auth can get stuck only in host
    //this especialy happens in cases like
    //url.resolveObject('mailto:local1@domain1', 'local2@domain2')
    var authInHost = result.host && result.host.indexOf('@') > 0 ?
                     result.host.split('@') : false;
    if (authInHost) {
      result.auth = authInHost.shift();
      result.host = result.hostname = authInHost.shift();
    }
  }

  mustEndAbs = mustEndAbs || (result.host && srcPath.length);

  if (mustEndAbs && !isAbsolute) {
    srcPath.unshift('');
  }

  if (!srcPath.length) {
    result.pathname = null;
    result.path = null;
  } else {
    result.pathname = srcPath.join('/');
  }

  //to support request.http
  if (!isNull(result.pathname) || !isNull(result.search)) {
    result.path = (result.pathname ? result.pathname : '') +
                  (result.search ? result.search : '');
  }
  result.auth = relative.auth || result.auth;
  result.slashes = result.slashes || relative.slashes;
  result.href = result.format();
  return result;
};

Url.prototype.parseHost = function() {
  var host = this.host;
  var port = portPattern.exec(host);
  if (port) {
    port = port[0];
    if (port !== ':') {
      this.port = port.substr(1);
    }
    host = host.substr(0, host.length - port.length);
  }
  if (host) this.hostname = host;
};

function isString(arg) {
  return typeof arg === "string";
}

function isObject(arg) {
  return typeof arg === 'object' && arg !== null;
}

function isNull(arg) {
  return arg === null;
}
function isNullOrUndefined(arg) {
  return  arg == null;
}

},{"punycode":18,"querystring":21}],31:[function(require,module,exports){
var http = module.exports;
var EventEmitter = require('events').EventEmitter;
var Request = require('./lib/request');
var url = require('url')

http.request = function (params, cb) {
    if (typeof params === 'string') {
        params = url.parse(params)
    }
    if (!params) params = {};
    if (!params.host && !params.port) {
        params.port = parseInt(window.location.port, 10);
    }
    if (!params.host && params.hostname) {
        params.host = params.hostname;
    }
    
    if (!params.scheme) params.scheme = window.location.protocol.split(':')[0];
    if (!params.host) {
        params.host = window.location.hostname || window.location.host;
    }
    if (/:/.test(params.host)) {
        if (!params.port) {
            params.port = params.host.split(':')[1];
        }
        params.host = params.host.split(':')[0];
    }
    if (!params.port) params.port = params.scheme == 'https' ? 443 : 80;
    
    var req = new Request(new xhrHttp, params);
    if (cb) req.on('response', cb);
    return req;
};

http.get = function (params, cb) {
    params.method = 'GET';
    var req = http.request(params, cb);
    req.end();
    return req;
};

http.Agent = function () {};
http.Agent.defaultMaxSockets = 4;

var xhrHttp = (function () {
    if (typeof window === 'undefined') {
        throw new Error('no window object present');
    }
    else if (window.XMLHttpRequest) {
        return window.XMLHttpRequest;
    }
    else if (window.ActiveXObject) {
        var axs = [
            'Msxml2.XMLHTTP.6.0',
            'Msxml2.XMLHTTP.3.0',
            'Microsoft.XMLHTTP'
        ];
        for (var i = 0; i < axs.length; i++) {
            try {
                var ax = new(window.ActiveXObject)(axs[i]);
                return function () {
                    if (ax) {
                        var ax_ = ax;
                        ax = null;
                        return ax_;
                    }
                    else {
                        return new(window.ActiveXObject)(axs[i]);
                    }
                };
            }
            catch (e) {}
        }
        throw new Error('ajax not supported in this browser')
    }
    else {
        throw new Error('ajax not supported in this browser');
    }
})();

http.STATUS_CODES = {
    100 : 'Continue',
    101 : 'Switching Protocols',
    102 : 'Processing',                 // RFC 2518, obsoleted by RFC 4918
    200 : 'OK',
    201 : 'Created',
    202 : 'Accepted',
    203 : 'Non-Authoritative Information',
    204 : 'No Content',
    205 : 'Reset Content',
    206 : 'Partial Content',
    207 : 'Multi-Status',               // RFC 4918
    300 : 'Multiple Choices',
    301 : 'Moved Permanently',
    302 : 'Moved Temporarily',
    303 : 'See Other',
    304 : 'Not Modified',
    305 : 'Use Proxy',
    307 : 'Temporary Redirect',
    400 : 'Bad Request',
    401 : 'Unauthorized',
    402 : 'Payment Required',
    403 : 'Forbidden',
    404 : 'Not Found',
    405 : 'Method Not Allowed',
    406 : 'Not Acceptable',
    407 : 'Proxy Authentication Required',
    408 : 'Request Time-out',
    409 : 'Conflict',
    410 : 'Gone',
    411 : 'Length Required',
    412 : 'Precondition Failed',
    413 : 'Request Entity Too Large',
    414 : 'Request-URI Too Large',
    415 : 'Unsupported Media Type',
    416 : 'Requested Range Not Satisfiable',
    417 : 'Expectation Failed',
    418 : 'I\'m a teapot',              // RFC 2324
    422 : 'Unprocessable Entity',       // RFC 4918
    423 : 'Locked',                     // RFC 4918
    424 : 'Failed Dependency',          // RFC 4918
    425 : 'Unordered Collection',       // RFC 4918
    426 : 'Upgrade Required',           // RFC 2817
    428 : 'Precondition Required',      // RFC 6585
    429 : 'Too Many Requests',          // RFC 6585
    431 : 'Request Header Fields Too Large',// RFC 6585
    500 : 'Internal Server Error',
    501 : 'Not Implemented',
    502 : 'Bad Gateway',
    503 : 'Service Unavailable',
    504 : 'Gateway Time-out',
    505 : 'HTTP Version Not Supported',
    506 : 'Variant Also Negotiates',    // RFC 2295
    507 : 'Insufficient Storage',       // RFC 4918
    509 : 'Bandwidth Limit Exceeded',
    510 : 'Not Extended',               // RFC 2774
    511 : 'Network Authentication Required' // RFC 6585
};
},{"./lib/request":32,"events":16,"url":30}],32:[function(require,module,exports){
var Stream = require('stream');
var Response = require('./response');
var Base64 = require('Base64');
var inherits = require('inherits');

var Request = module.exports = function (xhr, params) {
    var self = this;
    self.writable = true;
    self.xhr = xhr;
    self.body = [];
    
    self.uri = (params.scheme || 'http') + '://'
        + params.host
        + (params.port ? ':' + params.port : '')
        + (params.path || '/')
    ;
    
    if (typeof params.withCredentials === 'undefined') {
        params.withCredentials = true;
    }

    try { xhr.withCredentials = params.withCredentials }
    catch (e) {}
    
    xhr.open(
        params.method || 'GET',
        self.uri,
        true
    );

    self._headers = {};
    
    if (params.headers) {
        var keys = objectKeys(params.headers);
        for (var i = 0; i < keys.length; i++) {
            var key = keys[i];
            if (!self.isSafeRequestHeader(key)) continue;
            var value = params.headers[key];
            self.setHeader(key, value);
        }
    }
    
    if (params.auth) {
        //basic auth
        this.setHeader('Authorization', 'Basic ' + Base64.btoa(params.auth));
    }

    var res = new Response;
    res.on('close', function () {
        self.emit('close');
    });
    
    res.on('ready', function () {
        self.emit('response', res);
    });
    
    xhr.onreadystatechange = function () {
        // Fix for IE9 bug
        // SCRIPT575: Could not complete the operation due to error c00c023f
        // It happens when a request is aborted, calling the success callback anyway with readyState === 4
        if (xhr.__aborted) return;
        res.handle(xhr);
    };
};

inherits(Request, Stream);

Request.prototype.setHeader = function (key, value) {
    this._headers[key.toLowerCase()] = value
};

Request.prototype.getHeader = function (key) {
    return this._headers[key.toLowerCase()]
};

Request.prototype.removeHeader = function (key) {
    delete this._headers[key.toLowerCase()]
};

Request.prototype.write = function (s) {
    this.body.push(s);
};

Request.prototype.destroy = function (s) {
    this.xhr.__aborted = true;
    this.xhr.abort();
    this.emit('close');
};

Request.prototype.end = function (s) {
    if (s !== undefined) this.body.push(s);

    var keys = objectKeys(this._headers);
    for (var i = 0; i < keys.length; i++) {
        var key = keys[i];
        var value = this._headers[key];
        if (isArray(value)) {
            for (var j = 0; j < value.length; j++) {
                this.xhr.setRequestHeader(key, value[j]);
            }
        }
        else this.xhr.setRequestHeader(key, value)
    }

    if (this.body.length === 0) {
        this.xhr.send('');
    }
    else if (typeof this.body[0] === 'string') {
        this.xhr.send(this.body.join(''));
    }
    else if (isArray(this.body[0])) {
        var body = [];
        for (var i = 0; i < this.body.length; i++) {
            body.push.apply(body, this.body[i]);
        }
        this.xhr.send(body);
    }
    else if (/Array/.test(Object.prototype.toString.call(this.body[0]))) {
        var len = 0;
        for (var i = 0; i < this.body.length; i++) {
            len += this.body[i].length;
        }
        var body = new(this.body[0].constructor)(len);
        var k = 0;
        
        for (var i = 0; i < this.body.length; i++) {
            var b = this.body[i];
            for (var j = 0; j < b.length; j++) {
                body[k++] = b[j];
            }
        }
        this.xhr.send(body);
    }
    else {
        var body = '';
        for (var i = 0; i < this.body.length; i++) {
            body += this.body[i].toString();
        }
        this.xhr.send(body);
    }
};

// Taken from http://dxr.mozilla.org/mozilla/mozilla-central/content/base/src/nsXMLHttpRequest.cpp.html
Request.unsafeHeaders = [
    "accept-charset",
    "accept-encoding",
    "access-control-request-headers",
    "access-control-request-method",
    "connection",
    "content-length",
    "cookie",
    "cookie2",
    "content-transfer-encoding",
    "date",
    "expect",
    "host",
    "keep-alive",
    "origin",
    "referer",
    "te",
    "trailer",
    "transfer-encoding",
    "upgrade",
    "user-agent",
    "via"
];

Request.prototype.isSafeRequestHeader = function (headerName) {
    if (!headerName) return false;
    return indexOf(Request.unsafeHeaders, headerName.toLowerCase()) === -1;
};

var objectKeys = Object.keys || function (obj) {
    var keys = [];
    for (var key in obj) keys.push(key);
    return keys;
};

var isArray = Array.isArray || function (xs) {
    return Object.prototype.toString.call(xs) === '[object Array]';
};

var indexOf = function (xs, x) {
    if (xs.indexOf) return xs.indexOf(x);
    for (var i = 0; i < xs.length; i++) {
        if (xs[i] === x) return i;
    }
    return -1;
};

},{"./response":33,"Base64":2,"inherits":36,"stream":23}],33:[function(require,module,exports){
var Stream = require('stream');
var util = require('util');

var Response = module.exports = function (res) {
    this.offset = 0;
    this.readable = true;
};

util.inherits(Response, Stream);

var capable = {
    streaming : true,
    status2 : true
};

function parseHeaders (res) {
    var lines = res.getAllResponseHeaders().split(/\r?\n/);
    var headers = {};
    for (var i = 0; i < lines.length; i++) {
        var line = lines[i];
        if (line === '') continue;
        
        var m = line.match(/^([^:]+):\s*(.*)/);
        if (m) {
            var key = m[1].toLowerCase(), value = m[2];
            
            if (headers[key] !== undefined) {
            
                if (isArray(headers[key])) {
                    headers[key].push(value);
                }
                else {
                    headers[key] = [ headers[key], value ];
                }
            }
            else {
                headers[key] = value;
            }
        }
        else {
            headers[line] = true;
        }
    }
    return headers;
}

Response.prototype.getResponse = function (xhr) {
    var respType = String(xhr.responseType).toLowerCase();
    if (respType === 'blob') return xhr.responseBlob || xhr.response;
    if (respType === 'arraybuffer') return xhr.response;
    return xhr.responseText;
}

Response.prototype.getHeader = function (key) {
    return this.headers[key.toLowerCase()];
};

Response.prototype.handle = function (res) {
    if (res.readyState === 2 && capable.status2) {
        try {
            this.statusCode = res.status;
            this.headers = parseHeaders(res);
        }
        catch (err) {
            capable.status2 = false;
        }
        
        if (capable.status2) {
            this.emit('ready');
        }
    }
    else if (capable.streaming && res.readyState === 3) {
        try {
            if (!this.statusCode) {
                this.statusCode = res.status;
                this.headers = parseHeaders(res);
                this.emit('ready');
            }
        }
        catch (err) {}
        
        try {
            this._emitData(res);
        }
        catch (err) {
            capable.streaming = false;
        }
    }
    else if (res.readyState === 4) {
        if (!this.statusCode) {
            this.statusCode = res.status;
            this.emit('ready');
        }
        this._emitData(res);
        
        if (res.error) {
            this.emit('error', this.getResponse(res));
        }
        else this.emit('end');
        
        this.emit('close');
    }
};

Response.prototype._emitData = function (res) {
    var respBody = this.getResponse(res);
    if (respBody.toString().match(/ArrayBuffer/)) {
        this.emit('data', new Uint8Array(respBody, this.offset));
        this.offset = respBody.byteLength;
        return;
    }
    if (respBody.length > this.offset) {
        this.emit('data', respBody.slice(this.offset));
        this.offset = respBody.length;
    }
};

var isArray = Array.isArray || function (xs) {
    return Object.prototype.toString.call(xs) === '[object Array]';
};

},{"stream":23,"util":104}],34:[function(require,module,exports){
var http = require('http');

var https = module.exports;

for (var key in http) {
    if (http.hasOwnProperty(key)) https[key] = http[key];
};

https.request = function (params, cb) {
    if (!params) params = {};
    params.scheme = 'https';
    params.protocol = 'https:';
    return http.request.call(this, params, cb);
}

},{"http":31}],35:[function(require,module,exports){
exports.read = function (buffer, offset, isLE, mLen, nBytes) {
  var e, m
  var eLen = nBytes * 8 - mLen - 1
  var eMax = (1 << eLen) - 1
  var eBias = eMax >> 1
  var nBits = -7
  var i = isLE ? (nBytes - 1) : 0
  var d = isLE ? -1 : 1
  var s = buffer[offset + i]

  i += d

  e = s & ((1 << (-nBits)) - 1)
  s >>= (-nBits)
  nBits += eLen
  for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8) {}

  m = e & ((1 << (-nBits)) - 1)
  e >>= (-nBits)
  nBits += mLen
  for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8) {}

  if (e === 0) {
    e = 1 - eBias
  } else if (e === eMax) {
    return m ? NaN : ((s ? -1 : 1) * Infinity)
  } else {
    m = m + Math.pow(2, mLen)
    e = e - eBias
  }
  return (s ? -1 : 1) * m * Math.pow(2, e - mLen)
}

exports.write = function (buffer, value, offset, isLE, mLen, nBytes) {
  var e, m, c
  var eLen = nBytes * 8 - mLen - 1
  var eMax = (1 << eLen) - 1
  var eBias = eMax >> 1
  var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0)
  var i = isLE ? 0 : (nBytes - 1)
  var d = isLE ? 1 : -1
  var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0

  value = Math.abs(value)

  if (isNaN(value) || value === Infinity) {
    m = isNaN(value) ? 1 : 0
    e = eMax
  } else {
    e = Math.floor(Math.log(value) / Math.LN2)
    if (value * (c = Math.pow(2, -e)) < 1) {
      e--
      c *= 2
    }
    if (e + eBias >= 1) {
      value += rt / c
    } else {
      value += rt * Math.pow(2, 1 - eBias)
    }
    if (value * c >= 2) {
      e++
      c /= 2
    }

    if (e + eBias >= eMax) {
      m = 0
      e = eMax
    } else if (e + eBias >= 1) {
      m = (value * c - 1) * Math.pow(2, mLen)
      e = e + eBias
    } else {
      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen)
      e = 0
    }
  }

  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}

  e = (e << mLen) | m
  eLen += mLen
  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}

  buffer[offset + i - d] |= s * 128
}

},{}],36:[function(require,module,exports){
if (typeof Object.create === 'function') {
  // implementation from standard node.js 'util' module
  module.exports = function inherits(ctor, superCtor) {
    ctor.super_ = superCtor
    ctor.prototype = Object.create(superCtor.prototype, {
      constructor: {
        value: ctor,
        enumerable: false,
        writable: true,
        configurable: true
      }
    });
  };
} else {
  // old school shim for old browsers
  module.exports = function inherits(ctor, superCtor) {
    ctor.super_ = superCtor
    var TempCtor = function () {}
    TempCtor.prototype = superCtor.prototype
    ctor.prototype = new TempCtor()
    ctor.prototype.constructor = ctor
  }
}

},{}],37:[function(require,module,exports){
(function (Buffer){
'use strict';

/**
 * Minimal HTTP/S proxy client
 */

var net = require('net');
var tls = require('tls');
var urllib = require('url');

module.exports = proxyConnect;

/**
 * Establishes proxied connection to destinationPort
 *
 * proxyConnect("http://localhost:3128/", 80, "google.com", function(err, socket){
 *     socket.write("GET / HTTP/1.0\r\n\r\n");
 * });
 *
 * @param {String} proxyUrl proxy configuration, etg "http://proxy.host:3128/"
 * @param {Number} destinationPort Port to open in destination host
 * @param {String} destinationHost Destination hostname
 * @param {Function} callback Callback to run with the rocket object once connection is established
 */
function proxyConnect(proxyUrl, destinationPort, destinationHost, callback) {
    var proxy = urllib.parse(proxyUrl);

    // create a socket connection to the proxy server
    var options;
    var connect;
    var socket;

    options = {
        host: proxy.hostname,
        port: Number(proxy.port) ? Number(proxy.port) : (proxy.protocol === 'https:' ? 443 : 80)
    };

    if (proxy.protocol === 'https:') {
        // we can use untrusted proxies as long as we verify actual SMTP certificates
        options.rejectUnauthorized = false;
        connect = tls.connect.bind(tls);
    } else {
        connect = net.connect.bind(net);
    }

    // Error harness for initial connection. Once connection is established, the responsibility
    // to handle errors is passed to whoever uses this socket
    var finished = false;
    var tempSocketErr = function (err) {
        if (finished) {
            return;
        }
        finished = true;
        try {
            socket.destroy();
        } catch (E) {
            // ignore
        }
        callback(err);
    };

    socket = connect(options, function () {
        if (finished) {
            return;
        }

        var reqHeaders = {
            Host: destinationHost + ':' + destinationPort,
            Connection: 'close'
        };
        if (proxy.auth) {
            reqHeaders['Proxy-Authorization'] = 'Basic ' + new Buffer(proxy.auth).toString('base64');
        }

        socket.write(
            // HTTP method
            'CONNECT ' + destinationHost + ':' + destinationPort + ' HTTP/1.1\r\n' +

            // HTTP request headers
            Object.keys(reqHeaders).map(function (key) {
                return key + ': ' + reqHeaders[key];
            }).join('\r\n') +

            // End request
            '\r\n\r\n');


        var headers = '';
        var onSocketData = function (chunk) {
            var match;
            var remainder;

            if (finished) {
                return;
            }

            headers += chunk.toString('binary');
            if ((match = headers.match(/\r\n\r\n/))) {
                socket.removeListener('data', onSocketData);
                remainder = headers.substr(match.index + match[0].length);
                headers = headers.substr(0, match.index);
                if (remainder) {
                    socket.unshift(new Buffer(remainder, 'binary'));
                }
                // proxy connection is now established
                finished = true;

                socket.removeListener('error', tempSocketErr);

                // check response code
                match = headers.match(/^HTTP\/\d+\.\d+ (\d+)/i);
                if (!match || (match[1] || '').charAt(0) !== '2') {
                    try {
                        socket.destroy();
                    } catch (E) {
                        // ignore
                    }
                    return callback(new Error('Invalid response from proxy' + (match && ': ' + match[1] || '')));
                }

                return callback(null, socket);
            }
        };
        socket.on('data', onSocketData);
    });

    socket.once('error', tempSocketErr);
}

}).call(this,require("buffer").Buffer)
},{"buffer":9,"net":8,"tls":8,"url":30}],38:[function(require,module,exports){
'use strict';

var mailcomposer = require('mailcomposer');
var EventEmitter = require('events').EventEmitter;
var util = require('util');
var shared = require('nodemailer-shared');
var directTransport = require('nodemailer-direct-transport');
var smtpTransport = require('nodemailer-smtp-transport');
var smtpPoolTransport = require('nodemailer-smtp-pool');
var templateSender = require('./template-sender');
var packageData = require('../package.json');
var httpProxy = require('./http-proxy');
var Socks = require('socks');
var urllib = require('url');

// Export createTransport method
module.exports.createTransport = function (transporter, defaults) {
    var urlConfig;
    var options;
    var mailer;
    var proxyUrl;

    // if no transporter configuration is provided use direct as default
    transporter = transporter || directTransport({
        debug: true
    });

    if (
        // provided transporter is a configuration object, not transporter plugin
        (typeof transporter === 'object' && typeof transporter.send !== 'function') ||
        // provided transporter looks like a connection url
        (typeof transporter === 'string' && /^(smtps?|direct):/i.test(transporter))
    ) {

        if ((urlConfig = typeof transporter === 'string' ? transporter : transporter.url)) {
            // parse a configuration URL into configuration options
            options = shared.parseConnectionUrl(urlConfig);
        } else {
            options = transporter;
        }

        if (options.proxy && typeof options.proxy === 'string') {
            proxyUrl = options.proxy;
        }

        if (options.transport && typeof options.transport === 'string') {
            try {
                transporter = require('nodemailer-' + (options.transport).toLowerCase() + '-transport')(options);
            } catch (E) {
                // if transporter loader fails, return an error when sending mail
                transporter = {
                    send: function (mail, callback) {
                        var errmsg = 'Requested transport plugin  "nodemailer-' + (options.transport).toLowerCase() + '-transport" could not be initiated';
                        var err = new Error(errmsg);
                        err.code = 'EINIT';
                        setImmediate(function () {
                            return callback(err);
                        });
                    }
                };
            }
        } else if (options.direct) {
            transporter = directTransport(options);
        } else if (options.pool) {
            transporter = smtpPoolTransport(options);
        } else {
            transporter = smtpTransport(options);
        }
    }

    mailer = new Nodemailer(transporter, defaults);

    if (proxyUrl) {
        setupProxy(mailer, proxyUrl);
    }

    return mailer;
};

/**
 * Sets up proxy handler for a Nodemailer object
 *
 * @param {Object} mailer Nodemailer instance to modify
 * @param {String} proxyUrl Proxy configuration url
 */
function setupProxy(mailer, proxyUrl) {
    var proxy = urllib.parse(proxyUrl);

    // setup socket handler for the mailer object
    mailer.getSocket = function (options, callback) {
        switch (proxy.protocol) {

            // Connect using a HTTP CONNECT method
            case 'http:':
            case 'https:':
                httpProxy(proxy.href, options.port, options.host, function (err, socket) {
                    if (err) {
                        return callback(err);
                    }
                    return callback(null, {
                        connection: socket
                    });
                });
                return;

                // Connect using a SOCKS4/5 proxy
            case 'socks:':
            case 'socks5:':
            case 'socks4:':
            case 'socks4a:':
                Socks.createConnection({
                    proxy: {
                        ipaddress: proxy.hostname,
                        port: proxy.port,
                        type: Number(proxy.protocol.replace(/\D/g, '')) || 5
                    },
                    target: {
                        host: options.host,
                        port: options.port
                    },
                    command: 'connect',
                    authentication: !proxy.auth ? false : {
                        username: decodeURIComponent(proxy.auth.split(':').shift()),
                        password: decodeURIComponent(proxy.auth.split(':').pop())
                    }
                }, function (err, socket) {
                    if (err) {
                        return callback(err);
                    }
                    return callback(null, {
                        connection: socket
                    });
                });
                return;
        }

        callback(new Error('Unknown proxy configuration'));
    };
}

/**
 * Creates an object for exposing the Nodemailer API
 *
 * @constructor
 * @param {Object} transporter Transport object instance to pass the mails to
 */
function Nodemailer(transporter, defaults) {
    EventEmitter.call(this);

    this._defaults = defaults || {};

    this._plugins = {
        compile: [],
        stream: []
    };

    this.transporter = transporter;
    this.logger = this.transporter.logger || shared.getLogger({
        logger: false
    });

    // setup emit handlers for the transporter
    if (typeof transporter.on === 'function') {

        // deprecated log interface
        this.transporter.on('log', function (log) {
            this.logger.debug('%s: %s', log.type, log.message);
        }.bind(this));

        // transporter errors
        this.transporter.on('error', function (err) {
            this.logger.error('Transport Error: %s', err.message);
            this.emit('error', err);
        }.bind(this));

        // indicates if the sender has became idle
        this.transporter.on('idle', function () {
            var args = Array.prototype.slice.call(arguments);
            args.unshift('idle');
            this.emit.apply(this, args);
        }.bind(this));
    }
}
util.inherits(Nodemailer, EventEmitter);

/**
 * Creates a template based sender function
 *
 * @param {Object} templates Object with string values where key is a message field and value is a template
 * @param {Object} defaults Optional default message fields
 * @return {Function} E-mail sender
 */
Nodemailer.prototype.templateSender = function (templates, defaults) {
    return templateSender(this, templates, defaults);
};

Nodemailer.prototype.use = function (step, plugin) {
    step = (step || '').toString();
    if (!this._plugins.hasOwnProperty(step)) {
        this._plugins[step] = [plugin];
    } else {
        this._plugins[step].push(plugin);
    }
};

/**
 * Optional methods passed to the underlying transport object
 */
['close', 'isIdle', 'verify'].forEach(function (method) {
    Nodemailer.prototype[method] = function ( /* possible arguments */ ) {
        var args = Array.prototype.slice.call(arguments);
        if (typeof this.transporter[method] === 'function') {
            return this.transporter[method].apply(this.transporter, args);
        } else {
            return false;
        }
    };
});

/**
 * Sends an email using the preselected transport object
 *
 * @param {Object} data E-data description
 * @param {Function} callback Callback to run once the sending succeeded or failed
 */
Nodemailer.prototype.sendMail = function (data, callback) {
    var promise;

    if (!callback && typeof Promise === 'function') {
        promise = new Promise(function (resolve, reject) {
            callback = shared.callbackPromise(resolve, reject);
        });
    }

    if (typeof this.getSocket === 'function') {
        this.transporter.getSocket = this.getSocket.bind(this);
        this.getSocket = false;
    }

    data = data || {};
    data.headers = data.headers || {};
    callback = callback || function () {};

    // apply defaults
    Object.keys(this._defaults).forEach(function (key) {
        if (!(key in data)) {
            data[key] = this._defaults[key];
        } else if (key === 'headers') {
            // headers is a special case. Allow setting individual default headers
            Object.keys(this._defaults.headers || {}).forEach(function (key) {
                if (!(key in data.headers)) {
                    data.headers[key] = this._defaults.headers[key];
                }
            }.bind(this));
        }
    }.bind(this));

    var mail = {
        data: data,
        message: null,
        resolveContent: shared.resolveContent
    };

    if (typeof this.transporter === 'string') {
        callback(new Error('Unsupported configuration, downgrade Nodemailer to v0.7.1 to use it'));
        return promise;
    }

    this.logger.info('Sending mail using %s/%s', this.transporter.name, this.transporter.version);

    this._processPlugins('compile', mail, function (err) {
        if (err) {
            this.logger.error('PluginCompile Error: %s', err.message);
            return callback(err);
        }

        mail.message = mailcomposer(mail.data);

        if (mail.data.xMailer !== false) {
            mail.message.setHeader('X-Mailer', mail.data.xMailer || this._getVersionString());
        }

        if (mail.data.priority) {
            switch ((mail.data.priority || '').toString().toLowerCase()) {
                case 'high':
                    mail.message.setHeader('X-Priority', '1 (Highest)');
                    mail.message.setHeader('X-MSMail-Priority', 'High');
                    mail.message.setHeader('Importance', 'High');
                    break;
                case 'low':
                    mail.message.setHeader('X-Priority', '5 (Lowest)');
                    mail.message.setHeader('X-MSMail-Priority', 'Low');
                    mail.message.setHeader('Importance', 'Low');
                    break;
                default:
                    // do not add anything, since all messages are 'Normal' by default
            }
        }

        // add optional List-* headers
        if (mail.data.list && typeof mail.data.list === 'object') {
            this._getListHeaders(mail.data.list).forEach(function (listHeader) {
                listHeader.value.forEach(function (value) {
                    mail.message.addHeader(listHeader.key, value);
                });
            });
        }

        this._processPlugins('stream', mail, function (err) {
            if (err) {
                this.logger.error('PluginStream Error: %s', err.message);
                return callback(err);
            }

            this.transporter.send(mail, function () {
                var args = Array.prototype.slice.call(arguments);
                if (args[0]) {
                    this.logger.error('Send Error: %s', args[0].message);
                }
                callback.apply(null, args);
            }.bind(this));
        }.bind(this));
    }.bind(this));

    return promise;
};

Nodemailer.prototype._getVersionString = function () {
    return util.format(
        '%s (%s; +%s; %s/%s)',
        packageData.name,
        packageData.version,
        packageData.homepage,
        this.transporter.name,
        this.transporter.version
    );
};

Nodemailer.prototype._processPlugins = function (step, mail, callback) {
    step = (step || '').toString();

    if (!this._plugins.hasOwnProperty(step) || !this._plugins[step].length) {
        return callback(null);
    }

    var plugins = Array.prototype.slice.call(this._plugins[step]);

    this.logger.debug('Using %s plugins for %s', plugins.length, step);

    var processPlugins = function () {
        if (!plugins.length) {
            return callback(null);
        }
        var plugin = plugins.shift();
        plugin(mail, function (err) {
            if (err) {
                return callback(err);
            }
            processPlugins();
        });
    }.bind(this);

    processPlugins();
};

/**
 * This method takes list headers structure and converts it into
 * header list with key-value pairs
 *
 * @param {Object} listData Structured List-* headers
 * @return {Array} An array of headers
 */
Nodemailer.prototype._getListHeaders = function (listData) {
    // make sure an url looks like <protocol:url>
    var formatListUrl = function (url) {
        url = url.replace(/[\s<]+|[\s>]+/g, '');
        if (/^(https?|mailto|ftp):/.test(url)) {
            return '<' + url + '>';
        }
        if (/^[^@]+@[^@]+$/.test(url)) {
            return '<mailto:' + url + '>';
        }

        return '<http://' + url + '>';
    };

    return Object.keys(listData).map(function (key) {
        return {
            key: 'list-' + key.toLowerCase().trim(),
            value: [].concat(listData[key] || []).map(function (value) {
                if (typeof value === 'string') {
                    return formatListUrl(value);
                }
                return {
                    prepared: true,
                    value: [].concat(value || []).map(function (value) {
                        if (typeof value === 'string') {
                            return formatListUrl(value);
                        }
                        if (value && value.url) {
                            return formatListUrl(value.url) + (value.comment ? ' (' + value.comment + ')' : '');
                        }
                        return '';
                    }).join(', ')
                };
            })
        };
    });
};

},{"../package.json":90,"./http-proxy":37,"./template-sender":39,"events":16,"mailcomposer":68,"nodemailer-direct-transport":69,"nodemailer-shared":74,"nodemailer-smtp-pool":77,"nodemailer-smtp-transport":79,"socks":87,"url":30,"util":104}],39:[function(require,module,exports){
'use strict';

var shared = require('nodemailer-shared');

module.exports = templateSender;

// expose for testing
module.exports.render = render;

/**
 * Create template based e-mail sender
 *
 * @param {Object} transport Nodemailer transport object to use for actual sending
 * @param {Object} templates Either an object with template strings or an external renderer
 * @param {Object} [defaults] Default fields set for every mail sent using this sender
 * @return {Function} Template based sender
 */
function templateSender(transport, templates, defaults) {
    templates = templates || {};
    defaults = defaults || {};

    // built in renderer
    var defaultRenderer = function (context, callback) {
        var rendered = {};
        Object.keys(templates).forEach(function (key) {
            rendered[key] = render(templates[key], {
                escapeHtml: key === 'html'
            }, context);
        });
        callback(null, rendered);
    };

    // actual renderer
    var renderer = (typeof templates.render === 'function' ? templates.render.bind(templates) : defaultRenderer);

    return function (fields, context, callback) {

        var promise;

        if (!callback && typeof Promise === 'function') {
            promise = new Promise(function (resolve, reject) {
                callback = shared.callbackPromise(resolve, reject);
            });
        }

        // render data
        renderer(context, function (err, rendered) {
            if (err) {
                return callback(err);
            }
            var mailData = mix(defaults, fields, rendered);
            setImmediate(function () {
                transport.sendMail(mailData, callback);
            });
        });

        return promise;
    };
}

/**
 * Merges multiple objects into one. Assumes single level, except 'headers'
 */
function mix( /* obj1, obj2, ..., objN */ ) {
    var args = Array.prototype.slice.call(arguments);
    var result = {};

    args.forEach(function (arg) {
        Object.keys(arg || {}).forEach(function (key) {
            if (key === 'headers') {
                if (!result.headers) {
                    result.headers = {};
                }
                Object.keys(arg[key]).forEach(function (hKey) {
                    if (!(hKey in result.headers)) {
                        result.headers[hKey] = arg[key][hKey];
                    }
                });
            } else if (!(key in result)) {
                result[key] = arg[key];
            }
        });
    });

    return result;
}

/**
 * Renders a template string using provided context. Values are marked as {{key}} in the template.
 *
 * @param {String} str Template string
 * @param {Object} options Render options. options.escapeHtml=true escapes html specific characters
 * @param {Object} context Key-value pairs for the template, eg {name: 'User Name'}
 * @return {String} Rendered template
 */
function render(str, options, context) {
    str = (str || '').toString();
    context = context || {};
    options = options || {};

    var re = /\{\{[ ]*([^{}\s]+)[ ]*\}\}/g;

    return str.replace(re, function (match, key) {
        var value;
        if (context.hasOwnProperty(key)) {
            value = context[key].toString();
            if (options.escapeHtml) {
                value = value.replace(/["'&<>]/g, function (char) {
                    switch (char) {
                        case '&':
                            return '&amp;';
                        case '<':
                            return '&lt;';
                        case '>':
                            return '&gt;';
                        case '"':
                            return '&quot;';
                        case '\'':
                            return '&#039;';
                        default:
                            return char;
                    }
                });
            }
            return value;
        }
        return match;
    });
}

},{"nodemailer-shared":74}],40:[function(require,module,exports){
'use strict';

// expose to the world
module.exports = addressparser;

/**
 * Parses structured e-mail addresses from an address field
 *
 * Example:
 *
 *    'Name <address@domain>'
 *
 * will be converted to
 *
 *     [{name: 'Name', address: 'address@domain'}]
 *
 * @param {String} str Address field
 * @return {Array} An array of address objects
 */
function addressparser(str) {
    var tokenizer = new Tokenizer(str);
    var tokens = tokenizer.tokenize();

    var addresses = [];
    var address = [];
    var parsedAddresses = [];

    tokens.forEach(function (token) {
        if (token.type === 'operator' && (token.value === ',' || token.value === ';')) {
            if (address.length) {
                addresses.push(address);
            }
            address = [];
        } else {
            address.push(token);
        }
    });

    if (address.length) {
        addresses.push(address);
    }

    addresses.forEach(function (address) {
        address = _handleAddress(address);
        if (address.length) {
            parsedAddresses = parsedAddresses.concat(address);
        }
    });

    return parsedAddresses;
}

/**
 * Converts tokens for a single address into an address object
 *
 * @param {Array} tokens Tokens object
 * @return {Object} Address object
 */
function _handleAddress(tokens) {
    var token;
    var isGroup = false;
    var state = 'text';
    var address;
    var addresses = [];
    var data = {
        address: [],
        comment: [],
        group: [],
        text: []
    };
    var i;
    var len;

    // Filter out <addresses>, (comments) and regular text
    for (i = 0, len = tokens.length; i < len; i++) {
        token = tokens[i];
        if (token.type === 'operator') {
            switch (token.value) {
                case '<':
                    state = 'address';
                    break;
                case '(':
                    state = 'comment';
                    break;
                case ':':
                    state = 'group';
                    isGroup = true;
                    break;
                default:
                    state = 'text';
            }
        } else if (token.value) {
            if (state === 'address') {
                // handle use case where unquoted name includes a "<"
                // Apple Mail truncates everything between an unexpected < and an address
                // and so will we
                token.value = token.value.replace(/^[^<]*<\s*/, '');
            }
            data[state].push(token.value);
        }
    }

    // If there is no text but a comment, replace the two
    if (!data.text.length && data.comment.length) {
        data.text = data.comment;
        data.comment = [];
    }

    if (isGroup) {
        // http://tools.ietf.org/html/rfc2822#appendix-A.1.3
        data.text = data.text.join(' ');
        addresses.push({
            name: data.text || (address && address.name),
            group: data.group.length ? addressparser(data.group.join(',')) : []
        });
    } else {
        // If no address was found, try to detect one from regular text
        if (!data.address.length && data.text.length) {
            for (i = data.text.length - 1; i >= 0; i--) {
                if (data.text[i].match(/^[^@\s]+@[^@\s]+$/)) {
                    data.address = data.text.splice(i, 1);
                    break;
                }
            }

            var _regexHandler = function (address) {
                if (!data.address.length) {
                    data.address = [address.trim()];
                    return ' ';
                } else {
                    return address;
                }
            };

            // still no address
            if (!data.address.length) {
                for (i = data.text.length - 1; i >= 0; i--) {
                    // fixed the regex to parse email address correctly when email address has more than one @
                    data.text[i] = data.text[i].replace(/\s*\b[^@\s]+@[^\s]+\b\s*/, _regexHandler).trim();
                    if (data.address.length) {
                        break;
                    }
                }
            }
        }

        // If there's still is no text but a comment exixts, replace the two
        if (!data.text.length && data.comment.length) {
            data.text = data.comment;
            data.comment = [];
        }

        // Keep only the first address occurence, push others to regular text
        if (data.address.length > 1) {
            data.text = data.text.concat(data.address.splice(1));
        }

        // Join values with spaces
        data.text = data.text.join(' ');
        data.address = data.address.join(' ');

        if (!data.address && isGroup) {
            return [];
        } else {
            address = {
                address: data.address || data.text || '',
                name: data.text || data.address || ''
            };

            if (address.address === address.name) {
                if ((address.address || '').match(/@/)) {
                    address.name = '';
                } else {
                    address.address = '';
                }

            }

            addresses.push(address);
        }
    }

    return addresses;
}

/**
 * Creates a Tokenizer object for tokenizing address field strings
 *
 * @constructor
 * @param {String} str Address field string
 */
function Tokenizer(str) {
    this.str = (str || '').toString();
    this.operatorCurrent = '';
    this.operatorExpecting = '';
    this.node = null;
    this.escaped = false;

    this.list = [];
}

/**
 * Operator tokens and which tokens are expected to end the sequence
 */
Tokenizer.prototype.operators = {
    '"': '"',
    '(': ')',
    '<': '>',
    ',': '',
    ':': ';',
    // Semicolons are not a legal delimiter per the RFC2822 grammar other
    // than for terminating a group, but they are also not valid for any
    // other use in this context.  Given that some mail clients have
    // historically allowed the semicolon as a delimiter equivalent to the
    // comma in their UI, it makes sense to treat them the same as a comma
    // when used outside of a group.
    ';': ''
};

/**
 * Tokenizes the original input string
 *
 * @return {Array} An array of operator|text tokens
 */
Tokenizer.prototype.tokenize = function () {
    var chr, list = [];
    for (var i = 0, len = this.str.length; i < len; i++) {
        chr = this.str.charAt(i);
        this.checkChar(chr);
    }

    this.list.forEach(function (node) {
        node.value = (node.value || '').toString().trim();
        if (node.value) {
            list.push(node);
        }
    });

    return list;
};

/**
 * Checks if a character is an operator or text and acts accordingly
 *
 * @param {String} chr Character from the address field
 */
Tokenizer.prototype.checkChar = function (chr) {
    if ((chr in this.operators || chr === '\\') && this.escaped) {
        this.escaped = false;
    } else if (this.operatorExpecting && chr === this.operatorExpecting) {
        this.node = {
            type: 'operator',
            value: chr
        };
        this.list.push(this.node);
        this.node = null;
        this.operatorExpecting = '';
        this.escaped = false;
        return;
    } else if (!this.operatorExpecting && chr in this.operators) {
        this.node = {
            type: 'operator',
            value: chr
        };
        this.list.push(this.node);
        this.node = null;
        this.operatorExpecting = this.operators[chr];
        this.escaped = false;
        return;
    }

    if (!this.escaped && chr === '\\') {
        this.escaped = true;
        return;
    }

    if (!this.node) {
        this.node = {
            type: 'text',
            value: ''
        };
        this.list.push(this.node);
    }

    if (this.escaped && chr !== '\\') {
        this.node.value += '\\';
    }

    this.node.value += chr;
    this.escaped = false;
};

},{}],41:[function(require,module,exports){
(function (Buffer){
'use strict';

var libmime = require('libmime');
var libqp = require('libqp');
var libbase64 = require('libbase64');
var punycode = require('punycode');
var addressparser = require('addressparser');
var stream = require('stream');
var PassThrough = stream.PassThrough;
var fs = require('fs');
var fetch = require('nodemailer-fetch');

module.exports = MimeNode;

/**
 * Creates a new mime tree node. Assumes 'multipart/*' as the content type
 * if it is a branch, anything else counts as leaf. If rootNode is missing from
 * the options, assumes this is the root.
 *
 * @param {String} contentType Define the content type for the node. Can be left blank for attachments (derived from filename)
 * @param {Object} [options] optional options
 * @param {Object} [options.rootNode] root node for this tree
 * @param {Object} [options.parentNode] immediate parent for this node
 * @param {Object} [options.filename] filename for an attachment node
 * @param {String} [options.baseBoundary] shared part of the unique multipart boundary
 * @param {Boolean} [options.keepBcc] If true, do not exclude Bcc from the generated headers
 * @param {String} [options.textEncoding] either 'Q' (the default) or 'B'
 */
function MimeNode(contentType, options) {
    this.nodeCounter = 0;

    options = options || {};

    /**
     * shared part of the unique multipart boundary
     */
    this.baseBoundary = options.baseBoundary || Date.now().toString() + Math.random();

    /**
     * If date headers is missing and current node is the root, this value is used instead
     */
    this.date = new Date();

    /**
     * Root node for current mime tree
     */
    this.rootNode = options.rootNode || this;

    /**
     * If true include Bcc in generated headers (if available)
     */
    this.keepBcc = !!options.keepBcc;

    /**
     * If filename is specified but contentType is not (probably an attachment)
     * detect the content type from filename extension
     */
    if (options.filename) {
        /**
         * Filename for this node. Useful with attachments
         */
        this.filename = options.filename;
        if (!contentType) {
            contentType = libmime.detectMimeType(this.filename.split('.').pop());
        }
    }

    /**
     * Indicates which encoding should be used for header strings: "Q" or "B"
     */
    this.textEncoding = (options.textEncoding || '').toString().trim().charAt(0).toUpperCase();

    /**
     * Immediate parent for this node (or undefined if not set)
     */
    this.parentNode = options.parentNode;

    /**
     * An array for possible child nodes
     */
    this.childNodes = [];

    /**
     * Used for generating unique boundaries (prepended to the shared base)
     */
    this._nodeId = ++this.rootNode.nodeCounter;

    /**
     * A list of header values for this node in the form of [{key:'', value:''}]
     */
    this._headers = [];

    /**
     * True if the content only uses ASCII printable characters
     * @type {Boolean}
     */
    this._isPlainText = false;

    /**
     * True if the content is plain text but has longer lines than allowed
     * @type {Boolean}
     */
    this._hasLongLines = false;

    /**
     * If set, use instead this value for envelopes instead of generating one
     * @type {Boolean}
     */
    this._envelope = false;

    /**
     * If set then use this value as the stream content instead of building it
     * @type {String|Buffer|Stream}
     */
    this._raw = false;

    /**
     * Additional transform streams that the message will be piped before
     * exposing by createReadStream
     * @type {Array}
     */
    this._transforms = [];

    /**
     * If content type is set (or derived from the filename) add it to headers
     */
    if (contentType) {
        this.setHeader('content-type', contentType);
    }
}

/////// PUBLIC METHODS

/**
 * Creates and appends a child node.Arguments provided are passed to MimeNode constructor
 *
 * @param {String} [contentType] Optional content type
 * @param {Object} [options] Optional options object
 * @return {Object} Created node object
 */
MimeNode.prototype.createChild = function (contentType, options) {
    if (!options && typeof contentType === 'object') {
        options = contentType;
        contentType = undefined;
    }
    var node = new MimeNode(contentType, options);
    this.appendChild(node);
    return node;
};

/**
 * Appends an existing node to the mime tree. Removes the node from an existing
 * tree if needed
 *
 * @param {Object} childNode node to be appended
 * @return {Object} Appended node object
 */
MimeNode.prototype.appendChild = function (childNode) {

    if (childNode.rootNode !== this.rootNode) {
        childNode.rootNode = this.rootNode;
        childNode._nodeId = ++this.rootNode.nodeCounter;
    }

    childNode.parentNode = this;

    this.childNodes.push(childNode);
    return childNode;
};

/**
 * Replaces current node with another node
 *
 * @param {Object} node Replacement node
 * @return {Object} Replacement node
 */
MimeNode.prototype.replace = function (node) {
    if (node === this) {
        return this;
    }

    this.parentNode.childNodes.forEach(function (childNode, i) {
        if (childNode === this) {

            node.rootNode = this.rootNode;
            node.parentNode = this.parentNode;
            node._nodeId = this._nodeId;

            this.rootNode = this;
            this.parentNode = undefined;

            node.parentNode.childNodes[i] = node;
        }
    }.bind(this));

    return node;
};

/**
 * Removes current node from the mime tree
 *
 * @return {Object} removed node
 */
MimeNode.prototype.remove = function () {
    if (!this.parentNode) {
        return this;
    }

    for (var i = this.parentNode.childNodes.length - 1; i >= 0; i--) {
        if (this.parentNode.childNodes[i] === this) {
            this.parentNode.childNodes.splice(i, 1);
            this.parentNode = undefined;
            this.rootNode = this;
            return this;
        }
    }
};

/**
 * Sets a header value. If the value for selected key exists, it is overwritten.
 * You can set multiple values as well by using [{key:'', value:''}] or
 * {key: 'value'} as the first argument.
 *
 * @param {String|Array|Object} key Header key or a list of key value pairs
 * @param {String} value Header value
 * @return {Object} current node
 */
MimeNode.prototype.setHeader = function (key, value) {
    var added = false,
        headerValue;

    // Allow setting multiple headers at once
    if (!value && key && typeof key === 'object') {
        // allow {key:'content-type', value: 'text/plain'}
        if (key.key && 'value' in key) {
            this.setHeader(key.key, key.value);
        }
        // allow [{key:'content-type', value: 'text/plain'}]
        else if (Array.isArray(key)) {
            key.forEach(function (i) {
                this.setHeader(i.key, i.value);
            }.bind(this));
        }
        // allow {'content-type': 'text/plain'}
        else {
            Object.keys(key).forEach(function (i) {
                this.setHeader(i, key[i]);
            }.bind(this));
        }
        return this;
    }

    key = this._normalizeHeaderKey(key);

    headerValue = {
        key: key,
        value: value
    };

    // Check if the value exists and overwrite
    for (var i = 0, len = this._headers.length; i < len; i++) {
        if (this._headers[i].key === key) {
            if (!added) {
                // replace the first match
                this._headers[i] = headerValue;
                added = true;
            } else {
                // remove following matches
                this._headers.splice(i, 1);
                i--;
                len--;
            }
        }
    }

    // match not found, append the value
    if (!added) {
        this._headers.push(headerValue);
    }

    return this;
};

/**
 * Adds a header value. If the value for selected key exists, the value is appended
 * as a new field and old one is not touched.
 * You can set multiple values as well by using [{key:'', value:''}] or
 * {key: 'value'} as the first argument.
 *
 * @param {String|Array|Object} key Header key or a list of key value pairs
 * @param {String} value Header value
 * @return {Object} current node
 */
MimeNode.prototype.addHeader = function (key, value) {

    // Allow setting multiple headers at once
    if (!value && key && typeof key === 'object') {
        // allow {key:'content-type', value: 'text/plain'}
        if (key.key && key.value) {
            this.addHeader(key.key, key.value);
        }
        // allow [{key:'content-type', value: 'text/plain'}]
        else if (Array.isArray(key)) {
            key.forEach(function (i) {
                this.addHeader(i.key, i.value);
            }.bind(this));
        }
        // allow {'content-type': 'text/plain'}
        else {
            Object.keys(key).forEach(function (i) {
                this.addHeader(i, key[i]);
            }.bind(this));
        }
        return this;
    } else if (Array.isArray(value)) {
        value.forEach(function (val) {
            this.addHeader(key, val);
        }.bind(this));
        return this;
    }

    this._headers.push({
        key: this._normalizeHeaderKey(key),
        value: value
    });

    return this;
};

/**
 * Retrieves the first mathcing value of a selected key
 *
 * @param {String} key Key to search for
 * @retun {String} Value for the key
 */
MimeNode.prototype.getHeader = function (key) {
    key = this._normalizeHeaderKey(key);
    for (var i = 0, len = this._headers.length; i < len; i++) {
        if (this._headers[i].key === key) {
            return this._headers[i].value;
        }
    }
};

/**
 * Sets body content for current node. If the value is a string, charset is added automatically
 * to Content-Type (if it is text/*). If the value is a Buffer, you need to specify
 * the charset yourself
 *
 * @param (String|Buffer) content Body content
 * @return {Object} current node
 */
MimeNode.prototype.setContent = function (content) {
    var _self = this;
    this.content = content;
    if (typeof this.content.pipe === 'function') {
        // pre-stream handler. might be triggered if a stream is set as content
        // and 'error' fires before anything is done with this stream
        this._contentErrorHandler = function (err) {
            _self.content.removeListener('error', _self._contentErrorHandler);
            _self.content = err;
        };
        this.content.once('error', this._contentErrorHandler);
    } else if (typeof this.content === 'string') {
        this._isPlainText = libmime.isPlainText(this.content);
        if (this._isPlainText && libmime.hasLongerLines(this.content, 76)) {
            // If there are lines longer than 76 symbols/bytes do not use 7bit
            this._hasLongLines = true;
        }
    }
    return this;
};

MimeNode.prototype.build = function (callback) {
    var stream = this.createReadStream();
    var buf = [];
    var buflen = 0;
    var returned = false;

    stream.on('readable', function () {
        var chunk;

        while ((chunk = stream.read()) !== null) {
            buf.push(chunk);
            buflen += chunk.length;
        }
    });

    stream.once('error', function (err) {
        if (returned) {
            return;
        }
        returned = true;

        return callback(err);
    });

    stream.once('end', function (chunk) {
        if (returned) {
            return;
        }
        returned = true;

        if (chunk && chunk.length) {
            buf.push(chunk);
            buflen += chunk.length;
        }
        return callback(null, Buffer.concat(buf, buflen));
    });
};

MimeNode.prototype.getTransferEncoding = function () {
    var transferEncoding = false;
    var contentType = (this.getHeader('Content-Type') || '').toString().toLowerCase().trim();

    if (this.content) {
        transferEncoding = (this.getHeader('Content-Transfer-Encoding') || '').toString().toLowerCase().trim();
        if (!transferEncoding || ['base64', 'quoted-printable'].indexOf(transferEncoding) < 0) {
            if (/^text\//i.test(contentType)) {
                // If there are no special symbols, no need to modify the text
                if (this._isPlainText && !this._hasLongLines) {
                    transferEncoding = '7bit';
                } else if (typeof this.content === 'string' || this.content instanceof Buffer) {
                    // detect preferred encoding for string value
                    transferEncoding = this._getTextEncoding(this.content) === 'Q' ? 'quoted-printable' : 'base64';
                } else {
                    // we can not check content for a stream, so either use preferred encoding or fallback to QP
                    transferEncoding = this.transferEncoding === 'B' ? 'base64' : 'quoted-printable';
                }
            } else if (!/^(multipart|message)\//i.test(contentType)) {
                transferEncoding = transferEncoding || 'base64';
            }
        }
    }
    return transferEncoding;
};

/**
 * Builds the header block for the mime node. Append \r\n\r\n before writing the content
 *
 * @returns {String} Headers
 */
MimeNode.prototype.buildHeaders = function () {
    var _self = this;
    var transferEncoding = this.getTransferEncoding();
    var headers = [];

    if (transferEncoding) {
        this.setHeader('Content-Transfer-Encoding', transferEncoding);
    }

    if (this.filename && !this.getHeader('Content-Disposition')) {
        this.setHeader('Content-Disposition', 'attachment');
    }

    // Ensure mandatory header fields
    if (this.rootNode === this) {
        if (!this.getHeader('Date')) {
            this.setHeader('Date', this.date.toUTCString().replace(/GMT/, '+0000'));
        }

        // ensure that Message-Id is present
        this.messageId();

        if (!this.getHeader('MIME-Version')) {
            this.setHeader('MIME-Version', '1.0');
        }
    }

    this._headers.forEach(function (header) {
        var key = header.key;
        var value = header.value;
        var structured;
        var param;
        var options = {};
        var formattedHeaders = ['From', 'Sender', 'To', 'Cc', 'Bcc', 'Reply-To', 'Date', 'References'];

        if (value && formattedHeaders.indexOf(key) < 0 && typeof value === 'object') {
            Object.keys(value).forEach(function (key) {
                if (key !== 'value') {
                    options[key] = value[key];
                }
            });
            value = (value.value || '').toString();
            if (!value.trim()) {
                return;
            }
        }

        if (options.prepared) {
            // header value is
            headers.push(key + ': ' + value);
            return;
        }

        switch (header.key) {
            case 'Content-Disposition':
                structured = libmime.parseHeaderValue(value);
                if (_self.filename) {
                    structured.params.filename = _self.filename;
                }
                value = libmime.buildHeaderValue(structured);
                break;
            case 'Content-Type':
                structured = libmime.parseHeaderValue(value);

                _self._handleContentType(structured);

                if (structured.value.match(/^text\/plain\b/) && typeof _self.content === 'string' && /[\u0080-\uFFFF]/.test(_self.content)) {
                    structured.params.charset = 'utf-8';
                }

                value = libmime.buildHeaderValue(structured);

                if (_self.filename) {
                    // add support for non-compliant clients like QQ webmail
                    // we can't build the value with buildHeaderValue as the value is non standard and
                    // would be converted to parameter continuation encoding that we do not want
                    param = this._encodeWords(_self.filename);
                    if (param !== _self.filename || /[\s"=;]/.test(param)) {
                        // include value in quotes if needed
                        param = '"' + param + '"';
                    }
                    value += '; name=' + param;
                }
                break;
            case 'Bcc':
                if (!_self.keepBcc) {
                    // skip BCC values
                    return;
                }
                break;
        }

        value = _self._encodeHeaderValue(key, value);

        // skip empty lines
        if (!(value || '').toString().trim()) {
            return;
        }

        headers.push(libmime.foldLines(key + ': ' + value, 76));
    }.bind(this));

    return headers.join('\r\n');
};

/**
 * Streams the rfc2822 message from the current node. If this is a root node,
 * mandatory header fields are set if missing (Date, Message-Id, MIME-Version)
 *
 * @return {String} Compiled message
 */
MimeNode.prototype.createReadStream = function (options) {
    options = options || {};

    var outputStream = new PassThrough(options);
    var transform;

    this.stream(outputStream, options, function (err) {
        if (err) {
            outputStream.emit('error', err);
            return;
        }
        outputStream.end();
    });

    for (var i = 0, len = this._transforms.length; i < len; i++) {
        transform = typeof this._transforms[i] === 'function' ? this._transforms[i]() : this._transforms[i];
        outputStream.once('error', function (err) {
            transform.emit('error', err);
        });
        outputStream = outputStream.pipe(transform);
    }

    return outputStream;
};

/**
 * Appends a transform stream object to the transforms list. Final output
 * is passed through this stream before exposing
 *
 * @param {Object} transform Read-Write stream
 */
MimeNode.prototype.transform = function (transform) {
    this._transforms.push(transform);
};

MimeNode.prototype.stream = function (outputStream, options, done) {
    var _self = this;
    var transferEncoding = this.getTransferEncoding();
    var contentStream;
    var localStream;

    // protect actual callback against multiple triggering
    var returned = false;
    var callback = function (err) {
        if (returned) {
            return;
        }
        returned = true;
        done(err);
    };

    // pushes node content
    function sendContent() {
        if (_self.content) {

            if (Object.prototype.toString.call(_self.content) === '[object Error]') {
                // content is already errored
                return callback(_self.content);
            }

            if (typeof _self.content.pipe === 'function') {
                _self.content.removeListener('error', _self._contentErrorHandler);
                _self._contentErrorHandler = function (err) {
                    return callback(err);
                };
                _self.content.once('error', _self._contentErrorHandler);
            }

            if (['quoted-printable', 'base64'].indexOf(transferEncoding) >= 0) {
                contentStream = new(transferEncoding === 'base64' ? libbase64 : libqp).Encoder(options);

                contentStream.pipe(outputStream, {
                    end: false
                });
                contentStream.once('end', finalize);
                contentStream.once('error', function (err) {
                    return callback(err);
                });

                localStream = _self._getStream(_self.content);
                localStream.pipe(contentStream);
            } else {
                // anything that is not QP or Base54 passes as-is
                localStream = _self._getStream(_self.content);
                localStream.pipe(outputStream, {
                    end: false
                });
                localStream.once('end', finalize);
            }

            localStream.once('error', function (err) {
                return callback(err);
            });

            return;
        } else {
            return setImmediate(finalize);
        }
    }

    // for multipart nodes, push child nodes
    // for content nodes end the stream
    function finalize() {
        var childId = 0;
        var processChildNode = function () {
            if (childId >= _self.childNodes.length) {
                outputStream.write('\r\n--' + _self.boundary + '--\r\n');
                return callback();
            }
            var child = _self.childNodes[childId++];
            outputStream.write((childId > 1 ? '\r\n' : '') + '--' + _self.boundary + '\r\n');
            child.stream(outputStream, options, function (err) {
                if (err) {
                    return callback(err);
                }
                setImmediate(processChildNode);
            });
        };

        if (_self.multipart) {
            setImmediate(processChildNode);
        } else {
            return callback();
        }
    }

    if (this._raw) {
        setImmediate(function () {
            if (Object.prototype.toString.call(_self._raw) === '[object Error]') {
                // content is already errored
                return callback(_self._raw);
            }

            // remove default error handler (if set)
            if (typeof _self._raw.pipe === 'function') {
                _self._raw.removeListener('error', _self._contentErrorHandler);
            }

            var raw = _self._getStream(_self._raw);
            raw.pipe(outputStream, {
                end: false
            });
            raw.on('error', function (err) {
                outputStream.emit('error', err);
            });
            raw.on('end', finalize);
        });
    } else {
        outputStream.write(this.buildHeaders() + '\r\n\r\n');
        setImmediate(sendContent);
    }
};

/**
 * Sets envelope to be used instead of the generated one
 *
 * @return {Object} SMTP envelope in the form of {from: 'from@example.com', to: ['to@example.com']}
 */
MimeNode.prototype.setEnvelope = function (envelope) {
    var list;

    this._envelope = {
        from: false,
        to: []
    };

    if (envelope.from) {
        list = [];
        this._convertAddresses(this._parseAddresses(envelope.from), list);
        list = list.filter(function (address) {
            return address && address.address;
        });
        if (list.length && list[0]) {
            this._envelope.from = list[0].address;
        }
    }
    ['to', 'cc', 'bcc'].forEach(function (key) {
        if (envelope[key]) {
            this._convertAddresses(this._parseAddresses(envelope[key]), this._envelope.to);
        }
    }.bind(this));

    this._envelope.to = this._envelope.to.map(function (to) {
        return to.address;
    }).filter(function (address) {
        return address;
    });

    return this;
};

/**
 * Generates and returns an object with parsed address fields
 *
 * @return {Object} Address object
 */
MimeNode.prototype.getAddresses = function () {
    var addresses = {};

    this._headers.forEach(function (header) {
        var key = header.key.toLowerCase();
        if (['from', 'sender', 'reply-to', 'to', 'cc', 'bcc'].indexOf(key) >= 0) {
            if (!Array.isArray(addresses[key])) {
                addresses[key] = [];
            }

            this._convertAddresses(this._parseAddresses(header.value), addresses[key]);
        }
    }.bind(this));

    return addresses;
};

/**
 * Generates and returns SMTP envelope with the sender address and a list of recipients addresses
 *
 * @return {Object} SMTP envelope in the form of {from: 'from@example.com', to: ['to@example.com']}
 */
MimeNode.prototype.getEnvelope = function () {
    if (this._envelope) {
        return this._envelope;
    }

    var envelope = {
        from: false,
        to: []
    };
    this._headers.forEach(function (header) {
        var list = [];
        if (header.key === 'From' || (!envelope.from && ['Reply-To', 'Sender'].indexOf(header.key) >= 0)) {
            this._convertAddresses(this._parseAddresses(header.value), list);
            if (list.length && list[0]) {
                envelope.from = list[0].address;
            }
        } else if (['To', 'Cc', 'Bcc'].indexOf(header.key) >= 0) {
            this._convertAddresses(this._parseAddresses(header.value), envelope.to);
        }
    }.bind(this));

    envelope.to = envelope.to.map(function (to) {
        return to.address;
    });

    return envelope;
};

/**
 * Returns Message-Id value. If it does not exist, then creates one
 *
 * @return {String} Message-Id value
 */
MimeNode.prototype.messageId = function () {
    var messageId = this.getHeader('Message-Id');
    // You really should define your own Message-Id field!
    if (!messageId) {
        messageId = '<' +
            // crux to generate random strings like this:
            // "1401391905590-58aa8c32-d32a065c-c1a2aad2"
            [0, 0, 0].reduce(function (prev) {
                return prev + '-' + Math.floor((1 + Math.random()) * 0x100000000).
                toString(16).
                substring(1);
            }, Date.now()) +
            '@' +
            // try to use the domain of the FROM address or fallback localhost
            (this.getEnvelope().from || 'localhost').split('@').pop() +
            '>';
        this.setHeader('Message-Id', messageId);
    }

    return messageId;
};

/**
 * Sets pregenerated content that will be used as the output of this node
 *
 * @param {String|Buffer|Stream} Raw MIME contents
 */
MimeNode.prototype.setRaw = function (raw) {
    var _self = this;

    this._raw = raw;

    if (this._raw && typeof this._raw.pipe === 'function') {
        // pre-stream handler. might be triggered if a stream is set as content
        // and 'error' fires before anything is done with this stream
        this._contentErrorHandler = function (err) {
            _self._raw.removeListener('error', _self._contentErrorHandler);
            _self._raw = err;
        };
        _self._raw.once('error', this._contentErrorHandler);
    }

    return this;
};

/////// PRIVATE METHODS

/**
 * Detects and returns handle to a stream related with the content.
 *
 * @param {Mixed} content Node content
 * @returns {Object} Stream object
 */
MimeNode.prototype._getStream = function (content) {
    var contentStream;

    if (typeof content.pipe === 'function') {
        // assume as stream
        return content;
    } else if (content && typeof content.path === 'string' && !content.href) {
        // read file
        return fs.createReadStream(content.path);
    } else if (content && typeof content.href === 'string') {
        // fetch URL
        return fetch(content.href);
    } else {
        // pass string or buffer content as a stream
        contentStream = new PassThrough();
        setImmediate(function () {
            contentStream.end(content || '');
        });
        return contentStream;
    }
};

/**
 * Parses addresses. Takes in a single address or an array or an
 * array of address arrays (eg. To: [[first group], [second group],...])
 *
 * @param {Mixed} addresses Addresses to be parsed
 * @return {Array} An array of address objects
 */
MimeNode.prototype._parseAddresses = function (addresses) {
    return [].concat.apply([], [].concat(addresses).map(function (address) {
        if (address && address.address) {
            address = this._convertAddresses(address);
        }
        return addressparser(address);
    }.bind(this)));
};

/**
 * Normalizes a header key, uses Camel-Case form, except for uppercase MIME-
 *
 * @param {String} key Key to be normalized
 * @return {String} key in Camel-Case form
 */
MimeNode.prototype._normalizeHeaderKey = function (key) {
    return (key || '').toString().
        // no newlines in keys
    replace(/\r?\n|\r/g, ' ').
    trim().toLowerCase().
        // use uppercase words, except MIME
    replace(/^MIME\b|^[a-z]|\-[a-z]/ig, function (c) {
        return c.toUpperCase();
    });
};

/**
 * Checks if the content type is multipart and defines boundary if needed.
 * Doesn't return anything, modifies object argument instead.
 *
 * @param {Object} structured Parsed header value for 'Content-Type' key
 */
MimeNode.prototype._handleContentType = function (structured) {
    this.contentType = structured.value.trim().toLowerCase();

    this.multipart = this.contentType.split('/').reduce(function (prev, value) {
        return prev === 'multipart' ? value : false;
    });

    if (this.multipart) {
        this.boundary = structured.params.boundary = structured.params.boundary || this.boundary || this._generateBoundary();
    } else {
        this.boundary = false;
    }
};

/**
 * Generates a multipart boundary value
 *
 * @return {String} boundary value
 */
MimeNode.prototype._generateBoundary = function () {
    return '----sinikael-?=_' + this._nodeId + '-' + this.rootNode.baseBoundary;
};

/**
 * Encodes a header value for use in the generated rfc2822 email.
 *
 * @param {String} key Header key
 * @param {String} value Header value
 */
MimeNode.prototype._encodeHeaderValue = function (key, value) {
    key = this._normalizeHeaderKey(key);

    switch (key) {

        // Structured headers
        case 'From':
        case 'Sender':
        case 'To':
        case 'Cc':
        case 'Bcc':
        case 'Reply-To':
            return this._convertAddresses(this._parseAddresses(value));

            // values enclosed in <>
        case 'Message-Id':
        case 'In-Reply-To':
        case 'Content-Id':
            value = (value || '').toString().replace(/\r?\n|\r/g, ' ');

            if (value.charAt(0) !== '<') {
                value = '<' + value;
            }

            if (value.charAt(value.length - 1) !== '>') {
                value = value + '>';
            }
            return value;

            // space separated list of values enclosed in <>
        case 'References':
            value = [].concat.apply([], [].concat(value || '').map(function (elm) {
                elm = (elm || '').toString().replace(/\r?\n|\r/g, ' ').trim();
                return elm.replace(/<[^>]*>/g, function (str) {
                    return str.replace(/\s/g, '');
                }).split(/\s+/);
            })).map(function (elm) {
                if (elm.charAt(0) !== '<') {
                    elm = '<' + elm;
                }
                if (elm.charAt(elm.length - 1) !== '>') {
                    elm = elm + '>';
                }
                return elm;
            });

            return value.join(' ').trim();

        case 'Date':
            if (Object.prototype.toString.call(value) === '[object Date]') {
                return value.toUTCString().replace(/GMT/, '+0000');
            }

            value = (value || '').toString().replace(/\r?\n|\r/g, ' ');
            return this._encodeWords(value);

        default:
            value = (value || '').toString().replace(/\r?\n|\r/g, ' ');
            // encodeWords only encodes if needed, otherwise the original string is returned
            return this._encodeWords(value);
    }
};

/**
 * Rebuilds address object using punycode and other adjustments
 *
 * @param {Array} addresses An array of address objects
 * @param {Array} [uniqueList] An array to be populated with addresses
 * @return {String} address string
 */
MimeNode.prototype._convertAddresses = function (addresses, uniqueList) {
    var values = [];

    uniqueList = uniqueList || [];

    [].concat(addresses || []).forEach(function (address) {
        if (address.address) {
            address.address = address.address.replace(/@.+$/, function (domain) {
                // usernames are not touched and are kept as is even if these include unicode
                // domains are punycoded by default
                // 'jgeva.ee' will be converted to 'xn--jgeva-dua.ee'
                // non-unicode domains are left as is
                return '@' + punycode.toASCII(domain.substr(1));
            });

            if (!address.name) {
                values.push(address.address);
            } else if (address.name) {
                values.push(this._encodeAddressName(address.name) + ' <' + address.address + '>');
            }

            if (address.address) {
                if (!uniqueList.filter(
                        function (a) {
                            return a.address === address.address;
                        }).length) {
                    uniqueList.push(address);
                }
            }
        } else if (address.group) {
            values.push(this._encodeAddressName(address.name) + ':' + (address.group.length ? this._convertAddresses(address.group, uniqueList) : '').trim() + ';');
        }
    }.bind(this));

    return values.join(', ');
};

/**
 * If needed, mime encodes the name part
 *
 * @param {String} name Name part of an address
 * @returns {String} Mime word encoded string if needed
 */
MimeNode.prototype._encodeAddressName = function (name) {
    if (!/^[\w ']*$/.test(name)) {
        if (/^[\x20-\x7e]*$/.test(name)) {
            return '"' + name.replace(/([\\"])/g, '\\$1') + '"';
        } else {
            return libmime.encodeWord(name, this._getTextEncoding(name), 52);
        }
    }
    return name;
};

/**
 * If needed, mime encodes the name part
 *
 * @param {String} name Name part of an address
 * @returns {String} Mime word encoded string if needed
 */
MimeNode.prototype._encodeWords = function (value) {
    return libmime.encodeWords(value, this._getTextEncoding(value), 52);
};

/**
 * Detects best mime encoding for a text value
 *
 * @param {String} value Value to check for
 * @return {String} either 'Q' or 'B'
 */
MimeNode.prototype._getTextEncoding = function (value) {
    value = (value || '').toString();

    var encoding = this.textEncoding;
    var latinLen;
    var nonLatinLen;

    if (!encoding) {
        // count latin alphabet symbols and 8-bit range symbols + control symbols
        // if there are more latin characters, then use quoted-printable
        // encoding, otherwise use base64
        nonLatinLen = (value.match(/[\x00-\x08\x0B\x0C\x0E-\x1F\u0080-\uFFFF]/g) || []).length;
        latinLen = (value.match(/[a-z]/gi) || []).length;
        // if there are more latin symbols than binary/unicode, then prefer Q, otherwise B
        encoding = nonLatinLen < latinLen ? 'Q' : 'B';
    }
    return encoding;
};

}).call(this,require("buffer").Buffer)
},{"addressparser":40,"buffer":9,"fs":8,"libbase64":63,"libmime":65,"libqp":67,"nodemailer-fetch":73,"punycode":18,"stream":23}],42:[function(require,module,exports){
(function (Buffer){
var crypto = require('crypto');

var flags = {
	NTLM_NegotiateUnicode                :  0x00000001,
	NTLM_NegotiateOEM                    :  0x00000002,
	NTLM_RequestTarget                   :  0x00000004,
	NTLM_Unknown9                        :  0x00000008,
	NTLM_NegotiateSign                   :  0x00000010,
	NTLM_NegotiateSeal                   :  0x00000020,
	NTLM_NegotiateDatagram               :  0x00000040,
	NTLM_NegotiateLanManagerKey          :  0x00000080,
	NTLM_Unknown8                        :  0x00000100,
	NTLM_NegotiateNTLM                   :  0x00000200,
	NTLM_NegotiateNTOnly                 :  0x00000400,
	NTLM_Anonymous                       :  0x00000800,
	NTLM_NegotiateOemDomainSupplied      :  0x00001000,
	NTLM_NegotiateOemWorkstationSupplied :  0x00002000,
	NTLM_Unknown6                        :  0x00004000,
	NTLM_NegotiateAlwaysSign             :  0x00008000,
	NTLM_TargetTypeDomain                :  0x00010000,
	NTLM_TargetTypeServer                :  0x00020000,
	NTLM_TargetTypeShare                 :  0x00040000,
	NTLM_NegotiateExtendedSecurity       :  0x00080000,
	NTLM_NegotiateIdentify               :  0x00100000,
	NTLM_Unknown5                        :  0x00200000,
	NTLM_RequestNonNTSessionKey          :  0x00400000,
	NTLM_NegotiateTargetInfo             :  0x00800000,
	NTLM_Unknown4                        :  0x01000000,
	NTLM_NegotiateVersion                :  0x02000000,
	NTLM_Unknown3                        :  0x04000000,
	NTLM_Unknown2                        :  0x08000000,
	NTLM_Unknown1                        :  0x10000000,
	NTLM_Negotiate128                    :  0x20000000,
	NTLM_NegotiateKeyExchange            :  0x40000000,
	NTLM_Negotiate56                     :  0x80000000
};
var typeflags = {
	NTLM_TYPE1_FLAGS : 	  flags.NTLM_NegotiateUnicode
						+ flags.NTLM_NegotiateOEM
						+ flags.NTLM_RequestTarget
						+ flags.NTLM_NegotiateNTLM
						+ flags.NTLM_NegotiateOemDomainSupplied
						+ flags.NTLM_NegotiateOemWorkstationSupplied
						+ flags.NTLM_NegotiateAlwaysSign
						+ flags.NTLM_NegotiateExtendedSecurity
						+ flags.NTLM_NegotiateVersion
						+ flags.NTLM_Negotiate128
						+ flags.NTLM_Negotiate56,

	NTLM_TYPE2_FLAGS :    flags.NTLM_NegotiateUnicode
						+ flags.NTLM_RequestTarget
						+ flags.NTLM_NegotiateNTLM
						+ flags.NTLM_NegotiateAlwaysSign
						+ flags.NTLM_NegotiateExtendedSecurity
						+ flags.NTLM_NegotiateTargetInfo
						+ flags.NTLM_NegotiateVersion
						+ flags.NTLM_Negotiate128
						+ flags.NTLM_Negotiate56
};

function createType1Message(options){
	var domain = escape(options.domain.toUpperCase());
	var workstation = escape(options.workstation.toUpperCase());
	var protocol = 'NTLMSSP\0';

	var BODY_LENGTH = 40;

	var type1flags = typeflags.NTLM_TYPE1_FLAGS;
	if(!domain || domain === '')
		type1flags = type1flags - flags.NTLM_NegotiateOemDomainSupplied;

	var pos = 0;
	var buf = new Buffer(BODY_LENGTH + domain.length + workstation.length);


	buf.write(protocol, pos, protocol.length); pos += protocol.length; // protocol
	buf.writeUInt32LE(1, pos); pos += 4;          // type 1
	buf.writeUInt32LE(type1flags, pos); pos += 4; // TYPE1 flag

	buf.writeUInt16LE(domain.length, pos); pos += 2; // domain length
	buf.writeUInt16LE(domain.length, pos); pos += 2; // domain max length
	buf.writeUInt32LE(BODY_LENGTH + workstation.length, pos); pos += 4; // domain buffer offset

	buf.writeUInt16LE(workstation.length, pos); pos += 2; // workstation length
	buf.writeUInt16LE(workstation.length, pos); pos += 2; // workstation max length
	buf.writeUInt32LE(BODY_LENGTH, pos); pos += 4; // workstation buffer offset

	buf.writeUInt8(5, pos); pos += 1;      //ProductMajorVersion
	buf.writeUInt8(1, pos); pos += 1;      //ProductMinorVersion
	buf.writeUInt16LE(2600, pos); pos += 2; //ProductBuild

	buf.writeUInt8(0 , pos); pos += 1; //VersionReserved1
	buf.writeUInt8(0 , pos); pos += 1; //VersionReserved2
	buf.writeUInt8(0 , pos); pos += 1; //VersionReserved3
	buf.writeUInt8(15, pos); pos += 1; //NTLMRevisionCurrent

	buf.write(workstation, pos, workstation.length, 'ascii'); pos += workstation.length; // workstation string
	buf.write(domain     , pos, domain.length     , 'ascii'); pos += domain.length;

	return 'NTLM ' + buf.toString('base64');
}

function parseType2Message(rawmsg, callback){
	var match = rawmsg.match(/NTLM (.+)?/);
	if(!match || !match[1])
		return callback(new Error("Couldn't find NTLM in the message type2 comming from the server"));

	var buf = new Buffer(match[1], 'base64');

	var msg = {};

	msg.signature = buf.slice(0, 8);
	msg.type = buf.readInt16LE(8);

	if(msg.type != 2)
		return callback(new Error("Server didn't return a type 2 message"));

	msg.targetNameLen = buf.readInt16LE(12);
	msg.targetNameMaxLen = buf.readInt16LE(14);
	msg.targetNameOffset = buf.readInt32LE(16);
	msg.targetName  = buf.slice(msg.targetNameOffset, msg.targetNameOffset + msg.targetNameMaxLen);

    msg.negotiateFlags = buf.readInt32LE(20);
    msg.serverChallenge = buf.slice(24, 32);
    msg.reserved = buf.slice(32, 40);

    if(msg.negotiateFlags & flags.NTLM_NegotiateTargetInfo){
    	msg.targetInfoLen = buf.readInt16LE(40);
    	msg.targetInfoMaxLen = buf.readInt16LE(42);
    	msg.targetInfoOffset = buf.readInt32LE(44);
    	msg.targetInfo = buf.slice(msg.targetInfoOffset, msg.targetInfoOffset + msg.targetInfoLen);
    }
	return msg;
}

function createType3Message(msg2, options){
	var nonce = msg2.serverChallenge;
	var username = options.username;
	var password = options.password;
	var negotiateFlags = msg2.negotiateFlags;

	var isUnicode = negotiateFlags & flags.NTLM_NegotiateUnicode;
	var isNegotiateExtendedSecurity = negotiateFlags & flags.NTLM_NegotiateExtendedSecurity;

	var BODY_LENGTH = 72;

	var domainName = escape(options.domain.toUpperCase());
	var workstation = escape(options.workstation.toUpperCase());

	var workstationBytes, domainNameBytes, usernameBytes, encryptedRandomSessionKeyBytes;

	var encryptedRandomSessionKey = "";
	if(isUnicode){
		workstationBytes = new Buffer(workstation, 'utf16le');
		domainNameBytes = new Buffer(domainName, 'utf16le');
		usernameBytes = new Buffer(username, 'utf16le');
		encryptedRandomSessionKeyBytes = new Buffer(encryptedRandomSessionKey, 'utf16le');
	}else{
		workstationBytes = new Buffer(workstation, 'ascii');
		domainNameBytes = new Buffer(domainName, 'ascii');
		usernameBytes = new Buffer(username, 'ascii');
		encryptedRandomSessionKeyBytes = new Buffer(encryptedRandomSessionKey, 'ascii');
	}

	var lmChallengeResponse = calc_resp(create_LM_hashed_password_v1(password), nonce);
	var ntChallengeResponse = calc_resp(create_NT_hashed_password_v1(password), nonce);

	if(isNegotiateExtendedSecurity){
		var pwhash = create_NT_hashed_password_v1(password);
	 	var clientChallenge = "";
	 	for(var i=0; i < 8; i++){
	 		clientChallenge += String.fromCharCode( Math.floor(Math.random()*256) );
	   	}
	   	var clientChallengeBytes = new Buffer(clientChallenge, 'ascii');
	    var challenges = ntlm2sr_calc_resp(pwhash, nonce, clientChallengeBytes);
	    lmChallengeResponse = challenges.lmChallengeResponse;
	    ntChallengeResponse = challenges.ntChallengeResponse;
	}

	var signature = 'NTLMSSP\0';

	var pos = 0;
	var buf = new Buffer(BODY_LENGTH + domainNameBytes.length + usernameBytes.length + workstationBytes.length + lmChallengeResponse.length + ntChallengeResponse.length + encryptedRandomSessionKeyBytes.length);

	buf.write(signature, pos, signature.length); pos += signature.length;
	buf.writeUInt32LE(3, pos); pos += 4;          // type 1

	buf.writeUInt16LE(lmChallengeResponse.length, pos); pos += 2; // LmChallengeResponseLen
	buf.writeUInt16LE(lmChallengeResponse.length, pos); pos += 2; // LmChallengeResponseMaxLen
	buf.writeUInt32LE(BODY_LENGTH + domainNameBytes.length + usernameBytes.length + workstationBytes.length, pos); pos += 4; // LmChallengeResponseOffset

	buf.writeUInt16LE(ntChallengeResponse.length, pos); pos += 2; // NtChallengeResponseLen
	buf.writeUInt16LE(ntChallengeResponse.length, pos); pos += 2; // NtChallengeResponseMaxLen
	buf.writeUInt32LE(BODY_LENGTH + domainNameBytes.length + usernameBytes.length + workstationBytes.length + lmChallengeResponse.length, pos); pos += 4; // NtChallengeResponseOffset

	buf.writeUInt16LE(domainNameBytes.length, pos); pos += 2; // DomainNameLen
	buf.writeUInt16LE(domainNameBytes.length, pos); pos += 2; // DomainNameMaxLen
	buf.writeUInt32LE(BODY_LENGTH, pos); pos += 4; 			  // DomainNameOffset

	buf.writeUInt16LE(usernameBytes.length, pos); pos += 2; // UserNameLen
	buf.writeUInt16LE(usernameBytes.length, pos); pos += 2; // UserNameMaxLen
	buf.writeUInt32LE(BODY_LENGTH + domainNameBytes.length, pos); pos += 4; // UserNameOffset

	buf.writeUInt16LE(workstationBytes.length, pos); pos += 2; // WorkstationLen
	buf.writeUInt16LE(workstationBytes.length, pos); pos += 2; // WorkstationMaxLen
	buf.writeUInt32LE(BODY_LENGTH + domainNameBytes.length + usernameBytes.length, pos); pos += 4; // WorkstationOffset

	buf.writeUInt16LE(encryptedRandomSessionKeyBytes.length, pos); pos += 2; // EncryptedRandomSessionKeyLen
	buf.writeUInt16LE(encryptedRandomSessionKeyBytes.length, pos); pos += 2; // EncryptedRandomSessionKeyMaxLen
	buf.writeUInt32LE(BODY_LENGTH + domainNameBytes.length + usernameBytes.length + workstationBytes.length + lmChallengeResponse.length + ntChallengeResponse.length, pos); pos += 4; // EncryptedRandomSessionKeyOffset

	buf.writeUInt32LE(typeflags.NTLM_TYPE2_FLAGS, pos); pos += 4; // NegotiateFlags

	buf.writeUInt8(5, pos); pos++; // ProductMajorVersion
	buf.writeUInt8(1, pos); pos++; // ProductMinorVersion
	buf.writeUInt16LE(2600, pos); pos += 2; // ProductBuild
	buf.writeUInt8(0, pos); pos++; // VersionReserved1
	buf.writeUInt8(0, pos); pos++; // VersionReserved2
	buf.writeUInt8(0, pos); pos++; // VersionReserved3
	buf.writeUInt8(15, pos); pos++; // NTLMRevisionCurrent

	domainNameBytes.copy(buf, pos); pos += domainNameBytes.length;
	usernameBytes.copy(buf, pos); pos += usernameBytes.length;
	workstationBytes.copy(buf, pos); pos += workstationBytes.length;
	lmChallengeResponse.copy(buf, pos); pos += lmChallengeResponse.length;
	ntChallengeResponse.copy(buf, pos); pos += ntChallengeResponse.length;
	encryptedRandomSessionKeyBytes.copy(buf, pos); pos += encryptedRandomSessionKeyBytes.length;

	return 'NTLM ' + buf.toString('base64');
}

function create_LM_hashed_password_v1(password){
	// fix the password length to 14 bytes
	password = password.toUpperCase();
	var passwordBytes = new Buffer(password, 'ascii');

	var passwordBytesPadded = new Buffer(14);
	passwordBytesPadded.fill("\0");
	var sourceEnd = 14;
	if(passwordBytes.length < 14) sourceEnd = passwordBytes.length;
	passwordBytes.copy(passwordBytesPadded, 0, 0, sourceEnd);

	// split into 2 parts of 7 bytes:
	var firstPart = passwordBytesPadded.slice(0,7);
	var secondPart = passwordBytesPadded.slice(7);

	function encrypt(buf){
		var key = insertZerosEvery7Bits(buf);
		var des = crypto.createCipheriv('DES-ECB', key, '');
		return des.update("KGS!@#$%"); // page 57 in [MS-NLMP]);
	}

	var firstPartEncrypted = encrypt(firstPart);
	var secondPartEncrypted = encrypt(secondPart);

	return Buffer.concat([firstPartEncrypted, secondPartEncrypted]);
}

function insertZerosEvery7Bits(buf){
	var binaryArray = bytes2binaryArray(buf);
	var newBinaryArray = [];
	for(var i=0; i<binaryArray.length; i++){
		newBinaryArray.push(binaryArray[i]);

		if((i+1)%7 === 0){
			newBinaryArray.push(0);
		}
	}
	return binaryArray2bytes(newBinaryArray);
}

function bytes2binaryArray(buf){
	var hex2binary = {
		0: [0,0,0,0],
		1: [0,0,0,1],
		2: [0,0,1,0],
		3: [0,0,1,1],
		4: [0,1,0,0],
		5: [0,1,0,1],
		6: [0,1,1,0],
		7: [0,1,1,1],
		8: [1,0,0,0],
		9: [1,0,0,1],
		A: [1,0,1,0],
		B: [1,0,1,1],
		C: [1,1,0,0],
		D: [1,1,0,1],
		E: [1,1,1,0],
		F: [1,1,1,1]
	};

	var hexString = buf.toString('hex').toUpperCase();
	var array = [];
	for(var i=0; i<hexString.length; i++){
   		var hexchar = hexString.charAt(i);
   		array = array.concat(hex2binary[hexchar]);
   	}
   	return array;
}

function binaryArray2bytes(array){
	var binary2hex = {
		'0000': 0,
		'0001': 1,
		'0010': 2,
		'0011': 3,
		'0100': 4,
		'0101': 5,
		'0110': 6,
		'0111': 7,
		'1000': 8,
		'1001': 9,
		'1010': 'A',
		'1011': 'B',
		'1100': 'C',
		'1101': 'D',
		'1110': 'E',
		'1111': 'F'
	};

 	var bufArray = [];

	for(var i=0; i<array.length; i +=8 ){
		if((i+7) > array.length)
			break;

		var binString1 = '' + array[i] + '' + array[i+1] + '' + array[i+2] + '' + array[i+3];
		var binString2 = '' + array[i+4] + '' + array[i+5] + '' + array[i+6] + '' + array[i+7];
   		var hexchar1 = binary2hex[binString1];
   		var hexchar2 = binary2hex[binString2];

   		var buf = new Buffer(hexchar1 + '' + hexchar2, 'hex');
   		bufArray.push(buf);
   	}

   	return Buffer.concat(bufArray);
}

function create_NT_hashed_password_v1(password){
	var buf = new Buffer(password, 'utf16le');
	var md4 = crypto.createHash('md4');
	md4.update(buf);
	return new Buffer(md4.digest());
}

function calc_resp(password_hash, server_challenge){
    // padding with zeros to make the hash 21 bytes long
    var passHashPadded = new Buffer(21);
    passHashPadded.fill("\0");
    password_hash.copy(passHashPadded, 0, 0, password_hash.length);

    var resArray = [];

    var des = crypto.createCipheriv('DES-ECB', insertZerosEvery7Bits(passHashPadded.slice(0,7)), '');
    resArray.push( des.update(server_challenge.slice(0,8)) );

    des = crypto.createCipheriv('DES-ECB', insertZerosEvery7Bits(passHashPadded.slice(7,14)), '');
    resArray.push( des.update(server_challenge.slice(0,8)) );

    des = crypto.createCipheriv('DES-ECB', insertZerosEvery7Bits(passHashPadded.slice(14,21)), '');
    resArray.push( des.update(server_challenge.slice(0,8)) );

   	return Buffer.concat(resArray);
}

function ntlm2sr_calc_resp(responseKeyNT, serverChallenge, clientChallenge){
	// padding with zeros to make the hash 16 bytes longer
    var lmChallengeResponse = new Buffer(clientChallenge.length + 16);
    lmChallengeResponse.fill("\0");
    clientChallenge.copy(lmChallengeResponse, 0, 0, clientChallenge.length);

    var buf = Buffer.concat([serverChallenge, clientChallenge]);
    var md5 = crypto.createHash('md5');
    md5.update(buf);
    var sess = md5.digest();
    var ntChallengeResponse = calc_resp(responseKeyNT, sess.slice(0,8));

    return {
    	lmChallengeResponse: lmChallengeResponse,
    	ntChallengeResponse: ntChallengeResponse
    };
}

exports.createType1Message = createType1Message;
exports.parseType2Message = parseType2Message;
exports.createType3Message = createType3Message;





}).call(this,require("buffer").Buffer)
},{"buffer":9,"crypto":11}],43:[function(require,module,exports){
(function (Buffer){
"use strict"

// Multibyte codec. In this scheme, a character is represented by 1 or more bytes.
// Our codec supports UTF-16 surrogates, extensions for GB18030 and unicode sequences.
// To save memory and loading time, we read table files only when requested.

exports._dbcs = DBCSCodec;

var UNASSIGNED = -1,
    GB18030_CODE = -2,
    SEQ_START  = -10,
    NODE_START = -1000,
    UNASSIGNED_NODE = new Array(0x100),
    DEF_CHAR = -1;

for (var i = 0; i < 0x100; i++)
    UNASSIGNED_NODE[i] = UNASSIGNED;


// Class DBCSCodec reads and initializes mapping tables.
function DBCSCodec(codecOptions, iconv) {
    this.encodingName = codecOptions.encodingName;
    if (!codecOptions)
        throw new Error("DBCS codec is called without the data.")
    if (!codecOptions.table)
        throw new Error("Encoding '" + this.encodingName + "' has no data.");

    // Load tables.
    var mappingTable = codecOptions.table();


    // Decode tables: MBCS -> Unicode.

    // decodeTables is a trie, encoded as an array of arrays of integers. Internal arrays are trie nodes and all have len = 256.
    // Trie root is decodeTables[0].
    // Values: >=  0 -> unicode character code. can be > 0xFFFF
    //         == UNASSIGNED -> unknown/unassigned sequence.
    //         == GB18030_CODE -> this is the end of a GB18030 4-byte sequence.
    //         <= NODE_START -> index of the next node in our trie to process next byte.
    //         <= SEQ_START  -> index of the start of a character code sequence, in decodeTableSeq.
    this.decodeTables = [];
    this.decodeTables[0] = UNASSIGNED_NODE.slice(0); // Create root node.

    // Sometimes a MBCS char corresponds to a sequence of unicode chars. We store them as arrays of integers here. 
    this.decodeTableSeq = [];

    // Actual mapping tables consist of chunks. Use them to fill up decode tables.
    for (var i = 0; i < mappingTable.length; i++)
        this._addDecodeChunk(mappingTable[i]);

    this.defaultCharUnicode = iconv.defaultCharUnicode;

    
    // Encode tables: Unicode -> DBCS.

    // `encodeTable` is array mapping from unicode char to encoded char. All its values are integers for performance.
    // Because it can be sparse, it is represented as array of buckets by 256 chars each. Bucket can be null.
    // Values: >=  0 -> it is a normal char. Write the value (if <=256 then 1 byte, if <=65536 then 2 bytes, etc.).
    //         == UNASSIGNED -> no conversion found. Output a default char.
    //         <= SEQ_START  -> it's an index in encodeTableSeq, see below. The character starts a sequence.
    this.encodeTable = [];
    
    // `encodeTableSeq` is used when a sequence of unicode characters is encoded as a single code. We use a tree of
    // objects where keys correspond to characters in sequence and leafs are the encoded dbcs values. A special DEF_CHAR key
    // means end of sequence (needed when one sequence is a strict subsequence of another).
    // Objects are kept separately from encodeTable to increase performance.
    this.encodeTableSeq = [];

    // Some chars can be decoded, but need not be encoded.
    var skipEncodeChars = {};
    if (codecOptions.encodeSkipVals)
        for (var i = 0; i < codecOptions.encodeSkipVals.length; i++) {
            var val = codecOptions.encodeSkipVals[i];
            if (typeof val === 'number')
                skipEncodeChars[val] = true;
            else
                for (var j = val.from; j <= val.to; j++)
                    skipEncodeChars[j] = true;
        }
        
    // Use decode trie to recursively fill out encode tables.
    this._fillEncodeTable(0, 0, skipEncodeChars);

    // Add more encoding pairs when needed.
    if (codecOptions.encodeAdd) {
        for (var uChar in codecOptions.encodeAdd)
            if (Object.prototype.hasOwnProperty.call(codecOptions.encodeAdd, uChar))
                this._setEncodeChar(uChar.charCodeAt(0), codecOptions.encodeAdd[uChar]);
    }

    this.defCharSB  = this.encodeTable[0][iconv.defaultCharSingleByte.charCodeAt(0)];
    if (this.defCharSB === UNASSIGNED) this.defCharSB = this.encodeTable[0]['?'];
    if (this.defCharSB === UNASSIGNED) this.defCharSB = "?".charCodeAt(0);


    // Load & create GB18030 tables when needed.
    if (typeof codecOptions.gb18030 === 'function') {
        this.gb18030 = codecOptions.gb18030(); // Load GB18030 ranges.

        // Add GB18030 decode tables.
        var thirdByteNodeIdx = this.decodeTables.length;
        var thirdByteNode = this.decodeTables[thirdByteNodeIdx] = UNASSIGNED_NODE.slice(0);

        var fourthByteNodeIdx = this.decodeTables.length;
        var fourthByteNode = this.decodeTables[fourthByteNodeIdx] = UNASSIGNED_NODE.slice(0);

        for (var i = 0x81; i <= 0xFE; i++) {
            var secondByteNodeIdx = NODE_START - this.decodeTables[0][i];
            var secondByteNode = this.decodeTables[secondByteNodeIdx];
            for (var j = 0x30; j <= 0x39; j++)
                secondByteNode[j] = NODE_START - thirdByteNodeIdx;
        }
        for (var i = 0x81; i <= 0xFE; i++)
            thirdByteNode[i] = NODE_START - fourthByteNodeIdx;
        for (var i = 0x30; i <= 0x39; i++)
            fourthByteNode[i] = GB18030_CODE
    }        
}

DBCSCodec.prototype.encoder = DBCSEncoder;
DBCSCodec.prototype.decoder = DBCSDecoder;

// Decoder helpers
DBCSCodec.prototype._getDecodeTrieNode = function(addr) {
    var bytes = [];
    for (; addr > 0; addr >>= 8)
        bytes.push(addr & 0xFF);
    if (bytes.length == 0)
        bytes.push(0);

    var node = this.decodeTables[0];
    for (var i = bytes.length-1; i > 0; i--) { // Traverse nodes deeper into the trie.
        var val = node[bytes[i]];

        if (val == UNASSIGNED) { // Create new node.
            node[bytes[i]] = NODE_START - this.decodeTables.length;
            this.decodeTables.push(node = UNASSIGNED_NODE.slice(0));
        }
        else if (val <= NODE_START) { // Existing node.
            node = this.decodeTables[NODE_START - val];
        }
        else
            throw new Error("Overwrite byte in " + this.encodingName + ", addr: " + addr.toString(16));
    }
    return node;
}


DBCSCodec.prototype._addDecodeChunk = function(chunk) {
    // First element of chunk is the hex mbcs code where we start.
    var curAddr = parseInt(chunk[0], 16);

    // Choose the decoding node where we'll write our chars.
    var writeTable = this._getDecodeTrieNode(curAddr);
    curAddr = curAddr & 0xFF;

    // Write all other elements of the chunk to the table.
    for (var k = 1; k < chunk.length; k++) {
        var part = chunk[k];
        if (typeof part === "string") { // String, write as-is.
            for (var l = 0; l < part.length;) {
                var code = part.charCodeAt(l++);
                if (0xD800 <= code && code < 0xDC00) { // Decode surrogate
                    var codeTrail = part.charCodeAt(l++);
                    if (0xDC00 <= codeTrail && codeTrail < 0xE000)
                        writeTable[curAddr++] = 0x10000 + (code - 0xD800) * 0x400 + (codeTrail - 0xDC00);
                    else
                        throw new Error("Incorrect surrogate pair in "  + this.encodingName + " at chunk " + chunk[0]);
                }
                else if (0x0FF0 < code && code <= 0x0FFF) { // Character sequence (our own encoding used)
                    var len = 0xFFF - code + 2;
                    var seq = [];
                    for (var m = 0; m < len; m++)
                        seq.push(part.charCodeAt(l++)); // Simple variation: don't support surrogates or subsequences in seq.

                    writeTable[curAddr++] = SEQ_START - this.decodeTableSeq.length;
                    this.decodeTableSeq.push(seq);
                }
                else
                    writeTable[curAddr++] = code; // Basic char
            }
        } 
        else if (typeof part === "number") { // Integer, meaning increasing sequence starting with prev character.
            var charCode = writeTable[curAddr - 1] + 1;
            for (var l = 0; l < part; l++)
                writeTable[curAddr++] = charCode++;
        }
        else
            throw new Error("Incorrect type '" + typeof part + "' given in "  + this.encodingName + " at chunk " + chunk[0]);
    }
    if (curAddr > 0xFF)
        throw new Error("Incorrect chunk in "  + this.encodingName + " at addr " + chunk[0] + ": too long" + curAddr);
}

// Encoder helpers
DBCSCodec.prototype._getEncodeBucket = function(uCode) {
    var high = uCode >> 8; // This could be > 0xFF because of astral characters.
    if (this.encodeTable[high] === undefined)
        this.encodeTable[high] = UNASSIGNED_NODE.slice(0); // Create bucket on demand.
    return this.encodeTable[high];
}

DBCSCodec.prototype._setEncodeChar = function(uCode, dbcsCode) {
    var bucket = this._getEncodeBucket(uCode);
    var low = uCode & 0xFF;
    if (bucket[low] <= SEQ_START)
        this.encodeTableSeq[SEQ_START-bucket[low]][DEF_CHAR] = dbcsCode; // There's already a sequence, set a single-char subsequence of it.
    else if (bucket[low] == UNASSIGNED)
        bucket[low] = dbcsCode;
}

DBCSCodec.prototype._setEncodeSequence = function(seq, dbcsCode) {
    
    // Get the root of character tree according to first character of the sequence.
    var uCode = seq[0];
    var bucket = this._getEncodeBucket(uCode);
    var low = uCode & 0xFF;

    var node;
    if (bucket[low] <= SEQ_START) {
        // There's already a sequence with  - use it.
        node = this.encodeTableSeq[SEQ_START-bucket[low]];
    }
    else {
        // There was no sequence object - allocate a new one.
        node = {};
        if (bucket[low] !== UNASSIGNED) node[DEF_CHAR] = bucket[low]; // If a char was set before - make it a single-char subsequence.
        bucket[low] = SEQ_START - this.encodeTableSeq.length;
        this.encodeTableSeq.push(node);
    }

    // Traverse the character tree, allocating new nodes as needed.
    for (var j = 1; j < seq.length-1; j++) {
        var oldVal = node[uCode];
        if (typeof oldVal === 'object')
            node = oldVal;
        else {
            node = node[uCode] = {}
            if (oldVal !== undefined)
                node[DEF_CHAR] = oldVal
        }
    }

    // Set the leaf to given dbcsCode.
    uCode = seq[seq.length-1];
    node[uCode] = dbcsCode;
}

DBCSCodec.prototype._fillEncodeTable = function(nodeIdx, prefix, skipEncodeChars) {
    var node = this.decodeTables[nodeIdx];
    for (var i = 0; i < 0x100; i++) {
        var uCode = node[i];
        var mbCode = prefix + i;
        if (skipEncodeChars[mbCode])
            continue;

        if (uCode >= 0)
            this._setEncodeChar(uCode, mbCode);
        else if (uCode <= NODE_START)
            this._fillEncodeTable(NODE_START - uCode, mbCode << 8, skipEncodeChars);
        else if (uCode <= SEQ_START)
            this._setEncodeSequence(this.decodeTableSeq[SEQ_START - uCode], mbCode);
    }
}



// == Encoder ==================================================================

function DBCSEncoder(options, codec) {
    // Encoder state
    this.leadSurrogate = -1;
    this.seqObj = undefined;
    
    // Static data
    this.encodeTable = codec.encodeTable;
    this.encodeTableSeq = codec.encodeTableSeq;
    this.defaultCharSingleByte = codec.defCharSB;
    this.gb18030 = codec.gb18030;
}

DBCSEncoder.prototype.write = function(str) {
    var newBuf = new Buffer(str.length * (this.gb18030 ? 4 : 3)), 
        leadSurrogate = this.leadSurrogate,
        seqObj = this.seqObj, nextChar = -1,
        i = 0, j = 0;

    while (true) {
        // 0. Get next character.
        if (nextChar === -1) {
            if (i == str.length) break;
            var uCode = str.charCodeAt(i++);
        }
        else {
            var uCode = nextChar;
            nextChar = -1;    
        }

        // 1. Handle surrogates.
        if (0xD800 <= uCode && uCode < 0xE000) { // Char is one of surrogates.
            if (uCode < 0xDC00) { // We've got lead surrogate.
                if (leadSurrogate === -1) {
                    leadSurrogate = uCode;
                    continue;
                } else {
                    leadSurrogate = uCode;
                    // Double lead surrogate found.
                    uCode = UNASSIGNED;
                }
            } else { // We've got trail surrogate.
                if (leadSurrogate !== -1) {
                    uCode = 0x10000 + (leadSurrogate - 0xD800) * 0x400 + (uCode - 0xDC00);
                    leadSurrogate = -1;
                } else {
                    // Incomplete surrogate pair - only trail surrogate found.
                    uCode = UNASSIGNED;
                }
                
            }
        }
        else if (leadSurrogate !== -1) {
            // Incomplete surrogate pair - only lead surrogate found.
            nextChar = uCode; uCode = UNASSIGNED; // Write an error, then current char.
            leadSurrogate = -1;
        }

        // 2. Convert uCode character.
        var dbcsCode = UNASSIGNED;
        if (seqObj !== undefined && uCode != UNASSIGNED) { // We are in the middle of the sequence
            var resCode = seqObj[uCode];
            if (typeof resCode === 'object') { // Sequence continues.
                seqObj = resCode;
                continue;

            } else if (typeof resCode == 'number') { // Sequence finished. Write it.
                dbcsCode = resCode;

            } else if (resCode == undefined) { // Current character is not part of the sequence.

                // Try default character for this sequence
                resCode = seqObj[DEF_CHAR];
                if (resCode !== undefined) {
                    dbcsCode = resCode; // Found. Write it.
                    nextChar = uCode; // Current character will be written too in the next iteration.

                } else {
                    // TODO: What if we have no default? (resCode == undefined)
                    // Then, we should write first char of the sequence as-is and try the rest recursively.
                    // Didn't do it for now because no encoding has this situation yet.
                    // Currently, just skip the sequence and write current char.
                }
            }
            seqObj = undefined;
        }
        else if (uCode >= 0) {  // Regular character
            var subtable = this.encodeTable[uCode >> 8];
            if (subtable !== undefined)
                dbcsCode = subtable[uCode & 0xFF];
            
            if (dbcsCode <= SEQ_START) { // Sequence start
                seqObj = this.encodeTableSeq[SEQ_START-dbcsCode];
                continue;
            }

            if (dbcsCode == UNASSIGNED && this.gb18030) {
                // Use GB18030 algorithm to find character(s) to write.
                var idx = findIdx(this.gb18030.uChars, uCode);
                if (idx != -1) {
                    var dbcsCode = this.gb18030.gbChars[idx] + (uCode - this.gb18030.uChars[idx]);
                    newBuf[j++] = 0x81 + Math.floor(dbcsCode / 12600); dbcsCode = dbcsCode % 12600;
                    newBuf[j++] = 0x30 + Math.floor(dbcsCode / 1260); dbcsCode = dbcsCode % 1260;
                    newBuf[j++] = 0x81 + Math.floor(dbcsCode / 10); dbcsCode = dbcsCode % 10;
                    newBuf[j++] = 0x30 + dbcsCode;
                    continue;
                }
            }
        }

        // 3. Write dbcsCode character.
        if (dbcsCode === UNASSIGNED)
            dbcsCode = this.defaultCharSingleByte;
        
        if (dbcsCode < 0x100) {
            newBuf[j++] = dbcsCode;
        }
        else if (dbcsCode < 0x10000) {
            newBuf[j++] = dbcsCode >> 8;   // high byte
            newBuf[j++] = dbcsCode & 0xFF; // low byte
        }
        else {
            newBuf[j++] = dbcsCode >> 16;
            newBuf[j++] = (dbcsCode >> 8) & 0xFF;
            newBuf[j++] = dbcsCode & 0xFF;
        }
    }

    this.seqObj = seqObj;
    this.leadSurrogate = leadSurrogate;
    return newBuf.slice(0, j);
}

DBCSEncoder.prototype.end = function() {
    if (this.leadSurrogate === -1 && this.seqObj === undefined)
        return; // All clean. Most often case.

    var newBuf = new Buffer(10), j = 0;

    if (this.seqObj) { // We're in the sequence.
        var dbcsCode = this.seqObj[DEF_CHAR];
        if (dbcsCode !== undefined) { // Write beginning of the sequence.
            if (dbcsCode < 0x100) {
                newBuf[j++] = dbcsCode;
            }
            else {
                newBuf[j++] = dbcsCode >> 8;   // high byte
                newBuf[j++] = dbcsCode & 0xFF; // low byte
            }
        } else {
            // See todo above.
        }
        this.seqObj = undefined;
    }

    if (this.leadSurrogate !== -1) {
        // Incomplete surrogate pair - only lead surrogate found.
        newBuf[j++] = this.defaultCharSingleByte;
        this.leadSurrogate = -1;
    }
    
    return newBuf.slice(0, j);
}

// Export for testing
DBCSEncoder.prototype.findIdx = findIdx;


// == Decoder ==================================================================

function DBCSDecoder(options, codec) {
    // Decoder state
    this.nodeIdx = 0;
    this.prevBuf = new Buffer(0);

    // Static data
    this.decodeTables = codec.decodeTables;
    this.decodeTableSeq = codec.decodeTableSeq;
    this.defaultCharUnicode = codec.defaultCharUnicode;
    this.gb18030 = codec.gb18030;
}

DBCSDecoder.prototype.write = function(buf) {
    var newBuf = new Buffer(buf.length*2),
        nodeIdx = this.nodeIdx, 
        prevBuf = this.prevBuf, prevBufOffset = this.prevBuf.length,
        seqStart = -this.prevBuf.length, // idx of the start of current parsed sequence.
        uCode;

    if (prevBufOffset > 0) // Make prev buf overlap a little to make it easier to slice later.
        prevBuf = Buffer.concat([prevBuf, buf.slice(0, 10)]);
    
    for (var i = 0, j = 0; i < buf.length; i++) {
        var curByte = (i >= 0) ? buf[i] : prevBuf[i + prevBufOffset];

        // Lookup in current trie node.
        var uCode = this.decodeTables[nodeIdx][curByte];

        if (uCode >= 0) { 
            // Normal character, just use it.
        }
        else if (uCode === UNASSIGNED) { // Unknown char.
            // TODO: Callback with seq.
            //var curSeq = (seqStart >= 0) ? buf.slice(seqStart, i+1) : prevBuf.slice(seqStart + prevBufOffset, i+1 + prevBufOffset);
            i = seqStart; // Try to parse again, after skipping first byte of the sequence ('i' will be incremented by 'for' cycle).
            uCode = this.defaultCharUnicode.charCodeAt(0);
        }
        else if (uCode === GB18030_CODE) {
            var curSeq = (seqStart >= 0) ? buf.slice(seqStart, i+1) : prevBuf.slice(seqStart + prevBufOffset, i+1 + prevBufOffset);
            var ptr = (curSeq[0]-0x81)*12600 + (curSeq[1]-0x30)*1260 + (curSeq[2]-0x81)*10 + (curSeq[3]-0x30);
            var idx = findIdx(this.gb18030.gbChars, ptr);
            uCode = this.gb18030.uChars[idx] + ptr - this.gb18030.gbChars[idx];
        }
        else if (uCode <= NODE_START) { // Go to next trie node.
            nodeIdx = NODE_START - uCode;
            continue;
        }
        else if (uCode <= SEQ_START) { // Output a sequence of chars.
            var seq = this.decodeTableSeq[SEQ_START - uCode];
            for (var k = 0; k < seq.length - 1; k++) {
                uCode = seq[k];
                newBuf[j++] = uCode & 0xFF;
                newBuf[j++] = uCode >> 8;
            }
            uCode = seq[seq.length-1];
        }
        else
            throw new Error("iconv-lite internal error: invalid decoding table value " + uCode + " at " + nodeIdx + "/" + curByte);

        // Write the character to buffer, handling higher planes using surrogate pair.
        if (uCode > 0xFFFF) { 
            uCode -= 0x10000;
            var uCodeLead = 0xD800 + Math.floor(uCode / 0x400);
            newBuf[j++] = uCodeLead & 0xFF;
            newBuf[j++] = uCodeLead >> 8;

            uCode = 0xDC00 + uCode % 0x400;
        }
        newBuf[j++] = uCode & 0xFF;
        newBuf[j++] = uCode >> 8;

        // Reset trie node.
        nodeIdx = 0; seqStart = i+1;
    }

    this.nodeIdx = nodeIdx;
    this.prevBuf = (seqStart >= 0) ? buf.slice(seqStart) : prevBuf.slice(seqStart + prevBufOffset);
    return newBuf.slice(0, j).toString('ucs2');
}

DBCSDecoder.prototype.end = function() {
    var ret = '';

    // Try to parse all remaining chars.
    while (this.prevBuf.length > 0) {
        // Skip 1 character in the buffer.
        ret += this.defaultCharUnicode;
        var buf = this.prevBuf.slice(1);

        // Parse remaining as usual.
        this.prevBuf = new Buffer(0);
        this.nodeIdx = 0;
        if (buf.length > 0)
            ret += this.write(buf);
    }

    this.nodeIdx = 0;
    return ret;
}

// Binary search for GB18030. Returns largest i such that table[i] <= val.
function findIdx(table, val) {
    if (table[0] > val)
        return -1;

    var l = 0, r = table.length;
    while (l < r-1) { // always table[l] <= val < table[r]
        var mid = l + Math.floor((r-l+1)/2);
        if (table[mid] <= val)
            l = mid;
        else
            r = mid;
    }
    return l;
}


}).call(this,require("buffer").Buffer)
},{"buffer":9}],44:[function(require,module,exports){
"use strict"

// Description of supported double byte encodings and aliases.
// Tables are not require()-d until they are needed to speed up library load.
// require()-s are direct to support Browserify.

module.exports = {
    
    // == Japanese/ShiftJIS ====================================================
    // All japanese encodings are based on JIS X set of standards:
    // JIS X 0201 - Single-byte encoding of ASCII +  + Kana chars at 0xA1-0xDF.
    // JIS X 0208 - Main set of 6879 characters, placed in 94x94 plane, to be encoded by 2 bytes. 
    //              Has several variations in 1978, 1983, 1990 and 1997.
    // JIS X 0212 - Supplementary plane of 6067 chars in 94x94 plane. 1990. Effectively dead.
    // JIS X 0213 - Extension and modern replacement of 0208 and 0212. Total chars: 11233.
    //              2 planes, first is superset of 0208, second - revised 0212.
    //              Introduced in 2000, revised 2004. Some characters are in Unicode Plane 2 (0x2xxxx)

    // Byte encodings are:
    //  * Shift_JIS: Compatible with 0201, uses not defined chars in top half as lead bytes for double-byte
    //               encoding of 0208. Lead byte ranges: 0x81-0x9F, 0xE0-0xEF; Trail byte ranges: 0x40-0x7E, 0x80-0x9E, 0x9F-0xFC.
    //               Windows CP932 is a superset of Shift_JIS. Some companies added more chars, notably KDDI.
    //  * EUC-JP:    Up to 3 bytes per character. Used mostly on *nixes.
    //               0x00-0x7F       - lower part of 0201
    //               0x8E, 0xA1-0xDF - upper part of 0201
    //               (0xA1-0xFE)x2   - 0208 plane (94x94).
    //               0x8F, (0xA1-0xFE)x2 - 0212 plane (94x94).
    //  * JIS X 208: 7-bit, direct encoding of 0208. Byte ranges: 0x21-0x7E (94 values). Uncommon.
    //               Used as-is in ISO2022 family.
    //  * ISO2022-JP: Stateful encoding, with escape sequences to switch between ASCII, 
    //                0201-1976 Roman, 0208-1978, 0208-1983.
    //  * ISO2022-JP-1: Adds esc seq for 0212-1990.
    //  * ISO2022-JP-2: Adds esc seq for GB2313-1980, KSX1001-1992, ISO8859-1, ISO8859-7.
    //  * ISO2022-JP-3: Adds esc seq for 0201-1976 Kana set, 0213-2000 Planes 1, 2.
    //  * ISO2022-JP-2004: Adds 0213-2004 Plane 1.
    //
    // After JIS X 0213 appeared, Shift_JIS-2004, EUC-JISX0213 and ISO2022-JP-2004 followed, with just changing the planes.
    //
    // Overall, it seems that it's a mess :( http://www8.plala.or.jp/tkubota1/unicode-symbols-map2.html


    'shiftjis': {
        type: '_dbcs',
        table: function() { return require('./tables/shiftjis.json') },
        encodeAdd: {'\u00a5': 0x5C, '\u203E': 0x7E},
        encodeSkipVals: [{from: 0xED40, to: 0xF940}],
    },
    'csshiftjis': 'shiftjis',
    'mskanji': 'shiftjis',
    'sjis': 'shiftjis',
    'windows31j': 'shiftjis',
    'xsjis': 'shiftjis',
    'windows932': 'shiftjis',
    '932': 'shiftjis',
    'cp932': 'shiftjis',

    'eucjp': {
        type: '_dbcs',
        table: function() { return require('./tables/eucjp.json') },
        encodeAdd: {'\u00a5': 0x5C, '\u203E': 0x7E},
    },

    // TODO: KDDI extension to Shift_JIS
    // TODO: IBM CCSID 942 = CP932, but F0-F9 custom chars and other char changes.
    // TODO: IBM CCSID 943 = Shift_JIS = CP932 with original Shift_JIS lower 128 chars.

    // == Chinese/GBK ==========================================================
    // http://en.wikipedia.org/wiki/GBK

    // Oldest GB2312 (1981, ~7600 chars) is a subset of CP936
    'gb2312': 'cp936',
    'gb231280': 'cp936',
    'gb23121980': 'cp936',
    'csgb2312': 'cp936',
    'csiso58gb231280': 'cp936',
    'euccn': 'cp936',
    'isoir58': 'gbk',

    // Microsoft's CP936 is a subset and approximation of GBK.
    // TODO: Euro = 0x80 in cp936, but not in GBK (where it's valid but undefined)
    'windows936': 'cp936',
    '936': 'cp936',
    'cp936': {
        type: '_dbcs',
        table: function() { return require('./tables/cp936.json') },
    },

    // GBK (~22000 chars) is an extension of CP936 that added user-mapped chars and some other.
    'gbk': {
        type: '_dbcs',
        table: function() { return require('./tables/cp936.json').concat(require('./tables/gbk-added.json')) },
    },
    'xgbk': 'gbk',

    // GB18030 is an algorithmic extension of GBK.
    'gb18030': {
        type: '_dbcs',
        table: function() { return require('./tables/cp936.json').concat(require('./tables/gbk-added.json')) },
        gb18030: function() { return require('./tables/gb18030-ranges.json') },
    },

    'chinese': 'gb18030',

    // TODO: Support GB18030 (~27000 chars + whole unicode mapping, cp54936)
    // http://icu-project.org/docs/papers/gb18030.html
    // http://source.icu-project.org/repos/icu/data/trunk/charset/data/xml/gb-18030-2000.xml
    // http://www.khngai.com/chinese/charmap/tblgbk.php?page=0

    // == Korean ===============================================================
    // EUC-KR, KS_C_5601 and KS X 1001 are exactly the same.
    'windows949': 'cp949',
    '949': 'cp949',
    'cp949': {
        type: '_dbcs',
        table: function() { return require('./tables/cp949.json') },
    },

    'cseuckr': 'cp949',
    'csksc56011987': 'cp949',
    'euckr': 'cp949',
    'isoir149': 'cp949',
    'korean': 'cp949',
    'ksc56011987': 'cp949',
    'ksc56011989': 'cp949',
    'ksc5601': 'cp949',


    // == Big5/Taiwan/Hong Kong ================================================
    // There are lots of tables for Big5 and cp950. Please see the following links for history:
    // http://moztw.org/docs/big5/  http://www.haible.de/bruno/charsets/conversion-tables/Big5.html
    // Variations, in roughly number of defined chars:
    //  * Windows CP 950: Microsoft variant of Big5. Canonical: http://www.unicode.org/Public/MAPPINGS/VENDORS/MICSFT/WINDOWS/CP950.TXT
    //  * Windows CP 951: Microsoft variant of Big5-HKSCS-2001. Seems to be never public. http://me.abelcheung.org/articles/research/what-is-cp951/
    //  * Big5-2003 (Taiwan standard) almost superset of cp950.
    //  * Unicode-at-on (UAO) / Mozilla 1.8. Falling out of use on the Web. Not supported by other browsers.
    //  * Big5-HKSCS (-2001, -2004, -2008). Hong Kong standard. 
    //    many unicode code points moved from PUA to Supplementary plane (U+2XXXX) over the years.
    //    Plus, it has 4 combining sequences.
    //    Seems that Mozilla refused to support it for 10 yrs. https://bugzilla.mozilla.org/show_bug.cgi?id=162431 https://bugzilla.mozilla.org/show_bug.cgi?id=310299
    //    because big5-hkscs is the only encoding to include astral characters in non-algorithmic way.
    //    Implementations are not consistent within browsers; sometimes labeled as just big5.
    //    MS Internet Explorer switches from big5 to big5-hkscs when a patch applied.
    //    Great discussion & recap of what's going on https://bugzilla.mozilla.org/show_bug.cgi?id=912470#c31
    //    In the encoder, it might make sense to support encoding old PUA mappings to Big5 bytes seq-s.
    //    Official spec: http://www.ogcio.gov.hk/en/business/tech_promotion/ccli/terms/doc/2003cmp_2008.txt
    //                   http://www.ogcio.gov.hk/tc/business/tech_promotion/ccli/terms/doc/hkscs-2008-big5-iso.txt
    // 
    // Current understanding of how to deal with Big5(-HKSCS) is in the Encoding Standard, http://encoding.spec.whatwg.org/#big5-encoder
    // Unicode mapping (http://www.unicode.org/Public/MAPPINGS/OBSOLETE/EASTASIA/OTHER/BIG5.TXT) is said to be wrong.

    'windows950': 'cp950',
    '950': 'cp950',
    'cp950': {
        type: '_dbcs',
        table: function() { return require('./tables/cp950.json') },
    },

    // Big5 has many variations and is an extension of cp950. We use Encoding Standard's as a consensus.
    'big5': 'big5hkscs',
    'big5hkscs': {
        type: '_dbcs',
        table: function() { return require('./tables/cp950.json').concat(require('./tables/big5-added.json')) },
        encodeSkipVals: [0xa2cc],
    },

    'cnbig5': 'big5hkscs',
    'csbig5': 'big5hkscs',
    'xxbig5': 'big5hkscs',

};

},{"./tables/big5-added.json":50,"./tables/cp936.json":51,"./tables/cp949.json":52,"./tables/cp950.json":53,"./tables/eucjp.json":54,"./tables/gb18030-ranges.json":55,"./tables/gbk-added.json":56,"./tables/shiftjis.json":57}],45:[function(require,module,exports){
"use strict"

// Update this array if you add/rename/remove files in this directory.
// We support Browserify by skipping automatic module discovery and requiring modules directly.
var modules = [
    require("./internal"),
    require("./utf16"),
    require("./utf7"),
    require("./sbcs-codec"),
    require("./sbcs-data"),
    require("./sbcs-data-generated"),
    require("./dbcs-codec"),
    require("./dbcs-data"),
];

// Put all encoding/alias/codec definitions to single object and export it. 
for (var i = 0; i < modules.length; i++) {
    var module = modules[i];
    for (var enc in module)
        if (Object.prototype.hasOwnProperty.call(module, enc))
            exports[enc] = module[enc];
}

},{"./dbcs-codec":43,"./dbcs-data":44,"./internal":46,"./sbcs-codec":47,"./sbcs-data":49,"./sbcs-data-generated":48,"./utf16":58,"./utf7":59}],46:[function(require,module,exports){
(function (Buffer){
"use strict"

// Export Node.js internal encodings.

module.exports = {
    // Encodings
    utf8:   { type: "_internal", bomAware: true},
    cesu8:  { type: "_internal", bomAware: true},
    unicode11utf8: "utf8",

    ucs2:   { type: "_internal", bomAware: true},
    utf16le: "ucs2",

    binary: { type: "_internal" },
    base64: { type: "_internal" },
    hex:    { type: "_internal" },

    // Codec.
    _internal: InternalCodec,
};

//------------------------------------------------------------------------------

function InternalCodec(codecOptions, iconv) {
    this.enc = codecOptions.encodingName;
    this.bomAware = codecOptions.bomAware;

    if (this.enc === "base64")
        this.encoder = InternalEncoderBase64;
    else if (this.enc === "cesu8") {
        this.enc = "utf8"; // Use utf8 for decoding.
        this.encoder = InternalEncoderCesu8;

        // Add decoder for versions of Node not supporting CESU-8
        if (new Buffer("eda080", 'hex').toString().length == 3) {
            this.decoder = InternalDecoderCesu8;
            this.defaultCharUnicode = iconv.defaultCharUnicode;
        }
    }
}

InternalCodec.prototype.encoder = InternalEncoder;
InternalCodec.prototype.decoder = InternalDecoder;

//------------------------------------------------------------------------------

// We use node.js internal decoder. Its signature is the same as ours.
var StringDecoder = require('string_decoder').StringDecoder;

if (!StringDecoder.prototype.end) // Node v0.8 doesn't have this method.
    StringDecoder.prototype.end = function() {};


function InternalDecoder(options, codec) {
    StringDecoder.call(this, codec.enc);
}

InternalDecoder.prototype = StringDecoder.prototype;


//------------------------------------------------------------------------------
// Encoder is mostly trivial

function InternalEncoder(options, codec) {
    this.enc = codec.enc;
}

InternalEncoder.prototype.write = function(str) {
    return new Buffer(str, this.enc);
}

InternalEncoder.prototype.end = function() {
}


//------------------------------------------------------------------------------
// Except base64 encoder, which must keep its state.

function InternalEncoderBase64(options, codec) {
    this.prevStr = '';
}

InternalEncoderBase64.prototype.write = function(str) {
    str = this.prevStr + str;
    var completeQuads = str.length - (str.length % 4);
    this.prevStr = str.slice(completeQuads);
    str = str.slice(0, completeQuads);

    return new Buffer(str, "base64");
}

InternalEncoderBase64.prototype.end = function() {
    return new Buffer(this.prevStr, "base64");
}


//------------------------------------------------------------------------------
// CESU-8 encoder is also special.

function InternalEncoderCesu8(options, codec) {
}

InternalEncoderCesu8.prototype.write = function(str) {
    var buf = new Buffer(str.length * 3), bufIdx = 0;
    for (var i = 0; i < str.length; i++) {
        var charCode = str.charCodeAt(i);
        // Naive implementation, but it works because CESU-8 is especially easy
        // to convert from UTF-16 (which all JS strings are encoded in).
        if (charCode < 0x80)
            buf[bufIdx++] = charCode;
        else if (charCode < 0x800) {
            buf[bufIdx++] = 0xC0 + (charCode >>> 6);
            buf[bufIdx++] = 0x80 + (charCode & 0x3f);
        }
        else { // charCode will always be < 0x10000 in javascript.
            buf[bufIdx++] = 0xE0 + (charCode >>> 12);
            buf[bufIdx++] = 0x80 + ((charCode >>> 6) & 0x3f);
            buf[bufIdx++] = 0x80 + (charCode & 0x3f);
        }
    }
    return buf.slice(0, bufIdx);
}

InternalEncoderCesu8.prototype.end = function() {
}

//------------------------------------------------------------------------------
// CESU-8 decoder is not implemented in Node v4.0+

function InternalDecoderCesu8(options, codec) {
    this.acc = 0;
    this.contBytes = 0;
    this.accBytes = 0;
    this.defaultCharUnicode = codec.defaultCharUnicode;
}

InternalDecoderCesu8.prototype.write = function(buf) {
    var acc = this.acc, contBytes = this.contBytes, accBytes = this.accBytes, 
        res = '';
    for (var i = 0; i < buf.length; i++) {
        var curByte = buf[i];
        if ((curByte & 0xC0) !== 0x80) { // Leading byte
            if (contBytes > 0) { // Previous code is invalid
                res += this.defaultCharUnicode;
                contBytes = 0;
            }

            if (curByte < 0x80) { // Single-byte code
                res += String.fromCharCode(curByte);
            } else if (curByte < 0xE0) { // Two-byte code
                acc = curByte & 0x1F;
                contBytes = 1; accBytes = 1;
            } else if (curByte < 0xF0) { // Three-byte code
                acc = curByte & 0x0F;
                contBytes = 2; accBytes = 1;
            } else { // Four or more are not supported for CESU-8.
                res += this.defaultCharUnicode;
            }
        } else { // Continuation byte
            if (contBytes > 0) { // We're waiting for it.
                acc = (acc << 6) | (curByte & 0x3f);
                contBytes--; accBytes++;
                if (contBytes === 0) {
                    // Check for overlong encoding, but support Modified UTF-8 (encoding NULL as C0 80)
                    if (accBytes === 2 && acc < 0x80 && acc > 0)
                        res += this.defaultCharUnicode;
                    else if (accBytes === 3 && acc < 0x800)
                        res += this.defaultCharUnicode;
                    else
                        // Actually add character.
                        res += String.fromCharCode(acc);
                }
            } else { // Unexpected continuation byte
                res += this.defaultCharUnicode;
            }
        }
    }
    this.acc = acc; this.contBytes = contBytes; this.accBytes = accBytes;
    return res;
}

InternalDecoderCesu8.prototype.end = function() {
    var res = 0;
    if (this.contBytes > 0)
        res += this.defaultCharUnicode;
    return res;
}

}).call(this,require("buffer").Buffer)
},{"buffer":9,"string_decoder":29}],47:[function(require,module,exports){
(function (Buffer){
"use strict"

// Single-byte codec. Needs a 'chars' string parameter that contains 256 or 128 chars that
// correspond to encoded bytes (if 128 - then lower half is ASCII). 

exports._sbcs = SBCSCodec;
function SBCSCodec(codecOptions, iconv) {
    if (!codecOptions)
        throw new Error("SBCS codec is called without the data.")
    
    // Prepare char buffer for decoding.
    if (!codecOptions.chars || (codecOptions.chars.length !== 128 && codecOptions.chars.length !== 256))
        throw new Error("Encoding '"+codecOptions.type+"' has incorrect 'chars' (must be of len 128 or 256)");
    
    if (codecOptions.chars.length === 128) {
        var asciiString = "";
        for (var i = 0; i < 128; i++)
            asciiString += String.fromCharCode(i);
        codecOptions.chars = asciiString + codecOptions.chars;
    }

    this.decodeBuf = new Buffer(codecOptions.chars, 'ucs2');
    
    // Encoding buffer.
    var encodeBuf = new Buffer(65536);
    encodeBuf.fill(iconv.defaultCharSingleByte.charCodeAt(0));

    for (var i = 0; i < codecOptions.chars.length; i++)
        encodeBuf[codecOptions.chars.charCodeAt(i)] = i;

    this.encodeBuf = encodeBuf;
}

SBCSCodec.prototype.encoder = SBCSEncoder;
SBCSCodec.prototype.decoder = SBCSDecoder;


function SBCSEncoder(options, codec) {
    this.encodeBuf = codec.encodeBuf;
}

SBCSEncoder.prototype.write = function(str) {
    var buf = new Buffer(str.length);
    for (var i = 0; i < str.length; i++)
        buf[i] = this.encodeBuf[str.charCodeAt(i)];
    
    return buf;
}

SBCSEncoder.prototype.end = function() {
}


function SBCSDecoder(options, codec) {
    this.decodeBuf = codec.decodeBuf;
}

SBCSDecoder.prototype.write = function(buf) {
    // Strings are immutable in JS -> we use ucs2 buffer to speed up computations.
    var decodeBuf = this.decodeBuf;
    var newBuf = new Buffer(buf.length*2);
    var idx1 = 0, idx2 = 0;
    for (var i = 0; i < buf.length; i++) {
        idx1 = buf[i]*2; idx2 = i*2;
        newBuf[idx2] = decodeBuf[idx1];
        newBuf[idx2+1] = decodeBuf[idx1+1];
    }
    return newBuf.toString('ucs2');
}

SBCSDecoder.prototype.end = function() {
}

}).call(this,require("buffer").Buffer)
},{"buffer":9}],48:[function(require,module,exports){
"use strict"

// Generated data for sbcs codec. Don't edit manually. Regenerate using generation/gen-sbcs.js script.
module.exports = {
  "437": "cp437",
  "737": "cp737",
  "775": "cp775",
  "850": "cp850",
  "852": "cp852",
  "855": "cp855",
  "856": "cp856",
  "857": "cp857",
  "858": "cp858",
  "860": "cp860",
  "861": "cp861",
  "862": "cp862",
  "863": "cp863",
  "864": "cp864",
  "865": "cp865",
  "866": "cp866",
  "869": "cp869",
  "874": "windows874",
  "922": "cp922",
  "1046": "cp1046",
  "1124": "cp1124",
  "1125": "cp1125",
  "1129": "cp1129",
  "1133": "cp1133",
  "1161": "cp1161",
  "1162": "cp1162",
  "1163": "cp1163",
  "1250": "windows1250",
  "1251": "windows1251",
  "1252": "windows1252",
  "1253": "windows1253",
  "1254": "windows1254",
  "1255": "windows1255",
  "1256": "windows1256",
  "1257": "windows1257",
  "1258": "windows1258",
  "28591": "iso88591",
  "28592": "iso88592",
  "28593": "iso88593",
  "28594": "iso88594",
  "28595": "iso88595",
  "28596": "iso88596",
  "28597": "iso88597",
  "28598": "iso88598",
  "28599": "iso88599",
  "28600": "iso885910",
  "28601": "iso885911",
  "28603": "iso885913",
  "28604": "iso885914",
  "28605": "iso885915",
  "28606": "iso885916",
  "windows874": {
    "type": "_sbcs",
    "chars": ""
  },
  "win874": "windows874",
  "cp874": "windows874",
  "windows1250": {
    "type": "_sbcs",
    "chars": ""
  },
  "win1250": "windows1250",
  "cp1250": "windows1250",
  "windows1251": {
    "type": "_sbcs",
    "chars": ""
  },
  "win1251": "windows1251",
  "cp1251": "windows1251",
  "windows1252": {
    "type": "_sbcs",
    "chars": ""
  },
  "win1252": "windows1252",
  "cp1252": "windows1252",
  "windows1253": {
    "type": "_sbcs",
    "chars": ""
  },
  "win1253": "windows1253",
  "cp1253": "windows1253",
  "windows1254": {
    "type": "_sbcs",
    "chars": ""
  },
  "win1254": "windows1254",
  "cp1254": "windows1254",
  "windows1255": {
    "type": "_sbcs",
    "chars": ""
  },
  "win1255": "windows1255",
  "cp1255": "windows1255",
  "windows1256": {
    "type": "_sbcs",
    "chars": ""
  },
  "win1256": "windows1256",
  "cp1256": "windows1256",
  "windows1257": {
    "type": "_sbcs",
    "chars": ""
  },
  "win1257": "windows1257",
  "cp1257": "windows1257",
  "windows1258": {
    "type": "_sbcs",
    "chars": ""
  },
  "win1258": "windows1258",
  "cp1258": "windows1258",
  "iso88591": {
    "type": "_sbcs",
    "chars": ""
  },
  "cp28591": "iso88591",
  "iso88592": {
    "type": "_sbcs",
    "chars": ""
  },
  "cp28592": "iso88592",
  "iso88593": {
    "type": "_sbcs",
    "chars": ""
  },
  "cp28593": "iso88593",
  "iso88594": {
    "type": "_sbcs",
    "chars": ""
  },
  "cp28594": "iso88594",
  "iso88595": {
    "type": "_sbcs",
    "chars": ""
  },
  "cp28595": "iso88595",
  "iso88596": {
    "type": "_sbcs",
    "chars": ""
  },
  "cp28596": "iso88596",
  "iso88597": {
    "type": "_sbcs",
    "chars": ""
  },
  "cp28597": "iso88597",
  "iso88598": {
    "type": "_sbcs",
    "chars": ""
  },
  "cp28598": "iso88598",
  "iso88599": {
    "type": "_sbcs",
    "chars": ""
  },
  "cp28599": "iso88599",
  "iso885910": {
    "type": "_sbcs",
    "chars": ""
  },
  "cp28600": "iso885910",
  "iso885911": {
    "type": "_sbcs",
    "chars": ""
  },
  "cp28601": "iso885911",
  "iso885913": {
    "type": "_sbcs",
    "chars": ""
  },
  "cp28603": "iso885913",
  "iso885914": {
    "type": "_sbcs",
    "chars": ""
  },
  "cp28604": "iso885914",
  "iso885915": {
    "type": "_sbcs",
    "chars": ""
  },
  "cp28605": "iso885915",
  "iso885916": {
    "type": "_sbcs",
    "chars": ""
  },
  "cp28606": "iso885916",
  "cp437": {
    "type": "_sbcs",
    "chars": ""
  },
  "ibm437": "cp437",
  "csibm437": "cp437",
  "cp737": {
    "type": "_sbcs",
    "chars": ""
  },
  "ibm737": "cp737",
  "csibm737": "cp737",
  "cp775": {
    "type": "_sbcs",
    "chars": ""
  },
  "ibm775": "cp775",
  "csibm775": "cp775",
  "cp850": {
    "type": "_sbcs",
    "chars": ""
  },
  "ibm850": "cp850",
  "csibm850": "cp850",
  "cp852": {
    "type": "_sbcs",
    "chars": ""
  },
  "ibm852": "cp852",
  "csibm852": "cp852",
  "cp855": {
    "type": "_sbcs",
    "chars": ""
  },
  "ibm855": "cp855",
  "csibm855": "cp855",
  "cp856": {
    "type": "_sbcs",
    "chars": ""
  },
  "ibm856": "cp856",
  "csibm856": "cp856",
  "cp857": {
    "type": "_sbcs",
    "chars": ""
  },
  "ibm857": "cp857",
  "csibm857": "cp857",
  "cp858": {
    "type": "_sbcs",
    "chars": ""
  },
  "ibm858": "cp858",
  "csibm858": "cp858",
  "cp860": {
    "type": "_sbcs",
    "chars": ""
  },
  "ibm860": "cp860",
  "csibm860": "cp860",
  "cp861": {
    "type": "_sbcs",
    "chars": ""
  },
  "ibm861": "cp861",
  "csibm861": "cp861",
  "cp862": {
    "type": "_sbcs",
    "chars": ""
  },
  "ibm862": "cp862",
  "csibm862": "cp862",
  "cp863": {
    "type": "_sbcs",
    "chars": ""
  },
  "ibm863": "cp863",
  "csibm863": "cp863",
  "cp864": {
    "type": "_sbcs",
    "chars": "\u0000\u0001\u0002\u0003\u0004\u0005\u0006\u0007\b\t\n\u000b\f\r\u000e\u000f\u0010\u0011\u0012\u0013\u0014\u0015\u0016\u0017\u0018\u0019\u001a\u001b\u001c\u001d\u001e\u001f !\"#$&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}~"
  },
  "ibm864": "cp864",
  "csibm864": "cp864",
  "cp865": {
    "type": "_sbcs",
    "chars": ""
  },
  "ibm865": "cp865",
  "csibm865": "cp865",
  "cp866": {
    "type": "_sbcs",
    "chars": ""
  },
  "ibm866": "cp866",
  "csibm866": "cp866",
  "cp869": {
    "type": "_sbcs",
    "chars": ""
  },
  "ibm869": "cp869",
  "csibm869": "cp869",
  "cp922": {
    "type": "_sbcs",
    "chars": ""
  },
  "ibm922": "cp922",
  "csibm922": "cp922",
  "cp1046": {
    "type": "_sbcs",
    "chars": ""
  },
  "ibm1046": "cp1046",
  "csibm1046": "cp1046",
  "cp1124": {
    "type": "_sbcs",
    "chars": ""
  },
  "ibm1124": "cp1124",
  "csibm1124": "cp1124",
  "cp1125": {
    "type": "_sbcs",
    "chars": ""
  },
  "ibm1125": "cp1125",
  "csibm1125": "cp1125",
  "cp1129": {
    "type": "_sbcs",
    "chars": ""
  },
  "ibm1129": "cp1129",
  "csibm1129": "cp1129",
  "cp1133": {
    "type": "_sbcs",
    "chars": ""
  },
  "ibm1133": "cp1133",
  "csibm1133": "cp1133",
  "cp1161": {
    "type": "_sbcs",
    "chars": ""
  },
  "ibm1161": "cp1161",
  "csibm1161": "cp1161",
  "cp1162": {
    "type": "_sbcs",
    "chars": ""
  },
  "ibm1162": "cp1162",
  "csibm1162": "cp1162",
  "cp1163": {
    "type": "_sbcs",
    "chars": ""
  },
  "ibm1163": "cp1163",
  "csibm1163": "cp1163",
  "maccroatian": {
    "type": "_sbcs",
    "chars": ""
  },
  "maccyrillic": {
    "type": "_sbcs",
    "chars": ""
  },
  "macgreek": {
    "type": "_sbcs",
    "chars": ""
  },
  "maciceland": {
    "type": "_sbcs",
    "chars": ""
  },
  "macroman": {
    "type": "_sbcs",
    "chars": ""
  },
  "macromania": {
    "type": "_sbcs",
    "chars": ""
  },
  "macthai": {
    "type": "_sbcs",
    "chars": ""
  },
  "macturkish": {
    "type": "_sbcs",
    "chars": ""
  },
  "macukraine": {
    "type": "_sbcs",
    "chars": ""
  },
  "koi8r": {
    "type": "_sbcs",
    "chars": ""
  },
  "koi8u": {
    "type": "_sbcs",
    "chars": ""
  },
  "koi8ru": {
    "type": "_sbcs",
    "chars": ""
  },
  "koi8t": {
    "type": "_sbcs",
    "chars": ""
  },
  "armscii8": {
    "type": "_sbcs",
    "chars": ")(.,-"
  },
  "rk1048": {
    "type": "_sbcs",
    "chars": ""
  },
  "tcvn": {
    "type": "_sbcs",
    "chars": "\u0000\u0003\u0007\b\t\n\u000b\f\r\u000e\u000f\u0010\u0018\u0019\u001a\u001b\u001c\u001d\u001e\u001f !\"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}~"
  },
  "georgianacademy": {
    "type": "_sbcs",
    "chars": ""
  },
  "georgianps": {
    "type": "_sbcs",
    "chars": ""
  },
  "pt154": {
    "type": "_sbcs",
    "chars": ""
  },
  "viscii": {
    "type": "_sbcs",
    "chars": "\u0000\u0001\u0003\u0004\u0007\b\t\n\u000b\f\r\u000e\u000f\u0010\u0011\u0012\u0013\u0015\u0016\u0017\u0018\u001a\u001b\u001c\u001d\u001f !\"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}~"
  },
  "iso646cn": {
    "type": "_sbcs",
    "chars": "\u0000\u0001\u0002\u0003\u0004\u0005\u0006\u0007\b\t\n\u000b\f\r\u000e\u000f\u0010\u0011\u0012\u0013\u0014\u0015\u0016\u0017\u0018\u0019\u001a\u001b\u001c\u001d\u001e\u001f !\"#%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}"
  },
  "iso646jp": {
    "type": "_sbcs",
    "chars": "\u0000\u0001\u0002\u0003\u0004\u0005\u0006\u0007\b\t\n\u000b\f\r\u000e\u000f\u0010\u0011\u0012\u0013\u0014\u0015\u0016\u0017\u0018\u0019\u001a\u001b\u001c\u001d\u001e\u001f !\"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[]^_`abcdefghijklmnopqrstuvwxyz{|}"
  },
  "hproman8": {
    "type": "_sbcs",
    "chars": ""
  },
  "macintosh": {
    "type": "_sbcs",
    "chars": ""
  },
  "ascii": {
    "type": "_sbcs",
    "chars": ""
  },
  "tis620": {
    "type": "_sbcs",
    "chars": ""
  }
}
},{}],49:[function(require,module,exports){
"use strict"

// Manually added data to be used by sbcs codec in addition to generated one.

module.exports = {
    // Not supported by iconv, not sure why.
    "10029": "maccenteuro",
    "maccenteuro": {
        "type": "_sbcs",
        "chars": ""
    },

    "808": "cp808",
    "ibm808": "cp808",
    "cp808": {
        "type": "_sbcs",
        "chars": ""
    },

    // Aliases of generated encodings.
    "ascii8bit": "ascii",
    "usascii": "ascii",
    "ansix34": "ascii",
    "ansix341968": "ascii",
    "ansix341986": "ascii",
    "csascii": "ascii",
    "cp367": "ascii",
    "ibm367": "ascii",
    "isoir6": "ascii",
    "iso646us": "ascii",
    "iso646irv": "ascii",
    "us": "ascii",

    "latin1": "iso88591",
    "latin2": "iso88592",
    "latin3": "iso88593",
    "latin4": "iso88594",
    "latin5": "iso88599",
    "latin6": "iso885910",
    "latin7": "iso885913",
    "latin8": "iso885914",
    "latin9": "iso885915",
    "latin10": "iso885916",

    "csisolatin1": "iso88591",
    "csisolatin2": "iso88592",
    "csisolatin3": "iso88593",
    "csisolatin4": "iso88594",
    "csisolatincyrillic": "iso88595",
    "csisolatinarabic": "iso88596",
    "csisolatingreek" : "iso88597",
    "csisolatinhebrew": "iso88598",
    "csisolatin5": "iso88599",
    "csisolatin6": "iso885910",

    "l1": "iso88591",
    "l2": "iso88592",
    "l3": "iso88593",
    "l4": "iso88594",
    "l5": "iso88599",
    "l6": "iso885910",
    "l7": "iso885913",
    "l8": "iso885914",
    "l9": "iso885915",
    "l10": "iso885916",

    "isoir14": "iso646jp",
    "isoir57": "iso646cn",
    "isoir100": "iso88591",
    "isoir101": "iso88592",
    "isoir109": "iso88593",
    "isoir110": "iso88594",
    "isoir144": "iso88595",
    "isoir127": "iso88596",
    "isoir126": "iso88597",
    "isoir138": "iso88598",
    "isoir148": "iso88599",
    "isoir157": "iso885910",
    "isoir166": "tis620",
    "isoir179": "iso885913",
    "isoir199": "iso885914",
    "isoir203": "iso885915",
    "isoir226": "iso885916",

    "cp819": "iso88591",
    "ibm819": "iso88591",

    "cyrillic": "iso88595",

    "arabic": "iso88596",
    "arabic8": "iso88596",
    "ecma114": "iso88596",
    "asmo708": "iso88596",

    "greek" : "iso88597",
    "greek8" : "iso88597",
    "ecma118" : "iso88597",
    "elot928" : "iso88597",

    "hebrew": "iso88598",
    "hebrew8": "iso88598",

    "turkish": "iso88599",
    "turkish8": "iso88599",

    "thai": "iso885911",
    "thai8": "iso885911",

    "celtic": "iso885914",
    "celtic8": "iso885914",
    "isoceltic": "iso885914",

    "tis6200": "tis620",
    "tis62025291": "tis620",
    "tis62025330": "tis620",

    "10000": "macroman",
    "10006": "macgreek",
    "10007": "maccyrillic",
    "10079": "maciceland",
    "10081": "macturkish",

    "cspc8codepage437": "cp437",
    "cspc775baltic": "cp775",
    "cspc850multilingual": "cp850",
    "cspcp852": "cp852",
    "cspc862latinhebrew": "cp862",
    "cpgr": "cp869",

    "msee": "cp1250",
    "mscyrl": "cp1251",
    "msansi": "cp1252",
    "msgreek": "cp1253",
    "msturk": "cp1254",
    "mshebr": "cp1255",
    "msarab": "cp1256",
    "winbaltrim": "cp1257",

    "cp20866": "koi8r",
    "20866": "koi8r",
    "ibm878": "koi8r",
    "cskoi8r": "koi8r",

    "cp21866": "koi8u",
    "21866": "koi8u",
    "ibm1168": "koi8u",

    "strk10482002": "rk1048",

    "tcvn5712": "tcvn",
    "tcvn57121": "tcvn",

    "gb198880": "iso646cn",
    "cn": "iso646cn",

    "csiso14jisc6220ro": "iso646jp",
    "jisc62201969ro": "iso646jp",
    "jp": "iso646jp",

    "cshproman8": "hproman8",
    "r8": "hproman8",
    "roman8": "hproman8",
    "xroman8": "hproman8",
    "ibm1051": "hproman8",

    "mac": "macintosh",
    "csmacintosh": "macintosh",
};


},{}],50:[function(require,module,exports){
module.exports=[
["8740",""],
["8767",""],
["87a1",""],
["8840","",4,""],
["88a1",""],
["8940",""],
["8943",""],
["8946",""],
["894c",""],
["89a1",""],
["89ab",""],
["89b0",""],
["89b5",""],
["89c1",""],
["89c5",""],
["8a40",""],
["8a43",""],
["8a64",""],
["8a76",""],
["8aa1",""],
["8aac",""],
["8ab2",""],
["8abb",""],
["8ac9",""],
["8ace",""],
["8adf",""],
["8af6",""],
["8b40",""],
["8b55",""],
["8ba1",""],
["8bde",""],
["8c40",""],
["8ca1",""],
["8ca7",""],
["8cc9",""],
["8cce",""],
["8ce6",""],
["8d40",""],
["8d42",""],
["8da1",""],
["8e40",""],
["8ea1",""],
["8f40",""],
["8fa1",""],
["9040",""],
["90a1",""],
["9140",""],
["91a1",""],
["9240",""],
["92a1",""],
["9340",""],
["93a1",""],
["9440",""],
["94a1",""],
["9540",""],
["95a1",""],
["9640",""],
["96a1",""],
["9740",""],
["97a1",""],
["9840",""],
["98a1",""],
["9940",""],
["99a1",""],
["9a40",""],
["9aa1",""],
["9b40",""],
["9b62",""],
["9ba1",""],
["9c40",""],
["9ca1",""],
["9d40",""],
["9da1",""],
["9e40",""],
["9ea1",""],
["9ead",""],
["9ec5",""],
["9ef5",""],
["9f40",""],
["9f4f",""],
["9fa1",""],
["9fae",""],
["9fb2",""],
["9fc1",""],
["9fc9",""],
["9fdb",""],
["9fe7",""],
["9feb",""],
["9ff0",""],
["a040",""],
["a055",""],
["a058",""],
["a05b",""],
["a063",""],
["a073",""],
["a0a1",""],
["a0a6",""],
["a0ae",""],
["a0b0",""],
["a0d4",""],
["a0e2",""],
["a3c0","",31,""],
["c6a1","",9,"",9,"",9,"",23],
["c740","",58,""],
["c7a1","",81,"",5,"",4],
["c840","",26,"",25,""],
["c8a1",""],
["c8cd",""],
["c8f5",""],
["f9fe",""],
["fa40",""],
["faa1",""],
["fb40",""],
["fba1",""],
["fc40",""],
["fca1",""],
["fd40",""],
["fda1",""],
["fe40",""],
["fea1",""]
]

},{}],51:[function(require,module,exports){
module.exports=[
["0","\u0000",127,""],
["8140","",5,"",9,"",6,""],
["8180","",6,"",4,"",4,"",5,""],
["8240","",4,"",8,"",4,"",11],
["8280","",10,"",4,"",7,"",5,"",8,"",20,"",4,"",6,""],
["8340","",17,"",5,"",10,"",4,"",9,""],
["8380","",5,"",13,"",28,"",4,"",4,"",5],
["8440","",5,"",5,""],
["8480","",9,"",4,"",6,"",6,"",9,"",5,"",10,"",7,""],
["8540","",9,""],
["8580","",4,"",6,"",4,"",4,"",7,""],
["8640","",4,"",5,"",4,"",5,""],
["8680","",4,"",4,"",5,"",6,"",8,"",4,"",4,"",4,""],
["8740","",7,"",11,"",4,"",4],
["8780","",7,"",6,"",14,"",10,"",6,"",12,"",8,"",5,"",6],
["8840","",9,"",4,"",4,""],
["8880","",4,"",6,"",8,"",6,"",7,"",4,"",4,"",7],
["8940","",5,"",6,"",4,"",5,"",4,"",16,""],
["8980","",4,"",4,"",7,"",17,"",10,"",13,"",5,"",7,"",4,""],
["8a40","",4,"",12,""],
["8a80","",5,"",6,"",4,"",11,"",6,"",4,"",4,"",9,"",5],
["8b40","",8,"",17,"",6,"",13,""],
["8b80","",4,"",4,"",5,"",4,"",4,"",22,"",11,"",25,"",7,"",6],
["8c40","",7,""],
["8c80","",8,"",4,"",6,"",6,"",6,"",4,"",4,"",4],
["8d40","",5,"",5,"",5,"",6,"",9,"",4],
["8d80","",5,"",4,"",4,"",4,"",7,"",7,"",10,"",10,"",12,"",21,""],
["8e40","",21,"",12,"",6,"",12,""],
["8e80","",4,"",7,"",4,"",4,"",5,"",6,"",4,"",14,"",4,"",4,"",6],
["8f40","",5,"",11,"",8,""],
["8f80","",6,"",14,"",5,"",5,"",4,""],
["9040","",4,"",4,"",6,""],
["9080","",7,"",4,"",4,"",4,"",4,"",18,"",6],
["9140","",6,"",6,"",18,"",4,""],
["9180","",6,"",8,"",9,"",5,"",4,"",4,"",16,"",13,"",8,"",5,"",4,""],
["9240","",6,"",5,""],
["9280","",5,"",7,"",6,""],
["9340","",6,"",4,"",4,"",5,""],
["9380","",5,"",4,"",6,"",4,"",7,"",9,"",6,"",8,"",4,"",6,""],
["9440","",24,"",7,"",7,"",4,"",8],
["9480","",4,"",4,"",14,"",7,"",7,""],
["9540","",4,"",4,"",6,""],
["9580","",4,"",4,"",8,"",4,"",4,"",25,"",7,"",5,""],
["9640","",5,"",4,""],
["9680","",7,"",9,"",7,"",4,"",6,"",6,"",5],
["9740","",7,"",8,"",7,"",9,""],
["9780","",6,"",5,"",4,"",9,"",4,"",11,"",7,"",16,""],
["9840","",4,"",5,"",9,""],
["9880","",7,"",5,"",11,"",9,"",9,"",11,"",5,"",5,"",6,"",4,"",7,"",6,""],
["9940","",4,"",10,"",6,"",8,"",4,"",7,"",5],
["9980","",114,"",6],
["9a40","",11,"",7,"",13,""],
["9a80","",4,"",7,"",7,"",6,"",4,"",4,"",7,"",6,"",4,"",4,""],
["9b40","",4,""],
["9b80","",5,"",4,"",4,"",5,""],
["9c40","",7,""],
["9c80","",7,"",7,"",10,"",14,"",4,"",6,"",5],
["9d40","",7,"",4,"",9,"",6,""],
["9d80","",9,"",5,"",6,"",12,"",4,"",10,"",5,"",5,"",6,"",10,""],
["9e40","",7,"",32,"",7,"",6,"",6],
["9e80","",9,"",17,"",13,"",11,"",12,"",12,""],
["9f40","",6,"",10,"",4,"",10,"",7,""],
["9f80","",13,"",12,"",4,"",4,"",5,"",4,"",4,"",6,"",5,"",8,"",9,"",4],
["a040","",9,"",5,"",9,"",11,"",19],
["a080","",9,"",6,"",4,"",11,"",11,"",6,""],
["a1a1","",7,""],
["a2a1","",9],
["a2b1","",19,"",19,"",9],
["a2e5","",9],
["a2f1","",11],
["a3a1","",88,""],
["a4a1","",82],
["a5a1","",85],
["a6a1","",16,"",6],
["a6c1","",16,"",6],
["a6e0",""],
["a6ee",""],
["a6f4",""],
["a7a1","",5,"",25],
["a7d1","",5,"",25],
["a840","",35,"",6],
["a880","",7,""],
["a8a1",""],
["a8bd",""],
["a8c0",""],
["a8c5","",36],
["a940","",8,""],
["a959",""],
["a95c",""],
["a960","",9,"",8],
["a980","",4,""],
["a996",""],
["a9a4","",75],
["aa40","",5,"",5,"",8],
["aa80","",7,"",10,""],
["ab40","",11,"",4,"",5,"",4],
["ab80","",6,"",4],
["ac40","",10,"",8,"",5,"",4,"",11],
["ac80","",6,"",12,"",4,""],
["ad40","",10,"",7,"",15,"",12],
["ad80","",9,"",8,"",6,""],
["ae40","",6,"",7,"",4,""],
["ae80","",7,"",6,"",4,""],
["af40","",4,""],
["af80",""],
["b040","",6,"",5,"",4,"",6,"",7,""],
["b080","",7,"",8,"",9,""],
["b140","",4,"",7,"",10,""],
["b180","",4,"",7,"",7,""],
["b240","",11,"",5,"",11,"",4],
["b280","",12,"",8,"",4,""],
["b340","",5,""],
["b380","",11,"",7,"",6,""],
["b440","",7,"",9],
["b480","",4,"",5,"",6,""],
["b540","",5,"",9,"",4,"",14,"",4,"",8,""],
["b580","",6,"",4,""],
["b640","",6,"",11,"",10,"",4,"",5,""],
["b680","",6,"",4,""],
["b740","",14,"",5,"",9,"",4,"",16],
["b780","",6,""],
["b840","",4,"",10,"",10,"",9,"",5,""],
["b880","",4,""],
["b940","",5,"",10,"",6,""],
["b980","",7,""],
["ba40","",4,"",4,"",7,"",5,""],
["ba80","",4,"",5,"",12,"",5,""],
["bb40","",9,"",36,"",5,"",9],
["bb80","",6,"",4,""],
["bc40","",6,"",6,"",5,"",7,"",13,"",5],
["bc80","",14,"",6,""],
["bd40","",54,"",7],
["bd80","",32,""],
["be40","",12,"",6,"",42],
["be80","",32,""],
["bf40","",62],
["bf80","",4,"",4,"",21,""],
["c040","",35,"",23,""],
["c080","",6,"",9,""],
["c140","",4,"",7,"",4,"",4,"",6,""],
["c180","",4,"",4,"",5,""],
["c240","",6,"",5,""],
["c280","",13,"",5,"",11,""],
["c340","",5,"",4,"",6,""],
["c380","",12,"",4,""],
["c440","",5,"",4,"",4,"",5,"",4,""],
["c480","",7,"",5,"",6,""],
["c540","",14,"",4,"",5,"",4,"",5,""],
["c580","",7,"",7,""],
["c640",""],
["c680","",4,"",9,""],
["c740","",4,"",4,"",6,"",6,"",6,""],
["c780",""],
["c840","",4,"",5,"",5,"",7,"",5,"",7,""],
["c880","",6,"",4,"",4,""],
["c940","",4,"",7,"",12,""],
["c980","",4,"",4,"",10,""],
["ca40","",8,"",8,"",9,"",4,"",10],
["ca80","",4,"",8,""],
["cb40","",6,"",10,"",6,"",5,"",6,"",6,"",4,""],
["cb80","",5,"",6,"",14,""],
["cc40","",4,"",10,"",15,"",13,""],
["cc80","",11,"",4,"",7,""],
["cd40","",6,"",6,"",4,"",5,"",4,"",4,""],
["cd80",""],
["ce40","",6,"",5,"",7,""],
["ce80","",4,"",6,"",4,""],
["cf40","",4,"",4,"",6,"",9],
["cf80","",5,"",7,"",4,""],
["d040","",13,"",5,"",5,"",5,"",6,""],
["d080","",4,"",4,"",5,""],
["d140","",4,"",4,"",6,"",5],
["d180","",4,"",4,"",4,""],
["d240","",8,"",24,"",5,"",19,""],
["d280","",26,""],
["d340","",30,"",6],
["d380","",4,"",5,"",21,""],
["d440","",31,"",8,"",21],
["d480","",25,"",6,""],
["d540","",7,"",7,"",46],
["d580","",32,""],
["d640","",34,"",27],
["d680","",30,""],
["d740","",31,"",4,"",25],
["d780","",24,""],
["d840","",8,"",7,"",5,"",6,"",6,"",6,""],
["d880","",6,"",20,""],
["d940","",62],
["d980","",32,""],
["da40","",14,"",8,"",4,"",9,""],
["da80","",12,""],
["db40","",6,"",7,"",4,""],
["db80","",4,"",5,"",11,""],
["dc40","",4,"",6,"",6,"",11,"",6,"",7],
["dc80","",10,"",21,""],
["dd40","",62],
["dd80","",32,""],
["de40","",32,""],
["de80","",4,""],
["df40","",5,"",4,"",4,"",5,"",4,"",6,""],
["df80","",4,""],
["e040","",19,""],
["e080","",10,"",6,"",8,""],
["e140","",4,"",6,"",5,"",5,""],
["e180","",10,"",9,"",8,""],
["e240","",62],
["e280","",32,"",5,""],
["e340","",45,"",16],
["e380","",7,"",24,""],
["e440","",5,"",24,"",31],
["e480","",32,""],
["e540","",51,"",10],
["e580","",31,""],
["e640","",34,"",27],
["e680","",29,""],
["e740","",7,"",54],
["e780","",32,"",6,"",4,""],
["e840","",14,"",43,""],
["e880","",20,""],
["e940","",7,"",42],
["e980","",32,""],
["ea40","",27,"",6,""],
["ea80","",4,"",12,""],
["eb40","",9,"",7,"",9,"",6,""],
["eb80","",4,""],
["ec40","",8,"",4,"",18,"",7],
["ec80","",4,"",7,"",4,"",4,""],
["ed40","",6,"",46],
["ed80","",4,"",23,""],
["ee40","",62],
["ee80","",32,"",4,"",6,""],
["ef40","",5,"",37,"",4],
["ef80","",30,"",4,"",8,""],
["f040","",4,"",28,"",26],
["f080","",9,"",12,"",4,"",6,""],
["f140","",10,"",47],
["f180","",32,""],
["f240","",62],
["f280","",32,""],
["f340","",17,"",6,"",4,""],
["f380","",8,"",6,""],
["f440","",5,"",10,"",10,"",7,"",5],
["f480","",32,""],
["f540","",62],
["f580","",32,""],
["f640","",62],
["f680","",32,"",5,"",5,"",4,"",7,""],
["f740","",62],
["f780","",4,"",4,""],
["f840","",62],
["f880","",32],
["f940","",62],
["f980","",32],
["fa40","",62],
["fa80","",32],
["fb40","",27,"",9,""],
["fb80","",5,"",8,"",5,""],
["fc40","",8,"",4,"",8,"",6],
["fc80","",4,"",5,"",8,""],
["fd40","",4,"",4,"",10,"",38],
["fd80","",5,"",11,"",4,""],
["fe40",""]
]

},{}],52:[function(require,module,exports){
module.exports=[
["0","\u0000",127],
["8141","",4,"",6,""],
["8161","",9,"",5,""],
["8181","",18,"",4,"",6,"",5,"",6,"",7,"",7,"",4,"",4,""],
["8241","",7,"",5],
["8261","",6,"",5,""],
["8281","",7,"",7,"",4,"",10,"",5,"",17,"",7,"",6,"",7,"",18],
["8341","",5,"",5,"",7],
["8361","",18,""],
["8381","",4,"",6,"",5,"",5,"",46,"",6,"",5,"",8],
["8441","",5,"",8],
["8461","",18],
["8481","",7,"",6,"",5,"",10,"",5,"",18,"",5,"",6,"",5,"",26,""],
["8541","",5,"",4,"",6,"",4],
["8561","",5,"",5,"",6,""],
["8581","",6,"",6,"",9,"",26,"",29,"",6,"",5,""],
["8641","",6,"",5,""],
["8661","",6,"",10],
["8681","",22,"",4,"",6,"",5,"",6,"",22,"",4,""],
["8741","",9,"",15],
["8761","",18,""],
["8781","",5,"",7,"",7,"",5,"",6,"",5,"",18,"",6,"",26,"",6,"",4],
["8841","",4,"",5,"",6,"",4],
["8861","",4,""],
["8881","",15,"",4,"",6,"",5,"",54,""],
["8941","",6,"",5,""],
["8961","",10,"",5,""],
["8981","",21,"",18,"",18,"",6,"",6,"",7,"",15],
["8a41","",10,"",6,""],
["8a61","",4,"",18,""],
["8a81","",4,"",19,"",5,"",7,"",5,"",6,"",5,"",4,"",5,"",26,""],
["8b41","",5,"",4,"",6,""],
["8b61","",6,"",8],
["8b81","",52,"",4,"",6,"",5,"",18,"",18],
["8c41","",15,"",4],
["8c61","",6,"",5,"",6,"",5],
["8c81","",12,"",26,"",50,"",5,"",16],
["8d41","",16,"",8],
["8d61","",17,""],
["8d81","",4,"",33,"",6,"",7,"",6,"",9,"",6,"",5,"",6,""],
["8e41","",6,"",5,"",8],
["8e61","",4,"",19],
["8e81","",13,"",6,"",4,"",6,"",5,"",6,"",5,"",11,"",7,"",6,"",5,"",7],
["8f41","",7,"",17],
["8f61","",7,"",6,"",4],
["8f81","",5,"",7,"",5,"",6,"",5,"",18,"",6,"",26,"",6,"",5],
["9041","",6,"",5,""],
["9061","",5,"",15],
["9081","",12,"",6,"",5,"",4,"",6,"",4,"",5,"",11,"",33,""],
["9141","",6,"",5],
["9161","",9,"",5],
["9181","",20,"",4,"",5,"",14,"",33,"",7,"",5,"",6],
["9241","",7,"",4,""],
["9261","",7,"",7,"",4],
["9281","",21,"",18,"",6,"",7,"",6,"",35,""],
["9341","",4,""],
["9361","",6,"",8],
["9381","",37,"",4,"",4,"",6,"",5,"",7,"",22,""],
["9441","",5,"",5,"",8],
["9461","",5,"",6,"",12],
["9481","",5,"",6,"",6,"",9,"",22,"",4,"",6,"",10,"",6,"",24],
["9541","",11,"",5,""],
["9561","",6,"",5,""],
["9581","",6,"",35,"",4,"",4,"",4,"",6,"",5,"",13,"",14],
["9641","",23,""],
["9661","",6,"",5,"",8],
["9681","",10,"",5,"",13,"",33,"",6,"",44],
["9741","",16,"",8],
["9761","",17,"",7],
["9781","",11,"",5,"",6,"",89,""],
["9841","",16,"",5,""],
["9861","",6,"",15],
["9881","",21,"",6,"",5,"",4,"",6,"",5,"",6,"",5,"",6,"",5,""],
["9941","",6,"",5,""],
["9961","",6,"",5,""],
["9981","",8,"",5,"",4,"",11,"",5,"",6,"",6,"",6,"",7,"",6,"",5,""],
["9a41","",16],
["9a61","",6,"",6,""],
["9a81","",4,"",6,"",5,"",5,"",6,"",5,"",5,"",33,"",5,"",6,""],
["9b41","",6,"",8],
["9b61","",17,"",7],
["9b81","",25,"",4,"",5,"",50,"",22,""],
["9c41","",4,"",5,"",5],
["9c61","",8,"",6,"",9],
["9c81","",8,"",6,"",6,"",9,"",26,"",6,"",5,"",18,"",6,"",12],
["9d41","",13,"",8],
["9d61","",25],
["9d81","",8,"",5,"",9,"",6,"",10,"",6,"",5,"",6,"",5,""],
["9e41","",7,"",9,""],
["9e61","",4,"",6,""],
["9e81","",6,"",6,"",6,"",5,"",10,"",5,"",6,"",5,"",6,""],
["9f41","",5,"",4,"",5,""],
["9f61","",6,"",5,""],
["9f81","",4,"",5,"",6,"",5,"",6,"",4,"",6,"",7,"",4,"",4,""],
["a041","",5,"",6,""],
["a061","",5,"",13],
["a081","",4,"",4,"",4,"",6,"",5,"",6,"",5,"",26,"",4,"",5,"",7,""],
["a141","",18,""],
["a161","",6,"",5,""],
["a181","",14,"",5,"",4,"",9,""],
["a241","",5,"",18],
["a261","",6,"",18],
["a281","",7,"",6,"",7,""],
["a341","",6,"",10,""],
["a361","",6,"",16],
["a381","",16,"",4,"",58,"",32,""],
["a441","",5,""],
["a461","",5,"",12],
["a481","",28,"",93],
["a541","",4,"",6,"",5,""],
["a561","",17,"",5,""],
["a581","",16,"",14,"",9],
["a5b0","",9],
["a5c1","",16,"",6],
["a5e1","",16,"",6],
["a641","",19,""],
["a661","",5,"",5,"",6],
["a681","",6,"",18,"",7],
["a741","",4,"",6,"",7],
["a761","",22,""],
["a781","",6,"",5,"",7,"",9,"",9,"",4,"",5,"",4,""],
["a841","",10,"",14],
["a861","",18,"",6],
["a881","",19,"",11,""],
["a8a6",""],
["a8a8",""],
["a8b1","",27,"",25,"",14,""],
["a941","",14,"",10],
["a961","",18],
["a981","",14,"",6,"",27,"",25,"",14,""],
["aa41","",6,"",4,""],
["aa61","",4,"",5,"",6,""],
["aa81","",29,"",82],
["ab41","",6,"",5,""],
["ab61","",6,"",5,"",5],
["ab81","",8,"",6,"",12,"",85],
["ac41","",5,"",6,""],
["ac61","",11,"",4],
["ac81","",28,"",5,"",25],
["acd1","",5,"",25],
["ad41","",6,"",5,"",7],
["ad61","",6,"",10,""],
["ad81","",5,"",18,""],
["ae41","",5,"",16],
["ae61","",5,"",6,"",4],
["ae81","",6,"",5,""],
["af41","",19],
["af61","",13,"",5,""],
["af81","",5,"",6,"",5,""],
["b041","",5,"",5,"",12],
["b061","",5,"",19],
["b081","",13,"",6,"",5,"",7,"",4,""],
["b141","",6,"",5,""],
["b161","",6,"",5,"",11],
["b181","",14,"",6,""],
["b241","",6,"",5,""],
["b261","",18,"",5,""],
["b281","",5,"",18,"",6,""],
["b341","",19,""],
["b361","",5,"",5,"",5],
["b381","",5,"",5,"",19,"",4,""],
["b441","",5,"",6,"",5],
["b461","",6,"",10,""],
["b481","",6,"",18,"",4,"",4,""],
["b541","",14,"",5],
["b561","",5,"",5,"",4],
["b581","",6,"",5,"",11,""],
["b641","",7,"",17],
["b661","",15,""],
["b681","",5,"",6,"",5,""],
["b741","",13,"",6,""],
["b761","",20,""],
["b781","",6,"",14,""],
["b841","",7,"",17],
["b861","",8,"",13],
["b881","",5,"",24,"",4,""],
["b941","",6,"",5,""],
["b961","",14,"",6,""],
["b981","",22,"",4,"",4,""],
["ba41","",5,"",6,""],
["ba61","",5,"",4,"",5],
["ba81","",6,"",9,""],
["bb41","",4,"",5,"",4,""],
["bb61","",6,"",5,""],
["bb81","",31,""],
["bc41","",17,""],
["bc61","",5,"",6,""],
["bc81","",4,"",6,"",5,"",5,"",4,""],
["bd41","",7,"",7,""],
["bd61","",5,"",13],
["bd81","",5,"",25,""],
["be41","",7,"",14],
["be61","",7,"",7,""],
["be81","",4,"",4,"",5,"",8,"",6,""],
["bf41","",10,"",14],
["bf61","",18,""],
["bf81","",5,"",7,"",6,"",5,""],
["c041","",5,"",6,"",5],
["c061","",25],
["c081","",6,"",5,"",7,""],
["c141","",5,"",6,""],
["c161","",19,""],
["c181","",31,""],
["c241","",4,"",5,""],
["c261","",4,"",5,"",6,""],
["c281","",5,"",7,"",9,""],
["c341","",4],
["c361","",4,"",5,"",11],
["c381","",5,"",7,"",5,""],
["c441","",7,"",7,""],
["c461","",5,"",4],
["c481","",5,"",11,""],
["c541","",6,"",5,""],
["c561","",6,"",5,"",4],
["c581","",6,"",5,""],
["c641","",6,"",5],
["c6a1",""],
["c7a1",""],
["c8a1",""],
["caa1",""],
["cba1",""],
["cca1",""],
["cda1",""],
["cea1",""],
["cfa1",""],
["d0a1",""],
["d1a1","",5,"",4,""],
["d2a1","",4,"",5,"",10,"",7,"",5,""],
["d3a1",""],
["d4a1",""],
["d5a1",""],
["d6a1",""],
["d7a1",""],
["d8a1",""],
["d9a1",""],
["daa1",""],
["dba1",""],
["dca1",""],
["dda1",""],
["dea1",""],
["dfa1",""],
["e0a1",""],
["e1a1",""],
["e2a1",""],
["e3a1",""],
["e4a1",""],
["e5a1",""],
["e6a1",""],
["e7a1",""],
["e8a1",""],
["e9a1",""],
["eaa1",""],
["eba1",""],
["eca1",""],
["eda1",""],
["eea1",""],
["efa1",""],
["f0a1",""],
["f1a1",""],
["f2a1",""],
["f3a1",""],
["f4a1",""],
["f5a1",""],
["f6a1",""],
["f7a1",""],
["f8a1",""],
["f9a1",""],
["faa1",""],
["fba1",""],
["fca1",""],
["fda1",""]
]

},{}],53:[function(require,module,exports){
module.exports=[
["0","\u0000",127],
["a140",""],
["a1a1","",4,""],
["a240","",7,""],
["a2a1","",9,"",9,"",8,"",25,"",21],
["a340","",16,"",6,"",16,"",6,"",10],
["a3a1","",25,""],
["a3e1",""],
["a440",""],
["a4a1",""],
["a540",""],
["a5a1",""],
["a640",""],
["a6a1",""],
["a740",""],
["a7a1",""],
["a840",""],
["a8a1",""],
["a940",""],
["a9a1",""],
["aa40",""],
["aaa1",""],
["ab40",""],
["aba1",""],
["ac40",""],
["aca1",""],
["ad40",""],
["ada1",""],
["ae40",""],
["aea1",""],
["af40",""],
["afa1",""],
["b040",""],
["b0a1",""],
["b140",""],
["b1a1",""],
["b240",""],
["b2a1",""],
["b340",""],
["b3a1",""],
["b440",""],
["b4a1",""],
["b540",""],
["b5a1",""],
["b640",""],
["b6a1",""],
["b740",""],
["b7a1",""],
["b840",""],
["b8a1",""],
["b940",""],
["b9a1",""],
["ba40",""],
["baa1",""],
["bb40",""],
["bba1",""],
["bc40",""],
["bca1",""],
["bd40",""],
["bda1",""],
["be40",""],
["bea1",""],
["bf40",""],
["bfa1",""],
["c040",""],
["c0a1",""],
["c140",""],
["c1a1",""],
["c240",""],
["c2a1",""],
["c340",""],
["c3a1",""],
["c440",""],
["c4a1",""],
["c540",""],
["c5a1",""],
["c640",""],
["c940",""],
["c9a1",""],
["ca40",""],
["caa1",""],
["cb40",""],
["cba1",""],
["cc40",""],
["cca1",""],
["cd40",""],
["cda1",""],
["ce40",""],
["cea1",""],
["cf40",""],
["cfa1",""],
["d040",""],
["d0a1",""],
["d140",""],
["d1a1",""],
["d240",""],
["d2a1",""],
["d340",""],
["d3a1",""],
["d440",""],
["d4a1",""],
["d540",""],
["d5a1",""],
["d640",""],
["d6a1",""],
["d740",""],
["d7a1",""],
["d840",""],
["d8a1",""],
["d940",""],
["d9a1",""],
["da40",""],
["daa1",""],
["db40",""],
["dba1",""],
["dc40",""],
["dca1",""],
["dd40",""],
["dda1",""],
["de40",""],
["dea1",""],
["df40",""],
["dfa1",""],
["e040",""],
["e0a1",""],
["e140",""],
["e1a1",""],
["e240",""],
["e2a1",""],
["e340",""],
["e3a1",""],
["e440",""],
["e4a1",""],
["e540",""],
["e5a1",""],
["e640",""],
["e6a1",""],
["e740",""],
["e7a1",""],
["e840",""],
["e8a1",""],
["e940",""],
["e9a1",""],
["ea40",""],
["eaa1",""],
["eb40",""],
["eba1",""],
["ec40",""],
["eca1",""],
["ed40",""],
["eda1",""],
["ee40",""],
["eea1",""],
["ef40",""],
["efa1",""],
["f040",""],
["f0a1",""],
["f140",""],
["f1a1",""],
["f240",""],
["f2a1",""],
["f340",""],
["f3a1",""],
["f440",""],
["f4a1",""],
["f540",""],
["f5a1",""],
["f640",""],
["f6a1",""],
["f740",""],
["f7a1",""],
["f840",""],
["f8a1",""],
["f940",""],
["f9a1",""]
]

},{}],54:[function(require,module,exports){
module.exports=[
["0","\u0000",127],
["8ea1","",62],
["a1a1","",9,""],
["a2a1",""],
["a2ba",""],
["a2ca",""],
["a2dc",""],
["a2f2",""],
["a2fe",""],
["a3b0","",9],
["a3c1","",25],
["a3e1","",25],
["a4a1","",82],
["a5a1","",85],
["a6a1","",16,"",6],
["a6c1","",16,"",6],
["a7a1","",5,"",25],
["a7d1","",5,"",25],
["a8a1",""],
["ada1","",19,"",9],
["adc0",""],
["addf","",4,""],
["b0a1",""],
["b1a1",""],
["b2a1",""],
["b3a1",""],
["b4a1",""],
["b5a1",""],
["b6a1",""],
["b7a1",""],
["b8a1",""],
["b9a1",""],
["baa1",""],
["bba1",""],
["bca1",""],
["bda1",""],
["bea1",""],
["bfa1",""],
["c0a1",""],
["c1a1",""],
["c2a1",""],
["c3a1",""],
["c4a1",""],
["c5a1",""],
["c6a1",""],
["c7a1",""],
["c8a1",""],
["c9a1",""],
["caa1",""],
["cba1",""],
["cca1",""],
["cda1",""],
["cea1",""],
["cfa1",""],
["d0a1",""],
["d1a1",""],
["d2a1",""],
["d3a1",""],
["d4a1",""],
["d5a1",""],
["d6a1",""],
["d7a1",""],
["d8a1",""],
["d9a1",""],
["daa1",""],
["dba1",""],
["dca1",""],
["dda1",""],
["dea1",""],
["dfa1",""],
["e0a1",""],
["e1a1",""],
["e2a1",""],
["e3a1",""],
["e4a1",""],
["e5a1",""],
["e6a1",""],
["e7a1",""],
["e8a1",""],
["e9a1",""],
["eaa1",""],
["eba1",""],
["eca1",""],
["eda1",""],
["eea1",""],
["efa1",""],
["f0a1",""],
["f1a1",""],
["f2a1",""],
["f3a1",""],
["f4a1",""],
["f9a1",""],
["faa1",""],
["fba1",""],
["fca1",""],
["fcf1","",9,""],
["8fa2af",""],
["8fa2c2",""],
["8fa2eb",""],
["8fa6e1",""],
["8fa6e7",""],
["8fa6e9",""],
["8fa6ec",""],
["8fa6f1",""],
["8fa7c2","",10,""],
["8fa7f2","",10,""],
["8fa9a1",""],
["8fa9a4",""],
["8fa9a6",""],
["8fa9a8",""],
["8fa9ab",""],
["8fa9af",""],
["8fa9c1",""],
["8faaa1",""],
["8faaba",""],
["8faba1",""],
["8fabbd",""],
["8fabc5",""],
["8fb0a1",""],
["8fb1a1",""],
["8fb2a1","",4,""],
["8fb3a1",""],
["8fb4a1",""],
["8fb5a1",""],
["8fb6a1","",5,"",4,""],
["8fb7a1","",4,""],
["8fb8a1",""],
["8fb9a1",""],
["8fbaa1","",4,""],
["8fbba1",""],
["8fbca1","",4,""],
["8fbda1","",4,""],
["8fbea1","",4,""],
["8fbfa1",""],
["8fc0a1",""],
["8fc1a1",""],
["8fc2a1",""],
["8fc3a1","",4,""],
["8fc4a1",""],
["8fc5a1",""],
["8fc6a1",""],
["8fc7a1",""],
["8fc8a1",""],
["8fc9a1","",4,"",4,""],
["8fcaa1",""],
["8fcba1",""],
["8fcca1","",9,""],
["8fcda1","",5,""],
["8fcea1","",6,""],
["8fcfa1",""],
["8fd0a1",""],
["8fd1a1",""],
["8fd2a1","",5],
["8fd3a1",""],
["8fd4a1","",4,""],
["8fd5a1",""],
["8fd6a1",""],
["8fd7a1",""],
["8fd8a1",""],
["8fd9a1","",4,"",6,""],
["8fdaa1","",4,""],
["8fdba1","",6,""],
["8fdca1","",4,""],
["8fdda1","",4,""],
["8fdea1","",4,""],
["8fdfa1",""],
["8fe0a1",""],
["8fe1a1","",4,""],
["8fe2a1",""],
["8fe3a1","",5,"",4,""],
["8fe4a1","",4,""],
["8fe5a1","",4,""],
["8fe6a1",""],
["8fe7a1",""],
["8fe8a1","",4,""],
["8fe9a1","",4],
["8feaa1","",4,""],
["8feba1","",4,""],
["8feca1",""],
["8feda1","",4,"",4,""]
]

},{}],55:[function(require,module,exports){
module.exports={"uChars":[128,165,169,178,184,216,226,235,238,244,248,251,253,258,276,284,300,325,329,334,364,463,465,467,469,471,473,475,477,506,594,610,712,716,730,930,938,962,970,1026,1104,1106,8209,8215,8218,8222,8231,8241,8244,8246,8252,8365,8452,8454,8458,8471,8482,8556,8570,8596,8602,8713,8720,8722,8726,8731,8737,8740,8742,8748,8751,8760,8766,8777,8781,8787,8802,8808,8816,8854,8858,8870,8896,8979,9322,9372,9548,9588,9616,9622,9634,9652,9662,9672,9676,9680,9702,9735,9738,9793,9795,11906,11909,11913,11917,11928,11944,11947,11951,11956,11960,11964,11979,12284,12292,12312,12319,12330,12351,12436,12447,12535,12543,12586,12842,12850,12964,13200,13215,13218,13253,13263,13267,13270,13384,13428,13727,13839,13851,14617,14703,14801,14816,14964,15183,15471,15585,16471,16736,17208,17325,17330,17374,17623,17997,18018,18212,18218,18301,18318,18760,18811,18814,18820,18823,18844,18848,18872,19576,19620,19738,19887,40870,59244,59336,59367,59413,59417,59423,59431,59437,59443,59452,59460,59478,59493,63789,63866,63894,63976,63986,64016,64018,64021,64025,64034,64037,64042,65074,65093,65107,65112,65127,65132,65375,65510,65536],"gbChars":[0,36,38,45,50,81,89,95,96,100,103,104,105,109,126,133,148,172,175,179,208,306,307,308,309,310,311,312,313,341,428,443,544,545,558,741,742,749,750,805,819,820,7922,7924,7925,7927,7934,7943,7944,7945,7950,8062,8148,8149,8152,8164,8174,8236,8240,8262,8264,8374,8380,8381,8384,8388,8390,8392,8393,8394,8396,8401,8406,8416,8419,8424,8437,8439,8445,8482,8485,8496,8521,8603,8936,8946,9046,9050,9063,9066,9076,9092,9100,9108,9111,9113,9131,9162,9164,9218,9219,11329,11331,11334,11336,11346,11361,11363,11366,11370,11372,11375,11389,11682,11686,11687,11692,11694,11714,11716,11723,11725,11730,11736,11982,11989,12102,12336,12348,12350,12384,12393,12395,12397,12510,12553,12851,12962,12973,13738,13823,13919,13933,14080,14298,14585,14698,15583,15847,16318,16434,16438,16481,16729,17102,17122,17315,17320,17402,17418,17859,17909,17911,17915,17916,17936,17939,17961,18664,18703,18814,18962,19043,33469,33470,33471,33484,33485,33490,33497,33501,33505,33513,33520,33536,33550,37845,37921,37948,38029,38038,38064,38065,38066,38069,38075,38076,38078,39108,39109,39113,39114,39115,39116,39265,39394,189000]}
},{}],56:[function(require,module,exports){
module.exports=[
["a140","",62],
["a180","",32],
["a240","",62],
["a280","",32],
["a2ab","",5],
["a2e3",""],
["a2ef",""],
["a2fd",""],
["a340","",62],
["a380","",31,""],
["a440","",62],
["a480","",32],
["a4f4","",10],
["a540","",62],
["a580","",32],
["a5f7","",7],
["a640","",62],
["a680","",32],
["a6b9","",7],
["a6d9","",6],
["a6ec",""],
["a6f3",""],
["a6f6","",8],
["a740","",62],
["a780","",32],
["a7c2","",14],
["a7f2","",12],
["a896","",10],
["a8bc",""],
["a8bf",""],
["a8c1",""],
["a8ea","",20],
["a958",""],
["a95b",""],
["a95d",""],
["a989","",11],
["a997","",12],
["a9f0","",14],
["aaa1","",93],
["aba1","",93],
["aca1","",93],
["ada1","",93],
["aea1","",93],
["afa1","",93],
["d7fa","",4],
["f8a1","",93],
["f9a1","",93],
["faa1","",93],
["fba1","",93],
["fca1","",93],
["fda1","",93],
["fe50",""],
["fe80","",6,"",93]
]

},{}],57:[function(require,module,exports){
module.exports=[
["0","\u0000",128],
["a1","",62],
["8140","",9,""],
["8180",""],
["81b8",""],
["81c8",""],
["81da",""],
["81f0",""],
["81fc",""],
["824f","",9],
["8260","",25],
["8281","",25],
["829f","",82],
["8340","",62],
["8380","",22],
["839f","",16,"",6],
["83bf","",16,"",6],
["8440","",5,"",25],
["8470","",5,"",7],
["8480","",17],
["849f",""],
["8740","",19,"",9],
["875f",""],
["877e",""],
["8780","",4,""],
["889f",""],
["8940",""],
["8980",""],
["8a40",""],
["8a80",""],
["8b40",""],
["8b80",""],
["8c40",""],
["8c80",""],
["8d40",""],
["8d80",""],
["8e40",""],
["8e80",""],
["8f40",""],
["8f80",""],
["9040",""],
["9080",""],
["9140",""],
["9180",""],
["9240",""],
["9280",""],
["9340",""],
["9380",""],
["9440",""],
["9480",""],
["9540",""],
["9580",""],
["9640",""],
["9680",""],
["9740",""],
["9780",""],
["9840",""],
["989f",""],
["9940",""],
["9980",""],
["9a40",""],
["9a80",""],
["9b40",""],
["9b80",""],
["9c40",""],
["9c80",""],
["9d40",""],
["9d80",""],
["9e40",""],
["9e80",""],
["9f40",""],
["9f80",""],
["e040",""],
["e080",""],
["e140",""],
["e180",""],
["e240",""],
["e280",""],
["e340",""],
["e380",""],
["e440",""],
["e480",""],
["e540",""],
["e580",""],
["e640",""],
["e680",""],
["e740",""],
["e780",""],
["e840",""],
["e880",""],
["e940",""],
["e980",""],
["ea40",""],
["ea80",""],
["ed40",""],
["ed80",""],
["ee40",""],
["ee80",""],
["eeef","",9,""],
["f040","",62],
["f080","",124],
["f140","",62],
["f180","",124],
["f240","",62],
["f280","",124],
["f340","",62],
["f380","",124],
["f440","",62],
["f480","",124],
["f540","",62],
["f580","",124],
["f640","",62],
["f680","",124],
["f740","",62],
["f780","",124],
["f840","",62],
["f880","",124],
["f940",""],
["fa40","",9,"",9,""],
["fa80",""],
["fb40",""],
["fb80",""],
["fc40",""]
]

},{}],58:[function(require,module,exports){
(function (Buffer){
"use strict"

// == UTF16-BE codec. ==========================================================

exports.utf16be = Utf16BECodec;
function Utf16BECodec() {
}

Utf16BECodec.prototype.encoder = Utf16BEEncoder;
Utf16BECodec.prototype.decoder = Utf16BEDecoder;
Utf16BECodec.prototype.bomAware = true;


// -- Encoding

function Utf16BEEncoder() {
}

Utf16BEEncoder.prototype.write = function(str) {
    var buf = new Buffer(str, 'ucs2');
    for (var i = 0; i < buf.length; i += 2) {
        var tmp = buf[i]; buf[i] = buf[i+1]; buf[i+1] = tmp;
    }
    return buf;
}

Utf16BEEncoder.prototype.end = function() {
}


// -- Decoding

function Utf16BEDecoder() {
    this.overflowByte = -1;
}

Utf16BEDecoder.prototype.write = function(buf) {
    if (buf.length == 0)
        return '';

    var buf2 = new Buffer(buf.length + 1),
        i = 0, j = 0;

    if (this.overflowByte !== -1) {
        buf2[0] = buf[0];
        buf2[1] = this.overflowByte;
        i = 1; j = 2;
    }

    for (; i < buf.length-1; i += 2, j+= 2) {
        buf2[j] = buf[i+1];
        buf2[j+1] = buf[i];
    }

    this.overflowByte = (i == buf.length-1) ? buf[buf.length-1] : -1;

    return buf2.slice(0, j).toString('ucs2');
}

Utf16BEDecoder.prototype.end = function() {
}


// == UTF-16 codec =============================================================
// Decoder chooses automatically from UTF-16LE and UTF-16BE using BOM and space-based heuristic.
// Defaults to UTF-16LE, as it's prevalent and default in Node.
// http://en.wikipedia.org/wiki/UTF-16 and http://encoding.spec.whatwg.org/#utf-16le
// Decoder default can be changed: iconv.decode(buf, 'utf16', {defaultEncoding: 'utf-16be'});

// Encoder uses UTF-16LE and prepends BOM (which can be overridden with addBOM: false).

exports.utf16 = Utf16Codec;
function Utf16Codec(codecOptions, iconv) {
    this.iconv = iconv;
}

Utf16Codec.prototype.encoder = Utf16Encoder;
Utf16Codec.prototype.decoder = Utf16Decoder;


// -- Encoding (pass-through)

function Utf16Encoder(options, codec) {
    options = options || {};
    if (options.addBOM === undefined)
        options.addBOM = true;
    this.encoder = codec.iconv.getEncoder('utf-16le', options);
}

Utf16Encoder.prototype.write = function(str) {
    return this.encoder.write(str);
}

Utf16Encoder.prototype.end = function() {
    return this.encoder.end();
}


// -- Decoding

function Utf16Decoder(options, codec) {
    this.decoder = null;
    this.initialBytes = [];
    this.initialBytesLen = 0;

    this.options = options || {};
    this.iconv = codec.iconv;
}

Utf16Decoder.prototype.write = function(buf) {
    if (!this.decoder) {
        // Codec is not chosen yet. Accumulate initial bytes.
        this.initialBytes.push(buf);
        this.initialBytesLen += buf.length;
        
        if (this.initialBytesLen < 16) // We need more bytes to use space heuristic (see below)
            return '';

        // We have enough bytes -> detect endianness.
        var buf = Buffer.concat(this.initialBytes),
            encoding = detectEncoding(buf, this.options.defaultEncoding);
        this.decoder = this.iconv.getDecoder(encoding, this.options);
        this.initialBytes.length = this.initialBytesLen = 0;
    }

    return this.decoder.write(buf);
}

Utf16Decoder.prototype.end = function() {
    if (!this.decoder) {
        var buf = Buffer.concat(this.initialBytes),
            encoding = detectEncoding(buf, this.options.defaultEncoding);
        this.decoder = this.iconv.getDecoder(encoding, this.options);

        var res = this.decoder.write(buf),
            trail = this.decoder.end();

        return trail ? (res + trail) : res;
    }
    return this.decoder.end();
}

function detectEncoding(buf, defaultEncoding) {
    var enc = defaultEncoding || 'utf-16le';

    if (buf.length >= 2) {
        // Check BOM.
        if (buf[0] == 0xFE && buf[1] == 0xFF) // UTF-16BE BOM
            enc = 'utf-16be';
        else if (buf[0] == 0xFF && buf[1] == 0xFE) // UTF-16LE BOM
            enc = 'utf-16le';
        else {
            // No BOM found. Try to deduce encoding from initial content.
            // Most of the time, the content has ASCII chars (U+00**), but the opposite (U+**00) is uncommon.
            // So, we count ASCII as if it was LE or BE, and decide from that.
            var asciiCharsLE = 0, asciiCharsBE = 0, // Counts of chars in both positions
                _len = Math.min(buf.length - (buf.length % 2), 64); // Len is always even.

            for (var i = 0; i < _len; i += 2) {
                if (buf[i] === 0 && buf[i+1] !== 0) asciiCharsBE++;
                if (buf[i] !== 0 && buf[i+1] === 0) asciiCharsLE++;
            }

            if (asciiCharsBE > asciiCharsLE)
                enc = 'utf-16be';
            else if (asciiCharsBE < asciiCharsLE)
                enc = 'utf-16le';
        }
    }

    return enc;
}



}).call(this,require("buffer").Buffer)
},{"buffer":9}],59:[function(require,module,exports){
(function (Buffer){
"use strict"

// UTF-7 codec, according to https://tools.ietf.org/html/rfc2152
// See also below a UTF-7-IMAP codec, according to http://tools.ietf.org/html/rfc3501#section-5.1.3

exports.utf7 = Utf7Codec;
exports.unicode11utf7 = 'utf7'; // Alias UNICODE-1-1-UTF-7
function Utf7Codec(codecOptions, iconv) {
    this.iconv = iconv;
};

Utf7Codec.prototype.encoder = Utf7Encoder;
Utf7Codec.prototype.decoder = Utf7Decoder;
Utf7Codec.prototype.bomAware = true;


// -- Encoding

var nonDirectChars = /[^A-Za-z0-9'\(\),-\.\/:\? \n\r\t]+/g;

function Utf7Encoder(options, codec) {
    this.iconv = codec.iconv;
}

Utf7Encoder.prototype.write = function(str) {
    // Naive implementation.
    // Non-direct chars are encoded as "+<base64>-"; single "+" char is encoded as "+-".
    return new Buffer(str.replace(nonDirectChars, function(chunk) {
        return "+" + (chunk === '+' ? '' : 
            this.iconv.encode(chunk, 'utf16-be').toString('base64').replace(/=+$/, '')) 
            + "-";
    }.bind(this)));
}

Utf7Encoder.prototype.end = function() {
}


// -- Decoding

function Utf7Decoder(options, codec) {
    this.iconv = codec.iconv;
    this.inBase64 = false;
    this.base64Accum = '';
}

var base64Regex = /[A-Za-z0-9\/+]/;
var base64Chars = [];
for (var i = 0; i < 256; i++)
    base64Chars[i] = base64Regex.test(String.fromCharCode(i));

var plusChar = '+'.charCodeAt(0), 
    minusChar = '-'.charCodeAt(0),
    andChar = '&'.charCodeAt(0);

Utf7Decoder.prototype.write = function(buf) {
    var res = "", lastI = 0,
        inBase64 = this.inBase64,
        base64Accum = this.base64Accum;

    // The decoder is more involved as we must handle chunks in stream.

    for (var i = 0; i < buf.length; i++) {
        if (!inBase64) { // We're in direct mode.
            // Write direct chars until '+'
            if (buf[i] == plusChar) {
                res += this.iconv.decode(buf.slice(lastI, i), "ascii"); // Write direct chars.
                lastI = i+1;
                inBase64 = true;
            }
        } else { // We decode base64.
            if (!base64Chars[buf[i]]) { // Base64 ended.
                if (i == lastI && buf[i] == minusChar) {// "+-" -> "+"
                    res += "+";
                } else {
                    var b64str = base64Accum + buf.slice(lastI, i).toString();
                    res += this.iconv.decode(new Buffer(b64str, 'base64'), "utf16-be");
                }

                if (buf[i] != minusChar) // Minus is absorbed after base64.
                    i--;

                lastI = i+1;
                inBase64 = false;
                base64Accum = '';
            }
        }
    }

    if (!inBase64) {
        res += this.iconv.decode(buf.slice(lastI), "ascii"); // Write direct chars.
    } else {
        var b64str = base64Accum + buf.slice(lastI).toString();

        var canBeDecoded = b64str.length - (b64str.length % 8); // Minimal chunk: 2 quads -> 2x3 bytes -> 3 chars.
        base64Accum = b64str.slice(canBeDecoded); // The rest will be decoded in future.
        b64str = b64str.slice(0, canBeDecoded);

        res += this.iconv.decode(new Buffer(b64str, 'base64'), "utf16-be");
    }

    this.inBase64 = inBase64;
    this.base64Accum = base64Accum;

    return res;
}

Utf7Decoder.prototype.end = function() {
    var res = "";
    if (this.inBase64 && this.base64Accum.length > 0)
        res = this.iconv.decode(new Buffer(this.base64Accum, 'base64'), "utf16-be");

    this.inBase64 = false;
    this.base64Accum = '';
    return res;
}


// UTF-7-IMAP codec.
// RFC3501 Sec. 5.1.3 Modified UTF-7 (http://tools.ietf.org/html/rfc3501#section-5.1.3)
// Differences:
//  * Base64 part is started by "&" instead of "+"
//  * Direct characters are 0x20-0x7E, except "&" (0x26)
//  * In Base64, "," is used instead of "/"
//  * Base64 must not be used to represent direct characters.
//  * No implicit shift back from Base64 (should always end with '-')
//  * String must end in non-shifted position.
//  * "-&" while in base64 is not allowed.


exports.utf7imap = Utf7IMAPCodec;
function Utf7IMAPCodec(codecOptions, iconv) {
    this.iconv = iconv;
};

Utf7IMAPCodec.prototype.encoder = Utf7IMAPEncoder;
Utf7IMAPCodec.prototype.decoder = Utf7IMAPDecoder;
Utf7IMAPCodec.prototype.bomAware = true;


// -- Encoding

function Utf7IMAPEncoder(options, codec) {
    this.iconv = codec.iconv;
    this.inBase64 = false;
    this.base64Accum = new Buffer(6);
    this.base64AccumIdx = 0;
}

Utf7IMAPEncoder.prototype.write = function(str) {
    var inBase64 = this.inBase64,
        base64Accum = this.base64Accum,
        base64AccumIdx = this.base64AccumIdx,
        buf = new Buffer(str.length*5 + 10), bufIdx = 0;

    for (var i = 0; i < str.length; i++) {
        var uChar = str.charCodeAt(i);
        if (0x20 <= uChar && uChar <= 0x7E) { // Direct character or '&'.
            if (inBase64) {
                if (base64AccumIdx > 0) {
                    bufIdx += buf.write(base64Accum.slice(0, base64AccumIdx).toString('base64').replace(/\//g, ',').replace(/=+$/, ''), bufIdx);
                    base64AccumIdx = 0;
                }

                buf[bufIdx++] = minusChar; // Write '-', then go to direct mode.
                inBase64 = false;
            }

            if (!inBase64) {
                buf[bufIdx++] = uChar; // Write direct character

                if (uChar === andChar)  // Ampersand -> '&-'
                    buf[bufIdx++] = minusChar;
            }

        } else { // Non-direct character
            if (!inBase64) {
                buf[bufIdx++] = andChar; // Write '&', then go to base64 mode.
                inBase64 = true;
            }
            if (inBase64) {
                base64Accum[base64AccumIdx++] = uChar >> 8;
                base64Accum[base64AccumIdx++] = uChar & 0xFF;

                if (base64AccumIdx == base64Accum.length) {
                    bufIdx += buf.write(base64Accum.toString('base64').replace(/\//g, ','), bufIdx);
                    base64AccumIdx = 0;
                }
            }
        }
    }

    this.inBase64 = inBase64;
    this.base64AccumIdx = base64AccumIdx;

    return buf.slice(0, bufIdx);
}

Utf7IMAPEncoder.prototype.end = function() {
    var buf = new Buffer(10), bufIdx = 0;
    if (this.inBase64) {
        if (this.base64AccumIdx > 0) {
            bufIdx += buf.write(this.base64Accum.slice(0, this.base64AccumIdx).toString('base64').replace(/\//g, ',').replace(/=+$/, ''), bufIdx);
            this.base64AccumIdx = 0;
        }

        buf[bufIdx++] = minusChar; // Write '-', then go to direct mode.
        this.inBase64 = false;
    }

    return buf.slice(0, bufIdx);
}


// -- Decoding

function Utf7IMAPDecoder(options, codec) {
    this.iconv = codec.iconv;
    this.inBase64 = false;
    this.base64Accum = '';
}

var base64IMAPChars = base64Chars.slice();
base64IMAPChars[','.charCodeAt(0)] = true;

Utf7IMAPDecoder.prototype.write = function(buf) {
    var res = "", lastI = 0,
        inBase64 = this.inBase64,
        base64Accum = this.base64Accum;

    // The decoder is more involved as we must handle chunks in stream.
    // It is forgiving, closer to standard UTF-7 (for example, '-' is optional at the end).

    for (var i = 0; i < buf.length; i++) {
        if (!inBase64) { // We're in direct mode.
            // Write direct chars until '&'
            if (buf[i] == andChar) {
                res += this.iconv.decode(buf.slice(lastI, i), "ascii"); // Write direct chars.
                lastI = i+1;
                inBase64 = true;
            }
        } else { // We decode base64.
            if (!base64IMAPChars[buf[i]]) { // Base64 ended.
                if (i == lastI && buf[i] == minusChar) { // "&-" -> "&"
                    res += "&";
                } else {
                    var b64str = base64Accum + buf.slice(lastI, i).toString().replace(/,/g, '/');
                    res += this.iconv.decode(new Buffer(b64str, 'base64'), "utf16-be");
                }

                if (buf[i] != minusChar) // Minus may be absorbed after base64.
                    i--;

                lastI = i+1;
                inBase64 = false;
                base64Accum = '';
            }
        }
    }

    if (!inBase64) {
        res += this.iconv.decode(buf.slice(lastI), "ascii"); // Write direct chars.
    } else {
        var b64str = base64Accum + buf.slice(lastI).toString().replace(/,/g, '/');

        var canBeDecoded = b64str.length - (b64str.length % 8); // Minimal chunk: 2 quads -> 2x3 bytes -> 3 chars.
        base64Accum = b64str.slice(canBeDecoded); // The rest will be decoded in future.
        b64str = b64str.slice(0, canBeDecoded);

        res += this.iconv.decode(new Buffer(b64str, 'base64'), "utf16-be");
    }

    this.inBase64 = inBase64;
    this.base64Accum = base64Accum;

    return res;
}

Utf7IMAPDecoder.prototype.end = function() {
    var res = "";
    if (this.inBase64 && this.base64Accum.length > 0)
        res = this.iconv.decode(new Buffer(this.base64Accum, 'base64'), "utf16-be");

    this.inBase64 = false;
    this.base64Accum = '';
    return res;
}



}).call(this,require("buffer").Buffer)
},{"buffer":9}],60:[function(require,module,exports){
"use strict"

var BOMChar = '\uFEFF';

exports.PrependBOM = PrependBOMWrapper
function PrependBOMWrapper(encoder, options) {
    this.encoder = encoder;
    this.addBOM = true;
}

PrependBOMWrapper.prototype.write = function(str) {
    if (this.addBOM) {
        str = BOMChar + str;
        this.addBOM = false;
    }

    return this.encoder.write(str);
}

PrependBOMWrapper.prototype.end = function() {
    return this.encoder.end();
}


//------------------------------------------------------------------------------

exports.StripBOM = StripBOMWrapper;
function StripBOMWrapper(decoder, options) {
    this.decoder = decoder;
    this.pass = false;
    this.options = options || {};
}

StripBOMWrapper.prototype.write = function(buf) {
    var res = this.decoder.write(buf);
    if (this.pass || !res)
        return res;

    if (res[0] === BOMChar) {
        res = res.slice(1);
        if (typeof this.options.stripBOM === 'function')
            this.options.stripBOM();
    }

    this.pass = true;
    return res;
}

StripBOMWrapper.prototype.end = function() {
    return this.decoder.end();
}


},{}],61:[function(require,module,exports){
(function (process,Buffer){
"use strict"

var bomHandling = require('./bom-handling'),
    iconv = module.exports;

// All codecs and aliases are kept here, keyed by encoding name/alias.
// They are lazy loaded in `iconv.getCodec` from `encodings/index.js`.
iconv.encodings = null;

// Characters emitted in case of error.
iconv.defaultCharUnicode = '';
iconv.defaultCharSingleByte = '?';

// Public API.
iconv.encode = function encode(str, encoding, options) {
    str = "" + (str || ""); // Ensure string.

    var encoder = iconv.getEncoder(encoding, options);

    var res = encoder.write(str);
    var trail = encoder.end();
    
    return (trail && trail.length > 0) ? Buffer.concat([res, trail]) : res;
}

iconv.decode = function decode(buf, encoding, options) {
    if (typeof buf === 'string') {
        if (!iconv.skipDecodeWarning) {
            console.error('Iconv-lite warning: decode()-ing strings is deprecated. Refer to https://github.com/ashtuchkin/iconv-lite/wiki/Use-Buffers-when-decoding');
            iconv.skipDecodeWarning = true;
        }

        buf = new Buffer("" + (buf || ""), "binary"); // Ensure buffer.
    }

    var decoder = iconv.getDecoder(encoding, options);

    var res = decoder.write(buf);
    var trail = decoder.end();

    return trail ? (res + trail) : res;
}

iconv.encodingExists = function encodingExists(enc) {
    try {
        iconv.getCodec(enc);
        return true;
    } catch (e) {
        return false;
    }
}

// Legacy aliases to convert functions
iconv.toEncoding = iconv.encode;
iconv.fromEncoding = iconv.decode;

// Search for a codec in iconv.encodings. Cache codec data in iconv._codecDataCache.
iconv._codecDataCache = {};
iconv.getCodec = function getCodec(encoding) {
    if (!iconv.encodings)
        iconv.encodings = require("../encodings"); // Lazy load all encoding definitions.
    
    // Canonicalize encoding name: strip all non-alphanumeric chars and appended year.
    var enc = (''+encoding).toLowerCase().replace(/[^0-9a-z]|:\d{4}$/g, "");

    // Traverse iconv.encodings to find actual codec.
    var codecOptions = {};
    while (true) {
        var codec = iconv._codecDataCache[enc];
        if (codec)
            return codec;

        var codecDef = iconv.encodings[enc];

        switch (typeof codecDef) {
            case "string": // Direct alias to other encoding.
                enc = codecDef;
                break;

            case "object": // Alias with options. Can be layered.
                for (var key in codecDef)
                    codecOptions[key] = codecDef[key];

                if (!codecOptions.encodingName)
                    codecOptions.encodingName = enc;
                
                enc = codecDef.type;
                break;

            case "function": // Codec itself.
                if (!codecOptions.encodingName)
                    codecOptions.encodingName = enc;

                // The codec function must load all tables and return object with .encoder and .decoder methods.
                // It'll be called only once (for each different options object).
                codec = new codecDef(codecOptions, iconv);

                iconv._codecDataCache[codecOptions.encodingName] = codec; // Save it to be reused later.
                return codec;

            default:
                throw new Error("Encoding not recognized: '" + encoding + "' (searched as: '"+enc+"')");
        }
    }
}

iconv.getEncoder = function getEncoder(encoding, options) {
    var codec = iconv.getCodec(encoding),
        encoder = new codec.encoder(options, codec);

    if (codec.bomAware && options && options.addBOM)
        encoder = new bomHandling.PrependBOM(encoder, options);

    return encoder;
}

iconv.getDecoder = function getDecoder(encoding, options) {
    var codec = iconv.getCodec(encoding),
        decoder = new codec.decoder(options, codec);

    if (codec.bomAware && !(options && options.stripBOM === false))
        decoder = new bomHandling.StripBOM(decoder, options);

    return decoder;
}


// Load extensions in Node. All of them are omitted in Browserify build via 'browser' field in package.json.
var nodeVer = typeof process !== 'undefined' && process.versions && process.versions.node;
if (nodeVer) {

    // Load streaming support in Node v0.10+
    var nodeVerArr = nodeVer.split(".").map(Number);
    if (nodeVerArr[0] > 0 || nodeVerArr[1] >= 10) {
        require("./streams")(iconv);
    }

    // Load Node primitive extensions.
    require("./extend-node")(iconv);
}


}).call(this,require("7YKIPe"),require("buffer").Buffer)
},{"../encodings":45,"./bom-handling":60,"./extend-node":7,"./streams":7,"7YKIPe":17,"buffer":9}],62:[function(require,module,exports){
'use strict';

var ip = exports;
var Buffer = require('buffer').Buffer;
var os = require('os');

ip.toBuffer = function(ip, buff, offset) {
  offset = ~~offset;

  var result;

  if (this.isV4Format(ip)) {
    result = buff || new Buffer(offset + 4);
    ip.split(/\./g).map(function(byte) {
      result[offset++] = parseInt(byte, 10) & 0xff;
    });
  } else if (this.isV6Format(ip)) {
    var sections = ip.split(':', 8);

    var i;
    for (i = 0; i < sections.length; i++) {
      var isv4 = this.isV4Format(sections[i]);
      var v4Buffer;

      if (isv4) {
        v4Buffer = this.toBuffer(sections[i]);
        sections[i] = v4Buffer.slice(0, 2).toString('hex');
      }

      if (v4Buffer && ++i < 8) {
        sections.splice(i, 0, v4Buffer.slice(2, 4).toString('hex'));
      }
    }

    if (sections[0] === '') {
      while (sections.length < 8) sections.unshift('0');
    } else if (sections[sections.length - 1] === '') {
      while (sections.length < 8) sections.push('0');
    } else if (sections.length < 8) {
      for (i = 0; i < sections.length && sections[i] !== ''; i++);
      var argv = [ i, 1 ];
      for (i = 9 - sections.length; i > 0; i--) {
        argv.push('0');
      }
      sections.splice.apply(sections, argv);
    }

    result = buff || new Buffer(offset + 16);
    for (i = 0; i < sections.length; i++) {
      var word = parseInt(sections[i], 16);
      result[offset++] = (word >> 8) & 0xff;
      result[offset++] = word & 0xff;
    }
  }

  if (!result) {
    throw Error('Invalid ip address: ' + ip);
  }

  return result;
};

ip.toString = function(buff, offset, length) {
  offset = ~~offset;
  length = length || (buff.length - offset);

  var result = [];
  if (length === 4) {
    // IPv4
    for (var i = 0; i < length; i++) {
      result.push(buff[offset + i]);
    }
    result = result.join('.');
  } else if (length === 16) {
    // IPv6
    for (var i = 0; i < length; i += 2) {
      result.push(buff.readUInt16BE(offset + i).toString(16));
    }
    result = result.join(':');
    result = result.replace(/(^|:)0(:0)*:0(:|$)/, '$1::$3');
    result = result.replace(/:{3,4}/, '::');
  }

  return result;
};

var ipv4Regex = /^(\d{1,3}\.){3,3}\d{1,3}$/;
var ipv6Regex =
    /^(::)?(((\d{1,3}\.){3}(\d{1,3}){1})?([0-9a-f]){0,4}:{0,2}){1,8}(::)?$/i;

ip.isV4Format = function(ip) {
  return ipv4Regex.test(ip);
};

ip.isV6Format = function(ip) {
  return ipv6Regex.test(ip);
};
function _normalizeFamily(family) {
  return family ? family.toLowerCase() : 'ipv4';
}

ip.fromPrefixLen = function(prefixlen, family) {
  if (prefixlen > 32) {
    family = 'ipv6';
  } else {
    family = _normalizeFamily(family);
  }

  var len = 4;
  if (family === 'ipv6') {
    len = 16;
  }
  var buff = new Buffer(len);

  for (var i = 0, n = buff.length; i < n; ++i) {
    var bits = 8;
    if (prefixlen < 8) {
      bits = prefixlen;
    }
    prefixlen -= bits;

    buff[i] = ~(0xff >> bits);
  }

  return ip.toString(buff);
};

ip.mask = function(addr, mask) {
  addr = ip.toBuffer(addr);
  mask = ip.toBuffer(mask);

  var result = new Buffer(Math.max(addr.length, mask.length));

  // Same protocol - do bitwise and
  if (addr.length === mask.length) {
    for (var i = 0; i < addr.length; i++) {
      result[i] = addr[i] & mask[i];
    }
  } else if (mask.length === 4) {
    // IPv6 address and IPv4 mask
    // (Mask low bits)
    for (var i = 0; i < mask.length; i++) {
      result[i] = addr[addr.length - 4  + i] & mask[i];
    }
  } else {
    // IPv6 mask and IPv4 addr
    for (var i = 0; i < result.length - 6; i++) {
      result[i] = 0;
    }

    // ::ffff:ipv4
    result[10] = 0xff;
    result[11] = 0xff;
    for (var i = 0; i < addr.length; i++) {
      result[i + 12] = addr[i] & mask[i + 12];
    }
  }

  return ip.toString(result);
};

ip.cidr = function(cidrString) {
  var cidrParts = cidrString.split('/');

  var addr = cidrParts[0];
  if (cidrParts.length !== 2)
    throw new Error('invalid CIDR subnet: ' + addr);

  var mask = ip.fromPrefixLen(parseInt(cidrParts[1], 10));

  return ip.mask(addr, mask);
};

ip.subnet = function(addr, mask) {
  var networkAddress = ip.toLong(ip.mask(addr, mask));

  // Calculate the mask's length.
  var maskBuffer = ip.toBuffer(mask);
  var maskLength = 0;

  for (var i = 0; i < maskBuffer.length; i++) {
    if (maskBuffer[i] === 0xff) {
      maskLength += 8;
    } else {
      var octet = maskBuffer[i] & 0xff;
      while (octet) {
        octet = (octet << 1) & 0xff;
        maskLength++;
      }
    }
  }

  var numberOfAddresses = Math.pow(2, 32 - maskLength);

  return {
    networkAddress: ip.fromLong(networkAddress),
    firstAddress: numberOfAddresses <= 2 ?
                    ip.fromLong(networkAddress) :
                    ip.fromLong(networkAddress + 1),
    lastAddress: numberOfAddresses <= 2 ?
                    ip.fromLong(networkAddress + numberOfAddresses - 1) :
                    ip.fromLong(networkAddress + numberOfAddresses - 2),
    broadcastAddress: ip.fromLong(networkAddress + numberOfAddresses - 1),
    subnetMask: mask,
    subnetMaskLength: maskLength,
    numHosts: numberOfAddresses <= 2 ?
                numberOfAddresses : numberOfAddresses - 2,
    length: numberOfAddresses,
    contains: function(other) {
      return networkAddress === ip.toLong(ip.mask(other, mask));
    }
  };
};

ip.cidrSubnet = function(cidrString) {
  var cidrParts = cidrString.split('/');

  var addr = cidrParts[0];
  if (cidrParts.length !== 2)
    throw new Error('invalid CIDR subnet: ' + addr);

  var mask = ip.fromPrefixLen(parseInt(cidrParts[1], 10));

  return ip.subnet(addr, mask);
};

ip.not = function(addr) {
  var buff = ip.toBuffer(addr);
  for (var i = 0; i < buff.length; i++) {
    buff[i] = 0xff ^ buff[i];
  }
  return ip.toString(buff);
};

ip.or = function(a, b) {
  a = ip.toBuffer(a);
  b = ip.toBuffer(b);

  // same protocol
  if (a.length === b.length) {
    for (var i = 0; i < a.length; ++i) {
      a[i] |= b[i];
    }
    return ip.toString(a);

  // mixed protocols
  } else {
    var buff = a;
    var other = b;
    if (b.length > a.length) {
      buff = b;
      other = a;
    }

    var offset = buff.length - other.length;
    for (var i = offset; i < buff.length; ++i) {
      buff[i] |= other[i - offset];
    }

    return ip.toString(buff);
  }
};

ip.isEqual = function(a, b) {
  a = ip.toBuffer(a);
  b = ip.toBuffer(b);

  // Same protocol
  if (a.length === b.length) {
    for (var i = 0; i < a.length; i++) {
      if (a[i] !== b[i]) return false;
    }
    return true;
  }

  // Swap
  if (b.length === 4) {
    var t = b;
    b = a;
    a = t;
  }

  // a - IPv4, b - IPv6
  for (var i = 0; i < 10; i++) {
    if (b[i] !== 0) return false;
  }

  var word = b.readUInt16BE(10);
  if (word !== 0 && word !== 0xffff) return false;

  for (var i = 0; i < 4; i++) {
    if (a[i] !== b[i + 12]) return false;
  }

  return true;
};

ip.isPrivate = function(addr) {
  return /^(::f{4}:)?10\.([0-9]{1,3})\.([0-9]{1,3})\.([0-9]{1,3})$/i
      .test(addr) ||
    /^(::f{4}:)?192\.168\.([0-9]{1,3})\.([0-9]{1,3})$/i.test(addr) ||
    /^(::f{4}:)?172\.(1[6-9]|2\d|30|31)\.([0-9]{1,3})\.([0-9]{1,3})$/i
      .test(addr) ||
    /^(::f{4}:)?127\.([0-9]{1,3})\.([0-9]{1,3})\.([0-9]{1,3})$/i.test(addr) ||
    /^(::f{4}:)?169\.254\.([0-9]{1,3})\.([0-9]{1,3})$/i.test(addr) ||
    /^f[cd][0-9a-f]{2}:/i.test(addr) ||
    /^fe80:/i.test(addr) ||
    /^::1$/.test(addr) ||
    /^::$/.test(addr);
};

ip.isPublic = function(addr) {
  return !ip.isPrivate(addr);
};

ip.isLoopback = function(addr) {
  return /^(::f{4}:)?127\.([0-9]{1,3})\.([0-9]{1,3})\.([0-9]{1,3})/
      .test(addr) ||
    /^fe80::1$/.test(addr) ||
    /^::1$/.test(addr) ||
    /^::$/.test(addr);
};

ip.loopback = function(family) {
  //
  // Default to `ipv4`
  //
  family = _normalizeFamily(family);

  if (family !== 'ipv4' && family !== 'ipv6') {
    throw new Error('family must be ipv4 or ipv6');
  }

  return family === 'ipv4' ? '127.0.0.1' : 'fe80::1';
};

//
// ### function address (name, family)
// #### @name {string|'public'|'private'} **Optional** Name or security
//      of the network interface.
// #### @family {ipv4|ipv6} **Optional** IP family of the address (defaults
//      to ipv4).
//
// Returns the address for the network interface on the current system with
// the specified `name`:
//   * String: First `family` address of the interface.
//             If not found see `undefined`.
//   * 'public': the first public ip address of family.
//   * 'private': the first private ip address of family.
//   * undefined: First address with `ipv4` or loopback address `127.0.0.1`.
//
ip.address = function(name, family) {
  var interfaces = os.networkInterfaces();
  var all;

  //
  // Default to `ipv4`
  //
  family = _normalizeFamily(family);

  //
  // If a specific network interface has been named,
  // return the address.
  //
  if (name && name !== 'private' && name !== 'public') {
    var res = interfaces[name].filter(function(details) {
      var itemFamily = details.family.toLowerCase();
      return itemFamily === family;
    });
    if (res.length === 0)
      return undefined;
    return res[0].address;
  }

  var all = Object.keys(interfaces).map(function (nic) {
    //
    // Note: name will only be `public` or `private`
    // when this is called.
    //
    var addresses = interfaces[nic].filter(function (details) {
      details.family = details.family.toLowerCase();
      if (details.family !== family || ip.isLoopback(details.address)) {
        return false;
      } else if (!name) {
        return true;
      }

      return name === 'public' ? ip.isPrivate(details.address) :
          ip.isPublic(details.address);
    });

    return addresses.length ? addresses[0].address : undefined;
  }).filter(Boolean);

  return !all.length ? ip.loopback(family) : all[0];
};

ip.toLong = function(ip) {
  var ipl = 0;
  ip.split('.').forEach(function(octet) {
    ipl <<= 8;
    ipl += parseInt(octet);
  });
  return(ipl >>> 0);
};

ip.fromLong = function(ipl) {
  return ((ipl >>> 24) + '.' +
      (ipl >> 16 & 255) + '.' +
      (ipl >> 8 & 255) + '.' +
      (ipl & 255) );
};

},{"buffer":9,"os":91}],63:[function(require,module,exports){
(function (Buffer){
'use strict';

var stream = require('stream');
var util = require('util');
var Transform = stream.Transform;

// expose to the world
module.exports = {
    encode: encode,
    decode: decode,
    wrap: wrap,
    Encoder: Encoder,
    Decoder: Decoder
};

/**
 * Encodes a Buffer into a base64 encoded string
 *
 * @param {Buffer} buffer Buffer to convert
 * @returns {String} base64 encoded string
 */
function encode(buffer) {
    if (typeof buffer === 'string') {
        buffer = new Buffer(buffer, 'utf-8');
    }

    return buffer.toString('base64');
}

/**
 * Decodes a base64 encoded string to a Buffer object
 *
 * @param {String} str base64 encoded string
 * @returns {Buffer} Decoded value
 */
function decode(str) {
    str = (str || '');
    return new Buffer(str, 'base64');
}

/**
 * Adds soft line breaks to a base64 string
 *
 * @param {String} str base64 encoded string that might need line wrapping
 * @param {Number} [lineLength=76] Maximum allowed length for a line
 * @returns {String} Soft-wrapped base64 encoded string
 */
function wrap(str, lineLength) {
    str = (str || '').toString();
    lineLength = lineLength || 76;

    if (str.length <= lineLength) {
        return str;
    }

    return str.replace(new RegExp('.{' + lineLength + '}', 'g'), '$&\r\n').trim();
}

/**
 * Creates a transform stream for encoding data to base64 encoding
 *
 * @constructor
 * @param {Object} options Stream options
 * @param {Number} [options.lineLength=76] Maximum lenght for lines, set to false to disable wrapping
 */
function Encoder(options) {
    // init Transform
    this.options = options || {};

    if (this.options.lineLength !== false) {
        this.options.lineLength = this.options.lineLength || 76;
    }

    this._curLine = '';
    this._remainingBytes = false;

    this.inputBytes = 0;
    this.outputBytes = 0;

    Transform.call(this, this.options);
}
util.inherits(Encoder, Transform);

Encoder.prototype._transform = function(chunk, encoding, done) {
    var b64, _self = this;

    if (encoding !== 'buffer') {
        chunk = new Buffer(chunk, encoding);
    }

    if (!chunk || !chunk.length) {
        return done();
    }

    this.inputBytes += chunk.length;

    if (this._remainingBytes && this._remainingBytes.length) {
        chunk = Buffer.concat([this._remainingBytes, chunk]);
        this._remainingBytes = false;
    }

    if (chunk.length % 3) {
        this._remainingBytes = chunk.slice(chunk.length - chunk.length % 3);
        chunk = chunk.slice(0, chunk.length - chunk.length % 3);
    } else {
        this._remainingBytes = false;
    }

    b64 = this._curLine + encode(chunk);

    if (this.options.lineLength) {
        b64 = wrap(b64, this.options.lineLength);
        b64 = b64.replace(/(^|\n)([^\n]*)$/, function(match, lineBreak, lastLine) {
            _self._curLine = lastLine;
            return lineBreak;
        });
    }

    if (b64) {
        this.outputBytes += b64.length;
        this.push(b64);
    }

    done();
};

Encoder.prototype._flush = function(done) {
    if (this._remainingBytes && this._remainingBytes.length) {
        this._curLine += encode(this._remainingBytes);
    }
    if (this._curLine) {
        this._curLine = wrap(this._curLine, this.options.lineLength);
        this.outputBytes += this._curLine.length;
        this.push(this._curLine, 'ascii');
        this._curLine = '';
    }
    done();
};

/**
 * Creates a transform stream for decoding base64 encoded strings
 *
 * @constructor
 * @param {Object} options Stream options
 */
function Decoder(options) {
    // init Transform
    this.options = options || {};
    this._curLine = '';

    this.inputBytes = 0;
    this.outputBytes = 0;

    Transform.call(this, this.options);
}
util.inherits(Decoder, Transform);

Decoder.prototype._transform = function(chunk, encoding, done) {
    var b64, buf;

    chunk = chunk.toString('ascii');

    if (!chunk || !chunk.length) {
        return done();
    }

    this.inputBytes += chunk.length;

    b64 = (this._curLine + chunk);
    this._curLine = '';

    b64 = b64.replace(/[^a-zA-Z0-9+\/=]/g, '');

    if (b64.length % 4) {
        this._curLine = b64.substr(-b64.length % 4);
        if (this._curLine.length == b64.length) {
            b64 = '';
        } else {
            b64 = b64.substr(0, this._curLine.length);
        }
    }

    if (b64) {
        buf = decode(b64);
        this.outputBytes += buf.length;
        this.push(buf);
    }

    done();
};

Decoder.prototype._flush = function(done) {
    var b64, buf;
    if (this._curLine) {
        buf = decode(this._curLine);
        this.outputBytes += buf.length;
        this.push(buf);
        this._curLine = '';
    }
    done();
};
}).call(this,require("buffer").Buffer)
},{"buffer":9,"stream":23,"util":104}],64:[function(require,module,exports){
(function (Buffer){
'use strict';

var iconv = require('iconv-lite');

/**
 * Character set encoding and decoding functions
 */
var charset = module.exports = {

    /**
     * Encodes an unicode string into an Buffer object as UTF-8
     *
     * We force UTF-8 here, no strange encodings allowed.
     *
     * @param {String} str String to be encoded
     * @return {Buffer} UTF-8 encoded typed array
     */
    encode: function (str) {
        return new Buffer(str, 'utf-8');
    },

    /**
     * Decodes a string from Buffer to an unicode string using specified encoding
     *
     * @param {Buffer} buf Binary data to be decoded
     * @param {String} [fromCharset='UTF-8'] Binary data is decoded into string using this charset
     * @return {String} Decded string
     */
    decode: function (buf, fromCharset) {
        fromCharset = charset.normalizeCharset(fromCharset || 'UTF-8');

        if (/^(us\-)?ascii|utf\-8|7bit$/i.test(fromCharset)) {
            return buf.toString('utf-8');
        }

        return iconv.decode(buf, fromCharset);
    },

    /**
     * Convert a string from specific encoding to UTF-8 Buffer
     *
     * @param {String|Buffer} str String to be encoded
     * @param {String} [fromCharset='UTF-8'] Source encoding for the string
     * @return {Buffer} UTF-8 encoded typed array
     */
    convert: function (data, fromCharset) {
        fromCharset = charset.normalizeCharset(fromCharset || 'UTF-8');

        var bufString;

        if (typeof data !== 'string') {
            if (/^(us\-)?ascii|utf\-8|7bit$/i.test(fromCharset)) {
                return data;
            }
            bufString = charset.decode(data, fromCharset);
            return charset.encode(bufString);
        }
        return charset.encode(data);
    },

    /**
     * Converts well known invalid character set names to proper names.
     * eg. win-1257 will be converted to WINDOWS-1257
     *
     * @param {String} charset Charset name to convert
     * @return {String} Canoninicalized charset name
     */
    normalizeCharset: function (charset) {
        var match;

        if ((match = charset.match(/^utf[\-_]?(\d+)$/i))) {
            return 'UTF-' + match[1];
        }

        if ((match = charset.match(/^win[\-_]?(\d+)$/i))) {
            return 'WINDOWS-' + match[1];
        }

        if ((match = charset.match(/^latin[\-_]?(\d+)$/i))) {
            return 'ISO-8859-' + match[1];
        }

        return charset;
    }
};

}).call(this,require("buffer").Buffer)
},{"buffer":9,"iconv-lite":61}],65:[function(require,module,exports){
(function (Buffer){
'use strict';

var libcharset = require('./charset');
var libbase64 = require('libbase64');
var libqp = require('libqp');
var mimetypes = require('./mimetypes');

var libmime = module.exports = {

    /**
     * Checks if a value is plaintext string (uses only printable 7bit chars)
     *
     * @param {String} value String to be tested
     * @returns {Boolean} true if it is a plaintext string
     */
    isPlainText: function (value) {
        if (typeof value !== 'string' || /[\x00-\x08\x0b\x0c\x0e-\x1f\u0080-\uFFFF]/.test(value)) {
            return false;
        } else {
            return true;
        }
    },

    /**
     * Checks if a multi line string containes lines longer than the selected value.
     *
     * Useful when detecting if a mail message needs any processing at all 
     * if only plaintext characters are used and lines are short, then there is
     * no need to encode the values in any way. If the value is plaintext but has
     * longer lines then allowed, then use format=flowed
     *
     * @param {Number} lineLength Max line length to check for
     * @returns {Boolean} Returns true if there is at least one line longer than lineLength chars
     */
    hasLongerLines: function (str, lineLength) {
        return new RegExp('^.{' + (lineLength + 1) + ',}', 'm').test(str);
    },

    /**
     * Decodes a string from a format=flowed soft wrapping.
     *
     * @param {String} str Plaintext string with format=flowed to decode
     * @param {Boolean} [delSp] If true, delete leading spaces (delsp=yes)
     * @return {String} Mime decoded string
     */
    decodeFlowed: function (str, delSp) {
        str = (str || '').toString();

        return str.
        split(/\r?\n/).
            // remove soft linebreaks
            // soft linebreaks are added after space symbols
        reduce(
                function (previousValue, currentValue, index) {
                    var body = previousValue;
                    if (delSp) {
                        // delsp adds spaces to text to be able to fold it
                        // these spaces can be removed once the text is unfolded
                        body = body.replace(/[ ]+$/, '');
                    }
                    if (/ $/.test(previousValue) && !/(^|\n)\-\- $/.test(previousValue) || index === 1) {
                        return body + currentValue;
                    } else {
                        return body + '\n' + currentValue;
                    }
                }
            ).
            // remove whitespace stuffing
            // http://tools.ietf.org/html/rfc3676#section-4.4
        replace(/^ /gm, '');
    },

    /**
     * Adds soft line breaks to content marked with format=flowed to
     * ensure that no line in the message is never longer than lineLength
     *
     * @param {String} str Plaintext string that requires wrapping
     * @param {Number} [lineLength=76] Maximum length of a line
     * @return {String} String with forced line breaks
     */
    encodeFlowed: function (str, lineLength) {
        lineLength = lineLength || 76;

        var flowed = [];
        str.split(/\r?\n/).forEach(function (line) {
            flowed.push(libmime.foldLines(line.
                // space stuffing http://tools.ietf.org/html/rfc3676#section-4.2
                replace(/^( |From|>)/igm, ' $1'),
                lineLength, true));
        });
        return flowed.join('\r\n');
    },

    /**
     * Encodes a string or an Buffer to an UTF-8 MIME Word (rfc2047)
     *
     * @param {String|Buffer} data String to be encoded
     * @param {String} mimeWordEncoding='Q' Encoding for the mime word, either Q or B
     * @param {Number} [maxLength=0] If set, split mime words into several chunks if needed
     * @return {String} Single or several mime words joined together
     */
    encodeWord: function (data, mimeWordEncoding, maxLength) {
        mimeWordEncoding = (mimeWordEncoding || 'Q').toString().toUpperCase().trim().charAt(0);
        maxLength = maxLength || 0;

        var encodedStr,
            toCharset = 'UTF-8',
            i, len, parts, lpart, chr;

        if (maxLength && maxLength > 7 + toCharset.length) {
            maxLength -= (7 + toCharset.length);
        }

        if (mimeWordEncoding === 'Q') {
            // https://tools.ietf.org/html/rfc2047#section-5 rule (3)
            encodedStr = libqp.encode(data).replace(/[^a-z0-9!*+\-\/=]/ig, function (chr) {
                var ord = chr.charCodeAt(0).toString(16).toUpperCase();
                if (chr === ' ') {
                    return '_';
                } else {
                    return '=' + (ord.length === 1 ? '0' + ord : ord);
                }
            });
        } else if (mimeWordEncoding === 'B') {
            encodedStr = typeof data === 'string' ? data : libbase64.encode(data);
            maxLength = maxLength ? Math.max(3, (maxLength - maxLength % 4) / 4 * 3) : 0;
        }

        if (maxLength && (mimeWordEncoding !== 'B' ? encodedStr : libbase64.encode(data)).length > maxLength) {
            if (mimeWordEncoding === 'Q') {
                encodedStr = splitMimeEncodedString(encodedStr, maxLength).join('?= =?' + toCharset + '?' + mimeWordEncoding + '?');
            } else {
                // RFC2047 6.3 (2) states that encoded-word must include an integral number of characters, so no chopping unicode sequences
                parts = [];
                lpart = '';
                for (i = 0, len = encodedStr.length; i < len; i++) {
                    chr = encodedStr.charAt(i);
                    // check if we can add this character to the existing string
                    // without breaking byte length limit
                    if (Buffer.byteLength(lpart + chr) <= maxLength || i === 0) {
                        lpart += chr;
                    } else {
                        // we hit the length limit, so push the existing string and start over
                        parts.push(libbase64.encode(lpart));
                        lpart = chr;
                    }
                }
                if (lpart) {
                    parts.push(libbase64.encode(lpart));
                }

                if (parts.length > 1) {
                    encodedStr = parts.join('?= =?' + toCharset + '?' + mimeWordEncoding + '?');
                } else {
                    encodedStr = parts.join('');
                }
            }
        } else if (mimeWordEncoding === 'B') {
            encodedStr = libbase64.encode(data);
        }

        return '=?' + toCharset + '?' + mimeWordEncoding + '?' + encodedStr + (encodedStr.substr(-2) === '?=' ? '' : '?=');
    },

    /**
     * Decode a complete mime word encoded string
     *
     * @param {String} str Mime word encoded string
     * @return {String} Decoded unicode string
     */
    decodeWord: function (str) {
        str = (str || '').toString().trim();

        var fromCharset, encoding, match;

        match = str.match(/^\=\?([\w_\-\*]+)\?([QqBb])\?([^\?]+)\?\=$/i);
        if (!match) {
            return str;
        }

        // RFC2231 added language tag to the encoding
        // see: https://tools.ietf.org/html/rfc2231#section-5
        // this implementation silently ignores this tag
        fromCharset = match[1].split('*').shift();

        encoding = (match[2] || 'Q').toString().toUpperCase();
        str = (match[3] || '').replace(/_/g, ' ').replace(/ $/, '=20');

        if (encoding === 'B') {
            return libcharset.decode(libbase64.decode(str), fromCharset);
        } else if (encoding === 'Q') {
            return libcharset.decode(libqp.decode(str), fromCharset);
        } else {
            return str;
        }
    },

    /**
     * Finds word sequences with non ascii text and converts these to mime words
     *
     * @param {String|Buffer} data String to be encoded
     * @param {String} mimeWordEncoding='Q' Encoding for the mime word, either Q or B
     * @param {Number} [maxLength=0] If set, split mime words into several chunks if needed
     * @param {String} [fromCharset='UTF-8'] Source sharacter set
     * @return {String} String with possible mime words
     */
    encodeWords: function (data, mimeWordEncoding, maxLength, fromCharset) {
        if (!fromCharset && typeof maxLength === 'string' && !maxLength.match(/^[0-9]+$/)) {
            fromCharset = maxLength;
            maxLength = undefined;
        }

        maxLength = maxLength || 0;

        var decodedValue = libcharset.decode(libcharset.convert((data || ''), fromCharset)),
            encodedValue;

        encodedValue = decodedValue.replace(/([^\s\u0080-\uFFFF]*[\u0080-\uFFFF]+[^\s\u0080-\uFFFF]*(?:\s+[^\s\u0080-\uFFFF]*[\u0080-\uFFFF]+[^\s\u0080-\uFFFF]*\s*)?)+(?=\s|$)/g, function (match) {
            return match.length ? libmime.encodeWord(match, mimeWordEncoding || 'Q', maxLength) : '';
        });

        return encodedValue;
    },

    /**
     * Decode a string that might include one or several mime words
     *
     * @param {String} str String including some mime words that will be encoded
     * @return {String} Decoded unicode string
     */
    decodeWords: function (str) {
        str = (str || '').toString();
        str = str.
        replace(/(=\?[^?]+\?[QqBb]\?[^?]+\?=)\s+(?==\?[^?]+\?[QqBb]\?[^?]+\?=)/g, '$1').
        replace(/\=\?([\w_\-\*]+)\?([QqBb])\?[^\?]+\?\=/g, function (mimeWord) {
            return libmime.decodeWord(mimeWord);
        });

        return str;
    },

    /**
     * Splits a string by :
     * The result is not mime word decoded, you need to do your own decoding based
     * on the rules for the specific header key
     *
     * @param {String} headerLine Single header line, might include linebreaks as well if folded
     * @return {Object} And object of {key, value}
     */
    decodeHeader: function (headerLine) {
        var line = (headerLine || '').toString().replace(/(?:\r?\n|\r)[ \t]*/g, ' ').trim(),
            match = line.match(/^\s*([^:]+):(.*)$/),
            key = (match && match[1] || '').trim().toLowerCase(),
            value = (match && match[2] || '').trim();

        return {
            key: key,
            value: value
        };
    },

    /**
     * Parses a block of header lines. Does not decode mime words as every
     * header might have its own rules (eg. formatted email addresses and such)
     *
     * @param {String} headers Headers string
     * @return {Object} An object of headers, where header keys are object keys. NB! Several values with the same key make up an Array
     */
    decodeHeaders: function (headers) {
        var lines = headers.split(/\r?\n|\r/),
            headersObj = {},
            header,
            i, len;

        for (i = lines.length - 1; i >= 0; i--) {
            if (i && lines[i].match(/^\s/)) {
                lines[i - 1] += '\r\n' + lines[i];
                lines.splice(i, 1);
            }
        }

        for (i = 0, len = lines.length; i < len; i++) {
            header = libmime.decodeHeader(lines[i]);
            if (!headersObj[header.key]) {
                headersObj[header.key] = [header.value];
            } else {
                headersObj[header.key].push(header.value);
            }
        }

        return headersObj;
    },

    /**
     * Joins parsed header value together as 'value; param1=value1; param2=value2'
     *
     * @param {Object} structured Parsed header value
     * @return {String} joined header value
     */
    buildHeaderValue: function (structured) {
        var paramsArray = [];

        Object.keys(structured.params || {}).forEach(function (param) {
            // filename might include unicode characters so it is a special case
            var value = structured.params[param];
            if (!libmime.isPlainText(value) || value.length >= 75) {
                libmime.buildHeaderParam(param, value, 50).forEach(function (encodedParam) {
                    if (!/[\s"\\;\/=]|^[\-']|'$/.test(encodedParam.value) || encodedParam.key.substr(-1) === '*') {
                        paramsArray.push(encodedParam.key + '=' + encodedParam.value);
                    } else {
                        paramsArray.push(encodedParam.key + '=' + JSON.stringify(encodedParam.value));
                    }
                });
            } else if (/[\s'"\\;\/=]|^\-/.test(value)) {
                paramsArray.push(param + '=' + JSON.stringify(value));
            } else {
                paramsArray.push(param + '=' + value);
            }
        }.bind(this));

        return structured.value + (paramsArray.length ? '; ' + paramsArray.join('; ') : '');
    },

    /**
     * Parses a header value with key=value arguments into a structured
     * object.
     *
     *   parseHeaderValue('content-type: text/plain; CHARSET='UTF-8'') ->
     *   {
     *     'value': 'text/plain',
     *     'params': {
     *       'charset': 'UTF-8'
     *     }
     *   }
     *
     * @param {String} str Header value
     * @return {Object} Header value as a parsed structure
     */
    parseHeaderValue: function (str) {
        var response = {
                value: false,
                params: {}
            },
            key = false,
            value = '',
            type = 'value',
            quote = false,
            escaped = false,
            chr;

        for (var i = 0, len = str.length; i < len; i++) {
            chr = str.charAt(i);
            if (type === 'key') {
                if (chr === '=') {
                    key = value.trim().toLowerCase();
                    type = 'value';
                    value = '';
                    continue;
                }
                value += chr;
            } else {
                if (escaped) {
                    value += chr;
                } else if (chr === '\\') {
                    escaped = true;
                    continue;
                } else if (quote && chr === quote) {
                    quote = false;
                } else if (!quote && chr === '"') {
                    quote = chr;
                } else if (!quote && chr === ';') {
                    if (key === false) {
                        response.value = value.trim();
                    } else {
                        response.params[key] = value.trim();
                    }
                    type = 'key';
                    value = '';
                } else {
                    value += chr;
                }
                escaped = false;

            }
        }

        if (type === 'value') {
            if (key === false) {
                response.value = value.trim();
            } else {
                response.params[key] = value.trim();
            }
        } else if (value.trim()) {
            response.params[value.trim().toLowerCase()] = '';
        }

        // handle parameter value continuations
        // https://tools.ietf.org/html/rfc2231#section-3

        // preprocess values
        Object.keys(response.params).forEach(function (key) {
            var actualKey, nr, match, value;
            if ((match = key.match(/(\*(\d+)|\*(\d+)\*|\*)$/))) {
                actualKey = key.substr(0, match.index);
                nr = Number(match[2] || match[3]) || 0;

                if (!response.params[actualKey] || typeof response.params[actualKey] !== 'object') {
                    response.params[actualKey] = {
                        charset: false,
                        values: []
                    };
                }

                value = response.params[key];

                if (nr === 0 && match[0].substr(-1) === '*' && (match = value.match(/^([^']*)'[^']*'(.*)$/))) {
                    response.params[actualKey].charset = match[1] || 'iso-8859-1';
                    value = match[2];
                }

                response.params[actualKey].values[nr] = value;

                // remove the old reference
                delete response.params[key];
            }
        });

        // concatenate split rfc2231 strings and convert encoded strings to mime encoded words
        Object.keys(response.params).forEach(function (key) {
            var value;
            if (response.params[key] && Array.isArray(response.params[key].values)) {
                value = response.params[key].values.map(function (val) {
                    return val || '';
                }).join('');

                if (response.params[key].charset) {
                    // convert "%AB" to "=?charset?Q?=AB?="
                    response.params[key] = '=?' +
                        response.params[key].charset +
                        '?Q?' +
                        value.
                        // fix invalidly encoded chars
                    replace(/[=\?_\s]/g,
                            function (s) {
                                var c = s.charCodeAt(0).toString(16);
                                if (s === ' ') {
                                    return '_';
                                } else {
                                    return '%' + (c.length < 2 ? '0' : '') + c;
                                }
                            }
                        ).
                        // change from urlencoding to percent encoding
                    replace(/%/g, '=') +
                        '?=';
                } else {
                    response.params[key] = value;
                }
            }
        }.bind(this));

        return response;
    },

    /**
     * Encodes a string or an Buffer to an UTF-8 Parameter Value Continuation encoding (rfc2231)
     * Useful for splitting long parameter values.
     *
     * For example
     *      title="unicode string"
     * becomes
     *     title*0*=utf-8''unicode
     *     title*1*=%20string
     *
     * @param {String|Buffer} data String to be encoded
     * @param {Number} [maxLength=50] Max length for generated chunks
     * @param {String} [fromCharset='UTF-8'] Source sharacter set
     * @return {Array} A list of encoded keys and headers
     */
    buildHeaderParam: function (key, data, maxLength, fromCharset) {
        var list = [];
        var encodedStr = typeof data === 'string' ? data : libmime.decode(data, fromCharset);
        var encodedStrArr;
        var chr, ord;
        var line;
        var startPos = 0;
        var isEncoded = false;
        var i, len;

        maxLength = maxLength || 50;

        // process ascii only text
        if (libmime.isPlainText(data)) {

            // check if conversion is even needed
            if (encodedStr.length <= maxLength) {
                return [{
                    key: key,
                    value: encodedStr
                }];
            }

            encodedStr = encodedStr.replace(new RegExp('.{' + maxLength + '}', 'g'), function (str) {
                list.push({
                    line: str
                });
                return '';
            });

            if (encodedStr) {
                list.push({
                    line: encodedStr
                });
            }

        } else {

            if (/[\uD800-\uDBFF]/.test(encodedStr)) {
                // string containts surrogate pairs, so normalize it to an array of bytes
                encodedStrArr = [];
                for (i = 0, len = encodedStr.length; i < len; i++) {
                    chr = encodedStr.charAt(i);
                    ord = chr.charCodeAt(0);
                    if (ord >= 0xD800 && ord <= 0xDBFF && i < len - 1) {
                        chr += encodedStr.charAt(i + 1);
                        encodedStrArr.push(chr);
                        i++;
                    } else {
                        encodedStrArr.push(chr);
                    }
                }
                encodedStr = encodedStrArr;
            }

            // first line includes the charset and language info and needs to be encoded
            // even if it does not contain any unicode characters
            line = 'utf-8\'\'';
            isEncoded = true;
            startPos = 0;

            // process text with unicode or special chars
            for (i = 0, len = encodedStr.length; i < len; i++) {

                chr = encodedStr[i];

                if (isEncoded) {
                    chr = safeEncodeURIComponent(chr);
                } else {
                    // try to urlencode current char
                    chr = chr === ' ' ? chr : safeEncodeURIComponent(chr);
                    // By default it is not required to encode a line, the need
                    // only appears when the string contains unicode or special chars
                    // in this case we start processing the line over and encode all chars
                    if (chr !== encodedStr[i]) {
                        // Check if it is even possible to add the encoded char to the line
                        // If not, there is no reason to use this line, just push it to the list
                        // and start a new line with the char that needs encoding
                        if ((safeEncodeURIComponent(line) + chr).length >= maxLength) {
                            list.push({
                                line: line,
                                encoded: isEncoded
                            });
                            line = '';
                            startPos = i - 1;
                        } else {
                            isEncoded = true;
                            i = startPos;
                            line = '';
                            continue;
                        }
                    }
                }

                // if the line is already too long, push it to the list and start a new one
                if ((line + chr).length >= maxLength) {
                    list.push({
                        line: line,
                        encoded: isEncoded
                    });
                    line = chr = encodedStr[i] === ' ' ? ' ' : safeEncodeURIComponent(encodedStr[i]);
                    if (chr === encodedStr[i]) {
                        isEncoded = false;
                        startPos = i - 1;
                    } else {
                        isEncoded = true;
                    }
                } else {
                    line += chr;
                }
            }

            if (line) {
                list.push({
                    line: line,
                    encoded: isEncoded
                });
            }
        }

        return list.map(function (item, i) {
            return {
                // encoded lines: {name}*{part}*
                // unencoded lines: {name}*{part}
                // if any line needs to be encoded then the first line (part==0) is always encoded
                key: key + '*' + i + (item.encoded ? '*' : ''),
                value: item.line
            };
        });
    },


    /**
     * Returns file extension for a content type string. If no suitable extensions
     * are found, 'bin' is used as the default extension
     *
     * @param {String} mimeType Content type to be checked for
     * @return {String} File extension
     */
    detectExtension: function (mimeType) {
        mimeType = (mimeType || '').toString().toLowerCase().replace(/\s/g, '');
        if (!(mimeType in mimetypes.list)) {
            return 'bin';
        }

        if (typeof mimetypes.list[mimeType] === 'string') {
            return mimetypes.list[mimeType];
        }

        var mimeParts = mimeType.split('/');

        // search for name match
        for (var i = 0, len = mimetypes.list[mimeType].length; i < len; i++) {
            if (mimeParts[1] === mimetypes.list[mimeType][i]) {
                return mimetypes.list[mimeType][i];
            }
        }

        // use the first one
        return mimetypes.list[mimeType][0] !== '*' ? mimetypes.list[mimeType][0] : 'bin';
    },

    /**
     * Returns content type for a file extension. If no suitable content types
     * are found, 'application/octet-stream' is used as the default content type
     *
     * @param {String} extension Extension to be checked for
     * @return {String} File extension
     */
    detectMimeType: function (extension) {
        extension = (extension || '').toString().toLowerCase().replace(/\s/g, '').replace(/^\./g, '').split('.').pop();

        if (!(extension in mimetypes.extensions)) {
            return 'application/octet-stream';
        }

        if (typeof mimetypes.extensions[extension] === 'string') {
            return mimetypes.extensions[extension];
        }

        var mimeParts;

        // search for name match
        for (var i = 0, len = mimetypes.extensions[extension].length; i < len; i++) {
            mimeParts = mimetypes.extensions[extension][i].split('/');
            if (mimeParts[1] === extension) {
                return mimetypes.extensions[extension][i];
            }
        }

        // use the first one
        return mimetypes.extensions[extension][0];
    },

    /**
     * Folds long lines, useful for folding header lines (afterSpace=false) and
     * flowed text (afterSpace=true)
     *
     * @param {String} str String to be folded
     * @param {Number} [lineLength=76] Maximum length of a line
     * @param {Boolean} afterSpace If true, leave a space in th end of a line
     * @return {String} String with folded lines
     */
    foldLines: function (str, lineLength, afterSpace) {
        str = (str || '').toString();
        lineLength = lineLength || 76;

        var pos = 0,
            len = str.length,
            result = '',
            line, match;

        while (pos < len) {
            line = str.substr(pos, lineLength);
            if (line.length < lineLength) {
                result += line;
                break;
            }
            if ((match = line.match(/^[^\n\r]*(\r?\n|\r)/))) {
                line = match[0];
                result += line;
                pos += line.length;
                continue;
            } else if ((match = line.match(/(\s+)[^\s]*$/)) && match[0].length - (afterSpace ? (match[1] || '').length : 0) < line.length) {
                line = line.substr(0, line.length - (match[0].length - (afterSpace ? (match[1] || '').length : 0)));
            } else if ((match = str.substr(pos + line.length).match(/^[^\s]+(\s*)/))) {
                line = line + match[0].substr(0, match[0].length - (!afterSpace ? (match[1] || '').length : 0));
            }

            result += line;
            pos += line.length;
            if (pos < len) {
                result += '\r\n';
            }
        }

        return result;
    }
};

/**
 * Splits a mime encoded string. Needed for dividing mime words into smaller chunks
 *
 * @param {String} str Mime encoded string to be split up
 * @param {Number} maxlen Maximum length of characters for one part (minimum 12)
 * @return {Array} Split string
 */
function splitMimeEncodedString(str, maxlen) {
    var curLine, match, chr, done,
        lines = [];

    // require at least 12 symbols to fit possible 4 octet UTF-8 sequences
    maxlen = Math.max(maxlen || 0, 12);

    while (str.length) {
        curLine = str.substr(0, maxlen);

        // move incomplete escaped char back to main
        if ((match = curLine.match(/\=[0-9A-F]?$/i))) {
            curLine = curLine.substr(0, match.index);
        }

        done = false;
        while (!done) {
            done = true;
            // check if not middle of a unicode char sequence
            if ((match = str.substr(curLine.length).match(/^\=([0-9A-F]{2})/i))) {
                chr = parseInt(match[1], 16);
                // invalid sequence, move one char back anc recheck
                if (chr < 0xC2 && chr > 0x7F) {
                    curLine = curLine.substr(0, curLine.length - 3);
                    done = false;
                }
            }
        }

        if (curLine.length) {
            lines.push(curLine);
        }
        str = str.substr(curLine.length);
    }

    return lines;
}

function encodeURICharComponent(chr) {
    var i, len, ord;
    var res = '';

    ord = chr.charCodeAt(0).toString(16).toUpperCase();
    if (ord.length % 2) {
        ord = '0' + ord;
    }
    if (ord.length > 2) {
        for (i = 0, len = ord.length / 2; i < len; i++) {
            res += '%' + ord.substr(i, 2);
        }
    } else {
        res += '%' + ord;
    }

    return res;
}

function safeEncodeURIComponent(str) {
    str = (str || '').toString();

    try {
        // might throw if we try to encode invalid sequences, eg. partial emoji
        str = encodeURIComponent(str);
    } catch (E) {
        // should never run
        return str.replace(/[^\x00-\x1F *'()<>@,;:\\"\[\]?=\u007F-\uFFFF]+/g, '');
    }

    // ensure chars that are not handled by encodeURICompent are converted as well
    return str.replace(/[\x00-\x1F *'()<>@,;:\\"\[\]?=\u007F-\uFFFF]/g, encodeURICharComponent);
}

}).call(this,require("buffer").Buffer)
},{"./charset":64,"./mimetypes":66,"buffer":9,"libbase64":63,"libqp":67}],66:[function(require,module,exports){
/* eslint quote-props: 0 */

'use strict';

module.exports = {
    list: {
        'application/acad': 'dwg',
        'application/applixware': 'aw',
        'application/arj': 'arj',
        'application/atom+xml': 'xml',
        'application/atomcat+xml': 'atomcat',
        'application/atomsvc+xml': 'atomsvc',
        'application/base64': ['mm', 'mme'],
        'application/binhex': 'hqx',
        'application/binhex4': 'hqx',
        'application/book': ['book', 'boo'],
        'application/ccxml+xml,': 'ccxml',
        'application/cdf': 'cdf',
        'application/cdmi-capability': 'cdmia',
        'application/cdmi-container': 'cdmic',
        'application/cdmi-domain': 'cdmid',
        'application/cdmi-object': 'cdmio',
        'application/cdmi-queue': 'cdmiq',
        'application/clariscad': 'ccad',
        'application/commonground': 'dp',
        'application/cu-seeme': 'cu',
        'application/davmount+xml': 'davmount',
        'application/drafting': 'drw',
        'application/dsptype': 'tsp',
        'application/dssc+der': 'dssc',
        'application/dssc+xml': 'xdssc',
        'application/dxf': 'dxf',
        'application/ecmascript': ['js', 'es'],
        'application/emma+xml': 'emma',
        'application/envoy': 'evy',
        'application/epub+zip': 'epub',
        'application/excel': ['xls', 'xl', 'xla', 'xlb', 'xlc', 'xld', 'xlk', 'xll', 'xlm', 'xlt', 'xlv', 'xlw'],
        'application/exi': 'exi',
        'application/font-tdpfr': 'pfr',
        'application/fractals': 'fif',
        'application/freeloader': 'frl',
        'application/futuresplash': 'spl',
        'application/gnutar': 'tgz',
        'application/groupwise': 'vew',
        'application/hlp': 'hlp',
        'application/hta': 'hta',
        'application/hyperstudio': 'stk',
        'application/i-deas': 'unv',
        'application/iges': ['iges', 'igs'],
        'application/inf': 'inf',
        'application/internet-property-stream': 'acx',
        'application/ipfix': 'ipfix',
        'application/java': 'class',
        'application/java-archive': 'jar',
        'application/java-byte-code': 'class',
        'application/java-serialized-object': 'ser',
        'application/java-vm': 'class',
        'application/javascript': 'js',
        'application/json': 'json',
        'application/lha': 'lha',
        'application/lzx': 'lzx',
        'application/mac-binary': 'bin',
        'application/mac-binhex': 'hqx',
        'application/mac-binhex40': 'hqx',
        'application/mac-compactpro': 'cpt',
        'application/macbinary': 'bin',
        'application/mads+xml': 'mads',
        'application/marc': 'mrc',
        'application/marcxml+xml': 'mrcx',
        'application/mathematica': 'ma',
        'application/mathml+xml': 'mathml',
        'application/mbedlet': 'mbd',
        'application/mbox': 'mbox',
        'application/mcad': 'mcd',
        'application/mediaservercontrol+xml': 'mscml',
        'application/metalink4+xml': 'meta4',
        'application/mets+xml': 'mets',
        'application/mime': 'aps',
        'application/mods+xml': 'mods',
        'application/mp21': 'm21',
        'application/mp4': 'mp4',
        'application/mspowerpoint': ['ppt', 'pot', 'pps', 'ppz'],
        'application/msword': ['doc', 'dot', 'w6w', 'wiz', 'word'],
        'application/mswrite': 'wri',
        'application/mxf': 'mxf',
        'application/netmc': 'mcp',
        'application/octet-stream': ['*'],
        'application/oda': 'oda',
        'application/oebps-package+xml': 'opf',
        'application/ogg': 'ogx',
        'application/olescript': 'axs',
        'application/onenote': 'onetoc',
        'application/patch-ops-error+xml': 'xer',
        'application/pdf': 'pdf',
        'application/pgp-encrypted': 'asc',
        'application/pgp-signature': 'pgp',
        'application/pics-rules': 'prf',
        'application/pkcs-12': 'p12',
        'application/pkcs-crl': 'crl',
        'application/pkcs10': 'p10',
        'application/pkcs7-mime': ['p7c', 'p7m'],
        'application/pkcs7-signature': 'p7s',
        'application/pkcs8': 'p8',
        'application/pkix-attr-cert': 'ac',
        'application/pkix-cert': ['cer', 'crt'],
        'application/pkix-crl': 'crl',
        'application/pkix-pkipath': 'pkipath',
        'application/pkixcmp': 'pki',
        'application/plain': 'text',
        'application/pls+xml': 'pls',
        'application/postscript': ['ps', 'ai', 'eps'],
        'application/powerpoint': 'ppt',
        'application/pro_eng': ['part', 'prt'],
        'application/prs.cww': 'cww',
        'application/pskc+xml': 'pskcxml',
        'application/rdf+xml': 'rdf',
        'application/reginfo+xml': 'rif',
        'application/relax-ng-compact-syntax': 'rnc',
        'application/resource-lists+xml': 'rl',
        'application/resource-lists-diff+xml': 'rld',
        'application/ringing-tones': 'rng',
        'application/rls-services+xml': 'rs',
        'application/rsd+xml': 'rsd',
        'application/rss+xml': 'xml',
        'application/rtf': ['rtf', 'rtx'],
        'application/sbml+xml': 'sbml',
        'application/scvp-cv-request': 'scq',
        'application/scvp-cv-response': 'scs',
        'application/scvp-vp-request': 'spq',
        'application/scvp-vp-response': 'spp',
        'application/sdp': 'sdp',
        'application/sea': 'sea',
        'application/set': 'set',
        'application/set-payment-initiation': 'setpay',
        'application/set-registration-initiation': 'setreg',
        'application/shf+xml': 'shf',
        'application/sla': 'stl',
        'application/smil': ['smi', 'smil'],
        'application/smil+xml': 'smi',
        'application/solids': 'sol',
        'application/sounder': 'sdr',
        'application/sparql-query': 'rq',
        'application/sparql-results+xml': 'srx',
        'application/srgs': 'gram',
        'application/srgs+xml': 'grxml',
        'application/sru+xml': 'sru',
        'application/ssml+xml': 'ssml',
        'application/step': ['step', 'stp'],
        'application/streamingmedia': 'ssm',
        'application/tei+xml': 'tei',
        'application/thraud+xml': 'tfi',
        'application/timestamped-data': 'tsd',
        'application/toolbook': 'tbk',
        'application/vda': 'vda',
        'application/vnd.3gpp.pic-bw-large': 'plb',
        'application/vnd.3gpp.pic-bw-small': 'psb',
        'application/vnd.3gpp.pic-bw-var': 'pvb',
        'application/vnd.3gpp2.tcap': 'tcap',
        'application/vnd.3m.post-it-notes': 'pwn',
        'application/vnd.accpac.simply.aso': 'aso',
        'application/vnd.accpac.simply.imp': 'imp',
        'application/vnd.acucobol': 'acu',
        'application/vnd.acucorp': 'atc',
        'application/vnd.adobe.air-application-installer-package+zip': 'air',
        'application/vnd.adobe.fxp': 'fxp',
        'application/vnd.adobe.xdp+xml': 'xdp',
        'application/vnd.adobe.xfdf': 'xfdf',
        'application/vnd.ahead.space': 'ahead',
        'application/vnd.airzip.filesecure.azf': 'azf',
        'application/vnd.airzip.filesecure.azs': 'azs',
        'application/vnd.amazon.ebook': 'azw',
        'application/vnd.americandynamics.acc': 'acc',
        'application/vnd.amiga.ami': 'ami',
        'application/vnd.android.package-archive': 'apk',
        'application/vnd.anser-web-certificate-issue-initiation': 'cii',
        'application/vnd.anser-web-funds-transfer-initiation': 'fti',
        'application/vnd.antix.game-component': 'atx',
        'application/vnd.apple.installer+xml': 'mpkg',
        'application/vnd.apple.mpegurl': 'm3u8',
        'application/vnd.aristanetworks.swi': 'swi',
        'application/vnd.audiograph': 'aep',
        'application/vnd.blueice.multipass': 'mpm',
        'application/vnd.bmi': 'bmi',
        'application/vnd.businessobjects': 'rep',
        'application/vnd.chemdraw+xml': 'cdxml',
        'application/vnd.chipnuts.karaoke-mmd': 'mmd',
        'application/vnd.cinderella': 'cdy',
        'application/vnd.claymore': 'cla',
        'application/vnd.cloanto.rp9': 'rp9',
        'application/vnd.clonk.c4group': 'c4g',
        'application/vnd.cluetrust.cartomobile-config': 'c11amc',
        'application/vnd.cluetrust.cartomobile-config-pkg': 'c11amz',
        'application/vnd.commonspace': 'csp',
        'application/vnd.contact.cmsg': 'cdbcmsg',
        'application/vnd.cosmocaller': 'cmc',
        'application/vnd.crick.clicker': 'clkx',
        'application/vnd.crick.clicker.keyboard': 'clkk',
        'application/vnd.crick.clicker.palette': 'clkp',
        'application/vnd.crick.clicker.template': 'clkt',
        'application/vnd.crick.clicker.wordbank': 'clkw',
        'application/vnd.criticaltools.wbs+xml': 'wbs',
        'application/vnd.ctc-posml': 'pml',
        'application/vnd.cups-ppd': 'ppd',
        'application/vnd.curl.car': 'car',
        'application/vnd.curl.pcurl': 'pcurl',
        'application/vnd.data-vision.rdz': 'rdz',
        'application/vnd.denovo.fcselayout-link': 'fe_launch',
        'application/vnd.dna': 'dna',
        'application/vnd.dolby.mlp': 'mlp',
        'application/vnd.dpgraph': 'dpg',
        'application/vnd.dreamfactory': 'dfac',
        'application/vnd.dvb.ait': 'ait',
        'application/vnd.dvb.service': 'svc',
        'application/vnd.dynageo': 'geo',
        'application/vnd.ecowin.chart': 'mag',
        'application/vnd.enliven': 'nml',
        'application/vnd.epson.esf': 'esf',
        'application/vnd.epson.msf': 'msf',
        'application/vnd.epson.quickanime': 'qam',
        'application/vnd.epson.salt': 'slt',
        'application/vnd.epson.ssf': 'ssf',
        'application/vnd.eszigno3+xml': 'es3',
        'application/vnd.ezpix-album': 'ez2',
        'application/vnd.ezpix-package': 'ez3',
        'application/vnd.fdf': 'fdf',
        'application/vnd.fdsn.seed': 'seed',
        'application/vnd.flographit': 'gph',
        'application/vnd.fluxtime.clip': 'ftc',
        'application/vnd.framemaker': 'fm',
        'application/vnd.frogans.fnc': 'fnc',
        'application/vnd.frogans.ltf': 'ltf',
        'application/vnd.fsc.weblaunch': 'fsc',
        'application/vnd.fujitsu.oasys': 'oas',
        'application/vnd.fujitsu.oasys2': 'oa2',
        'application/vnd.fujitsu.oasys3': 'oa3',
        'application/vnd.fujitsu.oasysgp': 'fg5',
        'application/vnd.fujitsu.oasysprs': 'bh2',
        'application/vnd.fujixerox.ddd': 'ddd',
        'application/vnd.fujixerox.docuworks': 'xdw',
        'application/vnd.fujixerox.docuworks.binder': 'xbd',
        'application/vnd.fuzzysheet': 'fzs',
        'application/vnd.genomatix.tuxedo': 'txd',
        'application/vnd.geogebra.file': 'ggb',
        'application/vnd.geogebra.tool': 'ggt',
        'application/vnd.geometry-explorer': 'gex',
        'application/vnd.geonext': 'gxt',
        'application/vnd.geoplan': 'g2w',
        'application/vnd.geospace': 'g3w',
        'application/vnd.gmx': 'gmx',
        'application/vnd.google-earth.kml+xml': 'kml',
        'application/vnd.google-earth.kmz': 'kmz',
        'application/vnd.grafeq': 'gqf',
        'application/vnd.groove-account': 'gac',
        'application/vnd.groove-help': 'ghf',
        'application/vnd.groove-identity-message': 'gim',
        'application/vnd.groove-injector': 'grv',
        'application/vnd.groove-tool-message': 'gtm',
        'application/vnd.groove-tool-template': 'tpl',
        'application/vnd.groove-vcard': 'vcg',
        'application/vnd.hal+xml': 'hal',
        'application/vnd.handheld-entertainment+xml': 'zmm',
        'application/vnd.hbci': 'hbci',
        'application/vnd.hhe.lesson-player': 'les',
        'application/vnd.hp-hpgl': ['hgl', 'hpg', 'hpgl'],
        'application/vnd.hp-hpid': 'hpid',
        'application/vnd.hp-hps': 'hps',
        'application/vnd.hp-jlyt': 'jlt',
        'application/vnd.hp-pcl': 'pcl',
        'application/vnd.hp-pclxl': 'pclxl',
        'application/vnd.hydrostatix.sof-data': 'sfd-hdstx',
        'application/vnd.hzn-3d-crossword': 'x3d',
        'application/vnd.ibm.minipay': 'mpy',
        'application/vnd.ibm.modcap': 'afp',
        'application/vnd.ibm.rights-management': 'irm',
        'application/vnd.ibm.secure-container': 'sc',
        'application/vnd.iccprofile': 'icc',
        'application/vnd.igloader': 'igl',
        'application/vnd.immervision-ivp': 'ivp',
        'application/vnd.immervision-ivu': 'ivu',
        'application/vnd.insors.igm': 'igm',
        'application/vnd.intercon.formnet': 'xpw',
        'application/vnd.intergeo': 'i2g',
        'application/vnd.intu.qbo': 'qbo',
        'application/vnd.intu.qfx': 'qfx',
        'application/vnd.ipunplugged.rcprofile': 'rcprofile',
        'application/vnd.irepository.package+xml': 'irp',
        'application/vnd.is-xpr': 'xpr',
        'application/vnd.isac.fcs': 'fcs',
        'application/vnd.jam': 'jam',
        'application/vnd.jcp.javame.midlet-rms': 'rms',
        'application/vnd.jisp': 'jisp',
        'application/vnd.joost.joda-archive': 'joda',
        'application/vnd.kahootz': 'ktz',
        'application/vnd.kde.karbon': 'karbon',
        'application/vnd.kde.kchart': 'chrt',
        'application/vnd.kde.kformula': 'kfo',
        'application/vnd.kde.kivio': 'flw',
        'application/vnd.kde.kontour': 'kon',
        'application/vnd.kde.kpresenter': 'kpr',
        'application/vnd.kde.kspread': 'ksp',
        'application/vnd.kde.kword': 'kwd',
        'application/vnd.kenameaapp': 'htke',
        'application/vnd.kidspiration': 'kia',
        'application/vnd.kinar': 'kne',
        'application/vnd.koan': 'skp',
        'application/vnd.kodak-descriptor': 'sse',
        'application/vnd.las.las+xml': 'lasxml',
        'application/vnd.llamagraphics.life-balance.desktop': 'lbd',
        'application/vnd.llamagraphics.life-balance.exchange+xml': 'lbe',
        'application/vnd.lotus-1-2-3': '123',
        'application/vnd.lotus-approach': 'apr',
        'application/vnd.lotus-freelance': 'pre',
        'application/vnd.lotus-notes': 'nsf',
        'application/vnd.lotus-organizer': 'org',
        'application/vnd.lotus-screencam': 'scm',
        'application/vnd.lotus-wordpro': 'lwp',
        'application/vnd.macports.portpkg': 'portpkg',
        'application/vnd.mcd': 'mcd',
        'application/vnd.medcalcdata': 'mc1',
        'application/vnd.mediastation.cdkey': 'cdkey',
        'application/vnd.mfer': 'mwf',
        'application/vnd.mfmp': 'mfm',
        'application/vnd.micrografx.flo': 'flo',
        'application/vnd.micrografx.igx': 'igx',
        'application/vnd.mif': 'mif',
        'application/vnd.mobius.daf': 'daf',
        'application/vnd.mobius.dis': 'dis',
        'application/vnd.mobius.mbk': 'mbk',
        'application/vnd.mobius.mqy': 'mqy',
        'application/vnd.mobius.msl': 'msl',
        'application/vnd.mobius.plc': 'plc',
        'application/vnd.mobius.txf': 'txf',
        'application/vnd.mophun.application': 'mpn',
        'application/vnd.mophun.certificate': 'mpc',
        'application/vnd.mozilla.xul+xml': 'xul',
        'application/vnd.ms-artgalry': 'cil',
        'application/vnd.ms-cab-compressed': 'cab',
        'application/vnd.ms-excel': ['xls', 'xla', 'xlc', 'xlm', 'xlt', 'xlw', 'xlb', 'xll'],
        'application/vnd.ms-excel.addin.macroenabled.12': 'xlam',
        'application/vnd.ms-excel.sheet.binary.macroenabled.12': 'xlsb',
        'application/vnd.ms-excel.sheet.macroenabled.12': 'xlsm',
        'application/vnd.ms-excel.template.macroenabled.12': 'xltm',
        'application/vnd.ms-fontobject': 'eot',
        'application/vnd.ms-htmlhelp': 'chm',
        'application/vnd.ms-ims': 'ims',
        'application/vnd.ms-lrm': 'lrm',
        'application/vnd.ms-officetheme': 'thmx',
        'application/vnd.ms-outlook': 'msg',
        'application/vnd.ms-pki.certstore': 'sst',
        'application/vnd.ms-pki.pko': 'pko',
        'application/vnd.ms-pki.seccat': 'cat',
        'application/vnd.ms-pki.stl': 'stl',
        'application/vnd.ms-pkicertstore': 'sst',
        'application/vnd.ms-pkiseccat': 'cat',
        'application/vnd.ms-pkistl': 'stl',
        'application/vnd.ms-powerpoint': ['ppt', 'pot', 'pps', 'ppa', 'pwz'],
        'application/vnd.ms-powerpoint.addin.macroenabled.12': 'ppam',
        'application/vnd.ms-powerpoint.presentation.macroenabled.12': 'pptm',
        'application/vnd.ms-powerpoint.slide.macroenabled.12': 'sldm',
        'application/vnd.ms-powerpoint.slideshow.macroenabled.12': 'ppsm',
        'application/vnd.ms-powerpoint.template.macroenabled.12': 'potm',
        'application/vnd.ms-project': 'mpp',
        'application/vnd.ms-word.document.macroenabled.12': 'docm',
        'application/vnd.ms-word.template.macroenabled.12': 'dotm',
        'application/vnd.ms-works': ['wks', 'wcm', 'wdb', 'wps'],
        'application/vnd.ms-wpl': 'wpl',
        'application/vnd.ms-xpsdocument': 'xps',
        'application/vnd.mseq': 'mseq',
        'application/vnd.musician': 'mus',
        'application/vnd.muvee.style': 'msty',
        'application/vnd.neurolanguage.nlu': 'nlu',
        'application/vnd.noblenet-directory': 'nnd',
        'application/vnd.noblenet-sealer': 'nns',
        'application/vnd.noblenet-web': 'nnw',
        'application/vnd.nokia.configuration-message': 'ncm',
        'application/vnd.nokia.n-gage.data': 'ngdat',
        'application/vnd.nokia.n-gage.symbian.install': 'n-gage',
        'application/vnd.nokia.radio-preset': 'rpst',
        'application/vnd.nokia.radio-presets': 'rpss',
        'application/vnd.nokia.ringing-tone': 'rng',
        'application/vnd.novadigm.edm': 'edm',
        'application/vnd.novadigm.edx': 'edx',
        'application/vnd.novadigm.ext': 'ext',
        'application/vnd.oasis.opendocument.chart': 'odc',
        'application/vnd.oasis.opendocument.chart-template': 'otc',
        'application/vnd.oasis.opendocument.database': 'odb',
        'application/vnd.oasis.opendocument.formula': 'odf',
        'application/vnd.oasis.opendocument.formula-template': 'odft',
        'application/vnd.oasis.opendocument.graphics': 'odg',
        'application/vnd.oasis.opendocument.graphics-template': 'otg',
        'application/vnd.oasis.opendocument.image': 'odi',
        'application/vnd.oasis.opendocument.image-template': 'oti',
        'application/vnd.oasis.opendocument.presentation': 'odp',
        'application/vnd.oasis.opendocument.presentation-template': 'otp',
        'application/vnd.oasis.opendocument.spreadsheet': 'ods',
        'application/vnd.oasis.opendocument.spreadsheet-template': 'ots',
        'application/vnd.oasis.opendocument.text': 'odt',
        'application/vnd.oasis.opendocument.text-master': 'odm',
        'application/vnd.oasis.opendocument.text-template': 'ott',
        'application/vnd.oasis.opendocument.text-web': 'oth',
        'application/vnd.olpc-sugar': 'xo',
        'application/vnd.oma.dd2+xml': 'dd2',
        'application/vnd.openofficeorg.extension': 'oxt',
        'application/vnd.openxmlformats-officedocument.presentationml.presentation': 'pptx',
        'application/vnd.openxmlformats-officedocument.presentationml.slide': 'sldx',
        'application/vnd.openxmlformats-officedocument.presentationml.slideshow': 'ppsx',
        'application/vnd.openxmlformats-officedocument.presentationml.template': 'potx',
        'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet': 'xlsx',
        'application/vnd.openxmlformats-officedocument.spreadsheetml.template': 'xltx',
        'application/vnd.openxmlformats-officedocument.wordprocessingml.document': 'docx',
        'application/vnd.openxmlformats-officedocument.wordprocessingml.template': 'dotx',
        'application/vnd.osgeo.mapguide.package': 'mgp',
        'application/vnd.osgi.dp': 'dp',
        'application/vnd.palm': 'pdb',
        'application/vnd.pawaafile': 'paw',
        'application/vnd.pg.format': 'str',
        'application/vnd.pg.osasli': 'ei6',
        'application/vnd.picsel': 'efif',
        'application/vnd.pmi.widget': 'wg',
        'application/vnd.pocketlearn': 'plf',
        'application/vnd.powerbuilder6': 'pbd',
        'application/vnd.previewsystems.box': 'box',
        'application/vnd.proteus.magazine': 'mgz',
        'application/vnd.publishare-delta-tree': 'qps',
        'application/vnd.pvi.ptid1': 'ptid',
        'application/vnd.quark.quarkxpress': 'qxd',
        'application/vnd.realvnc.bed': 'bed',
        'application/vnd.recordare.musicxml': 'mxl',
        'application/vnd.recordare.musicxml+xml': 'musicxml',
        'application/vnd.rig.cryptonote': 'cryptonote',
        'application/vnd.rim.cod': 'cod',
        'application/vnd.rn-realmedia': 'rm',
        'application/vnd.rn-realplayer': 'rnx',
        'application/vnd.route66.link66+xml': 'link66',
        'application/vnd.sailingtracker.track': 'st',
        'application/vnd.seemail': 'see',
        'application/vnd.sema': 'sema',
        'application/vnd.semd': 'semd',
        'application/vnd.semf': 'semf',
        'application/vnd.shana.informed.formdata': 'ifm',
        'application/vnd.shana.informed.formtemplate': 'itp',
        'application/vnd.shana.informed.interchange': 'iif',
        'application/vnd.shana.informed.package': 'ipk',
        'application/vnd.simtech-mindmapper': 'twd',
        'application/vnd.smaf': 'mmf',
        'application/vnd.smart.teacher': 'teacher',
        'application/vnd.solent.sdkm+xml': 'sdkm',
        'application/vnd.spotfire.dxp': 'dxp',
        'application/vnd.spotfire.sfs': 'sfs',
        'application/vnd.stardivision.calc': 'sdc',
        'application/vnd.stardivision.draw': 'sda',
        'application/vnd.stardivision.impress': 'sdd',
        'application/vnd.stardivision.math': 'smf',
        'application/vnd.stardivision.writer': 'sdw',
        'application/vnd.stardivision.writer-global': 'sgl',
        'application/vnd.stepmania.stepchart': 'sm',
        'application/vnd.sun.xml.calc': 'sxc',
        'application/vnd.sun.xml.calc.template': 'stc',
        'application/vnd.sun.xml.draw': 'sxd',
        'application/vnd.sun.xml.draw.template': 'std',
        'application/vnd.sun.xml.impress': 'sxi',
        'application/vnd.sun.xml.impress.template': 'sti',
        'application/vnd.sun.xml.math': 'sxm',
        'application/vnd.sun.xml.writer': 'sxw',
        'application/vnd.sun.xml.writer.global': 'sxg',
        'application/vnd.sun.xml.writer.template': 'stw',
        'application/vnd.sus-calendar': 'sus',
        'application/vnd.svd': 'svd',
        'application/vnd.symbian.install': 'sis',
        'application/vnd.syncml+xml': 'xsm',
        'application/vnd.syncml.dm+wbxml': 'bdm',
        'application/vnd.syncml.dm+xml': 'xdm',
        'application/vnd.tao.intent-module-archive': 'tao',
        'application/vnd.tmobile-livetv': 'tmo',
        'application/vnd.trid.tpt': 'tpt',
        'application/vnd.triscape.mxs': 'mxs',
        'application/vnd.trueapp': 'tra',
        'application/vnd.ufdl': 'ufd',
        'application/vnd.uiq.theme': 'utz',
        'application/vnd.umajin': 'umj',
        'application/vnd.unity': 'unityweb',
        'application/vnd.uoml+xml': 'uoml',
        'application/vnd.vcx': 'vcx',
        'application/vnd.visio': 'vsd',
        'application/vnd.visionary': 'vis',
        'application/vnd.vsf': 'vsf',
        'application/vnd.wap.wbxml': 'wbxml',
        'application/vnd.wap.wmlc': 'wmlc',
        'application/vnd.wap.wmlscriptc': 'wmlsc',
        'application/vnd.webturbo': 'wtb',
        'application/vnd.wolfram.player': 'nbp',
        'application/vnd.wordperfect': 'wpd',
        'application/vnd.wqd': 'wqd',
        'application/vnd.wt.stf': 'stf',
        'application/vnd.xara': ['web', 'xar'],
        'application/vnd.xfdl': 'xfdl',
        'application/vnd.yamaha.hv-dic': 'hvd',
        'application/vnd.yamaha.hv-script': 'hvs',
        'application/vnd.yamaha.hv-voice': 'hvp',
        'application/vnd.yamaha.openscoreformat': 'osf',
        'application/vnd.yamaha.openscoreformat.osfpvg+xml': 'osfpvg',
        'application/vnd.yamaha.smaf-audio': 'saf',
        'application/vnd.yamaha.smaf-phrase': 'spf',
        'application/vnd.yellowriver-custom-menu': 'cmp',
        'application/vnd.zul': 'zir',
        'application/vnd.zzazz.deck+xml': 'zaz',
        'application/vocaltec-media-desc': 'vmd',
        'application/vocaltec-media-file': 'vmf',
        'application/voicexml+xml': 'vxml',
        'application/widget': 'wgt',
        'application/winhlp': 'hlp',
        'application/wordperfect': ['wp', 'wp5', 'wp6', 'wpd'],
        'application/wordperfect6.0': ['w60', 'wp5'],
        'application/wordperfect6.1': 'w61',
        'application/wsdl+xml': 'wsdl',
        'application/wspolicy+xml': 'wspolicy',
        'application/x-123': 'wk1',
        'application/x-7z-compressed': '7z',
        'application/x-abiword': 'abw',
        'application/x-ace-compressed': 'ace',
        'application/x-aim': 'aim',
        'application/x-authorware-bin': 'aab',
        'application/x-authorware-map': 'aam',
        'application/x-authorware-seg': 'aas',
        'application/x-bcpio': 'bcpio',
        'application/x-binary': 'bin',
        'application/x-binhex40': 'hqx',
        'application/x-bittorrent': 'torrent',
        'application/x-bsh': ['bsh', 'sh', 'shar'],
        'application/x-bytecode.elisp': 'elc',
        'applicaiton/x-bytecode.python': 'pyc',
        'application/x-bzip': 'bz',
        'application/x-bzip2': ['boz', 'bz2'],
        'application/x-cdf': 'cdf',
        'application/x-cdlink': 'vcd',
        'application/x-chat': ['cha', 'chat'],
        'application/x-chess-pgn': 'pgn',
        'application/x-cmu-raster': 'ras',
        'application/x-cocoa': 'cco',
        'application/x-compactpro': 'cpt',
        'application/x-compress': 'z',
        'application/x-compressed': ['tgz', 'gz', 'z', 'zip'],
        'application/x-conference': 'nsc',
        'application/x-cpio': 'cpio',
        'application/x-cpt': 'cpt',
        'application/x-csh': 'csh',
        'application/x-debian-package': 'deb',
        'application/x-deepv': 'deepv',
        'application/x-director': ['dir', 'dcr', 'dxr'],
        'application/x-doom': 'wad',
        'application/x-dtbncx+xml': 'ncx',
        'application/x-dtbook+xml': 'dtb',
        'application/x-dtbresource+xml': 'res',
        'application/x-dvi': 'dvi',
        'application/x-elc': 'elc',
        'application/x-envoy': ['env', 'evy'],
        'application/x-esrehber': 'es',
        'application/x-excel': ['xls', 'xla', 'xlb', 'xlc', 'xld', 'xlk', 'xll', 'xlm', 'xlt', 'xlv', 'xlw'],
        'application/x-font-bdf': 'bdf',
        'application/x-font-ghostscript': 'gsf',
        'application/x-font-linux-psf': 'psf',
        'application/x-font-otf': 'otf',
        'application/x-font-pcf': 'pcf',
        'application/x-font-snf': 'snf',
        'application/x-font-ttf': 'ttf',
        'application/x-font-type1': 'pfa',
        'application/x-font-woff': 'woff',
        'application/x-frame': 'mif',
        'application/x-freelance': 'pre',
        'application/x-futuresplash': 'spl',
        'application/x-gnumeric': 'gnumeric',
        'application/x-gsp': 'gsp',
        'application/x-gss': 'gss',
        'application/x-gtar': 'gtar',
        'application/x-gzip': ['gz', 'gzip'],
        'application/x-hdf': 'hdf',
        'application/x-helpfile': ['help', 'hlp'],
        'application/x-httpd-imap': 'imap',
        'application/x-ima': 'ima',
        'application/x-internet-signup': ['ins', 'isp'],
        'application/x-internett-signup': 'ins',
        'application/x-inventor': 'iv',
        'application/x-ip2': 'ip',
        'application/x-iphone': 'iii',
        'application/x-java-class': 'class',
        'application/x-java-commerce': 'jcm',
        'application/x-java-jnlp-file': 'jnlp',
        'application/x-javascript': 'js',
        'application/x-koan': ['skd', 'skm', 'skp', 'skt'],
        'application/x-ksh': 'ksh',
        'application/x-latex': ['latex', 'ltx'],
        'application/x-lha': 'lha',
        'application/x-lisp': 'lsp',
        'application/x-livescreen': 'ivy',
        'application/x-lotus': 'wq1',
        'application/x-lotusscreencam': 'scm',
        'application/x-lzh': 'lzh',
        'application/x-lzx': 'lzx',
        'application/x-mac-binhex40': 'hqx',
        'application/x-macbinary': 'bin',
        'application/x-magic-cap-package-1.0': 'mc$',
        'application/x-mathcad': 'mcd',
        'application/x-meme': 'mm',
        'application/x-midi': ['mid', 'midi'],
        'application/x-mif': 'mif',
        'application/x-mix-transfer': 'nix',
        'application/x-mobipocket-ebook': 'prc',
        'application/x-mplayer2': 'asx',
        'application/x-ms-application': 'application',
        'application/x-ms-wmd': 'wmd',
        'application/x-ms-wmz': 'wmz',
        'application/x-ms-xbap': 'xbap',
        'application/x-msaccess': 'mdb',
        'application/x-msbinder': 'obd',
        'application/x-mscardfile': 'crd',
        'application/x-msclip': 'clp',
        'application/x-msdownload': ['exe', 'dll'],
        'application/x-msexcel': ['xls', 'xla', 'xlw'],
        'application/x-msmediaview': ['mvb', 'm13', 'm14'],
        'application/x-msmetafile': 'wmf',
        'application/x-msmoney': 'mny',
        'application/x-mspowerpoint': 'ppt',
        'application/x-mspublisher': 'pub',
        'application/x-msschedule': 'scd',
        'application/x-msterminal': 'trm',
        'application/x-mswrite': 'wri',
        'application/x-navi-animation': 'ani',
        'application/x-navidoc': 'nvd',
        'application/x-navimap': 'map',
        'application/x-navistyle': 'stl',
        'application/x-netcdf': ['cdf', 'nc'],
        'application/x-newton-compatible-pkg': 'pkg',
        'application/x-nokia-9000-communicator-add-on-software': 'aos',
        'application/x-omc': 'omc',
        'application/x-omcdatamaker': 'omcd',
        'application/x-omcregerator': 'omcr',
        'application/x-pagemaker': ['pm4', 'pm5'],
        'application/x-pcl': 'pcl',
        'application/x-perfmon': ['pma', 'pmc', 'pml', 'pmr', 'pmw'],
        'application/x-pixclscript': 'plx',
        'application/x-pkcs10': 'p10',
        'application/x-pkcs12': ['p12', 'pfx'],
        'application/x-pkcs7-certificates': ['p7b', 'spc'],
        'application/x-pkcs7-certreqresp': 'p7r',
        'application/x-pkcs7-mime': ['p7m', 'p7c'],
        'application/x-pkcs7-signature': ['p7s', 'p7a'],
        'application/x-pointplus': 'css',
        'application/x-portable-anymap': 'pnm',
        'application/x-project': ['mpc', 'mpt', 'mpv', 'mpx'],
        'application/x-qpro': 'wb1',
        'application/x-rar-compressed': 'rar',
        'application/x-rtf': 'rtf',
        'application/x-sdp': 'sdp',
        'application/x-sea': 'sea',
        'application/x-seelogo': 'sl',
        'application/x-sh': 'sh',
        'application/x-shar': ['shar', 'sh'],
        'application/x-shockwave-flash': 'swf',
        'application/x-silverlight-app': 'xap',
        'application/x-sit': 'sit',
        'application/x-sprite': ['spr', 'sprite'],
        'application/x-stuffit': 'sit',
        'application/x-stuffitx': 'sitx',
        'application/x-sv4cpio': 'sv4cpio',
        'application/x-sv4crc': 'sv4crc',
        'application/x-tar': 'tar',
        'application/x-tbook': ['sbk', 'tbk'],
        'application/x-tcl': 'tcl',
        'application/x-tex': 'tex',
        'application/x-tex-tfm': 'tfm',
        'application/x-texinfo': ['texi', 'texinfo'],
        'application/x-troff': ['roff', 't', 'tr'],
        'application/x-troff-man': 'man',
        'application/x-troff-me': 'me',
        'application/x-troff-ms': 'ms',
        'application/x-troff-msvideo': 'avi',
        'application/x-ustar': 'ustar',
        'application/x-visio': ['vsd', 'vst', 'vsw'],
        'application/x-vnd.audioexplosion.mzz': 'mzz',
        'application/x-vnd.ls-xpix': 'xpix',
        'application/x-vrml': 'vrml',
        'application/x-wais-source': ['src', 'wsrc'],
        'application/x-winhelp': 'hlp',
        'application/x-wintalk': 'wtk',
        'application/x-world': ['wrl', 'svr'],
        'application/x-wpwin': 'wpd',
        'application/x-wri': 'wri',
        'application/x-x509-ca-cert': ['cer', 'crt', 'der'],
        'application/x-x509-user-cert': 'crt',
        'application/x-xfig': 'fig',
        'application/x-xpinstall': 'xpi',
        'application/x-zip-compressed': 'zip',
        'application/xcap-diff+xml': 'xdf',
        'application/xenc+xml': 'xenc',
        'application/xhtml+xml': 'xhtml',
        'application/xml': 'xml',
        'application/xml-dtd': 'dtd',
        'application/xop+xml': 'xop',
        'application/xslt+xml': 'xslt',
        'application/xspf+xml': 'xspf',
        'application/xv+xml': 'mxml',
        'application/yang': 'yang',
        'application/yin+xml': 'yin',
        'application/ynd.ms-pkipko': 'pko',
        'application/zip': 'zip',
        'audio/adpcm': 'adp',
        'audio/aiff': ['aiff', 'aif', 'aifc'],
        'audio/basic': ['snd', 'au'],
        'audio/it': 'it',
        'audio/make': ['funk', 'my', 'pfunk'],
        'audio/make.my.funk': 'pfunk',
        'audio/mid': ['mid', 'rmi'],
        'audio/midi': ['midi', 'kar', 'mid'],
        'audio/mod': 'mod',
        'audio/mp4': 'mp4a',
        'audio/mpeg': ['mpga', 'mp3', 'm2a', 'mp2', 'mpa', 'mpg'],
        'audio/mpeg3': 'mp3',
        'audio/nspaudio': ['la', 'lma'],
        'audio/ogg': 'oga',
        'audio/s3m': 's3m',
        'audio/tsp-audio': 'tsi',
        'audio/tsplayer': 'tsp',
        'audio/vnd.dece.audio': 'uva',
        'audio/vnd.digital-winds': 'eol',
        'audio/vnd.dra': 'dra',
        'audio/vnd.dts': 'dts',
        'audio/vnd.dts.hd': 'dtshd',
        'audio/vnd.lucent.voice': 'lvp',
        'audio/vnd.ms-playready.media.pya': 'pya',
        'audio/vnd.nuera.ecelp4800': 'ecelp4800',
        'audio/vnd.nuera.ecelp7470': 'ecelp7470',
        'audio/vnd.nuera.ecelp9600': 'ecelp9600',
        'audio/vnd.qcelp': 'qcp',
        'audio/vnd.rip': 'rip',
        'audio/voc': 'voc',
        'audio/voxware': 'vox',
        'audio/wav': 'wav',
        'audio/webm': 'weba',
        'audio/x-aac': 'aac',
        'audio/x-adpcm': 'snd',
        'audio/x-aiff': ['aiff', 'aif', 'aifc'],
        'audio/x-au': 'au',
        'audio/x-gsm': ['gsd', 'gsm'],
        'audio/x-jam': 'jam',
        'audio/x-liveaudio': 'lam',
        'audio/x-mid': ['mid', 'midi'],
        'audio/x-midi': ['midi', 'mid'],
        'audio/x-mod': 'mod',
        'audio/x-mpeg': 'mp2',
        'audio/x-mpeg-3': 'mp3',
        'audio/x-mpegurl': 'm3u',
        'audio/x-mpequrl': 'm3u',
        'audio/x-ms-wax': 'wax',
        'audio/x-ms-wma': 'wma',
        'audio/x-nspaudio': ['la', 'lma'],
        'audio/x-pn-realaudio': ['ra', 'ram', 'rm', 'rmm', 'rmp'],
        'audio/x-pn-realaudio-plugin': ['ra', 'rmp', 'rpm'],
        'audio/x-psid': 'sid',
        'audio/x-realaudio': 'ra',
        'audio/x-twinvq': 'vqf',
        'audio/x-twinvq-plugin': ['vqe', 'vql'],
        'audio/x-vnd.audioexplosion.mjuicemediafile': 'mjf',
        'audio/x-voc': 'voc',
        'audio/x-wav': 'wav',
        'audio/xm': 'xm',
        'chemical/x-cdx': 'cdx',
        'chemical/x-cif': 'cif',
        'chemical/x-cmdf': 'cmdf',
        'chemical/x-cml': 'cml',
        'chemical/x-csml': 'csml',
        'chemical/x-pdb': ['pdb', 'xyz'],
        'chemical/x-xyz': 'xyz',
        'drawing/x-dwf': 'dwf',
        'i-world/i-vrml': 'ivr',
        'image/bmp': ['bmp', 'bm'],
        'image/cgm': 'cgm',
        'image/cis-cod': 'cod',
        'image/cmu-raster': ['ras', 'rast'],
        'image/fif': 'fif',
        'image/florian': ['flo', 'turbot'],
        'image/g3fax': 'g3',
        'image/gif': 'gif',
        'image/ief': ['ief', 'iefs'],
        'image/jpeg': ['jpeg', 'jpe', 'jpg', 'jfif', 'jfif-tbnl'],
        'image/jutvision': 'jut',
        'image/ktx': 'ktx',
        'image/naplps': ['nap', 'naplps'],
        'image/pict': ['pic', 'pict'],
        'image/pipeg': 'jfif',
        'image/pjpeg': ['jfif', 'jpe', 'jpeg', 'jpg'],
        'image/png': ['png', 'x-png'],
        'image/prs.btif': 'btif',
        'image/svg+xml': 'svg',
        'image/tiff': ['tif', 'tiff'],
        'image/vasa': 'mcf',
        'image/vnd.adobe.photoshop': 'psd',
        'image/vnd.dece.graphic': 'uvi',
        'image/vnd.djvu': 'djvu',
        'image/vnd.dvb.subtitle': 'sub',
        'image/vnd.dwg': ['dwg', 'dxf', 'svf'],
        'image/vnd.dxf': 'dxf',
        'image/vnd.fastbidsheet': 'fbs',
        'image/vnd.fpx': 'fpx',
        'image/vnd.fst': 'fst',
        'image/vnd.fujixerox.edmics-mmr': 'mmr',
        'image/vnd.fujixerox.edmics-rlc': 'rlc',
        'image/vnd.ms-modi': 'mdi',
        'image/vnd.net-fpx': ['fpx', 'npx'],
        'image/vnd.rn-realflash': 'rf',
        'image/vnd.rn-realpix': 'rp',
        'image/vnd.wap.wbmp': 'wbmp',
        'image/vnd.xiff': 'xif',
        'image/webp': 'webp',
        'image/x-cmu-raster': 'ras',
        'image/x-cmx': 'cmx',
        'image/x-dwg': ['dwg', 'dxf', 'svf'],
        'image/x-freehand': 'fh',
        'image/x-icon': 'ico',
        'image/x-jg': 'art',
        'image/x-jps': 'jps',
        'image/x-niff': ['niff', 'nif'],
        'image/x-pcx': 'pcx',
        'image/x-pict': ['pct', 'pic'],
        'image/x-portable-anymap': 'pnm',
        'image/x-portable-bitmap': 'pbm',
        'image/x-portable-graymap': 'pgm',
        'image/x-portable-greymap': 'pgm',
        'image/x-portable-pixmap': 'ppm',
        'image/x-quicktime': ['qif', 'qti', 'qtif'],
        'image/x-rgb': 'rgb',
        'image/x-tiff': ['tif', 'tiff'],
        'image/x-windows-bmp': 'bmp',
        'image/x-xbitmap': 'xbm',
        'image/x-xbm': 'xbm',
        'image/x-xpixmap': ['xpm', 'pm'],
        'image/x-xwd': 'xwd',
        'image/x-xwindowdump': 'xwd',
        'image/xbm': 'xbm',
        'image/xpm': 'xpm',
        'message/rfc822': ['eml', 'mht', 'mhtml', 'nws', 'mime'],
        'model/iges': ['iges', 'igs'],
        'model/mesh': 'msh',
        'model/vnd.collada+xml': 'dae',
        'model/vnd.dwf': 'dwf',
        'model/vnd.gdl': 'gdl',
        'model/vnd.gtw': 'gtw',
        'model/vnd.mts': 'mts',
        'model/vnd.vtu': 'vtu',
        'model/vrml': ['vrml', 'wrl', 'wrz'],
        'model/x-pov': 'pov',
        'multipart/x-gzip': 'gzip',
        'multipart/x-ustar': 'ustar',
        'multipart/x-zip': 'zip',
        'music/crescendo': ['mid', 'midi'],
        'music/x-karaoke': 'kar',
        'paleovu/x-pv': 'pvu',
        'text/asp': 'asp',
        'text/calendar': 'ics',
        'text/css': 'css',
        'text/csv': 'csv',
        'text/ecmascript': 'js',
        'text/h323': '323',
        'text/html': ['html', 'htm', 'stm', 'acgi', 'htmls', 'htx', 'shtml'],
        'text/iuls': 'uls',
        'text/javascript': 'js',
        'text/mcf': 'mcf',
        'text/n3': 'n3',
        'text/pascal': 'pas',
        'text/plain': ['txt', 'bas', 'c', 'h', 'c++', 'cc', 'com', 'conf', 'cxx', 'def', 'f', 'f90', 'for', 'g', 'hh', 'idc', 'jav', 'java', 'list', 'log', 'lst', 'm', 'mar', 'pl', 'sdml', 'text'],
        'text/plain-bas': 'par',
        'text/prs.lines.tag': 'dsc',
        'text/richtext': ['rtx', 'rt', 'rtf'],
        'text/scriplet': 'wsc',
        'text/scriptlet': 'sct',
        'text/sgml': ['sgm', 'sgml'],
        'text/tab-separated-values': 'tsv',
        'text/troff': 't',
        'text/turtle': 'ttl',
        'text/uri-list': ['uni', 'unis', 'uri', 'uris'],
        'text/vnd.abc': 'abc',
        'text/vnd.curl': 'curl',
        'text/vnd.curl.dcurl': 'dcurl',
        'text/vnd.curl.mcurl': 'mcurl',
        'text/vnd.curl.scurl': 'scurl',
        'text/vnd.fly': 'fly',
        'text/vnd.fmi.flexstor': 'flx',
        'text/vnd.graphviz': 'gv',
        'text/vnd.in3d.3dml': '3dml',
        'text/vnd.in3d.spot': 'spot',
        'text/vnd.rn-realtext': 'rt',
        'text/vnd.sun.j2me.app-descriptor': 'jad',
        'text/vnd.wap.wml': 'wml',
        'text/vnd.wap.wmlscript': 'wmls',
        'text/webviewhtml': 'htt',
        'text/x-asm': ['asm', 's'],
        'text/x-audiosoft-intra': 'aip',
        'text/x-c': ['c', 'cc', 'cpp'],
        'text/x-component': 'htc',
        'text/x-fortran': ['for', 'f', 'f77', 'f90'],
        'text/x-h': ['h', 'hh'],
        'text/x-java-source': ['java', 'jav'],
        'text/x-java-source,java': 'java',
        'text/x-la-asf': 'lsx',
        'text/x-m': 'm',
        'text/x-pascal': 'p',
        'text/x-script': 'hlb',
        'text/x-script.csh': 'csh',
        'text/x-script.elisp': 'el',
        'text/x-script.guile': 'scm',
        'text/x-script.ksh': 'ksh',
        'text/x-script.lisp': 'lsp',
        'text/x-script.perl': 'pl',
        'text/x-script.perl-module': 'pm',
        'text/x-script.phyton': 'py',
        'text/x-script.rexx': 'rexx',
        'text/x-script.scheme': 'scm',
        'text/x-script.sh': 'sh',
        'text/x-script.tcl': 'tcl',
        'text/x-script.tcsh': 'tcsh',
        'text/x-script.zsh': 'zsh',
        'text/x-server-parsed-html': ['shtml', 'ssi'],
        'text/x-setext': 'etx',
        'text/x-sgml': ['sgm', 'sgml'],
        'text/x-speech': ['spc', 'talk'],
        'text/x-uil': 'uil',
        'text/x-uuencode': ['uu', 'uue'],
        'text/x-vcalendar': 'vcs',
        'text/x-vcard': 'vcf',
        'text/xml': 'xml',
        'video/3gpp': '3gp',
        'video/3gpp2': '3g2',
        'video/animaflex': 'afl',
        'video/avi': 'avi',
        'video/avs-video': 'avs',
        'video/dl': 'dl',
        'video/fli': 'fli',
        'video/gl': 'gl',
        'video/h261': 'h261',
        'video/h263': 'h263',
        'video/h264': 'h264',
        'video/jpeg': 'jpgv',
        'video/jpm': 'jpm',
        'video/mj2': 'mj2',
        'video/mp4': 'mp4',
        'video/mpeg': ['mpeg', 'mp2', 'mpa', 'mpe', 'mpg', 'mpv2', 'm1v', 'm2v', 'mp3'],
        'video/msvideo': 'avi',
        'video/ogg': 'ogv',
        'video/quicktime': ['mov', 'qt', 'moov'],
        'video/vdo': 'vdo',
        'video/vivo': ['viv', 'vivo'],
        'video/vnd.dece.hd': 'uvh',
        'video/vnd.dece.mobile': 'uvm',
        'video/vnd.dece.pd': 'uvp',
        'video/vnd.dece.sd': 'uvs',
        'video/vnd.dece.video': 'uvv',
        'video/vnd.fvt': 'fvt',
        'video/vnd.mpegurl': 'mxu',
        'video/vnd.ms-playready.media.pyv': 'pyv',
        'video/vnd.rn-realvideo': 'rv',
        'video/vnd.uvvu.mp4': 'uvu',
        'video/vnd.vivo': ['viv', 'vivo'],
        'video/vosaic': 'vos',
        'video/webm': 'webm',
        'video/x-amt-demorun': 'xdr',
        'video/x-amt-showrun': 'xsr',
        'video/x-atomic3d-feature': 'fmf',
        'video/x-dl': 'dl',
        'video/x-dv': ['dif', 'dv'],
        'video/x-f4v': 'f4v',
        'video/x-fli': 'fli',
        'video/x-flv': 'flv',
        'video/x-gl': 'gl',
        'video/x-isvideo': 'isu',
        'video/x-la-asf': ['lsf', 'lsx'],
        'video/x-m4v': 'm4v',
        'video/x-motion-jpeg': 'mjpg',
        'video/x-mpeg': ['mp3', 'mp2'],
        'video/x-mpeq2a': 'mp2',
        'video/x-ms-asf': ['asf', 'asr', 'asx'],
        'video/x-ms-asf-plugin': 'asx',
        'video/x-ms-wm': 'wm',
        'video/x-ms-wmv': 'wmv',
        'video/x-ms-wmx': 'wmx',
        'video/x-ms-wvx': 'wvx',
        'video/x-msvideo': 'avi',
        'video/x-qtc': 'qtc',
        'video/x-scm': 'scm',
        'video/x-sgi-movie': ['movie', 'mv'],
        'windows/metafile': 'wmf',
        'www/mime': 'mime',
        'x-conference/x-cooltalk': 'ice',
        'x-music/x-midi': ['mid', 'midi'],
        'x-world/x-3dmf': ['3dm', '3dmf', 'qd3', 'qd3d'],
        'x-world/x-svr': 'svr',
        'x-world/x-vrml': ['flr', 'vrml', 'wrl', 'wrz', 'xaf', 'xof'],
        'x-world/x-vrt': 'vrt',
        'xgl/drawing': 'xgz',
        'xgl/movie': 'xmz'
    },

    extensions: {
        '*': 'application/octet-stream',
        '123': 'application/vnd.lotus-1-2-3',
        '323': 'text/h323',
        '3dm': 'x-world/x-3dmf',
        '3dmf': 'x-world/x-3dmf',
        '3dml': 'text/vnd.in3d.3dml',
        '3g2': 'video/3gpp2',
        '3gp': 'video/3gpp',
        '7z': 'application/x-7z-compressed',
        'a': 'application/octet-stream',
        'aab': 'application/x-authorware-bin',
        'aac': 'audio/x-aac',
        'aam': 'application/x-authorware-map',
        'aas': 'application/x-authorware-seg',
        'abc': 'text/vnd.abc',
        'abw': 'application/x-abiword',
        'ac': 'application/pkix-attr-cert',
        'acc': 'application/vnd.americandynamics.acc',
        'ace': 'application/x-ace-compressed',
        'acgi': 'text/html',
        'acu': 'application/vnd.acucobol',
        'acx': 'application/internet-property-stream',
        'adp': 'audio/adpcm',
        'aep': 'application/vnd.audiograph',
        'afl': 'video/animaflex',
        'afp': 'application/vnd.ibm.modcap',
        'ahead': 'application/vnd.ahead.space',
        'ai': 'application/postscript',
        'aif': ['audio/aiff', 'audio/x-aiff'],
        'aifc': ['audio/aiff', 'audio/x-aiff'],
        'aiff': ['audio/aiff', 'audio/x-aiff'],
        'aim': 'application/x-aim',
        'aip': 'text/x-audiosoft-intra',
        'air': 'application/vnd.adobe.air-application-installer-package+zip',
        'ait': 'application/vnd.dvb.ait',
        'ami': 'application/vnd.amiga.ami',
        'ani': 'application/x-navi-animation',
        'aos': 'application/x-nokia-9000-communicator-add-on-software',
        'apk': 'application/vnd.android.package-archive',
        'application': 'application/x-ms-application',
        'apr': 'application/vnd.lotus-approach',
        'aps': 'application/mime',
        'arc': 'application/octet-stream',
        'arj': ['application/arj', 'application/octet-stream'],
        'art': 'image/x-jg',
        'asf': 'video/x-ms-asf',
        'asm': 'text/x-asm',
        'aso': 'application/vnd.accpac.simply.aso',
        'asp': 'text/asp',
        'asr': 'video/x-ms-asf',
        'asx': ['video/x-ms-asf', 'application/x-mplayer2', 'video/x-ms-asf-plugin'],
        'atc': 'application/vnd.acucorp',
        'atomcat': 'application/atomcat+xml',
        'atomsvc': 'application/atomsvc+xml',
        'atx': 'application/vnd.antix.game-component',
        'au': ['audio/basic', 'audio/x-au'],
        'avi': ['video/avi', 'video/msvideo', 'application/x-troff-msvideo', 'video/x-msvideo'],
        'avs': 'video/avs-video',
        'aw': 'application/applixware',
        'axs': 'application/olescript',
        'azf': 'application/vnd.airzip.filesecure.azf',
        'azs': 'application/vnd.airzip.filesecure.azs',
        'azw': 'application/vnd.amazon.ebook',
        'bas': 'text/plain',
        'bcpio': 'application/x-bcpio',
        'bdf': 'application/x-font-bdf',
        'bdm': 'application/vnd.syncml.dm+wbxml',
        'bed': 'application/vnd.realvnc.bed',
        'bh2': 'application/vnd.fujitsu.oasysprs',
        'bin': ['application/octet-stream', 'application/mac-binary', 'application/macbinary', 'application/x-macbinary', 'application/x-binary'],
        'bm': 'image/bmp',
        'bmi': 'application/vnd.bmi',
        'bmp': ['image/bmp', 'image/x-windows-bmp'],
        'boo': 'application/book',
        'book': 'application/book',
        'box': 'application/vnd.previewsystems.box',
        'boz': 'application/x-bzip2',
        'bsh': 'application/x-bsh',
        'btif': 'image/prs.btif',
        'bz': 'application/x-bzip',
        'bz2': 'application/x-bzip2',
        'c': ['text/plain', 'text/x-c'],
        'c++': 'text/plain',
        'c11amc': 'application/vnd.cluetrust.cartomobile-config',
        'c11amz': 'application/vnd.cluetrust.cartomobile-config-pkg',
        'c4g': 'application/vnd.clonk.c4group',
        'cab': 'application/vnd.ms-cab-compressed',
        'car': 'application/vnd.curl.car',
        'cat': ['application/vnd.ms-pkiseccat', 'application/vnd.ms-pki.seccat'],
        'cc': ['text/plain', 'text/x-c'],
        'ccad': 'application/clariscad',
        'cco': 'application/x-cocoa',
        'ccxml': 'application/ccxml+xml,',
        'cdbcmsg': 'application/vnd.contact.cmsg',
        'cdf': ['application/cdf', 'application/x-cdf', 'application/x-netcdf'],
        'cdkey': 'application/vnd.mediastation.cdkey',
        'cdmia': 'application/cdmi-capability',
        'cdmic': 'application/cdmi-container',
        'cdmid': 'application/cdmi-domain',
        'cdmio': 'application/cdmi-object',
        'cdmiq': 'application/cdmi-queue',
        'cdx': 'chemical/x-cdx',
        'cdxml': 'application/vnd.chemdraw+xml',
        'cdy': 'application/vnd.cinderella',
        'cer': ['application/pkix-cert', 'application/x-x509-ca-cert'],
        'cgm': 'image/cgm',
        'cha': 'application/x-chat',
        'chat': 'application/x-chat',
        'chm': 'application/vnd.ms-htmlhelp',
        'chrt': 'application/vnd.kde.kchart',
        'cif': 'chemical/x-cif',
        'cii': 'application/vnd.anser-web-certificate-issue-initiation',
        'cil': 'application/vnd.ms-artgalry',
        'cla': 'application/vnd.claymore',
        'class': ['application/octet-stream', 'application/java', 'application/java-byte-code', 'application/java-vm', 'application/x-java-class'],
        'clkk': 'application/vnd.crick.clicker.keyboard',
        'clkp': 'application/vnd.crick.clicker.palette',
        'clkt': 'application/vnd.crick.clicker.template',
        'clkw': 'application/vnd.crick.clicker.wordbank',
        'clkx': 'application/vnd.crick.clicker',
        'clp': 'application/x-msclip',
        'cmc': 'application/vnd.cosmocaller',
        'cmdf': 'chemical/x-cmdf',
        'cml': 'chemical/x-cml',
        'cmp': 'application/vnd.yellowriver-custom-menu',
        'cmx': 'image/x-cmx',
        'cod': ['image/cis-cod', 'application/vnd.rim.cod'],
        'com': ['application/octet-stream', 'text/plain'],
        'conf': 'text/plain',
        'cpio': 'application/x-cpio',
        'cpp': 'text/x-c',
        'cpt': ['application/mac-compactpro', 'application/x-compactpro', 'application/x-cpt'],
        'crd': 'application/x-mscardfile',
        'crl': ['application/pkix-crl', 'application/pkcs-crl'],
        'crt': ['application/pkix-cert', 'application/x-x509-user-cert', 'application/x-x509-ca-cert'],
        'cryptonote': 'application/vnd.rig.cryptonote',
        'csh': ['text/x-script.csh', 'application/x-csh'],
        'csml': 'chemical/x-csml',
        'csp': 'application/vnd.commonspace',
        'css': ['text/css', 'application/x-pointplus'],
        'csv': 'text/csv',
        'cu': 'application/cu-seeme',
        'curl': 'text/vnd.curl',
        'cww': 'application/prs.cww',
        'cxx': 'text/plain',
        'dae': 'model/vnd.collada+xml',
        'daf': 'application/vnd.mobius.daf',
        'davmount': 'application/davmount+xml',
        'dcr': 'application/x-director',
        'dcurl': 'text/vnd.curl.dcurl',
        'dd2': 'application/vnd.oma.dd2+xml',
        'ddd': 'application/vnd.fujixerox.ddd',
        'deb': 'application/x-debian-package',
        'deepv': 'application/x-deepv',
        'def': 'text/plain',
        'der': 'application/x-x509-ca-cert',
        'dfac': 'application/vnd.dreamfactory',
        'dif': 'video/x-dv',
        'dir': 'application/x-director',
        'dis': 'application/vnd.mobius.dis',
        'djvu': 'image/vnd.djvu',
        'dl': ['video/dl', 'video/x-dl'],
        'dll': 'application/x-msdownload',
        'dms': 'application/octet-stream',
        'dna': 'application/vnd.dna',
        'doc': 'application/msword',
        'docm': 'application/vnd.ms-word.document.macroenabled.12',
        'docx': 'application/vnd.openxmlformats-officedocument.wordprocessingml.document',
        'dot': 'application/msword',
        'dotm': 'application/vnd.ms-word.template.macroenabled.12',
        'dotx': 'application/vnd.openxmlformats-officedocument.wordprocessingml.template',
        'dp': ['application/commonground', 'application/vnd.osgi.dp'],
        'dpg': 'application/vnd.dpgraph',
        'dra': 'audio/vnd.dra',
        'drw': 'application/drafting',
        'dsc': 'text/prs.lines.tag',
        'dssc': 'application/dssc+der',
        'dtb': 'application/x-dtbook+xml',
        'dtd': 'application/xml-dtd',
        'dts': 'audio/vnd.dts',
        'dtshd': 'audio/vnd.dts.hd',
        'dump': 'application/octet-stream',
        'dv': 'video/x-dv',
        'dvi': 'application/x-dvi',
        'dwf': ['model/vnd.dwf', 'drawing/x-dwf'],
        'dwg': ['application/acad', 'image/vnd.dwg', 'image/x-dwg'],
        'dxf': ['application/dxf', 'image/vnd.dwg', 'image/vnd.dxf', 'image/x-dwg'],
        'dxp': 'application/vnd.spotfire.dxp',
        'dxr': 'application/x-director',
        'ecelp4800': 'audio/vnd.nuera.ecelp4800',
        'ecelp7470': 'audio/vnd.nuera.ecelp7470',
        'ecelp9600': 'audio/vnd.nuera.ecelp9600',
        'edm': 'application/vnd.novadigm.edm',
        'edx': 'application/vnd.novadigm.edx',
        'efif': 'application/vnd.picsel',
        'ei6': 'application/vnd.pg.osasli',
        'el': 'text/x-script.elisp',
        'elc': ['application/x-elc', 'application/x-bytecode.elisp'],
        'eml': 'message/rfc822',
        'emma': 'application/emma+xml',
        'env': 'application/x-envoy',
        'eol': 'audio/vnd.digital-winds',
        'eot': 'application/vnd.ms-fontobject',
        'eps': 'application/postscript',
        'epub': 'application/epub+zip',
        'es': ['application/ecmascript', 'application/x-esrehber'],
        'es3': 'application/vnd.eszigno3+xml',
        'esf': 'application/vnd.epson.esf',
        'etx': 'text/x-setext',
        'evy': ['application/envoy', 'application/x-envoy'],
        'exe': ['application/octet-stream', 'application/x-msdownload'],
        'exi': 'application/exi',
        'ext': 'application/vnd.novadigm.ext',
        'ez2': 'application/vnd.ezpix-album',
        'ez3': 'application/vnd.ezpix-package',
        'f': ['text/plain', 'text/x-fortran'],
        'f4v': 'video/x-f4v',
        'f77': 'text/x-fortran',
        'f90': ['text/plain', 'text/x-fortran'],
        'fbs': 'image/vnd.fastbidsheet',
        'fcs': 'application/vnd.isac.fcs',
        'fdf': 'application/vnd.fdf',
        'fe_launch': 'application/vnd.denovo.fcselayout-link',
        'fg5': 'application/vnd.fujitsu.oasysgp',
        'fh': 'image/x-freehand',
        'fif': ['application/fractals', 'image/fif'],
        'fig': 'application/x-xfig',
        'fli': ['video/fli', 'video/x-fli'],
        'flo': ['image/florian', 'application/vnd.micrografx.flo'],
        'flr': 'x-world/x-vrml',
        'flv': 'video/x-flv',
        'flw': 'application/vnd.kde.kivio',
        'flx': 'text/vnd.fmi.flexstor',
        'fly': 'text/vnd.fly',
        'fm': 'application/vnd.framemaker',
        'fmf': 'video/x-atomic3d-feature',
        'fnc': 'application/vnd.frogans.fnc',
        'for': ['text/plain', 'text/x-fortran'],
        'fpx': ['image/vnd.fpx', 'image/vnd.net-fpx'],
        'frl': 'application/freeloader',
        'fsc': 'application/vnd.fsc.weblaunch',
        'fst': 'image/vnd.fst',
        'ftc': 'application/vnd.fluxtime.clip',
        'fti': 'application/vnd.anser-web-funds-transfer-initiation',
        'funk': 'audio/make',
        'fvt': 'video/vnd.fvt',
        'fxp': 'application/vnd.adobe.fxp',
        'fzs': 'application/vnd.fuzzysheet',
        'g': 'text/plain',
        'g2w': 'application/vnd.geoplan',
        'g3': 'image/g3fax',
        'g3w': 'application/vnd.geospace',
        'gac': 'application/vnd.groove-account',
        'gdl': 'model/vnd.gdl',
        'geo': 'application/vnd.dynageo',
        'gex': 'application/vnd.geometry-explorer',
        'ggb': 'application/vnd.geogebra.file',
        'ggt': 'application/vnd.geogebra.tool',
        'ghf': 'application/vnd.groove-help',
        'gif': 'image/gif',
        'gim': 'application/vnd.groove-identity-message',
        'gl': ['video/gl', 'video/x-gl'],
        'gmx': 'application/vnd.gmx',
        'gnumeric': 'application/x-gnumeric',
        'gph': 'application/vnd.flographit',
        'gqf': 'application/vnd.grafeq',
        'gram': 'application/srgs',
        'grv': 'application/vnd.groove-injector',
        'grxml': 'application/srgs+xml',
        'gsd': 'audio/x-gsm',
        'gsf': 'application/x-font-ghostscript',
        'gsm': 'audio/x-gsm',
        'gsp': 'application/x-gsp',
        'gss': 'application/x-gss',
        'gtar': 'application/x-gtar',
        'gtm': 'application/vnd.groove-tool-message',
        'gtw': 'model/vnd.gtw',
        'gv': 'text/vnd.graphviz',
        'gxt': 'application/vnd.geonext',
        'gz': ['application/x-gzip', 'application/x-compressed'],
        'gzip': ['multipart/x-gzip', 'application/x-gzip'],
        'h': ['text/plain', 'text/x-h'],
        'h261': 'video/h261',
        'h263': 'video/h263',
        'h264': 'video/h264',
        'hal': 'application/vnd.hal+xml',
        'hbci': 'application/vnd.hbci',
        'hdf': 'application/x-hdf',
        'help': 'application/x-helpfile',
        'hgl': 'application/vnd.hp-hpgl',
        'hh': ['text/plain', 'text/x-h'],
        'hlb': 'text/x-script',
        'hlp': ['application/winhlp', 'application/hlp', 'application/x-helpfile', 'application/x-winhelp'],
        'hpg': 'application/vnd.hp-hpgl',
        'hpgl': 'application/vnd.hp-hpgl',
        'hpid': 'application/vnd.hp-hpid',
        'hps': 'application/vnd.hp-hps',
        'hqx': ['application/mac-binhex40', 'application/binhex', 'application/binhex4', 'application/mac-binhex', 'application/x-binhex40', 'application/x-mac-binhex40'],
        'hta': 'application/hta',
        'htc': 'text/x-component',
        'htke': 'application/vnd.kenameaapp',
        'htm': 'text/html',
        'html': 'text/html',
        'htmls': 'text/html',
        'htt': 'text/webviewhtml',
        'htx': 'text/html',
        'hvd': 'application/vnd.yamaha.hv-dic',
        'hvp': 'application/vnd.yamaha.hv-voice',
        'hvs': 'application/vnd.yamaha.hv-script',
        'i2g': 'application/vnd.intergeo',
        'icc': 'application/vnd.iccprofile',
        'ice': 'x-conference/x-cooltalk',
        'ico': 'image/x-icon',
        'ics': 'text/calendar',
        'idc': 'text/plain',
        'ief': 'image/ief',
        'iefs': 'image/ief',
        'ifm': 'application/vnd.shana.informed.formdata',
        'iges': ['application/iges', 'model/iges'],
        'igl': 'application/vnd.igloader',
        'igm': 'application/vnd.insors.igm',
        'igs': ['application/iges', 'model/iges'],
        'igx': 'application/vnd.micrografx.igx',
        'iif': 'application/vnd.shana.informed.interchange',
        'iii': 'application/x-iphone',
        'ima': 'application/x-ima',
        'imap': 'application/x-httpd-imap',
        'imp': 'application/vnd.accpac.simply.imp',
        'ims': 'application/vnd.ms-ims',
        'inf': 'application/inf',
        'ins': ['application/x-internet-signup', 'application/x-internett-signup'],
        'ip': 'application/x-ip2',
        'ipfix': 'application/ipfix',
        'ipk': 'application/vnd.shana.informed.package',
        'irm': 'application/vnd.ibm.rights-management',
        'irp': 'application/vnd.irepository.package+xml',
        'isp': 'application/x-internet-signup',
        'isu': 'video/x-isvideo',
        'it': 'audio/it',
        'itp': 'application/vnd.shana.informed.formtemplate',
        'iv': 'application/x-inventor',
        'ivp': 'application/vnd.immervision-ivp',
        'ivr': 'i-world/i-vrml',
        'ivu': 'application/vnd.immervision-ivu',
        'ivy': 'application/x-livescreen',
        'jad': 'text/vnd.sun.j2me.app-descriptor',
        'jam': ['application/vnd.jam', 'audio/x-jam'],
        'jar': 'application/java-archive',
        'jav': ['text/plain', 'text/x-java-source'],
        'java': ['text/plain', 'text/x-java-source,java', 'text/x-java-source'],
        'jcm': 'application/x-java-commerce',
        'jfif': ['image/pipeg', 'image/jpeg', 'image/pjpeg'],
        'jfif-tbnl': 'image/jpeg',
        'jisp': 'application/vnd.jisp',
        'jlt': 'application/vnd.hp-jlyt',
        'jnlp': 'application/x-java-jnlp-file',
        'joda': 'application/vnd.joost.joda-archive',
        'jpe': ['image/jpeg', 'image/pjpeg'],
        'jpeg': ['image/jpeg', 'image/pjpeg'],
        'jpg': ['image/jpeg', 'image/pjpeg'],
        'jpgv': 'video/jpeg',
        'jpm': 'video/jpm',
        'jps': 'image/x-jps',
        'js': ['application/javascript', 'application/ecmascript', 'text/javascript', 'text/ecmascript', 'application/x-javascript'],
        'json': 'application/json',
        'jut': 'image/jutvision',
        'kar': ['audio/midi', 'music/x-karaoke'],
        'karbon': 'application/vnd.kde.karbon',
        'kfo': 'application/vnd.kde.kformula',
        'kia': 'application/vnd.kidspiration',
        'kml': 'application/vnd.google-earth.kml+xml',
        'kmz': 'application/vnd.google-earth.kmz',
        'kne': 'application/vnd.kinar',
        'kon': 'application/vnd.kde.kontour',
        'kpr': 'application/vnd.kde.kpresenter',
        'ksh': ['application/x-ksh', 'text/x-script.ksh'],
        'ksp': 'application/vnd.kde.kspread',
        'ktx': 'image/ktx',
        'ktz': 'application/vnd.kahootz',
        'kwd': 'application/vnd.kde.kword',
        'la': ['audio/nspaudio', 'audio/x-nspaudio'],
        'lam': 'audio/x-liveaudio',
        'lasxml': 'application/vnd.las.las+xml',
        'latex': 'application/x-latex',
        'lbd': 'application/vnd.llamagraphics.life-balance.desktop',
        'lbe': 'application/vnd.llamagraphics.life-balance.exchange+xml',
        'les': 'application/vnd.hhe.lesson-player',
        'lha': ['application/octet-stream', 'application/lha', 'application/x-lha'],
        'lhx': 'application/octet-stream',
        'link66': 'application/vnd.route66.link66+xml',
        'list': 'text/plain',
        'lma': ['audio/nspaudio', 'audio/x-nspaudio'],
        'log': 'text/plain',
        'lrm': 'application/vnd.ms-lrm',
        'lsf': 'video/x-la-asf',
        'lsp': ['application/x-lisp', 'text/x-script.lisp'],
        'lst': 'text/plain',
        'lsx': ['video/x-la-asf', 'text/x-la-asf'],
        'ltf': 'application/vnd.frogans.ltf',
        'ltx': 'application/x-latex',
        'lvp': 'audio/vnd.lucent.voice',
        'lwp': 'application/vnd.lotus-wordpro',
        'lzh': ['application/octet-stream', 'application/x-lzh'],
        'lzx': ['application/lzx', 'application/octet-stream', 'application/x-lzx'],
        'm': ['text/plain', 'text/x-m'],
        'm13': 'application/x-msmediaview',
        'm14': 'application/x-msmediaview',
        'm1v': 'video/mpeg',
        'm21': 'application/mp21',
        'm2a': 'audio/mpeg',
        'm2v': 'video/mpeg',
        'm3u': ['audio/x-mpegurl', 'audio/x-mpequrl'],
        'm3u8': 'application/vnd.apple.mpegurl',
        'm4v': 'video/x-m4v',
        'ma': 'application/mathematica',
        'mads': 'application/mads+xml',
        'mag': 'application/vnd.ecowin.chart',
        'man': 'application/x-troff-man',
        'map': 'application/x-navimap',
        'mar': 'text/plain',
        'mathml': 'application/mathml+xml',
        'mbd': 'application/mbedlet',
        'mbk': 'application/vnd.mobius.mbk',
        'mbox': 'application/mbox',
        'mc$': 'application/x-magic-cap-package-1.0',
        'mc1': 'application/vnd.medcalcdata',
        'mcd': ['application/mcad', 'application/vnd.mcd', 'application/x-mathcad'],
        'mcf': ['image/vasa', 'text/mcf'],
        'mcp': 'application/netmc',
        'mcurl': 'text/vnd.curl.mcurl',
        'mdb': 'application/x-msaccess',
        'mdi': 'image/vnd.ms-modi',
        'me': 'application/x-troff-me',
        'meta4': 'application/metalink4+xml',
        'mets': 'application/mets+xml',
        'mfm': 'application/vnd.mfmp',
        'mgp': 'application/vnd.osgeo.mapguide.package',
        'mgz': 'application/vnd.proteus.magazine',
        'mht': 'message/rfc822',
        'mhtml': 'message/rfc822',
        'mid': ['audio/mid', 'audio/midi', 'music/crescendo', 'x-music/x-midi', 'audio/x-midi', 'application/x-midi', 'audio/x-mid'],
        'midi': ['audio/midi', 'music/crescendo', 'x-music/x-midi', 'audio/x-midi', 'application/x-midi', 'audio/x-mid'],
        'mif': ['application/vnd.mif', 'application/x-mif', 'application/x-frame'],
        'mime': ['message/rfc822', 'www/mime'],
        'mj2': 'video/mj2',
        'mjf': 'audio/x-vnd.audioexplosion.mjuicemediafile',
        'mjpg': 'video/x-motion-jpeg',
        'mlp': 'application/vnd.dolby.mlp',
        'mm': ['application/base64', 'application/x-meme'],
        'mmd': 'application/vnd.chipnuts.karaoke-mmd',
        'mme': 'application/base64',
        'mmf': 'application/vnd.smaf',
        'mmr': 'image/vnd.fujixerox.edmics-mmr',
        'mny': 'application/x-msmoney',
        'mod': ['audio/mod', 'audio/x-mod'],
        'mods': 'application/mods+xml',
        'moov': 'video/quicktime',
        'mov': 'video/quicktime',
        'movie': 'video/x-sgi-movie',
        'mp2': ['video/mpeg', 'audio/mpeg', 'video/x-mpeg', 'audio/x-mpeg', 'video/x-mpeq2a'],
        'mp3': ['audio/mpeg', 'audio/mpeg3', 'video/mpeg', 'audio/x-mpeg-3', 'video/x-mpeg'],
        'mp4': ['video/mp4', 'application/mp4'],
        'mp4a': 'audio/mp4',
        'mpa': ['video/mpeg', 'audio/mpeg'],
        'mpc': ['application/vnd.mophun.certificate', 'application/x-project'],
        'mpe': 'video/mpeg',
        'mpeg': 'video/mpeg',
        'mpg': ['video/mpeg', 'audio/mpeg'],
        'mpga': 'audio/mpeg',
        'mpkg': 'application/vnd.apple.installer+xml',
        'mpm': 'application/vnd.blueice.multipass',
        'mpn': 'application/vnd.mophun.application',
        'mpp': 'application/vnd.ms-project',
        'mpt': 'application/x-project',
        'mpv': 'application/x-project',
        'mpv2': 'video/mpeg',
        'mpx': 'application/x-project',
        'mpy': 'application/vnd.ibm.minipay',
        'mqy': 'application/vnd.mobius.mqy',
        'mrc': 'application/marc',
        'mrcx': 'application/marcxml+xml',
        'ms': 'application/x-troff-ms',
        'mscml': 'application/mediaservercontrol+xml',
        'mseq': 'application/vnd.mseq',
        'msf': 'application/vnd.epson.msf',
        'msg': 'application/vnd.ms-outlook',
        'msh': 'model/mesh',
        'msl': 'application/vnd.mobius.msl',
        'msty': 'application/vnd.muvee.style',
        'mts': 'model/vnd.mts',
        'mus': 'application/vnd.musician',
        'musicxml': 'application/vnd.recordare.musicxml+xml',
        'mv': 'video/x-sgi-movie',
        'mvb': 'application/x-msmediaview',
        'mwf': 'application/vnd.mfer',
        'mxf': 'application/mxf',
        'mxl': 'application/vnd.recordare.musicxml',
        'mxml': 'application/xv+xml',
        'mxs': 'application/vnd.triscape.mxs',
        'mxu': 'video/vnd.mpegurl',
        'my': 'audio/make',
        'mzz': 'application/x-vnd.audioexplosion.mzz',
        'n-gage': 'application/vnd.nokia.n-gage.symbian.install',
        'n3': 'text/n3',
        'nap': 'image/naplps',
        'naplps': 'image/naplps',
        'nbp': 'application/vnd.wolfram.player',
        'nc': 'application/x-netcdf',
        'ncm': 'application/vnd.nokia.configuration-message',
        'ncx': 'application/x-dtbncx+xml',
        'ngdat': 'application/vnd.nokia.n-gage.data',
        'nif': 'image/x-niff',
        'niff': 'image/x-niff',
        'nix': 'application/x-mix-transfer',
        'nlu': 'application/vnd.neurolanguage.nlu',
        'nml': 'application/vnd.enliven',
        'nnd': 'application/vnd.noblenet-directory',
        'nns': 'application/vnd.noblenet-sealer',
        'nnw': 'application/vnd.noblenet-web',
        'npx': 'image/vnd.net-fpx',
        'nsc': 'application/x-conference',
        'nsf': 'application/vnd.lotus-notes',
        'nvd': 'application/x-navidoc',
        'nws': 'message/rfc822',
        'o': 'application/octet-stream',
        'oa2': 'application/vnd.fujitsu.oasys2',
        'oa3': 'application/vnd.fujitsu.oasys3',
        'oas': 'application/vnd.fujitsu.oasys',
        'obd': 'application/x-msbinder',
        'oda': 'application/oda',
        'odb': 'application/vnd.oasis.opendocument.database',
        'odc': 'application/vnd.oasis.opendocument.chart',
        'odf': 'application/vnd.oasis.opendocument.formula',
        'odft': 'application/vnd.oasis.opendocument.formula-template',
        'odg': 'application/vnd.oasis.opendocument.graphics',
        'odi': 'application/vnd.oasis.opendocument.image',
        'odm': 'application/vnd.oasis.opendocument.text-master',
        'odp': 'application/vnd.oasis.opendocument.presentation',
        'ods': 'application/vnd.oasis.opendocument.spreadsheet',
        'odt': 'application/vnd.oasis.opendocument.text',
        'oga': 'audio/ogg',
        'ogv': 'video/ogg',
        'ogx': 'application/ogg',
        'omc': 'application/x-omc',
        'omcd': 'application/x-omcdatamaker',
        'omcr': 'application/x-omcregerator',
        'onetoc': 'application/onenote',
        'opf': 'application/oebps-package+xml',
        'org': 'application/vnd.lotus-organizer',
        'osf': 'application/vnd.yamaha.openscoreformat',
        'osfpvg': 'application/vnd.yamaha.openscoreformat.osfpvg+xml',
        'otc': 'application/vnd.oasis.opendocument.chart-template',
        'otf': 'application/x-font-otf',
        'otg': 'application/vnd.oasis.opendocument.graphics-template',
        'oth': 'application/vnd.oasis.opendocument.text-web',
        'oti': 'application/vnd.oasis.opendocument.image-template',
        'otp': 'application/vnd.oasis.opendocument.presentation-template',
        'ots': 'application/vnd.oasis.opendocument.spreadsheet-template',
        'ott': 'application/vnd.oasis.opendocument.text-template',
        'oxt': 'application/vnd.openofficeorg.extension',
        'p': 'text/x-pascal',
        'p10': ['application/pkcs10', 'application/x-pkcs10'],
        'p12': ['application/pkcs-12', 'application/x-pkcs12'],
        'p7a': 'application/x-pkcs7-signature',
        'p7b': 'application/x-pkcs7-certificates',
        'p7c': ['application/pkcs7-mime', 'application/x-pkcs7-mime'],
        'p7m': ['application/pkcs7-mime', 'application/x-pkcs7-mime'],
        'p7r': 'application/x-pkcs7-certreqresp',
        'p7s': ['application/pkcs7-signature', 'application/x-pkcs7-signature'],
        'p8': 'application/pkcs8',
        'par': 'text/plain-bas',
        'part': 'application/pro_eng',
        'pas': 'text/pascal',
        'paw': 'application/vnd.pawaafile',
        'pbd': 'application/vnd.powerbuilder6',
        'pbm': 'image/x-portable-bitmap',
        'pcf': 'application/x-font-pcf',
        'pcl': ['application/vnd.hp-pcl', 'application/x-pcl'],
        'pclxl': 'application/vnd.hp-pclxl',
        'pct': 'image/x-pict',
        'pcurl': 'application/vnd.curl.pcurl',
        'pcx': 'image/x-pcx',
        'pdb': ['application/vnd.palm', 'chemical/x-pdb'],
        'pdf': 'application/pdf',
        'pfa': 'application/x-font-type1',
        'pfr': 'application/font-tdpfr',
        'pfunk': ['audio/make', 'audio/make.my.funk'],
        'pfx': 'application/x-pkcs12',
        'pgm': ['image/x-portable-graymap', 'image/x-portable-greymap'],
        'pgn': 'application/x-chess-pgn',
        'pgp': 'application/pgp-signature',
        'pic': ['image/pict', 'image/x-pict'],
        'pict': 'image/pict',
        'pkg': 'application/x-newton-compatible-pkg',
        'pki': 'application/pkixcmp',
        'pkipath': 'application/pkix-pkipath',
        'pko': ['application/ynd.ms-pkipko', 'application/vnd.ms-pki.pko'],
        'pl': ['text/plain', 'text/x-script.perl'],
        'plb': 'application/vnd.3gpp.pic-bw-large',
        'plc': 'application/vnd.mobius.plc',
        'plf': 'application/vnd.pocketlearn',
        'pls': 'application/pls+xml',
        'plx': 'application/x-pixclscript',
        'pm': ['text/x-script.perl-module', 'image/x-xpixmap'],
        'pm4': 'application/x-pagemaker',
        'pm5': 'application/x-pagemaker',
        'pma': 'application/x-perfmon',
        'pmc': 'application/x-perfmon',
        'pml': ['application/vnd.ctc-posml', 'application/x-perfmon'],
        'pmr': 'application/x-perfmon',
        'pmw': 'application/x-perfmon',
        'png': 'image/png',
        'pnm': ['application/x-portable-anymap', 'image/x-portable-anymap'],
        'portpkg': 'application/vnd.macports.portpkg',
        'pot': ['application/vnd.ms-powerpoint', 'application/mspowerpoint'],
        'potm': 'application/vnd.ms-powerpoint.template.macroenabled.12',
        'potx': 'application/vnd.openxmlformats-officedocument.presentationml.template',
        'pov': 'model/x-pov',
        'ppa': 'application/vnd.ms-powerpoint',
        'ppam': 'application/vnd.ms-powerpoint.addin.macroenabled.12',
        'ppd': 'application/vnd.cups-ppd',
        'ppm': 'image/x-portable-pixmap',
        'pps': ['application/vnd.ms-powerpoint', 'application/mspowerpoint'],
        'ppsm': 'application/vnd.ms-powerpoint.slideshow.macroenabled.12',
        'ppsx': 'application/vnd.openxmlformats-officedocument.presentationml.slideshow',
        'ppt': ['application/vnd.ms-powerpoint', 'application/mspowerpoint', 'application/powerpoint', 'application/x-mspowerpoint'],
        'pptm': 'application/vnd.ms-powerpoint.presentation.macroenabled.12',
        'pptx': 'application/vnd.openxmlformats-officedocument.presentationml.presentation',
        'ppz': 'application/mspowerpoint',
        'prc': 'application/x-mobipocket-ebook',
        'pre': ['application/vnd.lotus-freelance', 'application/x-freelance'],
        'prf': 'application/pics-rules',
        'prt': 'application/pro_eng',
        'ps': 'application/postscript',
        'psb': 'application/vnd.3gpp.pic-bw-small',
        'psd': ['application/octet-stream', 'image/vnd.adobe.photoshop'],
        'psf': 'application/x-font-linux-psf',
        'pskcxml': 'application/pskc+xml',
        'ptid': 'application/vnd.pvi.ptid1',
        'pub': 'application/x-mspublisher',
        'pvb': 'application/vnd.3gpp.pic-bw-var',
        'pvu': 'paleovu/x-pv',
        'pwn': 'application/vnd.3m.post-it-notes',
        'pwz': 'application/vnd.ms-powerpoint',
        'py': 'text/x-script.phyton',
        'pya': 'audio/vnd.ms-playready.media.pya',
        'pyc': 'applicaiton/x-bytecode.python',
        'pyv': 'video/vnd.ms-playready.media.pyv',
        'qam': 'application/vnd.epson.quickanime',
        'qbo': 'application/vnd.intu.qbo',
        'qcp': 'audio/vnd.qcelp',
        'qd3': 'x-world/x-3dmf',
        'qd3d': 'x-world/x-3dmf',
        'qfx': 'application/vnd.intu.qfx',
        'qif': 'image/x-quicktime',
        'qps': 'application/vnd.publishare-delta-tree',
        'qt': 'video/quicktime',
        'qtc': 'video/x-qtc',
        'qti': 'image/x-quicktime',
        'qtif': 'image/x-quicktime',
        'qxd': 'application/vnd.quark.quarkxpress',
        'ra': ['audio/x-realaudio', 'audio/x-pn-realaudio', 'audio/x-pn-realaudio-plugin'],
        'ram': 'audio/x-pn-realaudio',
        'rar': 'application/x-rar-compressed',
        'ras': ['image/cmu-raster', 'application/x-cmu-raster', 'image/x-cmu-raster'],
        'rast': 'image/cmu-raster',
        'rcprofile': 'application/vnd.ipunplugged.rcprofile',
        'rdf': 'application/rdf+xml',
        'rdz': 'application/vnd.data-vision.rdz',
        'rep': 'application/vnd.businessobjects',
        'res': 'application/x-dtbresource+xml',
        'rexx': 'text/x-script.rexx',
        'rf': 'image/vnd.rn-realflash',
        'rgb': 'image/x-rgb',
        'rif': 'application/reginfo+xml',
        'rip': 'audio/vnd.rip',
        'rl': 'application/resource-lists+xml',
        'rlc': 'image/vnd.fujixerox.edmics-rlc',
        'rld': 'application/resource-lists-diff+xml',
        'rm': ['application/vnd.rn-realmedia', 'audio/x-pn-realaudio'],
        'rmi': 'audio/mid',
        'rmm': 'audio/x-pn-realaudio',
        'rmp': ['audio/x-pn-realaudio-plugin', 'audio/x-pn-realaudio'],
        'rms': 'application/vnd.jcp.javame.midlet-rms',
        'rnc': 'application/relax-ng-compact-syntax',
        'rng': ['application/ringing-tones', 'application/vnd.nokia.ringing-tone'],
        'rnx': 'application/vnd.rn-realplayer',
        'roff': 'application/x-troff',
        'rp': 'image/vnd.rn-realpix',
        'rp9': 'application/vnd.cloanto.rp9',
        'rpm': 'audio/x-pn-realaudio-plugin',
        'rpss': 'application/vnd.nokia.radio-presets',
        'rpst': 'application/vnd.nokia.radio-preset',
        'rq': 'application/sparql-query',
        'rs': 'application/rls-services+xml',
        'rsd': 'application/rsd+xml',
        'rt': ['text/richtext', 'text/vnd.rn-realtext'],
        'rtf': ['application/rtf', 'text/richtext', 'application/x-rtf'],
        'rtx': ['text/richtext', 'application/rtf'],
        'rv': 'video/vnd.rn-realvideo',
        's': 'text/x-asm',
        's3m': 'audio/s3m',
        'saf': 'application/vnd.yamaha.smaf-audio',
        'saveme': 'application/octet-stream',
        'sbk': 'application/x-tbook',
        'sbml': 'application/sbml+xml',
        'sc': 'application/vnd.ibm.secure-container',
        'scd': 'application/x-msschedule',
        'scm': ['application/vnd.lotus-screencam', 'video/x-scm', 'text/x-script.guile', 'application/x-lotusscreencam', 'text/x-script.scheme'],
        'scq': 'application/scvp-cv-request',
        'scs': 'application/scvp-cv-response',
        'sct': 'text/scriptlet',
        'scurl': 'text/vnd.curl.scurl',
        'sda': 'application/vnd.stardivision.draw',
        'sdc': 'application/vnd.stardivision.calc',
        'sdd': 'application/vnd.stardivision.impress',
        'sdkm': 'application/vnd.solent.sdkm+xml',
        'sdml': 'text/plain',
        'sdp': ['application/sdp', 'application/x-sdp'],
        'sdr': 'application/sounder',
        'sdw': 'application/vnd.stardivision.writer',
        'sea': ['application/sea', 'application/x-sea'],
        'see': 'application/vnd.seemail',
        'seed': 'application/vnd.fdsn.seed',
        'sema': 'application/vnd.sema',
        'semd': 'application/vnd.semd',
        'semf': 'application/vnd.semf',
        'ser': 'application/java-serialized-object',
        'set': 'application/set',
        'setpay': 'application/set-payment-initiation',
        'setreg': 'application/set-registration-initiation',
        'sfd-hdstx': 'application/vnd.hydrostatix.sof-data',
        'sfs': 'application/vnd.spotfire.sfs',
        'sgl': 'application/vnd.stardivision.writer-global',
        'sgm': ['text/sgml', 'text/x-sgml'],
        'sgml': ['text/sgml', 'text/x-sgml'],
        'sh': ['application/x-shar', 'application/x-bsh', 'application/x-sh', 'text/x-script.sh'],
        'shar': ['application/x-bsh', 'application/x-shar'],
        'shf': 'application/shf+xml',
        'shtml': ['text/html', 'text/x-server-parsed-html'],
        'sid': 'audio/x-psid',
        'sis': 'application/vnd.symbian.install',
        'sit': ['application/x-stuffit', 'application/x-sit'],
        'sitx': 'application/x-stuffitx',
        'skd': 'application/x-koan',
        'skm': 'application/x-koan',
        'skp': ['application/vnd.koan', 'application/x-koan'],
        'skt': 'application/x-koan',
        'sl': 'application/x-seelogo',
        'sldm': 'application/vnd.ms-powerpoint.slide.macroenabled.12',
        'sldx': 'application/vnd.openxmlformats-officedocument.presentationml.slide',
        'slt': 'application/vnd.epson.salt',
        'sm': 'application/vnd.stepmania.stepchart',
        'smf': 'application/vnd.stardivision.math',
        'smi': ['application/smil', 'application/smil+xml'],
        'smil': 'application/smil',
        'snd': ['audio/basic', 'audio/x-adpcm'],
        'snf': 'application/x-font-snf',
        'sol': 'application/solids',
        'spc': ['text/x-speech', 'application/x-pkcs7-certificates'],
        'spf': 'application/vnd.yamaha.smaf-phrase',
        'spl': ['application/futuresplash', 'application/x-futuresplash'],
        'spot': 'text/vnd.in3d.spot',
        'spp': 'application/scvp-vp-response',
        'spq': 'application/scvp-vp-request',
        'spr': 'application/x-sprite',
        'sprite': 'application/x-sprite',
        'src': 'application/x-wais-source',
        'sru': 'application/sru+xml',
        'srx': 'application/sparql-results+xml',
        'sse': 'application/vnd.kodak-descriptor',
        'ssf': 'application/vnd.epson.ssf',
        'ssi': 'text/x-server-parsed-html',
        'ssm': 'application/streamingmedia',
        'ssml': 'application/ssml+xml',
        'sst': ['application/vnd.ms-pkicertstore', 'application/vnd.ms-pki.certstore'],
        'st': 'application/vnd.sailingtracker.track',
        'stc': 'application/vnd.sun.xml.calc.template',
        'std': 'application/vnd.sun.xml.draw.template',
        'step': 'application/step',
        'stf': 'application/vnd.wt.stf',
        'sti': 'application/vnd.sun.xml.impress.template',
        'stk': 'application/hyperstudio',
        'stl': ['application/vnd.ms-pkistl', 'application/sla', 'application/vnd.ms-pki.stl', 'application/x-navistyle'],
        'stm': 'text/html',
        'stp': 'application/step',
        'str': 'application/vnd.pg.format',
        'stw': 'application/vnd.sun.xml.writer.template',
        'sub': 'image/vnd.dvb.subtitle',
        'sus': 'application/vnd.sus-calendar',
        'sv4cpio': 'application/x-sv4cpio',
        'sv4crc': 'application/x-sv4crc',
        'svc': 'application/vnd.dvb.service',
        'svd': 'application/vnd.svd',
        'svf': ['image/vnd.dwg', 'image/x-dwg'],
        'svg': 'image/svg+xml',
        'svr': ['x-world/x-svr', 'application/x-world'],
        'swf': 'application/x-shockwave-flash',
        'swi': 'application/vnd.aristanetworks.swi',
        'sxc': 'application/vnd.sun.xml.calc',
        'sxd': 'application/vnd.sun.xml.draw',
        'sxg': 'application/vnd.sun.xml.writer.global',
        'sxi': 'application/vnd.sun.xml.impress',
        'sxm': 'application/vnd.sun.xml.math',
        'sxw': 'application/vnd.sun.xml.writer',
        't': ['text/troff', 'application/x-troff'],
        'talk': 'text/x-speech',
        'tao': 'application/vnd.tao.intent-module-archive',
        'tar': 'application/x-tar',
        'tbk': ['application/toolbook', 'application/x-tbook'],
        'tcap': 'application/vnd.3gpp2.tcap',
        'tcl': ['text/x-script.tcl', 'application/x-tcl'],
        'tcsh': 'text/x-script.tcsh',
        'teacher': 'application/vnd.smart.teacher',
        'tei': 'application/tei+xml',
        'tex': 'application/x-tex',
        'texi': 'application/x-texinfo',
        'texinfo': 'application/x-texinfo',
        'text': ['application/plain', 'text/plain'],
        'tfi': 'application/thraud+xml',
        'tfm': 'application/x-tex-tfm',
        'tgz': ['application/gnutar', 'application/x-compressed'],
        'thmx': 'application/vnd.ms-officetheme',
        'tif': ['image/tiff', 'image/x-tiff'],
        'tiff': ['image/tiff', 'image/x-tiff'],
        'tmo': 'application/vnd.tmobile-livetv',
        'torrent': 'application/x-bittorrent',
        'tpl': 'application/vnd.groove-tool-template',
        'tpt': 'application/vnd.trid.tpt',
        'tr': 'application/x-troff',
        'tra': 'application/vnd.trueapp',
        'trm': 'application/x-msterminal',
        'tsd': 'application/timestamped-data',
        'tsi': 'audio/tsp-audio',
        'tsp': ['application/dsptype', 'audio/tsplayer'],
        'tsv': 'text/tab-separated-values',
        'ttf': 'application/x-font-ttf',
        'ttl': 'text/turtle',
        'turbot': 'image/florian',
        'twd': 'application/vnd.simtech-mindmapper',
        'txd': 'application/vnd.genomatix.tuxedo',
        'txf': 'application/vnd.mobius.txf',
        'txt': 'text/plain',
        'ufd': 'application/vnd.ufdl',
        'uil': 'text/x-uil',
        'uls': 'text/iuls',
        'umj': 'application/vnd.umajin',
        'uni': 'text/uri-list',
        'unis': 'text/uri-list',
        'unityweb': 'application/vnd.unity',
        'unv': 'application/i-deas',
        'uoml': 'application/vnd.uoml+xml',
        'uri': 'text/uri-list',
        'uris': 'text/uri-list',
        'ustar': ['application/x-ustar', 'multipart/x-ustar'],
        'utz': 'application/vnd.uiq.theme',
        'uu': ['application/octet-stream', 'text/x-uuencode'],
        'uue': 'text/x-uuencode',
        'uva': 'audio/vnd.dece.audio',
        'uvh': 'video/vnd.dece.hd',
        'uvi': 'image/vnd.dece.graphic',
        'uvm': 'video/vnd.dece.mobile',
        'uvp': 'video/vnd.dece.pd',
        'uvs': 'video/vnd.dece.sd',
        'uvu': 'video/vnd.uvvu.mp4',
        'uvv': 'video/vnd.dece.video',
        'vcd': 'application/x-cdlink',
        'vcf': 'text/x-vcard',
        'vcg': 'application/vnd.groove-vcard',
        'vcs': 'text/x-vcalendar',
        'vcx': 'application/vnd.vcx',
        'vda': 'application/vda',
        'vdo': 'video/vdo',
        'vew': 'application/groupwise',
        'vis': 'application/vnd.visionary',
        'viv': ['video/vivo', 'video/vnd.vivo'],
        'vivo': ['video/vivo', 'video/vnd.vivo'],
        'vmd': 'application/vocaltec-media-desc',
        'vmf': 'application/vocaltec-media-file',
        'voc': ['audio/voc', 'audio/x-voc'],
        'vos': 'video/vosaic',
        'vox': 'audio/voxware',
        'vqe': 'audio/x-twinvq-plugin',
        'vqf': 'audio/x-twinvq',
        'vql': 'audio/x-twinvq-plugin',
        'vrml': ['model/vrml', 'x-world/x-vrml', 'application/x-vrml'],
        'vrt': 'x-world/x-vrt',
        'vsd': ['application/vnd.visio', 'application/x-visio'],
        'vsf': 'application/vnd.vsf',
        'vst': 'application/x-visio',
        'vsw': 'application/x-visio',
        'vtu': 'model/vnd.vtu',
        'vxml': 'application/voicexml+xml',
        'w60': 'application/wordperfect6.0',
        'w61': 'application/wordperfect6.1',
        'w6w': 'application/msword',
        'wad': 'application/x-doom',
        'wav': ['audio/wav', 'audio/x-wav'],
        'wax': 'audio/x-ms-wax',
        'wb1': 'application/x-qpro',
        'wbmp': 'image/vnd.wap.wbmp',
        'wbs': 'application/vnd.criticaltools.wbs+xml',
        'wbxml': 'application/vnd.wap.wbxml',
        'wcm': 'application/vnd.ms-works',
        'wdb': 'application/vnd.ms-works',
        'web': 'application/vnd.xara',
        'weba': 'audio/webm',
        'webm': 'video/webm',
        'webp': 'image/webp',
        'wg': 'application/vnd.pmi.widget',
        'wgt': 'application/widget',
        'wiz': 'application/msword',
        'wk1': 'application/x-123',
        'wks': 'application/vnd.ms-works',
        'wm': 'video/x-ms-wm',
        'wma': 'audio/x-ms-wma',
        'wmd': 'application/x-ms-wmd',
        'wmf': ['windows/metafile', 'application/x-msmetafile'],
        'wml': 'text/vnd.wap.wml',
        'wmlc': 'application/vnd.wap.wmlc',
        'wmls': 'text/vnd.wap.wmlscript',
        'wmlsc': 'application/vnd.wap.wmlscriptc',
        'wmv': 'video/x-ms-wmv',
        'wmx': 'video/x-ms-wmx',
        'wmz': 'application/x-ms-wmz',
        'woff': 'application/x-font-woff',
        'word': 'application/msword',
        'wp': 'application/wordperfect',
        'wp5': ['application/wordperfect', 'application/wordperfect6.0'],
        'wp6': 'application/wordperfect',
        'wpd': ['application/wordperfect', 'application/vnd.wordperfect', 'application/x-wpwin'],
        'wpl': 'application/vnd.ms-wpl',
        'wps': 'application/vnd.ms-works',
        'wq1': 'application/x-lotus',
        'wqd': 'application/vnd.wqd',
        'wri': ['application/mswrite', 'application/x-wri', 'application/x-mswrite'],
        'wrl': ['model/vrml', 'x-world/x-vrml', 'application/x-world'],
        'wrz': ['model/vrml', 'x-world/x-vrml'],
        'wsc': 'text/scriplet',
        'wsdl': 'application/wsdl+xml',
        'wspolicy': 'application/wspolicy+xml',
        'wsrc': 'application/x-wais-source',
        'wtb': 'application/vnd.webturbo',
        'wtk': 'application/x-wintalk',
        'wvx': 'video/x-ms-wvx',
        'x-png': 'image/png',
        'x3d': 'application/vnd.hzn-3d-crossword',
        'xaf': 'x-world/x-vrml',
        'xap': 'application/x-silverlight-app',
        'xar': 'application/vnd.xara',
        'xbap': 'application/x-ms-xbap',
        'xbd': 'application/vnd.fujixerox.docuworks.binder',
        'xbm': ['image/xbm', 'image/x-xbm', 'image/x-xbitmap'],
        'xdf': 'application/xcap-diff+xml',
        'xdm': 'application/vnd.syncml.dm+xml',
        'xdp': 'application/vnd.adobe.xdp+xml',
        'xdr': 'video/x-amt-demorun',
        'xdssc': 'application/dssc+xml',
        'xdw': 'application/vnd.fujixerox.docuworks',
        'xenc': 'application/xenc+xml',
        'xer': 'application/patch-ops-error+xml',
        'xfdf': 'application/vnd.adobe.xfdf',
        'xfdl': 'application/vnd.xfdl',
        'xgz': 'xgl/drawing',
        'xhtml': 'application/xhtml+xml',
        'xif': 'image/vnd.xiff',
        'xl': 'application/excel',
        'xla': ['application/vnd.ms-excel', 'application/excel', 'application/x-msexcel', 'application/x-excel'],
        'xlam': 'application/vnd.ms-excel.addin.macroenabled.12',
        'xlb': ['application/excel', 'application/vnd.ms-excel', 'application/x-excel'],
        'xlc': ['application/vnd.ms-excel', 'application/excel', 'application/x-excel'],
        'xld': ['application/excel', 'application/x-excel'],
        'xlk': ['application/excel', 'application/x-excel'],
        'xll': ['application/excel', 'application/vnd.ms-excel', 'application/x-excel'],
        'xlm': ['application/vnd.ms-excel', 'application/excel', 'application/x-excel'],
        'xls': ['application/vnd.ms-excel', 'application/excel', 'application/x-msexcel', 'application/x-excel'],
        'xlsb': 'application/vnd.ms-excel.sheet.binary.macroenabled.12',
        'xlsm': 'application/vnd.ms-excel.sheet.macroenabled.12',
        'xlsx': 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet',
        'xlt': ['application/vnd.ms-excel', 'application/excel', 'application/x-excel'],
        'xltm': 'application/vnd.ms-excel.template.macroenabled.12',
        'xltx': 'application/vnd.openxmlformats-officedocument.spreadsheetml.template',
        'xlv': ['application/excel', 'application/x-excel'],
        'xlw': ['application/vnd.ms-excel', 'application/excel', 'application/x-msexcel', 'application/x-excel'],
        'xm': 'audio/xm',
        'xml': ['application/xml', 'text/xml', 'application/atom+xml', 'application/rss+xml'],
        'xmz': 'xgl/movie',
        'xo': 'application/vnd.olpc-sugar',
        'xof': 'x-world/x-vrml',
        'xop': 'application/xop+xml',
        'xpi': 'application/x-xpinstall',
        'xpix': 'application/x-vnd.ls-xpix',
        'xpm': ['image/xpm', 'image/x-xpixmap'],
        'xpr': 'application/vnd.is-xpr',
        'xps': 'application/vnd.ms-xpsdocument',
        'xpw': 'application/vnd.intercon.formnet',
        'xslt': 'application/xslt+xml',
        'xsm': 'application/vnd.syncml+xml',
        'xspf': 'application/xspf+xml',
        'xsr': 'video/x-amt-showrun',
        'xul': 'application/vnd.mozilla.xul+xml',
        'xwd': ['image/x-xwd', 'image/x-xwindowdump'],
        'xyz': ['chemical/x-xyz', 'chemical/x-pdb'],
        'yang': 'application/yang',
        'yin': 'application/yin+xml',
        'z': ['application/x-compressed', 'application/x-compress'],
        'zaz': 'application/vnd.zzazz.deck+xml',
        'zip': ['application/zip', 'multipart/x-zip', 'application/x-zip-compressed', 'application/x-compressed'],
        'zir': 'application/vnd.zul',
        'zmm': 'application/vnd.handheld-entertainment+xml',
        'zoo': 'application/octet-stream',
        'zsh': 'text/x-script.zsh'
    }
};

},{}],67:[function(require,module,exports){
(function (Buffer){
'use strict';

var stream = require('stream');
var util = require('util');
var Transform = stream.Transform;

// expose to the world
module.exports = {
    encode: encode,
    decode: decode,
    wrap: wrap,
    Encoder: Encoder,
    Decoder: Decoder
};

/**
 * Encodes a Buffer into a Quoted-Printable encoded string
 *
 * @param {Buffer} buffer Buffer to convert
 * @returns {String} Quoted-Printable encoded string
 */
function encode(buffer) {
    if (typeof buffer === 'string') {
        buffer = new Buffer(buffer, 'utf-8');
    }

    // usable characters that do not need encoding
    var ranges = [
        // https://tools.ietf.org/html/rfc2045#section-6.7
        [0x09], // <TAB>
        [0x0A], // <LF>
        [0x0D], // <CR>
        [0x20, 0x3C], // <SP>!"#$%&'()*+,-./0123456789:;
        [0x3E, 0x7E] // >?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\]^_`abcdefghijklmnopqrstuvwxyz{|}
    ];
    var result = '';
    var ord;

    for (var i = 0, len = buffer.length; i < len; i++) {
        ord = buffer[i];
        // if the char is in allowed range, then keep as is, unless it is a ws in the end of a line
        if (checkRanges(ord, ranges) && !((ord === 0x20 || ord === 0x09) && (i === len - 1 || buffer[i + 1] === 0x0a || buffer[i + 1] === 0x0d))) {
            result += String.fromCharCode(ord);
            continue;
        }
        result += '=' + (ord < 0x10 ? '0' : '') + ord.toString(16).toUpperCase();
    }

    return result;
}

/**
 * Decodes a Quoted-Printable encoded string to a Buffer object
 *
 * @param {String} str Quoted-Printable encoded string
 * @returns {Buffer} Decoded value
 */
function decode(str) {
    str = (str || '').toString().
        // remove invalid whitespace from the end of lines
    replace(/[\t ]+$/gm, '').
        // remove soft line breaks
    replace(/\=(?:\r?\n|$)/g, '');

    var encodedBytesCount = (str.match(/\=[\da-fA-F]{2}/g) || []).length,
        bufferLength = str.length - encodedBytesCount * 2,
        chr, hex,
        buffer = new Buffer(bufferLength),
        bufferPos = 0;

    for (var i = 0, len = str.length; i < len; i++) {
        chr = str.charAt(i);
        if (chr === '=' && (hex = str.substr(i + 1, 2)) && /[\da-fA-F]{2}/.test(hex)) {
            buffer[bufferPos++] = parseInt(hex, 16);
            i += 2;
            continue;
        }
        buffer[bufferPos++] = chr.charCodeAt(0);
    }

    return buffer;
}

/**
 * Adds soft line breaks to a Quoted-Printable string
 *
 * @param {String} str Quoted-Printable encoded string that might need line wrapping
 * @param {Number} [lineLength=76] Maximum allowed length for a line
 * @returns {String} Soft-wrapped Quoted-Printable encoded string
 */
function wrap(str, lineLength) {
    str = (str || '').toString();
    lineLength = lineLength || 76;

    if (str.length <= lineLength) {
        return str;
    }

    var pos = 0,
        len = str.length,
        match, code, line,
        lineMargin = Math.floor(lineLength / 3),
        result = '';

    // insert soft linebreaks where needed
    while (pos < len) {
        line = str.substr(pos, lineLength);
        if ((match = line.match(/\r\n/))) {
            line = line.substr(0, match.index + match[0].length);
            result += line;
            pos += line.length;
            continue;
        }

        if (line.substr(-1) === '\n') {
            // nothing to change here
            result += line;
            pos += line.length;
            continue;
        } else if ((match = line.substr(-lineMargin).match(/\n.*?$/))) {
            // truncate to nearest line break
            line = line.substr(0, line.length - (match[0].length - 1));
            result += line;
            pos += line.length;
            continue;
        } else if (line.length > lineLength - lineMargin && (match = line.substr(-lineMargin).match(/[ \t\.,!\?][^ \t\.,!\?]*$/))) {
            // truncate to nearest space
            line = line.substr(0, line.length - (match[0].length - 1));
        } else {
            if (line.match(/\=[\da-f]{0,2}$/i)) {

                // push incomplete encoding sequences to the next line
                if ((match = line.match(/\=[\da-f]{0,1}$/i))) {
                    line = line.substr(0, line.length - match[0].length);
                }

                // ensure that utf-8 sequences are not split
                while (line.length > 3 && line.length < len - pos && !line.match(/^(?:=[\da-f]{2}){1,4}$/i) && (match = line.match(/\=[\da-f]{2}$/ig))) {
                    code = parseInt(match[0].substr(1, 2), 16);
                    if (code < 128) {
                        break;
                    }

                    line = line.substr(0, line.length - 3);

                    if (code >= 0xC0) {
                        break;
                    }
                }
            }
        }

        if (pos + line.length < len && line.substr(-1) !== '\n') {
            if (line.length === lineLength && line.match(/\=[\da-f]{2}$/i)) {
                line = line.substr(0, line.length - 3);
            } else if (line.length === lineLength) {
                line = line.substr(0, line.length - 1);
            }
            pos += line.length;
            line += '=\r\n';
        } else {
            pos += line.length;
        }

        result += line;
    }

    return result;
}

/**
 * Helper function to check if a number is inside provided ranges
 *
 * @param {Number} nr Number to check for
 * @param {Array} ranges An Array of allowed values
 * @returns {Boolean} True if the value was found inside allowed ranges, false otherwise
 */
function checkRanges(nr, ranges) {
    for (var i = ranges.length - 1; i >= 0; i--) {
        if (!ranges[i].length) {
            continue;
        }
        if (ranges[i].length === 1 && nr === ranges[i][0]) {
            return true;
        }
        if (ranges[i].length === 2 && nr >= ranges[i][0] && nr <= ranges[i][1]) {
            return true;
        }
    }
    return false;
}

/**
 * Creates a transform stream for encoding data to Quoted-Printable encoding
 *
 * @constructor
 * @param {Object} options Stream options
 * @param {Number} [options.lineLength=76] Maximum lenght for lines, set to false to disable wrapping
 */
function Encoder(options) {
    // init Transform
    this.options = options || {};

    if (this.options.lineLength !== false) {
        this.options.lineLength = this.options.lineLength || 76;
    }

    this._curLine = '';

    this.inputBytes = 0;
    this.outputBytes = 0;

    Transform.call(this, this.options);
}
util.inherits(Encoder, Transform);

Encoder.prototype._transform = function(chunk, encoding, done) {
    var qp, _self = this;

    if (encoding !== 'buffer') {
        chunk = new Buffer(chunk, encoding);
    }

    if (!chunk || !chunk.length) {
        return done();
    }

    this.inputBytes += chunk.length;

    if (this.options.lineLength) {
        qp = this._curLine + encode(chunk);
        qp = wrap(qp, this.options.lineLength);
        qp = qp.replace(/(^|\n)([^\n]*)$/, function(match, lineBreak, lastLine) {
            _self._curLine = lastLine;
            return lineBreak;
        });

        if (qp) {
            this.outputBytes += qp.length;
            this.push(qp);
        }

    } else {
        qp = encode(chunk);
        this.outputBytes += qp.length;
        this.push(qp, 'ascii');
    }

    done();
};

Encoder.prototype._flush = function(done) {
    if (this._curLine) {
        this.outputBytes += this._curLine.length;
        this.push(this._curLine, 'ascii');
    }
    done();
};

/**
 * Creates a transform stream for decoding Quoted-Printable encoded strings
 *
 * @constructor
 * @param {Object} options Stream options
 */
function Decoder(options) {
    // init Transform
    this.options = options || {};
    this._curLine = '';

    this.inputBytes = 0;
    this.outputBytes = 0;

    Transform.call(this, this.options);
}
util.inherits(Decoder, Transform);

Decoder.prototype._transform = function(chunk, encoding, done) {
    var qp, buf, _self = this;

    chunk = chunk.toString('ascii');

    if (!chunk || !chunk.length) {
        return done();
    }

    this.inputBytes += chunk.length;

    qp = (this._curLine + chunk);
    this._curLine = '';
    qp = qp.replace(/=[^\n]?$/, function(lastLine) {
        _self._curLine = lastLine;
        return '';
    });

    if (qp) {
        buf = decode(qp);
        this.outputBytes += buf.length;
        this.push(buf);
    }

    done();
};

Decoder.prototype._flush = function(done) {
    var qp, buf;
    if (this._curLine) {
        buf = decode(this._curLine);
        this.outputBytes += buf.length;
        this.push(buf);
    }
    done();
};
}).call(this,require("buffer").Buffer)
},{"buffer":9,"stream":23,"util":104}],68:[function(require,module,exports){
(function (Buffer){
'use strict';

var BuildMail = require('buildmail');
var libmime = require('libmime');

module.exports = function (mail) {
    return new MailComposer(mail).compile();
};

module.exports.MailComposer = MailComposer;

/**
 * Creates the object for composing a BuildMail instance out from the mail options
 *
 * @constructor
 * @param {Object} mail Mail options
 */
function MailComposer(mail) {
    if (!(this instanceof MailComposer)) {
        return new MailComposer(mail);
    }

    this.mail = mail || {};
    this.message = false;
}

/**
 * Builds BuildMail instance
 */
MailComposer.prototype.compile = function () {
    this._alternatives = this._getAlternatives();
    this._htmlNode = this._alternatives.filter(function (alternative) {
        return /^text\/html\b/i.test(alternative.contentType);
    }).pop();
    this._attachments = this._getAttachments(!!this._htmlNode);

    this._useRelated = !!(this._htmlNode && this._attachments.related.length);
    this._useAlternative = this._alternatives.length > 1;
    this._useMixed = this._attachments.attached.length > 1 || (this._alternatives.length && this._attachments.attached.length === 1);

    // Compose MIME tree
    if (this.mail.raw) {
        this.message = new BuildMail().setRaw(this.mail.raw);
    } else if (this._useMixed) {
        this.message = this._createMixed();
    } else if (this._useAlternative) {
        this.message = this._createAlternative();
    } else if (this._useRelated) {
        this.message = this._createRelated();
    } else {
        this.message = this._createContentNode(false, [].concat(this._alternatives || []).concat(this._attachments.attached || []).shift() || {
            contentType: 'text/plain',
            content: ''
        });
    }

    // Add custom headers
    if (this.mail.headers) {
        this.message.addHeader(this.mail.headers);
    }

    // Add headers to the root node, always overrides custom headers
    [
        'from',
        'sender',
        'to',
        'cc',
        'bcc',
        'reply-to',
        'in-reply-to',
        'references',
        'subject',
        'message-id',
        'date'
    ].forEach(function (header) {
        var key = header.replace(/-(\w)/g, function (o, c) {
            return c.toUpperCase();
        });
        if (this.mail[key]) {
            this.message.setHeader(header, this.mail[key]);
        }
    }.bind(this));

    // Sets custom envelope
    if (this.mail.envelope) {
        this.message.setEnvelope(this.mail.envelope);
    }

    // ensure Message-Id value
    this.message.messageId();

    return this.message;
};

/**
 * Builds multipart/mixed node. It should always contain different type of elements on the same level
 * eg. text + attachments
 *
 * @param {Object} parentNode Parent for this note. If it does not exist, a root node is created
 * @returns {Object} BuildMail node element
 */
MailComposer.prototype._createMixed = function (parentNode) {
    var node;

    if (!parentNode) {
        node = new BuildMail('multipart/mixed', {
            baseBoundary: this.mail.baseBoundary,
            textEncoding: this.mail.textEncoding
        });
    } else {
        node = parentNode.createChild('multipart/mixed');
    }

    if (this._useAlternative) {
        this._createAlternative(node);
    } else if (this._useRelated) {
        this._createRelated(node);
    }

    [].concat(!this._useAlternative && this._alternatives || []).concat(this._attachments.attached || []).forEach(function (element) {
        // if the element is a html node from related subpart then ignore it
        if (!this._useRelated || element !== this._htmlNode) {
            this._createContentNode(node, element);
        }
    }.bind(this));

    return node;
};

/**
 * Builds multipart/alternative node. It should always contain same type of elements on the same level
 * eg. text + html view of the same data
 *
 * @param {Object} parentNode Parent for this note. If it does not exist, a root node is created
 * @returns {Object} BuildMail node element
 */
MailComposer.prototype._createAlternative = function (parentNode) {
    var node;

    if (!parentNode) {
        node = new BuildMail('multipart/alternative', {
            baseBoundary: this.mail.baseBoundary,
            textEncoding: this.mail.textEncoding
        });
    } else {
        node = parentNode.createChild('multipart/alternative');
    }

    this._alternatives.forEach(function (alternative) {
        if (this._useRelated && this._htmlNode === alternative) {
            this._createRelated(node);
        } else {
            this._createContentNode(node, alternative);
        }
    }.bind(this));

    return node;
};

/**
 * Builds multipart/related node. It should always contain html node with related attachments
 *
 * @param {Object} parentNode Parent for this note. If it does not exist, a root node is created
 * @returns {Object} BuildMail node element
 */
MailComposer.prototype._createRelated = function (parentNode) {
    var node;

    if (!parentNode) {
        node = new BuildMail('multipart/related; type="text/html"', {
            baseBoundary: this.mail.baseBoundary,
            textEncoding: this.mail.textEncoding
        });
    } else {
        node = parentNode.createChild('multipart/related; type="text/html"');
    }

    this._createContentNode(node, this._htmlNode);

    this._attachments.related.forEach(function (alternative) {
        this._createContentNode(node, alternative);
    }.bind(this));

    return node;
};

/**
 * Creates a regular node with contents
 *
 * @param {Object} parentNode Parent for this note. If it does not exist, a root node is created
 * @param {Object} element Node data
 * @returns {Object} BuildMail node element
 */
MailComposer.prototype._createContentNode = function (parentNode, element) {
    element = element || {};
    element.content = element.content || '';

    var node;
    var encoding = (element.encoding || 'utf8')
        .toString()
        .toLowerCase()
        .replace(/[-_\s]/g, '');

    if (!parentNode) {
        node = new BuildMail(element.contentType, {
            filename: element.filename,
            baseBoundary: this.mail.baseBoundary,
            textEncoding: this.mail.textEncoding
        });
    } else {
        node = parentNode.createChild(element.contentType, {
            filename: element.filename
        });
    }

    // add custom headers
    if (element.headers) {
        node.addHeader(element.headers);
    }

    if (element.cid) {
        node.setHeader('Content-Id', '<' + element.cid.replace(/[<>]/g, '') + '>');
    }

    if (element.contentTransferEncoding) {
        node.setHeader('Content-Transfer-Encoding', element.contentTransferEncoding);
    } else if (this.mail.encoding && /^text\//i.test(element.contentType)) {
        node.setHeader('Content-Transfer-Encoding', this.mail.encoding);
    }

    if (!/^text\//i.test(element.contentType) || element.contentDisposition) {
        node.setHeader('Content-Disposition', element.contentDisposition || 'attachment');
    }

    if (typeof element.content === 'string' && ['utf8', 'usascii', 'ascii'].indexOf(encoding) < 0) {
        element.content = new Buffer(element.content, encoding);
    }

    // prefer pregenerated raw content
    if (element.raw) {
        node.setRaw(element.raw);
    } else {
        node.setContent(element.content);
    }

    return node;
};

/**
 * List all attachments. Resulting attachment objects can be used as input for BuildMail nodes
 *
 * @param {Boolean} findRelated If true separate related attachments from attached ones
 * @returns {Object} An object of arrays (`related` and `attached`)
 */
MailComposer.prototype._getAttachments = function (findRelated) {
    var attachments = [].concat(this.mail.attachments || []).map(function (attachment, i) {
        var data;
        var isMessageNode = /^message\//i.test(attachment.contentType);

        if (/^data:/i.test(attachment.path || attachment.href)) {
            attachment = this._processDataUrl(attachment);
        }

        data = {
            contentType: attachment.contentType ||
                libmime.detectMimeType(attachment.filename || attachment.path || attachment.href || 'bin'),
            contentDisposition: attachment.contentDisposition || (isMessageNode ? 'inline' : 'attachment'),
            contentTransferEncoding: attachment.contentTransferEncoding
        };

        if (attachment.filename) {
            data.filename = attachment.filename;
        } else if (!isMessageNode && attachment.filename !== false) {
            data.filename = (attachment.path || attachment.href || '').split('/').pop() || 'attachment-' + (i + 1);
            if (data.filename.indexOf('.') < 0) {
                data.filename += '.' + libmime.detectExtension(data.contentType);
            }
        }

        if (/^https?:\/\//i.test(attachment.path)) {
            attachment.href = attachment.path;
            attachment.path = undefined;
        }

        if (attachment.cid) {
            data.cid = attachment.cid;
        }

        if (attachment.raw) {
            data.raw = attachment.raw;
        } else if (attachment.path) {
            data.content = {
                path: attachment.path
            };
        } else if (attachment.href) {
            data.content = {
                href: attachment.href
            };
        } else {
            data.content = attachment.content || '';
        }

        if (attachment.encoding) {
            data.encoding = attachment.encoding;
        }

        if (attachment.headers) {
            data.headers = attachment.headers;
        }

        return data;
    }.bind(this));

    if (!findRelated) {
        return {
            attached: attachments,
            related: []
        };
    } else {
        return {
            attached: attachments.filter(function (attachment) {
                return !attachment.cid;
            }),
            related: attachments.filter(function (attachment) {
                return !!attachment.cid;
            })
        };
    }
};

/**
 * List alternatives. Resulting objects can be used as input for BuildMail nodes
 *
 * @returns {Array} An array of alternative elements. Includes the `text` and `html` values as well
 */
MailComposer.prototype._getAlternatives = function () {
    var alternatives = [],
        text, html, watchHtml, icalEvent;

    if (this.mail.text) {
        if (typeof this.mail.text === 'object' && (this.mail.text.content || this.mail.text.path || this.mail.text.href || this.mail.text.raw)) {
            text = this.mail.text;
        } else {
            text = {
                content: this.mail.text
            };
        }
        text.contentType = 'text/plain' + (!text.encoding && libmime.isPlainText(text.content) ? '' : '; charset=utf-8');
    }

    if (this.mail.watchHtml) {
        if (typeof this.mail.watchHtml === 'object' && (this.mail.watchHtml.content || this.mail.watchHtml.path || this.mail.watchHtml.href || this.mail.watchHtml.raw)) {
            watchHtml = this.mail.watchHtml;
        } else {
            watchHtml = {
                content: this.mail.watchHtml
            };
        }
        watchHtml.contentType = 'text/watch-html' + (!watchHtml.encoding && libmime.isPlainText(watchHtml.content) ? '' : '; charset=utf-8');
    }

    if (this.mail.icalEvent) {
        if (typeof this.mail.icalEvent === 'object' && (this.mail.icalEvent.content || this.mail.icalEvent.path || this.mail.icalEvent.href || this.mail.icalEvent.raw)) {
            icalEvent = this.mail.icalEvent;
        } else {
            icalEvent = {
                content: this.mail.icalEvent
            };
        }
        icalEvent.contentType = 'text/calendar; charset="utf-8"; method=' + (icalEvent.method || 'PUBLISH').toString().trim().toUpperCase();
        if (!icalEvent.headers) {
            icalEvent.headers = {};
        }
        icalEvent.headers['Content-Transfer-Encoding'] = 'base64';
    }

    if (this.mail.html) {
        if (typeof this.mail.html === 'object' && (this.mail.html.content || this.mail.html.path || this.mail.html.href || this.mail.html.raw)) {
            html = this.mail.html;
        } else {
            html = {
                content: this.mail.html
            };
        }
        html.contentType = 'text/html' + (!html.encoding && libmime.isPlainText(html.content) ? '' : '; charset=utf-8');
    }

    [].
    concat(text || []).
    concat(watchHtml || []).
    concat(html || []).
    concat(icalEvent || []).
    concat(this.mail.alternatives || []).
    forEach(function (alternative) {
        var data;

        if (/^data:/i.test(alternative.path || alternative.href)) {
            alternative = this._processDataUrl(alternative);
        }

        data = {
            contentType: alternative.contentType ||
                libmime.detectMimeType(alternative.filename || alternative.path || alternative.href || 'txt'),
            contentTransferEncoding: alternative.contentTransferEncoding
        };

        if (alternative.filename) {
            data.filename = alternative.filename;
        }

        if (/^https?:\/\//i.test(alternative.path)) {
            alternative.href = alternative.path;
            alternative.path = undefined;
        }

        if (alternative.raw) {
            data.raw = alternative.raw;
        } else if (alternative.path) {
            data.content = {
                path: alternative.path
            };
        } else if (alternative.href) {
            data.content = {
                href: alternative.href
            };
        } else {
            data.content = alternative.content || '';
        }

        if (alternative.encoding) {
            data.encoding = alternative.encoding;
        }

        if (alternative.headers) {
            data.headers = alternative.headers;
        }

        alternatives.push(data);
    }.bind(this));

    return alternatives;
};

/**
 * Parses data uri and converts it to a Buffer
 *
 * @param {Object} element Content element
 * @return {Object} Parsed element
 */
MailComposer.prototype._processDataUrl = function (element) {
    var parts = (element.path || element.href).match(/^data:((?:[^;]*;)*(?:[^,]*)),(.*)$/i);
    if (!parts) {
        return element;
    }

    element.content = /\bbase64$/i.test(parts[1]) ? new Buffer(parts[2], 'base64') : new Buffer(decodeURIComponent(parts[2]));

    if ('path' in element) {
        element.path = false;
    }

    if ('href' in element) {
        element.href = false;
    }

    parts[1].split(';').forEach(function (item) {
        if (/^\w+\/[^\/]+$/i.test(item)) {
            element.contentType = element.contentType || item.toLowerCase();
        }
    });

    return element;
};

}).call(this,require("buffer").Buffer)
},{"buffer":9,"buildmail":41,"libmime":65}],69:[function(require,module,exports){
'use strict';

var createQueue = require('./message-queue');
var SMTPConnection = require('smtp-connection');
var dns = require('dns');
var net = require('net');
var os = require('os');
var util = require('util');
var packageData = require('../package.json');
var EventEmitter = require('events').EventEmitter;
var shared = require('nodemailer-shared');

// Expose to the world
module.exports = function (options) {
    return new DirectMailer(options);
};

/**
 * Creates a new DirectMailer instance. Provides method 'send' to queue
 * outgoing e-mails. The queue is processed in the background.
 *
 * @constructor
 * @param {Object} [options] Optional options object
 */
function DirectMailer(options) {
    EventEmitter.call(this);
    this.options = options || {};
    this._queue = createQueue();
    this._started = false;
    this._lastId = 0;

    if (options && typeof options.getSocket === 'function') {
        this.getSocket = options.getSocket;
    }

    this.logger = shared.getLogger(this.options);

    // temporary object
    var connection = new SMTPConnection({});

    this.name = 'SMTP (direct)';
    this.version = packageData.version + '[client:' + connection.version + ']';
}
util.inherits(DirectMailer, EventEmitter);

// Adds a dynamic property 'length'
Object.defineProperty(DirectMailer.prototype, 'length', {
    get: function () {
        return this._queue._instantQueue.length + this._queue._sortedQueue.length;
    }
});

/**
 * Placeholder function for creating proxy sockets. This method immediatelly returns
 * without a socket
 *
 * @param {Object} options Connection options
 * @param {Function} callback Callback function to run with the socket keys
 */
DirectMailer.prototype.getSocket = function (options, callback) {
    // return immediatelly
    return callback(null, false);
};

/**
 * Adds an outgoing message to the queue. Recipient addresses are sorted
 * by the receiving domain and for every domain, a copy of the message is queued.
 *
 * If input is deemed invalid, an error is thrown, so be ready to catch these
 * when calling directmail.send(...)
 *
 * @param {Object} mail Mail object
 * @param {Function} callback Callback function
 */
DirectMailer.prototype.send = function (mail, callback) {

    var envelope = mail.data.envelope || mail.message.getEnvelope();
    var domainEnvelopes = {};

    if (!envelope.from) {
        return callback(new Error('"From" address missing'));
    }

    envelope.to = [].concat(envelope.to || []);

    if (!envelope.to.length) {
        return callback('"Recipients" addresses missing');
    }

    // We cant't run existing streams more than once so we need to change these
    // to buffers. Filenames, URLs etc are not affected  for every
    // message copy a new file stream will be created
    this._clearStreams(mail, function (err) {
        if (err) {
            return callback(err);
        }

        this._formatMessage(mail.message);

        envelope.to.forEach(function (recipient) {
            recipient = (recipient || '').toString();

            var domain = (recipient.split('@').pop() || '').toLowerCase().trim();

            if (!domainEnvelopes[domain]) {
                domainEnvelopes[domain] = {
                    from: envelope.from,
                    to: [recipient]
                };
            } else if (domainEnvelopes[domain].to.indexOf(recipient) < 0) {
                domainEnvelopes[domain].to.push(recipient);
            }
        });

        var returned = 0;
        var domains = Object.keys(domainEnvelopes);
        var combinedInfo = {
            accepted: [],
            rejected: [],
            pending: [],
            errors: [],
            envelope: mail.data.envelope || mail.message.getEnvelope()
        };

        domains.forEach((function (domain) {
            var called = false;
            var id = ++this._lastId;
            var item = {
                envelope: domainEnvelopes[domain],
                data: mail.data,
                message: mail.message,
                domain: domain,
                id: id,
                callback: function (err, info) {
                    if (called) {
                        this.logger.info('Callback for #%s already called. Updated values: %s', id, JSON.stringify(err || info));
                        return;
                    }

                    called = true;
                    returned++;

                    if (err) {
                        combinedInfo.errors.push(err);
                        if (err.recipients) {
                            combinedInfo.rejected = combinedInfo.rejected.concat(err.recipients || []);
                        }
                    } else if (info) {
                        combinedInfo.accepted = combinedInfo.accepted.concat(info.accepted || []);
                        combinedInfo.rejected = combinedInfo.rejected.concat(info.rejected || []);
                        combinedInfo.pending = combinedInfo.pending.concat(info.pending || []);
                        combinedInfo.messageId = info.messageId;
                    }

                    if (returned >= domains.length) {
                        if (combinedInfo.errors.length === domains.length) {
                            var error = new Error('Sending failed');
                            error.errors = combinedInfo.errors;
                            return callback(error);
                        } else {
                            return callback(null, combinedInfo);
                        }
                    }
                }.bind(this)
            };

            this._queue.insert(item);
        }).bind(this));

        // start send loop if needed
        if (!this._started) {
            this._started = true;

            // do not start the loop before current execution context is finished
            setImmediate(this._loop.bind(this));
        }

    }.bind(this));
};

/**
 * Looping function to fetch a message from the queue and send it.
 */
DirectMailer.prototype._loop = function () {

    // callback is fired when a message is added to the queue
    this._queue.get((function (data) {

        this.logger.info('Retrieved message #%s from the queue, resolving %s', data.id, data.domain);

        // Resolve destination MX server
        this._resolveMx(data.domain, (function (err, list) {

            if (err) {
                this.logger.info('Resolving %s for #%s failed', data.domain, data.id);
                this.logger.info(err);
            } else if (!list || !list.length) {
                this.logger.info('Could not resolve any MX servers for %s', data.domain);
            }
            if (err || !list || !list.length) {
                data.callback(err || new Error('Could not resolve MX for ' + data.domain));
                return setImmediate(this._loop.bind(this));
            }

            // Sort MX list by priority field
            list.sort(function (a, b) {
                return (a && a.priority || 0) - (b && b.priority || 0);
            });

            // Use the first server on the list
            var exchange = list[0] && list[0].exchange;

            this.logger.info('%s resolved to %s for #%s', data.domain, exchange, data.id);

            // Try to send the message
            this._process(exchange, data, (function (err, response) {
                if (err) {
                    this.logger.info('Failed processing message #%s', data.id);
                } else {
                    this.logger.info('Server responded for #%s: %s', data.id, JSON.stringify(response));
                }

                if (err) {
                    if (err.responseCode && err.responseCode >= 500) {
                        err.domain = data.domain;
                        err.exchange = exchange;
                        err.recipients = data.envelope.to;
                        data.callback(err);
                    } else {
                        data.replies = (data.replies || 0) + 1;
                        if (data.replies <= 5) {
                            this._queue.insert(data, this.options.retryDelay || data.replies * 15 * 60 * 1000);
                            this.logger.info('Message #%s requeued', data.id);
                            data.callback(null, {
                                pending: {
                                    domain: data.domain,
                                    exchange: exchange,
                                    recipients: data.envelope.to,
                                    response: err.response
                                }
                            });
                        } else {
                            err.domain = data.domain;
                            err.exchange = exchange;
                            err.recipients = data.envelope.to;
                            data.callback(err);
                        }
                    }
                } else {
                    data.callback(null, response);
                }

                setImmediate(this._loop.bind(this));
            }).bind(this));
        }).bind(this));
    }).bind(this));
};

/**
 * Sends a message to provided MX server
 *
 * @param {String} exchange MX server
 * @param {Object} data Message object
 * @param {Function} callback Callback to run once the message is either sent or sending fails
 */
DirectMailer.prototype._process = function (exchange, data, callback) {
    this.logger.info('Connecting to %s:%s for message #%s %s STARTTLS', exchange, this.options.port || 25, data.id, data.ignoreTLS ? 'without' : 'with');

    var options = {
        host: exchange,
        port: this.options.port || 25,
        requireTLS: !data.ignoreTLS,
        ignoreTLS: data.ignoreTLS,
        tls: {
            rejectUnauthorized: false
        }
    };

    // Add options from DirectMailer options to simplesmtp client
    Object.keys(this.options).forEach((function (key) {
        options[key] = this.options[key];
    }).bind(this));

    this.getSocket(options, function (err, socketOptions) {
        if (err) {
            return callback(err);
        }

        if (socketOptions && socketOptions.connection) {
            this.logger.info('Using proxied socket from %s:%s to %s:%s', socketOptions.connection.remoteAddress, socketOptions.connection.remotePort, options.host || '', options.port || '');
            Object.keys(socketOptions).forEach(function (key) {
                options[key] = socketOptions[key];
            });
        }

        var connection = new SMTPConnection(options);
        var returned = false;

        connection.once('error', function (err) {
            if (returned) {
                return;
            }
            returned = true;
            if (err.code === 'ETLS') {
                // STARTTLS failed, try again, this time without encryption
                data.ignoreTLS = true;
                return this._process(exchange, data, callback);
            }
            return callback(err);
        }.bind(this));

        var sendMessage = function () {
            var messageId = (data.message.getHeader('message-id') || '').replace(/[<>\s]/g, '');
            var recipients = [].concat(data.envelope.to || []);
            if (recipients.length > 3) {
                recipients.push('...and ' + recipients.splice(2).length + ' more');
            }

            this.logger.info('Sending message <%s> to <%s>', messageId, recipients.join(', '));
            connection.send(data.envelope, data.message.createReadStream(), function (err, info) {
                if (returned) {
                    return;
                }
                returned = true;

                connection.close();
                if (err) {
                    return callback(err);
                }

                info.messageId = (data.message.getHeader('message-id') || '').replace(/[<>\s]/g, '');
                return callback(null, info);
            });
        }.bind(this);

        connection.connect(function () {
            if (returned) {
                return;
            }
            sendMessage();
        }.bind(this));
    }.bind(this));
};

/**
 * Adds additional headers to the outgoing message
 *
 * @param {Object} message BuildMail message object
 */
DirectMailer.prototype._formatMessage = function (message) {
    var hostname = this._resolveHostname(this.options.name);

    // set the first header as 'Received:'
    message._headers.unshift({
        key: 'Received',
        value: 'from localhost (127.0.0.1) by ' + hostname + ' with SMTP; ' + Date()
    });
};

/**
 * Detects stream objects and resolves these to buffers before sending. File paths,
 * urls etc. are not affected.
 *
 * @param {Object} message BuildMail message object
 * @param {Function} callback Callback to run
 */
DirectMailer.prototype._clearStreams = function (mail, callback) {
    var streamNodes = [];

    function walkNode(node) {
        if (node.content && typeof node.content.pipe === 'function') {
            streamNodes.push(node);
        }
        if (node.childNodes && node.childNodes.length) {
            node.childNodes.forEach(walkNode);
        }
    }
    walkNode(mail.message);

    function resolveNodes() {
        if (!streamNodes.length) {
            return callback();
        }
        var node = streamNodes.shift();

        mail.resolveContent(node, 'content', function (err) {
            if (err) {
                return callback(err);
            }
            setImmediate(resolveNodes);
        });
    }

    resolveNodes();
};

/**
 * Resolves MX server for a domain. This solution is somewhat incomplete as
 * it only considers the hostname with lowest priority and ignores all the rest
 *
 * @param {String} domain Domain to resolve the MX to
 * @param {Function} callback Callback function to run
 */
DirectMailer.prototype._resolveMx = function (domain, callback) {
    domain = domain.replace(/^\[(ipv6:)?|\]$/gi, '');

    // Do not try to resolve the domain name if it is an IP address
    if (net.isIP(domain)) {
        return callback(null, [{
            priority: 0,
            exchange: domain
        }]);
    }

    dns.resolveMx(domain, function (err, list) {
        if (err) {
            if (err.code === 'ENODATA') {
                // fallback to A
                dns.resolve4(domain, function (err, list) {
                    if (err) {
                        if (err.code === 'ENODATA') {
                            // fallback to AAAA
                            dns.resolve6(domain, function (err, list) {
                                if (err) {
                                    return callback(err);
                                }

                                // return the first resolved Ipv6 with priority 0
                                return callback(null, [].concat(list || []).map(function (entry) {
                                    return {
                                        priority: 0,
                                        exchange: entry
                                    };
                                }).slice(0, 1));
                            });
                        } else {
                            return callback(err);
                        }
                        return;
                    }

                    // return the first resolved Ipv4 with priority 0
                    return callback(null, [].concat(list || []).map(function (entry) {
                        return {
                            priority: 0,
                            exchange: entry
                        };
                    }).slice(0, 1));
                });
            } else {
                return callback(err);
            }
            return;
        }
        callback(null, list);
    });
};

/**
 * Resolves current hostname. If resolved name is an IP address, uses 'localhost'.
 *
 * @param {String} [name] Preferred hostname
 * @return {String} Resolved hostname
 */
DirectMailer.prototype._resolveHostname = function (name) {
    if (!name || net.isIP(name.replace(/[\[\]]/g, '').trim())) {
        name = (os.hostname && os.hostname()) || '';
    }

    if (!name || net.isIP(name.replace(/[\[\]]/g, '').trim())) {
        name = 'localhost';
    }

    return name.toLowerCase();
};

},{"../package.json":71,"./message-queue":70,"dns":8,"events":16,"net":8,"nodemailer-shared":74,"os":91,"smtp-connection":85,"util":104}],70:[function(require,module,exports){
'use strict';

// expose to the world
module.exports = function () {
    return new MessageQueue();
};

/**
 * Creates a queue object
 *
 * @constructor
 */
function MessageQueue() {
    this._instantQueue = [];
    this._sortedQueue = [];
    this._shiftTimer = null;
    this._callbackQueue = [];
}

/**
 * Sets a callback to be run when something comes available from the queue
 *
 * @param {Function} callback Callback function to run with queue element as an argument
 */
MessageQueue.prototype.get = function (callback) {
    if (this._instantQueue.length) {
        return callback(this._instantQueue.pop());
    } else {
        this._callbackQueue.unshift(callback);
    }
};

/**
 * Adds an element to the queue. If delay (ms) is set, the data will not be available before
 * specified delay has passed. Otherwise the data will be available for processing immediatelly.
 *
 * @param {Mixed} data Value to be queued
 * @param {Number} [delay] If set, delay the availability of the data by {delay} milliseconds
 */
MessageQueue.prototype.insert = function (data, delay) {
    var container, added = -1;
    if (typeof delay !== 'number') {
        this._instantQueue.unshift(data);
        this._processInsert();
        return true;
    } else {
        container = {
            data: data,
            available: Date.now() + delay
        };
        for (var i = 0, len = this._sortedQueue.length; i < len; i++) {
            if (this._sortedQueue[i].available >= container.available) {
                this._sortedQueue.splice(i, 0, container);
                added = i;
                break;
            }
        }
        if (added < 0) {
            this._sortedQueue.push(container);
            added = 0;
        }

        if (added === 0) {
            this._updateShiftTimer();
        }
    }
};

/**
 * Clears previous timer and creates a new one (if needed) to process the element
 * in the queue that needs to be processed first.
 */
MessageQueue.prototype._updateShiftTimer = function () {
    var nextShift, now = Date.now();
    clearTimeout(this._shiftTimer);

    if (!this._sortedQueue.length) {
        return;
    }

    nextShift = this._sortedQueue[0].available;

    if (nextShift <= now) {
        this._shiftSorted();
    } else {
        setTimeout(this._shiftSorted.bind(this),
            // add +15ms to ensure that data is already available when the timer is fired
            this._sortedQueue[0].available - Date.now() + 15);
    }
};

/**
 * Moves an element from the delayed queue to the immediate queue if an elmenet
 * becomes avilable
 */
MessageQueue.prototype._shiftSorted = function () {
    var container;
    if (!this._sortedQueue.length) {
        return;
    }

    if (this._sortedQueue[0].available <= Date.now()) {
        container = this._sortedQueue.shift();
        this.insert(container.data);
    }

    this._updateShiftTimer();
};

/**
 * If data from a queue is available and a callback is set, run the callback
 * with available data
 */
MessageQueue.prototype._processInsert = function () {
    if (this._instantQueue.length && this._callbackQueue.length) {
        this._callbackQueue.pop()(this._instantQueue.pop());
    }
};

},{}],71:[function(require,module,exports){
module.exports={
  "_args": [
    [
      "nodemailer-direct-transport@https://registry.npmjs.org/nodemailer-direct-transport/-/nodemailer-direct-transport-3.1.0.tgz",
      "/Users/nhong/nickhong.io/node_modules/nodemailer"
    ]
  ],
  "_from": "nodemailer-direct-transport@3.1.0",
  "_id": "nodemailer-direct-transport@3.1.0",
  "_inCache": true,
  "_location": "/nodemailer/nodemailer-direct-transport",
  "_phantomChildren": {},
  "_requested": {
    "name": "nodemailer-direct-transport",
    "raw": "nodemailer-direct-transport@https://registry.npmjs.org/nodemailer-direct-transport/-/nodemailer-direct-transport-3.1.0.tgz",
    "rawSpec": "https://registry.npmjs.org/nodemailer-direct-transport/-/nodemailer-direct-transport-3.1.0.tgz",
    "scope": null,
    "spec": "https://registry.npmjs.org/nodemailer-direct-transport/-/nodemailer-direct-transport-3.1.0.tgz",
    "type": "remote"
  },
  "_requiredBy": [
    "/nodemailer"
  ],
  "_resolved": "https://registry.npmjs.org/nodemailer-direct-transport/-/nodemailer-direct-transport-3.1.0.tgz",
  "_shasum": "308b6f4c16000a3af1af1bb49eafd6a0b2747b62",
  "_shrinkwrap": null,
  "_spec": "nodemailer-direct-transport@https://registry.npmjs.org/nodemailer-direct-transport/-/nodemailer-direct-transport-3.1.0.tgz",
  "_where": "/Users/nhong/nickhong.io/node_modules/nodemailer",
  "author": {
    "name": "Andris Reinman"
  },
  "bugs": {
    "url": "https://github.com/andris9/nodemailer-direct-transport/issues"
  },
  "dependencies": {
    "nodemailer-shared": "1.0.5",
    "smtp-connection": "2.5.0"
  },
  "description": "Direct transport for Nodemailer",
  "devDependencies": {
    "chai": "^3.5.0",
    "grunt": "^1.0.1",
    "grunt-eslint": "^18.1.0",
    "grunt-mocha-test": "^0.12.7",
    "mocha": "^2.4.5",
    "smtp-server": "^1.9.1"
  },
  "homepage": "http://github.com/andris9/nodemailer-direct-transport",
  "keywords": [
    "SMTP",
    "Nodemailer"
  ],
  "license": "MIT",
  "main": "lib/direct-transport.js",
  "name": "nodemailer-direct-transport",
  "optionalDependencies": {},
  "readme": "# Direct SMTP transport module for Nodemailer\n\nApplies for Nodemailer v1.x and not for v0.x where transports are built-in.\n\n## Usage\n\nInstall with npm\n\n    npm install nodemailer-direct-transport\n\nRequire to your script\n\n```javascript\nvar nodemailer = require('nodemailer');\nvar directTransport = require('nodemailer-direct-transport');\n```\n\nCreate a Nodemailer transport object\n\n```javascript\nvar transporter = nodemailer.createTransport(directTransport(options))\n```\n\nWhere\n\n  * **options** defines connection data\n    * **options.name** hostname to be used when introducing the client to the MX server\n    * **options.logger** optional [bunyan](https://github.com/trentm/node-bunyan) compatible logger instance. If set to `true` then logs to console. If value is not set or is `false` then nothing is logged\n    * **options.debug** if set to true, then logs SMTP traffic, otherwise logs only transaction events\n    * **options.port** optional port to use for connecting to MX servers (defaults to MTA standard 25)\n    * **options.retryDelay** optional timeout in ms for retrying failed messages (defaults to 15 minutes)\n    * **getSocket** optional method that is called every time a new connection is made against the SMTP server. This method can provide an existing socket to be used instead of creating a new one\n\n**Example**\n\n```javascript\nvar transport = nodemailer.createTransport(directTransport({\n    name: 'smtp.example.com' // should be the hostname machine IP address resolves to\n}));\n```\n\n## send callback\n\nSend callback includes the following arguments\n\n  * **error** if the mail was not sent\n    * **error.errors** is an array of error responses (one response for one MX exchange)\n      * **error.errors[].recipients** an array of failed recipients\n      * **error.errors[].response** Error response from the SMTP server\n  * **info** if at least one mail was sent or is pending\n    * **info.accepted** an array of recipients that were accepted\n    * **info.rejected** an array of recipients that were rejected\n    * **info.pending** an array of pending recipient objects (messages that were not rejected permanently and are retried later)\n      * **info.pending[].recipients** an array of recipient addresses that are still pending\n      * **info.pending[].response** Response from the SMTP server\n    * **info.errors** An array of errors (for these exhanges that rejected mail)\n\n## Issues\n\nDirect transport is very inefficient as it queues all e-mails to be sent into memory. Additionally, if a message is not yet sent and the process is closed, all data about queued messages is lost. Thus direct transport is only suitable for low throughput systems, where the message can be processed immediately.\n\nWhile not being 100% reliable (remember - if process exits, entire queue is lost), direct transport can still handle sending errors, graylisting and such. If a message can not be sent, it is re-queued and retried later.\n\n## License\n\n**MIT**\n",
  "readmeFilename": "README.md",
  "repository": {
    "type": "git",
    "url": "git://github.com/andris9/nodemailer-direct-transport.git"
  },
  "scripts": {
    "test": "grunt"
  },
  "version": "3.1.0"
}

},{}],72:[function(require,module,exports){
'use strict';

// module to handle cookies

var urllib = require('url');

var SESSION_TIMEOUT = 1800; // 30 min

module.exports = Cookies;

/**
 * Creates a biskviit cookie jar for managing cookie values in memory
 *
 * @constructor
 * @param {Object} [options] Optional options object
 */
function Cookies(options) {
    this.options = options || {};
    this.cookies = [];
}

/**
 * Stores a cookie string to the cookie storage
 *
 * @param {String} cookieStr Value from the 'Set-Cookie:' header
 * @param {String} url Current URL
 */
Cookies.prototype.set = function (cookieStr, url) {
    var urlparts = urllib.parse(url || '');
    var cookie = this.parse(cookieStr);
    var domain;

    if (cookie.domain) {
        domain = cookie.domain.replace(/^\./, '');

        // do not allow cross origin cookies
        if (
            // can't be valid if the requested domain is shorter than current hostname
            urlparts.hostname.length < domain.length ||

            // prefix domains with dot to be sure that partial matches are not used
            ('.' + urlparts.hostname).substr(-domain.length + 1) !== ('.' + domain)) {
            cookie.domain = urlparts.hostname;
        }
    } else {
        cookie.domain = urlparts.hostname;
    }

    if (!cookie.path) {
        cookie.path = this.getPath(urlparts.pathname);
    }

    // if no expire date, then use sessionTimeout value
    if (!cookie.expires) {
        cookie.expires = new Date(Date.now() + (Number(this.options.sessionTimeout || SESSION_TIMEOUT) || SESSION_TIMEOUT) * 1000);
    }

    return this.add(cookie);
};

/**
 * Returns cookie string for the 'Cookie:' header.
 *
 * @param {String} url URL to check for
 * @returns {String} Cookie header or empty string if no matches were found
 */
Cookies.prototype.get = function (url) {
    return this.list(url).map(function (cookie) {
        return cookie.name + '=' + cookie.value;
    }).join('; ');
};

/**
 * Lists all valied cookie objects for the specified URL
 *
 * @param {String} url URL to check for
 * @returns {Array} An array of cookie objects
 */
Cookies.prototype.list = function (url) {
    var result = [];
    var i;
    var cookie;

    for (i = this.cookies.length - 1; i >= 0; i--) {
        cookie = this.cookies[i];

        if (this.isExpired(cookie)) {
            this.cookies.splice(i, i);
            continue;
        }

        if (this.match(cookie, url)) {
            result.unshift(cookie);
        }
    }

    return result;
};

/**
 * Parses cookie string from the 'Set-Cookie:' header
 *
 * @param {String} cookieStr String from the 'Set-Cookie:' header
 * @returns {Object} Cookie object
 */
Cookies.prototype.parse = function (cookieStr) {
    var cookie = {};

    (cookieStr || '').toString().split(';').forEach(function (cookiePart) {
        var valueParts = cookiePart.split('=');
        var key = valueParts.shift().trim().toLowerCase();
        var value = valueParts.join('=').trim();
        var domain;

        if (!key) {
            // skip empty parts
            return;
        }

        switch (key) {

            case 'expires':
                value = new Date(value);
                // ignore date if can not parse it
                if (value.toString() !== 'Invalid Date') {
                    cookie.expires = value;
                }
                break;

            case 'path':
                cookie.path = value;
                break;

            case 'domain':
                domain = value.toLowerCase();
                if (domain.length && domain.charAt(0) !== '.') {
                    domain = '.' + domain; // ensure preceeding dot for user set domains
                }
                cookie.domain = domain;
                break;

            case 'max-age':
                cookie.expires = new Date(Date.now() + (Number(value) || 0) * 1000);
                break;

            case 'secure':
                cookie.secure = true;
                break;

            case 'httponly':
                cookie.httponly = true;
                break;

            default:
                if (!cookie.name) {
                    cookie.name = key;
                    cookie.value = value;
                }
        }
    });

    return cookie;
};

/**
 * Checks if a cookie object is valid for a specified URL
 *
 * @param {Object} cookie Cookie object
 * @param {String} url URL to check for
 * @returns {Boolean} true if cookie is valid for specifiec URL
 */
Cookies.prototype.match = function (cookie, url) {
    var urlparts = urllib.parse(url || '');

    // check if hostname matches
    // .foo.com also matches subdomains, foo.com does not
    if (urlparts.hostname !== cookie.domain && (cookie.domain.charAt(0) !== '.' || ('.' + urlparts.hostname).substr(-cookie.domain.length) !== cookie.domain)) {
        return false;
    }

    // check if path matches
    var path = this.getPath(urlparts.pathname);
    if (path.substr(0, cookie.path.length) !== cookie.path) {
        return false;
    }

    // check secure argument
    if (cookie.secure && urlparts.protocol !== 'https:') {
        return false;
    }

    return true;
};

/**
 * Adds (or updates/removes if needed) a cookie object to the cookie storage
 *
 * @param {Object} cookie Cookie value to be stored
 */
Cookies.prototype.add = function (cookie) {
    var i;
    var len;

    // nothing to do here
    if (!cookie || !cookie.name) {
        return false;
    }

    // overwrite if has same params
    for (i = 0, len = this.cookies.length; i < len; i++) {
        if (this.compare(this.cookies[i], cookie)) {

            // check if the cookie needs to be removed instead
            if (this.isExpired(cookie)) {
                this.cookies.splice(i, 1); // remove expired/unset cookie
                return false;
            }

            this.cookies[i] = cookie;
            return true;
        }
    }

    // add as new if not already expired
    if (!this.isExpired(cookie)) {
        this.cookies.push(cookie);
    }

    return true;
};

/**
 * Checks if two cookie objects are the same
 *
 * @param {Object} a Cookie to check against
 * @param {Object} b Cookie to check against
 * @returns {Boolean} True, if the cookies are the same
 */
Cookies.prototype.compare = function (a, b) {
    return a.name === b.name && a.path === b.path && a.domain === b.domain && a.secure === b.secure && a.httponly === a.httponly;
};

/**
 * Checks if a cookie is expired
 *
 * @param {Object} cookie Cookie object to check against
 * @returns {Boolean} True, if the cookie is expired
 */
Cookies.prototype.isExpired = function (cookie) {
    return (cookie.expires && cookie.expires < new Date()) || !cookie.value;
};

/**
 * Returns normalized cookie path for an URL path argument
 *
 * @param {String} pathname
 * @returns {String} Normalized path
 */
Cookies.prototype.getPath = function (pathname) {
    var path = (pathname || '/').split('/');
    path.pop(); // remove filename part
    path = path.join('/').trim();

    // ensure path prefix /
    if (path.charAt(0) !== '/') {
        path = '/' + path;
    }

    // ensure path suffix /
    if (path.substr(-1) !== '/') {
        path += '/';
    }

    return path;
};

},{"url":30}],73:[function(require,module,exports){
(function (Buffer){
'use strict';

var http = require('http');
var https = require('https');
var urllib = require('url');
var zlib = require('zlib');
var PassThrough = require('stream').PassThrough;
var Cookies = require('./cookies');

var MAX_REDIRECTS = 5;

module.exports = function (url, options) {
    return fetch(url, options);
};

module.exports.Cookies = Cookies;

function fetch(url, options) {
    options = options || {};

    options.fetchRes = options.fetchRes || new PassThrough();
    options.cookies = options.cookies || new Cookies();
    options.redirects = options.redirects || 0;
    options.maxRedirects = isNaN(options.maxRedirects) ? MAX_REDIRECTS : options.maxRedirects;

    if (options.cookie) {
        [].concat(options.cookie || []).forEach(function (cookie) {
            options.cookies.set(cookie, url);
        });
        options.cookie = false;
    }

    var fetchRes = options.fetchRes;
    var parsed = urllib.parse(url);
    var method = (options.method || '').toString().trim().toUpperCase() || 'GET';
    var finished = false;
    var cookies;
    var body;

    var handler = parsed.protocol === 'https:' ? https : http;

    var headers = {
        'accept-encoding': 'gzip,deflate'
    };

    if (options.userAgent) {
        headers['User-Agent'] = options.userAgent;
    }

    if (parsed.auth) {
        headers.Authorization = 'Basic ' + new Buffer(parsed.auth).toString('base64');
    }

    if ((cookies = options.cookies.get(url))) {
        headers.cookie = cookies;
    }

    if (options.body) {
        if (options.body instanceof Buffer) {
            body = options.body;
        } else if (typeof options.body === 'object') {
            body = new Buffer(Object.keys(options.body).map(function (key) {
                var value = options.body[key].toString().trim();
                return encodeURIComponent(key) + '=' + encodeURIComponent(value);
            }).join('&'));
        } else {
            body = new Buffer(options.body.toString().trim());
        }

        headers['Content-Type'] = options.contentType || 'application/x-www-form-urlencoded';
        headers['Content-Length'] = body.length;

        // if method is not provided, use POST instead of GET
        method = (options.method || '').toString().trim().toUpperCase() || 'POST';
    }

    var req;
    var reqOptions = {
        method: method,
        host: parsed.hostname,
        path: parsed.path,
        port: parsed.port ? parsed.port : (parsed.protocol === 'https:' ? 443 : 80),
        headers: headers,
        rejectUnauthorized: false,
        agent: false
    };

    if (options.tls) {
        Object.keys(options.tls).forEach(function (key) {
            reqOptions[key] = options.tls[key];
        });
    }

    try {
        req = handler.request(reqOptions);
    } catch (E) {
        finished = true;
        setImmediate(function () {
            fetchRes.emit('error', E);
        });
        return fetchRes;
    }

    if (options.timeout) {
        req.setTimeout(options.timeout, function () {
            if (finished) {
                return;
            }
            finished = true;
            req.abort();
            fetchRes.emit('error', new Error('Request Tiemout'));
        });
    }

    req.on('error', function (err) {
        if (finished) {
            return;
        }
        finished = true;
        fetchRes.emit('error', err);
    });

    req.on('response', function (res) {
        var inflate;

        if (finished) {
            return;
        }

        switch (res.headers['content-encoding']) {
            case 'gzip':
            case 'deflate':
                inflate = zlib.createUnzip();
                break;
        }

        if (res.headers['set-cookie']) {
            [].concat(res.headers['set-cookie'] || []).forEach(function (cookie) {
                options.cookies.set(cookie, url);
            });
        }

        if ([301, 302, 303, 307, 308].indexOf(res.statusCode) >= 0 && res.headers.location) {
            // redirect
            options.redirects++;
            if (options.redirects > options.maxRedirects) {
                finished = true;
                fetchRes.emit('error', new Error('Maximum redirect count exceeded'));
                req.abort();
                return;
            }
            return fetch(urllib.resolve(url, res.headers.location), options);
        }

        if (res.statusCode >= 300) {
            finished = true;
            fetchRes.emit('error', new Error('Invalid status code ' + res.statusCode));
            req.abort();
            return;
        }

        res.on('error', function (err) {
            if (finished) {
                return;
            }
            finished = true;
            fetchRes.emit('error', err);
            req.abort();
        });

        if (inflate) {
            res.pipe(inflate).pipe(fetchRes);
            inflate.on('error', function (err) {
                if (finished) {
                    return;
                }
                finished = true;
                fetchRes.emit('error', err);
                req.abort();
            });
        } else {
            res.pipe(fetchRes);
        }
    });

    setImmediate(function () {
        if (body) {
            try {
                req.write(body);
            } catch (err) {
                finished = true;
                fetchRes.emit('error', err);
                return;
            }
        }
        req.end();
    });

    return fetchRes;
}

}).call(this,require("buffer").Buffer)
},{"./cookies":72,"buffer":9,"http":31,"https":34,"stream":23,"url":30,"zlib":4}],74:[function(require,module,exports){
(function (Buffer){
'use strict';

var urllib = require('url');
var util = require('util');
var fs = require('fs');
var fetch = require('nodemailer-fetch');

/**
 * Parses connection url to a structured configuration object
 *
 * @param {String} str Connection url
 * @return {Object} Configuration object
 */
module.exports.parseConnectionUrl = function (str) {
    str = str || '';
    var options = {};

    [urllib.parse(str, true)].forEach(function (url) {
        var auth;

        switch (url.protocol) {
            case 'smtp:':
                options.secure = false;
                break;
            case 'smtps:':
                options.secure = true;
                break;
            case 'direct:':
                options.direct = true;
                break;
        }

        if (!isNaN(url.port) && Number(url.port)) {
            options.port = Number(url.port);
        }

        if (url.hostname) {
            options.host = url.hostname;
        }

        if (url.auth) {
            auth = url.auth.split(':');

            if (!options.auth) {
                options.auth = {};
            }

            options.auth.user = auth.shift();
            options.auth.pass = auth.join(':');
        }

        Object.keys(url.query || {}).forEach(function (key) {
            var obj = options;
            var lKey = key;
            var value = url.query[key];

            if (!isNaN(value)) {
                value = Number(value);
            }

            switch (value) {
                case 'true':
                    value = true;
                    break;
                case 'false':
                    value = false;
                    break;
            }

            // tls is nested object
            if (key.indexOf('tls.') === 0) {
                lKey = key.substr(4);
                if (!options.tls) {
                    options.tls = {};
                }
                obj = options.tls;
            } else if (key.indexOf('.') >= 0) {
                // ignore nested properties besides tls
                return;
            }

            if (!(lKey in obj)) {
                obj[lKey] = value;
            }
        });
    });

    return options;
};

/**
 * Returns a bunyan-compatible logger interface. Uses either provided logger or
 * creates a default console logger
 *
 * @param {Object} [options] Options object that might include 'logger' value
 * @return {Object} bunyan compatible logger
 */
module.exports.getLogger = function (options) {
    options = options || {};

    if (!options.logger) {
        // use vanity logger
        return {
            info: function () {},
            debug: function () {},
            error: function () {}
        };
    }

    if (options.logger === true) {
        // create console logger
        return createDefaultLogger();
    }

    // return whatever was passed
    return options.logger;
};

/**
 * Wrapper for creating a callback than either resolves or rejects a promise
 * based on input
 *
 * @param {Function} resolve Function to run if callback is called
 * @param {Function} reject Function to run if callback ends with an error
 */
module.exports.callbackPromise = function (resolve, reject) {
    return function () {
        var args = Array.prototype.slice.call(arguments);
        var err = args.shift();
        if (err) {
            reject(err);
        } else {
            resolve.apply(null, args);
        }
    };
};

/**
 * Resolves a String or a Buffer value for content value. Useful if the value
 * is a Stream or a file or an URL. If the value is a Stream, overwrites
 * the stream object with the resolved value (you can't stream a value twice).
 *
 * This is useful when you want to create a plugin that needs a content value,
 * for example the `html` or `text` value as a String or a Buffer but not as
 * a file path or an URL.
 *
 * @param {Object} data An object or an Array you want to resolve an element for
 * @param {String|Number} key Property name or an Array index
 * @param {Function} callback Callback function with (err, value)
 */
module.exports.resolveContent = function (data, key, callback) {
    var promise;

    if (!callback && typeof Promise === 'function') {
        promise = new Promise(function (resolve, reject) {
            callback = module.exports.callbackPromise(resolve, reject);
        });
    }

    var content = data && data[key] && data[key].content || data[key];
    var contentStream;
    var encoding = (typeof data[key] === 'object' && data[key].encoding || 'utf8')
        .toString()
        .toLowerCase()
        .replace(/[-_\s]/g, '');

    if (!content) {
        return callback(null, content);
    }

    if (typeof content === 'object') {
        if (typeof content.pipe === 'function') {
            return resolveStream(content, function (err, value) {
                if (err) {
                    return callback(err);
                }
                // we can't stream twice the same content, so we need
                // to replace the stream object with the streaming result
                data[key] = value;
                callback(null, value);
            });
        } else if (/^https?:\/\//i.test(content.path || content.href)) {
            contentStream = fetch(content.path || content.href);
            return resolveStream(contentStream, callback);
        } else if (/^data:/i.test(content.path || content.href)) {
            var parts = (content.path || content.href).match(/^data:((?:[^;]*;)*(?:[^,]*)),(.*)$/i);
            if (!parts) {
                return callback(null, new Buffer(0));
            }
            return callback(null, /\bbase64$/i.test(parts[1]) ? new Buffer(parts[2], 'base64') : new Buffer(decodeURIComponent(parts[2])));
        } else if (content.path) {
            return resolveStream(fs.createReadStream(content.path), callback);
        }
    }

    if (typeof data[key].content === 'string' && ['utf8', 'usascii', 'ascii'].indexOf(encoding) < 0) {
        content = new Buffer(data[key].content, encoding);
    }

    // default action, return as is
    setImmediate(callback.bind(null, null, content));

    return promise;
};

/**
 * Streams a stream value into a Buffer
 *
 * @param {Object} stream Readable stream
 * @param {Function} callback Callback function with (err, value)
 */
function resolveStream(stream, callback) {
    var responded = false;
    var chunks = [];
    var chunklen = 0;

    stream.on('error', function (err) {
        if (responded) {
            return;
        }

        responded = true;
        callback(err);
    });

    stream.on('readable', function () {
        var chunk;
        while ((chunk = stream.read()) !== null) {
            chunks.push(chunk);
            chunklen += chunk.length;
        }
    });

    stream.on('end', function () {
        if (responded) {
            return;
        }
        responded = true;

        var value;

        try {
            value = Buffer.concat(chunks, chunklen);
        } catch (E) {
            return callback(E);
        }
        callback(null, value);
    });
}

/**
 * Generates a bunyan-like logger that prints to console
 *
 * @returns {Object} Bunyan logger instance
 */
function createDefaultLogger() {

    var logger = {
        _print: function ( /* level, message */ ) {
            var args = Array.prototype.slice.call(arguments);
            var level = args.shift();
            var message;

            if (args.length > 1) {
                message = util.format.apply(util, args);
            } else {
                message = args.shift();
            }

            console.log('[%s] %s: %s',
                new Date().toISOString().substr(0, 19).replace(/T/, ' '),
                level.toUpperCase(),
                message);
        }
    };

    logger.info = logger._print.bind(null, 'info');
    logger.debug = logger._print.bind(null, 'debug');
    logger.error = logger._print.bind(null, 'error');

    return logger;
}

}).call(this,require("buffer").Buffer)
},{"buffer":9,"fs":8,"nodemailer-fetch":73,"url":30,"util":104}],75:[function(require,module,exports){
'use strict';

module.exports = assign;

/**
 * Copies properties from source objects to target objects
 */
function assign( /* target, ... sources */ ) {
    var args = Array.prototype.slice.call(arguments);
    var target = args.shift() || {};

    args.forEach(function (source) {
        Object.keys(source || {}).forEach(function (key) {
            if (['tls', 'auth'].indexOf(key) >= 0 && source[key] && typeof source[key] === 'object') {
                // tls and auth are special keys that need to be enumerated separately
                // other objects are passed as is
                if (!target[key]) {
                    // esnure that target has this key
                    target[key] = {};
                }
                Object.keys(source[key]).forEach(function (subKey) {
                    target[key][subKey] = source[key][subKey];
                });
            } else {
                target[key] = source[key];
            }
        });
    });
    return target;
}

},{}],76:[function(require,module,exports){
'use strict';

var SMTPConnection = require('smtp-connection');
var assign = require('./assign');
var EventEmitter = require('events').EventEmitter;
var util = require('util');

module.exports = PoolResource;

/**
 * Creates an element for the pool
 *
 * @constructor
 * @param {Object} options SMTPPool instance
 */
function PoolResource(pool) {
    EventEmitter.call(this);
    this.pool = pool;
    this.options = pool.options;

    this.logger = this.options.logger;

    this._connection = false;
    this._connected = false;

    this.messages = 0;
    this.available = true;
}
util.inherits(PoolResource, EventEmitter);

/**
 * Initiates a connection to the SMTP server
 *
 * @param {Function} callback Callback function to run once the connection is established or failed
 */
PoolResource.prototype.connect = function (callback) {
    this.pool.getSocket(this.options, function (err, socketOptions) {
        if (err) {
            return callback(err);
        }

        var returned = false;
        var options = this.options;
        if (socketOptions && socketOptions.connection) {
            this.logger.info('Using proxied socket from %s:%s to %s:%s', socketOptions.connection.remoteAddress, socketOptions.connection.remotePort, options.host || '', options.port || '');
            options = assign(false, options);
            Object.keys(socketOptions).forEach(function (key) {
                options[key] = socketOptions[key];
            });
        }

        this.connection = new SMTPConnection(options);

        this.connection.once('error', function (err) {
            this.emit('error', err);
            if (returned) {
                return;
            }
            returned = true;
            return callback(err);
        }.bind(this));

        this.connection.once('end', function () {
            this.close();
            if (returned) {
                return;
            }
            returned = true;
            return callback();
        }.bind(this));

        this.connection.connect(function () {
            if (returned) {
                return;
            }

            if (this.options.auth) {
                this.connection.login(this.options.auth, function (err) {
                    if (returned) {
                        return;
                    }
                    returned = true;

                    if (err) {
                        this.connection.close();
                        this.emit('error', err);
                        return callback(err);
                    }

                    this._connected = true;
                    callback(null, true);
                }.bind(this));
            } else {
                returned = true;
                this._connected = true;
                return callback(null, true);
            }
        }.bind(this));
    }.bind(this));
};

/**
 * Sends an e-mail to be sent using the selected settings
 *
 * @param {Object} mail Mail object
 * @param {Function} callback Callback function
 */
PoolResource.prototype.send = function (mail, callback) {
    if (!this._connected) {
        this.connect(function (err) {
            if (err) {
                return callback(err);
            }
            this.send(mail, callback);
        }.bind(this));
        return;
    }

    var envelope = mail.data.envelope || mail.message.getEnvelope();
    var messageId = (mail.message.getHeader('message-id') || '').replace(/[<>\s]/g, '');
    var recipients = [].concat(envelope.to || []);
    if (recipients.length > 3) {
        recipients.push('...and ' + recipients.splice(2).length + ' more');
    }

    this.logger.info('Sending message <%s> using #%s to <%s>', messageId, this.id, recipients.join(', '));

    this.connection.send(envelope, mail.message.createReadStream(), function (err, info) {
        this.messages++;

        if (err) {
            this.connection.close();
            this.emit('error', err);
            return callback(err);
        }

        info.envelope = {
            from: envelope.from,
            to: envelope.to
        };
        info.messageId = messageId;

        setImmediate(function () {
            var err;
            if (this.messages >= this.options.maxMessages) {
                err = new Error('Resource exhausted');
                err.code = 'EMAXLIMIT';
                this.connection.close();
                this.emit('error', err);
            } else {
                this.pool._checkRateLimit(function () {
                    this.available = true;
                    this.emit('available');
                }.bind(this));
            }
        }.bind(this));

        callback(null, info);
    }.bind(this));
};

/**
 * Closes the connection
 */
PoolResource.prototype.close = function () {
    this._connected = false;
    if (this.connection) {
        this.connection.close();
    }
    this.emit('close');
};

},{"./assign":75,"events":16,"smtp-connection":85,"util":104}],77:[function(require,module,exports){
'use strict';

var SMTPConnection = require('smtp-connection');
var packageData = require('../package.json');
var wellknown = require('nodemailer-wellknown');
var assign = require('./assign');
var PoolResource = require('./pool-resource');
var EventEmitter = require('events').EventEmitter;
var util = require('util');
var shared = require('nodemailer-shared');

// expose to the world
module.exports = function (options) {
    return new SMTPPool(options);
};

/**
 * Creates a SMTP pool transport object for Nodemailer
 *
 * @constructor
 * @param {Object} options SMTP Connection options
 */
function SMTPPool(options) {
    EventEmitter.call(this);

    options = options || {};
    if (typeof options === 'string') {
        options = {
            url: options
        };
    }

    var urlData;
    var service = options.service;

    if (typeof options.getSocket === 'function') {
        this.getSocket = options.getSocket;
    }

    if (options.url) {
        urlData = shared.parseConnectionUrl(options.url);
        service = service || urlData.service;
    }

    this.options = assign(
        false, // create new object
        options, // regular options
        urlData, // url options
        service && wellknown(service) // wellknown options
    );

    this.options.maxConnections = this.options.maxConnections || 5;
    this.options.maxMessages = this.options.maxMessages || 100;

    this.logger = this.options.logger = shared.getLogger(this.options);

    // temporary object
    var connection = new SMTPConnection(this.options);

    this.name = 'SMTP (pool)';
    this.version = packageData.version + '[client:' + connection.version + ']';

    this._rateLimit = {
        counter: 0,
        timeout: null,
        waiting: [],
        checkpoint: false
    };
    this._closed = false;
    this._queue = [];
    this._connections = [];
    this._connectionCounter = 0;

    this.idling = true;

    setImmediate(function () {
        if (this.idling) {
            this.emit('idle');
        }
    }.bind(this));
}
util.inherits(SMTPPool, EventEmitter);

/**
 * Placeholder function for creating proxy sockets. This method immediatelly returns
 * without a socket
 *
 * @param {Object} options Connection options
 * @param {Function} callback Callback function to run with the socket keys
 */
SMTPPool.prototype.getSocket = function (options, callback) {
    // return immediatelly
    return callback(null, false);
};

/**
 * Queues an e-mail to be sent using the selected settings
 *
 * @param {Object} mail Mail object
 * @param {Function} callback Callback function
 */
SMTPPool.prototype.send = function (mail, callback) {
    if (this._closed) {
        return false;
    }

    this._queue.push({
        mail: mail,
        callback: callback
    });

    if (this.idling && this._queue.length >= this.options.maxConnections) {
        this.idling = false;
    }

    setImmediate(this._processMessages.bind(this));

    return true;
};

/**
 * Closes all connections in the pool. If there is a message being sent, the connection
 * is closed later
 */
SMTPPool.prototype.close = function () {
    var connection;
    var len = this._connections.length;
    this._closed = true;

    // clear rate limit timer if it exists
    clearTimeout(this._rateLimit.timeout);

    // remove all available connections
    for (var i = len - 1; i >= 0; i--) {
        if (this._connections[i] && this._connections[i].available) {
            connection = this._connections[i];
            connection.close();
            this.logger.info('Connection #%s removed', connection.id);
        }
    }

    if (len && !this._connections.length) {
        this.logger.debug('All connections removed');
    }

    // make sure that entire queue would be cleaned
    var invokeCallbacks = function () {
        if (!this._queue.length) {
            this.logger.debug('Pending queue elements cleared');
            return;
        }
        var element = this._queue.shift();
        if (element && typeof element.callback === 'function') {
            try {
                element.callback(new Error('Connection pool was closed'));
            } catch (E) {
                this.logger.error('Callback error for #%s: %s', connection.id, E.message);
            }
        }
        setImmediate(invokeCallbacks);
    }.bind(this);
    setImmediate(invokeCallbacks);
};

/**
 * Check the queue and available connections. If there is a message to be sent and there is
 * an available connection, then use this connection to send the mail
 */
SMTPPool.prototype._processMessages = function () {
    var connection;
    var i, len;

    // do nothing if already closed
    if (this._closed) {
        return;
    }

    // do nothing if queue is empty
    if (!this._queue.length) {
        if (!this.idling) {
            // no pending jobs
            this.idling = true;
            this.emit('idle');
        }
        return;
    }

    // find first available connection
    for (i = 0, len = this._connections.length; i < len; i++) {
        if (this._connections[i].available) {
            connection = this._connections[i];
            break;
        }
    }

    if (!connection && this._connections.length < this.options.maxConnections) {
        connection = this._createConnection();
    }

    if (!connection) {
        // no more free connection slots available
        this.idling = false;
        return;
    }

    // check if there is free space in the processing queue
    if (!this.idling && this._queue.length < this.options.maxConnections) {
        this.idling = true;
        this.emit('idle');
    }

    var element = connection.queueElement = this._queue.shift();
    element.messageId = (connection.queueElement.mail.message.getHeader('message-id') || '').replace(/[<>\s]/g, '');

    connection.available = false;

    this.logger.debug('Assigned message <%s> to #%s (%s)', element.messageId, connection.id, connection.messages + 1);

    if (this.options.rateLimit) {
        this._rateLimit.counter++;
        if (!this._rateLimit.checkpoint) {
            this._rateLimit.checkpoint = Date.now();
        }
    }

    connection.send(element.mail, function (err, info) {
        // only process callback if current handler is not changed
        if (element === connection.queueElement) {
            try {
                element.callback(err, info);
            } catch (E) {
                this.logger.error('Callback error for #%s: %s', connection.id, E.message);
            }
            connection.queueElement = false;
        }
    }.bind(this));
};

/**
 * Creates a new pool resource
 */
SMTPPool.prototype._createConnection = function () {
    var connection = new PoolResource(this);

    connection.id = ++this._connectionCounter;

    this.logger.info('Created new pool resource #%s', connection.id);

    // resource comes available
    connection.on('available', function () {
        this.logger.debug('Connection #%s became available', connection.id);

        if (this._closed) {
            // if already closed run close() that will remove this connections from connections list
            this.close();
        } else {
            // check if there's anything else to send
            this._processMessages();
        }
    }.bind(this));

    // resource is terminated with an error
    connection.once('error', function (err) {
        if (err.code !== 'EMAXLIMIT') {
            this.logger.error('Pool Error for #%s: %s', connection.id, err.message);
        } else {
            this.logger.debug('Max messages limit exchausted for #%s', connection.id);
        }

        if (connection.queueElement) {
            try {
                connection.queueElement.callback(err);
            } catch (E) {
                this.logger.error('Callback error for #%s: %s', connection.id, E.message);
            }
            connection.queueElement = false;
        }

        // remove the erroneus connection from connections list
        this._removeConnection(connection);

        this._continueProcessing();
    }.bind(this));

    connection.once('close', function () {
        this.logger.info('Connection #%s was closed', connection.id);

        this._removeConnection(connection);

        if (connection.queueElement) {
            // If the connection closed when sending, add the message to the queue again
            // Note that we must wait a bit.. because the callback of the 'error' handler might be called
            // in the next event loop
            setTimeout(function () {
                if (connection.queueElement) {
                    this.logger.debug('Re-queued message <%s> for #%s', connection.queueElement.messageId, connection.id);
                    this._queue.unshift(connection.queueElement);
                    connection.queueElement = false;
                }
                this._continueProcessing();
            }.bind(this), 50);
        } else {
            this._continueProcessing();
        }
    }.bind(this));

    this._connections.push(connection);

    return connection;
};

/**
 * Continue to process message if the pool hasn't closed
 */
SMTPPool.prototype._continueProcessing = function () {
    if (this._closed) {
        this.close();
    } else {
        setTimeout(this._processMessages.bind(this), 100);
    }
};

/**
 * Remove resource from pool
 *
 * @param {Object} connection The PoolResource to remove
 */
SMTPPool.prototype._removeConnection = function (connection) {
    var index = this._connections.indexOf(connection);

    if (index !== -1) {
        this._connections.splice(index, 1);
    }
};

/**
 * Checks if connections have hit current rate limit and if so, queues the availability callback
 *
 * @param {Function} callback Callback function to run once rate limiter has been cleared
 */
SMTPPool.prototype._checkRateLimit = function (callback) {
    if (!this.options.rateLimit) {
        return callback();
    }

    var now = Date.now();

    if (this._rateLimit.counter < this.options.rateLimit) {
        return callback();
    }

    this._rateLimit.waiting.push(callback);

    if (this._rateLimit.checkpoint <= now - 1000) {
        return this._clearRateLimit();
    } else if (!this._rateLimit.timeout) {
        this._rateLimit.timeout = setTimeout(this._clearRateLimit.bind(this), 1000 - (now - this._rateLimit.checkpoint));
        this._rateLimit.checkpoint = now;
    }
};

/**
 * Clears current rate limit limitation and runs paused callback
 */
SMTPPool.prototype._clearRateLimit = function () {
    clearTimeout(this._rateLimit.timeout);
    this._rateLimit.timeout = null;
    this._rateLimit.counter = 0;
    this._rateLimit.checkpoint = false;

    // resume all paused connections
    while (this._rateLimit.waiting.length) {
        var cb = this._rateLimit.waiting.shift();
        setImmediate(cb);
    }
};

/**
 * Returns true if there are free slots in the queue
 */
SMTPPool.prototype.isIdle = function () {
    return this.idling;
};

/**
 * Verifies SMTP configuration
 *
 * @param {Function} callback Callback function
 */
SMTPPool.prototype.verify = function (callback) {
    var promise;

    if (!callback && typeof Promise === 'function') {
        promise = new Promise(function (resolve, reject) {
            callback = shared.callbackPromise(resolve, reject);
        });
    }

    this.getSocket(this.options, function (err, socketOptions) {
        if (err) {
            return callback(err);
        }

        var options = this.options;
        if (socketOptions && socketOptions.connection) {
            this.logger.info('Using proxied socket from %s:%s to %s:%s', socketOptions.connection.remoteAddress, socketOptions.connection.remotePort, options.host || '', options.port || '');
            options = assign(false, options);
            Object.keys(socketOptions).forEach(function (key) {
                options[key] = socketOptions[key];
            });
        }

        var connection = new SMTPConnection(options);
        var returned = false;

        connection.once('error', function (err) {
            if (returned) {
                return;
            }
            returned = true;
            connection.close();
            return callback(err);
        });

        connection.once('end', function () {
            if (returned) {
                return;
            }
            returned = true;
            return callback(new Error('Connection closed'));
        });

        var finalize = function () {
            if (returned) {
                return;
            }
            returned = true;
            connection.quit();
            return callback(null, true);
        };

        connection.connect(function () {
            if (returned) {
                return;
            }

            if (this.options.auth) {
                connection.login(this.options.auth, function (err) {
                    if (returned) {
                        return;
                    }

                    if (err) {
                        returned = true;
                        connection.close();
                        return callback(err);
                    }

                    finalize();
                });
            } else {
                finalize();
            }
        }.bind(this));
    }.bind(this));

    return promise;
};

},{"../package.json":78,"./assign":75,"./pool-resource":76,"events":16,"nodemailer-shared":74,"nodemailer-wellknown":81,"smtp-connection":85,"util":104}],78:[function(require,module,exports){
module.exports={
  "_args": [
    [
      "nodemailer-smtp-pool@https://registry.npmjs.org/nodemailer-smtp-pool/-/nodemailer-smtp-pool-2.6.0.tgz",
      "/Users/nhong/nickhong.io/node_modules/nodemailer"
    ]
  ],
  "_from": "nodemailer-smtp-pool@2.6.0",
  "_id": "nodemailer-smtp-pool@2.6.0",
  "_inCache": true,
  "_location": "/nodemailer/nodemailer-smtp-pool",
  "_phantomChildren": {},
  "_requested": {
    "name": "nodemailer-smtp-pool",
    "raw": "nodemailer-smtp-pool@https://registry.npmjs.org/nodemailer-smtp-pool/-/nodemailer-smtp-pool-2.6.0.tgz",
    "rawSpec": "https://registry.npmjs.org/nodemailer-smtp-pool/-/nodemailer-smtp-pool-2.6.0.tgz",
    "scope": null,
    "spec": "https://registry.npmjs.org/nodemailer-smtp-pool/-/nodemailer-smtp-pool-2.6.0.tgz",
    "type": "remote"
  },
  "_requiredBy": [
    "/nodemailer"
  ],
  "_resolved": "https://registry.npmjs.org/nodemailer-smtp-pool/-/nodemailer-smtp-pool-2.6.0.tgz",
  "_shasum": "c407140db12b2b0b705089b02573db3868a919ac",
  "_shrinkwrap": null,
  "_spec": "nodemailer-smtp-pool@https://registry.npmjs.org/nodemailer-smtp-pool/-/nodemailer-smtp-pool-2.6.0.tgz",
  "_where": "/Users/nhong/nickhong.io/node_modules/nodemailer",
  "author": {
    "name": "Andris Reinman"
  },
  "bugs": {
    "url": "https://github.com/andris9/nodemailer-smtp-pool/issues"
  },
  "dependencies": {
    "nodemailer-shared": "1.0.5",
    "nodemailer-wellknown": "0.1.9",
    "smtp-connection": "2.5.0"
  },
  "description": "SMTP transport for Nodemailer",
  "devDependencies": {
    "chai": "^3.5.0",
    "grunt": "^1.0.1",
    "grunt-eslint": "^18.1.0",
    "grunt-mocha-test": "^0.12.7",
    "mocha": "^2.4.5",
    "smtp-server": "^1.9.1"
  },
  "homepage": "http://github.com/andris9/nodemailer-smtp-pool",
  "keywords": [
    "SMTP",
    "Nodemailer"
  ],
  "license": "MIT",
  "main": "lib/smtp-pool.js",
  "name": "nodemailer-smtp-pool",
  "optionalDependencies": {},
  "readme": "# SMTP transport module for Nodemailer\n\nApplies for Nodemailer v1.x and not for v0.x where transports are built-in.\n\n## Usage\n\nInstall with npm\n\n    npm install nodemailer-smtp-pool\n\nRequire to your script\n\n```javascript\nvar nodemailer = require('nodemailer');\nvar smtpPool = require('nodemailer-smtp-pool');\n```\n\nCreate a Nodemailer transport object\n\n```javascript\nvar transporter = nodemailer.createTransport(smtpPool(options))\n```\n\nWhere\n\n  * **options** defines connection data\n    * **options.port** is the port to connect to (defaults to 25 or 465)\n    * **options.host** is the hostname or IP address to connect to (defaults to 'localhost')\n    * **options.secure** defines if the connection should use SSL (if `true`) or not (if `false`)\n    * **options.auth** defines authentication data (see [authentication](#authentication) section below)\n    * **options.ignoreTLS** turns off STARTTLS support if true\n    * **options.name** optional hostname of the client, used for identifying to the server\n    * **options.localAddress** is the local interface to bind to for network connections\n    * **options.connectionTimeout** how many milliseconds to wait for the connection to establish\n    * **options.greetingTimeout** how many milliseconds to wait for the greeting after connection is established\n    * **options.socketTimeout** how many milliseconds of inactivity to allow\n    * **options.logger** optional [bunyan](https://github.com/trentm/node-bunyan) compatible logger instance. If set to `true` then logs to console. If value is not set or is `false` then nothing is logged\n    * **options.debug** if set to true, then logs SMTP traffic, otherwise logs only transaction events\n    * **options.authMethod** defines preferred authentication method, eg. 'PLAIN'\n    * **options.tls** defines additional options to be passed to the socket constructor, eg. *{rejectUnauthorized: true}*\n    * **maxConnections** (defaults to 5) is the count of maximum simultaneous connections to make against the SMTP server\n    * **maxMessages** (defaults to 100) limits the message count to be sent using a single connection. After maxMessages messages the connection is dropped and a new one is created for the following messages\n    * **rateLimit** (defaults to `false`) limits the message count to be sent in a second. Once rateLimit is reached, sending is paused until the end of the second. This limit is shared between connections, so if one connection uses up the limit, then other connections are paused as well\n    * **getSocket** optional method that is called every time a new connection is made against the SMTP server. This method can provide an existing socket to be used instead of creating a new one\n\nAlternatively you can use connection url with protocol 'smtp:' or 'smtps:'. Use query arguments for additional configuration values.\n\nPooled SMTP transport uses the same options as [SMTP transport](https://github.com/andris9/nodemailer-smtp-transport) with the addition of **maxConnections** and **maxMessages**.\n\n**Example**\n\n```javascript\nvar transport = nodemailer.createTransport(smtpPool({\n    host: 'localhost',\n    port: 25,\n    auth: {\n        user: 'username',\n        pass: 'password'\n    },\n    // use up to 5 parallel connections\n    maxConnections: 5,\n    // do not send more than 10 messages per connection\n    maxMessages: 10,\n    // no not send more than 5 messages in a second\n    rateLimit: 5\n}));\n```\n\nOr with connection url (gmail)\n\n```javascript\nvar transporter = nodemailer.createTransport(\n    smtpTransport('smtps://username%40gmail.com:password@smtp.gmail.com')\n);\n```\n\n## Events\n\nThe following events are emitted by this transport\n\n### Event: 'idle'\n\nEmitted if there are free slots in the connection pool.\nCheck with `.isIdle()` method if these free slots are still available.\nUsing this method makes sense if you maintain your own queue (for example pull from some queue service).\n\n```javascript\nvar messages = [...'list of messages'];\ntransporter.on('idle', function(){\n    // send next messages from the pending queue\n    while(transporter.isIdle() && messages.length){\n        transporter.send(messages.shift());\n    }\n});\n```\n\n## Authentication\n\nIf authentication data is not present, the connection is considered authenticated from the start.\n\nSet authentcation data with `options.auth`\n\nWhere\n\n  * **auth** is the authentication object\n    * **auth.user** is the username\n    * **auth.pass** is the password for the user\n    * **auth.xoauth2** is the OAuth2 access token (preferred if both `pass` and `xoauth2` values are set) or an [XOAuth2](https://github.com/andris9/xoauth2) token generator object.\n\nIf a [XOAuth2](https://github.com/andris9/xoauth2) token generator is used as the value for `auth.xoauth2` then you do not need to set the value for `auth.user`. XOAuth2 generator generates required `accessToken` itself if it is missing or expired. In this case if the authentication fails, a new token is requested and the authentication is retried once. If it still fails, an error is returned.\n\nInstall xoauth2 module to use XOauth2 token generators (not included by default)\n\n    npm install xoauth2 --save\n\n**XOAuth2 Example**\n\n> **NB!** The correct OAuth2 scope for Gmail is `https://mail.google.com/`\n\n```javascript\nvar generator = require('xoauth2').createXOAuth2Generator({\n    user: '{username}',\n    clientId: '{Client ID}',\n    clientSecret: '{Client Secret}',\n    refreshToken: '{refresh-token}',\n    accessToken: '{cached access token}' // optional\n});\n\n// listen for token updates\n// you probably want to store these to a db\ngenerator.on('token', function(token){\n    console.log('New token for %s: %s', token.user, token.accessToken);\n});\n\n// login\nvar transport = nodemailer.createTransport(smtpPool({\n    service: 'gmail',\n    auth: {\n        xoauth2: generator\n    },\n    maxConnections: 5,\n    maxMessages: 10\n}));\n```\n\n## Using well-known services\n\nIf you do not want to specify the hostname, port and security settings for a well known service, you can use it by its name (case insensitive).\n\n```javascript\nsmtpPool({\n    service: 'gmail',\n    auth: ..\n});\n```\n\nSee the list of all supported services [here](https://github.com/andris9/nodemailer-wellknown#supported-services).\n\n## Close the pool\n\nClose all connections with `close()`\n\n```javascript\ntransport.close();\n```\n\n## Verify connection configuration\n\nYou can verify your configuration with `verify(callback)` call. If it returns an error, then something is not correct, otherwise the server is ready to accept messages.\n\n```javascript\n// verify connection configuration\ntransporter.verify(function(error, success) {\n   if (error) {\n        console.log(error);\n   } else {\n        console.log('Server is ready to take our messages');\n   }\n});\n```\n\n## License\n\n**MIT**\n",
  "readmeFilename": "README.md",
  "repository": {
    "type": "git",
    "url": "git://github.com/andris9/nodemailer-smtp-pool.git"
  },
  "scripts": {
    "test": "grunt"
  },
  "version": "2.6.0"
}

},{}],79:[function(require,module,exports){
'use strict';

var SMTPConnection = require('smtp-connection');
var packageData = require('../package.json');
var wellknown = require('nodemailer-wellknown');
var shared = require('nodemailer-shared');

var EventEmitter = require('events').EventEmitter;
var util = require('util');

// expose to the world
module.exports = function (options) {
    return new SMTPTransport(options);
};

/**
 * Creates a SMTP transport object for Nodemailer
 *
 * @constructor
 * @param {Object} options Connection options
 */
function SMTPTransport(options) {
    EventEmitter.call(this);

    options = options || {};
    if (typeof options === 'string') {
        options = {
            url: options
        };
    }

    var urlData;
    var service = options.service;

    if (typeof options.getSocket === 'function') {
        this.getSocket = options.getSocket;
    }

    if (options.url) {
        urlData = shared.parseConnectionUrl(options.url);
        service = service || urlData.service;
    }

    this.options = assign(
        false, // create new object
        options, // regular options
        urlData, // url options
        service && wellknown(service) // wellknown options
    );

    this.logger = shared.getLogger(this.options);

    // temporary object
    var connection = new SMTPConnection(this.options);

    this.name = 'SMTP';
    this.version = packageData.version + '[client:' + connection.version + ']';
}
util.inherits(SMTPTransport, EventEmitter);

/**
 * Placeholder function for creating proxy sockets. This method immediatelly returns
 * without a socket
 *
 * @param {Object} options Connection options
 * @param {Function} callback Callback function to run with the socket keys
 */
SMTPTransport.prototype.getSocket = function (options, callback) {
    // return immediatelly
    return callback(null, false);
};

/**
 * Sends an e-mail using the selected settings
 *
 * @param {Object} mail Mail object
 * @param {Function} callback Callback function
 */
SMTPTransport.prototype.send = function (mail, callback) {

    this.getSocket(this.options, function (err, socketOptions) {
        if (err) {
            return callback(err);
        }

        var options = this.options;
        if (socketOptions && socketOptions.connection) {
            this.logger.info('Using proxied socket from %s:%s to %s:%s', socketOptions.connection.remoteAddress, socketOptions.connection.remotePort, options.host || '', options.port || '');
            // only copy options if we need to modify it
            options = assign(false, options);
            Object.keys(socketOptions).forEach(function (key) {
                options[key] = socketOptions[key];
            });
        }

        var connection = new SMTPConnection(options);
        var returned = false;

        connection.once('error', function (err) {
            if (returned) {
                return;
            }
            returned = true;
            connection.close();
            return callback(err);
        });

        connection.once('end', function () {
            if (returned) {
                return;
            }
            returned = true;
            return callback(new Error('Connection closed'));
        });

        var sendMessage = function () {
            var envelope = mail.data.envelope || mail.message.getEnvelope();
            var messageId = (mail.message.getHeader('message-id') || '').replace(/[<>\s]/g, '');
            var recipients = [].concat(envelope.to || []);
            if (recipients.length > 3) {
                recipients.push('...and ' + recipients.splice(2).length + ' more');
            }

            this.logger.info('Sending message <%s> to <%s>', messageId, recipients.join(', '));

            connection.send(envelope, mail.message.createReadStream(), function (err, info) {
                if (returned) {
                    return;
                }
                returned = true;

                connection.close();
                if (err) {
                    return callback(err);
                }
                info.envelope = {
                    from: envelope.from,
                    to: envelope.to
                };
                info.messageId = messageId;
                return callback(null, info);
            });
        }.bind(this);

        connection.connect(function () {
            if (returned) {
                return;
            }

            if (this.options.auth) {
                connection.login(this.options.auth, function (err) {
                    if (returned) {
                        return;
                    }

                    if (err) {
                        returned = true;
                        connection.close();
                        return callback(err);
                    }

                    sendMessage();
                });
            } else {
                sendMessage();
            }
        }.bind(this));
    }.bind(this));
};

/**
 * Verifies SMTP configuration
 *
 * @param {Function} callback Callback function
 */
SMTPTransport.prototype.verify = function (callback) {
    var promise;

    if (!callback && typeof Promise === 'function') {
        promise = new Promise(function (resolve, reject) {
            callback = shared.callbackPromise(resolve, reject);
        });
    }

    this.getSocket(this.options, function (err, socketOptions) {
        if (err) {
            return callback(err);
        }

        var options = this.options;
        if (socketOptions && socketOptions.connection) {
            this.logger.info('Using proxied socket from %s:%s', socketOptions.connection.remoteAddress, socketOptions.connection.remotePort);
            options = assign(false, options);
            Object.keys(socketOptions).forEach(function (key) {
                options[key] = socketOptions[key];
            });
        }

        var connection = new SMTPConnection(options);
        var returned = false;

        connection.once('error', function (err) {
            if (returned) {
                return;
            }
            returned = true;
            connection.close();
            return callback(err);
        });

        connection.once('end', function () {
            if (returned) {
                return;
            }
            returned = true;
            return callback(new Error('Connection closed'));
        });

        var finalize = function () {
            if (returned) {
                return;
            }
            returned = true;
            connection.quit();
            return callback(null, true);
        };

        connection.connect(function () {
            if (returned) {
                return;
            }

            if (this.options.auth) {
                connection.login(this.options.auth, function (err) {
                    if (returned) {
                        return;
                    }

                    if (err) {
                        returned = true;
                        connection.close();
                        return callback(err);
                    }

                    finalize();
                });
            } else {
                finalize();
            }
        }.bind(this));
    }.bind(this));

    return promise;
};

/**
 * Copies properties from source objects to target objects
 */
function assign( /* target, ... sources */ ) {
    var args = Array.prototype.slice.call(arguments);
    var target = args.shift() || {};

    args.forEach(function (source) {
        Object.keys(source || {}).forEach(function (key) {
            if (['tls', 'auth'].indexOf(key) >= 0 && source[key] && typeof source[key] === 'object') {
                // tls and auth are special keys that need to be enumerated separately
                // other objects are passed as is
                if (!target[key]) {
                    // esnure that target has this key
                    target[key] = {};
                }
                Object.keys(source[key]).forEach(function (subKey) {
                    target[key][subKey] = source[key][subKey];
                });
            } else {
                target[key] = source[key];
            }
        });
    });
    return target;
}

},{"../package.json":80,"events":16,"nodemailer-shared":74,"nodemailer-wellknown":81,"smtp-connection":85,"util":104}],80:[function(require,module,exports){
module.exports={
  "_args": [
    [
      "nodemailer-smtp-transport@https://registry.npmjs.org/nodemailer-smtp-transport/-/nodemailer-smtp-transport-2.5.0.tgz",
      "/Users/nhong/nickhong.io/node_modules/nodemailer"
    ]
  ],
  "_from": "nodemailer-smtp-transport@2.5.0",
  "_id": "nodemailer-smtp-transport@2.5.0",
  "_inCache": true,
  "_location": "/nodemailer/nodemailer-smtp-transport",
  "_phantomChildren": {},
  "_requested": {
    "name": "nodemailer-smtp-transport",
    "raw": "nodemailer-smtp-transport@https://registry.npmjs.org/nodemailer-smtp-transport/-/nodemailer-smtp-transport-2.5.0.tgz",
    "rawSpec": "https://registry.npmjs.org/nodemailer-smtp-transport/-/nodemailer-smtp-transport-2.5.0.tgz",
    "scope": null,
    "spec": "https://registry.npmjs.org/nodemailer-smtp-transport/-/nodemailer-smtp-transport-2.5.0.tgz",
    "type": "remote"
  },
  "_requiredBy": [
    "/nodemailer"
  ],
  "_resolved": "https://registry.npmjs.org/nodemailer-smtp-transport/-/nodemailer-smtp-transport-2.5.0.tgz",
  "_shasum": "6f5ff7a99401a3ba3d324081a5b7e41ae54e85fa",
  "_shrinkwrap": null,
  "_spec": "nodemailer-smtp-transport@https://registry.npmjs.org/nodemailer-smtp-transport/-/nodemailer-smtp-transport-2.5.0.tgz",
  "_where": "/Users/nhong/nickhong.io/node_modules/nodemailer",
  "author": {
    "name": "Andris Reinman"
  },
  "bugs": {
    "url": "https://github.com/andris9/nodemailer-smtp-transport/issues"
  },
  "dependencies": {
    "nodemailer-shared": "1.0.5",
    "nodemailer-wellknown": "0.1.9",
    "smtp-connection": "2.5.0"
  },
  "description": "SMTP transport for Nodemailer",
  "devDependencies": {
    "chai": "^3.5.0",
    "grunt": "^1.0.1",
    "grunt-eslint": "^18.1.0",
    "grunt-mocha-test": "^0.12.7",
    "mocha": "^2.4.5",
    "smtp-server": "^1.9.1"
  },
  "homepage": "http://github.com/andris9/nodemailer-smtp-transport",
  "keywords": [
    "SMTP",
    "Nodemailer"
  ],
  "license": "MIT",
  "main": "lib/smtp-transport.js",
  "name": "nodemailer-smtp-transport",
  "optionalDependencies": {},
  "readme": "# SMTP transport module for Nodemailer\n\n[![Build Status](https://travis-ci.org/andris9/nodemailer-smtp-transport.svg)](https://travis-ci.org/andris9/nodemailer-smtp-transport)\n[![NPM version](https://badge.fury.io/js/nodemailer-smtp-transport.png)](http://badge.fury.io/js/nodemailer-smtp-transport)\n\nApplies for Nodemailer v1.x and not for v0.x where transports are built-in.\n\n## Setup\n\nInstall with npm\n\n    npm install nodemailer-smtp-transport\n\nRequire to your script\n\n```javascript\nvar nodemailer = require('nodemailer');\nvar smtpTransport = require('nodemailer-smtp-transport');\n```\n\n## Usage\n\nCreate a Nodemailer transport object\n\n```javascript\nvar transporter = nodemailer.createTransport(smtpTransport(options))\n```\n\nor (by using smtpTransport as default)\n\n```javascript\nvar transporter = nodemailer.createTransport(options)\n```\n\nWhere\n\n  * **options** defines connection data\n    * **options.port** is the port to connect to (defaults to 25 or 465)\n    * **options.host** is the hostname or IP address to connect to (defaults to 'localhost')\n    * **options.secure** defines if the connection should use SSL (if `true`) or not (if `false`)\n    * **options.auth** defines authentication data (see [authentication](#authentication) section below)\n    * **options.ignoreTLS** turns off STARTTLS support if true\n    * **options.name** optional hostname of the client, used for identifying to the server\n    * **options.localAddress** is the local interface to bind to for network connections\n    * **options.connectionTimeout** how many milliseconds to wait for the connection to establish\n    * **options.greetingTimeout** how many milliseconds to wait for the greeting after connection is established\n    * **options.socketTimeout** how many milliseconds of inactivity to allow\n    * **options.logger** optional [bunyan](https://github.com/trentm/node-bunyan) compatible logger instance. If set to `true` then logs to console. If value is not set or is `false` then nothing is logged\n    * **options.debug** if set to true, then logs SMTP traffic, otherwise logs only transaction events\n    * **options.authMethod** defines preferred authentication method, eg. 'PLAIN'\n    * **options.tls** defines additional options to be passed to the socket constructor, eg. *{rejectUnauthorized: true}*\n    * **getSocket** optional method that is called every time a new connection is made against the SMTP server. This method can provide an existing socket to be used instead of creating a new one\n\nAlternatively you can use connection url with protocol 'smtp:' or 'smtps:'. Use query arguments for additional configuration values.\n\n**Example**\n\n```javascript\nvar transporter = nodemailer.createTransport(smtpTransport({\n    host: 'localhost',\n    port: 25,\n    auth: {\n        user: 'username',\n        pass: 'password'\n    }\n}));\n```\n\nOr with connection url (gmail)\n\n```javascript\nvar transporter = nodemailer.createTransport(\n    smtpTransport('smtps://username%40gmail.com:password@smtp.gmail.com')\n);\n```\n\n## Authentication\n\nIf authentication data is not present, the connection is considered authenticated from the start.\n\nSet authentcation data with `options.auth`\n\nWhere\n\n  * **auth** is the authentication object\n    * **auth.user** is the username\n    * **auth.pass** is the password for the user\n    * **auth.xoauth2** is the OAuth2 access token (preferred if both `pass` and `xoauth2` values are set) or an [XOAuth2](https://github.com/andris9/xoauth2) token generator object.\n\nIf a [XOAuth2](https://github.com/andris9/xoauth2) token generator is used as the value for `auth.xoauth2` then you do not need to set the value for `auth.user`. XOAuth2 generator generates required `accessToken` itself if it is missing or expired. In this case if the authentication fails, a new token is requested and the authentication is retried once. If it still fails, an error is returned.\n\nInstall xoauth2 module to use XOauth2 token generators (not included by default)\n\n    npm install xoauth2 --save\n\n**XOAuth2 Example**\n\n> **NB!** The correct OAuth2 scope for Gmail is `https://mail.google.com/`\n\n```javascript\nvar nodemailer = require('nodemailer');\nvar generator = require('xoauth2').createXOAuth2Generator({\n    user: '{username}',\n    clientId: '{Client ID}',\n    clientSecret: '{Client Secret}',\n    refreshToken: '{refresh-token}',\n    accessToken: '{cached access token}' // optional\n});\n\n// listen for token updates\n// you probably want to store these to a db\ngenerator.on('token', function(token){\n    console.log('New token for %s: %s', token.user, token.accessToken);\n});\n\n// login\nvar transporter = nodemailer.createTransport(({\n    service: 'gmail',\n    auth: {\n        xoauth2: generator\n    }\n}));\n\n// send mail\ntransporter.sendMail({\n    from: 'sender@example.com',\n    to: 'receiver@example.com',\n    subject: 'hello world!',\n    text: 'Authenticated with OAuth2'\n}, function(error, response) {\n   if (error) {\n        console.log(error);\n   } else {\n        console.log('Message sent');\n   }\n});\n```\n\n## Using well-known services\n\nIf you do not want to specify the hostname, port and security settings for a well known service, you can use it by its name (case insensitive)\n\n```javascript\nsmtpTransport({\n    service: 'gmail',\n    auth: ..\n});\n```\n\nSee the list of all supported services [here](https://github.com/andris9/nodemailer-wellknown#supported-services).\n\n## Verify connection configuration\n\nYou can verify your configuration with `verify(callback)` call. If it returns an error, then something is not correct, otherwise the server is ready to accept messages.\n\n```javascript\n// verify connection configuration\ntransporter.verify(function(error, success) {\n   if (error) {\n        console.log(error);\n   } else {\n        console.log('Server is ready to take our messages');\n   }\n});\n```\n\n## License\n\n**MIT**\n",
  "readmeFilename": "README.md",
  "repository": {
    "type": "git",
    "url": "git://github.com/andris9/nodemailer-smtp-transport.git"
  },
  "scripts": {
    "test": "grunt"
  },
  "version": "2.5.0"
}

},{}],81:[function(require,module,exports){
'use strict';

var services = require('./services.json');
var normalized = {};

Object.keys(services).forEach(function(key) {
    var service = services[key];

    normalized[normalizeKey(key)] = normalizeService(service);

    [].concat(service.aliases || []).forEach(function(alias) {
        normalized[normalizeKey(alias)] = normalizeService(service);
    });

    [].concat(service.domains || []).forEach(function(domain) {
        normalized[normalizeKey(domain)] = normalizeService(service);
    });
});

function normalizeKey(key) {
    return key.replace(/[^a-zA-Z0-9.\-]/g, '').toLowerCase();
}

function normalizeService(service) {
    var filter = ['domains', 'aliases'];
    var response = {};

    Object.keys(service).forEach(function(key) {
        if (filter.indexOf(key) < 0) {
            response[key] = service[key];
        }
    });

    return response;
}

/**
 * Resolves SMTP config for given key. Key can be a name (like 'Gmail'), alias (like 'Google Mail') or
 * an email address (like 'test@googlemail.com').
 *
 * @param {String} key [description]
 * @returns {Object} SMTP config or false if not found
 */
module.exports = function(key) {
    key = normalizeKey(key.split('@').pop());
    return normalized[key] || false;
};
},{"./services.json":82}],82:[function(require,module,exports){
module.exports={
    "1und1": {
        "host": "smtp.1und1.de",
        "port": 465,
        "secure": true,
        "authMethod": "LOGIN"
    },

    "AOL": {
        "domains": [
            "aol.com"
        ],
        "host": "smtp.aol.com",
        "port": 587
    },

    "DebugMail": {
        "host": "debugmail.io",
        "port": 25
    },

    "DynectEmail": {
        "aliases": ["Dynect"],
        "host": "smtp.dynect.net",
        "port": 25
    },

    "FastMail": {
        "domains": [
            "fastmail.fm"
        ],
        "host": "mail.messagingengine.com",
        "port": 465,
        "secure": true
    },

    "GandiMail": {
        "aliases": [
            "Gandi",
            "Gandi Mail"
        ],
        "host": "mail.gandi.net",
        "port": 587
    },

    "Gmail": {
        "aliases": [
            "Google Mail"
        ],
        "domains": [
            "gmail.com",
            "googlemail.com"
        ],
        "host": "smtp.gmail.com",
        "port": 465,
        "secure": true
    },

    "Godaddy": {
        "host": "smtpout.secureserver.net",
        "port": 25
    },

    "GodaddyAsia": {
        "host": "smtp.asia.secureserver.net",
        "port": 25
    },

    "GodaddyEurope": {
        "host": "smtp.europe.secureserver.net",
        "port": 25
    },

    "hot.ee": {
        "host": "mail.hot.ee"
    },

    "Hotmail": {
        "aliases": [
            "Outlook",
            "Outlook.com",
            "Hotmail.com"
        ],
        "domains": [
            "hotmail.com",
            "outlook.com"
        ],
        "host": "smtp.live.com",
        "port": 587,
        "tls": {
            "ciphers": "SSLv3"
        }
    },

    "iCloud": {
        "aliases": ["Me", "Mac"],
        "domains": [
            "me.com",
            "mac.com"
        ],
        "host": "smtp.mail.me.com",
        "port": 587
    },

    "mail.ee": {
        "host": "smtp.mail.ee"
    },

    "Mail.ru": {
        "host": "smtp.mail.ru",
        "port": 465,
        "secure": true
    },

    "Maildev": {
        "port": 1025,
        "ignoreTLS": true
    },

    "Mailgun": {
        "host": "smtp.mailgun.org",
        "port": 587
    },

    "Mailjet": {
        "host": "in.mailjet.com",
        "port": 587
    },

    "Mandrill": {
        "host": "smtp.mandrillapp.com",
        "port": 587
    },

    "Naver": {
        "host": "smtp.naver.com",
        "port": 587
    },

    "OpenMailBox": {
        "aliases": [
            "OMB",
            "openmailbox.org"
        ],
        "host": "smtp.openmailbox.org",
        "port": 465,
        "secure": true
    },

    "Postmark": {
        "aliases": ["PostmarkApp"],
        "host": "smtp.postmarkapp.com",
        "port": 2525
    },

    "QQ": {
        "domains": [
            "qq.com"
        ],
        "host": "smtp.qq.com",
        "port": 465,
        "secure": true
    },

    "QQex": {
        "aliases": ["QQ Enterprise"],
        "domains": [
            "exmail.qq.com"
        ],
        "host": "smtp.exmail.qq.com",
        "port": 465,
        "secure": true
    },

    "SendCloud": {
        "host": "smtpcloud.sohu.com",
        "port": 25
    },

    "SendGrid": {
        "host": "smtp.sendgrid.net",
        "port": 587
    },

    "SES": {
        "host": "email-smtp.us-east-1.amazonaws.com",
        "port": 465,
        "secure": true
    },
    "SES-US-EAST-1": {
        "host": "email-smtp.us-east-1.amazonaws.com",
        "port": 465,
        "secure": true
    },
    "SES-US-WEST-1": {
        "host": "email-smtp.us-west-1.amazonaws.com",
        "port": 465,
        "secure": true
    },
    "SES-EU-WEST-1": {
        "host": "email-smtp.eu-west-1.amazonaws.com",
        "port": 465,
        "secure": true
    },
    

    "Sparkpost": {
        "aliases": [
            "SparkPost",
            "SparkPost Mail"
        ],
        "domains": [
            "sparkpost.com"
        ],
        "host": "smtp.sparkpostmail.com",
        "port": 587,
        "secure": false
    },

    "Yahoo": {
        "domains": [
            "yahoo.com"
        ],
        "host": "smtp.mail.yahoo.com",
        "port": 465,
        "secure": true
    },

    "Yandex": {
        "domains": [
            "yandex.ru"
        ],
        "host": "smtp.yandex.ru",
        "port": 465,
        "secure": true
    },

    "Zoho": {
        "host": "smtp.zoho.com",
        "port": 465,
        "secure": true,
        "authMethod": "LOGIN"
    },
    "126": {
        "host": "smtp.126.com",
        "port": 465,
        "secure": true
    },
    "163": {
        "host": "smtp.163.com",
        "port": 465,
        "secure": true
    }

}

},{}],83:[function(require,module,exports){
(function (Buffer){
var SmartBuffer = (function () {

    /**
     * Constructor for SmartBuffer.
     * @param arg1 {Buffer || Number || String} Buffer to read from, or expected size to write to, or encoding to use.
     * @param arg2 {String} Encoding to use for writing and reading strings. Defaults to utf8. If encoding is given in arg1, this is ignored.
     * @constructor
     *
     * There are a few ways to construct a SmartBuffer:
     *
     * SmartBuffer() - Defaults to utf8, 4096 pre-set internal Buffer length.
     * SmartBuffer(size) - Defaults to utf8, sets internal Buffer length to the size given.
     * SmartBuffer(encoding) - Sets the given encoding, defaults to 4096 pre-set internal Buffer length.
     * SmartBuffer(Buffer) - Defaults to utf8, sets the internal Buffer to the given buffer (same memory).
     * SmartBuffer(Buffer, encoding) - Sets the given encoding, sets the internal Buffer to the given buffer (same memory).
     *
     */
    function SmartBuffer(arg1, arg2) {
        var type;
        switch (type = typeof arg1) {
            case 'number':
                if (isFinite(arg1) && arg1 > 0) {
                    this.buff = new Buffer(Math.ceil(arg1));
                    this.length = 0;
                } else {
                    throw new Error('When specifying a size, it must be a valid number above zero.');
                }
                break;

            case 'string':
                if (Buffer.isEncoding(arg1)) {
                    this.buff = new Buffer(4096);
                    this.length = 0;
                    this.encoding = arg1;
                } else {
                    throw new Error('Invalid Encoding');
                }
                break;

            case 'object':
                if (Buffer.isBuffer(arg1)) {
                    this.buff = arg1;
                    this.length = arg1.length;
                } else {
                    throw new TypeError('First argument must be a Buffer, Number representing the size, or a String representing the encoding.');
                }
                break;

            default:
                this.buff = new Buffer(4096);
                this.length = 0;
                break;
        }

        if (typeof this.encoding === 'undefined') {
            if (typeof arg2 === 'string') {
                if (Buffer.isEncoding(arg2)) {
                    this.encoding = arg2;
                } else {
                    throw new Error('Invalid Encoding');
                }
            }
        }

        this._readOffset = 0;
        this._writeOffset = 0;
    }


    SmartBuffer.prototype._ensureWritable = function (len, offset) {
        this._ensureCapacity(this.length + len + (offset || 0));

        if (typeof offset === 'number') {
            this.buff.copy(this.buff, offset + len, offset, this.buff.length);
        }
        this.length = Math.max(this.length + len, (offset || 0) + len);
    };

    SmartBuffer.prototype._ensureCapacity = function (minlen) {
        var oldlen = this.buff.length;

        if (minlen > oldlen) {
            var data = this.buff;
            var newlen = (oldlen * 3) / 2 + 1;
            if (newlen < minlen)
                newlen = minlen;
            this.buff = new Buffer(newlen);
            data.copy(this.buff, 0, 0, oldlen);
        }
    };


    var makeReader = function (func, size) {
        return function () {
            var ret = func.call(this.buff, this._readOffset);
            this._readOffset += size;
            return ret;
        }
    };

    var makeWriter = function (func, size) {
        return function (value, offset) {
            this._ensureWritable(size, offset);
            func.call(this.buff, value, typeof offset === 'number' ? offset : this._writeOffset);
            this._writeOffset += size;
            return this;
        }
    };


    /*
     Read Operations
     */

    SmartBuffer.prototype.readInt8 = makeReader(Buffer.prototype.readInt8, 1);
    SmartBuffer.prototype.readInt16BE = makeReader(Buffer.prototype.readInt16BE, 2);
    SmartBuffer.prototype.readInt16LE = makeReader(Buffer.prototype.readInt16LE, 2);
    SmartBuffer.prototype.readInt32BE = makeReader(Buffer.prototype.readInt32BE, 4);
    SmartBuffer.prototype.readInt32LE = makeReader(Buffer.prototype.readInt32LE, 4);

    SmartBuffer.prototype.readUInt8 = makeReader(Buffer.prototype.readUInt8, 1);
    SmartBuffer.prototype.readUInt16BE = makeReader(Buffer.prototype.readUInt16BE, 2);
    SmartBuffer.prototype.readUInt16LE = makeReader(Buffer.prototype.readUInt16LE, 2);
    SmartBuffer.prototype.readUInt32BE = makeReader(Buffer.prototype.readUInt32BE, 4);
    SmartBuffer.prototype.readUInt32LE = makeReader(Buffer.prototype.readUInt32LE, 4);

    SmartBuffer.prototype.readFloatBE = makeReader(Buffer.prototype.readFloatBE, 4);
    SmartBuffer.prototype.readFloatLE = makeReader(Buffer.prototype.readFloatLE, 4);

    SmartBuffer.prototype.readDoubleBE = makeReader(Buffer.prototype.readDoubleBE, 8);
    SmartBuffer.prototype.readDoubleLE = makeReader(Buffer.prototype.readDoubleLE, 8);


    /**
     * Reads a string of the given length.
     * @param length {Number} The length of the string to read. (Defaults to the length of the remaining data)
     * @param encoding {String} The encoding to use. (Defaults to encoding set in constructor, or utf8)
     * @returns {string} The string.
     */
    SmartBuffer.prototype.readString = function (length, encoding) {
        var len = Math.min(length, this.length - this._readOffset) || (this.length - this._readOffset);
        var ret = this.buff.slice(this._readOffset, this._readOffset + len).toString(encoding || this.encoding);
        this._readOffset += len;
        return ret;
    };

    /**
     * Reads a null terminated string from the underlying buffer.
     * @param encoding {String} Encoding to use. Defaults to encoding set in constructor, or utf8.
     * @returns {string}
     */
    SmartBuffer.prototype.readStringNT = function (encoding) {
        var nullpos = this.length;
        for (var i = this._readOffset; i < this.length; i++) {
            if (this.buff[i] == 0x00) {
                nullpos = i;
                break;
            }
        }

        var result = this.buff.slice(this._readOffset, nullpos);
        this._readOffset = nullpos + 1;

        return result.toString(encoding || this.encoding);
    };


    /**
     * Reads a specified number of bytes.
     * @param len {Number} Numbers of bytes to read. (Defaults to the remaining data length)
     * @returns {Buffer} Buffer containing the read bytes.
     */
    SmartBuffer.prototype.readBuffer = function (len) {
        var endpoint = Math.min(this.length, this._readOffset + (len || this.length));
        var ret = this.buff.slice(this._readOffset, endpoint);
        this._readOffset = endpoint;
        return ret;
    };

    /**
     * Reads a null terminated sequence of bytes from the underlying buffer.
     * @returns {Buffer} Buffer containing the read bytes.
     */
    SmartBuffer.prototype.readBufferNT = function () {
        var nullpos = this.length;
        for (var i = this._readOffset; i < this.length; i++) {
            if (this.buff[i] == 0x00) {
                nullpos = i;
                break;
            }
        }

        var ret = this.buff.slice(this._readOffset, nullpos);
        this._readOffset = nullpos + 1;

        return ret;
    };


    /*
     Write Operations
     */


    SmartBuffer.prototype.writeInt8 = makeWriter(Buffer.prototype.writeInt8, 1);
    SmartBuffer.prototype.writeInt16BE = makeWriter(Buffer.prototype.writeInt16BE, 2);
    SmartBuffer.prototype.writeInt16LE = makeWriter(Buffer.prototype.writeInt16LE, 2);
    SmartBuffer.prototype.writeInt32BE = makeWriter(Buffer.prototype.writeInt32BE, 4);
    SmartBuffer.prototype.writeInt32LE = makeWriter(Buffer.prototype.writeInt32LE, 4);

    SmartBuffer.prototype.writeUInt8 = makeWriter(Buffer.prototype.writeUInt8, 1);
    SmartBuffer.prototype.writeUInt16BE = makeWriter(Buffer.prototype.writeUInt16BE, 2);
    SmartBuffer.prototype.writeUInt16LE = makeWriter(Buffer.prototype.writeUInt16LE, 2);
    SmartBuffer.prototype.writeUInt32BE = makeWriter(Buffer.prototype.writeUInt32BE, 4);
    SmartBuffer.prototype.writeUInt32LE = makeWriter(Buffer.prototype.writeUInt32LE, 4);

    SmartBuffer.prototype.writeFloatBE = makeWriter(Buffer.prototype.writeFloatBE, 4);
    SmartBuffer.prototype.writeFloatLE = makeWriter(Buffer.prototype.writeFloatLE, 4);

    SmartBuffer.prototype.writeDoubleBE = makeWriter(Buffer.prototype.writeDoubleBE, 8);
    SmartBuffer.prototype.writeDoubleLE = makeWriter(Buffer.prototype.writeDoubleLE, 8);


    /**
     * Writes a string to the underlying buffer.
     * @param value {String} The string to write.
     * @param offset {Number} The offset to write the string to. (Encoding can also be set here in place of offset)
     * @param encoding {String} The encoding to use. (Defaults to encoding set in constructor, or to utf8)
     * @returns {*}
     */
    SmartBuffer.prototype.writeString = function (value, offset, encoding) {
        var len, _offset, type = typeof offset;

        if (type === 'number') {
            _offset = offset;
        } else if (type === 'string') {
            encoding = offset;
            offset = this._writeOffset;
        } else {
            encoding = undefined;
            offset = this._writeOffset;
        }

        len = Buffer.byteLength(value, encoding || this.encoding);
        this._ensureWritable(len, _offset);

        this.buff.write(value, offset, len, encoding || this.encoding);
        this._writeOffset += len;
        return this;
    };

    /**
     * Writes a null terminated string to the underlying buffer.
     * @param value {String} The string to write.
     * @param offset {Number} The offset to write the string to. (Encoding can also be set here in place of offset)
     * @param encoding {String} The encoding to use. (Defaults to encoding set in constructor, or to utf8)
     * @returns {*}
     */
    SmartBuffer.prototype.writeStringNT = function (value, offset, encoding) {
        this.writeString(value, offset, encoding);
        this.writeUInt8(0x00);
        return this;
    };

    /**
     * Writes a Buffer to the underlying buffer.
     * @param value {Buffer} The buffer to write.
     * @param offset {Number} The offset to write the Buffer to.
     * @returns {*}
     */
    SmartBuffer.prototype.writeBuffer = function (value, offset) {
        var len = value.length;
        this._ensureWritable(len, offset);
        value.copy(this.buff, offset || this._writeOffset);
        this._writeOffset += len;
        return this;
    };

    /**
     * Writes a null terminated Buffer to the underlying buffer.
     * @param value {Buffer} The buffer to write.
     * @param offset {Number} The offset to write the Buffer to.
     * @returns {*}
     */
    SmartBuffer.prototype.writeBufferNT = function (value, offset) {
        var len = value.length;
        this._ensureWritable(len, offset);
        value.copy(this.buff, offset || this._writeOffset);
        this.buff[this._writeOffset + len] = 0x00;
        this._writeOffset += len + 1;
        return this;
    };


    /**
     * Resets the Endless Buffer.
     */
    SmartBuffer.prototype.clear = function () {
        this._writeOffset = 0;
        this._readOffset = 0;
        this.length = 0;
    };

    /**
     * Gets the remaining number of bytes to be read from the existing Buffer.
     * @returns {number} The number of bytes remaining.
     */
    SmartBuffer.prototype.remaining = function () {
        return this.length - this._readOffset;
    };

    /**
     * Skips the read position forward by the amount of given.
     * @param amount {Number} The amount of bytes to skip forward.
     */
    SmartBuffer.prototype.skip = function (amount) {
        if (this._readOffset + amount > this.length)
            throw new Error('Target position is beyond the bounds of the data.');

        this._readOffset += amount;
    };

    /**
     * Rewinds the read position backward by the amount given.
     * @param amount {Number} The amount of bytes to reverse backward.
     */
    SmartBuffer.prototype.rewind = function (amount) {
        if (this._readOffset - amount < 0)
            throw new Error('Target position is beyond the bounds of the data.');

        this._readOffset -= amount;
    };

    /**
     * Skips the read position to the given position.
     * @param position {Number} The position to skip to.
     */
    SmartBuffer.prototype.skipTo = function (position) {
        if (position < 0 || position > this.length)
            throw new Error('Target position is beyond the bounds of the data.');

        this._readOffset = position;
    };

    /**
     * Gets the underlying Buffer.
     * @returns {*}
     */
    SmartBuffer.prototype.toBuffer = function () {
        return this.buff.slice(0, this.length);
    };

    /**
     * Gets a string representation of the underlying Buffer.
     * @param encoding {String} Encoding to use. (Defaults to encoding set in constructor, or utf8.)
     * @returns {*}
     */
    SmartBuffer.prototype.toString = function (encoding) {
        return this.buff.toString(encoding || this.encoding, 0, this.length);
    };

    /**
     * Destroys the underlying Buffer, and resets the SmartBuffer.
     */
    SmartBuffer.prototype.destroy = function () {
        delete this.buff;
        this.clear();
    };

    return SmartBuffer;
})();

module.exports = SmartBuffer;
}).call(this,require("buffer").Buffer)
},{"buffer":9}],84:[function(require,module,exports){
(function (Buffer){
'use strict';

var stream = require('stream');
var Transform = stream.Transform;
var util = require('util');

module.exports = DataStream;

/**
 * Escapes dots in the beginning of lines. Ends the stream with <CR><LF>.<CR><LF>
 * Also makes sure that only <CR><LF> sequences are used for linebreaks
 *
 * @param {Object} options Stream options
 */
function DataStream(options) {
    // init Transform
    this.options = options || {};
    this._curLine = '';

    this.inByteCount = 0;
    this.outByteCount = 0;
    this.lastByte = false;

    Transform.call(this, this.options);
}
util.inherits(DataStream, Transform);

/**
 * Escapes dots
 */
DataStream.prototype._transform = function (chunk, encoding, done) {
    var chunks = [];
    var chunklen = 0;
    var i, len, lastPos = 0;
    var buf;

    if (!chunk || !chunk.length) {
        return done();
    }

    if (typeof chunk === 'string') {
        chunk = new Buffer(chunk);
    }

    this.inByteCount += chunk.length;

    for (i = 0, len = chunk.length; i < len; i++) {
        if (chunk[i] === 0x2E) { // .
            if (
                (i && chunk[i - 1] === 0x0A) ||
                (!i && (!this.lastByte || this.lastByte === 0x0A))
            ) {
                buf = chunk.slice(lastPos, i + 1);
                chunks.push(buf);
                chunks.push(new Buffer('.'));
                chunklen += buf.length + 1;
                lastPos = i + 1;
            }
        } else if (chunk[i] === 0x0A) { // .
            if (
                (i && chunk[i - 1] !== 0x0D) ||
                (!i && this.lastByte !== 0x0D)
            ) {
                if (i > lastPos) {
                    buf = chunk.slice(lastPos, i);
                    chunks.push(buf);
                    chunklen += buf.length + 2;
                } else {
                    chunklen += 2;
                }
                chunks.push(new Buffer('\r\n'));
                lastPos = i + 1;
            }
        }
    }

    if (chunklen) {
        // add last piece
        if (lastPos < chunk.length) {
            buf = chunk.slice(lastPos);
            chunks.push(buf);
            chunklen += buf.length;
        }

        this.outByteCount += chunklen;
        this.push(Buffer.concat(chunks, chunklen));
    } else {
        this.outByteCount += chunk.length;
        this.push(chunk);
    }

    this.lastByte = chunk[chunk.length - 1];
    done();
};

/**
 * Finalizes the stream with a dot on a single line
 */
DataStream.prototype._flush = function (done) {
    var buf;
    if (this.lastByte === 0x0A) {
        buf = new Buffer('.\r\n');
    } else if (this.lastByte === 0x0D) {
        buf = new Buffer('\n.\r\n');
    } else {
        buf = new Buffer('\r\n.\r\n');
    }
    this.outByteCount += buf.length;
    this.push(buf);
    done();
};

}).call(this,require("buffer").Buffer)
},{"buffer":9,"stream":23,"util":104}],85:[function(require,module,exports){
(function (Buffer){
'use strict';

var packageInfo = require('../package.json');
var EventEmitter = require('events').EventEmitter;
var util = require('util');
var net = require('net');
var tls = require('tls');
var os = require('os');
var crypto = require('crypto');
var DataStream = require('./data-stream');
var PassThrough = require('stream').PassThrough;
var shared = require('nodemailer-shared');
var ntlm = require('httpntlm/ntlm');

module.exports = SMTPConnection;

/**
 * Generates a SMTP connection object
 *
 * Optional options object takes the following possible properties:
 *
 *  * **port** - is the port to connect to (defaults to 25 or 465)
 *  * **host** - is the hostname or IP address to connect to (defaults to 'localhost')
 *  * **secure** - use SSL
 *  * **ignoreTLS** - ignore server support for STARTTLS
 *  * **requireTLS** - forces the client to use STARTTLS
 *  * **name** - the name of the client server
 *  * **localAddress** - outbound address to bind to (see: http://nodejs.org/api/net.html#net_net_connect_options_connectionlistener)
 *  * **greetingTimeout** - Time to wait in ms until greeting message is received from the server (defaults to 10000)
 *  * **connectionTimeout** - how many milliseconds to wait for the connection to establish
 *  * **socketTimeout** - Time of inactivity until the connection is closed (defaults to 1 hour)
 *  * **lmtp** - if true, uses LMTP instead of SMTP protocol
 *  * **logger** - bunyan compatible logger interface
 *  * **debug** - if true pass SMTP traffic to the logger
 *  * **tls** - options for createCredentials
 *  * **socket** - existing socket to use instead of creating a new one (see: http://nodejs.org/api/net.html#net_class_net_socket)
 *  * **secured** - boolean indicates that the provided socket has already been upgraded to tls
 *
 * @constructor
 * @namespace SMTP Client module
 * @param {Object} [options] Option properties
 */
function SMTPConnection(options) {
    EventEmitter.call(this);

    this.id = crypto.randomBytes(8).toString('base64').replace(/\W/g, '');
    this.stage = 'init';

    this.options = options || {};

    this.secureConnection = !!this.options.secure;
    this.alreadySecured = !!this.options.secured;

    this.port = this.options.port || (this.secureConnection ? 465 : 25);
    this.host = this.options.host || 'localhost';

    if (typeof this.options.secure === 'undefined' && this.port === 465) {
        // if secure option is not set but port is 465, then default to secure
        this.secureConnection = true;
    }

    this.name = this.options.name || this._getHostname();

    this.logger = shared.getLogger(this.options);

    /**
     * Expose version nr, just for the reference
     * @type {String}
     */
    this.version = packageInfo.version;

    /**
     * If true, then the user is authenticated
     * @type {Boolean}
     */
    this.authenticated = false;

    /**
     * If set to true, this instance is no longer active
     * @private
     */
    this.destroyed = false;

    /**
     * Defines if the current connection is secure or not. If not,
     * STARTTLS can be used if available
     * @private
     */
    this.secure = !!this.secureConnection;

    /**
     * Store incomplete messages coming from the server
     * @private
     */
    this._remainder = '';

    /**
     * Unprocessed responses from the server
     * @type {Array}
     */
    this._responseQueue = [];

    /**
     * The socket connecting to the server
     * @publick
     */
    this._socket = false;

    /**
     * Lists supported auth mechanisms
     * @private
     */
    this._supportedAuth = [];

    /**
     * Lists supported extensions
     * @private
     */
    this._supportedExtensions = [];

    /**
     * Function to run if a data chunk comes from the server
     * @private
     */
    this._currentAction = false;

    /**
     * Timeout variable for waiting the greeting
     * @private
     */
    this._greetingTimeout = false;

    /**
     * Timeout variable for waiting the connection to start
     * @private
     */
    this._connectionTimeout = false;

    /**
     * If the socket is deemed already closed
     * @private
     */
    this._destroyed = false;

    /**
     * If the socket is already being closed
     * @private
     */
    this._closing = false;
}
util.inherits(SMTPConnection, EventEmitter);

/**
 * Creates a connection to a SMTP server and sets up connection
 * listener
 */
SMTPConnection.prototype.connect = function (connectCallback) {
    if (typeof connectCallback === 'function') {
        this.once('connect', function () {
            this.logger.debug('[%s] SMTP handshake finished', this.id);
            connectCallback();
        }.bind(this));
    }

    var opts = {
        port: this.port,
        host: this.host
    };

    if (this.options.localAddress) {
        opts.localAddress = this.options.localAddress;
    }

    if (this.options.connection) {
        // connection is already opened
        this._socket = this.options.connection;
        if (this.secureConnection && !this.alreadySecured) {
            setImmediate(this._upgradeConnection.bind(this, function (err) {
                if (err) {
                    this._onError(new Error('Error initiating TLS - ' + (err.message || err)), 'ETLS');
                    return;
                }
                this._onConnect();
            }.bind(this)));
        } else {
            setImmediate(this._onConnect.bind(this));
        }
    } else if (this.options.socket) {
        // socket object is set up but not yet connected
        this._socket = this.options.socket;
        try {
            this._socket.connect(this.port, this.host, this._onConnect.bind(this));
        } catch (E) {
            return setImmediate(this._onError.bind(this, E, 'ECONNECTION'));
        }
    } else if (this.secureConnection) {
        // connect using tls
        if (this.options.tls) {
            Object.keys(this.options.tls).forEach(function (key) {
                opts[key] = this.options.tls[key];
            }.bind(this));
        }
        try {
            this._socket = tls.connect(this.port, this.host, opts, this._onConnect.bind(this));
        } catch (E) {
            return setImmediate(this._onError.bind(this, E, 'ECONNECTION'));
        }
    } else {
        // connect using plaintext
        try {
            this._socket = net.connect(opts, this._onConnect.bind(this));
        } catch (E) {
            return setImmediate(this._onError.bind(this, E, 'ECONNECTION'));
        }
    }

    this._connectionTimeout = setTimeout(function () {
        this._onError('Connection timeout', 'ETIMEDOUT');
    }.bind(this), this.options.connectionTimeout || 60 * 1000);

    this._socket.on('error', this._onError.bind(this));
};

/**
 * Sends QUIT
 */
SMTPConnection.prototype.quit = function () {
    this._sendCommand('QUIT');
    this._currentAction = this.close;
};

/**
 * Closes the connection to the server
 */
SMTPConnection.prototype.close = function () {
    clearTimeout(this._connectionTimeout);
    clearTimeout(this._greetingTimeout);

    // allow to run this function only once
    if (this._closing) {
        return;
    }
    this._closing = true;

    var closeMethod = 'end';

    if (this.stage === 'init') {
        // Close the socket immediately when connection timed out
        closeMethod = 'destroy';
    }

    this.logger.debug('[%s] Closing connection to the server using "%s"', this.id, closeMethod);

    var socket = this._socket && this._socket.socket || this._socket;

    if (socket && !socket.destroyed) {
        try {
            this._socket[closeMethod]();
        } catch (E) {
            // just ignore
        }
    }

    this._destroy();
};

/**
 * Authenticate user
 */
SMTPConnection.prototype.login = function (authData, callback) {
    this._auth = authData || {};
    this._user = this._auth.xoauth2 && this._auth.xoauth2.options && this._auth.xoauth2.options.user || this._auth.user || '';

    var authMethod;
    if (this.options.authMethod) {
        authMethod = this.options.authMethod.toUpperCase().trim();
    } else if (this._auth.xoauth2 && this._supportedAuth.indexOf('XOAUTH2') >= 0) {
        authMethod = 'XOAUTH2';
    } else if (this._auth.domain && this._supportedAuth.indexOf('NTLM') >= 0) {
        authMethod = 'NTLM';
    } else {
        // use first supported
        authMethod = (this._supportedAuth[0] || 'PLAIN').toUpperCase().trim();
    }

    switch (authMethod) {
        case 'XOAUTH2':
            this._handleXOauth2Token(false, callback);
            return;
        case 'LOGIN':
            this._currentAction = function (str) {
                this._actionAUTH_LOGIN_USER(str, callback);
            }.bind(this);
            this._sendCommand('AUTH LOGIN');
            return;
        case 'PLAIN':
            this._currentAction = function (str) {
                this._actionAUTHComplete(str, callback);
            }.bind(this);
            this._sendCommand('AUTH PLAIN ' + new Buffer(
                //this._auth.user+'\u0000'+
                '\u0000' + // skip authorization identity as it causes problems with some servers
                this._auth.user + '\u0000' +
                this._auth.pass, 'utf-8').toString('base64'));
            return;
        case 'CRAM-MD5':
            this._currentAction = function (str) {
                this._actionAUTH_CRAM_MD5(str, callback);
            }.bind(this);
            this._sendCommand('AUTH CRAM-MD5');
            return;
        case 'NTLM':
            this._currentAction = function (str) {
                this._actionAUTH_NTLM_TYPE1(str, callback);
            }.bind(this);
            this._sendCommand('AUTH ' + ntlm.createType1Message({
                domain: this._auth.domain || '',
                workstation: this._auth.workstation || ''
            }));
            return;
    }

    return callback(this._formatError('Unknown authentication method "' + authMethod + '"', 'EAUTH'));
};

/**
 * Sends a message
 *
 * @param {Object} envelope Envelope object, {from: addr, to: [addr]}
 * @param {Object} message String, Buffer or a Stream
 * @param {Function} callback Callback to return once sending is completed
 */
SMTPConnection.prototype.send = function (envelope, message, done) {
    if (!message) {
        return done(this._formatError('Empty message', 'EMESSAGE'));
    }

    // ensure that callback is only called once
    var returned = false;
    var callback = function () {
        if (returned) {
            return;
        }
        returned = true;

        done.apply(null, Array.prototype.slice.call(arguments));
    };

    if (typeof message.on === 'function') {
        message.on('error', function (err) {
            return callback(this._formatError(err, 'ESTREAM'));
        }.bind(this));
    }

    this._setEnvelope(envelope, function (err, info) {
        if (err) {
            return callback(err);
        }
        var stream = this._createSendStream(function (err, str) {
            if (err) {
                return callback(err);
            }
            info.response = str;
            return callback(null, info);
        });
        if (typeof message.pipe === 'function') {
            message.pipe(stream);
        } else {
            stream.write(message);
            stream.end();
        }

    }.bind(this));
};

/**
 * Connection listener that is run when the connection to
 * the server is opened
 *
 * @event
 */
SMTPConnection.prototype._onConnect = function () {
    clearTimeout(this._connectionTimeout);

    this.logger.info('[%s] %s established to %s:%s', this.id, this.secure ? 'Secure connection' : 'Connection', this._socket.remoteAddress, this._socket.remotePort);

    if (this._destroyed) {
        // Connection was established after we already had canceled it
        this.close();
        return;
    }

    this.stage = 'connected';

    // clear existing listeners for the socket
    this._socket.removeAllListeners('data');
    this._socket.removeAllListeners('timeout');
    this._socket.removeAllListeners('close');
    this._socket.removeAllListeners('end');

    this._socket.on('data', this._onData.bind(this));
    this._socket.once('close', this._onClose.bind(this));
    this._socket.once('end', this._onEnd.bind(this));

    this._socket.setTimeout(this.options.socketTimeout || (10 * 60 * 1000)); // 10 min.
    this._socket.on('timeout', this._onTimeout.bind(this));

    this._greetingTimeout = setTimeout(function () {
        // if still waiting for greeting, give up
        if (this._socket && !this._destroyed && this._currentAction === this._actionGreeting) {
            this._onError('Greeting never received', 'ETIMEDOUT');
        }
    }.bind(this), this.options.greetingTimeout || 10000);

    this._currentAction = this._actionGreeting;

    // we have a 'data' listener set up so resume socket if it was paused
    this._socket.resume();
};

/**
 * 'data' listener for data coming from the server
 *
 * @event
 * @param {Buffer} chunk Data chunk coming from the server
 */
SMTPConnection.prototype._onData = function (chunk) {
    if (this._destroyed || !chunk || !chunk.length) {
        return;
    }

    var data = (chunk || '').toString('binary');
    var lines = (this._remainder + data).split(/\r?\n/);
    var lastline;

    this._remainder = lines.pop();

    for (var i = 0, len = lines.length; i < len; i++) {
        if (this._responseQueue.length) {
            lastline = this._responseQueue[this._responseQueue.length - 1];
            if (/^\d+\-/.test(lastline.split('\n').pop())) {
                this._responseQueue[this._responseQueue.length - 1] += '\n' + lines[i];
                continue;
            }
        }
        this._responseQueue.push(lines[i]);
    }

    this._processResponse();
};

/**
 * 'error' listener for the socket
 *
 * @event
 * @param {Error} err Error object
 * @param {String} type Error name
 */
SMTPConnection.prototype._onError = function (err, type, data) {
    clearTimeout(this._connectionTimeout);
    clearTimeout(this._greetingTimeout);

    if (this._destroyed) {
        // just ignore, already closed
        // this might happen when a socket is canceled because of reached timeout
        // but the socket timeout error itself receives only after
        return;
    }

    err = this._formatError(err, type, data);

    this.logger.error('[%s] %s', this.id, err.message);

    this.emit('error', err);
    this.close();
};

SMTPConnection.prototype._formatError = function (message, type, response) {
    var err;

    if (/Error\]$/i.test(Object.prototype.toString.call(message))) {
        err = message;
    } else {
        err = new Error(message);
    }

    if (type && type !== 'Error') {
        err.code = type;
    }

    if (response) {
        err.response = response;
        err.message += ': ' + response;
    }

    var responseCode = typeof response === 'string' && Number((response.match(/^\d+/) || [])[0]) || false;
    if (responseCode) {
        err.responseCode = responseCode;
    }

    return err;
};

/**
 * 'close' listener for the socket
 *
 * @event
 */
SMTPConnection.prototype._onClose = function () {
    this.logger.info('[%s] Connection closed', this.id);

    if ([this._actionGreeting, this.close].indexOf(this._currentAction) < 0 && !this._destroyed) {
        return this._onError(new Error('Connection closed unexpectedly'), 'ECONNECTION');
    }

    this._destroy();
};

/**
 * 'end' listener for the socket
 *
 * @event
 */
SMTPConnection.prototype._onEnd = function () {
    this._destroy();
};

/**
 * 'timeout' listener for the socket
 *
 * @event
 */
SMTPConnection.prototype._onTimeout = function () {
    return this._onError(new Error('Timeout'), 'ETIMEDOUT');
};

/**
 * Destroys the client, emits 'end'
 */
SMTPConnection.prototype._destroy = function () {
    if (this._destroyed) {
        return;
    }
    this._destroyed = true;
    this.emit('end');
};

/**
 * Upgrades the connection to TLS
 *
 * @param {Function} callback Callback function to run when the connection
 *        has been secured
 */
SMTPConnection.prototype._upgradeConnection = function (callback) {
    // do not remove all listeners or it breaks node v0.10 as there's
    // apparently a 'finish' event set that would be cleared as well

    // we can safely keep 'error', 'end', 'close' etc. events
    this._socket.removeAllListeners('data'); // incoming data is going to be gibberish from this point onwards
    this._socket.removeAllListeners('timeout'); // timeout will be re-set for the new socket object

    var socketPlain = this._socket;
    var opts = {
        socket: this._socket,
        host: this.host
    };

    Object.keys(this.options.tls || {}).forEach(function (key) {
        opts[key] = this.options.tls[key];
    }.bind(this));

    this._socket = tls.connect(opts, function () {
        this.secure = true;
        this._socket.on('data', this._onData.bind(this));

        socketPlain.removeAllListeners('close');
        socketPlain.removeAllListeners('end');

        return callback(null, true);
    }.bind(this));

    this._socket.on('error', this._onError.bind(this));
    this._socket.once('close', this._onClose.bind(this));
    this._socket.once('end', this._onEnd.bind(this));

    this._socket.setTimeout(this.options.socketTimeout || (10 * 60 * 1000)); // 10 min.
    this._socket.on('timeout', this._onTimeout.bind(this));

    // resume in case the socket was paused
    socketPlain.resume();
};

/**
 * Processes queued responses from the server
 *
 * @param {Boolean} force If true, ignores _processing flag
 */
SMTPConnection.prototype._processResponse = function () {
    if (!this._responseQueue.length) {
        return false;
    }

    var str = (this._responseQueue.shift() || '').toString();

    if (/^\d+\-/.test(str.split('\n').pop())) {
        // keep waiting for the final part of multiline response
        return;
    }

    if (this.options.debug) {
        this.logger.debug('[%s] S: %s', this.id, str.replace(/\r?\n$/, ''));
    }

    if (!str.trim()) { // skip unexpected empty lines
        setImmediate(this._processResponse.bind(this, true));
    }

    var action = this._currentAction;
    this._currentAction = null;

    if (typeof action === 'function') {
        action.call(this, str);
        setImmediate(this._processResponse.bind(this, true));
    } else {
        return this._onError(new Error('Unexpected Response'), 'EPROTOCOL', str);
    }
};

/**
 * Send a command to the server, append \r\n
 *
 * @param {String} str String to be sent to the server
 */
SMTPConnection.prototype._sendCommand = function (str) {
    if (this._destroyed) {
        // Connection already closed, can't send any more data
        return;
    }

    if (this._socket.destroyed) {
        return this.close();
    }

    if (this.options.debug) {
        this.logger.debug('[%s] C: %s', this.id, (str || '').toString().replace(/\r?\n$/, ''));
    }

    this._socket.write(new Buffer(str + '\r\n', 'utf-8'));
};

/**
 * Initiates a new message by submitting envelope data, starting with
 * MAIL FROM: command
 *
 * @param {Object} envelope Envelope object in the form of
 *        {from:'...', to:['...']}
 *        or
 *        {from:{address:'...',name:'...'}, to:[address:'...',name:'...']}
 */
SMTPConnection.prototype._setEnvelope = function (envelope, callback) {
    var args = [];
    var useSmtpUtf8 = false;

    this._envelope = envelope || {};
    this._envelope.from = (this._envelope.from && this._envelope.from.address || this._envelope.from || '').toString().trim();

    this._envelope.to = [].concat(this._envelope.to || []).map(function (to) {
        return (to && to.address || to || '').toString().trim();
    });

    if (!this._envelope.to.length) {
        return callback(this._formatError('No recipients defined', 'EENVELOPE'));
    }

    if (this._envelope.from && /[\r\n<>]/.test(this._envelope.from)) {
        return callback(this._formatError('Invalid sender ' + JSON.stringify(this._envelope.from), 'EENVELOPE'));
    }

    // check if the sender address uses only ASCII characters,
    // otherwise require usage of SMTPUTF8 extension
    if (/[\x80-\uFFFF]/.test(this._envelope.from)) {
        useSmtpUtf8 = true;
    }

    for (var i = 0, len = this._envelope.to.length; i < len; i++) {
        if (!this._envelope.to[i] || /[\r\n<>]/.test(this._envelope.to[i])) {
            return callback(this._formatError('Invalid recipient ' + JSON.stringify(this._envelope.to[i]), 'EENVELOPE'));
        }

        // check if the recipients addresses use only ASCII characters,
        // otherwise require usage of SMTPUTF8 extension
        if (/[\x80-\uFFFF]/.test(this._envelope.to[i])) {
            useSmtpUtf8 = true;
        }
    }

    // clone the recipients array for latter manipulation
    this._envelope.rcptQueue = JSON.parse(JSON.stringify(this._envelope.to || []));
    this._envelope.rejected = [];
    this._envelope.accepted = [];

    this._currentAction = function (str) {
        this._actionMAIL(str, callback);
    }.bind(this);

    // If the server supports SMTPUTF8 and the envelope includes an internationalized
    // email address then append SMTPUTF8 keyword to the MAIL FROM command
    if (useSmtpUtf8 && this._supportedExtensions.indexOf('SMTPUTF8') >= 0) {
        args.push('SMTPUTF8');
    }

    this._sendCommand('MAIL FROM:<' + (this._envelope.from) + '>' + (args.length ? ' ' + args.join(' ') : ''));
};

SMTPConnection.prototype._createSendStream = function (callback) {
    var dataStream = new DataStream();
    var logStream;

    this._currentAction = function (str) {
        this._actionStream(str, callback);
    }.bind(this);

    dataStream.pipe(this._socket, {
        end: false
    });

    if (this.options.debug) {
        logStream = new PassThrough();
        logStream.on('readable', function () {
            var chunk;
            while ((chunk = logStream.read())) {
                this.logger.debug('[%s] C: %s', this.id, chunk.toString('binary').replace(/\r?\n$/, ''));
            }
        }.bind(this));
        dataStream.pipe(logStream);
    }

    dataStream.once('end', function () {
        this.logger.info('[%s] C: <%s bytes encoded mime message (source size %s bytes)>', this.id, dataStream.outByteCount, dataStream.inByteCount);
    }.bind(this));

    return dataStream;
};

/** ACTIONS **/

/**
 * Will be run after the connection is created and the server sends
 * a greeting. If the incoming message starts with 220 initiate
 * SMTP session by sending EHLO command
 *
 * @param {String} str Message from the server
 */
SMTPConnection.prototype._actionGreeting = function (str) {
    clearTimeout(this._greetingTimeout);

    if (str.substr(0, 3) !== '220') {
        this._onError(new Error('Invalid greeting from server:\n' + str), 'EPROTOCOL', str);
        return;
    }

    if (this.options.lmtp) {
        this._currentAction = this._actionLHLO;
        this._sendCommand('LHLO ' + this.name);
    } else {
        this._currentAction = this._actionEHLO;
        this._sendCommand('EHLO ' + this.name);
    }
};

/**
 * Handles server response for LHLO command. If it yielded in
 * error, emit 'error', otherwise treat this as an EHLO response
 *
 * @param {String} str Message from the server
 */
SMTPConnection.prototype._actionLHLO = function (str) {
    if (str.charAt(0) !== '2') {
        this._onError(new Error('Invalid response for LHLO:\n' + str), 'EPROTOCOL', str);
        return;
    }

    this._actionEHLO(str);
};

/**
 * Handles server response for EHLO command. If it yielded in
 * error, try HELO instead, otherwise initiate TLS negotiation
 * if STARTTLS is supported by the server or move into the
 * authentication phase.
 *
 * @param {String} str Message from the server
 */
SMTPConnection.prototype._actionEHLO = function (str) {
    if (str.substr(0, 3) === '421') {
        this._onError(new Error('Server terminates connection:\n' + str), 'ECONNECTION', str);
        return;
    }

    if (str.charAt(0) !== '2') {
        if (this.options.requireTLS) {
            this._onError(new Error('EHLO failed but HELO does not support required STARTTLS:\n' + str), 'ECONNECTION', str);
            return;
        }

        // Try HELO instead
        this._currentAction = this._actionHELO;
        this._sendCommand('HELO ' + this.name);
        return;
    }

    // Detect if the server supports STARTTLS
    if (!this.secure && !this.options.ignoreTLS && (/[ \-]STARTTLS\b/mi.test(str) || this.options.requireTLS)) {
        this._sendCommand('STARTTLS');
        this._currentAction = this._actionSTARTTLS;
        return;
    }

    // Detect if the server supports SMTPUTF8
    if (/[ \-]SMTPUTF8\b/mi.test(str)) {
        this._supportedExtensions.push('SMTPUTF8');
    }

    // Detect if the server supports PLAIN auth
    if (str.match(/AUTH(?:(\s+|=)[^\n]*\s+|\s+|=)PLAIN/i)) {
        this._supportedAuth.push('PLAIN');
    }

    // Detect if the server supports LOGIN auth
    if (str.match(/AUTH(?:(\s+|=)[^\n]*\s+|\s+|=)LOGIN/i)) {
        this._supportedAuth.push('LOGIN');
    }

    // Detect if the server supports CRAM-MD5 auth
    if (str.match(/AUTH(?:(\s+|=)[^\n]*\s+|\s+|=)CRAM-MD5/i)) {
        this._supportedAuth.push('CRAM-MD5');
    }

    // Detect if the server supports XOAUTH2 auth
    if (str.match(/AUTH(?:(\s+|=)[^\n]*\s+|\s+|=)XOAUTH2/i)) {
        this._supportedAuth.push('XOAUTH2');
    }

    this.emit('connect');
};

/**
 * Handles server response for HELO command. If it yielded in
 * error, emit 'error', otherwise move into the authentication phase.
 *
 * @param {String} str Message from the server
 */
SMTPConnection.prototype._actionHELO = function (str) {
    if (str.charAt(0) !== '2') {
        this._onError(new Error('Invalid response for EHLO/HELO:\n' + str), 'EPROTOCOL', str);
        return;
    }

    this.emit('connect');
};

/**
 * Handles server response for STARTTLS command. If there's an error
 * try HELO instead, otherwise initiate TLS upgrade. If the upgrade
 * succeedes restart the EHLO
 *
 * @param {String} str Message from the server
 */
SMTPConnection.prototype._actionSTARTTLS = function (str) {
    if (str.charAt(0) !== '2') {
        this._onError(new Error('Error upgrading connection with STARTTLS'), 'ETLS', str);
        return;
    }

    this._upgradeConnection(function (err, secured) {
        if (err) {
            this._onError(new Error('Error initiating TLS - ' + (err.message || err)), 'ETLS');
            return;
        }

        this.logger.info('[%s] Connection upgraded with STARTTLS', this.id);

        if (secured) {
            // restart session
            this._currentAction = this._actionEHLO;
            this._sendCommand('EHLO ' + this.name);
        } else {
            this.emit('connect');
        }
    }.bind(this));
};

/**
 * Handle the response for AUTH LOGIN command. We are expecting
 * '334 VXNlcm5hbWU6' (base64 for 'Username:'). Data to be sent as
 * response needs to be base64 encoded username.
 *
 * @param {String} str Message from the server
 */
SMTPConnection.prototype._actionAUTH_LOGIN_USER = function (str, callback) {
    if (str !== '334 VXNlcm5hbWU6') {
        callback(this._formatError('Invalid login sequence while waiting for "334 VXNlcm5hbWU6"', 'EAUTH', str));
        return;
    }

    this._currentAction = function (str) {
        this._actionAUTH_LOGIN_PASS(str, callback);
    }.bind(this);

    this._sendCommand(new Buffer(this._auth.user + '', 'utf-8').toString('base64'));
};

/**
 * Handle the response for AUTH NTLM, which should be a
 * '334 <challenge string>'. See http://davenport.sourceforge.net/ntlm.html
 * We already sent the Type1 message, the challenge is a Type2 message, we
 * need to respond with a Type3 message.
 *
 * @param {String} str Message from the server
 */
SMTPConnection.prototype._actionAUTH_NTLM_TYPE1 = function (str, callback) {
    var challengeMatch = str.match(/^334\s+(.+)$/);
    var challengeString = '';

    if (!challengeMatch) {
        return callback(this._formatError('Invalid login sequence while waiting for server challenge string', 'EAUTH', str));
    } else {
        challengeString = challengeMatch[1];
    }

    if (!/^NTLM/i.test(challengeString)) {
        challengeString = 'NTLM ' + challengeString;
    }

    var type2Message = ntlm.parseType2Message(challengeString, callback);
    if (!type2Message) {
        return;
    }

    var type3Message = ntlm.createType3Message(type2Message, {
        domain: this._auth.domain || '',
        workstation: this._auth.workstation || '',
        username: this._auth.user,
        password: this._auth.pass
    });

    type3Message = type3Message.substring(5); // remove the "NTLM " prefix

    this._currentAction = function (str) {
        this._actionAUTH_NTLM_TYPE3(str, callback);
    }.bind(this);

    this._sendCommand(type3Message);
};

/**
 * Handle the response for AUTH CRAM-MD5 command. We are expecting
 * '334 <challenge string>'. Data to be sent as response needs to be
 * base64 decoded challenge string, MD5 hashed using the password as
 * a HMAC key, prefixed by the username and a space, and finally all
 * base64 encoded again.
 *
 * @param {String} str Message from the server
 */
SMTPConnection.prototype._actionAUTH_CRAM_MD5 = function (str, callback) {
    var challengeMatch = str.match(/^334\s+(.+)$/);
    var challengeString = '';

    if (!challengeMatch) {
        return callback(this._formatError('Invalid login sequence while waiting for server challenge string', 'EAUTH', str));
    } else {
        challengeString = challengeMatch[1];
    }

    // Decode from base64
    var base64decoded = new Buffer(challengeString, 'base64').toString('ascii'),
        hmac_md5 = crypto.createHmac('md5', this._auth.pass);

    hmac_md5.update(base64decoded);

    var hex_hmac = hmac_md5.digest('hex'),
        prepended = this._auth.user + ' ' + hex_hmac;

    this._currentAction = function (str) {
        this._actionAUTH_CRAM_MD5_PASS(str, callback);
    }.bind(this);


    this._sendCommand(new Buffer(prepended).toString('base64'));
};

/**
 * Handles the response to CRAM-MD5 authentication, if there's no error,
 * the user can be considered logged in. Start waiting for a message to send
 *
 * @param {String} str Message from the server
 */
SMTPConnection.prototype._actionAUTH_CRAM_MD5_PASS = function (str, callback) {
    if (!str.match(/^235\s+/)) {
        return callback(this._formatError('Invalid login sequence while waiting for "235"', 'EAUTH', str));
    }

    this.logger.info('[%s] User %s authenticated', this.id, JSON.stringify(this._user));
    this.authenticated = true;
    callback(null, true);
};

/**
 * Handles the TYPE3 response for NTLM authentication, if there's no error,
 * the user can be considered logged in. Start waiting for a message to send
 *
 * @param {String} str Message from the server
 */
SMTPConnection.prototype._actionAUTH_NTLM_TYPE3 = function (str, callback) {
    if (!str.match(/^235\s+/)) {
        return callback(this._formatError('Invalid login sequence while waiting for "235"', 'EAUTH', str));
    }

    this.logger.info('[%s] User %s authenticated', this.id, JSON.stringify(this._user));
    this.authenticated = true;
    callback(null, true);
};

/**
 * Handle the response for AUTH LOGIN command. We are expecting
 * '334 UGFzc3dvcmQ6' (base64 for 'Password:'). Data to be sent as
 * response needs to be base64 encoded password.
 *
 * @param {String} str Message from the server
 */
SMTPConnection.prototype._actionAUTH_LOGIN_PASS = function (str, callback) {
    if (str !== '334 UGFzc3dvcmQ6') {
        return callback(this._formatError('Invalid login sequence while waiting for "334 UGFzc3dvcmQ6"', 'EAUTH', str));
    }

    this._currentAction = function (str) {
        this._actionAUTHComplete(str, callback);
    }.bind(this);

    this._sendCommand(new Buffer(this._auth.pass + '', 'utf-8').toString('base64'));
};

/**
 * Handles the response for authentication, if there's no error,
 * the user can be considered logged in. Start waiting for a message to send
 *
 * @param {String} str Message from the server
 */
SMTPConnection.prototype._actionAUTHComplete = function (str, isRetry, callback) {
    if (!callback && typeof isRetry === 'function') {
        callback = isRetry;
        isRetry = undefined;
    }

    if (str.substr(0, 3) === '334') {
        this._currentAction = function (str) {
            if (isRetry || !this._auth.xoauth2 || typeof this._auth.xoauth2 !== 'object') {
                this._actionAUTHComplete(str, true, callback);
            } else {
                setTimeout(this._handleXOauth2Token.bind(this, true, callback), Math.random() * 4000 + 1000);
            }
        }.bind(this);
        this._sendCommand('');
        return;
    }

    if (str.charAt(0) !== '2') {
        this.logger.info('[%s] User %s failed to authenticate', this.id, JSON.stringify(this._user));
        return callback(this._formatError('Invalid login', 'EAUTH', str));
    }

    this.logger.info('[%s] User %s authenticated', this.id, JSON.stringify(this._user));
    this.authenticated = true;
    callback(null, true);
};

/**
 * Handle response for a MAIL FROM: command
 *
 * @param {String} str Message from the server
 */
SMTPConnection.prototype._actionMAIL = function (str, callback) {
    if (Number(str.charAt(0)) !== 2) {
        return callback(this._formatError('Mail command failed', 'EENVELOPE', str));
    }

    if (!this._envelope.rcptQueue.length) {
        return callback(this._formatError('Can\'t send mail - no recipients defined', 'EENVELOPE'));
    } else {
        this._envelope.curRecipient = this._envelope.rcptQueue.shift();
        this._currentAction = function (str) {
            this._actionRCPT(str, callback);
        }.bind(this);
        this._sendCommand('RCPT TO:<' + this._envelope.curRecipient + '>');
    }
};

/**
 * Handle response for a RCPT TO: command
 *
 * @param {String} str Message from the server
 */
SMTPConnection.prototype._actionRCPT = function (str, callback) {
    if (Number(str.charAt(0)) !== 2) {
        // this is a soft error
        this._envelope.rejected.push(this._envelope.curRecipient);
    } else {
        this._envelope.accepted.push(this._envelope.curRecipient);
    }

    if (!this._envelope.rcptQueue.length) {
        if (this._envelope.rejected.length < this._envelope.to.length) {
            this._currentAction = function (str) {
                this._actionDATA(str, callback);
            }.bind(this);
            this._sendCommand('DATA');
        } else {
            return callback(this._formatError('Can\'t send mail - all recipients were rejected', 'EENVELOPE', str));
        }
    } else {
        this._envelope.curRecipient = this._envelope.rcptQueue.shift();
        this._currentAction = function (str) {
            this._actionRCPT(str, callback);
        }.bind(this);
        this._sendCommand('RCPT TO:<' + this._envelope.curRecipient + '>');
    }
};

/**
 * Handle response for a DATA command
 *
 * @param {String} str Message from the server
 */
SMTPConnection.prototype._actionDATA = function (str, callback) {
    // response should be 354 but according to this issue https://github.com/eleith/emailjs/issues/24
    // some servers might use 250 instead, so lets check for 2 or 3 as the first digit
    if ([2, 3].indexOf(Number(str.charAt(0))) < 0) {
        return callback(this._formatError('Data command failed', 'EENVELOPE', str));
    }

    callback(null, {
        accepted: this._envelope.accepted,
        rejected: this._envelope.rejected
    });
};

/**
 * Handle response for a DATA stream
 *
 * @param {String} str Message from the server
 */
SMTPConnection.prototype._actionStream = function (str, callback) {
    if (Number(str.charAt(0)) !== 2) {
        // Message failed
        return callback(this._formatError('Message failed', 'EMESSAGE', str));
    } else {
        // Message sent succesfully
        return callback(null, str);
    }
};

SMTPConnection.prototype._handleXOauth2Token = function (isRetry, callback) {
    this._currentAction = function (str) {
        this._actionAUTHComplete(str, isRetry, callback);
    }.bind(this);

    if (this._auth.xoauth2 && typeof this._auth.xoauth2 === 'object') {
        this._auth.xoauth2[isRetry ? 'generateToken' : 'getToken'](function (err, token) {
            if (err) {
                this.logger.info('[%s] User %s failed to authenticate', this.id, JSON.stringify(this._user));
                return callback(this._formatError(err, 'EAUTH'));
            }
            this._sendCommand('AUTH XOAUTH2 ' + token);
        }.bind(this));
    } else {
        this._sendCommand('AUTH XOAUTH2 ' + this._buildXOAuth2Token(this._auth.user, this._auth.xoauth2));
    }
};

/**
 * Builds a login token for XOAUTH2 authentication command
 *
 * @param {String} user E-mail address of the user
 * @param {String} token Valid access token for the user
 * @return {String} Base64 formatted login token
 */
SMTPConnection.prototype._buildXOAuth2Token = function (user, token) {
    var authData = [
        'user=' + (user || ''),
        'auth=Bearer ' + token,
        '',
        ''
    ];
    return new Buffer(authData.join('\x01')).toString('base64');
};

SMTPConnection.prototype._getHostname = function () {
    // defaul hostname is machine hostname or [IP]
    var defaultHostname = os.hostname() || '';

    // ignore if not FQDN
    if (defaultHostname.indexOf('.') < 0) {
        defaultHostname = '[127.0.0.1]';
    }

    // IP should be enclosed in []
    if (defaultHostname.match(/^\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}$/)) {
        defaultHostname = '[' + defaultHostname + ']';
    }

    return defaultHostname;
};

}).call(this,require("buffer").Buffer)
},{"../package.json":86,"./data-stream":84,"buffer":9,"crypto":11,"events":16,"httpntlm/ntlm":42,"net":8,"nodemailer-shared":74,"os":91,"stream":23,"tls":8,"util":104}],86:[function(require,module,exports){
module.exports={
  "_args": [
    [
      "smtp-connection@https://registry.npmjs.org/smtp-connection/-/smtp-connection-2.5.0.tgz",
      "/Users/nhong/nickhong.io/node_modules/nodemailer"
    ]
  ],
  "_from": "smtp-connection@2.5.0",
  "_id": "smtp-connection@2.5.0",
  "_inCache": true,
  "_location": "/nodemailer/smtp-connection",
  "_phantomChildren": {},
  "_requested": {
    "name": "smtp-connection",
    "raw": "smtp-connection@https://registry.npmjs.org/smtp-connection/-/smtp-connection-2.5.0.tgz",
    "rawSpec": "https://registry.npmjs.org/smtp-connection/-/smtp-connection-2.5.0.tgz",
    "scope": null,
    "spec": "https://registry.npmjs.org/smtp-connection/-/smtp-connection-2.5.0.tgz",
    "type": "remote"
  },
  "_requiredBy": [
    "/nodemailer/nodemailer-direct-transport",
    "/nodemailer/nodemailer-smtp-pool",
    "/nodemailer/nodemailer-smtp-transport"
  ],
  "_resolved": "https://registry.npmjs.org/smtp-connection/-/smtp-connection-2.5.0.tgz",
  "_shasum": "05998f0937aa27554ce1aa3b0bdfdbfb4cfb35a7",
  "_shrinkwrap": null,
  "_spec": "smtp-connection@https://registry.npmjs.org/smtp-connection/-/smtp-connection-2.5.0.tgz",
  "_where": "/Users/nhong/nickhong.io/node_modules/nodemailer",
  "author": {
    "name": "Andris Reinman"
  },
  "bugs": {
    "url": "https://github.com/andris9/smtp-connection/issues"
  },
  "dependencies": {
    "httpntlm": "1.6.1",
    "nodemailer-shared": "1.0.5"
  },
  "description": "Connect to SMTP servers",
  "devDependencies": {
    "chai": "^3.5.0",
    "grunt": "^1.0.1",
    "grunt-cli": "^1.2.0",
    "grunt-eslint": "^18.1.0",
    "grunt-mocha-test": "^0.12.7",
    "mocha": "^2.4.5",
    "proxy-test-server": "^1.0.0",
    "sinon": "^1.17.4",
    "smtp-server": "^1.9.1",
    "xoauth2": "^1.1.0"
  },
  "directories": {
    "test": "test"
  },
  "homepage": "https://github.com/andris9/smtp-connection",
  "keywords": [
    "SMTP"
  ],
  "license": "MIT",
  "main": "lib/smtp-connection.js",
  "name": "smtp-connection",
  "optionalDependencies": {},
  "readme": "# smtp-connection\n\nSMTP client module. Connect to SMTP servers and send mail with it.\n\nThis module is the successor for the client part of the (now deprecated) SMTP module [simplesmtp](https://www.npmjs.com/package/simplesmtp). For matching SMTP server see [smtp-server](https://www.npmjs.com/package/smtp-server).\n\n[![Build Status](https://secure.travis-ci.org/nodemailer/smtp-connection.svg)](http://travis-ci.org/nodemailer/smtp-connection)\n[![npm version](https://badge.fury.io/js/smtp-connection.svg)](http://badge.fury.io/js/smtp-connection)\n\n## Usage\n\nInstall with npm\n\n    npm install smtp-connection\n\nRequire in your script\n\n    var SMTPConnection = require('smtp-connection');\n\n### Create SMTPConnection instance\n\n```javascript\nvar connection = new SMTPConnection(options);\n```\n\nWhere\n\n  * **options** defines connection data\n    * **options.port** is the port to connect to (defaults to 25 or 465)\n    * **options.host** is the hostname or IP address to connect to (defaults to 'localhost')\n    * **options.secure** defines if the connection should use SSL (if `true`) or not (if `false`)\n    * **options.ignoreTLS** turns off STARTTLS support if true\n    * **options.requireTLS** forces the client to use STARTTLS. Returns an error if upgrading the connection is not possible or fails.\n    * **options.name** optional hostname of the client, used for identifying to the server\n    * **options.localAddress** is the local interface to bind to for network connections\n    * **options.connectionTimeout** how many milliseconds to wait for the connection to establish\n    * **options.greetingTimeout** how many milliseconds to wait for the greeting after connection is established\n    * **options.socketTimeout** how many milliseconds of inactivity to allow\n    * **options.logger** optional [bunyan](https://github.com/trentm/node-bunyan) compatible logger instance. If set to `true` then logs to console. If value is not set or is `false` then nothing is logged\n    * **options.debug** if set to true, then logs SMTP traffic, otherwise logs only transaction events\n    * **options.lmtp** if true, uses LMTP instead of SMTP to talk to the server. Partial support, does not work well with multiple recipients\n    * **options.authMethod** defines preferred authentication method, e.g. 'PLAIN'\n    * **options.tls** defines additional options to be passed to the socket constructor, e.g. *{rejectUnauthorized: true}*\n    * **options.socket** - initialized socket to use instead of creating a new one\n    * **options.connection** - connected socket to use instead of creating and connecting a new one. If `secure` option is true, then socket is upgraded from plaintext to ciphertext\n\n### Events\n\nSMTPConnection instances are event emitters with the following events\n\n  * **'error'** *(err)* emitted when an error occurs. Connection is closed automatically in this case.\n  * **'connect'** emitted when the connection is established\n  * **'end'** when the instance is destroyed\n\n### connect\n\nEstablish the connection\n\n```javascript\nconnection.connect(callback)\n```\n\nWhere\n\n  * **callback** is the function to run once the connection is established. The function is added as a listener to the 'connect' event.\n\nAfter the connect event the `connection` has the following properties:\n\n  * **connection.secure** - if `true` then the connection uses a TLS socket, otherwise it is using a cleartext socket. Connection can start out as cleartext but if available (or `requireTLS` is set to true) connection upgrade is tried\n\n### login\n\nIf the server requires authentication you can login with\n\n```javascript\nconnection.login(auth, callback)\n```\n\nWhere\n\n  * **auth** is the authentication object\n    * **auth.user** is the username\n    * **auth.pass** is the password for the user\n    * **auth.xoauth2** is the OAuth2 access token (preferred if both `pass` and `xoauth2` values are set) or an [XOAuth2](https://github.com/andris9/xoauth2) token generator object.\n  * **callback** is the callback to run once the authentication is finished. Callback has the following arguments\n    * **err** and error object if authentication failed\n\nIf a [XOAuth2](https://github.com/andris9/xoauth2) token generator is used as the value for `auth.xoauth2` then you do not need to set `auth.user`. XOAuth2 generator generates required accessToken itself if it is missing or expired. In this case if the authentication fails, a new token is requeested and the authentication is retried. If it still fails, an error is returned.\n\n**XOAuth2 Example**\n\n```javascript\nvar generator = require('xoauth2').createXOAuth2Generator({\n    user: '{username}',\n    clientId: '{Client ID}',\n    clientSecret: '{Client Secret}',\n    refreshToken: '{refresh-token}'\n});\n\n// listen for token updates\n// you probably want to store these to a db\ngenerator.on('token', function(token){\n    console.log('New token for %s: %s', token.user, token.accessToken);\n});\n\n// login\nconnection.login({\n    xoauth2: generator\n}, callback);\n```\n\n### Login using NTLM\n\n`smtp-connection` has experimental support for NTLM authentication. You can try it out like this:\n\n```javascript\nconnection.login({\n    domain: 'windows-domain',\n    workstation: 'windows-workstation',\n    user: 'user@somedomain.com',\n    pass: 'pass'\n}, callback);\n```\n\nI do not have access to an actual server that supports NTLM authentication\nso this feature is untested and should be used carefully.\n\n### send\n\nOnce the connection is authenticated (or just after connection is established if authentication is not required), you can send mail with\n\n```javascript\nconnection.send(envelope, message, callback)\n```\n\nWhere\n\n  * **envelope** is the envelope object to use\n    * **envelope.from** is the sender address\n    * **envelope.to** is the recipient address or an array of addresses\n  * **message** is either a String, Buffer or a Stream. All newlines are converted to \\r\\n and all dots are escaped automatically, no need to convert anything before.\n  * **callback** is the callback to run once the sending is finished or failed. Callback has the following arguments\n    * **err** and error object if sending failed\n      * **code** string code identifying the error, for example 'EAUTH' is returned when authentication fails\n      * **response** is the last response received from the server (if the error is caused by an error response from the server)\n      * **responseCode** is the numeric response code of the `response` string (if available)\n    * **info** information object about accepted and rejected recipients\n      * **accepted** and array of accepted recipient addresses\n      * **rejected** and array of rejected recipient addresses\n      * **response** is the last response received from the server\n\n### quit\n\nUse it for graceful disconnect\n\n```javascript\nconnection.quit();\n```\n\n### close\n\nUse it for less graceful disconnect\n\n```javascript\nconnection.close();\n```\n\n## License\n\n**MIT**\n",
  "readmeFilename": "README.md",
  "repository": {
    "type": "git",
    "url": "git://github.com/andris9/smtp-connection.git"
  },
  "scripts": {
    "test": "grunt"
  },
  "version": "2.5.0"
}

},{}],87:[function(require,module,exports){
var SocksClient = require('./lib/socks-client.js');
var SocksAgent = require('./lib/socks-agent.js');

exports.createConnection = SocksClient.createConnection;
exports.createUDPFrame = SocksClient.createUDPFrame;
exports.Agent = SocksAgent.Agent;

},{"./lib/socks-agent.js":88,"./lib/socks-client.js":89}],88:[function(require,module,exports){
(function (process){
var tls = require('tls');
var inherits = require('util').inherits;
var EventEmitter = require('events').EventEmitter;
var SocksClient = require('./socks-client.js');

function SocksAgent(options, secure, rejectUnauthorized) {
    this.options = options;
    this.secure = secure || false;
    this.rejectUnauthorized = rejectUnauthorized;

    if (this.rejectUnauthorized === undefined) {
        this.rejectUnauthorized = true;
    }
}

inherits(SocksAgent, EventEmitter);

SocksAgent.prototype.createConnection = function(req, opts, fn) {
    var handler = fn, host, self = this;

    this.options.target = this.options.target || {};

    if (!this.options.target.host) {
        this.options.target.host = opts.host;
    }

    if (!this.options.target.port) {
        this.options.target.port = opts.port;
    }

    host = this.options.target.host;

    if (this.secure) {
        handler = function(err, socket, info) {
            var options, cleartext;

            if (err) {
                return fn(err);
            }

            // save encrypted socket
            self.encryptedSocket = socket;

            options = {
                socket: socket,
                servername: host,
                rejectUnauthorized: self.rejectUnauthorized
            };

            cleartext = tls.connect(options, function (err) {
                return fn(err, this);
            });
            cleartext.on('error', fn);

            socket.resume();
        }
    }

    SocksClient.createConnection(this.options, handler);
};

/**
 * @see https://www.npmjs.com/package/agent-base
 */
SocksAgent.prototype.addRequest = function(req, host, port, localAddress) {
    var opts;
    if ('object' === typeof host) {
        // >= v0.11.x API
        opts = host;
        if (opts.host && opts.path) {
            // if both a `host` and `path` are specified then it's most likely the
            // result of a `url.parse()` call... we need to remove the `path` portion so
            // that `net.connect()` doesn't attempt to open that as a unix socket file.
            delete opts.path;
        }
    } else {
        // <= v0.10.x API
        opts = { host: host, port: port };
        if (null !== localAddress) {
            opts.localAddress = localAddress;
        }
    }

    var sync = true;

    this.createConnection(req, opts, function (err, socket) {
        function emitErr () {
            req.emit('error', err);
        }
        if (err) {
            if (sync) {
                // need to defer the "error" event, when sync, because by now the `req`
                // instance hasn't event been passed back to the user yet...
                process.nextTick(emitErr);
            } else {
                emitErr();
            }
        } else {
            req.onSocket(socket);
            //have to resume this socket when node 12
            socket.resume();
        }
    });

    sync = false;
};

exports.Agent = SocksAgent;

}).call(this,require("7YKIPe"))
},{"./socks-client.js":89,"7YKIPe":17,"events":16,"tls":8,"util":104}],89:[function(require,module,exports){
(function (Buffer){
var net = require('net');
var ip = require('ip');
var SmartBuffer = require('smart-buffer');

(function () {

    var COMMAND = {
        Connect: 0x01,
        Bind: 0x02,
        Associate: 0x03
    };

    var SOCKS4_RESPONSE = {
        Granted: 0x5A,
        Failed: 0x5B,
        Rejected: 0x5C,
        RejectedIdent: 0x5D
    };

    var SOCKS5_AUTH = {
        NoAuth: 0x00,
        GSSApi: 0x01,
        UserPass: 0x02
    };

    var SOCKS5_RESPONSE = {
        Granted: 0x00,
        Failure: 0x01,
        NotAllowed: 0x02,
        NetworkUnreachable: 0x03,
        HostUnreachable: 0x04,
        ConnectionRefused: 0x05,
        TTLExpired: 0x06,
        CommandNotSupported: 0x07,
        AddressNotSupported: 0x08
    };


    exports.createConnection = function (options, callback) {
        var socket = new net.Socket(), finished = false, buff = new SmartBuffer();

        // Defaults
        options.timeout = options.timeout || 10000;
        options.proxy.command = commandFromString(options.proxy.command);
        options.proxy.userid = options.proxy.userid || "";

        var auth = options.proxy.authentication || {};
        auth.username = auth.username || "";
        auth.password = auth.password || "";

        options.proxy.authentication = auth;

        // Connect & negotiation timeout
        function onTimeout() {
            finish(new Error("Connection Timed Out"), socket, null, callback);
        }
        socket.setTimeout(options.timeout, onTimeout);

        // Socket events
        socket.once('close', function () {
            finish(new Error("Socket Closed"), socket, null, callback);
        });

        socket.once('error', function (err) {
        });

        socket.once('connect', function () {
            if (options.proxy.type === 4) {
                negotiateSocks4(options, socket, callback);
            } else if (options.proxy.type === 5) {
                negotiateSocks5(options, socket, callback);
            } else {
                throw new Error("Please specify a proxy type in options.proxy.type");
            }
        });

        socket.connect(options.proxy.port, options.proxy.ipaddress);


        // 4/4a  (connect, bind) - Supports domains & ipaddress
        function negotiateSocks4(options, socket, callback) {
            buff.writeUInt8(0x04);
            buff.writeUInt8(options.proxy.command);
            buff.writeUInt16BE(options.target.port);

            // ipv4 or domain?
            if (net.isIPv4(options.target.host)) {
                buff.writeBuffer(ip.toBuffer(options.target.host));
                buff.writeStringNT(options.proxy.userid);
            } else {
                buff.writeUInt8(0x00);
                buff.writeUInt8(0x00);
                buff.writeUInt8(0x00);
                buff.writeUInt8(0x01);
                buff.writeStringNT(options.proxy.userid);
                buff.writeStringNT(options.target.host);
            }

            socket.once('data', receivedResponse);
            socket.write(buff.toBuffer());

            function receivedResponse(data) {
                socket.pause();
                if (data.length === 8 && data[1] === SOCKS4_RESPONSE.Granted) {

                    if (options.proxy.command === COMMAND.Bind) {
                        buff.clear();
                        buff.writeBuffer(data);
                        buff.skip(2);

                        var info = {
                            port: buff.readUInt16BE(),
                            host: buff.readUInt32BE()
                        };

                        if (info.host === 0) {
                            info.host = options.proxy.ipaddress;
                        } else {
                            info.host = ip.fromLong(info.host);
                        }

                        finish(null, socket, info, callback);
                    } else {
                        finish(null, socket, null, callback);
                    }

                } else {
                    finish(new Error("Rejected (" + data[1] + ")"), socket, null, callback);
                }
            }
        }

        // Socks 5 (connect, bind, associate) - Supports domains and ipv4, ipv6.
        function negotiateSocks5(options, socket, callback) {
            buff.writeUInt8(0x05);
            buff.writeUInt8(2);
            buff.writeUInt8(SOCKS5_AUTH.NoAuth);
            buff.writeUInt8(SOCKS5_AUTH.UserPass);

            socket.once('data', handshake);
            socket.write(buff.toBuffer());

            function handshake(data) {
                if (data.length !== 2) {
                    finish(new Error("Negotiation Error"), socket, null, callback);
                } else if (data[0] !== 0x05) {
                    finish(new Error("Negotiation Error (invalid version)"), socket, null, callback);
                } else if (data[1] === 0xFF) {
                    finish(new Error("Negotiation Error (unacceptable authentication)"), socket, null, callback);
                } else {
                    if (data[1] === SOCKS5_AUTH.NoAuth) {
                        sendRequest();
                    } else if (data[1] === SOCKS5_AUTH.UserPass) {
                        sendAuthentication(options.proxy.authentication);
                    } else {
                        finish(new Error("Negotiation Error (unknown authentication type)"), socket, null, callback);
                    }
                }
            }

            function sendAuthentication(authinfo) {
                buff.clear();
                buff.writeUInt8(0x01);
                buff.writeUInt8(Buffer.byteLength(authinfo.username));
                buff.writeString(authinfo.username);
                buff.writeUInt8(Buffer.byteLength(authinfo.password));
                buff.writeString(authinfo.password);

                socket.once('data', authenticationResponse);
                socket.write(buff.toBuffer());

                function authenticationResponse(data) {
                    if (data.length === 2 && data[1] === 0x00) {
                        sendRequest();
                    } else {
                        finish(new Error("Negotiation Error (authentication failed)"), socket, null, callback);
                    }
                }
            }

            function sendRequest() {
                buff.clear();
                buff.writeUInt8(0x05);
                buff.writeUInt8(options.proxy.command);
                buff.writeUInt8(0x00);

                // ipv4, ipv6, domain?
                if (net.isIPv4(options.target.host)) {
                    buff.writeUInt8(0x01);
                    buff.writeBuffer(ip.toBuffer(options.target.host));
                } else if (net.isIPv6(options.target.host)) {
                    buff.writeUInt8(0x04);
                    buff.writeBuffer(ip.toBuffer(options.target.host));
                } else {
                    buff.writeUInt8(0x03);
                    buff.writeUInt8(options.target.host.length);
                    buff.writeString(options.target.host);
                }
                buff.writeUInt16BE(options.target.port);

                socket.once('data', receivedResponse);
                socket.write(buff.toBuffer());
            }

            function receivedResponse(data) {
                socket.pause();
                if (data.length < 4) {
                    finish(new Error("Negotiation Error"), socket, null, callback);
                } else if (data[0] === 0x05 && data[1] === SOCKS5_RESPONSE.Granted) {
                    if (options.proxy.command === COMMAND.Connect) {
                        finish(null, socket, null, callback);
                    } else if (options.proxy.command === COMMAND.Bind || options.proxy.command === COMMAND.Associate) {
                        buff.clear();
                        buff.writeBuffer(data);
                        buff.skip(3);

                        var info = {};
                        var addrtype = buff.readUInt8();

                        try {

                            if (addrtype === 0x01) {
                                info.host = buff.readUInt32BE();
                                if (info.host === 0)
                                    info.host = options.proxy.ipaddress;
                                else
                                    info.host = ip.fromLong(info.host);
                            } else if (addrtype === 0x03) {
                                var len = buff.readUInt8();
                                info.host = buff.readString(len);
                            } else if (addrtype === 0x04) {
                                info.host = buff.readBuffer(16);
                            } else {
                                finish(new Error("Negotiation Error (invalid host address)"), socket, null, callback);
                            }
                            info.port = buff.readUInt16BE();

                            finish(null, socket, info, callback);
                        } catch (ex) {
                            finish(new Error("Negotiation Error (missing data)"), socket, null, callback);
                        }
                    }
                } else {
                    finish(new Error("Negotiation Error (" + data[1] + ")"), socket, null, callback);
                }
            }
        }

        function finish(err, socket, info, callback) {
            socket.setTimeout(0, onTimeout);
            if (!finished) {
                finished = true;

                if (buff instanceof SmartBuffer)
                    buff.destroy();

                if (err && socket instanceof net.Socket) {
                    socket.removeAllListeners('close');
                    socket.removeAllListeners('timeout');
                    socket.removeAllListeners('data');
                    socket.destroy();
                    socket = null;
                }

                callback(err, socket, info);
            }
        }

        function commandFromString(str) {
            var result = COMMAND.Connect;

            if (str === "connect") {
                result = COMMAND.Connect;
            } else if (str === 'associate') {
                result = COMMAND.Associate;
            } else if (str === 'bind') {
                result = COMMAND.Bind;
            }

            return result;
        }
    };


    exports.createUDPFrame = function (target, data, frame) {
        var buff = new SmartBuffer();
        buff.writeUInt16BE(0);
        buff.writeUInt8(frame || 0x00);

        if (net.isIPv4(target.host)) {
            buff.writeUInt8(0x01);
            buff.writeUInt32BE(ip.toLong(target.host));
        } else if (net.isIPv6(target.host)) {
            buff.writeUInt8(0x04);
            buff.writeBuffer(ip.toBuffer(target.host));
        } else {
            buff.writeUInt8(0x03);
            buff.writeUInt8(Buffer.byteLength(target.host));
            buff.writeString(target.host);
        }

        buff.writeUInt16BE(target.port);
        buff.writeBuffer(data);
        return buff.toBuffer();
    };
})();

}).call(this,require("buffer").Buffer)
},{"buffer":9,"ip":62,"net":8,"smart-buffer":83}],90:[function(require,module,exports){
module.exports={
  "_args": [
    [
      "nodemailer",
      "/Users/nhong/nickhong.io"
    ]
  ],
  "_from": "nodemailer@latest",
  "_id": "nodemailer@2.4.1",
  "_inCache": true,
  "_installable": true,
  "_location": "/nodemailer",
  "_nodeVersion": "6.0.0",
  "_npmOperationalInternal": {
    "host": "packages-12-west.internal.npmjs.com",
    "tmp": "tmp/nodemailer-2.4.1.tgz_1463064956748_0.3808109597302973"
  },
  "_npmUser": {
    "email": "andris@kreata.ee",
    "name": "andris"
  },
  "_npmVersion": "3.8.6",
  "_phantomChildren": {},
  "_requested": {
    "name": "nodemailer",
    "raw": "nodemailer",
    "rawSpec": "",
    "scope": null,
    "spec": "latest",
    "type": "tag"
  },
  "_requiredBy": [
    "/"
  ],
  "_resolved": "https://registry.npmjs.org/nodemailer/-/nodemailer-2.4.1.tgz",
  "_shasum": "d5e375976f8772dcaa5c43f0669011d62aeab9e0",
  "_shrinkwrap": {
    "dependencies": {
      "addressparser": {
        "from": "addressparser@1.0.1",
        "resolved": "https://registry.npmjs.org/addressparser/-/addressparser-1.0.1.tgz",
        "version": "1.0.1"
      },
      "buildmail": {
        "from": "buildmail@3.7.0",
        "resolved": "https://registry.npmjs.org/buildmail/-/buildmail-3.7.0.tgz",
        "version": "3.7.0"
      },
      "httpntlm": {
        "from": "httpntlm@1.6.1",
        "resolved": "https://registry.npmjs.org/httpntlm/-/httpntlm-1.6.1.tgz",
        "version": "1.6.1"
      },
      "httpreq": {
        "from": "httpreq@>=0.4.22",
        "resolved": "https://registry.npmjs.org/httpreq/-/httpreq-0.4.22.tgz",
        "version": "0.4.22"
      },
      "iconv-lite": {
        "from": "iconv-lite@0.4.13",
        "resolved": "https://registry.npmjs.org/iconv-lite/-/iconv-lite-0.4.13.tgz",
        "version": "0.4.13"
      },
      "ip": {
        "from": "ip@>=1.1.2 <2.0.0",
        "resolved": "https://registry.npmjs.org/ip/-/ip-1.1.3.tgz",
        "version": "1.1.3"
      },
      "libbase64": {
        "from": "libbase64@0.1.0",
        "resolved": "https://registry.npmjs.org/libbase64/-/libbase64-0.1.0.tgz",
        "version": "0.1.0"
      },
      "libmime": {
        "from": "libmime@2.0.3",
        "resolved": "https://registry.npmjs.org/libmime/-/libmime-2.0.3.tgz",
        "version": "2.0.3"
      },
      "libqp": {
        "from": "libqp@1.1.0",
        "resolved": "https://registry.npmjs.org/libqp/-/libqp-1.1.0.tgz",
        "version": "1.1.0"
      },
      "mailcomposer": {
        "from": "mailcomposer@3.9.0",
        "resolved": "https://registry.npmjs.org/mailcomposer/-/mailcomposer-3.9.0.tgz",
        "version": "3.9.0"
      },
      "nodemailer-direct-transport": {
        "from": "nodemailer-direct-transport@3.1.0",
        "resolved": "https://registry.npmjs.org/nodemailer-direct-transport/-/nodemailer-direct-transport-3.1.0.tgz",
        "version": "3.1.0"
      },
      "nodemailer-fetch": {
        "from": "nodemailer-fetch@1.4.0",
        "version": "1.4.0"
      },
      "nodemailer-shared": {
        "from": "nodemailer-shared@1.0.5",
        "resolved": "https://registry.npmjs.org/nodemailer-shared/-/nodemailer-shared-1.0.5.tgz",
        "version": "1.0.5"
      },
      "nodemailer-smtp-pool": {
        "from": "nodemailer-smtp-pool@2.6.0",
        "resolved": "https://registry.npmjs.org/nodemailer-smtp-pool/-/nodemailer-smtp-pool-2.6.0.tgz",
        "version": "2.6.0"
      },
      "nodemailer-smtp-transport": {
        "from": "nodemailer-smtp-transport@2.5.0",
        "resolved": "https://registry.npmjs.org/nodemailer-smtp-transport/-/nodemailer-smtp-transport-2.5.0.tgz",
        "version": "2.5.0"
      },
      "nodemailer-wellknown": {
        "from": "nodemailer-wellknown@0.1.9",
        "resolved": "https://registry.npmjs.org/nodemailer-wellknown/-/nodemailer-wellknown-0.1.9.tgz",
        "version": "0.1.9"
      },
      "smart-buffer": {
        "from": "smart-buffer@>=1.0.4 <2.0.0",
        "resolved": "https://registry.npmjs.org/smart-buffer/-/smart-buffer-1.0.9.tgz",
        "version": "1.0.9"
      },
      "smtp-connection": {
        "from": "smtp-connection@2.5.0",
        "resolved": "https://registry.npmjs.org/smtp-connection/-/smtp-connection-2.5.0.tgz",
        "version": "2.5.0"
      },
      "socks": {
        "from": "socks@1.1.9",
        "resolved": "https://registry.npmjs.org/socks/-/socks-1.1.9.tgz",
        "version": "1.1.9"
      },
      "underscore": {
        "from": "underscore@>=1.7.0 <1.8.0",
        "resolved": "https://registry.npmjs.org/underscore/-/underscore-1.7.0.tgz",
        "version": "1.7.0"
      }
    },
    "name": "nodemailer",
    "version": "2.4.0"
  },
  "_spec": "nodemailer",
  "_where": "/Users/nhong/nickhong.io",
  "author": {
    "name": "Andris Reinman"
  },
  "bugs": {
    "url": "https://github.com/nodemailer/nodemailer/issues"
  },
  "dependencies": {
    "libmime": "2.0.3",
    "mailcomposer": "3.9.0",
    "nodemailer-direct-transport": "3.1.0",
    "nodemailer-shared": "1.0.5",
    "nodemailer-smtp-pool": "2.6.0",
    "nodemailer-smtp-transport": "2.5.0",
    "socks": "1.1.9"
  },
  "description": "Easy as cake e-mail sending from your Node.js applications",
  "devDependencies": {
    "amqp": "^0.2.4",
    "chai": "^3.5.0",
    "email-templates": "^2.3.0",
    "grunt": "^1.0.1",
    "grunt-cli": "^1.2.0",
    "grunt-eslint": "^18.1.0",
    "grunt-mocha-test": "^0.12.7",
    "handlebars": "^4.0.5",
    "mocha": "^2.4.5",
    "nodemailer-dkim": "^1.0.4",
    "nodemailer-markdown": "^1.0.0",
    "nodemailer-stub-transport": "^1.0.0",
    "proxy-test-server": "^1.0.0",
    "sinon": "^1.17.4",
    "smtp-server": "^1.9.1",
    "swig-email-templates": "^2.1.0"
  },
  "directories": {},
  "dist": {
    "shasum": "d5e375976f8772dcaa5c43f0669011d62aeab9e0",
    "tarball": "https://registry.npmjs.org/nodemailer/-/nodemailer-2.4.1.tgz"
  },
  "engines": {
    "node": ">=0.10.0"
  },
  "gitHead": "f49c5c7f2dcc775a072d1e4bafe597ad3bd73f8a",
  "homepage": "http://nodemailer.com/",
  "keywords": [
    "e-mail",
    "mime",
    "email",
    "mail",
    "sendmail",
    "ses",
    "smtp"
  ],
  "license": "MIT",
  "main": "lib/nodemailer.js",
  "maintainers": [
    {
      "email": "andris@node.ee",
      "name": "andris"
    }
  ],
  "name": "nodemailer",
  "optionalDependencies": {},
  "readme": "ERROR: No README data found!",
  "repository": {
    "type": "git",
    "url": "git://github.com/nodemailer/nodemailer.git"
  },
  "scripts": {
    "test": "grunt"
  },
  "version": "2.4.1"
}

},{}],91:[function(require,module,exports){
exports.endianness = function () { return 'LE' };

exports.hostname = function () {
    if (typeof location !== 'undefined') {
        return location.hostname
    }
    else return '';
};

exports.loadavg = function () { return [] };

exports.uptime = function () { return 0 };

exports.freemem = function () {
    return Number.MAX_VALUE;
};

exports.totalmem = function () {
    return Number.MAX_VALUE;
};

exports.cpus = function () { return [] };

exports.type = function () { return 'Browser' };

exports.release = function () {
    if (typeof navigator !== 'undefined') {
        return navigator.appVersion;
    }
    return '';
};

exports.networkInterfaces
= exports.getNetworkInterfaces
= function () { return {} };

exports.arch = function () { return 'javascript' };

exports.platform = function () { return 'browser' };

exports.tmpdir = exports.tmpDir = function () {
    return '/tmp';
};

exports.EOL = '\n';

},{}],92:[function(require,module,exports){
'use strict';


var TYPED_OK =  (typeof Uint8Array !== 'undefined') &&
                (typeof Uint16Array !== 'undefined') &&
                (typeof Int32Array !== 'undefined');


exports.assign = function (obj /*from1, from2, from3, ...*/) {
  var sources = Array.prototype.slice.call(arguments, 1);
  while (sources.length) {
    var source = sources.shift();
    if (!source) { continue; }

    if (typeof source !== 'object') {
      throw new TypeError(source + 'must be non-object');
    }

    for (var p in source) {
      if (source.hasOwnProperty(p)) {
        obj[p] = source[p];
      }
    }
  }

  return obj;
};


// reduce buffer size, avoiding mem copy
exports.shrinkBuf = function (buf, size) {
  if (buf.length === size) { return buf; }
  if (buf.subarray) { return buf.subarray(0, size); }
  buf.length = size;
  return buf;
};


var fnTyped = {
  arraySet: function (dest, src, src_offs, len, dest_offs) {
    if (src.subarray && dest.subarray) {
      dest.set(src.subarray(src_offs, src_offs+len), dest_offs);
      return;
    }
    // Fallback to ordinary array
    for (var i=0; i<len; i++) {
      dest[dest_offs + i] = src[src_offs + i];
    }
  },
  // Join array of chunks to single array.
  flattenChunks: function(chunks) {
    var i, l, len, pos, chunk, result;

    // calculate data length
    len = 0;
    for (i=0, l=chunks.length; i<l; i++) {
      len += chunks[i].length;
    }

    // join chunks
    result = new Uint8Array(len);
    pos = 0;
    for (i=0, l=chunks.length; i<l; i++) {
      chunk = chunks[i];
      result.set(chunk, pos);
      pos += chunk.length;
    }

    return result;
  }
};

var fnUntyped = {
  arraySet: function (dest, src, src_offs, len, dest_offs) {
    for (var i=0; i<len; i++) {
      dest[dest_offs + i] = src[src_offs + i];
    }
  },
  // Join array of chunks to single array.
  flattenChunks: function(chunks) {
    return [].concat.apply([], chunks);
  }
};


// Enable/Disable typed arrays use, for testing
//
exports.setTyped = function (on) {
  if (on) {
    exports.Buf8  = Uint8Array;
    exports.Buf16 = Uint16Array;
    exports.Buf32 = Int32Array;
    exports.assign(exports, fnTyped);
  } else {
    exports.Buf8  = Array;
    exports.Buf16 = Array;
    exports.Buf32 = Array;
    exports.assign(exports, fnUntyped);
  }
};

exports.setTyped(TYPED_OK);

},{}],93:[function(require,module,exports){
'use strict';

// Note: adler32 takes 12% for level 0 and 2% for level 6.
// It doesn't worth to make additional optimizationa as in original.
// Small size is preferable.

function adler32(adler, buf, len, pos) {
  var s1 = (adler & 0xffff) |0,
      s2 = ((adler >>> 16) & 0xffff) |0,
      n = 0;

  while (len !== 0) {
    // Set limit ~ twice less than 5552, to keep
    // s2 in 31-bits, because we force signed ints.
    // in other case %= will fail.
    n = len > 2000 ? 2000 : len;
    len -= n;

    do {
      s1 = (s1 + buf[pos++]) |0;
      s2 = (s2 + s1) |0;
    } while (--n);

    s1 %= 65521;
    s2 %= 65521;
  }

  return (s1 | (s2 << 16)) |0;
}


module.exports = adler32;

},{}],94:[function(require,module,exports){
module.exports = {

  /* Allowed flush values; see deflate() and inflate() below for details */
  Z_NO_FLUSH:         0,
  Z_PARTIAL_FLUSH:    1,
  Z_SYNC_FLUSH:       2,
  Z_FULL_FLUSH:       3,
  Z_FINISH:           4,
  Z_BLOCK:            5,
  Z_TREES:            6,

  /* Return codes for the compression/decompression functions. Negative values
  * are errors, positive values are used for special but normal events.
  */
  Z_OK:               0,
  Z_STREAM_END:       1,
  Z_NEED_DICT:        2,
  Z_ERRNO:           -1,
  Z_STREAM_ERROR:    -2,
  Z_DATA_ERROR:      -3,
  //Z_MEM_ERROR:     -4,
  Z_BUF_ERROR:       -5,
  //Z_VERSION_ERROR: -6,

  /* compression levels */
  Z_NO_COMPRESSION:         0,
  Z_BEST_SPEED:             1,
  Z_BEST_COMPRESSION:       9,
  Z_DEFAULT_COMPRESSION:   -1,


  Z_FILTERED:               1,
  Z_HUFFMAN_ONLY:           2,
  Z_RLE:                    3,
  Z_FIXED:                  4,
  Z_DEFAULT_STRATEGY:       0,

  /* Possible values of the data_type field (though see inflate()) */
  Z_BINARY:                 0,
  Z_TEXT:                   1,
  //Z_ASCII:                1, // = Z_TEXT (deprecated)
  Z_UNKNOWN:                2,

  /* The deflate compression method */
  Z_DEFLATED:               8
  //Z_NULL:                 null // Use -1 or null inline, depending on var type
};

},{}],95:[function(require,module,exports){
'use strict';

// Note: we can't get significant speed boost here.
// So write code to minimize size - no pregenerated tables
// and array tools dependencies.


// Use ordinary array, since untyped makes no boost here
function makeTable() {
  var c, table = [];

  for (var n =0; n < 256; n++) {
    c = n;
    for (var k =0; k < 8; k++) {
      c = ((c&1) ? (0xEDB88320 ^ (c >>> 1)) : (c >>> 1));
    }
    table[n] = c;
  }

  return table;
}

// Create table on load. Just 255 signed longs. Not a problem.
var crcTable = makeTable();


function crc32(crc, buf, len, pos) {
  var t = crcTable,
      end = pos + len;

  crc = crc ^ (-1);

  for (var i = pos; i < end; i++) {
    crc = (crc >>> 8) ^ t[(crc ^ buf[i]) & 0xFF];
  }

  return (crc ^ (-1)); // >>> 0;
}


module.exports = crc32;

},{}],96:[function(require,module,exports){
'use strict';

var utils   = require('../utils/common');
var trees   = require('./trees');
var adler32 = require('./adler32');
var crc32   = require('./crc32');
var msg   = require('./messages');

/* Public constants ==========================================================*/
/* ===========================================================================*/


/* Allowed flush values; see deflate() and inflate() below for details */
var Z_NO_FLUSH      = 0;
var Z_PARTIAL_FLUSH = 1;
//var Z_SYNC_FLUSH    = 2;
var Z_FULL_FLUSH    = 3;
var Z_FINISH        = 4;
var Z_BLOCK         = 5;
//var Z_TREES         = 6;


/* Return codes for the compression/decompression functions. Negative values
 * are errors, positive values are used for special but normal events.
 */
var Z_OK            = 0;
var Z_STREAM_END    = 1;
//var Z_NEED_DICT     = 2;
//var Z_ERRNO         = -1;
var Z_STREAM_ERROR  = -2;
var Z_DATA_ERROR    = -3;
//var Z_MEM_ERROR     = -4;
var Z_BUF_ERROR     = -5;
//var Z_VERSION_ERROR = -6;


/* compression levels */
//var Z_NO_COMPRESSION      = 0;
//var Z_BEST_SPEED          = 1;
//var Z_BEST_COMPRESSION    = 9;
var Z_DEFAULT_COMPRESSION = -1;


var Z_FILTERED            = 1;
var Z_HUFFMAN_ONLY        = 2;
var Z_RLE                 = 3;
var Z_FIXED               = 4;
var Z_DEFAULT_STRATEGY    = 0;

/* Possible values of the data_type field (though see inflate()) */
//var Z_BINARY              = 0;
//var Z_TEXT                = 1;
//var Z_ASCII               = 1; // = Z_TEXT
var Z_UNKNOWN             = 2;


/* The deflate compression method */
var Z_DEFLATED  = 8;

/*============================================================================*/


var MAX_MEM_LEVEL = 9;
/* Maximum value for memLevel in deflateInit2 */
var MAX_WBITS = 15;
/* 32K LZ77 window */
var DEF_MEM_LEVEL = 8;


var LENGTH_CODES  = 29;
/* number of length codes, not counting the special END_BLOCK code */
var LITERALS      = 256;
/* number of literal bytes 0..255 */
var L_CODES       = LITERALS + 1 + LENGTH_CODES;
/* number of Literal or Length codes, including the END_BLOCK code */
var D_CODES       = 30;
/* number of distance codes */
var BL_CODES      = 19;
/* number of codes used to transfer the bit lengths */
var HEAP_SIZE     = 2*L_CODES + 1;
/* maximum heap size */
var MAX_BITS  = 15;
/* All codes must not exceed MAX_BITS bits */

var MIN_MATCH = 3;
var MAX_MATCH = 258;
var MIN_LOOKAHEAD = (MAX_MATCH + MIN_MATCH + 1);

var PRESET_DICT = 0x20;

var INIT_STATE = 42;
var EXTRA_STATE = 69;
var NAME_STATE = 73;
var COMMENT_STATE = 91;
var HCRC_STATE = 103;
var BUSY_STATE = 113;
var FINISH_STATE = 666;

var BS_NEED_MORE      = 1; /* block not completed, need more input or more output */
var BS_BLOCK_DONE     = 2; /* block flush performed */
var BS_FINISH_STARTED = 3; /* finish started, need only more output at next deflate */
var BS_FINISH_DONE    = 4; /* finish done, accept no more input or output */

var OS_CODE = 0x03; // Unix :) . Don't detect, use this default.

function err(strm, errorCode) {
  strm.msg = msg[errorCode];
  return errorCode;
}

function rank(f) {
  return ((f) << 1) - ((f) > 4 ? 9 : 0);
}

function zero(buf) { var len = buf.length; while (--len >= 0) { buf[len] = 0; } }


/* =========================================================================
 * Flush as much pending output as possible. All deflate() output goes
 * through this function so some applications may wish to modify it
 * to avoid allocating a large strm->output buffer and copying into it.
 * (See also read_buf()).
 */
function flush_pending(strm) {
  var s = strm.state;

  //_tr_flush_bits(s);
  var len = s.pending;
  if (len > strm.avail_out) {
    len = strm.avail_out;
  }
  if (len === 0) { return; }

  utils.arraySet(strm.output, s.pending_buf, s.pending_out, len, strm.next_out);
  strm.next_out += len;
  s.pending_out += len;
  strm.total_out += len;
  strm.avail_out -= len;
  s.pending -= len;
  if (s.pending === 0) {
    s.pending_out = 0;
  }
}


function flush_block_only (s, last) {
  trees._tr_flush_block(s, (s.block_start >= 0 ? s.block_start : -1), s.strstart - s.block_start, last);
  s.block_start = s.strstart;
  flush_pending(s.strm);
}


function put_byte(s, b) {
  s.pending_buf[s.pending++] = b;
}


/* =========================================================================
 * Put a short in the pending buffer. The 16-bit value is put in MSB order.
 * IN assertion: the stream state is correct and there is enough room in
 * pending_buf.
 */
function putShortMSB(s, b) {
//  put_byte(s, (Byte)(b >> 8));
//  put_byte(s, (Byte)(b & 0xff));
  s.pending_buf[s.pending++] = (b >>> 8) & 0xff;
  s.pending_buf[s.pending++] = b & 0xff;
}


/* ===========================================================================
 * Read a new buffer from the current input stream, update the adler32
 * and total number of bytes read.  All deflate() input goes through
 * this function so some applications may wish to modify it to avoid
 * allocating a large strm->input buffer and copying from it.
 * (See also flush_pending()).
 */
function read_buf(strm, buf, start, size) {
  var len = strm.avail_in;

  if (len > size) { len = size; }
  if (len === 0) { return 0; }

  strm.avail_in -= len;

  utils.arraySet(buf, strm.input, strm.next_in, len, start);
  if (strm.state.wrap === 1) {
    strm.adler = adler32(strm.adler, buf, len, start);
  }

  else if (strm.state.wrap === 2) {
    strm.adler = crc32(strm.adler, buf, len, start);
  }

  strm.next_in += len;
  strm.total_in += len;

  return len;
}


/* ===========================================================================
 * Set match_start to the longest match starting at the given string and
 * return its length. Matches shorter or equal to prev_length are discarded,
 * in which case the result is equal to prev_length and match_start is
 * garbage.
 * IN assertions: cur_match is the head of the hash chain for the current
 *   string (strstart) and its distance is <= MAX_DIST, and prev_length >= 1
 * OUT assertion: the match length is not greater than s->lookahead.
 */
function longest_match(s, cur_match) {
  var chain_length = s.max_chain_length;      /* max hash chain length */
  var scan = s.strstart; /* current string */
  var match;                       /* matched string */
  var len;                           /* length of current match */
  var best_len = s.prev_length;              /* best match length so far */
  var nice_match = s.nice_match;             /* stop if match long enough */
  var limit = (s.strstart > (s.w_size - MIN_LOOKAHEAD)) ?
      s.strstart - (s.w_size - MIN_LOOKAHEAD) : 0/*NIL*/;

  var _win = s.window; // shortcut

  var wmask = s.w_mask;
  var prev  = s.prev;

  /* Stop when cur_match becomes <= limit. To simplify the code,
   * we prevent matches with the string of window index 0.
   */

  var strend = s.strstart + MAX_MATCH;
  var scan_end1  = _win[scan + best_len - 1];
  var scan_end   = _win[scan + best_len];

  /* The code is optimized for HASH_BITS >= 8 and MAX_MATCH-2 multiple of 16.
   * It is easy to get rid of this optimization if necessary.
   */
  // Assert(s->hash_bits >= 8 && MAX_MATCH == 258, "Code too clever");

  /* Do not waste too much time if we already have a good match: */
  if (s.prev_length >= s.good_match) {
    chain_length >>= 2;
  }
  /* Do not look for matches beyond the end of the input. This is necessary
   * to make deflate deterministic.
   */
  if (nice_match > s.lookahead) { nice_match = s.lookahead; }

  // Assert((ulg)s->strstart <= s->window_size-MIN_LOOKAHEAD, "need lookahead");

  do {
    // Assert(cur_match < s->strstart, "no future");
    match = cur_match;

    /* Skip to next match if the match length cannot increase
     * or if the match length is less than 2.  Note that the checks below
     * for insufficient lookahead only occur occasionally for performance
     * reasons.  Therefore uninitialized memory will be accessed, and
     * conditional jumps will be made that depend on those values.
     * However the length of the match is limited to the lookahead, so
     * the output of deflate is not affected by the uninitialized values.
     */

    if (_win[match + best_len]     !== scan_end  ||
        _win[match + best_len - 1] !== scan_end1 ||
        _win[match]                !== _win[scan] ||
        _win[++match]              !== _win[scan + 1]) {
      continue;
    }

    /* The check at best_len-1 can be removed because it will be made
     * again later. (This heuristic is not always a win.)
     * It is not necessary to compare scan[2] and match[2] since they
     * are always equal when the other bytes match, given that
     * the hash keys are equal and that HASH_BITS >= 8.
     */
    scan += 2;
    match++;
    // Assert(*scan == *match, "match[2]?");

    /* We check for insufficient lookahead only every 8th comparison;
     * the 256th check will be made at strstart+258.
     */
    do {
      /*jshint noempty:false*/
    } while (_win[++scan] === _win[++match] && _win[++scan] === _win[++match] &&
             _win[++scan] === _win[++match] && _win[++scan] === _win[++match] &&
             _win[++scan] === _win[++match] && _win[++scan] === _win[++match] &&
             _win[++scan] === _win[++match] && _win[++scan] === _win[++match] &&
             scan < strend);

    // Assert(scan <= s->window+(unsigned)(s->window_size-1), "wild scan");

    len = MAX_MATCH - (strend - scan);
    scan = strend - MAX_MATCH;

    if (len > best_len) {
      s.match_start = cur_match;
      best_len = len;
      if (len >= nice_match) {
        break;
      }
      scan_end1  = _win[scan + best_len - 1];
      scan_end   = _win[scan + best_len];
    }
  } while ((cur_match = prev[cur_match & wmask]) > limit && --chain_length !== 0);

  if (best_len <= s.lookahead) {
    return best_len;
  }
  return s.lookahead;
}


/* ===========================================================================
 * Fill the window when the lookahead becomes insufficient.
 * Updates strstart and lookahead.
 *
 * IN assertion: lookahead < MIN_LOOKAHEAD
 * OUT assertions: strstart <= window_size-MIN_LOOKAHEAD
 *    At least one byte has been read, or avail_in == 0; reads are
 *    performed for at least two bytes (required for the zip translate_eol
 *    option -- not supported here).
 */
function fill_window(s) {
  var _w_size = s.w_size;
  var p, n, m, more, str;

  //Assert(s->lookahead < MIN_LOOKAHEAD, "already enough lookahead");

  do {
    more = s.window_size - s.lookahead - s.strstart;

    // JS ints have 32 bit, block below not needed
    /* Deal with !@#$% 64K limit: */
    //if (sizeof(int) <= 2) {
    //    if (more == 0 && s->strstart == 0 && s->lookahead == 0) {
    //        more = wsize;
    //
    //  } else if (more == (unsigned)(-1)) {
    //        /* Very unlikely, but possible on 16 bit machine if
    //         * strstart == 0 && lookahead == 1 (input done a byte at time)
    //         */
    //        more--;
    //    }
    //}


    /* If the window is almost full and there is insufficient lookahead,
     * move the upper half to the lower one to make room in the upper half.
     */
    if (s.strstart >= _w_size + (_w_size - MIN_LOOKAHEAD)) {

      utils.arraySet(s.window, s.window, _w_size, _w_size, 0);
      s.match_start -= _w_size;
      s.strstart -= _w_size;
      /* we now have strstart >= MAX_DIST */
      s.block_start -= _w_size;

      /* Slide the hash table (could be avoided with 32 bit values
       at the expense of memory usage). We slide even when level == 0
       to keep the hash table consistent if we switch back to level > 0
       later. (Using level 0 permanently is not an optimal usage of
       zlib, so we don't care about this pathological case.)
       */

      n = s.hash_size;
      p = n;
      do {
        m = s.head[--p];
        s.head[p] = (m >= _w_size ? m - _w_size : 0);
      } while (--n);

      n = _w_size;
      p = n;
      do {
        m = s.prev[--p];
        s.prev[p] = (m >= _w_size ? m - _w_size : 0);
        /* If n is not on any hash chain, prev[n] is garbage but
         * its value will never be used.
         */
      } while (--n);

      more += _w_size;
    }
    if (s.strm.avail_in === 0) {
      break;
    }

    /* If there was no sliding:
     *    strstart <= WSIZE+MAX_DIST-1 && lookahead <= MIN_LOOKAHEAD - 1 &&
     *    more == window_size - lookahead - strstart
     * => more >= window_size - (MIN_LOOKAHEAD-1 + WSIZE + MAX_DIST-1)
     * => more >= window_size - 2*WSIZE + 2
     * In the BIG_MEM or MMAP case (not yet supported),
     *   window_size == input_size + MIN_LOOKAHEAD  &&
     *   strstart + s->lookahead <= input_size => more >= MIN_LOOKAHEAD.
     * Otherwise, window_size == 2*WSIZE so more >= 2.
     * If there was sliding, more >= WSIZE. So in all cases, more >= 2.
     */
    //Assert(more >= 2, "more < 2");
    n = read_buf(s.strm, s.window, s.strstart + s.lookahead, more);
    s.lookahead += n;

    /* Initialize the hash value now that we have some input: */
    if (s.lookahead + s.insert >= MIN_MATCH) {
      str = s.strstart - s.insert;
      s.ins_h = s.window[str];

      /* UPDATE_HASH(s, s->ins_h, s->window[str + 1]); */
      s.ins_h = ((s.ins_h << s.hash_shift) ^ s.window[str + 1]) & s.hash_mask;
//#if MIN_MATCH != 3
//        Call update_hash() MIN_MATCH-3 more times
//#endif
      while (s.insert) {
        /* UPDATE_HASH(s, s->ins_h, s->window[str + MIN_MATCH-1]); */
        s.ins_h = ((s.ins_h << s.hash_shift) ^ s.window[str + MIN_MATCH-1]) & s.hash_mask;

        s.prev[str & s.w_mask] = s.head[s.ins_h];
        s.head[s.ins_h] = str;
        str++;
        s.insert--;
        if (s.lookahead + s.insert < MIN_MATCH) {
          break;
        }
      }
    }
    /* If the whole input has less than MIN_MATCH bytes, ins_h is garbage,
     * but this is not important since only literal bytes will be emitted.
     */

  } while (s.lookahead < MIN_LOOKAHEAD && s.strm.avail_in !== 0);

  /* If the WIN_INIT bytes after the end of the current data have never been
   * written, then zero those bytes in order to avoid memory check reports of
   * the use of uninitialized (or uninitialised as Julian writes) bytes by
   * the longest match routines.  Update the high water mark for the next
   * time through here.  WIN_INIT is set to MAX_MATCH since the longest match
   * routines allow scanning to strstart + MAX_MATCH, ignoring lookahead.
   */
//  if (s.high_water < s.window_size) {
//    var curr = s.strstart + s.lookahead;
//    var init = 0;
//
//    if (s.high_water < curr) {
//      /* Previous high water mark below current data -- zero WIN_INIT
//       * bytes or up to end of window, whichever is less.
//       */
//      init = s.window_size - curr;
//      if (init > WIN_INIT)
//        init = WIN_INIT;
//      zmemzero(s->window + curr, (unsigned)init);
//      s->high_water = curr + init;
//    }
//    else if (s->high_water < (ulg)curr + WIN_INIT) {
//      /* High water mark at or above current data, but below current data
//       * plus WIN_INIT -- zero out to current data plus WIN_INIT, or up
//       * to end of window, whichever is less.
//       */
//      init = (ulg)curr + WIN_INIT - s->high_water;
//      if (init > s->window_size - s->high_water)
//        init = s->window_size - s->high_water;
//      zmemzero(s->window + s->high_water, (unsigned)init);
//      s->high_water += init;
//    }
//  }
//
//  Assert((ulg)s->strstart <= s->window_size - MIN_LOOKAHEAD,
//    "not enough room for search");
}

/* ===========================================================================
 * Copy without compression as much as possible from the input stream, return
 * the current block state.
 * This function does not insert new strings in the dictionary since
 * uncompressible data is probably not useful. This function is used
 * only for the level=0 compression option.
 * NOTE: this function should be optimized to avoid extra copying from
 * window to pending_buf.
 */
function deflate_stored(s, flush) {
  /* Stored blocks are limited to 0xffff bytes, pending_buf is limited
   * to pending_buf_size, and each stored block has a 5 byte header:
   */
  var max_block_size = 0xffff;

  if (max_block_size > s.pending_buf_size - 5) {
    max_block_size = s.pending_buf_size - 5;
  }

  /* Copy as much as possible from input to output: */
  for (;;) {
    /* Fill the window as much as possible: */
    if (s.lookahead <= 1) {

      //Assert(s->strstart < s->w_size+MAX_DIST(s) ||
      //  s->block_start >= (long)s->w_size, "slide too late");
//      if (!(s.strstart < s.w_size + (s.w_size - MIN_LOOKAHEAD) ||
//        s.block_start >= s.w_size)) {
//        throw  new Error("slide too late");
//      }

      fill_window(s);
      if (s.lookahead === 0 && flush === Z_NO_FLUSH) {
        return BS_NEED_MORE;
      }

      if (s.lookahead === 0) {
        break;
      }
      /* flush the current block */
    }
    //Assert(s->block_start >= 0L, "block gone");
//    if (s.block_start < 0) throw new Error("block gone");

    s.strstart += s.lookahead;
    s.lookahead = 0;

    /* Emit a stored block if pending_buf will be full: */
    var max_start = s.block_start + max_block_size;

    if (s.strstart === 0 || s.strstart >= max_start) {
      /* strstart == 0 is possible when wraparound on 16-bit machine */
      s.lookahead = s.strstart - max_start;
      s.strstart = max_start;
      /*** FLUSH_BLOCK(s, 0); ***/
      flush_block_only(s, false);
      if (s.strm.avail_out === 0) {
        return BS_NEED_MORE;
      }
      /***/


    }
    /* Flush if we may have to slide, otherwise block_start may become
     * negative and the data will be gone:
     */
    if (s.strstart - s.block_start >= (s.w_size - MIN_LOOKAHEAD)) {
      /*** FLUSH_BLOCK(s, 0); ***/
      flush_block_only(s, false);
      if (s.strm.avail_out === 0) {
        return BS_NEED_MORE;
      }
      /***/
    }
  }

  s.insert = 0;

  if (flush === Z_FINISH) {
    /*** FLUSH_BLOCK(s, 1); ***/
    flush_block_only(s, true);
    if (s.strm.avail_out === 0) {
      return BS_FINISH_STARTED;
    }
    /***/
    return BS_FINISH_DONE;
  }

  if (s.strstart > s.block_start) {
    /*** FLUSH_BLOCK(s, 0); ***/
    flush_block_only(s, false);
    if (s.strm.avail_out === 0) {
      return BS_NEED_MORE;
    }
    /***/
  }

  return BS_NEED_MORE;
}

/* ===========================================================================
 * Compress as much as possible from the input stream, return the current
 * block state.
 * This function does not perform lazy evaluation of matches and inserts
 * new strings in the dictionary only for unmatched strings or for short
 * matches. It is used only for the fast compression options.
 */
function deflate_fast(s, flush) {
  var hash_head;        /* head of the hash chain */
  var bflush;           /* set if current block must be flushed */

  for (;;) {
    /* Make sure that we always have enough lookahead, except
     * at the end of the input file. We need MAX_MATCH bytes
     * for the next match, plus MIN_MATCH bytes to insert the
     * string following the next match.
     */
    if (s.lookahead < MIN_LOOKAHEAD) {
      fill_window(s);
      if (s.lookahead < MIN_LOOKAHEAD && flush === Z_NO_FLUSH) {
        return BS_NEED_MORE;
      }
      if (s.lookahead === 0) {
        break; /* flush the current block */
      }
    }

    /* Insert the string window[strstart .. strstart+2] in the
     * dictionary, and set hash_head to the head of the hash chain:
     */
    hash_head = 0/*NIL*/;
    if (s.lookahead >= MIN_MATCH) {
      /*** INSERT_STRING(s, s.strstart, hash_head); ***/
      s.ins_h = ((s.ins_h << s.hash_shift) ^ s.window[s.strstart + MIN_MATCH - 1]) & s.hash_mask;
      hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
      s.head[s.ins_h] = s.strstart;
      /***/
    }

    /* Find the longest match, discarding those <= prev_length.
     * At this point we have always match_length < MIN_MATCH
     */
    if (hash_head !== 0/*NIL*/ && ((s.strstart - hash_head) <= (s.w_size - MIN_LOOKAHEAD))) {
      /* To simplify the code, we prevent matches with the string
       * of window index 0 (in particular we have to avoid a match
       * of the string with itself at the start of the input file).
       */
      s.match_length = longest_match(s, hash_head);
      /* longest_match() sets match_start */
    }
    if (s.match_length >= MIN_MATCH) {
      // check_match(s, s.strstart, s.match_start, s.match_length); // for debug only

      /*** _tr_tally_dist(s, s.strstart - s.match_start,
                     s.match_length - MIN_MATCH, bflush); ***/
      bflush = trees._tr_tally(s, s.strstart - s.match_start, s.match_length - MIN_MATCH);

      s.lookahead -= s.match_length;

      /* Insert new strings in the hash table only if the match length
       * is not too large. This saves time but degrades compression.
       */
      if (s.match_length <= s.max_lazy_match/*max_insert_length*/ && s.lookahead >= MIN_MATCH) {
        s.match_length--; /* string at strstart already in table */
        do {
          s.strstart++;
          /*** INSERT_STRING(s, s.strstart, hash_head); ***/
          s.ins_h = ((s.ins_h << s.hash_shift) ^ s.window[s.strstart + MIN_MATCH - 1]) & s.hash_mask;
          hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
          s.head[s.ins_h] = s.strstart;
          /***/
          /* strstart never exceeds WSIZE-MAX_MATCH, so there are
           * always MIN_MATCH bytes ahead.
           */
        } while (--s.match_length !== 0);
        s.strstart++;
      } else
      {
        s.strstart += s.match_length;
        s.match_length = 0;
        s.ins_h = s.window[s.strstart];
        /* UPDATE_HASH(s, s.ins_h, s.window[s.strstart+1]); */
        s.ins_h = ((s.ins_h << s.hash_shift) ^ s.window[s.strstart + 1]) & s.hash_mask;

//#if MIN_MATCH != 3
//                Call UPDATE_HASH() MIN_MATCH-3 more times
//#endif
        /* If lookahead < MIN_MATCH, ins_h is garbage, but it does not
         * matter since it will be recomputed at next deflate call.
         */
      }
    } else {
      /* No match, output a literal byte */
      //Tracevv((stderr,"%c", s.window[s.strstart]));
      /*** _tr_tally_lit(s, s.window[s.strstart], bflush); ***/
      bflush = trees._tr_tally(s, 0, s.window[s.strstart]);

      s.lookahead--;
      s.strstart++;
    }
    if (bflush) {
      /*** FLUSH_BLOCK(s, 0); ***/
      flush_block_only(s, false);
      if (s.strm.avail_out === 0) {
        return BS_NEED_MORE;
      }
      /***/
    }
  }
  s.insert = ((s.strstart < (MIN_MATCH-1)) ? s.strstart : MIN_MATCH-1);
  if (flush === Z_FINISH) {
    /*** FLUSH_BLOCK(s, 1); ***/
    flush_block_only(s, true);
    if (s.strm.avail_out === 0) {
      return BS_FINISH_STARTED;
    }
    /***/
    return BS_FINISH_DONE;
  }
  if (s.last_lit) {
    /*** FLUSH_BLOCK(s, 0); ***/
    flush_block_only(s, false);
    if (s.strm.avail_out === 0) {
      return BS_NEED_MORE;
    }
    /***/
  }
  return BS_BLOCK_DONE;
}

/* ===========================================================================
 * Same as above, but achieves better compression. We use a lazy
 * evaluation for matches: a match is finally adopted only if there is
 * no better match at the next window position.
 */
function deflate_slow(s, flush) {
  var hash_head;          /* head of hash chain */
  var bflush;              /* set if current block must be flushed */

  var max_insert;

  /* Process the input block. */
  for (;;) {
    /* Make sure that we always have enough lookahead, except
     * at the end of the input file. We need MAX_MATCH bytes
     * for the next match, plus MIN_MATCH bytes to insert the
     * string following the next match.
     */
    if (s.lookahead < MIN_LOOKAHEAD) {
      fill_window(s);
      if (s.lookahead < MIN_LOOKAHEAD && flush === Z_NO_FLUSH) {
        return BS_NEED_MORE;
      }
      if (s.lookahead === 0) { break; } /* flush the current block */
    }

    /* Insert the string window[strstart .. strstart+2] in the
     * dictionary, and set hash_head to the head of the hash chain:
     */
    hash_head = 0/*NIL*/;
    if (s.lookahead >= MIN_MATCH) {
      /*** INSERT_STRING(s, s.strstart, hash_head); ***/
      s.ins_h = ((s.ins_h << s.hash_shift) ^ s.window[s.strstart + MIN_MATCH - 1]) & s.hash_mask;
      hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
      s.head[s.ins_h] = s.strstart;
      /***/
    }

    /* Find the longest match, discarding those <= prev_length.
     */
    s.prev_length = s.match_length;
    s.prev_match = s.match_start;
    s.match_length = MIN_MATCH-1;

    if (hash_head !== 0/*NIL*/ && s.prev_length < s.max_lazy_match &&
        s.strstart - hash_head <= (s.w_size-MIN_LOOKAHEAD)/*MAX_DIST(s)*/) {
      /* To simplify the code, we prevent matches with the string
       * of window index 0 (in particular we have to avoid a match
       * of the string with itself at the start of the input file).
       */
      s.match_length = longest_match(s, hash_head);
      /* longest_match() sets match_start */

      if (s.match_length <= 5 &&
         (s.strategy === Z_FILTERED || (s.match_length === MIN_MATCH && s.strstart - s.match_start > 4096/*TOO_FAR*/))) {

        /* If prev_match is also MIN_MATCH, match_start is garbage
         * but we will ignore the current match anyway.
         */
        s.match_length = MIN_MATCH-1;
      }
    }
    /* If there was a match at the previous step and the current
     * match is not better, output the previous match:
     */
    if (s.prev_length >= MIN_MATCH && s.match_length <= s.prev_length) {
      max_insert = s.strstart + s.lookahead - MIN_MATCH;
      /* Do not insert strings in hash table beyond this. */

      //check_match(s, s.strstart-1, s.prev_match, s.prev_length);

      /***_tr_tally_dist(s, s.strstart - 1 - s.prev_match,
                     s.prev_length - MIN_MATCH, bflush);***/
      bflush = trees._tr_tally(s, s.strstart - 1- s.prev_match, s.prev_length - MIN_MATCH);
      /* Insert in hash table all strings up to the end of the match.
       * strstart-1 and strstart are already inserted. If there is not
       * enough lookahead, the last two strings are not inserted in
       * the hash table.
       */
      s.lookahead -= s.prev_length-1;
      s.prev_length -= 2;
      do {
        if (++s.strstart <= max_insert) {
          /*** INSERT_STRING(s, s.strstart, hash_head); ***/
          s.ins_h = ((s.ins_h << s.hash_shift) ^ s.window[s.strstart + MIN_MATCH - 1]) & s.hash_mask;
          hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
          s.head[s.ins_h] = s.strstart;
          /***/
        }
      } while (--s.prev_length !== 0);
      s.match_available = 0;
      s.match_length = MIN_MATCH-1;
      s.strstart++;

      if (bflush) {
        /*** FLUSH_BLOCK(s, 0); ***/
        flush_block_only(s, false);
        if (s.strm.avail_out === 0) {
          return BS_NEED_MORE;
        }
        /***/
      }

    } else if (s.match_available) {
      /* If there was no match at the previous position, output a
       * single literal. If there was a match but the current match
       * is longer, truncate the previous match to a single literal.
       */
      //Tracevv((stderr,"%c", s->window[s->strstart-1]));
      /*** _tr_tally_lit(s, s.window[s.strstart-1], bflush); ***/
      bflush = trees._tr_tally(s, 0, s.window[s.strstart-1]);

      if (bflush) {
        /*** FLUSH_BLOCK_ONLY(s, 0) ***/
        flush_block_only(s, false);
        /***/
      }
      s.strstart++;
      s.lookahead--;
      if (s.strm.avail_out === 0) {
        return BS_NEED_MORE;
      }
    } else {
      /* There is no previous match to compare with, wait for
       * the next step to decide.
       */
      s.match_available = 1;
      s.strstart++;
      s.lookahead--;
    }
  }
  //Assert (flush != Z_NO_FLUSH, "no flush?");
  if (s.match_available) {
    //Tracevv((stderr,"%c", s->window[s->strstart-1]));
    /*** _tr_tally_lit(s, s.window[s.strstart-1], bflush); ***/
    bflush = trees._tr_tally(s, 0, s.window[s.strstart-1]);

    s.match_available = 0;
  }
  s.insert = s.strstart < MIN_MATCH-1 ? s.strstart : MIN_MATCH-1;
  if (flush === Z_FINISH) {
    /*** FLUSH_BLOCK(s, 1); ***/
    flush_block_only(s, true);
    if (s.strm.avail_out === 0) {
      return BS_FINISH_STARTED;
    }
    /***/
    return BS_FINISH_DONE;
  }
  if (s.last_lit) {
    /*** FLUSH_BLOCK(s, 0); ***/
    flush_block_only(s, false);
    if (s.strm.avail_out === 0) {
      return BS_NEED_MORE;
    }
    /***/
  }

  return BS_BLOCK_DONE;
}


/* ===========================================================================
 * For Z_RLE, simply look for runs of bytes, generate matches only of distance
 * one.  Do not maintain a hash table.  (It will be regenerated if this run of
 * deflate switches away from Z_RLE.)
 */
function deflate_rle(s, flush) {
  var bflush;            /* set if current block must be flushed */
  var prev;              /* byte at distance one to match */
  var scan, strend;      /* scan goes up to strend for length of run */

  var _win = s.window;

  for (;;) {
    /* Make sure that we always have enough lookahead, except
     * at the end of the input file. We need MAX_MATCH bytes
     * for the longest run, plus one for the unrolled loop.
     */
    if (s.lookahead <= MAX_MATCH) {
      fill_window(s);
      if (s.lookahead <= MAX_MATCH && flush === Z_NO_FLUSH) {
        return BS_NEED_MORE;
      }
      if (s.lookahead === 0) { break; } /* flush the current block */
    }

    /* See how many times the previous byte repeats */
    s.match_length = 0;
    if (s.lookahead >= MIN_MATCH && s.strstart > 0) {
      scan = s.strstart - 1;
      prev = _win[scan];
      if (prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan]) {
        strend = s.strstart + MAX_MATCH;
        do {
          /*jshint noempty:false*/
        } while (prev === _win[++scan] && prev === _win[++scan] &&
                 prev === _win[++scan] && prev === _win[++scan] &&
                 prev === _win[++scan] && prev === _win[++scan] &&
                 prev === _win[++scan] && prev === _win[++scan] &&
                 scan < strend);
        s.match_length = MAX_MATCH - (strend - scan);
        if (s.match_length > s.lookahead) {
          s.match_length = s.lookahead;
        }
      }
      //Assert(scan <= s->window+(uInt)(s->window_size-1), "wild scan");
    }

    /* Emit match if have run of MIN_MATCH or longer, else emit literal */
    if (s.match_length >= MIN_MATCH) {
      //check_match(s, s.strstart, s.strstart - 1, s.match_length);

      /*** _tr_tally_dist(s, 1, s.match_length - MIN_MATCH, bflush); ***/
      bflush = trees._tr_tally(s, 1, s.match_length - MIN_MATCH);

      s.lookahead -= s.match_length;
      s.strstart += s.match_length;
      s.match_length = 0;
    } else {
      /* No match, output a literal byte */
      //Tracevv((stderr,"%c", s->window[s->strstart]));
      /*** _tr_tally_lit(s, s.window[s.strstart], bflush); ***/
      bflush = trees._tr_tally(s, 0, s.window[s.strstart]);

      s.lookahead--;
      s.strstart++;
    }
    if (bflush) {
      /*** FLUSH_BLOCK(s, 0); ***/
      flush_block_only(s, false);
      if (s.strm.avail_out === 0) {
        return BS_NEED_MORE;
      }
      /***/
    }
  }
  s.insert = 0;
  if (flush === Z_FINISH) {
    /*** FLUSH_BLOCK(s, 1); ***/
    flush_block_only(s, true);
    if (s.strm.avail_out === 0) {
      return BS_FINISH_STARTED;
    }
    /***/
    return BS_FINISH_DONE;
  }
  if (s.last_lit) {
    /*** FLUSH_BLOCK(s, 0); ***/
    flush_block_only(s, false);
    if (s.strm.avail_out === 0) {
      return BS_NEED_MORE;
    }
    /***/
  }
  return BS_BLOCK_DONE;
}

/* ===========================================================================
 * For Z_HUFFMAN_ONLY, do not look for matches.  Do not maintain a hash table.
 * (It will be regenerated if this run of deflate switches away from Huffman.)
 */
function deflate_huff(s, flush) {
  var bflush;             /* set if current block must be flushed */

  for (;;) {
    /* Make sure that we have a literal to write. */
    if (s.lookahead === 0) {
      fill_window(s);
      if (s.lookahead === 0) {
        if (flush === Z_NO_FLUSH) {
          return BS_NEED_MORE;
        }
        break;      /* flush the current block */
      }
    }

    /* Output a literal byte */
    s.match_length = 0;
    //Tracevv((stderr,"%c", s->window[s->strstart]));
    /*** _tr_tally_lit(s, s.window[s.strstart], bflush); ***/
    bflush = trees._tr_tally(s, 0, s.window[s.strstart]);
    s.lookahead--;
    s.strstart++;
    if (bflush) {
      /*** FLUSH_BLOCK(s, 0); ***/
      flush_block_only(s, false);
      if (s.strm.avail_out === 0) {
        return BS_NEED_MORE;
      }
      /***/
    }
  }
  s.insert = 0;
  if (flush === Z_FINISH) {
    /*** FLUSH_BLOCK(s, 1); ***/
    flush_block_only(s, true);
    if (s.strm.avail_out === 0) {
      return BS_FINISH_STARTED;
    }
    /***/
    return BS_FINISH_DONE;
  }
  if (s.last_lit) {
    /*** FLUSH_BLOCK(s, 0); ***/
    flush_block_only(s, false);
    if (s.strm.avail_out === 0) {
      return BS_NEED_MORE;
    }
    /***/
  }
  return BS_BLOCK_DONE;
}

/* Values for max_lazy_match, good_match and max_chain_length, depending on
 * the desired pack level (0..9). The values given below have been tuned to
 * exclude worst case performance for pathological files. Better values may be
 * found for specific files.
 */
var Config = function (good_length, max_lazy, nice_length, max_chain, func) {
  this.good_length = good_length;
  this.max_lazy = max_lazy;
  this.nice_length = nice_length;
  this.max_chain = max_chain;
  this.func = func;
};

var configuration_table;

configuration_table = [
  /*      good lazy nice chain */
  new Config(0, 0, 0, 0, deflate_stored),          /* 0 store only */
  new Config(4, 4, 8, 4, deflate_fast),            /* 1 max speed, no lazy matches */
  new Config(4, 5, 16, 8, deflate_fast),           /* 2 */
  new Config(4, 6, 32, 32, deflate_fast),          /* 3 */

  new Config(4, 4, 16, 16, deflate_slow),          /* 4 lazy matches */
  new Config(8, 16, 32, 32, deflate_slow),         /* 5 */
  new Config(8, 16, 128, 128, deflate_slow),       /* 6 */
  new Config(8, 32, 128, 256, deflate_slow),       /* 7 */
  new Config(32, 128, 258, 1024, deflate_slow),    /* 8 */
  new Config(32, 258, 258, 4096, deflate_slow)     /* 9 max compression */
];


/* ===========================================================================
 * Initialize the "longest match" routines for a new zlib stream
 */
function lm_init(s) {
  s.window_size = 2 * s.w_size;

  /*** CLEAR_HASH(s); ***/
  zero(s.head); // Fill with NIL (= 0);

  /* Set the default configuration parameters:
   */
  s.max_lazy_match = configuration_table[s.level].max_lazy;
  s.good_match = configuration_table[s.level].good_length;
  s.nice_match = configuration_table[s.level].nice_length;
  s.max_chain_length = configuration_table[s.level].max_chain;

  s.strstart = 0;
  s.block_start = 0;
  s.lookahead = 0;
  s.insert = 0;
  s.match_length = s.prev_length = MIN_MATCH - 1;
  s.match_available = 0;
  s.ins_h = 0;
}


function DeflateState() {
  this.strm = null;            /* pointer back to this zlib stream */
  this.status = 0;            /* as the name implies */
  this.pending_buf = null;      /* output still pending */
  this.pending_buf_size = 0;  /* size of pending_buf */
  this.pending_out = 0;       /* next pending byte to output to the stream */
  this.pending = 0;           /* nb of bytes in the pending buffer */
  this.wrap = 0;              /* bit 0 true for zlib, bit 1 true for gzip */
  this.gzhead = null;         /* gzip header information to write */
  this.gzindex = 0;           /* where in extra, name, or comment */
  this.method = Z_DEFLATED; /* can only be DEFLATED */
  this.last_flush = -1;   /* value of flush param for previous deflate call */

  this.w_size = 0;  /* LZ77 window size (32K by default) */
  this.w_bits = 0;  /* log2(w_size)  (8..16) */
  this.w_mask = 0;  /* w_size - 1 */

  this.window = null;
  /* Sliding window. Input bytes are read into the second half of the window,
   * and move to the first half later to keep a dictionary of at least wSize
   * bytes. With this organization, matches are limited to a distance of
   * wSize-MAX_MATCH bytes, but this ensures that IO is always
   * performed with a length multiple of the block size.
   */

  this.window_size = 0;
  /* Actual size of window: 2*wSize, except when the user input buffer
   * is directly used as sliding window.
   */

  this.prev = null;
  /* Link to older string with same hash index. To limit the size of this
   * array to 64K, this link is maintained only for the last 32K strings.
   * An index in this array is thus a window index modulo 32K.
   */

  this.head = null;   /* Heads of the hash chains or NIL. */

  this.ins_h = 0;       /* hash index of string to be inserted */
  this.hash_size = 0;   /* number of elements in hash table */
  this.hash_bits = 0;   /* log2(hash_size) */
  this.hash_mask = 0;   /* hash_size-1 */

  this.hash_shift = 0;
  /* Number of bits by which ins_h must be shifted at each input
   * step. It must be such that after MIN_MATCH steps, the oldest
   * byte no longer takes part in the hash key, that is:
   *   hash_shift * MIN_MATCH >= hash_bits
   */

  this.block_start = 0;
  /* Window position at the beginning of the current output block. Gets
   * negative when the window is moved backwards.
   */

  this.match_length = 0;      /* length of best match */
  this.prev_match = 0;        /* previous match */
  this.match_available = 0;   /* set if previous match exists */
  this.strstart = 0;          /* start of string to insert */
  this.match_start = 0;       /* start of matching string */
  this.lookahead = 0;         /* number of valid bytes ahead in window */

  this.prev_length = 0;
  /* Length of the best match at previous step. Matches not greater than this
   * are discarded. This is used in the lazy match evaluation.
   */

  this.max_chain_length = 0;
  /* To speed up deflation, hash chains are never searched beyond this
   * length.  A higher limit improves compression ratio but degrades the
   * speed.
   */

  this.max_lazy_match = 0;
  /* Attempt to find a better match only when the current match is strictly
   * smaller than this value. This mechanism is used only for compression
   * levels >= 4.
   */
  // That's alias to max_lazy_match, don't use directly
  //this.max_insert_length = 0;
  /* Insert new strings in the hash table only if the match length is not
   * greater than this length. This saves time but degrades compression.
   * max_insert_length is used only for compression levels <= 3.
   */

  this.level = 0;     /* compression level (1..9) */
  this.strategy = 0;  /* favor or force Huffman coding*/

  this.good_match = 0;
  /* Use a faster search when the previous match is longer than this */

  this.nice_match = 0; /* Stop searching when current match exceeds this */

              /* used by trees.c: */

  /* Didn't use ct_data typedef below to suppress compiler warning */

  // struct ct_data_s dyn_ltree[HEAP_SIZE];   /* literal and length tree */
  // struct ct_data_s dyn_dtree[2*D_CODES+1]; /* distance tree */
  // struct ct_data_s bl_tree[2*BL_CODES+1];  /* Huffman tree for bit lengths */

  // Use flat array of DOUBLE size, with interleaved fata,
  // because JS does not support effective
  this.dyn_ltree  = new utils.Buf16(HEAP_SIZE * 2);
  this.dyn_dtree  = new utils.Buf16((2*D_CODES+1) * 2);
  this.bl_tree    = new utils.Buf16((2*BL_CODES+1) * 2);
  zero(this.dyn_ltree);
  zero(this.dyn_dtree);
  zero(this.bl_tree);

  this.l_desc   = null;         /* desc. for literal tree */
  this.d_desc   = null;         /* desc. for distance tree */
  this.bl_desc  = null;         /* desc. for bit length tree */

  //ush bl_count[MAX_BITS+1];
  this.bl_count = new utils.Buf16(MAX_BITS+1);
  /* number of codes at each bit length for an optimal tree */

  //int heap[2*L_CODES+1];      /* heap used to build the Huffman trees */
  this.heap = new utils.Buf16(2*L_CODES+1);  /* heap used to build the Huffman trees */
  zero(this.heap);

  this.heap_len = 0;               /* number of elements in the heap */
  this.heap_max = 0;               /* element of largest frequency */
  /* The sons of heap[n] are heap[2*n] and heap[2*n+1]. heap[0] is not used.
   * The same heap array is used to build all trees.
   */

  this.depth = new utils.Buf16(2*L_CODES+1); //uch depth[2*L_CODES+1];
  zero(this.depth);
  /* Depth of each subtree used as tie breaker for trees of equal frequency
   */

  this.l_buf = 0;          /* buffer index for literals or lengths */

  this.lit_bufsize = 0;
  /* Size of match buffer for literals/lengths.  There are 4 reasons for
   * limiting lit_bufsize to 64K:
   *   - frequencies can be kept in 16 bit counters
   *   - if compression is not successful for the first block, all input
   *     data is still in the window so we can still emit a stored block even
   *     when input comes from standard input.  (This can also be done for
   *     all blocks if lit_bufsize is not greater than 32K.)
   *   - if compression is not successful for a file smaller than 64K, we can
   *     even emit a stored file instead of a stored block (saving 5 bytes).
   *     This is applicable only for zip (not gzip or zlib).
   *   - creating new Huffman trees less frequently may not provide fast
   *     adaptation to changes in the input data statistics. (Take for
   *     example a binary file with poorly compressible code followed by
   *     a highly compressible string table.) Smaller buffer sizes give
   *     fast adaptation but have of course the overhead of transmitting
   *     trees more frequently.
   *   - I can't count above 4
   */

  this.last_lit = 0;      /* running index in l_buf */

  this.d_buf = 0;
  /* Buffer index for distances. To simplify the code, d_buf and l_buf have
   * the same number of elements. To use different lengths, an extra flag
   * array would be necessary.
   */

  this.opt_len = 0;       /* bit length of current block with optimal trees */
  this.static_len = 0;    /* bit length of current block with static trees */
  this.matches = 0;       /* number of string matches in current block */
  this.insert = 0;        /* bytes at end of window left to insert */


  this.bi_buf = 0;
  /* Output buffer. bits are inserted starting at the bottom (least
   * significant bits).
   */
  this.bi_valid = 0;
  /* Number of valid bits in bi_buf.  All bits above the last valid bit
   * are always zero.
   */

  // Used for window memory init. We safely ignore it for JS. That makes
  // sense only for pointers and memory check tools.
  //this.high_water = 0;
  /* High water mark offset in window for initialized bytes -- bytes above
   * this are set to zero in order to avoid memory check warnings when
   * longest match routines access bytes past the input.  This is then
   * updated to the new high water mark.
   */
}


function deflateResetKeep(strm) {
  var s;

  if (!strm || !strm.state) {
    return err(strm, Z_STREAM_ERROR);
  }

  strm.total_in = strm.total_out = 0;
  strm.data_type = Z_UNKNOWN;

  s = strm.state;
  s.pending = 0;
  s.pending_out = 0;

  if (s.wrap < 0) {
    s.wrap = -s.wrap;
    /* was made negative by deflate(..., Z_FINISH); */
  }
  s.status = (s.wrap ? INIT_STATE : BUSY_STATE);
  strm.adler = (s.wrap === 2) ?
    0  // crc32(0, Z_NULL, 0)
  :
    1; // adler32(0, Z_NULL, 0)
  s.last_flush = Z_NO_FLUSH;
  trees._tr_init(s);
  return Z_OK;
}


function deflateReset(strm) {
  var ret = deflateResetKeep(strm);
  if (ret === Z_OK) {
    lm_init(strm.state);
  }
  return ret;
}


function deflateSetHeader(strm, head) {
  if (!strm || !strm.state) { return Z_STREAM_ERROR; }
  if (strm.state.wrap !== 2) { return Z_STREAM_ERROR; }
  strm.state.gzhead = head;
  return Z_OK;
}


function deflateInit2(strm, level, method, windowBits, memLevel, strategy) {
  if (!strm) { // === Z_NULL
    return Z_STREAM_ERROR;
  }
  var wrap = 1;

  if (level === Z_DEFAULT_COMPRESSION) {
    level = 6;
  }

  if (windowBits < 0) { /* suppress zlib wrapper */
    wrap = 0;
    windowBits = -windowBits;
  }

  else if (windowBits > 15) {
    wrap = 2;           /* write gzip wrapper instead */
    windowBits -= 16;
  }


  if (memLevel < 1 || memLevel > MAX_MEM_LEVEL || method !== Z_DEFLATED ||
    windowBits < 8 || windowBits > 15 || level < 0 || level > 9 ||
    strategy < 0 || strategy > Z_FIXED) {
    return err(strm, Z_STREAM_ERROR);
  }


  if (windowBits === 8) {
    windowBits = 9;
  }
  /* until 256-byte window bug fixed */

  var s = new DeflateState();

  strm.state = s;
  s.strm = strm;

  s.wrap = wrap;
  s.gzhead = null;
  s.w_bits = windowBits;
  s.w_size = 1 << s.w_bits;
  s.w_mask = s.w_size - 1;

  s.hash_bits = memLevel + 7;
  s.hash_size = 1 << s.hash_bits;
  s.hash_mask = s.hash_size - 1;
  s.hash_shift = ~~((s.hash_bits + MIN_MATCH - 1) / MIN_MATCH);

  s.window = new utils.Buf8(s.w_size * 2);
  s.head = new utils.Buf16(s.hash_size);
  s.prev = new utils.Buf16(s.w_size);

  // Don't need mem init magic for JS.
  //s.high_water = 0;  /* nothing written to s->window yet */

  s.lit_bufsize = 1 << (memLevel + 6); /* 16K elements by default */

  s.pending_buf_size = s.lit_bufsize * 4;
  s.pending_buf = new utils.Buf8(s.pending_buf_size);

  s.d_buf = s.lit_bufsize >> 1;
  s.l_buf = (1 + 2) * s.lit_bufsize;

  s.level = level;
  s.strategy = strategy;
  s.method = method;

  return deflateReset(strm);
}

function deflateInit(strm, level) {
  return deflateInit2(strm, level, Z_DEFLATED, MAX_WBITS, DEF_MEM_LEVEL, Z_DEFAULT_STRATEGY);
}


function deflate(strm, flush) {
  var old_flush, s;
  var beg, val; // for gzip header write only

  if (!strm || !strm.state ||
    flush > Z_BLOCK || flush < 0) {
    return strm ? err(strm, Z_STREAM_ERROR) : Z_STREAM_ERROR;
  }

  s = strm.state;

  if (!strm.output ||
      (!strm.input && strm.avail_in !== 0) ||
      (s.status === FINISH_STATE && flush !== Z_FINISH)) {
    return err(strm, (strm.avail_out === 0) ? Z_BUF_ERROR : Z_STREAM_ERROR);
  }

  s.strm = strm; /* just in case */
  old_flush = s.last_flush;
  s.last_flush = flush;

  /* Write the header */
  if (s.status === INIT_STATE) {

    if (s.wrap === 2) { // GZIP header
      strm.adler = 0;  //crc32(0L, Z_NULL, 0);
      put_byte(s, 31);
      put_byte(s, 139);
      put_byte(s, 8);
      if (!s.gzhead) { // s->gzhead == Z_NULL
        put_byte(s, 0);
        put_byte(s, 0);
        put_byte(s, 0);
        put_byte(s, 0);
        put_byte(s, 0);
        put_byte(s, s.level === 9 ? 2 :
                    (s.strategy >= Z_HUFFMAN_ONLY || s.level < 2 ?
                     4 : 0));
        put_byte(s, OS_CODE);
        s.status = BUSY_STATE;
      }
      else {
        put_byte(s, (s.gzhead.text ? 1 : 0) +
                    (s.gzhead.hcrc ? 2 : 0) +
                    (!s.gzhead.extra ? 0 : 4) +
                    (!s.gzhead.name ? 0 : 8) +
                    (!s.gzhead.comment ? 0 : 16)
                );
        put_byte(s, s.gzhead.time & 0xff);
        put_byte(s, (s.gzhead.time >> 8) & 0xff);
        put_byte(s, (s.gzhead.time >> 16) & 0xff);
        put_byte(s, (s.gzhead.time >> 24) & 0xff);
        put_byte(s, s.level === 9 ? 2 :
                    (s.strategy >= Z_HUFFMAN_ONLY || s.level < 2 ?
                     4 : 0));
        put_byte(s, s.gzhead.os & 0xff);
        if (s.gzhead.extra && s.gzhead.extra.length) {
          put_byte(s, s.gzhead.extra.length & 0xff);
          put_byte(s, (s.gzhead.extra.length >> 8) & 0xff);
        }
        if (s.gzhead.hcrc) {
          strm.adler = crc32(strm.adler, s.pending_buf, s.pending, 0);
        }
        s.gzindex = 0;
        s.status = EXTRA_STATE;
      }
    }
    else // DEFLATE header
    {
      var header = (Z_DEFLATED + ((s.w_bits - 8) << 4)) << 8;
      var level_flags = -1;

      if (s.strategy >= Z_HUFFMAN_ONLY || s.level < 2) {
        level_flags = 0;
      } else if (s.level < 6) {
        level_flags = 1;
      } else if (s.level === 6) {
        level_flags = 2;
      } else {
        level_flags = 3;
      }
      header |= (level_flags << 6);
      if (s.strstart !== 0) { header |= PRESET_DICT; }
      header += 31 - (header % 31);

      s.status = BUSY_STATE;
      putShortMSB(s, header);

      /* Save the adler32 of the preset dictionary: */
      if (s.strstart !== 0) {
        putShortMSB(s, strm.adler >>> 16);
        putShortMSB(s, strm.adler & 0xffff);
      }
      strm.adler = 1; // adler32(0L, Z_NULL, 0);
    }
  }

//#ifdef GZIP
  if (s.status === EXTRA_STATE) {
    if (s.gzhead.extra/* != Z_NULL*/) {
      beg = s.pending;  /* start of bytes to update crc */

      while (s.gzindex < (s.gzhead.extra.length & 0xffff)) {
        if (s.pending === s.pending_buf_size) {
          if (s.gzhead.hcrc && s.pending > beg) {
            strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
          }
          flush_pending(strm);
          beg = s.pending;
          if (s.pending === s.pending_buf_size) {
            break;
          }
        }
        put_byte(s, s.gzhead.extra[s.gzindex] & 0xff);
        s.gzindex++;
      }
      if (s.gzhead.hcrc && s.pending > beg) {
        strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
      }
      if (s.gzindex === s.gzhead.extra.length) {
        s.gzindex = 0;
        s.status = NAME_STATE;
      }
    }
    else {
      s.status = NAME_STATE;
    }
  }
  if (s.status === NAME_STATE) {
    if (s.gzhead.name/* != Z_NULL*/) {
      beg = s.pending;  /* start of bytes to update crc */
      //int val;

      do {
        if (s.pending === s.pending_buf_size) {
          if (s.gzhead.hcrc && s.pending > beg) {
            strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
          }
          flush_pending(strm);
          beg = s.pending;
          if (s.pending === s.pending_buf_size) {
            val = 1;
            break;
          }
        }
        // JS specific: little magic to add zero terminator to end of string
        if (s.gzindex < s.gzhead.name.length) {
          val = s.gzhead.name.charCodeAt(s.gzindex++) & 0xff;
        } else {
          val = 0;
        }
        put_byte(s, val);
      } while (val !== 0);

      if (s.gzhead.hcrc && s.pending > beg) {
        strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
      }
      if (val === 0) {
        s.gzindex = 0;
        s.status = COMMENT_STATE;
      }
    }
    else {
      s.status = COMMENT_STATE;
    }
  }
  if (s.status === COMMENT_STATE) {
    if (s.gzhead.comment/* != Z_NULL*/) {
      beg = s.pending;  /* start of bytes to update crc */
      //int val;

      do {
        if (s.pending === s.pending_buf_size) {
          if (s.gzhead.hcrc && s.pending > beg) {
            strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
          }
          flush_pending(strm);
          beg = s.pending;
          if (s.pending === s.pending_buf_size) {
            val = 1;
            break;
          }
        }
        // JS specific: little magic to add zero terminator to end of string
        if (s.gzindex < s.gzhead.comment.length) {
          val = s.gzhead.comment.charCodeAt(s.gzindex++) & 0xff;
        } else {
          val = 0;
        }
        put_byte(s, val);
      } while (val !== 0);

      if (s.gzhead.hcrc && s.pending > beg) {
        strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
      }
      if (val === 0) {
        s.status = HCRC_STATE;
      }
    }
    else {
      s.status = HCRC_STATE;
    }
  }
  if (s.status === HCRC_STATE) {
    if (s.gzhead.hcrc) {
      if (s.pending + 2 > s.pending_buf_size) {
        flush_pending(strm);
      }
      if (s.pending + 2 <= s.pending_buf_size) {
        put_byte(s, strm.adler & 0xff);
        put_byte(s, (strm.adler >> 8) & 0xff);
        strm.adler = 0; //crc32(0L, Z_NULL, 0);
        s.status = BUSY_STATE;
      }
    }
    else {
      s.status = BUSY_STATE;
    }
  }
//#endif

  /* Flush as much pending output as possible */
  if (s.pending !== 0) {
    flush_pending(strm);
    if (strm.avail_out === 0) {
      /* Since avail_out is 0, deflate will be called again with
       * more output space, but possibly with both pending and
       * avail_in equal to zero. There won't be anything to do,
       * but this is not an error situation so make sure we
       * return OK instead of BUF_ERROR at next call of deflate:
       */
      s.last_flush = -1;
      return Z_OK;
    }

    /* Make sure there is something to do and avoid duplicate consecutive
     * flushes. For repeated and useless calls with Z_FINISH, we keep
     * returning Z_STREAM_END instead of Z_BUF_ERROR.
     */
  } else if (strm.avail_in === 0 && rank(flush) <= rank(old_flush) &&
    flush !== Z_FINISH) {
    return err(strm, Z_BUF_ERROR);
  }

  /* User must not provide more input after the first FINISH: */
  if (s.status === FINISH_STATE && strm.avail_in !== 0) {
    return err(strm, Z_BUF_ERROR);
  }

  /* Start a new block or continue the current one.
   */
  if (strm.avail_in !== 0 || s.lookahead !== 0 ||
    (flush !== Z_NO_FLUSH && s.status !== FINISH_STATE)) {
    var bstate = (s.strategy === Z_HUFFMAN_ONLY) ? deflate_huff(s, flush) :
      (s.strategy === Z_RLE ? deflate_rle(s, flush) :
        configuration_table[s.level].func(s, flush));

    if (bstate === BS_FINISH_STARTED || bstate === BS_FINISH_DONE) {
      s.status = FINISH_STATE;
    }
    if (bstate === BS_NEED_MORE || bstate === BS_FINISH_STARTED) {
      if (strm.avail_out === 0) {
        s.last_flush = -1;
        /* avoid BUF_ERROR next call, see above */
      }
      return Z_OK;
      /* If flush != Z_NO_FLUSH && avail_out == 0, the next call
       * of deflate should use the same flush parameter to make sure
       * that the flush is complete. So we don't have to output an
       * empty block here, this will be done at next call. This also
       * ensures that for a very small output buffer, we emit at most
       * one empty block.
       */
    }
    if (bstate === BS_BLOCK_DONE) {
      if (flush === Z_PARTIAL_FLUSH) {
        trees._tr_align(s);
      }
      else if (flush !== Z_BLOCK) { /* FULL_FLUSH or SYNC_FLUSH */

        trees._tr_stored_block(s, 0, 0, false);
        /* For a full flush, this empty block will be recognized
         * as a special marker by inflate_sync().
         */
        if (flush === Z_FULL_FLUSH) {
          /*** CLEAR_HASH(s); ***/             /* forget history */
          zero(s.head); // Fill with NIL (= 0);

          if (s.lookahead === 0) {
            s.strstart = 0;
            s.block_start = 0;
            s.insert = 0;
          }
        }
      }
      flush_pending(strm);
      if (strm.avail_out === 0) {
        s.last_flush = -1; /* avoid BUF_ERROR at next call, see above */
        return Z_OK;
      }
    }
  }
  //Assert(strm->avail_out > 0, "bug2");
  //if (strm.avail_out <= 0) { throw new Error("bug2");}

  if (flush !== Z_FINISH) { return Z_OK; }
  if (s.wrap <= 0) { return Z_STREAM_END; }

  /* Write the trailer */
  if (s.wrap === 2) {
    put_byte(s, strm.adler & 0xff);
    put_byte(s, (strm.adler >> 8) & 0xff);
    put_byte(s, (strm.adler >> 16) & 0xff);
    put_byte(s, (strm.adler >> 24) & 0xff);
    put_byte(s, strm.total_in & 0xff);
    put_byte(s, (strm.total_in >> 8) & 0xff);
    put_byte(s, (strm.total_in >> 16) & 0xff);
    put_byte(s, (strm.total_in >> 24) & 0xff);
  }
  else
  {
    putShortMSB(s, strm.adler >>> 16);
    putShortMSB(s, strm.adler & 0xffff);
  }

  flush_pending(strm);
  /* If avail_out is zero, the application will call deflate again
   * to flush the rest.
   */
  if (s.wrap > 0) { s.wrap = -s.wrap; }
  /* write the trailer only once! */
  return s.pending !== 0 ? Z_OK : Z_STREAM_END;
}

function deflateEnd(strm) {
  var status;

  if (!strm/*== Z_NULL*/ || !strm.state/*== Z_NULL*/) {
    return Z_STREAM_ERROR;
  }

  status = strm.state.status;
  if (status !== INIT_STATE &&
    status !== EXTRA_STATE &&
    status !== NAME_STATE &&
    status !== COMMENT_STATE &&
    status !== HCRC_STATE &&
    status !== BUSY_STATE &&
    status !== FINISH_STATE
  ) {
    return err(strm, Z_STREAM_ERROR);
  }

  strm.state = null;

  return status === BUSY_STATE ? err(strm, Z_DATA_ERROR) : Z_OK;
}

/* =========================================================================
 * Copy the source state to the destination state
 */
//function deflateCopy(dest, source) {
//
//}

exports.deflateInit = deflateInit;
exports.deflateInit2 = deflateInit2;
exports.deflateReset = deflateReset;
exports.deflateResetKeep = deflateResetKeep;
exports.deflateSetHeader = deflateSetHeader;
exports.deflate = deflate;
exports.deflateEnd = deflateEnd;
exports.deflateInfo = 'pako deflate (from Nodeca project)';

/* Not implemented
exports.deflateBound = deflateBound;
exports.deflateCopy = deflateCopy;
exports.deflateSetDictionary = deflateSetDictionary;
exports.deflateParams = deflateParams;
exports.deflatePending = deflatePending;
exports.deflatePrime = deflatePrime;
exports.deflateTune = deflateTune;
*/

},{"../utils/common":92,"./adler32":93,"./crc32":95,"./messages":100,"./trees":101}],97:[function(require,module,exports){
'use strict';

// See state defs from inflate.js
var BAD = 30;       /* got a data error -- remain here until reset */
var TYPE = 12;      /* i: waiting for type bits, including last-flag bit */

/*
   Decode literal, length, and distance codes and write out the resulting
   literal and match bytes until either not enough input or output is
   available, an end-of-block is encountered, or a data error is encountered.
   When large enough input and output buffers are supplied to inflate(), for
   example, a 16K input buffer and a 64K output buffer, more than 95% of the
   inflate execution time is spent in this routine.

   Entry assumptions:

        state.mode === LEN
        strm.avail_in >= 6
        strm.avail_out >= 258
        start >= strm.avail_out
        state.bits < 8

   On return, state.mode is one of:

        LEN -- ran out of enough output space or enough available input
        TYPE -- reached end of block code, inflate() to interpret next block
        BAD -- error in block data

   Notes:

    - The maximum input bits used by a length/distance pair is 15 bits for the
      length code, 5 bits for the length extra, 15 bits for the distance code,
      and 13 bits for the distance extra.  This totals 48 bits, or six bytes.
      Therefore if strm.avail_in >= 6, then there is enough input to avoid
      checking for available input while decoding.

    - The maximum bytes that a single length/distance pair can output is 258
      bytes, which is the maximum length that can be coded.  inflate_fast()
      requires strm.avail_out >= 258 for each loop to avoid checking for
      output space.
 */
module.exports = function inflate_fast(strm, start) {
  var state;
  var _in;                    /* local strm.input */
  var last;                   /* have enough input while in < last */
  var _out;                   /* local strm.output */
  var beg;                    /* inflate()'s initial strm.output */
  var end;                    /* while out < end, enough space available */
//#ifdef INFLATE_STRICT
  var dmax;                   /* maximum distance from zlib header */
//#endif
  var wsize;                  /* window size or zero if not using window */
  var whave;                  /* valid bytes in the window */
  var wnext;                  /* window write index */
  // Use `s_window` instead `window`, avoid conflict with instrumentation tools
  var s_window;               /* allocated sliding window, if wsize != 0 */
  var hold;                   /* local strm.hold */
  var bits;                   /* local strm.bits */
  var lcode;                  /* local strm.lencode */
  var dcode;                  /* local strm.distcode */
  var lmask;                  /* mask for first level of length codes */
  var dmask;                  /* mask for first level of distance codes */
  var here;                   /* retrieved table entry */
  var op;                     /* code bits, operation, extra bits, or */
                              /*  window position, window bytes to copy */
  var len;                    /* match length, unused bytes */
  var dist;                   /* match distance */
  var from;                   /* where to copy match from */
  var from_source;


  var input, output; // JS specific, because we have no pointers

  /* copy state to local variables */
  state = strm.state;
  //here = state.here;
  _in = strm.next_in;
  input = strm.input;
  last = _in + (strm.avail_in - 5);
  _out = strm.next_out;
  output = strm.output;
  beg = _out - (start - strm.avail_out);
  end = _out + (strm.avail_out - 257);
//#ifdef INFLATE_STRICT
  dmax = state.dmax;
//#endif
  wsize = state.wsize;
  whave = state.whave;
  wnext = state.wnext;
  s_window = state.window;
  hold = state.hold;
  bits = state.bits;
  lcode = state.lencode;
  dcode = state.distcode;
  lmask = (1 << state.lenbits) - 1;
  dmask = (1 << state.distbits) - 1;


  /* decode literals and length/distances until end-of-block or not enough
     input data or output space */

  top:
  do {
    if (bits < 15) {
      hold += input[_in++] << bits;
      bits += 8;
      hold += input[_in++] << bits;
      bits += 8;
    }

    here = lcode[hold & lmask];

    dolen:
    for (;;) { // Goto emulation
      op = here >>> 24/*here.bits*/;
      hold >>>= op;
      bits -= op;
      op = (here >>> 16) & 0xff/*here.op*/;
      if (op === 0) {                          /* literal */
        //Tracevv((stderr, here.val >= 0x20 && here.val < 0x7f ?
        //        "inflate:         literal '%c'\n" :
        //        "inflate:         literal 0x%02x\n", here.val));
        output[_out++] = here & 0xffff/*here.val*/;
      }
      else if (op & 16) {                     /* length base */
        len = here & 0xffff/*here.val*/;
        op &= 15;                           /* number of extra bits */
        if (op) {
          if (bits < op) {
            hold += input[_in++] << bits;
            bits += 8;
          }
          len += hold & ((1 << op) - 1);
          hold >>>= op;
          bits -= op;
        }
        //Tracevv((stderr, "inflate:         length %u\n", len));
        if (bits < 15) {
          hold += input[_in++] << bits;
          bits += 8;
          hold += input[_in++] << bits;
          bits += 8;
        }
        here = dcode[hold & dmask];

        dodist:
        for (;;) { // goto emulation
          op = here >>> 24/*here.bits*/;
          hold >>>= op;
          bits -= op;
          op = (here >>> 16) & 0xff/*here.op*/;

          if (op & 16) {                      /* distance base */
            dist = here & 0xffff/*here.val*/;
            op &= 15;                       /* number of extra bits */
            if (bits < op) {
              hold += input[_in++] << bits;
              bits += 8;
              if (bits < op) {
                hold += input[_in++] << bits;
                bits += 8;
              }
            }
            dist += hold & ((1 << op) - 1);
//#ifdef INFLATE_STRICT
            if (dist > dmax) {
              strm.msg = 'invalid distance too far back';
              state.mode = BAD;
              break top;
            }
//#endif
            hold >>>= op;
            bits -= op;
            //Tracevv((stderr, "inflate:         distance %u\n", dist));
            op = _out - beg;                /* max distance in output */
            if (dist > op) {                /* see if copy from window */
              op = dist - op;               /* distance back in window */
              if (op > whave) {
                if (state.sane) {
                  strm.msg = 'invalid distance too far back';
                  state.mode = BAD;
                  break top;
                }

// (!) This block is disabled in zlib defailts,
// don't enable it for binary compatibility
//#ifdef INFLATE_ALLOW_INVALID_DISTANCE_TOOFAR_ARRR
//                if (len <= op - whave) {
//                  do {
//                    output[_out++] = 0;
//                  } while (--len);
//                  continue top;
//                }
//                len -= op - whave;
//                do {
//                  output[_out++] = 0;
//                } while (--op > whave);
//                if (op === 0) {
//                  from = _out - dist;
//                  do {
//                    output[_out++] = output[from++];
//                  } while (--len);
//                  continue top;
//                }
//#endif
              }
              from = 0; // window index
              from_source = s_window;
              if (wnext === 0) {           /* very common case */
                from += wsize - op;
                if (op < len) {         /* some from window */
                  len -= op;
                  do {
                    output[_out++] = s_window[from++];
                  } while (--op);
                  from = _out - dist;  /* rest from output */
                  from_source = output;
                }
              }
              else if (wnext < op) {      /* wrap around window */
                from += wsize + wnext - op;
                op -= wnext;
                if (op < len) {         /* some from end of window */
                  len -= op;
                  do {
                    output[_out++] = s_window[from++];
                  } while (--op);
                  from = 0;
                  if (wnext < len) {  /* some from start of window */
                    op = wnext;
                    len -= op;
                    do {
                      output[_out++] = s_window[from++];
                    } while (--op);
                    from = _out - dist;      /* rest from output */
                    from_source = output;
                  }
                }
              }
              else {                      /* contiguous in window */
                from += wnext - op;
                if (op < len) {         /* some from window */
                  len -= op;
                  do {
                    output[_out++] = s_window[from++];
                  } while (--op);
                  from = _out - dist;  /* rest from output */
                  from_source = output;
                }
              }
              while (len > 2) {
                output[_out++] = from_source[from++];
                output[_out++] = from_source[from++];
                output[_out++] = from_source[from++];
                len -= 3;
              }
              if (len) {
                output[_out++] = from_source[from++];
                if (len > 1) {
                  output[_out++] = from_source[from++];
                }
              }
            }
            else {
              from = _out - dist;          /* copy direct from output */
              do {                        /* minimum length is three */
                output[_out++] = output[from++];
                output[_out++] = output[from++];
                output[_out++] = output[from++];
                len -= 3;
              } while (len > 2);
              if (len) {
                output[_out++] = output[from++];
                if (len > 1) {
                  output[_out++] = output[from++];
                }
              }
            }
          }
          else if ((op & 64) === 0) {          /* 2nd level distance code */
            here = dcode[(here & 0xffff)/*here.val*/ + (hold & ((1 << op) - 1))];
            continue dodist;
          }
          else {
            strm.msg = 'invalid distance code';
            state.mode = BAD;
            break top;
          }

          break; // need to emulate goto via "continue"
        }
      }
      else if ((op & 64) === 0) {              /* 2nd level length code */
        here = lcode[(here & 0xffff)/*here.val*/ + (hold & ((1 << op) - 1))];
        continue dolen;
      }
      else if (op & 32) {                     /* end-of-block */
        //Tracevv((stderr, "inflate:         end of block\n"));
        state.mode = TYPE;
        break top;
      }
      else {
        strm.msg = 'invalid literal/length code';
        state.mode = BAD;
        break top;
      }

      break; // need to emulate goto via "continue"
    }
  } while (_in < last && _out < end);

  /* return unused bytes (on entry, bits < 8, so in won't go too far back) */
  len = bits >> 3;
  _in -= len;
  bits -= len << 3;
  hold &= (1 << bits) - 1;

  /* update state and return */
  strm.next_in = _in;
  strm.next_out = _out;
  strm.avail_in = (_in < last ? 5 + (last - _in) : 5 - (_in - last));
  strm.avail_out = (_out < end ? 257 + (end - _out) : 257 - (_out - end));
  state.hold = hold;
  state.bits = bits;
  return;
};

},{}],98:[function(require,module,exports){
'use strict';


var utils = require('../utils/common');
var adler32 = require('./adler32');
var crc32   = require('./crc32');
var inflate_fast = require('./inffast');
var inflate_table = require('./inftrees');

var CODES = 0;
var LENS = 1;
var DISTS = 2;

/* Public constants ==========================================================*/
/* ===========================================================================*/


/* Allowed flush values; see deflate() and inflate() below for details */
//var Z_NO_FLUSH      = 0;
//var Z_PARTIAL_FLUSH = 1;
//var Z_SYNC_FLUSH    = 2;
//var Z_FULL_FLUSH    = 3;
var Z_FINISH        = 4;
var Z_BLOCK         = 5;
var Z_TREES         = 6;


/* Return codes for the compression/decompression functions. Negative values
 * are errors, positive values are used for special but normal events.
 */
var Z_OK            = 0;
var Z_STREAM_END    = 1;
var Z_NEED_DICT     = 2;
//var Z_ERRNO         = -1;
var Z_STREAM_ERROR  = -2;
var Z_DATA_ERROR    = -3;
var Z_MEM_ERROR     = -4;
var Z_BUF_ERROR     = -5;
//var Z_VERSION_ERROR = -6;

/* The deflate compression method */
var Z_DEFLATED  = 8;


/* STATES ====================================================================*/
/* ===========================================================================*/


var    HEAD = 1;       /* i: waiting for magic header */
var    FLAGS = 2;      /* i: waiting for method and flags (gzip) */
var    TIME = 3;       /* i: waiting for modification time (gzip) */
var    OS = 4;         /* i: waiting for extra flags and operating system (gzip) */
var    EXLEN = 5;      /* i: waiting for extra length (gzip) */
var    EXTRA = 6;      /* i: waiting for extra bytes (gzip) */
var    NAME = 7;       /* i: waiting for end of file name (gzip) */
var    COMMENT = 8;    /* i: waiting for end of comment (gzip) */
var    HCRC = 9;       /* i: waiting for header crc (gzip) */
var    DICTID = 10;    /* i: waiting for dictionary check value */
var    DICT = 11;      /* waiting for inflateSetDictionary() call */
var        TYPE = 12;      /* i: waiting for type bits, including last-flag bit */
var        TYPEDO = 13;    /* i: same, but skip check to exit inflate on new block */
var        STORED = 14;    /* i: waiting for stored size (length and complement) */
var        COPY_ = 15;     /* i/o: same as COPY below, but only first time in */
var        COPY = 16;      /* i/o: waiting for input or output to copy stored block */
var        TABLE = 17;     /* i: waiting for dynamic block table lengths */
var        LENLENS = 18;   /* i: waiting for code length code lengths */
var        CODELENS = 19;  /* i: waiting for length/lit and distance code lengths */
var            LEN_ = 20;      /* i: same as LEN below, but only first time in */
var            LEN = 21;       /* i: waiting for length/lit/eob code */
var            LENEXT = 22;    /* i: waiting for length extra bits */
var            DIST = 23;      /* i: waiting for distance code */
var            DISTEXT = 24;   /* i: waiting for distance extra bits */
var            MATCH = 25;     /* o: waiting for output space to copy string */
var            LIT = 26;       /* o: waiting for output space to write literal */
var    CHECK = 27;     /* i: waiting for 32-bit check value */
var    LENGTH = 28;    /* i: waiting for 32-bit length (gzip) */
var    DONE = 29;      /* finished check, done -- remain here until reset */
var    BAD = 30;       /* got a data error -- remain here until reset */
var    MEM = 31;       /* got an inflate() memory error -- remain here until reset */
var    SYNC = 32;      /* looking for synchronization bytes to restart inflate() */

/* ===========================================================================*/



var ENOUGH_LENS = 852;
var ENOUGH_DISTS = 592;
//var ENOUGH =  (ENOUGH_LENS+ENOUGH_DISTS);

var MAX_WBITS = 15;
/* 32K LZ77 window */
var DEF_WBITS = MAX_WBITS;


function ZSWAP32(q) {
  return  (((q >>> 24) & 0xff) +
          ((q >>> 8) & 0xff00) +
          ((q & 0xff00) << 8) +
          ((q & 0xff) << 24));
}


function InflateState() {
  this.mode = 0;             /* current inflate mode */
  this.last = false;          /* true if processing last block */
  this.wrap = 0;              /* bit 0 true for zlib, bit 1 true for gzip */
  this.havedict = false;      /* true if dictionary provided */
  this.flags = 0;             /* gzip header method and flags (0 if zlib) */
  this.dmax = 0;              /* zlib header max distance (INFLATE_STRICT) */
  this.check = 0;             /* protected copy of check value */
  this.total = 0;             /* protected copy of output count */
  // TODO: may be {}
  this.head = null;           /* where to save gzip header information */

  /* sliding window */
  this.wbits = 0;             /* log base 2 of requested window size */
  this.wsize = 0;             /* window size or zero if not using window */
  this.whave = 0;             /* valid bytes in the window */
  this.wnext = 0;             /* window write index */
  this.window = null;         /* allocated sliding window, if needed */

  /* bit accumulator */
  this.hold = 0;              /* input bit accumulator */
  this.bits = 0;              /* number of bits in "in" */

  /* for string and stored block copying */
  this.length = 0;            /* literal or length of data to copy */
  this.offset = 0;            /* distance back to copy string from */

  /* for table and code decoding */
  this.extra = 0;             /* extra bits needed */

  /* fixed and dynamic code tables */
  this.lencode = null;          /* starting table for length/literal codes */
  this.distcode = null;         /* starting table for distance codes */
  this.lenbits = 0;           /* index bits for lencode */
  this.distbits = 0;          /* index bits for distcode */

  /* dynamic table building */
  this.ncode = 0;             /* number of code length code lengths */
  this.nlen = 0;              /* number of length code lengths */
  this.ndist = 0;             /* number of distance code lengths */
  this.have = 0;              /* number of code lengths in lens[] */
  this.next = null;              /* next available space in codes[] */

  this.lens = new utils.Buf16(320); /* temporary storage for code lengths */
  this.work = new utils.Buf16(288); /* work area for code table building */

  /*
   because we don't have pointers in js, we use lencode and distcode directly
   as buffers so we don't need codes
  */
  //this.codes = new utils.Buf32(ENOUGH);       /* space for code tables */
  this.lendyn = null;              /* dynamic table for length/literal codes (JS specific) */
  this.distdyn = null;             /* dynamic table for distance codes (JS specific) */
  this.sane = 0;                   /* if false, allow invalid distance too far */
  this.back = 0;                   /* bits back of last unprocessed length/lit */
  this.was = 0;                    /* initial length of match */
}

function inflateResetKeep(strm) {
  var state;

  if (!strm || !strm.state) { return Z_STREAM_ERROR; }
  state = strm.state;
  strm.total_in = strm.total_out = state.total = 0;
  strm.msg = ''; /*Z_NULL*/
  if (state.wrap) {       /* to support ill-conceived Java test suite */
    strm.adler = state.wrap & 1;
  }
  state.mode = HEAD;
  state.last = 0;
  state.havedict = 0;
  state.dmax = 32768;
  state.head = null/*Z_NULL*/;
  state.hold = 0;
  state.bits = 0;
  //state.lencode = state.distcode = state.next = state.codes;
  state.lencode = state.lendyn = new utils.Buf32(ENOUGH_LENS);
  state.distcode = state.distdyn = new utils.Buf32(ENOUGH_DISTS);

  state.sane = 1;
  state.back = -1;
  //Tracev((stderr, "inflate: reset\n"));
  return Z_OK;
}

function inflateReset(strm) {
  var state;

  if (!strm || !strm.state) { return Z_STREAM_ERROR; }
  state = strm.state;
  state.wsize = 0;
  state.whave = 0;
  state.wnext = 0;
  return inflateResetKeep(strm);

}

function inflateReset2(strm, windowBits) {
  var wrap;
  var state;

  /* get the state */
  if (!strm || !strm.state) { return Z_STREAM_ERROR; }
  state = strm.state;

  /* extract wrap request from windowBits parameter */
  if (windowBits < 0) {
    wrap = 0;
    windowBits = -windowBits;
  }
  else {
    wrap = (windowBits >> 4) + 1;
    if (windowBits < 48) {
      windowBits &= 15;
    }
  }

  /* set number of window bits, free window if different */
  if (windowBits && (windowBits < 8 || windowBits > 15)) {
    return Z_STREAM_ERROR;
  }
  if (state.window !== null && state.wbits !== windowBits) {
    state.window = null;
  }

  /* update state and reset the rest of it */
  state.wrap = wrap;
  state.wbits = windowBits;
  return inflateReset(strm);
}

function inflateInit2(strm, windowBits) {
  var ret;
  var state;

  if (!strm) { return Z_STREAM_ERROR; }
  //strm.msg = Z_NULL;                 /* in case we return an error */

  state = new InflateState();

  //if (state === Z_NULL) return Z_MEM_ERROR;
  //Tracev((stderr, "inflate: allocated\n"));
  strm.state = state;
  state.window = null/*Z_NULL*/;
  ret = inflateReset2(strm, windowBits);
  if (ret !== Z_OK) {
    strm.state = null/*Z_NULL*/;
  }
  return ret;
}

function inflateInit(strm) {
  return inflateInit2(strm, DEF_WBITS);
}


/*
 Return state with length and distance decoding tables and index sizes set to
 fixed code decoding.  Normally this returns fixed tables from inffixed.h.
 If BUILDFIXED is defined, then instead this routine builds the tables the
 first time it's called, and returns those tables the first time and
 thereafter.  This reduces the size of the code by about 2K bytes, in
 exchange for a little execution time.  However, BUILDFIXED should not be
 used for threaded applications, since the rewriting of the tables and virgin
 may not be thread-safe.
 */
var virgin = true;

var lenfix, distfix; // We have no pointers in JS, so keep tables separate

function fixedtables(state) {
  /* build fixed huffman tables if first call (may not be thread safe) */
  if (virgin) {
    var sym;

    lenfix = new utils.Buf32(512);
    distfix = new utils.Buf32(32);

    /* literal/length table */
    sym = 0;
    while (sym < 144) { state.lens[sym++] = 8; }
    while (sym < 256) { state.lens[sym++] = 9; }
    while (sym < 280) { state.lens[sym++] = 7; }
    while (sym < 288) { state.lens[sym++] = 8; }

    inflate_table(LENS,  state.lens, 0, 288, lenfix,   0, state.work, {bits: 9});

    /* distance table */
    sym = 0;
    while (sym < 32) { state.lens[sym++] = 5; }

    inflate_table(DISTS, state.lens, 0, 32,   distfix, 0, state.work, {bits: 5});

    /* do this just once */
    virgin = false;
  }

  state.lencode = lenfix;
  state.lenbits = 9;
  state.distcode = distfix;
  state.distbits = 5;
}


/*
 Update the window with the last wsize (normally 32K) bytes written before
 returning.  If window does not exist yet, create it.  This is only called
 when a window is already in use, or when output has been written during this
 inflate call, but the end of the deflate stream has not been reached yet.
 It is also called to create a window for dictionary data when a dictionary
 is loaded.

 Providing output buffers larger than 32K to inflate() should provide a speed
 advantage, since only the last 32K of output is copied to the sliding window
 upon return from inflate(), and since all distances after the first 32K of
 output will fall in the output data, making match copies simpler and faster.
 The advantage may be dependent on the size of the processor's data caches.
 */
function updatewindow(strm, src, end, copy) {
  var dist;
  var state = strm.state;

  /* if it hasn't been done already, allocate space for the window */
  if (state.window === null) {
    state.wsize = 1 << state.wbits;
    state.wnext = 0;
    state.whave = 0;

    state.window = new utils.Buf8(state.wsize);
  }

  /* copy state->wsize or less output bytes into the circular window */
  if (copy >= state.wsize) {
    utils.arraySet(state.window,src, end - state.wsize, state.wsize, 0);
    state.wnext = 0;
    state.whave = state.wsize;
  }
  else {
    dist = state.wsize - state.wnext;
    if (dist > copy) {
      dist = copy;
    }
    //zmemcpy(state->window + state->wnext, end - copy, dist);
    utils.arraySet(state.window,src, end - copy, dist, state.wnext);
    copy -= dist;
    if (copy) {
      //zmemcpy(state->window, end - copy, copy);
      utils.arraySet(state.window,src, end - copy, copy, 0);
      state.wnext = copy;
      state.whave = state.wsize;
    }
    else {
      state.wnext += dist;
      if (state.wnext === state.wsize) { state.wnext = 0; }
      if (state.whave < state.wsize) { state.whave += dist; }
    }
  }
  return 0;
}

function inflate(strm, flush) {
  var state;
  var input, output;          // input/output buffers
  var next;                   /* next input INDEX */
  var put;                    /* next output INDEX */
  var have, left;             /* available input and output */
  var hold;                   /* bit buffer */
  var bits;                   /* bits in bit buffer */
  var _in, _out;              /* save starting available input and output */
  var copy;                   /* number of stored or match bytes to copy */
  var from;                   /* where to copy match bytes from */
  var from_source;
  var here = 0;               /* current decoding table entry */
  var here_bits, here_op, here_val; // paked "here" denormalized (JS specific)
  //var last;                   /* parent table entry */
  var last_bits, last_op, last_val; // paked "last" denormalized (JS specific)
  var len;                    /* length to copy for repeats, bits to drop */
  var ret;                    /* return code */
  var hbuf = new utils.Buf8(4);    /* buffer for gzip header crc calculation */
  var opts;

  var n; // temporary var for NEED_BITS

  var order = /* permutation of code lengths */
    [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15];


  if (!strm || !strm.state || !strm.output ||
      (!strm.input && strm.avail_in !== 0)) {
    return Z_STREAM_ERROR;
  }

  state = strm.state;
  if (state.mode === TYPE) { state.mode = TYPEDO; }    /* skip check */


  //--- LOAD() ---
  put = strm.next_out;
  output = strm.output;
  left = strm.avail_out;
  next = strm.next_in;
  input = strm.input;
  have = strm.avail_in;
  hold = state.hold;
  bits = state.bits;
  //---

  _in = have;
  _out = left;
  ret = Z_OK;

  inf_leave: // goto emulation
  for (;;) {
    switch (state.mode) {
    case HEAD:
      if (state.wrap === 0) {
        state.mode = TYPEDO;
        break;
      }
      //=== NEEDBITS(16);
      while (bits < 16) {
        if (have === 0) { break inf_leave; }
        have--;
        hold += input[next++] << bits;
        bits += 8;
      }
      //===//
      if ((state.wrap & 2) && hold === 0x8b1f) {  /* gzip header */
        state.check = 0/*crc32(0L, Z_NULL, 0)*/;
        //=== CRC2(state.check, hold);
        hbuf[0] = hold & 0xff;
        hbuf[1] = (hold >>> 8) & 0xff;
        state.check = crc32(state.check, hbuf, 2, 0);
        //===//

        //=== INITBITS();
        hold = 0;
        bits = 0;
        //===//
        state.mode = FLAGS;
        break;
      }
      state.flags = 0;           /* expect zlib header */
      if (state.head) {
        state.head.done = false;
      }
      if (!(state.wrap & 1) ||   /* check if zlib header allowed */
        (((hold & 0xff)/*BITS(8)*/ << 8) + (hold >> 8)) % 31) {
        strm.msg = 'incorrect header check';
        state.mode = BAD;
        break;
      }
      if ((hold & 0x0f)/*BITS(4)*/ !== Z_DEFLATED) {
        strm.msg = 'unknown compression method';
        state.mode = BAD;
        break;
      }
      //--- DROPBITS(4) ---//
      hold >>>= 4;
      bits -= 4;
      //---//
      len = (hold & 0x0f)/*BITS(4)*/ + 8;
      if (state.wbits === 0) {
        state.wbits = len;
      }
      else if (len > state.wbits) {
        strm.msg = 'invalid window size';
        state.mode = BAD;
        break;
      }
      state.dmax = 1 << len;
      //Tracev((stderr, "inflate:   zlib header ok\n"));
      strm.adler = state.check = 1/*adler32(0L, Z_NULL, 0)*/;
      state.mode = hold & 0x200 ? DICTID : TYPE;
      //=== INITBITS();
      hold = 0;
      bits = 0;
      //===//
      break;
    case FLAGS:
      //=== NEEDBITS(16); */
      while (bits < 16) {
        if (have === 0) { break inf_leave; }
        have--;
        hold += input[next++] << bits;
        bits += 8;
      }
      //===//
      state.flags = hold;
      if ((state.flags & 0xff) !== Z_DEFLATED) {
        strm.msg = 'unknown compression method';
        state.mode = BAD;
        break;
      }
      if (state.flags & 0xe000) {
        strm.msg = 'unknown header flags set';
        state.mode = BAD;
        break;
      }
      if (state.head) {
        state.head.text = ((hold >> 8) & 1);
      }
      if (state.flags & 0x0200) {
        //=== CRC2(state.check, hold);
        hbuf[0] = hold & 0xff;
        hbuf[1] = (hold >>> 8) & 0xff;
        state.check = crc32(state.check, hbuf, 2, 0);
        //===//
      }
      //=== INITBITS();
      hold = 0;
      bits = 0;
      //===//
      state.mode = TIME;
      /* falls through */
    case TIME:
      //=== NEEDBITS(32); */
      while (bits < 32) {
        if (have === 0) { break inf_leave; }
        have--;
        hold += input[next++] << bits;
        bits += 8;
      }
      //===//
      if (state.head) {
        state.head.time = hold;
      }
      if (state.flags & 0x0200) {
        //=== CRC4(state.check, hold)
        hbuf[0] = hold & 0xff;
        hbuf[1] = (hold >>> 8) & 0xff;
        hbuf[2] = (hold >>> 16) & 0xff;
        hbuf[3] = (hold >>> 24) & 0xff;
        state.check = crc32(state.check, hbuf, 4, 0);
        //===
      }
      //=== INITBITS();
      hold = 0;
      bits = 0;
      //===//
      state.mode = OS;
      /* falls through */
    case OS:
      //=== NEEDBITS(16); */
      while (bits < 16) {
        if (have === 0) { break inf_leave; }
        have--;
        hold += input[next++] << bits;
        bits += 8;
      }
      //===//
      if (state.head) {
        state.head.xflags = (hold & 0xff);
        state.head.os = (hold >> 8);
      }
      if (state.flags & 0x0200) {
        //=== CRC2(state.check, hold);
        hbuf[0] = hold & 0xff;
        hbuf[1] = (hold >>> 8) & 0xff;
        state.check = crc32(state.check, hbuf, 2, 0);
        //===//
      }
      //=== INITBITS();
      hold = 0;
      bits = 0;
      //===//
      state.mode = EXLEN;
      /* falls through */
    case EXLEN:
      if (state.flags & 0x0400) {
        //=== NEEDBITS(16); */
        while (bits < 16) {
          if (have === 0) { break inf_leave; }
          have--;
          hold += input[next++] << bits;
          bits += 8;
        }
        //===//
        state.length = hold;
        if (state.head) {
          state.head.extra_len = hold;
        }
        if (state.flags & 0x0200) {
          //=== CRC2(state.check, hold);
          hbuf[0] = hold & 0xff;
          hbuf[1] = (hold >>> 8) & 0xff;
          state.check = crc32(state.check, hbuf, 2, 0);
          //===//
        }
        //=== INITBITS();
        hold = 0;
        bits = 0;
        //===//
      }
      else if (state.head) {
        state.head.extra = null/*Z_NULL*/;
      }
      state.mode = EXTRA;
      /* falls through */
    case EXTRA:
      if (state.flags & 0x0400) {
        copy = state.length;
        if (copy > have) { copy = have; }
        if (copy) {
          if (state.head) {
            len = state.head.extra_len - state.length;
            if (!state.head.extra) {
              // Use untyped array for more conveniend processing later
              state.head.extra = new Array(state.head.extra_len);
            }
            utils.arraySet(
              state.head.extra,
              input,
              next,
              // extra field is limited to 65536 bytes
              // - no need for additional size check
              copy,
              /*len + copy > state.head.extra_max - len ? state.head.extra_max : copy,*/
              len
            );
            //zmemcpy(state.head.extra + len, next,
            //        len + copy > state.head.extra_max ?
            //        state.head.extra_max - len : copy);
          }
          if (state.flags & 0x0200) {
            state.check = crc32(state.check, input, copy, next);
          }
          have -= copy;
          next += copy;
          state.length -= copy;
        }
        if (state.length) { break inf_leave; }
      }
      state.length = 0;
      state.mode = NAME;
      /* falls through */
    case NAME:
      if (state.flags & 0x0800) {
        if (have === 0) { break inf_leave; }
        copy = 0;
        do {
          // TODO: 2 or 1 bytes?
          len = input[next + copy++];
          /* use constant limit because in js we should not preallocate memory */
          if (state.head && len &&
              (state.length < 65536 /*state.head.name_max*/)) {
            state.head.name += String.fromCharCode(len);
          }
        } while (len && copy < have);

        if (state.flags & 0x0200) {
          state.check = crc32(state.check, input, copy, next);
        }
        have -= copy;
        next += copy;
        if (len) { break inf_leave; }
      }
      else if (state.head) {
        state.head.name = null;
      }
      state.length = 0;
      state.mode = COMMENT;
      /* falls through */
    case COMMENT:
      if (state.flags & 0x1000) {
        if (have === 0) { break inf_leave; }
        copy = 0;
        do {
          len = input[next + copy++];
          /* use constant limit because in js we should not preallocate memory */
          if (state.head && len &&
              (state.length < 65536 /*state.head.comm_max*/)) {
            state.head.comment += String.fromCharCode(len);
          }
        } while (len && copy < have);
        if (state.flags & 0x0200) {
          state.check = crc32(state.check, input, copy, next);
        }
        have -= copy;
        next += copy;
        if (len) { break inf_leave; }
      }
      else if (state.head) {
        state.head.comment = null;
      }
      state.mode = HCRC;
      /* falls through */
    case HCRC:
      if (state.flags & 0x0200) {
        //=== NEEDBITS(16); */
        while (bits < 16) {
          if (have === 0) { break inf_leave; }
          have--;
          hold += input[next++] << bits;
          bits += 8;
        }
        //===//
        if (hold !== (state.check & 0xffff)) {
          strm.msg = 'header crc mismatch';
          state.mode = BAD;
          break;
        }
        //=== INITBITS();
        hold = 0;
        bits = 0;
        //===//
      }
      if (state.head) {
        state.head.hcrc = ((state.flags >> 9) & 1);
        state.head.done = true;
      }
      strm.adler = state.check = 0 /*crc32(0L, Z_NULL, 0)*/;
      state.mode = TYPE;
      break;
    case DICTID:
      //=== NEEDBITS(32); */
      while (bits < 32) {
        if (have === 0) { break inf_leave; }
        have--;
        hold += input[next++] << bits;
        bits += 8;
      }
      //===//
      strm.adler = state.check = ZSWAP32(hold);
      //=== INITBITS();
      hold = 0;
      bits = 0;
      //===//
      state.mode = DICT;
      /* falls through */
    case DICT:
      if (state.havedict === 0) {
        //--- RESTORE() ---
        strm.next_out = put;
        strm.avail_out = left;
        strm.next_in = next;
        strm.avail_in = have;
        state.hold = hold;
        state.bits = bits;
        //---
        return Z_NEED_DICT;
      }
      strm.adler = state.check = 1/*adler32(0L, Z_NULL, 0)*/;
      state.mode = TYPE;
      /* falls through */
    case TYPE:
      if (flush === Z_BLOCK || flush === Z_TREES) { break inf_leave; }
      /* falls through */
    case TYPEDO:
      if (state.last) {
        //--- BYTEBITS() ---//
        hold >>>= bits & 7;
        bits -= bits & 7;
        //---//
        state.mode = CHECK;
        break;
      }
      //=== NEEDBITS(3); */
      while (bits < 3) {
        if (have === 0) { break inf_leave; }
        have--;
        hold += input[next++] << bits;
        bits += 8;
      }
      //===//
      state.last = (hold & 0x01)/*BITS(1)*/;
      //--- DROPBITS(1) ---//
      hold >>>= 1;
      bits -= 1;
      //---//

      switch ((hold & 0x03)/*BITS(2)*/) {
      case 0:                             /* stored block */
        //Tracev((stderr, "inflate:     stored block%s\n",
        //        state.last ? " (last)" : ""));
        state.mode = STORED;
        break;
      case 1:                             /* fixed block */
        fixedtables(state);
        //Tracev((stderr, "inflate:     fixed codes block%s\n",
        //        state.last ? " (last)" : ""));
        state.mode = LEN_;             /* decode codes */
        if (flush === Z_TREES) {
          //--- DROPBITS(2) ---//
          hold >>>= 2;
          bits -= 2;
          //---//
          break inf_leave;
        }
        break;
      case 2:                             /* dynamic block */
        //Tracev((stderr, "inflate:     dynamic codes block%s\n",
        //        state.last ? " (last)" : ""));
        state.mode = TABLE;
        break;
      case 3:
        strm.msg = 'invalid block type';
        state.mode = BAD;
      }
      //--- DROPBITS(2) ---//
      hold >>>= 2;
      bits -= 2;
      //---//
      break;
    case STORED:
      //--- BYTEBITS() ---// /* go to byte boundary */
      hold >>>= bits & 7;
      bits -= bits & 7;
      //---//
      //=== NEEDBITS(32); */
      while (bits < 32) {
        if (have === 0) { break inf_leave; }
        have--;
        hold += input[next++] << bits;
        bits += 8;
      }
      //===//
      if ((hold & 0xffff) !== ((hold >>> 16) ^ 0xffff)) {
        strm.msg = 'invalid stored block lengths';
        state.mode = BAD;
        break;
      }
      state.length = hold & 0xffff;
      //Tracev((stderr, "inflate:       stored length %u\n",
      //        state.length));
      //=== INITBITS();
      hold = 0;
      bits = 0;
      //===//
      state.mode = COPY_;
      if (flush === Z_TREES) { break inf_leave; }
      /* falls through */
    case COPY_:
      state.mode = COPY;
      /* falls through */
    case COPY:
      copy = state.length;
      if (copy) {
        if (copy > have) { copy = have; }
        if (copy > left) { copy = left; }
        if (copy === 0) { break inf_leave; }
        //--- zmemcpy(put, next, copy); ---
        utils.arraySet(output, input, next, copy, put);
        //---//
        have -= copy;
        next += copy;
        left -= copy;
        put += copy;
        state.length -= copy;
        break;
      }
      //Tracev((stderr, "inflate:       stored end\n"));
      state.mode = TYPE;
      break;
    case TABLE:
      //=== NEEDBITS(14); */
      while (bits < 14) {
        if (have === 0) { break inf_leave; }
        have--;
        hold += input[next++] << bits;
        bits += 8;
      }
      //===//
      state.nlen = (hold & 0x1f)/*BITS(5)*/ + 257;
      //--- DROPBITS(5) ---//
      hold >>>= 5;
      bits -= 5;
      //---//
      state.ndist = (hold & 0x1f)/*BITS(5)*/ + 1;
      //--- DROPBITS(5) ---//
      hold >>>= 5;
      bits -= 5;
      //---//
      state.ncode = (hold & 0x0f)/*BITS(4)*/ + 4;
      //--- DROPBITS(4) ---//
      hold >>>= 4;
      bits -= 4;
      //---//
//#ifndef PKZIP_BUG_WORKAROUND
      if (state.nlen > 286 || state.ndist > 30) {
        strm.msg = 'too many length or distance symbols';
        state.mode = BAD;
        break;
      }
//#endif
      //Tracev((stderr, "inflate:       table sizes ok\n"));
      state.have = 0;
      state.mode = LENLENS;
      /* falls through */
    case LENLENS:
      while (state.have < state.ncode) {
        //=== NEEDBITS(3);
        while (bits < 3) {
          if (have === 0) { break inf_leave; }
          have--;
          hold += input[next++] << bits;
          bits += 8;
        }
        //===//
        state.lens[order[state.have++]] = (hold & 0x07);//BITS(3);
        //--- DROPBITS(3) ---//
        hold >>>= 3;
        bits -= 3;
        //---//
      }
      while (state.have < 19) {
        state.lens[order[state.have++]] = 0;
      }
      // We have separate tables & no pointers. 2 commented lines below not needed.
      //state.next = state.codes;
      //state.lencode = state.next;
      // Switch to use dynamic table
      state.lencode = state.lendyn;
      state.lenbits = 7;

      opts = {bits: state.lenbits};
      ret = inflate_table(CODES, state.lens, 0, 19, state.lencode, 0, state.work, opts);
      state.lenbits = opts.bits;

      if (ret) {
        strm.msg = 'invalid code lengths set';
        state.mode = BAD;
        break;
      }
      //Tracev((stderr, "inflate:       code lengths ok\n"));
      state.have = 0;
      state.mode = CODELENS;
      /* falls through */
    case CODELENS:
      while (state.have < state.nlen + state.ndist) {
        for (;;) {
          here = state.lencode[hold & ((1 << state.lenbits) - 1)];/*BITS(state.lenbits)*/
          here_bits = here >>> 24;
          here_op = (here >>> 16) & 0xff;
          here_val = here & 0xffff;

          if ((here_bits) <= bits) { break; }
          //--- PULLBYTE() ---//
          if (have === 0) { break inf_leave; }
          have--;
          hold += input[next++] << bits;
          bits += 8;
          //---//
        }
        if (here_val < 16) {
          //--- DROPBITS(here.bits) ---//
          hold >>>= here_bits;
          bits -= here_bits;
          //---//
          state.lens[state.have++] = here_val;
        }
        else {
          if (here_val === 16) {
            //=== NEEDBITS(here.bits + 2);
            n = here_bits + 2;
            while (bits < n) {
              if (have === 0) { break inf_leave; }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            //===//
            //--- DROPBITS(here.bits) ---//
            hold >>>= here_bits;
            bits -= here_bits;
            //---//
            if (state.have === 0) {
              strm.msg = 'invalid bit length repeat';
              state.mode = BAD;
              break;
            }
            len = state.lens[state.have - 1];
            copy = 3 + (hold & 0x03);//BITS(2);
            //--- DROPBITS(2) ---//
            hold >>>= 2;
            bits -= 2;
            //---//
          }
          else if (here_val === 17) {
            //=== NEEDBITS(here.bits + 3);
            n = here_bits + 3;
            while (bits < n) {
              if (have === 0) { break inf_leave; }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            //===//
            //--- DROPBITS(here.bits) ---//
            hold >>>= here_bits;
            bits -= here_bits;
            //---//
            len = 0;
            copy = 3 + (hold & 0x07);//BITS(3);
            //--- DROPBITS(3) ---//
            hold >>>= 3;
            bits -= 3;
            //---//
          }
          else {
            //=== NEEDBITS(here.bits + 7);
            n = here_bits + 7;
            while (bits < n) {
              if (have === 0) { break inf_leave; }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            //===//
            //--- DROPBITS(here.bits) ---//
            hold >>>= here_bits;
            bits -= here_bits;
            //---//
            len = 0;
            copy = 11 + (hold & 0x7f);//BITS(7);
            //--- DROPBITS(7) ---//
            hold >>>= 7;
            bits -= 7;
            //---//
          }
          if (state.have + copy > state.nlen + state.ndist) {
            strm.msg = 'invalid bit length repeat';
            state.mode = BAD;
            break;
          }
          while (copy--) {
            state.lens[state.have++] = len;
          }
        }
      }

      /* handle error breaks in while */
      if (state.mode === BAD) { break; }

      /* check for end-of-block code (better have one) */
      if (state.lens[256] === 0) {
        strm.msg = 'invalid code -- missing end-of-block';
        state.mode = BAD;
        break;
      }

      /* build code tables -- note: do not change the lenbits or distbits
         values here (9 and 6) without reading the comments in inftrees.h
         concerning the ENOUGH constants, which depend on those values */
      state.lenbits = 9;

      opts = {bits: state.lenbits};
      ret = inflate_table(LENS, state.lens, 0, state.nlen, state.lencode, 0, state.work, opts);
      // We have separate tables & no pointers. 2 commented lines below not needed.
      // state.next_index = opts.table_index;
      state.lenbits = opts.bits;
      // state.lencode = state.next;

      if (ret) {
        strm.msg = 'invalid literal/lengths set';
        state.mode = BAD;
        break;
      }

      state.distbits = 6;
      //state.distcode.copy(state.codes);
      // Switch to use dynamic table
      state.distcode = state.distdyn;
      opts = {bits: state.distbits};
      ret = inflate_table(DISTS, state.lens, state.nlen, state.ndist, state.distcode, 0, state.work, opts);
      // We have separate tables & no pointers. 2 commented lines below not needed.
      // state.next_index = opts.table_index;
      state.distbits = opts.bits;
      // state.distcode = state.next;

      if (ret) {
        strm.msg = 'invalid distances set';
        state.mode = BAD;
        break;
      }
      //Tracev((stderr, 'inflate:       codes ok\n'));
      state.mode = LEN_;
      if (flush === Z_TREES) { break inf_leave; }
      /* falls through */
    case LEN_:
      state.mode = LEN;
      /* falls through */
    case LEN:
      if (have >= 6 && left >= 258) {
        //--- RESTORE() ---
        strm.next_out = put;
        strm.avail_out = left;
        strm.next_in = next;
        strm.avail_in = have;
        state.hold = hold;
        state.bits = bits;
        //---
        inflate_fast(strm, _out);
        //--- LOAD() ---
        put = strm.next_out;
        output = strm.output;
        left = strm.avail_out;
        next = strm.next_in;
        input = strm.input;
        have = strm.avail_in;
        hold = state.hold;
        bits = state.bits;
        //---

        if (state.mode === TYPE) {
          state.back = -1;
        }
        break;
      }
      state.back = 0;
      for (;;) {
        here = state.lencode[hold & ((1 << state.lenbits) -1)];  /*BITS(state.lenbits)*/
        here_bits = here >>> 24;
        here_op = (here >>> 16) & 0xff;
        here_val = here & 0xffff;

        if (here_bits <= bits) { break; }
        //--- PULLBYTE() ---//
        if (have === 0) { break inf_leave; }
        have--;
        hold += input[next++] << bits;
        bits += 8;
        //---//
      }
      if (here_op && (here_op & 0xf0) === 0) {
        last_bits = here_bits;
        last_op = here_op;
        last_val = here_val;
        for (;;) {
          here = state.lencode[last_val +
                  ((hold & ((1 << (last_bits + last_op)) -1))/*BITS(last.bits + last.op)*/ >> last_bits)];
          here_bits = here >>> 24;
          here_op = (here >>> 16) & 0xff;
          here_val = here & 0xffff;

          if ((last_bits + here_bits) <= bits) { break; }
          //--- PULLBYTE() ---//
          if (have === 0) { break inf_leave; }
          have--;
          hold += input[next++] << bits;
          bits += 8;
          //---//
        }
        //--- DROPBITS(last.bits) ---//
        hold >>>= last_bits;
        bits -= last_bits;
        //---//
        state.back += last_bits;
      }
      //--- DROPBITS(here.bits) ---//
      hold >>>= here_bits;
      bits -= here_bits;
      //---//
      state.back += here_bits;
      state.length = here_val;
      if (here_op === 0) {
        //Tracevv((stderr, here.val >= 0x20 && here.val < 0x7f ?
        //        "inflate:         literal '%c'\n" :
        //        "inflate:         literal 0x%02x\n", here.val));
        state.mode = LIT;
        break;
      }
      if (here_op & 32) {
        //Tracevv((stderr, "inflate:         end of block\n"));
        state.back = -1;
        state.mode = TYPE;
        break;
      }
      if (here_op & 64) {
        strm.msg = 'invalid literal/length code';
        state.mode = BAD;
        break;
      }
      state.extra = here_op & 15;
      state.mode = LENEXT;
      /* falls through */
    case LENEXT:
      if (state.extra) {
        //=== NEEDBITS(state.extra);
        n = state.extra;
        while (bits < n) {
          if (have === 0) { break inf_leave; }
          have--;
          hold += input[next++] << bits;
          bits += 8;
        }
        //===//
        state.length += hold & ((1 << state.extra) -1)/*BITS(state.extra)*/;
        //--- DROPBITS(state.extra) ---//
        hold >>>= state.extra;
        bits -= state.extra;
        //---//
        state.back += state.extra;
      }
      //Tracevv((stderr, "inflate:         length %u\n", state.length));
      state.was = state.length;
      state.mode = DIST;
      /* falls through */
    case DIST:
      for (;;) {
        here = state.distcode[hold & ((1 << state.distbits) -1)];/*BITS(state.distbits)*/
        here_bits = here >>> 24;
        here_op = (here >>> 16) & 0xff;
        here_val = here & 0xffff;

        if ((here_bits) <= bits) { break; }
        //--- PULLBYTE() ---//
        if (have === 0) { break inf_leave; }
        have--;
        hold += input[next++] << bits;
        bits += 8;
        //---//
      }
      if ((here_op & 0xf0) === 0) {
        last_bits = here_bits;
        last_op = here_op;
        last_val = here_val;
        for (;;) {
          here = state.distcode[last_val +
                  ((hold & ((1 << (last_bits + last_op)) -1))/*BITS(last.bits + last.op)*/ >> last_bits)];
          here_bits = here >>> 24;
          here_op = (here >>> 16) & 0xff;
          here_val = here & 0xffff;

          if ((last_bits + here_bits) <= bits) { break; }
          //--- PULLBYTE() ---//
          if (have === 0) { break inf_leave; }
          have--;
          hold += input[next++] << bits;
          bits += 8;
          //---//
        }
        //--- DROPBITS(last.bits) ---//
        hold >>>= last_bits;
        bits -= last_bits;
        //---//
        state.back += last_bits;
      }
      //--- DROPBITS(here.bits) ---//
      hold >>>= here_bits;
      bits -= here_bits;
      //---//
      state.back += here_bits;
      if (here_op & 64) {
        strm.msg = 'invalid distance code';
        state.mode = BAD;
        break;
      }
      state.offset = here_val;
      state.extra = (here_op) & 15;
      state.mode = DISTEXT;
      /* falls through */
    case DISTEXT:
      if (state.extra) {
        //=== NEEDBITS(state.extra);
        n = state.extra;
        while (bits < n) {
          if (have === 0) { break inf_leave; }
          have--;
          hold += input[next++] << bits;
          bits += 8;
        }
        //===//
        state.offset += hold & ((1 << state.extra) -1)/*BITS(state.extra)*/;
        //--- DROPBITS(state.extra) ---//
        hold >>>= state.extra;
        bits -= state.extra;
        //---//
        state.back += state.extra;
      }
//#ifdef INFLATE_STRICT
      if (state.offset > state.dmax) {
        strm.msg = 'invalid distance too far back';
        state.mode = BAD;
        break;
      }
//#endif
      //Tracevv((stderr, "inflate:         distance %u\n", state.offset));
      state.mode = MATCH;
      /* falls through */
    case MATCH:
      if (left === 0) { break inf_leave; }
      copy = _out - left;
      if (state.offset > copy) {         /* copy from window */
        copy = state.offset - copy;
        if (copy > state.whave) {
          if (state.sane) {
            strm.msg = 'invalid distance too far back';
            state.mode = BAD;
            break;
          }
// (!) This block is disabled in zlib defailts,
// don't enable it for binary compatibility
//#ifdef INFLATE_ALLOW_INVALID_DISTANCE_TOOFAR_ARRR
//          Trace((stderr, "inflate.c too far\n"));
//          copy -= state.whave;
//          if (copy > state.length) { copy = state.length; }
//          if (copy > left) { copy = left; }
//          left -= copy;
//          state.length -= copy;
//          do {
//            output[put++] = 0;
//          } while (--copy);
//          if (state.length === 0) { state.mode = LEN; }
//          break;
//#endif
        }
        if (copy > state.wnext) {
          copy -= state.wnext;
          from = state.wsize - copy;
        }
        else {
          from = state.wnext - copy;
        }
        if (copy > state.length) { copy = state.length; }
        from_source = state.window;
      }
      else {                              /* copy from output */
        from_source = output;
        from = put - state.offset;
        copy = state.length;
      }
      if (copy > left) { copy = left; }
      left -= copy;
      state.length -= copy;
      do {
        output[put++] = from_source[from++];
      } while (--copy);
      if (state.length === 0) { state.mode = LEN; }
      break;
    case LIT:
      if (left === 0) { break inf_leave; }
      output[put++] = state.length;
      left--;
      state.mode = LEN;
      break;
    case CHECK:
      if (state.wrap) {
        //=== NEEDBITS(32);
        while (bits < 32) {
          if (have === 0) { break inf_leave; }
          have--;
          // Use '|' insdead of '+' to make sure that result is signed
          hold |= input[next++] << bits;
          bits += 8;
        }
        //===//
        _out -= left;
        strm.total_out += _out;
        state.total += _out;
        if (_out) {
          strm.adler = state.check =
              /*UPDATE(state.check, put - _out, _out);*/
              (state.flags ? crc32(state.check, output, _out, put - _out) : adler32(state.check, output, _out, put - _out));

        }
        _out = left;
        // NB: crc32 stored as signed 32-bit int, ZSWAP32 returns signed too
        if ((state.flags ? hold : ZSWAP32(hold)) !== state.check) {
          strm.msg = 'incorrect data check';
          state.mode = BAD;
          break;
        }
        //=== INITBITS();
        hold = 0;
        bits = 0;
        //===//
        //Tracev((stderr, "inflate:   check matches trailer\n"));
      }
      state.mode = LENGTH;
      /* falls through */
    case LENGTH:
      if (state.wrap && state.flags) {
        //=== NEEDBITS(32);
        while (bits < 32) {
          if (have === 0) { break inf_leave; }
          have--;
          hold += input[next++] << bits;
          bits += 8;
        }
        //===//
        if (hold !== (state.total & 0xffffffff)) {
          strm.msg = 'incorrect length check';
          state.mode = BAD;
          break;
        }
        //=== INITBITS();
        hold = 0;
        bits = 0;
        //===//
        //Tracev((stderr, "inflate:   length matches trailer\n"));
      }
      state.mode = DONE;
      /* falls through */
    case DONE:
      ret = Z_STREAM_END;
      break inf_leave;
    case BAD:
      ret = Z_DATA_ERROR;
      break inf_leave;
    case MEM:
      return Z_MEM_ERROR;
    case SYNC:
      /* falls through */
    default:
      return Z_STREAM_ERROR;
    }
  }

  // inf_leave <- here is real place for "goto inf_leave", emulated via "break inf_leave"

  /*
     Return from inflate(), updating the total counts and the check value.
     If there was no progress during the inflate() call, return a buffer
     error.  Call updatewindow() to create and/or update the window state.
     Note: a memory error from inflate() is non-recoverable.
   */

  //--- RESTORE() ---
  strm.next_out = put;
  strm.avail_out = left;
  strm.next_in = next;
  strm.avail_in = have;
  state.hold = hold;
  state.bits = bits;
  //---

  if (state.wsize || (_out !== strm.avail_out && state.mode < BAD &&
                      (state.mode < CHECK || flush !== Z_FINISH))) {
    if (updatewindow(strm, strm.output, strm.next_out, _out - strm.avail_out)) {
      state.mode = MEM;
      return Z_MEM_ERROR;
    }
  }
  _in -= strm.avail_in;
  _out -= strm.avail_out;
  strm.total_in += _in;
  strm.total_out += _out;
  state.total += _out;
  if (state.wrap && _out) {
    strm.adler = state.check = /*UPDATE(state.check, strm.next_out - _out, _out);*/
      (state.flags ? crc32(state.check, output, _out, strm.next_out - _out) : adler32(state.check, output, _out, strm.next_out - _out));
  }
  strm.data_type = state.bits + (state.last ? 64 : 0) +
                    (state.mode === TYPE ? 128 : 0) +
                    (state.mode === LEN_ || state.mode === COPY_ ? 256 : 0);
  if (((_in === 0 && _out === 0) || flush === Z_FINISH) && ret === Z_OK) {
    ret = Z_BUF_ERROR;
  }
  return ret;
}

function inflateEnd(strm) {

  if (!strm || !strm.state /*|| strm->zfree == (free_func)0*/) {
    return Z_STREAM_ERROR;
  }

  var state = strm.state;
  if (state.window) {
    state.window = null;
  }
  strm.state = null;
  return Z_OK;
}

function inflateGetHeader(strm, head) {
  var state;

  /* check state */
  if (!strm || !strm.state) { return Z_STREAM_ERROR; }
  state = strm.state;
  if ((state.wrap & 2) === 0) { return Z_STREAM_ERROR; }

  /* save header structure */
  state.head = head;
  head.done = false;
  return Z_OK;
}


exports.inflateReset = inflateReset;
exports.inflateReset2 = inflateReset2;
exports.inflateResetKeep = inflateResetKeep;
exports.inflateInit = inflateInit;
exports.inflateInit2 = inflateInit2;
exports.inflate = inflate;
exports.inflateEnd = inflateEnd;
exports.inflateGetHeader = inflateGetHeader;
exports.inflateInfo = 'pako inflate (from Nodeca project)';

/* Not implemented
exports.inflateCopy = inflateCopy;
exports.inflateGetDictionary = inflateGetDictionary;
exports.inflateMark = inflateMark;
exports.inflatePrime = inflatePrime;
exports.inflateSetDictionary = inflateSetDictionary;
exports.inflateSync = inflateSync;
exports.inflateSyncPoint = inflateSyncPoint;
exports.inflateUndermine = inflateUndermine;
*/

},{"../utils/common":92,"./adler32":93,"./crc32":95,"./inffast":97,"./inftrees":99}],99:[function(require,module,exports){
'use strict';


var utils = require('../utils/common');

var MAXBITS = 15;
var ENOUGH_LENS = 852;
var ENOUGH_DISTS = 592;
//var ENOUGH = (ENOUGH_LENS+ENOUGH_DISTS);

var CODES = 0;
var LENS = 1;
var DISTS = 2;

var lbase = [ /* Length codes 257..285 base */
  3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31,
  35, 43, 51, 59, 67, 83, 99, 115, 131, 163, 195, 227, 258, 0, 0
];

var lext = [ /* Length codes 257..285 extra */
  16, 16, 16, 16, 16, 16, 16, 16, 17, 17, 17, 17, 18, 18, 18, 18,
  19, 19, 19, 19, 20, 20, 20, 20, 21, 21, 21, 21, 16, 72, 78
];

var dbase = [ /* Distance codes 0..29 base */
  1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193,
  257, 385, 513, 769, 1025, 1537, 2049, 3073, 4097, 6145,
  8193, 12289, 16385, 24577, 0, 0
];

var dext = [ /* Distance codes 0..29 extra */
  16, 16, 16, 16, 17, 17, 18, 18, 19, 19, 20, 20, 21, 21, 22, 22,
  23, 23, 24, 24, 25, 25, 26, 26, 27, 27,
  28, 28, 29, 29, 64, 64
];

module.exports = function inflate_table(type, lens, lens_index, codes, table, table_index, work, opts)
{
  var bits = opts.bits;
      //here = opts.here; /* table entry for duplication */

  var len = 0;               /* a code's length in bits */
  var sym = 0;               /* index of code symbols */
  var min = 0, max = 0;          /* minimum and maximum code lengths */
  var root = 0;              /* number of index bits for root table */
  var curr = 0;              /* number of index bits for current table */
  var drop = 0;              /* code bits to drop for sub-table */
  var left = 0;                   /* number of prefix codes available */
  var used = 0;              /* code entries in table used */
  var huff = 0;              /* Huffman code */
  var incr;              /* for incrementing code, index */
  var fill;              /* index for replicating entries */
  var low;               /* low bits for current root entry */
  var mask;              /* mask for low root bits */
  var next;             /* next available space in table */
  var base = null;     /* base value table to use */
  var base_index = 0;
//  var shoextra;    /* extra bits table to use */
  var end;                    /* use base and extra for symbol > end */
  var count = new utils.Buf16(MAXBITS+1); //[MAXBITS+1];    /* number of codes of each length */
  var offs = new utils.Buf16(MAXBITS+1); //[MAXBITS+1];     /* offsets in table for each length */
  var extra = null;
  var extra_index = 0;

  var here_bits, here_op, here_val;

  /*
   Process a set of code lengths to create a canonical Huffman code.  The
   code lengths are lens[0..codes-1].  Each length corresponds to the
   symbols 0..codes-1.  The Huffman code is generated by first sorting the
   symbols by length from short to long, and retaining the symbol order
   for codes with equal lengths.  Then the code starts with all zero bits
   for the first code of the shortest length, and the codes are integer
   increments for the same length, and zeros are appended as the length
   increases.  For the deflate format, these bits are stored backwards
   from their more natural integer increment ordering, and so when the
   decoding tables are built in the large loop below, the integer codes
   are incremented backwards.

   This routine assumes, but does not check, that all of the entries in
   lens[] are in the range 0..MAXBITS.  The caller must assure this.
   1..MAXBITS is interpreted as that code length.  zero means that that
   symbol does not occur in this code.

   The codes are sorted by computing a count of codes for each length,
   creating from that a table of starting indices for each length in the
   sorted table, and then entering the symbols in order in the sorted
   table.  The sorted table is work[], with that space being provided by
   the caller.

   The length counts are used for other purposes as well, i.e. finding
   the minimum and maximum length codes, determining if there are any
   codes at all, checking for a valid set of lengths, and looking ahead
   at length counts to determine sub-table sizes when building the
   decoding tables.
   */

  /* accumulate lengths for codes (assumes lens[] all in 0..MAXBITS) */
  for (len = 0; len <= MAXBITS; len++) {
    count[len] = 0;
  }
  for (sym = 0; sym < codes; sym++) {
    count[lens[lens_index + sym]]++;
  }

  /* bound code lengths, force root to be within code lengths */
  root = bits;
  for (max = MAXBITS; max >= 1; max--) {
    if (count[max] !== 0) { break; }
  }
  if (root > max) {
    root = max;
  }
  if (max === 0) {                     /* no symbols to code at all */
    //table.op[opts.table_index] = 64;  //here.op = (var char)64;    /* invalid code marker */
    //table.bits[opts.table_index] = 1;   //here.bits = (var char)1;
    //table.val[opts.table_index++] = 0;   //here.val = (var short)0;
    table[table_index++] = (1 << 24) | (64 << 16) | 0;


    //table.op[opts.table_index] = 64;
    //table.bits[opts.table_index] = 1;
    //table.val[opts.table_index++] = 0;
    table[table_index++] = (1 << 24) | (64 << 16) | 0;

    opts.bits = 1;
    return 0;     /* no symbols, but wait for decoding to report error */
  }
  for (min = 1; min < max; min++) {
    if (count[min] !== 0) { break; }
  }
  if (root < min) {
    root = min;
  }

  /* check for an over-subscribed or incomplete set of lengths */
  left = 1;
  for (len = 1; len <= MAXBITS; len++) {
    left <<= 1;
    left -= count[len];
    if (left < 0) {
      return -1;
    }        /* over-subscribed */
  }
  if (left > 0 && (type === CODES || max !== 1)) {
    return -1;                      /* incomplete set */
  }

  /* generate offsets into symbol table for each length for sorting */
  offs[1] = 0;
  for (len = 1; len < MAXBITS; len++) {
    offs[len + 1] = offs[len] + count[len];
  }

  /* sort symbols by length, by symbol order within each length */
  for (sym = 0; sym < codes; sym++) {
    if (lens[lens_index + sym] !== 0) {
      work[offs[lens[lens_index + sym]]++] = sym;
    }
  }

  /*
   Create and fill in decoding tables.  In this loop, the table being
   filled is at next and has curr index bits.  The code being used is huff
   with length len.  That code is converted to an index by dropping drop
   bits off of the bottom.  For codes where len is less than drop + curr,
   those top drop + curr - len bits are incremented through all values to
   fill the table with replicated entries.

   root is the number of index bits for the root table.  When len exceeds
   root, sub-tables are created pointed to by the root entry with an index
   of the low root bits of huff.  This is saved in low to check for when a
   new sub-table should be started.  drop is zero when the root table is
   being filled, and drop is root when sub-tables are being filled.

   When a new sub-table is needed, it is necessary to look ahead in the
   code lengths to determine what size sub-table is needed.  The length
   counts are used for this, and so count[] is decremented as codes are
   entered in the tables.

   used keeps track of how many table entries have been allocated from the
   provided *table space.  It is checked for LENS and DIST tables against
   the constants ENOUGH_LENS and ENOUGH_DISTS to guard against changes in
   the initial root table size constants.  See the comments in inftrees.h
   for more information.

   sym increments through all symbols, and the loop terminates when
   all codes of length max, i.e. all codes, have been processed.  This
   routine permits incomplete codes, so another loop after this one fills
   in the rest of the decoding tables with invalid code markers.
   */

  /* set up for code type */
  // poor man optimization - use if-else instead of switch,
  // to avoid deopts in old v8
  if (type === CODES) {
    base = extra = work;    /* dummy value--not used */
    end = 19;

  } else if (type === LENS) {
    base = lbase;
    base_index -= 257;
    extra = lext;
    extra_index -= 257;
    end = 256;

  } else {                    /* DISTS */
    base = dbase;
    extra = dext;
    end = -1;
  }

  /* initialize opts for loop */
  huff = 0;                   /* starting code */
  sym = 0;                    /* starting code symbol */
  len = min;                  /* starting code length */
  next = table_index;              /* current table to fill in */
  curr = root;                /* current table index bits */
  drop = 0;                   /* current bits to drop from code for index */
  low = -1;                   /* trigger new sub-table when len > root */
  used = 1 << root;          /* use root table entries */
  mask = used - 1;            /* mask for comparing low */

  /* check available table space */
  if ((type === LENS && used > ENOUGH_LENS) ||
    (type === DISTS && used > ENOUGH_DISTS)) {
    return 1;
  }

  var i=0;
  /* process all codes and make table entries */
  for (;;) {
    i++;
    /* create table entry */
    here_bits = len - drop;
    if (work[sym] < end) {
      here_op = 0;
      here_val = work[sym];
    }
    else if (work[sym] > end) {
      here_op = extra[extra_index + work[sym]];
      here_val = base[base_index + work[sym]];
    }
    else {
      here_op = 32 + 64;         /* end of block */
      here_val = 0;
    }

    /* replicate for those indices with low len bits equal to huff */
    incr = 1 << (len - drop);
    fill = 1 << curr;
    min = fill;                 /* save offset to next table */
    do {
      fill -= incr;
      table[next + (huff >> drop) + fill] = (here_bits << 24) | (here_op << 16) | here_val |0;
    } while (fill !== 0);

    /* backwards increment the len-bit code huff */
    incr = 1 << (len - 1);
    while (huff & incr) {
      incr >>= 1;
    }
    if (incr !== 0) {
      huff &= incr - 1;
      huff += incr;
    } else {
      huff = 0;
    }

    /* go to next symbol, update count, len */
    sym++;
    if (--count[len] === 0) {
      if (len === max) { break; }
      len = lens[lens_index + work[sym]];
    }

    /* create new sub-table if needed */
    if (len > root && (huff & mask) !== low) {
      /* if first time, transition to sub-tables */
      if (drop === 0) {
        drop = root;
      }

      /* increment past last table */
      next += min;            /* here min is 1 << curr */

      /* determine length of next table */
      curr = len - drop;
      left = 1 << curr;
      while (curr + drop < max) {
        left -= count[curr + drop];
        if (left <= 0) { break; }
        curr++;
        left <<= 1;
      }

      /* check for enough space */
      used += 1 << curr;
      if ((type === LENS && used > ENOUGH_LENS) ||
        (type === DISTS && used > ENOUGH_DISTS)) {
        return 1;
      }

      /* point entry in root table to sub-table */
      low = huff & mask;
      /*table.op[low] = curr;
      table.bits[low] = root;
      table.val[low] = next - opts.table_index;*/
      table[low] = (root << 24) | (curr << 16) | (next - table_index) |0;
    }
  }

  /* fill in remaining table entry if code is incomplete (guaranteed to have
   at most one remaining entry, since if the code is incomplete, the
   maximum code length that was allowed to get this far is one bit) */
  if (huff !== 0) {
    //table.op[next + huff] = 64;            /* invalid code marker */
    //table.bits[next + huff] = len - drop;
    //table.val[next + huff] = 0;
    table[next + huff] = ((len - drop) << 24) | (64 << 16) |0;
  }

  /* set return parameters */
  //opts.table_index += used;
  opts.bits = root;
  return 0;
};

},{"../utils/common":92}],100:[function(require,module,exports){
'use strict';

module.exports = {
  '2':    'need dictionary',     /* Z_NEED_DICT       2  */
  '1':    'stream end',          /* Z_STREAM_END      1  */
  '0':    '',                    /* Z_OK              0  */
  '-1':   'file error',          /* Z_ERRNO         (-1) */
  '-2':   'stream error',        /* Z_STREAM_ERROR  (-2) */
  '-3':   'data error',          /* Z_DATA_ERROR    (-3) */
  '-4':   'insufficient memory', /* Z_MEM_ERROR     (-4) */
  '-5':   'buffer error',        /* Z_BUF_ERROR     (-5) */
  '-6':   'incompatible version' /* Z_VERSION_ERROR (-6) */
};

},{}],101:[function(require,module,exports){
'use strict';


var utils = require('../utils/common');

/* Public constants ==========================================================*/
/* ===========================================================================*/


//var Z_FILTERED          = 1;
//var Z_HUFFMAN_ONLY      = 2;
//var Z_RLE               = 3;
var Z_FIXED               = 4;
//var Z_DEFAULT_STRATEGY  = 0;

/* Possible values of the data_type field (though see inflate()) */
var Z_BINARY              = 0;
var Z_TEXT                = 1;
//var Z_ASCII             = 1; // = Z_TEXT
var Z_UNKNOWN             = 2;

/*============================================================================*/


function zero(buf) { var len = buf.length; while (--len >= 0) { buf[len] = 0; } }

// From zutil.h

var STORED_BLOCK = 0;
var STATIC_TREES = 1;
var DYN_TREES    = 2;
/* The three kinds of block type */

var MIN_MATCH    = 3;
var MAX_MATCH    = 258;
/* The minimum and maximum match lengths */

// From deflate.h
/* ===========================================================================
 * Internal compression state.
 */

var LENGTH_CODES  = 29;
/* number of length codes, not counting the special END_BLOCK code */

var LITERALS      = 256;
/* number of literal bytes 0..255 */

var L_CODES       = LITERALS + 1 + LENGTH_CODES;
/* number of Literal or Length codes, including the END_BLOCK code */

var D_CODES       = 30;
/* number of distance codes */

var BL_CODES      = 19;
/* number of codes used to transfer the bit lengths */

var HEAP_SIZE     = 2*L_CODES + 1;
/* maximum heap size */

var MAX_BITS      = 15;
/* All codes must not exceed MAX_BITS bits */

var Buf_size      = 16;
/* size of bit buffer in bi_buf */


/* ===========================================================================
 * Constants
 */

var MAX_BL_BITS = 7;
/* Bit length codes must not exceed MAX_BL_BITS bits */

var END_BLOCK   = 256;
/* end of block literal code */

var REP_3_6     = 16;
/* repeat previous bit length 3-6 times (2 bits of repeat count) */

var REPZ_3_10   = 17;
/* repeat a zero length 3-10 times  (3 bits of repeat count) */

var REPZ_11_138 = 18;
/* repeat a zero length 11-138 times  (7 bits of repeat count) */

var extra_lbits =   /* extra bits for each length code */
  [0,0,0,0,0,0,0,0,1,1,1,1,2,2,2,2,3,3,3,3,4,4,4,4,5,5,5,5,0];

var extra_dbits =   /* extra bits for each distance code */
  [0,0,0,0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,12,12,13,13];

var extra_blbits =  /* extra bits for each bit length code */
  [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,3,7];

var bl_order =
  [16,17,18,0,8,7,9,6,10,5,11,4,12,3,13,2,14,1,15];
/* The lengths of the bit length codes are sent in order of decreasing
 * probability, to avoid transmitting the lengths for unused bit length codes.
 */

/* ===========================================================================
 * Local data. These are initialized only once.
 */

// We pre-fill arrays with 0 to avoid uninitialized gaps

var DIST_CODE_LEN = 512; /* see definition of array dist_code below */

// !!!! Use flat array insdead of structure, Freq = i*2, Len = i*2+1
var static_ltree  = new Array((L_CODES+2) * 2);
zero(static_ltree);
/* The static literal tree. Since the bit lengths are imposed, there is no
 * need for the L_CODES extra codes used during heap construction. However
 * The codes 286 and 287 are needed to build a canonical tree (see _tr_init
 * below).
 */

var static_dtree  = new Array(D_CODES * 2);
zero(static_dtree);
/* The static distance tree. (Actually a trivial tree since all codes use
 * 5 bits.)
 */

var _dist_code    = new Array(DIST_CODE_LEN);
zero(_dist_code);
/* Distance codes. The first 256 values correspond to the distances
 * 3 .. 258, the last 256 values correspond to the top 8 bits of
 * the 15 bit distances.
 */

var _length_code  = new Array(MAX_MATCH-MIN_MATCH+1);
zero(_length_code);
/* length code for each normalized match length (0 == MIN_MATCH) */

var base_length   = new Array(LENGTH_CODES);
zero(base_length);
/* First normalized length for each code (0 = MIN_MATCH) */

var base_dist     = new Array(D_CODES);
zero(base_dist);
/* First normalized distance for each code (0 = distance of 1) */


var StaticTreeDesc = function (static_tree, extra_bits, extra_base, elems, max_length) {

  this.static_tree  = static_tree;  /* static tree or NULL */
  this.extra_bits   = extra_bits;   /* extra bits for each code or NULL */
  this.extra_base   = extra_base;   /* base index for extra_bits */
  this.elems        = elems;        /* max number of elements in the tree */
  this.max_length   = max_length;   /* max bit length for the codes */

  // show if `static_tree` has data or dummy - needed for monomorphic objects
  this.has_stree    = static_tree && static_tree.length;
};


var static_l_desc;
var static_d_desc;
var static_bl_desc;


var TreeDesc = function(dyn_tree, stat_desc) {
  this.dyn_tree = dyn_tree;     /* the dynamic tree */
  this.max_code = 0;            /* largest code with non zero frequency */
  this.stat_desc = stat_desc;   /* the corresponding static tree */
};



function d_code(dist) {
  return dist < 256 ? _dist_code[dist] : _dist_code[256 + (dist >>> 7)];
}


/* ===========================================================================
 * Output a short LSB first on the stream.
 * IN assertion: there is enough room in pendingBuf.
 */
function put_short (s, w) {
//    put_byte(s, (uch)((w) & 0xff));
//    put_byte(s, (uch)((ush)(w) >> 8));
  s.pending_buf[s.pending++] = (w) & 0xff;
  s.pending_buf[s.pending++] = (w >>> 8) & 0xff;
}


/* ===========================================================================
 * Send a value on a given number of bits.
 * IN assertion: length <= 16 and value fits in length bits.
 */
function send_bits(s, value, length) {
  if (s.bi_valid > (Buf_size - length)) {
    s.bi_buf |= (value << s.bi_valid) & 0xffff;
    put_short(s, s.bi_buf);
    s.bi_buf = value >> (Buf_size - s.bi_valid);
    s.bi_valid += length - Buf_size;
  } else {
    s.bi_buf |= (value << s.bi_valid) & 0xffff;
    s.bi_valid += length;
  }
}


function send_code(s, c, tree) {
  send_bits(s, tree[c*2]/*.Code*/, tree[c*2 + 1]/*.Len*/);
}


/* ===========================================================================
 * Reverse the first len bits of a code, using straightforward code (a faster
 * method would use a table)
 * IN assertion: 1 <= len <= 15
 */
function bi_reverse(code, len) {
  var res = 0;
  do {
    res |= code & 1;
    code >>>= 1;
    res <<= 1;
  } while (--len > 0);
  return res >>> 1;
}


/* ===========================================================================
 * Flush the bit buffer, keeping at most 7 bits in it.
 */
function bi_flush(s) {
  if (s.bi_valid === 16) {
    put_short(s, s.bi_buf);
    s.bi_buf = 0;
    s.bi_valid = 0;

  } else if (s.bi_valid >= 8) {
    s.pending_buf[s.pending++] = s.bi_buf & 0xff;
    s.bi_buf >>= 8;
    s.bi_valid -= 8;
  }
}


/* ===========================================================================
 * Compute the optimal bit lengths for a tree and update the total bit length
 * for the current block.
 * IN assertion: the fields freq and dad are set, heap[heap_max] and
 *    above are the tree nodes sorted by increasing frequency.
 * OUT assertions: the field len is set to the optimal bit length, the
 *     array bl_count contains the frequencies for each bit length.
 *     The length opt_len is updated; static_len is also updated if stree is
 *     not null.
 */
function gen_bitlen(s, desc)
//    deflate_state *s;
//    tree_desc *desc;    /* the tree descriptor */
{
  var tree            = desc.dyn_tree;
  var max_code        = desc.max_code;
  var stree           = desc.stat_desc.static_tree;
  var has_stree       = desc.stat_desc.has_stree;
  var extra           = desc.stat_desc.extra_bits;
  var base            = desc.stat_desc.extra_base;
  var max_length      = desc.stat_desc.max_length;
  var h;              /* heap index */
  var n, m;           /* iterate over the tree elements */
  var bits;           /* bit length */
  var xbits;          /* extra bits */
  var f;              /* frequency */
  var overflow = 0;   /* number of elements with bit length too large */

  for (bits = 0; bits <= MAX_BITS; bits++) {
    s.bl_count[bits] = 0;
  }

  /* In a first pass, compute the optimal bit lengths (which may
   * overflow in the case of the bit length tree).
   */
  tree[s.heap[s.heap_max]*2 + 1]/*.Len*/ = 0; /* root of the heap */

  for (h = s.heap_max+1; h < HEAP_SIZE; h++) {
    n = s.heap[h];
    bits = tree[tree[n*2 +1]/*.Dad*/ * 2 + 1]/*.Len*/ + 1;
    if (bits > max_length) {
      bits = max_length;
      overflow++;
    }
    tree[n*2 + 1]/*.Len*/ = bits;
    /* We overwrite tree[n].Dad which is no longer needed */

    if (n > max_code) { continue; } /* not a leaf node */

    s.bl_count[bits]++;
    xbits = 0;
    if (n >= base) {
      xbits = extra[n-base];
    }
    f = tree[n * 2]/*.Freq*/;
    s.opt_len += f * (bits + xbits);
    if (has_stree) {
      s.static_len += f * (stree[n*2 + 1]/*.Len*/ + xbits);
    }
  }
  if (overflow === 0) { return; }

  // Trace((stderr,"\nbit length overflow\n"));
  /* This happens for example on obj2 and pic of the Calgary corpus */

  /* Find the first bit length which could increase: */
  do {
    bits = max_length-1;
    while (s.bl_count[bits] === 0) { bits--; }
    s.bl_count[bits]--;      /* move one leaf down the tree */
    s.bl_count[bits+1] += 2; /* move one overflow item as its brother */
    s.bl_count[max_length]--;
    /* The brother of the overflow item also moves one step up,
     * but this does not affect bl_count[max_length]
     */
    overflow -= 2;
  } while (overflow > 0);

  /* Now recompute all bit lengths, scanning in increasing frequency.
   * h is still equal to HEAP_SIZE. (It is simpler to reconstruct all
   * lengths instead of fixing only the wrong ones. This idea is taken
   * from 'ar' written by Haruhiko Okumura.)
   */
  for (bits = max_length; bits !== 0; bits--) {
    n = s.bl_count[bits];
    while (n !== 0) {
      m = s.heap[--h];
      if (m > max_code) { continue; }
      if (tree[m*2 + 1]/*.Len*/ !== bits) {
        // Trace((stderr,"code %d bits %d->%d\n", m, tree[m].Len, bits));
        s.opt_len += (bits - tree[m*2 + 1]/*.Len*/)*tree[m*2]/*.Freq*/;
        tree[m*2 + 1]/*.Len*/ = bits;
      }
      n--;
    }
  }
}


/* ===========================================================================
 * Generate the codes for a given tree and bit counts (which need not be
 * optimal).
 * IN assertion: the array bl_count contains the bit length statistics for
 * the given tree and the field len is set for all tree elements.
 * OUT assertion: the field code is set for all tree elements of non
 *     zero code length.
 */
function gen_codes(tree, max_code, bl_count)
//    ct_data *tree;             /* the tree to decorate */
//    int max_code;              /* largest code with non zero frequency */
//    ushf *bl_count;            /* number of codes at each bit length */
{
  var next_code = new Array(MAX_BITS+1); /* next code value for each bit length */
  var code = 0;              /* running code value */
  var bits;                  /* bit index */
  var n;                     /* code index */

  /* The distribution counts are first used to generate the code values
   * without bit reversal.
   */
  for (bits = 1; bits <= MAX_BITS; bits++) {
    next_code[bits] = code = (code + bl_count[bits-1]) << 1;
  }
  /* Check that the bit counts in bl_count are consistent. The last code
   * must be all ones.
   */
  //Assert (code + bl_count[MAX_BITS]-1 == (1<<MAX_BITS)-1,
  //        "inconsistent bit counts");
  //Tracev((stderr,"\ngen_codes: max_code %d ", max_code));

  for (n = 0;  n <= max_code; n++) {
    var len = tree[n*2 + 1]/*.Len*/;
    if (len === 0) { continue; }
    /* Now reverse the bits */
    tree[n*2]/*.Code*/ = bi_reverse(next_code[len]++, len);

    //Tracecv(tree != static_ltree, (stderr,"\nn %3d %c l %2d c %4x (%x) ",
    //     n, (isgraph(n) ? n : ' '), len, tree[n].Code, next_code[len]-1));
  }
}


/* ===========================================================================
 * Initialize the various 'constant' tables.
 */
function tr_static_init() {
  var n;        /* iterates over tree elements */
  var bits;     /* bit counter */
  var length;   /* length value */
  var code;     /* code value */
  var dist;     /* distance index */
  var bl_count = new Array(MAX_BITS+1);
  /* number of codes at each bit length for an optimal tree */

  // do check in _tr_init()
  //if (static_init_done) return;

  /* For some embedded targets, global variables are not initialized: */
/*#ifdef NO_INIT_GLOBAL_POINTERS
  static_l_desc.static_tree = static_ltree;
  static_l_desc.extra_bits = extra_lbits;
  static_d_desc.static_tree = static_dtree;
  static_d_desc.extra_bits = extra_dbits;
  static_bl_desc.extra_bits = extra_blbits;
#endif*/

  /* Initialize the mapping length (0..255) -> length code (0..28) */
  length = 0;
  for (code = 0; code < LENGTH_CODES-1; code++) {
    base_length[code] = length;
    for (n = 0; n < (1<<extra_lbits[code]); n++) {
      _length_code[length++] = code;
    }
  }
  //Assert (length == 256, "tr_static_init: length != 256");
  /* Note that the length 255 (match length 258) can be represented
   * in two different ways: code 284 + 5 bits or code 285, so we
   * overwrite length_code[255] to use the best encoding:
   */
  _length_code[length-1] = code;

  /* Initialize the mapping dist (0..32K) -> dist code (0..29) */
  dist = 0;
  for (code = 0 ; code < 16; code++) {
    base_dist[code] = dist;
    for (n = 0; n < (1<<extra_dbits[code]); n++) {
      _dist_code[dist++] = code;
    }
  }
  //Assert (dist == 256, "tr_static_init: dist != 256");
  dist >>= 7; /* from now on, all distances are divided by 128 */
  for (; code < D_CODES; code++) {
    base_dist[code] = dist << 7;
    for (n = 0; n < (1<<(extra_dbits[code]-7)); n++) {
      _dist_code[256 + dist++] = code;
    }
  }
  //Assert (dist == 256, "tr_static_init: 256+dist != 512");

  /* Construct the codes of the static literal tree */
  for (bits = 0; bits <= MAX_BITS; bits++) {
    bl_count[bits] = 0;
  }

  n = 0;
  while (n <= 143) {
    static_ltree[n*2 + 1]/*.Len*/ = 8;
    n++;
    bl_count[8]++;
  }
  while (n <= 255) {
    static_ltree[n*2 + 1]/*.Len*/ = 9;
    n++;
    bl_count[9]++;
  }
  while (n <= 279) {
    static_ltree[n*2 + 1]/*.Len*/ = 7;
    n++;
    bl_count[7]++;
  }
  while (n <= 287) {
    static_ltree[n*2 + 1]/*.Len*/ = 8;
    n++;
    bl_count[8]++;
  }
  /* Codes 286 and 287 do not exist, but we must include them in the
   * tree construction to get a canonical Huffman tree (longest code
   * all ones)
   */
  gen_codes(static_ltree, L_CODES+1, bl_count);

  /* The static distance tree is trivial: */
  for (n = 0; n < D_CODES; n++) {
    static_dtree[n*2 + 1]/*.Len*/ = 5;
    static_dtree[n*2]/*.Code*/ = bi_reverse(n, 5);
  }

  // Now data ready and we can init static trees
  static_l_desc = new StaticTreeDesc(static_ltree, extra_lbits, LITERALS+1, L_CODES, MAX_BITS);
  static_d_desc = new StaticTreeDesc(static_dtree, extra_dbits, 0,          D_CODES, MAX_BITS);
  static_bl_desc =new StaticTreeDesc(new Array(0), extra_blbits, 0,         BL_CODES, MAX_BL_BITS);

  //static_init_done = true;
}


/* ===========================================================================
 * Initialize a new block.
 */
function init_block(s) {
  var n; /* iterates over tree elements */

  /* Initialize the trees. */
  for (n = 0; n < L_CODES;  n++) { s.dyn_ltree[n*2]/*.Freq*/ = 0; }
  for (n = 0; n < D_CODES;  n++) { s.dyn_dtree[n*2]/*.Freq*/ = 0; }
  for (n = 0; n < BL_CODES; n++) { s.bl_tree[n*2]/*.Freq*/ = 0; }

  s.dyn_ltree[END_BLOCK*2]/*.Freq*/ = 1;
  s.opt_len = s.static_len = 0;
  s.last_lit = s.matches = 0;
}


/* ===========================================================================
 * Flush the bit buffer and align the output on a byte boundary
 */
function bi_windup(s)
{
  if (s.bi_valid > 8) {
    put_short(s, s.bi_buf);
  } else if (s.bi_valid > 0) {
    //put_byte(s, (Byte)s->bi_buf);
    s.pending_buf[s.pending++] = s.bi_buf;
  }
  s.bi_buf = 0;
  s.bi_valid = 0;
}

/* ===========================================================================
 * Copy a stored block, storing first the length and its
 * one's complement if requested.
 */
function copy_block(s, buf, len, header)
//DeflateState *s;
//charf    *buf;    /* the input data */
//unsigned len;     /* its length */
//int      header;  /* true if block header must be written */
{
  bi_windup(s);        /* align on byte boundary */

  if (header) {
    put_short(s, len);
    put_short(s, ~len);
  }
//  while (len--) {
//    put_byte(s, *buf++);
//  }
  utils.arraySet(s.pending_buf, s.window, buf, len, s.pending);
  s.pending += len;
}

/* ===========================================================================
 * Compares to subtrees, using the tree depth as tie breaker when
 * the subtrees have equal frequency. This minimizes the worst case length.
 */
function smaller(tree, n, m, depth) {
  var _n2 = n*2;
  var _m2 = m*2;
  return (tree[_n2]/*.Freq*/ < tree[_m2]/*.Freq*/ ||
         (tree[_n2]/*.Freq*/ === tree[_m2]/*.Freq*/ && depth[n] <= depth[m]));
}

/* ===========================================================================
 * Restore the heap property by moving down the tree starting at node k,
 * exchanging a node with the smallest of its two sons if necessary, stopping
 * when the heap property is re-established (each father smaller than its
 * two sons).
 */
function pqdownheap(s, tree, k)
//    deflate_state *s;
//    ct_data *tree;  /* the tree to restore */
//    int k;               /* node to move down */
{
  var v = s.heap[k];
  var j = k << 1;  /* left son of k */
  while (j <= s.heap_len) {
    /* Set j to the smallest of the two sons: */
    if (j < s.heap_len &&
      smaller(tree, s.heap[j+1], s.heap[j], s.depth)) {
      j++;
    }
    /* Exit if v is smaller than both sons */
    if (smaller(tree, v, s.heap[j], s.depth)) { break; }

    /* Exchange v with the smallest son */
    s.heap[k] = s.heap[j];
    k = j;

    /* And continue down the tree, setting j to the left son of k */
    j <<= 1;
  }
  s.heap[k] = v;
}


// inlined manually
// var SMALLEST = 1;

/* ===========================================================================
 * Send the block data compressed using the given Huffman trees
 */
function compress_block(s, ltree, dtree)
//    deflate_state *s;
//    const ct_data *ltree; /* literal tree */
//    const ct_data *dtree; /* distance tree */
{
  var dist;           /* distance of matched string */
  var lc;             /* match length or unmatched char (if dist == 0) */
  var lx = 0;         /* running index in l_buf */
  var code;           /* the code to send */
  var extra;          /* number of extra bits to send */

  if (s.last_lit !== 0) {
    do {
      dist = (s.pending_buf[s.d_buf + lx*2] << 8) | (s.pending_buf[s.d_buf + lx*2 + 1]);
      lc = s.pending_buf[s.l_buf + lx];
      lx++;

      if (dist === 0) {
        send_code(s, lc, ltree); /* send a literal byte */
        //Tracecv(isgraph(lc), (stderr," '%c' ", lc));
      } else {
        /* Here, lc is the match length - MIN_MATCH */
        code = _length_code[lc];
        send_code(s, code+LITERALS+1, ltree); /* send the length code */
        extra = extra_lbits[code];
        if (extra !== 0) {
          lc -= base_length[code];
          send_bits(s, lc, extra);       /* send the extra length bits */
        }
        dist--; /* dist is now the match distance - 1 */
        code = d_code(dist);
        //Assert (code < D_CODES, "bad d_code");

        send_code(s, code, dtree);       /* send the distance code */
        extra = extra_dbits[code];
        if (extra !== 0) {
          dist -= base_dist[code];
          send_bits(s, dist, extra);   /* send the extra distance bits */
        }
      } /* literal or match pair ? */

      /* Check that the overlay between pending_buf and d_buf+l_buf is ok: */
      //Assert((uInt)(s->pending) < s->lit_bufsize + 2*lx,
      //       "pendingBuf overflow");

    } while (lx < s.last_lit);
  }

  send_code(s, END_BLOCK, ltree);
}


/* ===========================================================================
 * Construct one Huffman tree and assigns the code bit strings and lengths.
 * Update the total bit length for the current block.
 * IN assertion: the field freq is set for all tree elements.
 * OUT assertions: the fields len and code are set to the optimal bit length
 *     and corresponding code. The length opt_len is updated; static_len is
 *     also updated if stree is not null. The field max_code is set.
 */
function build_tree(s, desc)
//    deflate_state *s;
//    tree_desc *desc; /* the tree descriptor */
{
  var tree     = desc.dyn_tree;
  var stree    = desc.stat_desc.static_tree;
  var has_stree = desc.stat_desc.has_stree;
  var elems    = desc.stat_desc.elems;
  var n, m;          /* iterate over heap elements */
  var max_code = -1; /* largest code with non zero frequency */
  var node;          /* new node being created */

  /* Construct the initial heap, with least frequent element in
   * heap[SMALLEST]. The sons of heap[n] are heap[2*n] and heap[2*n+1].
   * heap[0] is not used.
   */
  s.heap_len = 0;
  s.heap_max = HEAP_SIZE;

  for (n = 0; n < elems; n++) {
    if (tree[n * 2]/*.Freq*/ !== 0) {
      s.heap[++s.heap_len] = max_code = n;
      s.depth[n] = 0;

    } else {
      tree[n*2 + 1]/*.Len*/ = 0;
    }
  }

  /* The pkzip format requires that at least one distance code exists,
   * and that at least one bit should be sent even if there is only one
   * possible code. So to avoid special checks later on we force at least
   * two codes of non zero frequency.
   */
  while (s.heap_len < 2) {
    node = s.heap[++s.heap_len] = (max_code < 2 ? ++max_code : 0);
    tree[node * 2]/*.Freq*/ = 1;
    s.depth[node] = 0;
    s.opt_len--;

    if (has_stree) {
      s.static_len -= stree[node*2 + 1]/*.Len*/;
    }
    /* node is 0 or 1 so it does not have extra bits */
  }
  desc.max_code = max_code;

  /* The elements heap[heap_len/2+1 .. heap_len] are leaves of the tree,
   * establish sub-heaps of increasing lengths:
   */
  for (n = (s.heap_len >> 1/*int /2*/); n >= 1; n--) { pqdownheap(s, tree, n); }

  /* Construct the Huffman tree by repeatedly combining the least two
   * frequent nodes.
   */
  node = elems;              /* next internal node of the tree */
  do {
    //pqremove(s, tree, n);  /* n = node of least frequency */
    /*** pqremove ***/
    n = s.heap[1/*SMALLEST*/];
    s.heap[1/*SMALLEST*/] = s.heap[s.heap_len--];
    pqdownheap(s, tree, 1/*SMALLEST*/);
    /***/

    m = s.heap[1/*SMALLEST*/]; /* m = node of next least frequency */

    s.heap[--s.heap_max] = n; /* keep the nodes sorted by frequency */
    s.heap[--s.heap_max] = m;

    /* Create a new node father of n and m */
    tree[node * 2]/*.Freq*/ = tree[n * 2]/*.Freq*/ + tree[m * 2]/*.Freq*/;
    s.depth[node] = (s.depth[n] >= s.depth[m] ? s.depth[n] : s.depth[m]) + 1;
    tree[n*2 + 1]/*.Dad*/ = tree[m*2 + 1]/*.Dad*/ = node;

    /* and insert the new node in the heap */
    s.heap[1/*SMALLEST*/] = node++;
    pqdownheap(s, tree, 1/*SMALLEST*/);

  } while (s.heap_len >= 2);

  s.heap[--s.heap_max] = s.heap[1/*SMALLEST*/];

  /* At this point, the fields freq and dad are set. We can now
   * generate the bit lengths.
   */
  gen_bitlen(s, desc);

  /* The field len is now set, we can generate the bit codes */
  gen_codes(tree, max_code, s.bl_count);
}


/* ===========================================================================
 * Scan a literal or distance tree to determine the frequencies of the codes
 * in the bit length tree.
 */
function scan_tree(s, tree, max_code)
//    deflate_state *s;
//    ct_data *tree;   /* the tree to be scanned */
//    int max_code;    /* and its largest code of non zero frequency */
{
  var n;                     /* iterates over all tree elements */
  var prevlen = -1;          /* last emitted length */
  var curlen;                /* length of current code */

  var nextlen = tree[0*2 + 1]/*.Len*/; /* length of next code */

  var count = 0;             /* repeat count of the current code */
  var max_count = 7;         /* max repeat count */
  var min_count = 4;         /* min repeat count */

  if (nextlen === 0) {
    max_count = 138;
    min_count = 3;
  }
  tree[(max_code+1)*2 + 1]/*.Len*/ = 0xffff; /* guard */

  for (n = 0; n <= max_code; n++) {
    curlen = nextlen;
    nextlen = tree[(n+1)*2 + 1]/*.Len*/;

    if (++count < max_count && curlen === nextlen) {
      continue;

    } else if (count < min_count) {
      s.bl_tree[curlen * 2]/*.Freq*/ += count;

    } else if (curlen !== 0) {

      if (curlen !== prevlen) { s.bl_tree[curlen * 2]/*.Freq*/++; }
      s.bl_tree[REP_3_6*2]/*.Freq*/++;

    } else if (count <= 10) {
      s.bl_tree[REPZ_3_10*2]/*.Freq*/++;

    } else {
      s.bl_tree[REPZ_11_138*2]/*.Freq*/++;
    }

    count = 0;
    prevlen = curlen;

    if (nextlen === 0) {
      max_count = 138;
      min_count = 3;

    } else if (curlen === nextlen) {
      max_count = 6;
      min_count = 3;

    } else {
      max_count = 7;
      min_count = 4;
    }
  }
}


/* ===========================================================================
 * Send a literal or distance tree in compressed form, using the codes in
 * bl_tree.
 */
function send_tree(s, tree, max_code)
//    deflate_state *s;
//    ct_data *tree; /* the tree to be scanned */
//    int max_code;       /* and its largest code of non zero frequency */
{
  var n;                     /* iterates over all tree elements */
  var prevlen = -1;          /* last emitted length */
  var curlen;                /* length of current code */

  var nextlen = tree[0*2 + 1]/*.Len*/; /* length of next code */

  var count = 0;             /* repeat count of the current code */
  var max_count = 7;         /* max repeat count */
  var min_count = 4;         /* min repeat count */

  /* tree[max_code+1].Len = -1; */  /* guard already set */
  if (nextlen === 0) {
    max_count = 138;
    min_count = 3;
  }

  for (n = 0; n <= max_code; n++) {
    curlen = nextlen;
    nextlen = tree[(n+1)*2 + 1]/*.Len*/;

    if (++count < max_count && curlen === nextlen) {
      continue;

    } else if (count < min_count) {
      do { send_code(s, curlen, s.bl_tree); } while (--count !== 0);

    } else if (curlen !== 0) {
      if (curlen !== prevlen) {
        send_code(s, curlen, s.bl_tree);
        count--;
      }
      //Assert(count >= 3 && count <= 6, " 3_6?");
      send_code(s, REP_3_6, s.bl_tree);
      send_bits(s, count-3, 2);

    } else if (count <= 10) {
      send_code(s, REPZ_3_10, s.bl_tree);
      send_bits(s, count-3, 3);

    } else {
      send_code(s, REPZ_11_138, s.bl_tree);
      send_bits(s, count-11, 7);
    }

    count = 0;
    prevlen = curlen;
    if (nextlen === 0) {
      max_count = 138;
      min_count = 3;

    } else if (curlen === nextlen) {
      max_count = 6;
      min_count = 3;

    } else {
      max_count = 7;
      min_count = 4;
    }
  }
}


/* ===========================================================================
 * Construct the Huffman tree for the bit lengths and return the index in
 * bl_order of the last bit length code to send.
 */
function build_bl_tree(s) {
  var max_blindex;  /* index of last bit length code of non zero freq */

  /* Determine the bit length frequencies for literal and distance trees */
  scan_tree(s, s.dyn_ltree, s.l_desc.max_code);
  scan_tree(s, s.dyn_dtree, s.d_desc.max_code);

  /* Build the bit length tree: */
  build_tree(s, s.bl_desc);
  /* opt_len now includes the length of the tree representations, except
   * the lengths of the bit lengths codes and the 5+5+4 bits for the counts.
   */

  /* Determine the number of bit length codes to send. The pkzip format
   * requires that at least 4 bit length codes be sent. (appnote.txt says
   * 3 but the actual value used is 4.)
   */
  for (max_blindex = BL_CODES-1; max_blindex >= 3; max_blindex--) {
    if (s.bl_tree[bl_order[max_blindex]*2 + 1]/*.Len*/ !== 0) {
      break;
    }
  }
  /* Update opt_len to include the bit length tree and counts */
  s.opt_len += 3*(max_blindex+1) + 5+5+4;
  //Tracev((stderr, "\ndyn trees: dyn %ld, stat %ld",
  //        s->opt_len, s->static_len));

  return max_blindex;
}


/* ===========================================================================
 * Send the header for a block using dynamic Huffman trees: the counts, the
 * lengths of the bit length codes, the literal tree and the distance tree.
 * IN assertion: lcodes >= 257, dcodes >= 1, blcodes >= 4.
 */
function send_all_trees(s, lcodes, dcodes, blcodes)
//    deflate_state *s;
//    int lcodes, dcodes, blcodes; /* number of codes for each tree */
{
  var rank;                    /* index in bl_order */

  //Assert (lcodes >= 257 && dcodes >= 1 && blcodes >= 4, "not enough codes");
  //Assert (lcodes <= L_CODES && dcodes <= D_CODES && blcodes <= BL_CODES,
  //        "too many codes");
  //Tracev((stderr, "\nbl counts: "));
  send_bits(s, lcodes-257, 5); /* not +255 as stated in appnote.txt */
  send_bits(s, dcodes-1,   5);
  send_bits(s, blcodes-4,  4); /* not -3 as stated in appnote.txt */
  for (rank = 0; rank < blcodes; rank++) {
    //Tracev((stderr, "\nbl code %2d ", bl_order[rank]));
    send_bits(s, s.bl_tree[bl_order[rank]*2 + 1]/*.Len*/, 3);
  }
  //Tracev((stderr, "\nbl tree: sent %ld", s->bits_sent));

  send_tree(s, s.dyn_ltree, lcodes-1); /* literal tree */
  //Tracev((stderr, "\nlit tree: sent %ld", s->bits_sent));

  send_tree(s, s.dyn_dtree, dcodes-1); /* distance tree */
  //Tracev((stderr, "\ndist tree: sent %ld", s->bits_sent));
}


/* ===========================================================================
 * Check if the data type is TEXT or BINARY, using the following algorithm:
 * - TEXT if the two conditions below are satisfied:
 *    a) There are no non-portable control characters belonging to the
 *       "black list" (0..6, 14..25, 28..31).
 *    b) There is at least one printable character belonging to the
 *       "white list" (9 {TAB}, 10 {LF}, 13 {CR}, 32..255).
 * - BINARY otherwise.
 * - The following partially-portable control characters form a
 *   "gray list" that is ignored in this detection algorithm:
 *   (7 {BEL}, 8 {BS}, 11 {VT}, 12 {FF}, 26 {SUB}, 27 {ESC}).
 * IN assertion: the fields Freq of dyn_ltree are set.
 */
function detect_data_type(s) {
  /* black_mask is the bit mask of black-listed bytes
   * set bits 0..6, 14..25, and 28..31
   * 0xf3ffc07f = binary 11110011111111111100000001111111
   */
  var black_mask = 0xf3ffc07f;
  var n;

  /* Check for non-textual ("black-listed") bytes. */
  for (n = 0; n <= 31; n++, black_mask >>>= 1) {
    if ((black_mask & 1) && (s.dyn_ltree[n*2]/*.Freq*/ !== 0)) {
      return Z_BINARY;
    }
  }

  /* Check for textual ("white-listed") bytes. */
  if (s.dyn_ltree[9 * 2]/*.Freq*/ !== 0 || s.dyn_ltree[10 * 2]/*.Freq*/ !== 0 ||
      s.dyn_ltree[13 * 2]/*.Freq*/ !== 0) {
    return Z_TEXT;
  }
  for (n = 32; n < LITERALS; n++) {
    if (s.dyn_ltree[n * 2]/*.Freq*/ !== 0) {
      return Z_TEXT;
    }
  }

  /* There are no "black-listed" or "white-listed" bytes:
   * this stream either is empty or has tolerated ("gray-listed") bytes only.
   */
  return Z_BINARY;
}


var static_init_done = false;

/* ===========================================================================
 * Initialize the tree data structures for a new zlib stream.
 */
function _tr_init(s)
{

  if (!static_init_done) {
    tr_static_init();
    static_init_done = true;
  }

  s.l_desc  = new TreeDesc(s.dyn_ltree, static_l_desc);
  s.d_desc  = new TreeDesc(s.dyn_dtree, static_d_desc);
  s.bl_desc = new TreeDesc(s.bl_tree, static_bl_desc);

  s.bi_buf = 0;
  s.bi_valid = 0;

  /* Initialize the first block of the first file: */
  init_block(s);
}


/* ===========================================================================
 * Send a stored block
 */
function _tr_stored_block(s, buf, stored_len, last)
//DeflateState *s;
//charf *buf;       /* input block */
//ulg stored_len;   /* length of input block */
//int last;         /* one if this is the last block for a file */
{
  send_bits(s, (STORED_BLOCK<<1)+(last ? 1 : 0), 3);    /* send block type */
  copy_block(s, buf, stored_len, true); /* with header */
}


/* ===========================================================================
 * Send one empty static block to give enough lookahead for inflate.
 * This takes 10 bits, of which 7 may remain in the bit buffer.
 */
function _tr_align(s) {
  send_bits(s, STATIC_TREES<<1, 3);
  send_code(s, END_BLOCK, static_ltree);
  bi_flush(s);
}


/* ===========================================================================
 * Determine the best encoding for the current block: dynamic trees, static
 * trees or store, and output the encoded block to the zip file.
 */
function _tr_flush_block(s, buf, stored_len, last)
//DeflateState *s;
//charf *buf;       /* input block, or NULL if too old */
//ulg stored_len;   /* length of input block */
//int last;         /* one if this is the last block for a file */
{
  var opt_lenb, static_lenb;  /* opt_len and static_len in bytes */
  var max_blindex = 0;        /* index of last bit length code of non zero freq */

  /* Build the Huffman trees unless a stored block is forced */
  if (s.level > 0) {

    /* Check if the file is binary or text */
    if (s.strm.data_type === Z_UNKNOWN) {
      s.strm.data_type = detect_data_type(s);
    }

    /* Construct the literal and distance trees */
    build_tree(s, s.l_desc);
    // Tracev((stderr, "\nlit data: dyn %ld, stat %ld", s->opt_len,
    //        s->static_len));

    build_tree(s, s.d_desc);
    // Tracev((stderr, "\ndist data: dyn %ld, stat %ld", s->opt_len,
    //        s->static_len));
    /* At this point, opt_len and static_len are the total bit lengths of
     * the compressed block data, excluding the tree representations.
     */

    /* Build the bit length tree for the above two trees, and get the index
     * in bl_order of the last bit length code to send.
     */
    max_blindex = build_bl_tree(s);

    /* Determine the best encoding. Compute the block lengths in bytes. */
    opt_lenb = (s.opt_len+3+7) >>> 3;
    static_lenb = (s.static_len+3+7) >>> 3;

    // Tracev((stderr, "\nopt %lu(%lu) stat %lu(%lu) stored %lu lit %u ",
    //        opt_lenb, s->opt_len, static_lenb, s->static_len, stored_len,
    //        s->last_lit));

    if (static_lenb <= opt_lenb) { opt_lenb = static_lenb; }

  } else {
    // Assert(buf != (char*)0, "lost buf");
    opt_lenb = static_lenb = stored_len + 5; /* force a stored block */
  }

  if ((stored_len+4 <= opt_lenb) && (buf !== -1)) {
    /* 4: two words for the lengths */

    /* The test buf != NULL is only necessary if LIT_BUFSIZE > WSIZE.
     * Otherwise we can't have processed more than WSIZE input bytes since
     * the last block flush, because compression would have been
     * successful. If LIT_BUFSIZE <= WSIZE, it is never too late to
     * transform a block into a stored block.
     */
    _tr_stored_block(s, buf, stored_len, last);

  } else if (s.strategy === Z_FIXED || static_lenb === opt_lenb) {

    send_bits(s, (STATIC_TREES<<1) + (last ? 1 : 0), 3);
    compress_block(s, static_ltree, static_dtree);

  } else {
    send_bits(s, (DYN_TREES<<1) + (last ? 1 : 0), 3);
    send_all_trees(s, s.l_desc.max_code+1, s.d_desc.max_code+1, max_blindex+1);
    compress_block(s, s.dyn_ltree, s.dyn_dtree);
  }
  // Assert (s->compressed_len == s->bits_sent, "bad compressed size");
  /* The above check is made mod 2^32, for files larger than 512 MB
   * and uLong implemented on 32 bits.
   */
  init_block(s);

  if (last) {
    bi_windup(s);
  }
  // Tracev((stderr,"\ncomprlen %lu(%lu) ", s->compressed_len>>3,
  //       s->compressed_len-7*last));
}

/* ===========================================================================
 * Save the match info and tally the frequency counts. Return true if
 * the current block must be flushed.
 */
function _tr_tally(s, dist, lc)
//    deflate_state *s;
//    unsigned dist;  /* distance of matched string */
//    unsigned lc;    /* match length-MIN_MATCH or unmatched char (if dist==0) */
{
  //var out_length, in_length, dcode;

  s.pending_buf[s.d_buf + s.last_lit * 2]     = (dist >>> 8) & 0xff;
  s.pending_buf[s.d_buf + s.last_lit * 2 + 1] = dist & 0xff;

  s.pending_buf[s.l_buf + s.last_lit] = lc & 0xff;
  s.last_lit++;

  if (dist === 0) {
    /* lc is the unmatched char */
    s.dyn_ltree[lc*2]/*.Freq*/++;
  } else {
    s.matches++;
    /* Here, lc is the match length - MIN_MATCH */
    dist--;             /* dist = match distance - 1 */
    //Assert((ush)dist < (ush)MAX_DIST(s) &&
    //       (ush)lc <= (ush)(MAX_MATCH-MIN_MATCH) &&
    //       (ush)d_code(dist) < (ush)D_CODES,  "_tr_tally: bad match");

    s.dyn_ltree[(_length_code[lc]+LITERALS+1) * 2]/*.Freq*/++;
    s.dyn_dtree[d_code(dist) * 2]/*.Freq*/++;
  }

// (!) This block is disabled in zlib defailts,
// don't enable it for binary compatibility

//#ifdef TRUNCATE_BLOCK
//  /* Try to guess if it is profitable to stop the current block here */
//  if ((s.last_lit & 0x1fff) === 0 && s.level > 2) {
//    /* Compute an upper bound for the compressed length */
//    out_length = s.last_lit*8;
//    in_length = s.strstart - s.block_start;
//
//    for (dcode = 0; dcode < D_CODES; dcode++) {
//      out_length += s.dyn_dtree[dcode*2]/*.Freq*/ * (5 + extra_dbits[dcode]);
//    }
//    out_length >>>= 3;
//    //Tracev((stderr,"\nlast_lit %u, in %ld, out ~%ld(%ld%%) ",
//    //       s->last_lit, in_length, out_length,
//    //       100L - out_length*100L/in_length));
//    if (s.matches < (s.last_lit>>1)/*int /2*/ && out_length < (in_length>>1)/*int /2*/) {
//      return true;
//    }
//  }
//#endif

  return (s.last_lit === s.lit_bufsize-1);
  /* We avoid equality with lit_bufsize because of wraparound at 64K
   * on 16 bit machines and because stored blocks are restricted to
   * 64K-1 bytes.
   */
}

exports._tr_init  = _tr_init;
exports._tr_stored_block = _tr_stored_block;
exports._tr_flush_block  = _tr_flush_block;
exports._tr_tally = _tr_tally;
exports._tr_align = _tr_align;

},{"../utils/common":92}],102:[function(require,module,exports){
'use strict';


function ZStream() {
  /* next input byte */
  this.input = null; // JS specific, because we have no pointers
  this.next_in = 0;
  /* number of bytes available at input */
  this.avail_in = 0;
  /* total number of input bytes read so far */
  this.total_in = 0;
  /* next output byte should be put there */
  this.output = null; // JS specific, because we have no pointers
  this.next_out = 0;
  /* remaining free space at output */
  this.avail_out = 0;
  /* total number of bytes output so far */
  this.total_out = 0;
  /* last error message, NULL if no error */
  this.msg = ''/*Z_NULL*/;
  /* not visible by applications */
  this.state = null;
  /* best guess about the data type: binary or text */
  this.data_type = 2/*Z_UNKNOWN*/;
  /* adler32 value of the uncompressed data */
  this.adler = 0;
}

module.exports = ZStream;

},{}],103:[function(require,module,exports){
module.exports = function isBuffer(arg) {
  return arg && typeof arg === 'object'
    && typeof arg.copy === 'function'
    && typeof arg.fill === 'function'
    && typeof arg.readUInt8 === 'function';
}
},{}],104:[function(require,module,exports){
(function (process,global){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

var formatRegExp = /%[sdj%]/g;
exports.format = function(f) {
  if (!isString(f)) {
    var objects = [];
    for (var i = 0; i < arguments.length; i++) {
      objects.push(inspect(arguments[i]));
    }
    return objects.join(' ');
  }

  var i = 1;
  var args = arguments;
  var len = args.length;
  var str = String(f).replace(formatRegExp, function(x) {
    if (x === '%%') return '%';
    if (i >= len) return x;
    switch (x) {
      case '%s': return String(args[i++]);
      case '%d': return Number(args[i++]);
      case '%j':
        try {
          return JSON.stringify(args[i++]);
        } catch (_) {
          return '[Circular]';
        }
      default:
        return x;
    }
  });
  for (var x = args[i]; i < len; x = args[++i]) {
    if (isNull(x) || !isObject(x)) {
      str += ' ' + x;
    } else {
      str += ' ' + inspect(x);
    }
  }
  return str;
};


// Mark that a method should not be used.
// Returns a modified function which warns once by default.
// If --no-deprecation is set, then it is a no-op.
exports.deprecate = function(fn, msg) {
  // Allow for deprecating things in the process of starting up.
  if (isUndefined(global.process)) {
    return function() {
      return exports.deprecate(fn, msg).apply(this, arguments);
    };
  }

  if (process.noDeprecation === true) {
    return fn;
  }

  var warned = false;
  function deprecated() {
    if (!warned) {
      if (process.throwDeprecation) {
        throw new Error(msg);
      } else if (process.traceDeprecation) {
        console.trace(msg);
      } else {
        console.error(msg);
      }
      warned = true;
    }
    return fn.apply(this, arguments);
  }

  return deprecated;
};


var debugs = {};
var debugEnviron;
exports.debuglog = function(set) {
  if (isUndefined(debugEnviron))
    debugEnviron = process.env.NODE_DEBUG || '';
  set = set.toUpperCase();
  if (!debugs[set]) {
    if (new RegExp('\\b' + set + '\\b', 'i').test(debugEnviron)) {
      var pid = process.pid;
      debugs[set] = function() {
        var msg = exports.format.apply(exports, arguments);
        console.error('%s %d: %s', set, pid, msg);
      };
    } else {
      debugs[set] = function() {};
    }
  }
  return debugs[set];
};


/**
 * Echos the value of a value. Trys to print the value out
 * in the best way possible given the different types.
 *
 * @param {Object} obj The object to print out.
 * @param {Object} opts Optional options object that alters the output.
 */
/* legacy: obj, showHidden, depth, colors*/
function inspect(obj, opts) {
  // default options
  var ctx = {
    seen: [],
    stylize: stylizeNoColor
  };
  // legacy...
  if (arguments.length >= 3) ctx.depth = arguments[2];
  if (arguments.length >= 4) ctx.colors = arguments[3];
  if (isBoolean(opts)) {
    // legacy...
    ctx.showHidden = opts;
  } else if (opts) {
    // got an "options" object
    exports._extend(ctx, opts);
  }
  // set default options
  if (isUndefined(ctx.showHidden)) ctx.showHidden = false;
  if (isUndefined(ctx.depth)) ctx.depth = 2;
  if (isUndefined(ctx.colors)) ctx.colors = false;
  if (isUndefined(ctx.customInspect)) ctx.customInspect = true;
  if (ctx.colors) ctx.stylize = stylizeWithColor;
  return formatValue(ctx, obj, ctx.depth);
}
exports.inspect = inspect;


// http://en.wikipedia.org/wiki/ANSI_escape_code#graphics
inspect.colors = {
  'bold' : [1, 22],
  'italic' : [3, 23],
  'underline' : [4, 24],
  'inverse' : [7, 27],
  'white' : [37, 39],
  'grey' : [90, 39],
  'black' : [30, 39],
  'blue' : [34, 39],
  'cyan' : [36, 39],
  'green' : [32, 39],
  'magenta' : [35, 39],
  'red' : [31, 39],
  'yellow' : [33, 39]
};

// Don't use 'blue' not visible on cmd.exe
inspect.styles = {
  'special': 'cyan',
  'number': 'yellow',
  'boolean': 'yellow',
  'undefined': 'grey',
  'null': 'bold',
  'string': 'green',
  'date': 'magenta',
  // "name": intentionally not styling
  'regexp': 'red'
};


function stylizeWithColor(str, styleType) {
  var style = inspect.styles[styleType];

  if (style) {
    return '\u001b[' + inspect.colors[style][0] + 'm' + str +
           '\u001b[' + inspect.colors[style][1] + 'm';
  } else {
    return str;
  }
}


function stylizeNoColor(str, styleType) {
  return str;
}


function arrayToHash(array) {
  var hash = {};

  array.forEach(function(val, idx) {
    hash[val] = true;
  });

  return hash;
}


function formatValue(ctx, value, recurseTimes) {
  // Provide a hook for user-specified inspect functions.
  // Check that value is an object with an inspect function on it
  if (ctx.customInspect &&
      value &&
      isFunction(value.inspect) &&
      // Filter out the util module, it's inspect function is special
      value.inspect !== exports.inspect &&
      // Also filter out any prototype objects using the circular check.
      !(value.constructor && value.constructor.prototype === value)) {
    var ret = value.inspect(recurseTimes, ctx);
    if (!isString(ret)) {
      ret = formatValue(ctx, ret, recurseTimes);
    }
    return ret;
  }

  // Primitive types cannot have properties
  var primitive = formatPrimitive(ctx, value);
  if (primitive) {
    return primitive;
  }

  // Look up the keys of the object.
  var keys = Object.keys(value);
  var visibleKeys = arrayToHash(keys);

  if (ctx.showHidden) {
    keys = Object.getOwnPropertyNames(value);
  }

  // IE doesn't make error fields non-enumerable
  // http://msdn.microsoft.com/en-us/library/ie/dww52sbt(v=vs.94).aspx
  if (isError(value)
      && (keys.indexOf('message') >= 0 || keys.indexOf('description') >= 0)) {
    return formatError(value);
  }

  // Some type of object without properties can be shortcutted.
  if (keys.length === 0) {
    if (isFunction(value)) {
      var name = value.name ? ': ' + value.name : '';
      return ctx.stylize('[Function' + name + ']', 'special');
    }
    if (isRegExp(value)) {
      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
    }
    if (isDate(value)) {
      return ctx.stylize(Date.prototype.toString.call(value), 'date');
    }
    if (isError(value)) {
      return formatError(value);
    }
  }

  var base = '', array = false, braces = ['{', '}'];

  // Make Array say that they are Array
  if (isArray(value)) {
    array = true;
    braces = ['[', ']'];
  }

  // Make functions say that they are functions
  if (isFunction(value)) {
    var n = value.name ? ': ' + value.name : '';
    base = ' [Function' + n + ']';
  }

  // Make RegExps say that they are RegExps
  if (isRegExp(value)) {
    base = ' ' + RegExp.prototype.toString.call(value);
  }

  // Make dates with properties first say the date
  if (isDate(value)) {
    base = ' ' + Date.prototype.toUTCString.call(value);
  }

  // Make error with message first say the error
  if (isError(value)) {
    base = ' ' + formatError(value);
  }

  if (keys.length === 0 && (!array || value.length == 0)) {
    return braces[0] + base + braces[1];
  }

  if (recurseTimes < 0) {
    if (isRegExp(value)) {
      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
    } else {
      return ctx.stylize('[Object]', 'special');
    }
  }

  ctx.seen.push(value);

  var output;
  if (array) {
    output = formatArray(ctx, value, recurseTimes, visibleKeys, keys);
  } else {
    output = keys.map(function(key) {
      return formatProperty(ctx, value, recurseTimes, visibleKeys, key, array);
    });
  }

  ctx.seen.pop();

  return reduceToSingleString(output, base, braces);
}


function formatPrimitive(ctx, value) {
  if (isUndefined(value))
    return ctx.stylize('undefined', 'undefined');
  if (isString(value)) {
    var simple = '\'' + JSON.stringify(value).replace(/^"|"$/g, '')
                                             .replace(/'/g, "\\'")
                                             .replace(/\\"/g, '"') + '\'';
    return ctx.stylize(simple, 'string');
  }
  if (isNumber(value))
    return ctx.stylize('' + value, 'number');
  if (isBoolean(value))
    return ctx.stylize('' + value, 'boolean');
  // For some reason typeof null is "object", so special case here.
  if (isNull(value))
    return ctx.stylize('null', 'null');
}


function formatError(value) {
  return '[' + Error.prototype.toString.call(value) + ']';
}


function formatArray(ctx, value, recurseTimes, visibleKeys, keys) {
  var output = [];
  for (var i = 0, l = value.length; i < l; ++i) {
    if (hasOwnProperty(value, String(i))) {
      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,
          String(i), true));
    } else {
      output.push('');
    }
  }
  keys.forEach(function(key) {
    if (!key.match(/^\d+$/)) {
      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,
          key, true));
    }
  });
  return output;
}


function formatProperty(ctx, value, recurseTimes, visibleKeys, key, array) {
  var name, str, desc;
  desc = Object.getOwnPropertyDescriptor(value, key) || { value: value[key] };
  if (desc.get) {
    if (desc.set) {
      str = ctx.stylize('[Getter/Setter]', 'special');
    } else {
      str = ctx.stylize('[Getter]', 'special');
    }
  } else {
    if (desc.set) {
      str = ctx.stylize('[Setter]', 'special');
    }
  }
  if (!hasOwnProperty(visibleKeys, key)) {
    name = '[' + key + ']';
  }
  if (!str) {
    if (ctx.seen.indexOf(desc.value) < 0) {
      if (isNull(recurseTimes)) {
        str = formatValue(ctx, desc.value, null);
      } else {
        str = formatValue(ctx, desc.value, recurseTimes - 1);
      }
      if (str.indexOf('\n') > -1) {
        if (array) {
          str = str.split('\n').map(function(line) {
            return '  ' + line;
          }).join('\n').substr(2);
        } else {
          str = '\n' + str.split('\n').map(function(line) {
            return '   ' + line;
          }).join('\n');
        }
      }
    } else {
      str = ctx.stylize('[Circular]', 'special');
    }
  }
  if (isUndefined(name)) {
    if (array && key.match(/^\d+$/)) {
      return str;
    }
    name = JSON.stringify('' + key);
    if (name.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/)) {
      name = name.substr(1, name.length - 2);
      name = ctx.stylize(name, 'name');
    } else {
      name = name.replace(/'/g, "\\'")
                 .replace(/\\"/g, '"')
                 .replace(/(^"|"$)/g, "'");
      name = ctx.stylize(name, 'string');
    }
  }

  return name + ': ' + str;
}


function reduceToSingleString(output, base, braces) {
  var numLinesEst = 0;
  var length = output.reduce(function(prev, cur) {
    numLinesEst++;
    if (cur.indexOf('\n') >= 0) numLinesEst++;
    return prev + cur.replace(/\u001b\[\d\d?m/g, '').length + 1;
  }, 0);

  if (length > 60) {
    return braces[0] +
           (base === '' ? '' : base + '\n ') +
           ' ' +
           output.join(',\n  ') +
           ' ' +
           braces[1];
  }

  return braces[0] + base + ' ' + output.join(', ') + ' ' + braces[1];
}


// NOTE: These type checking functions intentionally don't use `instanceof`
// because it is fragile and can be easily faked with `Object.create()`.
function isArray(ar) {
  return Array.isArray(ar);
}
exports.isArray = isArray;

function isBoolean(arg) {
  return typeof arg === 'boolean';
}
exports.isBoolean = isBoolean;

function isNull(arg) {
  return arg === null;
}
exports.isNull = isNull;

function isNullOrUndefined(arg) {
  return arg == null;
}
exports.isNullOrUndefined = isNullOrUndefined;

function isNumber(arg) {
  return typeof arg === 'number';
}
exports.isNumber = isNumber;

function isString(arg) {
  return typeof arg === 'string';
}
exports.isString = isString;

function isSymbol(arg) {
  return typeof arg === 'symbol';
}
exports.isSymbol = isSymbol;

function isUndefined(arg) {
  return arg === void 0;
}
exports.isUndefined = isUndefined;

function isRegExp(re) {
  return isObject(re) && objectToString(re) === '[object RegExp]';
}
exports.isRegExp = isRegExp;

function isObject(arg) {
  return typeof arg === 'object' && arg !== null;
}
exports.isObject = isObject;

function isDate(d) {
  return isObject(d) && objectToString(d) === '[object Date]';
}
exports.isDate = isDate;

function isError(e) {
  return isObject(e) &&
      (objectToString(e) === '[object Error]' || e instanceof Error);
}
exports.isError = isError;

function isFunction(arg) {
  return typeof arg === 'function';
}
exports.isFunction = isFunction;

function isPrimitive(arg) {
  return arg === null ||
         typeof arg === 'boolean' ||
         typeof arg === 'number' ||
         typeof arg === 'string' ||
         typeof arg === 'symbol' ||  // ES6 symbol
         typeof arg === 'undefined';
}
exports.isPrimitive = isPrimitive;

exports.isBuffer = require('./support/isBuffer');

function objectToString(o) {
  return Object.prototype.toString.call(o);
}


function pad(n) {
  return n < 10 ? '0' + n.toString(10) : n.toString(10);
}


var months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep',
              'Oct', 'Nov', 'Dec'];

// 26 Feb 16:19:34
function timestamp() {
  var d = new Date();
  var time = [pad(d.getHours()),
              pad(d.getMinutes()),
              pad(d.getSeconds())].join(':');
  return [d.getDate(), months[d.getMonth()], time].join(' ');
}


// log is just a thin wrapper to console.log that prepends a timestamp
exports.log = function() {
  console.log('%s - %s', timestamp(), exports.format.apply(exports, arguments));
};


/**
 * Inherit the prototype methods from one constructor into another.
 *
 * The Function.prototype.inherits from lang.js rewritten as a standalone
 * function (not on Function.prototype). NOTE: If this file is to be loaded
 * during bootstrapping this function needs to be rewritten using some native
 * functions as prototype setup using normal JavaScript does not work as
 * expected during bootstrapping (see mirror.js in r114903).
 *
 * @param {function} ctor Constructor function which needs to inherit the
 *     prototype.
 * @param {function} superCtor Constructor function to inherit prototype from.
 */
exports.inherits = require('inherits');

exports._extend = function(origin, add) {
  // Don't do anything if add isn't an object
  if (!add || !isObject(add)) return origin;

  var keys = Object.keys(add);
  var i = keys.length;
  while (i--) {
    origin[keys[i]] = add[keys[i]];
  }
  return origin;
};

function hasOwnProperty(obj, prop) {
  return Object.prototype.hasOwnProperty.call(obj, prop);
}

}).call(this,require("7YKIPe"),typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"./support/isBuffer":103,"7YKIPe":17,"inherits":36}]},{},[1])
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi9Vc2Vycy9uaG9uZy9uaWNraG9uZy5pby9ub2RlX21vZHVsZXMvZ3VscC1icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9icm93c2VyLXBhY2svX3ByZWx1ZGUuanMiLCIvVXNlcnMvbmhvbmcvbmlja2hvbmcuaW8vYXBwL2Zha2VfZWIzZmUyZGQuanMiLCIvVXNlcnMvbmhvbmcvbmlja2hvbmcuaW8vbm9kZV9tb2R1bGVzL0Jhc2U2NC9iYXNlNjQuanMiLCIvVXNlcnMvbmhvbmcvbmlja2hvbmcuaW8vbm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnktemxpYi9zcmMvYmluZGluZy5qcyIsIi9Vc2Vycy9uaG9uZy9uaWNraG9uZy5pby9ub2RlX21vZHVsZXMvYnJvd3NlcmlmeS16bGliL3NyYy9pbmRleC5qcyIsIi9Vc2Vycy9uaG9uZy9uaWNraG9uZy5pby9ub2RlX21vZHVsZXMvZ3VscC1icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9hc3NlcnQvYXNzZXJ0LmpzIiwiL1VzZXJzL25ob25nL25pY2tob25nLmlvL25vZGVfbW9kdWxlcy9ndWxwLWJyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL2Jhc2U2NC1qcy9saWIvYjY0LmpzIiwiL1VzZXJzL25ob25nL25pY2tob25nLmlvL25vZGVfbW9kdWxlcy9ndWxwLWJyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL2Jyb3dzZXItcmVzb2x2ZS9lbXB0eS5qcyIsIi9Vc2Vycy9uaG9uZy9uaWNraG9uZy5pby9ub2RlX21vZHVsZXMvZ3VscC1icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9idWZmZXIvaW5kZXguanMiLCIvVXNlcnMvbmhvbmcvbmlja2hvbmcuaW8vbm9kZV9tb2R1bGVzL2d1bHAtYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvY3J5cHRvLWJyb3dzZXJpZnkvaGVscGVycy5qcyIsIi9Vc2Vycy9uaG9uZy9uaWNraG9uZy5pby9ub2RlX21vZHVsZXMvZ3VscC1icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9jcnlwdG8tYnJvd3NlcmlmeS9pbmRleC5qcyIsIi9Vc2Vycy9uaG9uZy9uaWNraG9uZy5pby9ub2RlX21vZHVsZXMvZ3VscC1icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9jcnlwdG8tYnJvd3NlcmlmeS9tZDUuanMiLCIvVXNlcnMvbmhvbmcvbmlja2hvbmcuaW8vbm9kZV9tb2R1bGVzL2d1bHAtYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvY3J5cHRvLWJyb3dzZXJpZnkvcm5nLmpzIiwiL1VzZXJzL25ob25nL25pY2tob25nLmlvL25vZGVfbW9kdWxlcy9ndWxwLWJyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL2NyeXB0by1icm93c2VyaWZ5L3NoYS5qcyIsIi9Vc2Vycy9uaG9uZy9uaWNraG9uZy5pby9ub2RlX21vZHVsZXMvZ3VscC1icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9jcnlwdG8tYnJvd3NlcmlmeS9zaGEyNTYuanMiLCIvVXNlcnMvbmhvbmcvbmlja2hvbmcuaW8vbm9kZV9tb2R1bGVzL2d1bHAtYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvZXZlbnRzL2V2ZW50cy5qcyIsIi9Vc2Vycy9uaG9uZy9uaWNraG9uZy5pby9ub2RlX21vZHVsZXMvZ3VscC1icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9wcm9jZXNzL2Jyb3dzZXIuanMiLCIvVXNlcnMvbmhvbmcvbmlja2hvbmcuaW8vbm9kZV9tb2R1bGVzL2d1bHAtYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvcHVueWNvZGUvcHVueWNvZGUuanMiLCIvVXNlcnMvbmhvbmcvbmlja2hvbmcuaW8vbm9kZV9tb2R1bGVzL2d1bHAtYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvcXVlcnlzdHJpbmctZXMzL2RlY29kZS5qcyIsIi9Vc2Vycy9uaG9uZy9uaWNraG9uZy5pby9ub2RlX21vZHVsZXMvZ3VscC1icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9xdWVyeXN0cmluZy1lczMvZW5jb2RlLmpzIiwiL1VzZXJzL25ob25nL25pY2tob25nLmlvL25vZGVfbW9kdWxlcy9ndWxwLWJyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL3F1ZXJ5c3RyaW5nLWVzMy9pbmRleC5qcyIsIi9Vc2Vycy9uaG9uZy9uaWNraG9uZy5pby9ub2RlX21vZHVsZXMvZ3VscC1icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9zdHJlYW0tYnJvd3NlcmlmeS9kdXBsZXguanMiLCIvVXNlcnMvbmhvbmcvbmlja2hvbmcuaW8vbm9kZV9tb2R1bGVzL2d1bHAtYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvc3RyZWFtLWJyb3dzZXJpZnkvaW5kZXguanMiLCIvVXNlcnMvbmhvbmcvbmlja2hvbmcuaW8vbm9kZV9tb2R1bGVzL2d1bHAtYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvc3RyZWFtLWJyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL3Byb2Nlc3MvYnJvd3Nlci5qcyIsIi9Vc2Vycy9uaG9uZy9uaWNraG9uZy5pby9ub2RlX21vZHVsZXMvZ3VscC1icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9zdHJlYW0tYnJvd3NlcmlmeS9wYXNzdGhyb3VnaC5qcyIsIi9Vc2Vycy9uaG9uZy9uaWNraG9uZy5pby9ub2RlX21vZHVsZXMvZ3VscC1icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9zdHJlYW0tYnJvd3NlcmlmeS9yZWFkYWJsZS5qcyIsIi9Vc2Vycy9uaG9uZy9uaWNraG9uZy5pby9ub2RlX21vZHVsZXMvZ3VscC1icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9zdHJlYW0tYnJvd3NlcmlmeS90cmFuc2Zvcm0uanMiLCIvVXNlcnMvbmhvbmcvbmlja2hvbmcuaW8vbm9kZV9tb2R1bGVzL2d1bHAtYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvc3RyZWFtLWJyb3dzZXJpZnkvd3JpdGFibGUuanMiLCIvVXNlcnMvbmhvbmcvbmlja2hvbmcuaW8vbm9kZV9tb2R1bGVzL2d1bHAtYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvc3RyaW5nX2RlY29kZXIvaW5kZXguanMiLCIvVXNlcnMvbmhvbmcvbmlja2hvbmcuaW8vbm9kZV9tb2R1bGVzL2d1bHAtYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvdXJsL3VybC5qcyIsIi9Vc2Vycy9uaG9uZy9uaWNraG9uZy5pby9ub2RlX21vZHVsZXMvaHR0cC1icm93c2VyaWZ5L2luZGV4LmpzIiwiL1VzZXJzL25ob25nL25pY2tob25nLmlvL25vZGVfbW9kdWxlcy9odHRwLWJyb3dzZXJpZnkvbGliL3JlcXVlc3QuanMiLCIvVXNlcnMvbmhvbmcvbmlja2hvbmcuaW8vbm9kZV9tb2R1bGVzL2h0dHAtYnJvd3NlcmlmeS9saWIvcmVzcG9uc2UuanMiLCIvVXNlcnMvbmhvbmcvbmlja2hvbmcuaW8vbm9kZV9tb2R1bGVzL2h0dHBzLWJyb3dzZXJpZnkvaW5kZXguanMiLCIvVXNlcnMvbmhvbmcvbmlja2hvbmcuaW8vbm9kZV9tb2R1bGVzL2llZWU3NTQvaW5kZXguanMiLCIvVXNlcnMvbmhvbmcvbmlja2hvbmcuaW8vbm9kZV9tb2R1bGVzL2luaGVyaXRzL2luaGVyaXRzX2Jyb3dzZXIuanMiLCIvVXNlcnMvbmhvbmcvbmlja2hvbmcuaW8vbm9kZV9tb2R1bGVzL25vZGVtYWlsZXIvbGliL2h0dHAtcHJveHkuanMiLCIvVXNlcnMvbmhvbmcvbmlja2hvbmcuaW8vbm9kZV9tb2R1bGVzL25vZGVtYWlsZXIvbGliL25vZGVtYWlsZXIuanMiLCIvVXNlcnMvbmhvbmcvbmlja2hvbmcuaW8vbm9kZV9tb2R1bGVzL25vZGVtYWlsZXIvbGliL3RlbXBsYXRlLXNlbmRlci5qcyIsIi9Vc2Vycy9uaG9uZy9uaWNraG9uZy5pby9ub2RlX21vZHVsZXMvbm9kZW1haWxlci9ub2RlX21vZHVsZXMvYWRkcmVzc3BhcnNlci9saWIvYWRkcmVzc3BhcnNlci5qcyIsIi9Vc2Vycy9uaG9uZy9uaWNraG9uZy5pby9ub2RlX21vZHVsZXMvbm9kZW1haWxlci9ub2RlX21vZHVsZXMvYnVpbGRtYWlsL2xpYi9idWlsZG1haWwuanMiLCIvVXNlcnMvbmhvbmcvbmlja2hvbmcuaW8vbm9kZV9tb2R1bGVzL25vZGVtYWlsZXIvbm9kZV9tb2R1bGVzL2h0dHBudGxtL250bG0uanMiLCIvVXNlcnMvbmhvbmcvbmlja2hvbmcuaW8vbm9kZV9tb2R1bGVzL25vZGVtYWlsZXIvbm9kZV9tb2R1bGVzL2ljb252LWxpdGUvZW5jb2RpbmdzL2RiY3MtY29kZWMuanMiLCIvVXNlcnMvbmhvbmcvbmlja2hvbmcuaW8vbm9kZV9tb2R1bGVzL25vZGVtYWlsZXIvbm9kZV9tb2R1bGVzL2ljb252LWxpdGUvZW5jb2RpbmdzL2RiY3MtZGF0YS5qcyIsIi9Vc2Vycy9uaG9uZy9uaWNraG9uZy5pby9ub2RlX21vZHVsZXMvbm9kZW1haWxlci9ub2RlX21vZHVsZXMvaWNvbnYtbGl0ZS9lbmNvZGluZ3MvaW5kZXguanMiLCIvVXNlcnMvbmhvbmcvbmlja2hvbmcuaW8vbm9kZV9tb2R1bGVzL25vZGVtYWlsZXIvbm9kZV9tb2R1bGVzL2ljb252LWxpdGUvZW5jb2RpbmdzL2ludGVybmFsLmpzIiwiL1VzZXJzL25ob25nL25pY2tob25nLmlvL25vZGVfbW9kdWxlcy9ub2RlbWFpbGVyL25vZGVfbW9kdWxlcy9pY29udi1saXRlL2VuY29kaW5ncy9zYmNzLWNvZGVjLmpzIiwiL1VzZXJzL25ob25nL25pY2tob25nLmlvL25vZGVfbW9kdWxlcy9ub2RlbWFpbGVyL25vZGVfbW9kdWxlcy9pY29udi1saXRlL2VuY29kaW5ncy9zYmNzLWRhdGEtZ2VuZXJhdGVkLmpzIiwiL1VzZXJzL25ob25nL25pY2tob25nLmlvL25vZGVfbW9kdWxlcy9ub2RlbWFpbGVyL25vZGVfbW9kdWxlcy9pY29udi1saXRlL2VuY29kaW5ncy9zYmNzLWRhdGEuanMiLCIvVXNlcnMvbmhvbmcvbmlja2hvbmcuaW8vbm9kZV9tb2R1bGVzL25vZGVtYWlsZXIvbm9kZV9tb2R1bGVzL2ljb252LWxpdGUvZW5jb2RpbmdzL3RhYmxlcy9iaWc1LWFkZGVkLmpzb24iLCIvVXNlcnMvbmhvbmcvbmlja2hvbmcuaW8vbm9kZV9tb2R1bGVzL25vZGVtYWlsZXIvbm9kZV9tb2R1bGVzL2ljb252LWxpdGUvZW5jb2RpbmdzL3RhYmxlcy9jcDkzNi5qc29uIiwiL1VzZXJzL25ob25nL25pY2tob25nLmlvL25vZGVfbW9kdWxlcy9ub2RlbWFpbGVyL25vZGVfbW9kdWxlcy9pY29udi1saXRlL2VuY29kaW5ncy90YWJsZXMvY3A5NDkuanNvbiIsIi9Vc2Vycy9uaG9uZy9uaWNraG9uZy5pby9ub2RlX21vZHVsZXMvbm9kZW1haWxlci9ub2RlX21vZHVsZXMvaWNvbnYtbGl0ZS9lbmNvZGluZ3MvdGFibGVzL2NwOTUwLmpzb24iLCIvVXNlcnMvbmhvbmcvbmlja2hvbmcuaW8vbm9kZV9tb2R1bGVzL25vZGVtYWlsZXIvbm9kZV9tb2R1bGVzL2ljb252LWxpdGUvZW5jb2RpbmdzL3RhYmxlcy9ldWNqcC5qc29uIiwiL1VzZXJzL25ob25nL25pY2tob25nLmlvL25vZGVfbW9kdWxlcy9ub2RlbWFpbGVyL25vZGVfbW9kdWxlcy9pY29udi1saXRlL2VuY29kaW5ncy90YWJsZXMvZ2IxODAzMC1yYW5nZXMuanNvbiIsIi9Vc2Vycy9uaG9uZy9uaWNraG9uZy5pby9ub2RlX21vZHVsZXMvbm9kZW1haWxlci9ub2RlX21vZHVsZXMvaWNvbnYtbGl0ZS9lbmNvZGluZ3MvdGFibGVzL2diay1hZGRlZC5qc29uIiwiL1VzZXJzL25ob25nL25pY2tob25nLmlvL25vZGVfbW9kdWxlcy9ub2RlbWFpbGVyL25vZGVfbW9kdWxlcy9pY29udi1saXRlL2VuY29kaW5ncy90YWJsZXMvc2hpZnRqaXMuanNvbiIsIi9Vc2Vycy9uaG9uZy9uaWNraG9uZy5pby9ub2RlX21vZHVsZXMvbm9kZW1haWxlci9ub2RlX21vZHVsZXMvaWNvbnYtbGl0ZS9lbmNvZGluZ3MvdXRmMTYuanMiLCIvVXNlcnMvbmhvbmcvbmlja2hvbmcuaW8vbm9kZV9tb2R1bGVzL25vZGVtYWlsZXIvbm9kZV9tb2R1bGVzL2ljb252LWxpdGUvZW5jb2RpbmdzL3V0ZjcuanMiLCIvVXNlcnMvbmhvbmcvbmlja2hvbmcuaW8vbm9kZV9tb2R1bGVzL25vZGVtYWlsZXIvbm9kZV9tb2R1bGVzL2ljb252LWxpdGUvbGliL2JvbS1oYW5kbGluZy5qcyIsIi9Vc2Vycy9uaG9uZy9uaWNraG9uZy5pby9ub2RlX21vZHVsZXMvbm9kZW1haWxlci9ub2RlX21vZHVsZXMvaWNvbnYtbGl0ZS9saWIvaW5kZXguanMiLCIvVXNlcnMvbmhvbmcvbmlja2hvbmcuaW8vbm9kZV9tb2R1bGVzL25vZGVtYWlsZXIvbm9kZV9tb2R1bGVzL2lwL2xpYi9pcC5qcyIsIi9Vc2Vycy9uaG9uZy9uaWNraG9uZy5pby9ub2RlX21vZHVsZXMvbm9kZW1haWxlci9ub2RlX21vZHVsZXMvbGliYmFzZTY0L2xpYi9saWJiYXNlNjQuanMiLCIvVXNlcnMvbmhvbmcvbmlja2hvbmcuaW8vbm9kZV9tb2R1bGVzL25vZGVtYWlsZXIvbm9kZV9tb2R1bGVzL2xpYm1pbWUvbGliL2NoYXJzZXQuanMiLCIvVXNlcnMvbmhvbmcvbmlja2hvbmcuaW8vbm9kZV9tb2R1bGVzL25vZGVtYWlsZXIvbm9kZV9tb2R1bGVzL2xpYm1pbWUvbGliL2xpYm1pbWUuanMiLCIvVXNlcnMvbmhvbmcvbmlja2hvbmcuaW8vbm9kZV9tb2R1bGVzL25vZGVtYWlsZXIvbm9kZV9tb2R1bGVzL2xpYm1pbWUvbGliL21pbWV0eXBlcy5qcyIsIi9Vc2Vycy9uaG9uZy9uaWNraG9uZy5pby9ub2RlX21vZHVsZXMvbm9kZW1haWxlci9ub2RlX21vZHVsZXMvbGlicXAvbGliL2xpYnFwLmpzIiwiL1VzZXJzL25ob25nL25pY2tob25nLmlvL25vZGVfbW9kdWxlcy9ub2RlbWFpbGVyL25vZGVfbW9kdWxlcy9tYWlsY29tcG9zZXIvbGliL21haWxjb21wb3Nlci5qcyIsIi9Vc2Vycy9uaG9uZy9uaWNraG9uZy5pby9ub2RlX21vZHVsZXMvbm9kZW1haWxlci9ub2RlX21vZHVsZXMvbm9kZW1haWxlci1kaXJlY3QtdHJhbnNwb3J0L2xpYi9kaXJlY3QtdHJhbnNwb3J0LmpzIiwiL1VzZXJzL25ob25nL25pY2tob25nLmlvL25vZGVfbW9kdWxlcy9ub2RlbWFpbGVyL25vZGVfbW9kdWxlcy9ub2RlbWFpbGVyLWRpcmVjdC10cmFuc3BvcnQvbGliL21lc3NhZ2UtcXVldWUuanMiLCIvVXNlcnMvbmhvbmcvbmlja2hvbmcuaW8vbm9kZV9tb2R1bGVzL25vZGVtYWlsZXIvbm9kZV9tb2R1bGVzL25vZGVtYWlsZXItZGlyZWN0LXRyYW5zcG9ydC9wYWNrYWdlLmpzb24iLCIvVXNlcnMvbmhvbmcvbmlja2hvbmcuaW8vbm9kZV9tb2R1bGVzL25vZGVtYWlsZXIvbm9kZV9tb2R1bGVzL25vZGVtYWlsZXItZmV0Y2gvbGliL2Nvb2tpZXMuanMiLCIvVXNlcnMvbmhvbmcvbmlja2hvbmcuaW8vbm9kZV9tb2R1bGVzL25vZGVtYWlsZXIvbm9kZV9tb2R1bGVzL25vZGVtYWlsZXItZmV0Y2gvbGliL2ZldGNoLmpzIiwiL1VzZXJzL25ob25nL25pY2tob25nLmlvL25vZGVfbW9kdWxlcy9ub2RlbWFpbGVyL25vZGVfbW9kdWxlcy9ub2RlbWFpbGVyLXNoYXJlZC9saWIvc2hhcmVkLmpzIiwiL1VzZXJzL25ob25nL25pY2tob25nLmlvL25vZGVfbW9kdWxlcy9ub2RlbWFpbGVyL25vZGVfbW9kdWxlcy9ub2RlbWFpbGVyLXNtdHAtcG9vbC9saWIvYXNzaWduLmpzIiwiL1VzZXJzL25ob25nL25pY2tob25nLmlvL25vZGVfbW9kdWxlcy9ub2RlbWFpbGVyL25vZGVfbW9kdWxlcy9ub2RlbWFpbGVyLXNtdHAtcG9vbC9saWIvcG9vbC1yZXNvdXJjZS5qcyIsIi9Vc2Vycy9uaG9uZy9uaWNraG9uZy5pby9ub2RlX21vZHVsZXMvbm9kZW1haWxlci9ub2RlX21vZHVsZXMvbm9kZW1haWxlci1zbXRwLXBvb2wvbGliL3NtdHAtcG9vbC5qcyIsIi9Vc2Vycy9uaG9uZy9uaWNraG9uZy5pby9ub2RlX21vZHVsZXMvbm9kZW1haWxlci9ub2RlX21vZHVsZXMvbm9kZW1haWxlci1zbXRwLXBvb2wvcGFja2FnZS5qc29uIiwiL1VzZXJzL25ob25nL25pY2tob25nLmlvL25vZGVfbW9kdWxlcy9ub2RlbWFpbGVyL25vZGVfbW9kdWxlcy9ub2RlbWFpbGVyLXNtdHAtdHJhbnNwb3J0L2xpYi9zbXRwLXRyYW5zcG9ydC5qcyIsIi9Vc2Vycy9uaG9uZy9uaWNraG9uZy5pby9ub2RlX21vZHVsZXMvbm9kZW1haWxlci9ub2RlX21vZHVsZXMvbm9kZW1haWxlci1zbXRwLXRyYW5zcG9ydC9wYWNrYWdlLmpzb24iLCIvVXNlcnMvbmhvbmcvbmlja2hvbmcuaW8vbm9kZV9tb2R1bGVzL25vZGVtYWlsZXIvbm9kZV9tb2R1bGVzL25vZGVtYWlsZXItd2VsbGtub3duL2luZGV4LmpzIiwiL1VzZXJzL25ob25nL25pY2tob25nLmlvL25vZGVfbW9kdWxlcy9ub2RlbWFpbGVyL25vZGVfbW9kdWxlcy9ub2RlbWFpbGVyLXdlbGxrbm93bi9zZXJ2aWNlcy5qc29uIiwiL1VzZXJzL25ob25nL25pY2tob25nLmlvL25vZGVfbW9kdWxlcy9ub2RlbWFpbGVyL25vZGVfbW9kdWxlcy9zbWFydC1idWZmZXIvbGliL3NtYXJ0LWJ1ZmZlci5qcyIsIi9Vc2Vycy9uaG9uZy9uaWNraG9uZy5pby9ub2RlX21vZHVsZXMvbm9kZW1haWxlci9ub2RlX21vZHVsZXMvc210cC1jb25uZWN0aW9uL2xpYi9kYXRhLXN0cmVhbS5qcyIsIi9Vc2Vycy9uaG9uZy9uaWNraG9uZy5pby9ub2RlX21vZHVsZXMvbm9kZW1haWxlci9ub2RlX21vZHVsZXMvc210cC1jb25uZWN0aW9uL2xpYi9zbXRwLWNvbm5lY3Rpb24uanMiLCIvVXNlcnMvbmhvbmcvbmlja2hvbmcuaW8vbm9kZV9tb2R1bGVzL25vZGVtYWlsZXIvbm9kZV9tb2R1bGVzL3NtdHAtY29ubmVjdGlvbi9wYWNrYWdlLmpzb24iLCIvVXNlcnMvbmhvbmcvbmlja2hvbmcuaW8vbm9kZV9tb2R1bGVzL25vZGVtYWlsZXIvbm9kZV9tb2R1bGVzL3NvY2tzL2luZGV4LmpzIiwiL1VzZXJzL25ob25nL25pY2tob25nLmlvL25vZGVfbW9kdWxlcy9ub2RlbWFpbGVyL25vZGVfbW9kdWxlcy9zb2Nrcy9saWIvc29ja3MtYWdlbnQuanMiLCIvVXNlcnMvbmhvbmcvbmlja2hvbmcuaW8vbm9kZV9tb2R1bGVzL25vZGVtYWlsZXIvbm9kZV9tb2R1bGVzL3NvY2tzL2xpYi9zb2Nrcy1jbGllbnQuanMiLCIvVXNlcnMvbmhvbmcvbmlja2hvbmcuaW8vbm9kZV9tb2R1bGVzL25vZGVtYWlsZXIvcGFja2FnZS5qc29uIiwiL1VzZXJzL25ob25nL25pY2tob25nLmlvL25vZGVfbW9kdWxlcy9vcy1icm93c2VyaWZ5L2Jyb3dzZXIuanMiLCIvVXNlcnMvbmhvbmcvbmlja2hvbmcuaW8vbm9kZV9tb2R1bGVzL3Bha28vbGliL3V0aWxzL2NvbW1vbi5qcyIsIi9Vc2Vycy9uaG9uZy9uaWNraG9uZy5pby9ub2RlX21vZHVsZXMvcGFrby9saWIvemxpYi9hZGxlcjMyLmpzIiwiL1VzZXJzL25ob25nL25pY2tob25nLmlvL25vZGVfbW9kdWxlcy9wYWtvL2xpYi96bGliL2NvbnN0YW50cy5qcyIsIi9Vc2Vycy9uaG9uZy9uaWNraG9uZy5pby9ub2RlX21vZHVsZXMvcGFrby9saWIvemxpYi9jcmMzMi5qcyIsIi9Vc2Vycy9uaG9uZy9uaWNraG9uZy5pby9ub2RlX21vZHVsZXMvcGFrby9saWIvemxpYi9kZWZsYXRlLmpzIiwiL1VzZXJzL25ob25nL25pY2tob25nLmlvL25vZGVfbW9kdWxlcy9wYWtvL2xpYi96bGliL2luZmZhc3QuanMiLCIvVXNlcnMvbmhvbmcvbmlja2hvbmcuaW8vbm9kZV9tb2R1bGVzL3Bha28vbGliL3psaWIvaW5mbGF0ZS5qcyIsIi9Vc2Vycy9uaG9uZy9uaWNraG9uZy5pby9ub2RlX21vZHVsZXMvcGFrby9saWIvemxpYi9pbmZ0cmVlcy5qcyIsIi9Vc2Vycy9uaG9uZy9uaWNraG9uZy5pby9ub2RlX21vZHVsZXMvcGFrby9saWIvemxpYi9tZXNzYWdlcy5qcyIsIi9Vc2Vycy9uaG9uZy9uaWNraG9uZy5pby9ub2RlX21vZHVsZXMvcGFrby9saWIvemxpYi90cmVlcy5qcyIsIi9Vc2Vycy9uaG9uZy9uaWNraG9uZy5pby9ub2RlX21vZHVsZXMvcGFrby9saWIvemxpYi96c3RyZWFtLmpzIiwiL1VzZXJzL25ob25nL25pY2tob25nLmlvL25vZGVfbW9kdWxlcy91dGlsL3N1cHBvcnQvaXNCdWZmZXJCcm93c2VyLmpzIiwiL1VzZXJzL25ob25nL25pY2tob25nLmlvL25vZGVfbW9kdWxlcy91dGlsL3V0aWwuanMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUNBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDZEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDNURBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDOU9BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BtQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeFdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDNUhBOzs7O0FDQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JsQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25DQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25LQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQy9CQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDckdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDL0VBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDN1NBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQy9EQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDN2ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ0pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3hFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQy9IQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDckRBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3Y2QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDNU1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsWUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQy9MQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbnNCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeklBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzdMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN4SEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdkJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbElBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDelpBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuU0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbmxDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeFlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDNWlCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzdMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xjQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3pLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMUhBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3hRQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqUkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDakxBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0TEE7O0FDQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzdIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaExBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25TQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDL0lBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDNVpBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMU1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQy94QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQy85REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzFUQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzNkQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzNkQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3RIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25FQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDblJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMU1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM1UkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDOUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzNLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwZEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDelJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM5Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDL1BBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0WEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDOXJDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMzRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDTkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzlHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcFRBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3hOQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM3Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdEdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQy9DQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDekNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcnVEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdFVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQy85Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdlVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDYkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQy9xQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzdCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDTEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJmaWxlIjoiZ2VuZXJhdGVkLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXNDb250ZW50IjpbIihmdW5jdGlvbiBlKHQsbixyKXtmdW5jdGlvbiBzKG8sdSl7aWYoIW5bb10pe2lmKCF0W29dKXt2YXIgYT10eXBlb2YgcmVxdWlyZT09XCJmdW5jdGlvblwiJiZyZXF1aXJlO2lmKCF1JiZhKXJldHVybiBhKG8sITApO2lmKGkpcmV0dXJuIGkobywhMCk7dGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IGZpbmQgbW9kdWxlICdcIitvK1wiJ1wiKX12YXIgZj1uW29dPXtleHBvcnRzOnt9fTt0W29dWzBdLmNhbGwoZi5leHBvcnRzLGZ1bmN0aW9uKGUpe3ZhciBuPXRbb11bMV1bZV07cmV0dXJuIHMobj9uOmUpfSxmLGYuZXhwb3J0cyxlLHQsbixyKX1yZXR1cm4gbltvXS5leHBvcnRzfXZhciBpPXR5cGVvZiByZXF1aXJlPT1cImZ1bmN0aW9uXCImJnJlcXVpcmU7Zm9yKHZhciBvPTA7bzxyLmxlbmd0aDtvKyspcyhyW29dKTtyZXR1cm4gc30pIiwiKGZ1bmN0aW9uIChwcm9jZXNzKXtcbm5vZGVtYWlsZXIgPSByZXF1aXJlKCdub2RlbWFpbGVyJylcblxudHJhbnNwb3J0ZXIgPSBub2RlbWFpbGVyLmNyZWF0ZVRyYW5zcG9ydFxuICBzZXJ2aWNlOiAnTWFpbGd1bidcbiAgYXV0aDpcbiAgICB1c2VyOiAncG9zdG1hc3RlckBzYW5kYm94M2U5NzM4ZDdiNjgyNGYxMTlmZjlmZGU2MmVkZDdkNDIubWFpbGd1bi5vcmcnXG4gICAgcGFzczogcHJvY2Vzcy5lbnYuTUFJTEdVTl9QQVNTV09SRFxuXG5zZW5kRW1haWwgPSAnaGVsbG8nXG5cblxubW9kdWxlLmV4cG9ydHMgPSB7c2VuZEVtYWlsfVxuXG59KS5jYWxsKHRoaXMscmVxdWlyZShcIjdZS0lQZVwiKSkiLCI7KGZ1bmN0aW9uICgpIHtcblxuICB2YXIgb2JqZWN0ID0gdHlwZW9mIGV4cG9ydHMgIT0gJ3VuZGVmaW5lZCcgPyBleHBvcnRzIDogdGhpczsgLy8gIzg6IHdlYiB3b3JrZXJzXG4gIHZhciBjaGFycyA9ICdBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWmFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6MDEyMzQ1Njc4OSsvPSc7XG5cbiAgZnVuY3Rpb24gSW52YWxpZENoYXJhY3RlckVycm9yKG1lc3NhZ2UpIHtcbiAgICB0aGlzLm1lc3NhZ2UgPSBtZXNzYWdlO1xuICB9XG4gIEludmFsaWRDaGFyYWN0ZXJFcnJvci5wcm90b3R5cGUgPSBuZXcgRXJyb3I7XG4gIEludmFsaWRDaGFyYWN0ZXJFcnJvci5wcm90b3R5cGUubmFtZSA9ICdJbnZhbGlkQ2hhcmFjdGVyRXJyb3InO1xuXG4gIC8vIGVuY29kZXJcbiAgLy8gW2h0dHBzOi8vZ2lzdC5naXRodWIuY29tLzk5OTE2Nl0gYnkgW2h0dHBzOi8vZ2l0aHViLmNvbS9uaWduYWddXG4gIG9iamVjdC5idG9hIHx8IChcbiAgb2JqZWN0LmJ0b2EgPSBmdW5jdGlvbiAoaW5wdXQpIHtcbiAgICBmb3IgKFxuICAgICAgLy8gaW5pdGlhbGl6ZSByZXN1bHQgYW5kIGNvdW50ZXJcbiAgICAgIHZhciBibG9jaywgY2hhckNvZGUsIGlkeCA9IDAsIG1hcCA9IGNoYXJzLCBvdXRwdXQgPSAnJztcbiAgICAgIC8vIGlmIHRoZSBuZXh0IGlucHV0IGluZGV4IGRvZXMgbm90IGV4aXN0OlxuICAgICAgLy8gICBjaGFuZ2UgdGhlIG1hcHBpbmcgdGFibGUgdG8gXCI9XCJcbiAgICAgIC8vICAgY2hlY2sgaWYgZCBoYXMgbm8gZnJhY3Rpb25hbCBkaWdpdHNcbiAgICAgIGlucHV0LmNoYXJBdChpZHggfCAwKSB8fCAobWFwID0gJz0nLCBpZHggJSAxKTtcbiAgICAgIC8vIFwiOCAtIGlkeCAlIDEgKiA4XCIgZ2VuZXJhdGVzIHRoZSBzZXF1ZW5jZSAyLCA0LCA2LCA4XG4gICAgICBvdXRwdXQgKz0gbWFwLmNoYXJBdCg2MyAmIGJsb2NrID4+IDggLSBpZHggJSAxICogOClcbiAgICApIHtcbiAgICAgIGNoYXJDb2RlID0gaW5wdXQuY2hhckNvZGVBdChpZHggKz0gMy80KTtcbiAgICAgIGlmIChjaGFyQ29kZSA+IDB4RkYpIHtcbiAgICAgICAgdGhyb3cgbmV3IEludmFsaWRDaGFyYWN0ZXJFcnJvcihcIididG9hJyBmYWlsZWQ6IFRoZSBzdHJpbmcgdG8gYmUgZW5jb2RlZCBjb250YWlucyBjaGFyYWN0ZXJzIG91dHNpZGUgb2YgdGhlIExhdGluMSByYW5nZS5cIik7XG4gICAgICB9XG4gICAgICBibG9jayA9IGJsb2NrIDw8IDggfCBjaGFyQ29kZTtcbiAgICB9XG4gICAgcmV0dXJuIG91dHB1dDtcbiAgfSk7XG5cbiAgLy8gZGVjb2RlclxuICAvLyBbaHR0cHM6Ly9naXN0LmdpdGh1Yi5jb20vMTAyMDM5Nl0gYnkgW2h0dHBzOi8vZ2l0aHViLmNvbS9hdGtdXG4gIG9iamVjdC5hdG9iIHx8IChcbiAgb2JqZWN0LmF0b2IgPSBmdW5jdGlvbiAoaW5wdXQpIHtcbiAgICBpbnB1dCA9IGlucHV0LnJlcGxhY2UoLz0rJC8sICcnKTtcbiAgICBpZiAoaW5wdXQubGVuZ3RoICUgNCA9PSAxKSB7XG4gICAgICB0aHJvdyBuZXcgSW52YWxpZENoYXJhY3RlckVycm9yKFwiJ2F0b2InIGZhaWxlZDogVGhlIHN0cmluZyB0byBiZSBkZWNvZGVkIGlzIG5vdCBjb3JyZWN0bHkgZW5jb2RlZC5cIik7XG4gICAgfVxuICAgIGZvciAoXG4gICAgICAvLyBpbml0aWFsaXplIHJlc3VsdCBhbmQgY291bnRlcnNcbiAgICAgIHZhciBiYyA9IDAsIGJzLCBidWZmZXIsIGlkeCA9IDAsIG91dHB1dCA9ICcnO1xuICAgICAgLy8gZ2V0IG5leHQgY2hhcmFjdGVyXG4gICAgICBidWZmZXIgPSBpbnB1dC5jaGFyQXQoaWR4KyspO1xuICAgICAgLy8gY2hhcmFjdGVyIGZvdW5kIGluIHRhYmxlPyBpbml0aWFsaXplIGJpdCBzdG9yYWdlIGFuZCBhZGQgaXRzIGFzY2lpIHZhbHVlO1xuICAgICAgfmJ1ZmZlciAmJiAoYnMgPSBiYyAlIDQgPyBicyAqIDY0ICsgYnVmZmVyIDogYnVmZmVyLFxuICAgICAgICAvLyBhbmQgaWYgbm90IGZpcnN0IG9mIGVhY2ggNCBjaGFyYWN0ZXJzLFxuICAgICAgICAvLyBjb252ZXJ0IHRoZSBmaXJzdCA4IGJpdHMgdG8gb25lIGFzY2lpIGNoYXJhY3RlclxuICAgICAgICBiYysrICUgNCkgPyBvdXRwdXQgKz0gU3RyaW5nLmZyb21DaGFyQ29kZSgyNTUgJiBicyA+PiAoLTIgKiBiYyAmIDYpKSA6IDBcbiAgICApIHtcbiAgICAgIC8vIHRyeSB0byBmaW5kIGNoYXJhY3RlciBpbiB0YWJsZSAoMC02Mywgbm90IGZvdW5kID0+IC0xKVxuICAgICAgYnVmZmVyID0gY2hhcnMuaW5kZXhPZihidWZmZXIpO1xuICAgIH1cbiAgICByZXR1cm4gb3V0cHV0O1xuICB9KTtcblxufSgpKTtcbiIsIihmdW5jdGlvbiAocHJvY2VzcyxCdWZmZXIpe1xudmFyIG1zZyA9IHJlcXVpcmUoJ3Bha28vbGliL3psaWIvbWVzc2FnZXMnKTtcbnZhciB6c3RyZWFtID0gcmVxdWlyZSgncGFrby9saWIvemxpYi96c3RyZWFtJyk7XG52YXIgemxpYl9kZWZsYXRlID0gcmVxdWlyZSgncGFrby9saWIvemxpYi9kZWZsYXRlLmpzJyk7XG52YXIgemxpYl9pbmZsYXRlID0gcmVxdWlyZSgncGFrby9saWIvemxpYi9pbmZsYXRlLmpzJyk7XG52YXIgY29uc3RhbnRzID0gcmVxdWlyZSgncGFrby9saWIvemxpYi9jb25zdGFudHMnKTtcblxuZm9yICh2YXIga2V5IGluIGNvbnN0YW50cykge1xuICBleHBvcnRzW2tleV0gPSBjb25zdGFudHNba2V5XTtcbn1cblxuLy8gemxpYiBtb2Rlc1xuZXhwb3J0cy5OT05FID0gMDtcbmV4cG9ydHMuREVGTEFURSA9IDE7XG5leHBvcnRzLklORkxBVEUgPSAyO1xuZXhwb3J0cy5HWklQID0gMztcbmV4cG9ydHMuR1VOWklQID0gNDtcbmV4cG9ydHMuREVGTEFURVJBVyA9IDU7XG5leHBvcnRzLklORkxBVEVSQVcgPSA2O1xuZXhwb3J0cy5VTlpJUCA9IDc7XG5cbi8qKlxuICogRW11bGF0ZSBOb2RlJ3MgemxpYiBDKysgbGF5ZXIgZm9yIHVzZSBieSB0aGUgSlMgbGF5ZXIgaW4gaW5kZXguanNcbiAqL1xuZnVuY3Rpb24gWmxpYihtb2RlKSB7XG4gIGlmIChtb2RlIDwgZXhwb3J0cy5ERUZMQVRFIHx8IG1vZGUgPiBleHBvcnRzLlVOWklQKVxuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJCYWQgYXJndW1lbnRcIik7XG4gICAgXG4gIHRoaXMubW9kZSA9IG1vZGU7XG4gIHRoaXMuaW5pdF9kb25lID0gZmFsc2U7XG4gIHRoaXMud3JpdGVfaW5fcHJvZ3Jlc3MgPSBmYWxzZTtcbiAgdGhpcy5wZW5kaW5nX2Nsb3NlID0gZmFsc2U7XG4gIHRoaXMud2luZG93Qml0cyA9IDA7XG4gIHRoaXMubGV2ZWwgPSAwO1xuICB0aGlzLm1lbUxldmVsID0gMDtcbiAgdGhpcy5zdHJhdGVneSA9IDA7XG4gIHRoaXMuZGljdGlvbmFyeSA9IG51bGw7XG59XG5cblpsaWIucHJvdG90eXBlLmluaXQgPSBmdW5jdGlvbih3aW5kb3dCaXRzLCBsZXZlbCwgbWVtTGV2ZWwsIHN0cmF0ZWd5LCBkaWN0aW9uYXJ5KSB7XG4gIHRoaXMud2luZG93Qml0cyA9IHdpbmRvd0JpdHM7XG4gIHRoaXMubGV2ZWwgPSBsZXZlbDtcbiAgdGhpcy5tZW1MZXZlbCA9IG1lbUxldmVsO1xuICB0aGlzLnN0cmF0ZWd5ID0gc3RyYXRlZ3k7XG4gIC8vIGRpY3Rpb25hcnkgbm90IHN1cHBvcnRlZC5cbiAgXG4gIGlmICh0aGlzLm1vZGUgPT09IGV4cG9ydHMuR1pJUCB8fCB0aGlzLm1vZGUgPT09IGV4cG9ydHMuR1VOWklQKVxuICAgIHRoaXMud2luZG93Qml0cyArPSAxNjtcbiAgICBcbiAgaWYgKHRoaXMubW9kZSA9PT0gZXhwb3J0cy5VTlpJUClcbiAgICB0aGlzLndpbmRvd0JpdHMgKz0gMzI7XG4gICAgXG4gIGlmICh0aGlzLm1vZGUgPT09IGV4cG9ydHMuREVGTEFURVJBVyB8fCB0aGlzLm1vZGUgPT09IGV4cG9ydHMuSU5GTEFURVJBVylcbiAgICB0aGlzLndpbmRvd0JpdHMgPSAtdGhpcy53aW5kb3dCaXRzO1xuICAgIFxuICB0aGlzLnN0cm0gPSBuZXcgenN0cmVhbSgpO1xuICBcbiAgc3dpdGNoICh0aGlzLm1vZGUpIHtcbiAgICBjYXNlIGV4cG9ydHMuREVGTEFURTpcbiAgICBjYXNlIGV4cG9ydHMuR1pJUDpcbiAgICBjYXNlIGV4cG9ydHMuREVGTEFURVJBVzpcbiAgICAgIHZhciBzdGF0dXMgPSB6bGliX2RlZmxhdGUuZGVmbGF0ZUluaXQyKFxuICAgICAgICB0aGlzLnN0cm0sXG4gICAgICAgIHRoaXMubGV2ZWwsXG4gICAgICAgIGV4cG9ydHMuWl9ERUZMQVRFRCxcbiAgICAgICAgdGhpcy53aW5kb3dCaXRzLFxuICAgICAgICB0aGlzLm1lbUxldmVsLFxuICAgICAgICB0aGlzLnN0cmF0ZWd5XG4gICAgICApO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBleHBvcnRzLklORkxBVEU6XG4gICAgY2FzZSBleHBvcnRzLkdVTlpJUDpcbiAgICBjYXNlIGV4cG9ydHMuSU5GTEFURVJBVzpcbiAgICBjYXNlIGV4cG9ydHMuVU5aSVA6XG4gICAgICB2YXIgc3RhdHVzICA9IHpsaWJfaW5mbGF0ZS5pbmZsYXRlSW5pdDIoXG4gICAgICAgIHRoaXMuc3RybSxcbiAgICAgICAgdGhpcy53aW5kb3dCaXRzXG4gICAgICApO1xuICAgICAgYnJlYWs7XG4gICAgZGVmYXVsdDpcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIlVua25vd24gbW9kZSBcIiArIHRoaXMubW9kZSk7XG4gIH1cbiAgXG4gIGlmIChzdGF0dXMgIT09IGV4cG9ydHMuWl9PSykge1xuICAgIHRoaXMuX2Vycm9yKHN0YXR1cyk7XG4gICAgcmV0dXJuO1xuICB9XG4gIFxuICB0aGlzLndyaXRlX2luX3Byb2dyZXNzID0gZmFsc2U7XG4gIHRoaXMuaW5pdF9kb25lID0gdHJ1ZTtcbn07XG5cblpsaWIucHJvdG90eXBlLnBhcmFtcyA9IGZ1bmN0aW9uKCkge1xuICB0aHJvdyBuZXcgRXJyb3IoXCJkZWZsYXRlUGFyYW1zIE5vdCBzdXBwb3J0ZWRcIik7XG59O1xuXG5abGliLnByb3RvdHlwZS5fd3JpdGVDaGVjayA9IGZ1bmN0aW9uKCkge1xuICBpZiAoIXRoaXMuaW5pdF9kb25lKVxuICAgIHRocm93IG5ldyBFcnJvcihcIndyaXRlIGJlZm9yZSBpbml0XCIpO1xuICAgIFxuICBpZiAodGhpcy5tb2RlID09PSBleHBvcnRzLk5PTkUpXG4gICAgdGhyb3cgbmV3IEVycm9yKFwiYWxyZWFkeSBmaW5hbGl6ZWRcIik7XG4gICAgXG4gIGlmICh0aGlzLndyaXRlX2luX3Byb2dyZXNzKVxuICAgIHRocm93IG5ldyBFcnJvcihcIndyaXRlIGFscmVhZHkgaW4gcHJvZ3Jlc3NcIik7XG4gICAgXG4gIGlmICh0aGlzLnBlbmRpbmdfY2xvc2UpXG4gICAgdGhyb3cgbmV3IEVycm9yKFwiY2xvc2UgaXMgcGVuZGluZ1wiKTtcbn07XG5cblpsaWIucHJvdG90eXBlLndyaXRlID0gZnVuY3Rpb24oZmx1c2gsIGlucHV0LCBpbl9vZmYsIGluX2xlbiwgb3V0LCBvdXRfb2ZmLCBvdXRfbGVuKSB7ICAgIFxuICB0aGlzLl93cml0ZUNoZWNrKCk7XG4gIHRoaXMud3JpdGVfaW5fcHJvZ3Jlc3MgPSB0cnVlO1xuICBcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICBwcm9jZXNzLm5leHRUaWNrKGZ1bmN0aW9uKCkge1xuICAgIHNlbGYud3JpdGVfaW5fcHJvZ3Jlc3MgPSBmYWxzZTtcbiAgICB2YXIgcmVzID0gc2VsZi5fd3JpdGUoZmx1c2gsIGlucHV0LCBpbl9vZmYsIGluX2xlbiwgb3V0LCBvdXRfb2ZmLCBvdXRfbGVuKTtcbiAgICBzZWxmLmNhbGxiYWNrKHJlc1swXSwgcmVzWzFdKTtcbiAgICBcbiAgICBpZiAoc2VsZi5wZW5kaW5nX2Nsb3NlKVxuICAgICAgc2VsZi5jbG9zZSgpO1xuICB9KTtcbiAgXG4gIHJldHVybiB0aGlzO1xufTtcblxuLy8gc2V0IG1ldGhvZCBmb3IgTm9kZSBidWZmZXJzLCB1c2VkIGJ5IHBha29cbmZ1bmN0aW9uIGJ1ZmZlclNldChkYXRhLCBvZmZzZXQpIHtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBkYXRhLmxlbmd0aDsgaSsrKSB7XG4gICAgdGhpc1tvZmZzZXQgKyBpXSA9IGRhdGFbaV07XG4gIH1cbn1cblxuWmxpYi5wcm90b3R5cGUud3JpdGVTeW5jID0gZnVuY3Rpb24oZmx1c2gsIGlucHV0LCBpbl9vZmYsIGluX2xlbiwgb3V0LCBvdXRfb2ZmLCBvdXRfbGVuKSB7XG4gIHRoaXMuX3dyaXRlQ2hlY2soKTtcbiAgcmV0dXJuIHRoaXMuX3dyaXRlKGZsdXNoLCBpbnB1dCwgaW5fb2ZmLCBpbl9sZW4sIG91dCwgb3V0X29mZiwgb3V0X2xlbik7XG59O1xuXG5abGliLnByb3RvdHlwZS5fd3JpdGUgPSBmdW5jdGlvbihmbHVzaCwgaW5wdXQsIGluX29mZiwgaW5fbGVuLCBvdXQsIG91dF9vZmYsIG91dF9sZW4pIHtcbiAgdGhpcy53cml0ZV9pbl9wcm9ncmVzcyA9IHRydWU7XG4gIFxuICBpZiAoZmx1c2ggIT09IGV4cG9ydHMuWl9OT19GTFVTSCAmJlxuICAgICAgZmx1c2ggIT09IGV4cG9ydHMuWl9QQVJUSUFMX0ZMVVNIICYmXG4gICAgICBmbHVzaCAhPT0gZXhwb3J0cy5aX1NZTkNfRkxVU0ggJiZcbiAgICAgIGZsdXNoICE9PSBleHBvcnRzLlpfRlVMTF9GTFVTSCAmJlxuICAgICAgZmx1c2ggIT09IGV4cG9ydHMuWl9GSU5JU0ggJiZcbiAgICAgIGZsdXNoICE9PSBleHBvcnRzLlpfQkxPQ0spIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIGZsdXNoIHZhbHVlXCIpO1xuICB9XG4gIFxuICBpZiAoaW5wdXQgPT0gbnVsbCkge1xuICAgIGlucHV0ID0gbmV3IEJ1ZmZlcigwKTtcbiAgICBpbl9sZW4gPSAwO1xuICAgIGluX29mZiA9IDA7XG4gIH1cbiAgXG4gIGlmIChvdXQuX3NldClcbiAgICBvdXQuc2V0ID0gb3V0Ll9zZXQ7XG4gIGVsc2VcbiAgICBvdXQuc2V0ID0gYnVmZmVyU2V0O1xuICBcbiAgdmFyIHN0cm0gPSB0aGlzLnN0cm07XG4gIHN0cm0uYXZhaWxfaW4gPSBpbl9sZW47XG4gIHN0cm0uaW5wdXQgPSBpbnB1dDtcbiAgc3RybS5uZXh0X2luID0gaW5fb2ZmO1xuICBzdHJtLmF2YWlsX291dCA9IG91dF9sZW47XG4gIHN0cm0ub3V0cHV0ID0gb3V0O1xuICBzdHJtLm5leHRfb3V0ID0gb3V0X29mZjtcbiAgXG4gIHN3aXRjaCAodGhpcy5tb2RlKSB7XG4gICAgY2FzZSBleHBvcnRzLkRFRkxBVEU6XG4gICAgY2FzZSBleHBvcnRzLkdaSVA6XG4gICAgY2FzZSBleHBvcnRzLkRFRkxBVEVSQVc6XG4gICAgICB2YXIgc3RhdHVzID0gemxpYl9kZWZsYXRlLmRlZmxhdGUoc3RybSwgZmx1c2gpO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBleHBvcnRzLlVOWklQOlxuICAgIGNhc2UgZXhwb3J0cy5JTkZMQVRFOlxuICAgIGNhc2UgZXhwb3J0cy5HVU5aSVA6XG4gICAgY2FzZSBleHBvcnRzLklORkxBVEVSQVc6XG4gICAgICB2YXIgc3RhdHVzID0gemxpYl9pbmZsYXRlLmluZmxhdGUoc3RybSwgZmx1c2gpO1xuICAgICAgYnJlYWs7XG4gICAgZGVmYXVsdDpcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIlVua25vd24gbW9kZSBcIiArIHRoaXMubW9kZSk7XG4gIH1cbiAgXG4gIGlmIChzdGF0dXMgIT09IGV4cG9ydHMuWl9TVFJFQU1fRU5EICYmIHN0YXR1cyAhPT0gZXhwb3J0cy5aX09LKSB7XG4gICAgdGhpcy5fZXJyb3Ioc3RhdHVzKTtcbiAgfVxuICBcbiAgdGhpcy53cml0ZV9pbl9wcm9ncmVzcyA9IGZhbHNlO1xuICByZXR1cm4gW3N0cm0uYXZhaWxfaW4sIHN0cm0uYXZhaWxfb3V0XTtcbn07XG5cblpsaWIucHJvdG90eXBlLmNsb3NlID0gZnVuY3Rpb24oKSB7XG4gIGlmICh0aGlzLndyaXRlX2luX3Byb2dyZXNzKSB7XG4gICAgdGhpcy5wZW5kaW5nX2Nsb3NlID0gdHJ1ZTtcbiAgICByZXR1cm47XG4gIH1cbiAgXG4gIHRoaXMucGVuZGluZ19jbG9zZSA9IGZhbHNlO1xuICBcbiAgaWYgKHRoaXMubW9kZSA9PT0gZXhwb3J0cy5ERUZMQVRFIHx8IHRoaXMubW9kZSA9PT0gZXhwb3J0cy5HWklQIHx8IHRoaXMubW9kZSA9PT0gZXhwb3J0cy5ERUZMQVRFUkFXKSB7XG4gICAgemxpYl9kZWZsYXRlLmRlZmxhdGVFbmQodGhpcy5zdHJtKTtcbiAgfSBlbHNlIHtcbiAgICB6bGliX2luZmxhdGUuaW5mbGF0ZUVuZCh0aGlzLnN0cm0pO1xuICB9XG4gIFxuICB0aGlzLm1vZGUgPSBleHBvcnRzLk5PTkU7XG59O1xuXG5abGliLnByb3RvdHlwZS5yZXNldCA9IGZ1bmN0aW9uKCkge1xuICBzd2l0Y2ggKHRoaXMubW9kZSkge1xuICAgIGNhc2UgZXhwb3J0cy5ERUZMQVRFOlxuICAgIGNhc2UgZXhwb3J0cy5ERUZMQVRFUkFXOlxuICAgICAgdmFyIHN0YXR1cyA9IHpsaWJfZGVmbGF0ZS5kZWZsYXRlUmVzZXQodGhpcy5zdHJtKTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgZXhwb3J0cy5JTkZMQVRFOlxuICAgIGNhc2UgZXhwb3J0cy5JTkZMQVRFUkFXOlxuICAgICAgdmFyIHN0YXR1cyA9IHpsaWJfaW5mbGF0ZS5pbmZsYXRlUmVzZXQodGhpcy5zdHJtKTtcbiAgICAgIGJyZWFrO1xuICB9XG4gIFxuICBpZiAoc3RhdHVzICE9PSBleHBvcnRzLlpfT0spIHtcbiAgICB0aGlzLl9lcnJvcihzdGF0dXMpO1xuICB9XG59O1xuXG5abGliLnByb3RvdHlwZS5fZXJyb3IgPSBmdW5jdGlvbihzdGF0dXMpIHtcbiAgdGhpcy5vbmVycm9yKG1zZ1tzdGF0dXNdICsgJzogJyArIHRoaXMuc3RybS5tc2csIHN0YXR1cyk7XG4gIFxuICB0aGlzLndyaXRlX2luX3Byb2dyZXNzID0gZmFsc2U7XG4gIGlmICh0aGlzLnBlbmRpbmdfY2xvc2UpXG4gICAgdGhpcy5jbG9zZSgpO1xufTtcblxuZXhwb3J0cy5abGliID0gWmxpYjtcblxufSkuY2FsbCh0aGlzLHJlcXVpcmUoXCI3WUtJUGVcIikscmVxdWlyZShcImJ1ZmZlclwiKS5CdWZmZXIpIiwiKGZ1bmN0aW9uIChwcm9jZXNzLEJ1ZmZlcil7XG4vLyBDb3B5cmlnaHQgSm95ZW50LCBJbmMuIGFuZCBvdGhlciBOb2RlIGNvbnRyaWJ1dG9ycy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxuLy8gY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxuLy8gXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXG4vLyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXG4vLyBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0XG4vLyBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGVcbi8vIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkXG4vLyBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTXG4vLyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4vLyBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOXG4vLyBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSxcbi8vIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUlxuLy8gT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRVxuLy8gVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cblxudmFyIFRyYW5zZm9ybSA9IHJlcXVpcmUoJ19zdHJlYW1fdHJhbnNmb3JtJyk7XG5cbnZhciBiaW5kaW5nID0gcmVxdWlyZSgnLi9iaW5kaW5nJyk7XG52YXIgdXRpbCA9IHJlcXVpcmUoJ3V0aWwnKTtcbnZhciBhc3NlcnQgPSByZXF1aXJlKCdhc3NlcnQnKS5vaztcblxuLy8gemxpYiBkb2Vzbid0IHByb3ZpZGUgdGhlc2UsIHNvIGtsdWRnZSB0aGVtIGluIGZvbGxvd2luZyB0aGUgc2FtZVxuLy8gY29uc3QgbmFtaW5nIHNjaGVtZSB6bGliIHVzZXMuXG5iaW5kaW5nLlpfTUlOX1dJTkRPV0JJVFMgPSA4O1xuYmluZGluZy5aX01BWF9XSU5ET1dCSVRTID0gMTU7XG5iaW5kaW5nLlpfREVGQVVMVF9XSU5ET1dCSVRTID0gMTU7XG5cbi8vIGZld2VyIHRoYW4gNjQgYnl0ZXMgcGVyIGNodW5rIGlzIHN0dXBpZC5cbi8vIHRlY2huaWNhbGx5IGl0IGNvdWxkIHdvcmsgd2l0aCBhcyBmZXcgYXMgOCwgYnV0IGV2ZW4gNjQgYnl0ZXNcbi8vIGlzIGFic3VyZGx5IGxvdy4gIFVzdWFsbHkgYSBNQiBvciBtb3JlIGlzIGJlc3QuXG5iaW5kaW5nLlpfTUlOX0NIVU5LID0gNjQ7XG5iaW5kaW5nLlpfTUFYX0NIVU5LID0gSW5maW5pdHk7XG5iaW5kaW5nLlpfREVGQVVMVF9DSFVOSyA9ICgxNiAqIDEwMjQpO1xuXG5iaW5kaW5nLlpfTUlOX01FTUxFVkVMID0gMTtcbmJpbmRpbmcuWl9NQVhfTUVNTEVWRUwgPSA5O1xuYmluZGluZy5aX0RFRkFVTFRfTUVNTEVWRUwgPSA4O1xuXG5iaW5kaW5nLlpfTUlOX0xFVkVMID0gLTE7XG5iaW5kaW5nLlpfTUFYX0xFVkVMID0gOTtcbmJpbmRpbmcuWl9ERUZBVUxUX0xFVkVMID0gYmluZGluZy5aX0RFRkFVTFRfQ09NUFJFU1NJT047XG5cbi8vIGV4cG9zZSBhbGwgdGhlIHpsaWIgY29uc3RhbnRzXG5PYmplY3Qua2V5cyhiaW5kaW5nKS5mb3JFYWNoKGZ1bmN0aW9uKGspIHtcbiAgaWYgKGsubWF0Y2goL15aLykpIGV4cG9ydHNba10gPSBiaW5kaW5nW2tdO1xufSk7XG5cbi8vIHRyYW5zbGF0aW9uIHRhYmxlIGZvciByZXR1cm4gY29kZXMuXG5leHBvcnRzLmNvZGVzID0ge1xuICBaX09LOiBiaW5kaW5nLlpfT0ssXG4gIFpfU1RSRUFNX0VORDogYmluZGluZy5aX1NUUkVBTV9FTkQsXG4gIFpfTkVFRF9ESUNUOiBiaW5kaW5nLlpfTkVFRF9ESUNULFxuICBaX0VSUk5POiBiaW5kaW5nLlpfRVJSTk8sXG4gIFpfU1RSRUFNX0VSUk9SOiBiaW5kaW5nLlpfU1RSRUFNX0VSUk9SLFxuICBaX0RBVEFfRVJST1I6IGJpbmRpbmcuWl9EQVRBX0VSUk9SLFxuICBaX01FTV9FUlJPUjogYmluZGluZy5aX01FTV9FUlJPUixcbiAgWl9CVUZfRVJST1I6IGJpbmRpbmcuWl9CVUZfRVJST1IsXG4gIFpfVkVSU0lPTl9FUlJPUjogYmluZGluZy5aX1ZFUlNJT05fRVJST1Jcbn07XG5cbk9iamVjdC5rZXlzKGV4cG9ydHMuY29kZXMpLmZvckVhY2goZnVuY3Rpb24oaykge1xuICBleHBvcnRzLmNvZGVzW2V4cG9ydHMuY29kZXNba11dID0gaztcbn0pO1xuXG5leHBvcnRzLkRlZmxhdGUgPSBEZWZsYXRlO1xuZXhwb3J0cy5JbmZsYXRlID0gSW5mbGF0ZTtcbmV4cG9ydHMuR3ppcCA9IEd6aXA7XG5leHBvcnRzLkd1bnppcCA9IEd1bnppcDtcbmV4cG9ydHMuRGVmbGF0ZVJhdyA9IERlZmxhdGVSYXc7XG5leHBvcnRzLkluZmxhdGVSYXcgPSBJbmZsYXRlUmF3O1xuZXhwb3J0cy5VbnppcCA9IFVuemlwO1xuXG5leHBvcnRzLmNyZWF0ZURlZmxhdGUgPSBmdW5jdGlvbihvKSB7XG4gIHJldHVybiBuZXcgRGVmbGF0ZShvKTtcbn07XG5cbmV4cG9ydHMuY3JlYXRlSW5mbGF0ZSA9IGZ1bmN0aW9uKG8pIHtcbiAgcmV0dXJuIG5ldyBJbmZsYXRlKG8pO1xufTtcblxuZXhwb3J0cy5jcmVhdGVEZWZsYXRlUmF3ID0gZnVuY3Rpb24obykge1xuICByZXR1cm4gbmV3IERlZmxhdGVSYXcobyk7XG59O1xuXG5leHBvcnRzLmNyZWF0ZUluZmxhdGVSYXcgPSBmdW5jdGlvbihvKSB7XG4gIHJldHVybiBuZXcgSW5mbGF0ZVJhdyhvKTtcbn07XG5cbmV4cG9ydHMuY3JlYXRlR3ppcCA9IGZ1bmN0aW9uKG8pIHtcbiAgcmV0dXJuIG5ldyBHemlwKG8pO1xufTtcblxuZXhwb3J0cy5jcmVhdGVHdW56aXAgPSBmdW5jdGlvbihvKSB7XG4gIHJldHVybiBuZXcgR3VuemlwKG8pO1xufTtcblxuZXhwb3J0cy5jcmVhdGVVbnppcCA9IGZ1bmN0aW9uKG8pIHtcbiAgcmV0dXJuIG5ldyBVbnppcChvKTtcbn07XG5cblxuLy8gQ29udmVuaWVuY2UgbWV0aG9kcy5cbi8vIGNvbXByZXNzL2RlY29tcHJlc3MgYSBzdHJpbmcgb3IgYnVmZmVyIGluIG9uZSBzdGVwLlxuZXhwb3J0cy5kZWZsYXRlID0gZnVuY3Rpb24oYnVmZmVyLCBvcHRzLCBjYWxsYmFjaykge1xuICBpZiAodHlwZW9mIG9wdHMgPT09ICdmdW5jdGlvbicpIHtcbiAgICBjYWxsYmFjayA9IG9wdHM7XG4gICAgb3B0cyA9IHt9O1xuICB9XG4gIHJldHVybiB6bGliQnVmZmVyKG5ldyBEZWZsYXRlKG9wdHMpLCBidWZmZXIsIGNhbGxiYWNrKTtcbn07XG5cbmV4cG9ydHMuZGVmbGF0ZVN5bmMgPSBmdW5jdGlvbihidWZmZXIsIG9wdHMpIHtcbiAgcmV0dXJuIHpsaWJCdWZmZXJTeW5jKG5ldyBEZWZsYXRlKG9wdHMpLCBidWZmZXIpO1xufTtcblxuZXhwb3J0cy5nemlwID0gZnVuY3Rpb24oYnVmZmVyLCBvcHRzLCBjYWxsYmFjaykge1xuICBpZiAodHlwZW9mIG9wdHMgPT09ICdmdW5jdGlvbicpIHtcbiAgICBjYWxsYmFjayA9IG9wdHM7XG4gICAgb3B0cyA9IHt9O1xuICB9XG4gIHJldHVybiB6bGliQnVmZmVyKG5ldyBHemlwKG9wdHMpLCBidWZmZXIsIGNhbGxiYWNrKTtcbn07XG5cbmV4cG9ydHMuZ3ppcFN5bmMgPSBmdW5jdGlvbihidWZmZXIsIG9wdHMpIHtcbiAgcmV0dXJuIHpsaWJCdWZmZXJTeW5jKG5ldyBHemlwKG9wdHMpLCBidWZmZXIpO1xufTtcblxuZXhwb3J0cy5kZWZsYXRlUmF3ID0gZnVuY3Rpb24oYnVmZmVyLCBvcHRzLCBjYWxsYmFjaykge1xuICBpZiAodHlwZW9mIG9wdHMgPT09ICdmdW5jdGlvbicpIHtcbiAgICBjYWxsYmFjayA9IG9wdHM7XG4gICAgb3B0cyA9IHt9O1xuICB9XG4gIHJldHVybiB6bGliQnVmZmVyKG5ldyBEZWZsYXRlUmF3KG9wdHMpLCBidWZmZXIsIGNhbGxiYWNrKTtcbn07XG5cbmV4cG9ydHMuZGVmbGF0ZVJhd1N5bmMgPSBmdW5jdGlvbihidWZmZXIsIG9wdHMpIHtcbiAgcmV0dXJuIHpsaWJCdWZmZXJTeW5jKG5ldyBEZWZsYXRlUmF3KG9wdHMpLCBidWZmZXIpO1xufTtcblxuZXhwb3J0cy51bnppcCA9IGZ1bmN0aW9uKGJ1ZmZlciwgb3B0cywgY2FsbGJhY2spIHtcbiAgaWYgKHR5cGVvZiBvcHRzID09PSAnZnVuY3Rpb24nKSB7XG4gICAgY2FsbGJhY2sgPSBvcHRzO1xuICAgIG9wdHMgPSB7fTtcbiAgfVxuICByZXR1cm4gemxpYkJ1ZmZlcihuZXcgVW56aXAob3B0cyksIGJ1ZmZlciwgY2FsbGJhY2spO1xufTtcblxuZXhwb3J0cy51bnppcFN5bmMgPSBmdW5jdGlvbihidWZmZXIsIG9wdHMpIHtcbiAgcmV0dXJuIHpsaWJCdWZmZXJTeW5jKG5ldyBVbnppcChvcHRzKSwgYnVmZmVyKTtcbn07XG5cbmV4cG9ydHMuaW5mbGF0ZSA9IGZ1bmN0aW9uKGJ1ZmZlciwgb3B0cywgY2FsbGJhY2spIHtcbiAgaWYgKHR5cGVvZiBvcHRzID09PSAnZnVuY3Rpb24nKSB7XG4gICAgY2FsbGJhY2sgPSBvcHRzO1xuICAgIG9wdHMgPSB7fTtcbiAgfVxuICByZXR1cm4gemxpYkJ1ZmZlcihuZXcgSW5mbGF0ZShvcHRzKSwgYnVmZmVyLCBjYWxsYmFjayk7XG59O1xuXG5leHBvcnRzLmluZmxhdGVTeW5jID0gZnVuY3Rpb24oYnVmZmVyLCBvcHRzKSB7XG4gIHJldHVybiB6bGliQnVmZmVyU3luYyhuZXcgSW5mbGF0ZShvcHRzKSwgYnVmZmVyKTtcbn07XG5cbmV4cG9ydHMuZ3VuemlwID0gZnVuY3Rpb24oYnVmZmVyLCBvcHRzLCBjYWxsYmFjaykge1xuICBpZiAodHlwZW9mIG9wdHMgPT09ICdmdW5jdGlvbicpIHtcbiAgICBjYWxsYmFjayA9IG9wdHM7XG4gICAgb3B0cyA9IHt9O1xuICB9XG4gIHJldHVybiB6bGliQnVmZmVyKG5ldyBHdW56aXAob3B0cyksIGJ1ZmZlciwgY2FsbGJhY2spO1xufTtcblxuZXhwb3J0cy5ndW56aXBTeW5jID0gZnVuY3Rpb24oYnVmZmVyLCBvcHRzKSB7XG4gIHJldHVybiB6bGliQnVmZmVyU3luYyhuZXcgR3VuemlwKG9wdHMpLCBidWZmZXIpO1xufTtcblxuZXhwb3J0cy5pbmZsYXRlUmF3ID0gZnVuY3Rpb24oYnVmZmVyLCBvcHRzLCBjYWxsYmFjaykge1xuICBpZiAodHlwZW9mIG9wdHMgPT09ICdmdW5jdGlvbicpIHtcbiAgICBjYWxsYmFjayA9IG9wdHM7XG4gICAgb3B0cyA9IHt9O1xuICB9XG4gIHJldHVybiB6bGliQnVmZmVyKG5ldyBJbmZsYXRlUmF3KG9wdHMpLCBidWZmZXIsIGNhbGxiYWNrKTtcbn07XG5cbmV4cG9ydHMuaW5mbGF0ZVJhd1N5bmMgPSBmdW5jdGlvbihidWZmZXIsIG9wdHMpIHtcbiAgcmV0dXJuIHpsaWJCdWZmZXJTeW5jKG5ldyBJbmZsYXRlUmF3KG9wdHMpLCBidWZmZXIpO1xufTtcblxuZnVuY3Rpb24gemxpYkJ1ZmZlcihlbmdpbmUsIGJ1ZmZlciwgY2FsbGJhY2spIHtcbiAgdmFyIGJ1ZmZlcnMgPSBbXTtcbiAgdmFyIG5yZWFkID0gMDtcblxuICBlbmdpbmUub24oJ2Vycm9yJywgb25FcnJvcik7XG4gIGVuZ2luZS5vbignZW5kJywgb25FbmQpO1xuXG4gIGVuZ2luZS5lbmQoYnVmZmVyKTtcbiAgZmxvdygpO1xuXG4gIGZ1bmN0aW9uIGZsb3coKSB7XG4gICAgdmFyIGNodW5rO1xuICAgIHdoaWxlIChudWxsICE9PSAoY2h1bmsgPSBlbmdpbmUucmVhZCgpKSkge1xuICAgICAgYnVmZmVycy5wdXNoKGNodW5rKTtcbiAgICAgIG5yZWFkICs9IGNodW5rLmxlbmd0aDtcbiAgICB9XG4gICAgZW5naW5lLm9uY2UoJ3JlYWRhYmxlJywgZmxvdyk7XG4gIH1cblxuICBmdW5jdGlvbiBvbkVycm9yKGVycikge1xuICAgIGVuZ2luZS5yZW1vdmVMaXN0ZW5lcignZW5kJywgb25FbmQpO1xuICAgIGVuZ2luZS5yZW1vdmVMaXN0ZW5lcigncmVhZGFibGUnLCBmbG93KTtcbiAgICBjYWxsYmFjayhlcnIpO1xuICB9XG5cbiAgZnVuY3Rpb24gb25FbmQoKSB7XG4gICAgdmFyIGJ1ZiA9IEJ1ZmZlci5jb25jYXQoYnVmZmVycywgbnJlYWQpO1xuICAgIGJ1ZmZlcnMgPSBbXTtcbiAgICBjYWxsYmFjayhudWxsLCBidWYpO1xuICAgIGVuZ2luZS5jbG9zZSgpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHpsaWJCdWZmZXJTeW5jKGVuZ2luZSwgYnVmZmVyKSB7XG4gIGlmICh0eXBlb2YgYnVmZmVyID09PSAnc3RyaW5nJylcbiAgICBidWZmZXIgPSBuZXcgQnVmZmVyKGJ1ZmZlcik7XG4gIGlmICghQnVmZmVyLmlzQnVmZmVyKGJ1ZmZlcikpXG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignTm90IGEgc3RyaW5nIG9yIGJ1ZmZlcicpO1xuXG4gIHZhciBmbHVzaEZsYWcgPSBiaW5kaW5nLlpfRklOSVNIO1xuXG4gIHJldHVybiBlbmdpbmUuX3Byb2Nlc3NDaHVuayhidWZmZXIsIGZsdXNoRmxhZyk7XG59XG5cbi8vIGdlbmVyaWMgemxpYlxuLy8gbWluaW1hbCAyLWJ5dGUgaGVhZGVyXG5mdW5jdGlvbiBEZWZsYXRlKG9wdHMpIHtcbiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIERlZmxhdGUpKSByZXR1cm4gbmV3IERlZmxhdGUob3B0cyk7XG4gIFpsaWIuY2FsbCh0aGlzLCBvcHRzLCBiaW5kaW5nLkRFRkxBVEUpO1xufVxuXG5mdW5jdGlvbiBJbmZsYXRlKG9wdHMpIHtcbiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIEluZmxhdGUpKSByZXR1cm4gbmV3IEluZmxhdGUob3B0cyk7XG4gIFpsaWIuY2FsbCh0aGlzLCBvcHRzLCBiaW5kaW5nLklORkxBVEUpO1xufVxuXG5cblxuLy8gZ3ppcCAtIGJpZ2dlciBoZWFkZXIsIHNhbWUgZGVmbGF0ZSBjb21wcmVzc2lvblxuZnVuY3Rpb24gR3ppcChvcHRzKSB7XG4gIGlmICghKHRoaXMgaW5zdGFuY2VvZiBHemlwKSkgcmV0dXJuIG5ldyBHemlwKG9wdHMpO1xuICBabGliLmNhbGwodGhpcywgb3B0cywgYmluZGluZy5HWklQKTtcbn1cblxuZnVuY3Rpb24gR3VuemlwKG9wdHMpIHtcbiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIEd1bnppcCkpIHJldHVybiBuZXcgR3VuemlwKG9wdHMpO1xuICBabGliLmNhbGwodGhpcywgb3B0cywgYmluZGluZy5HVU5aSVApO1xufVxuXG5cblxuLy8gcmF3IC0gbm8gaGVhZGVyXG5mdW5jdGlvbiBEZWZsYXRlUmF3KG9wdHMpIHtcbiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIERlZmxhdGVSYXcpKSByZXR1cm4gbmV3IERlZmxhdGVSYXcob3B0cyk7XG4gIFpsaWIuY2FsbCh0aGlzLCBvcHRzLCBiaW5kaW5nLkRFRkxBVEVSQVcpO1xufVxuXG5mdW5jdGlvbiBJbmZsYXRlUmF3KG9wdHMpIHtcbiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIEluZmxhdGVSYXcpKSByZXR1cm4gbmV3IEluZmxhdGVSYXcob3B0cyk7XG4gIFpsaWIuY2FsbCh0aGlzLCBvcHRzLCBiaW5kaW5nLklORkxBVEVSQVcpO1xufVxuXG5cbi8vIGF1dG8tZGV0ZWN0IGhlYWRlci5cbmZ1bmN0aW9uIFVuemlwKG9wdHMpIHtcbiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIFVuemlwKSkgcmV0dXJuIG5ldyBVbnppcChvcHRzKTtcbiAgWmxpYi5jYWxsKHRoaXMsIG9wdHMsIGJpbmRpbmcuVU5aSVApO1xufVxuXG5cbi8vIHRoZSBabGliIGNsYXNzIHRoZXkgYWxsIGluaGVyaXQgZnJvbVxuLy8gVGhpcyB0aGluZyBtYW5hZ2VzIHRoZSBxdWV1ZSBvZiByZXF1ZXN0cywgYW5kIHJldHVybnNcbi8vIHRydWUgb3IgZmFsc2UgaWYgdGhlcmUgaXMgYW55dGhpbmcgaW4gdGhlIHF1ZXVlIHdoZW5cbi8vIHlvdSBjYWxsIHRoZSAud3JpdGUoKSBtZXRob2QuXG5cbmZ1bmN0aW9uIFpsaWIob3B0cywgbW9kZSkge1xuICB0aGlzLl9vcHRzID0gb3B0cyA9IG9wdHMgfHwge307XG4gIHRoaXMuX2NodW5rU2l6ZSA9IG9wdHMuY2h1bmtTaXplIHx8IGV4cG9ydHMuWl9ERUZBVUxUX0NIVU5LO1xuXG4gIFRyYW5zZm9ybS5jYWxsKHRoaXMsIG9wdHMpO1xuXG4gIGlmIChvcHRzLmZsdXNoKSB7XG4gICAgaWYgKG9wdHMuZmx1c2ggIT09IGJpbmRpbmcuWl9OT19GTFVTSCAmJlxuICAgICAgICBvcHRzLmZsdXNoICE9PSBiaW5kaW5nLlpfUEFSVElBTF9GTFVTSCAmJlxuICAgICAgICBvcHRzLmZsdXNoICE9PSBiaW5kaW5nLlpfU1lOQ19GTFVTSCAmJlxuICAgICAgICBvcHRzLmZsdXNoICE9PSBiaW5kaW5nLlpfRlVMTF9GTFVTSCAmJlxuICAgICAgICBvcHRzLmZsdXNoICE9PSBiaW5kaW5nLlpfRklOSVNIICYmXG4gICAgICAgIG9wdHMuZmx1c2ggIT09IGJpbmRpbmcuWl9CTE9DSykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGZsdXNoIGZsYWc6ICcgKyBvcHRzLmZsdXNoKTtcbiAgICB9XG4gIH1cbiAgdGhpcy5fZmx1c2hGbGFnID0gb3B0cy5mbHVzaCB8fCBiaW5kaW5nLlpfTk9fRkxVU0g7XG5cbiAgaWYgKG9wdHMuY2h1bmtTaXplKSB7XG4gICAgaWYgKG9wdHMuY2h1bmtTaXplIDwgZXhwb3J0cy5aX01JTl9DSFVOSyB8fFxuICAgICAgICBvcHRzLmNodW5rU2l6ZSA+IGV4cG9ydHMuWl9NQVhfQ0hVTkspIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBjaHVuayBzaXplOiAnICsgb3B0cy5jaHVua1NpemUpO1xuICAgIH1cbiAgfVxuXG4gIGlmIChvcHRzLndpbmRvd0JpdHMpIHtcbiAgICBpZiAob3B0cy53aW5kb3dCaXRzIDwgZXhwb3J0cy5aX01JTl9XSU5ET1dCSVRTIHx8XG4gICAgICAgIG9wdHMud2luZG93Qml0cyA+IGV4cG9ydHMuWl9NQVhfV0lORE9XQklUUykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIHdpbmRvd0JpdHM6ICcgKyBvcHRzLndpbmRvd0JpdHMpO1xuICAgIH1cbiAgfVxuXG4gIGlmIChvcHRzLmxldmVsKSB7XG4gICAgaWYgKG9wdHMubGV2ZWwgPCBleHBvcnRzLlpfTUlOX0xFVkVMIHx8XG4gICAgICAgIG9wdHMubGV2ZWwgPiBleHBvcnRzLlpfTUFYX0xFVkVMKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgY29tcHJlc3Npb24gbGV2ZWw6ICcgKyBvcHRzLmxldmVsKTtcbiAgICB9XG4gIH1cblxuICBpZiAob3B0cy5tZW1MZXZlbCkge1xuICAgIGlmIChvcHRzLm1lbUxldmVsIDwgZXhwb3J0cy5aX01JTl9NRU1MRVZFTCB8fFxuICAgICAgICBvcHRzLm1lbUxldmVsID4gZXhwb3J0cy5aX01BWF9NRU1MRVZFTCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIG1lbUxldmVsOiAnICsgb3B0cy5tZW1MZXZlbCk7XG4gICAgfVxuICB9XG5cbiAgaWYgKG9wdHMuc3RyYXRlZ3kpIHtcbiAgICBpZiAob3B0cy5zdHJhdGVneSAhPSBleHBvcnRzLlpfRklMVEVSRUQgJiZcbiAgICAgICAgb3B0cy5zdHJhdGVneSAhPSBleHBvcnRzLlpfSFVGRk1BTl9PTkxZICYmXG4gICAgICAgIG9wdHMuc3RyYXRlZ3kgIT0gZXhwb3J0cy5aX1JMRSAmJlxuICAgICAgICBvcHRzLnN0cmF0ZWd5ICE9IGV4cG9ydHMuWl9GSVhFRCAmJlxuICAgICAgICBvcHRzLnN0cmF0ZWd5ICE9IGV4cG9ydHMuWl9ERUZBVUxUX1NUUkFURUdZKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgc3RyYXRlZ3k6ICcgKyBvcHRzLnN0cmF0ZWd5KTtcbiAgICB9XG4gIH1cblxuICBpZiAob3B0cy5kaWN0aW9uYXJ5KSB7XG4gICAgaWYgKCFCdWZmZXIuaXNCdWZmZXIob3B0cy5kaWN0aW9uYXJ5KSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGRpY3Rpb25hcnk6IGl0IHNob3VsZCBiZSBhIEJ1ZmZlciBpbnN0YW5jZScpO1xuICAgIH1cbiAgfVxuXG4gIHRoaXMuX2JpbmRpbmcgPSBuZXcgYmluZGluZy5abGliKG1vZGUpO1xuXG4gIHZhciBzZWxmID0gdGhpcztcbiAgdGhpcy5faGFkRXJyb3IgPSBmYWxzZTtcbiAgdGhpcy5fYmluZGluZy5vbmVycm9yID0gZnVuY3Rpb24obWVzc2FnZSwgZXJybm8pIHtcbiAgICAvLyB0aGVyZSBpcyBubyB3YXkgdG8gY2xlYW5seSByZWNvdmVyLlxuICAgIC8vIGNvbnRpbnVpbmcgb25seSBvYnNjdXJlcyBwcm9ibGVtcy5cbiAgICBzZWxmLl9iaW5kaW5nID0gbnVsbDtcbiAgICBzZWxmLl9oYWRFcnJvciA9IHRydWU7XG5cbiAgICB2YXIgZXJyb3IgPSBuZXcgRXJyb3IobWVzc2FnZSk7XG4gICAgZXJyb3IuZXJybm8gPSBlcnJubztcbiAgICBlcnJvci5jb2RlID0gZXhwb3J0cy5jb2Rlc1tlcnJub107XG4gICAgc2VsZi5lbWl0KCdlcnJvcicsIGVycm9yKTtcbiAgfTtcblxuICB2YXIgbGV2ZWwgPSBleHBvcnRzLlpfREVGQVVMVF9DT01QUkVTU0lPTjtcbiAgaWYgKHR5cGVvZiBvcHRzLmxldmVsID09PSAnbnVtYmVyJykgbGV2ZWwgPSBvcHRzLmxldmVsO1xuXG4gIHZhciBzdHJhdGVneSA9IGV4cG9ydHMuWl9ERUZBVUxUX1NUUkFURUdZO1xuICBpZiAodHlwZW9mIG9wdHMuc3RyYXRlZ3kgPT09ICdudW1iZXInKSBzdHJhdGVneSA9IG9wdHMuc3RyYXRlZ3k7XG5cbiAgdGhpcy5fYmluZGluZy5pbml0KG9wdHMud2luZG93Qml0cyB8fCBleHBvcnRzLlpfREVGQVVMVF9XSU5ET1dCSVRTLFxuICAgICAgICAgICAgICAgICAgICAgbGV2ZWwsXG4gICAgICAgICAgICAgICAgICAgICBvcHRzLm1lbUxldmVsIHx8IGV4cG9ydHMuWl9ERUZBVUxUX01FTUxFVkVMLFxuICAgICAgICAgICAgICAgICAgICAgc3RyYXRlZ3ksXG4gICAgICAgICAgICAgICAgICAgICBvcHRzLmRpY3Rpb25hcnkpO1xuXG4gIHRoaXMuX2J1ZmZlciA9IG5ldyBCdWZmZXIodGhpcy5fY2h1bmtTaXplKTtcbiAgdGhpcy5fb2Zmc2V0ID0gMDtcbiAgdGhpcy5fY2xvc2VkID0gZmFsc2U7XG4gIHRoaXMuX2xldmVsID0gbGV2ZWw7XG4gIHRoaXMuX3N0cmF0ZWd5ID0gc3RyYXRlZ3k7XG5cbiAgdGhpcy5vbmNlKCdlbmQnLCB0aGlzLmNsb3NlKTtcbn1cblxudXRpbC5pbmhlcml0cyhabGliLCBUcmFuc2Zvcm0pO1xuXG5abGliLnByb3RvdHlwZS5wYXJhbXMgPSBmdW5jdGlvbihsZXZlbCwgc3RyYXRlZ3ksIGNhbGxiYWNrKSB7XG4gIGlmIChsZXZlbCA8IGV4cG9ydHMuWl9NSU5fTEVWRUwgfHxcbiAgICAgIGxldmVsID4gZXhwb3J0cy5aX01BWF9MRVZFTCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdJbnZhbGlkIGNvbXByZXNzaW9uIGxldmVsOiAnICsgbGV2ZWwpO1xuICB9XG4gIGlmIChzdHJhdGVneSAhPSBleHBvcnRzLlpfRklMVEVSRUQgJiZcbiAgICAgIHN0cmF0ZWd5ICE9IGV4cG9ydHMuWl9IVUZGTUFOX09OTFkgJiZcbiAgICAgIHN0cmF0ZWd5ICE9IGV4cG9ydHMuWl9STEUgJiZcbiAgICAgIHN0cmF0ZWd5ICE9IGV4cG9ydHMuWl9GSVhFRCAmJlxuICAgICAgc3RyYXRlZ3kgIT0gZXhwb3J0cy5aX0RFRkFVTFRfU1RSQVRFR1kpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdJbnZhbGlkIHN0cmF0ZWd5OiAnICsgc3RyYXRlZ3kpO1xuICB9XG5cbiAgaWYgKHRoaXMuX2xldmVsICE9PSBsZXZlbCB8fCB0aGlzLl9zdHJhdGVneSAhPT0gc3RyYXRlZ3kpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgdGhpcy5mbHVzaChiaW5kaW5nLlpfU1lOQ19GTFVTSCwgZnVuY3Rpb24oKSB7XG4gICAgICBzZWxmLl9iaW5kaW5nLnBhcmFtcyhsZXZlbCwgc3RyYXRlZ3kpO1xuICAgICAgaWYgKCFzZWxmLl9oYWRFcnJvcikge1xuICAgICAgICBzZWxmLl9sZXZlbCA9IGxldmVsO1xuICAgICAgICBzZWxmLl9zdHJhdGVneSA9IHN0cmF0ZWd5O1xuICAgICAgICBpZiAoY2FsbGJhY2spIGNhbGxiYWNrKCk7XG4gICAgICB9XG4gICAgfSk7XG4gIH0gZWxzZSB7XG4gICAgcHJvY2Vzcy5uZXh0VGljayhjYWxsYmFjayk7XG4gIH1cbn07XG5cblpsaWIucHJvdG90eXBlLnJlc2V0ID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzLl9iaW5kaW5nLnJlc2V0KCk7XG59O1xuXG4vLyBUaGlzIGlzIHRoZSBfZmx1c2ggZnVuY3Rpb24gY2FsbGVkIGJ5IHRoZSB0cmFuc2Zvcm0gY2xhc3MsXG4vLyBpbnRlcm5hbGx5LCB3aGVuIHRoZSBsYXN0IGNodW5rIGhhcyBiZWVuIHdyaXR0ZW4uXG5abGliLnByb3RvdHlwZS5fZmx1c2ggPSBmdW5jdGlvbihjYWxsYmFjaykge1xuICB0aGlzLl90cmFuc2Zvcm0obmV3IEJ1ZmZlcigwKSwgJycsIGNhbGxiYWNrKTtcbn07XG5cblpsaWIucHJvdG90eXBlLmZsdXNoID0gZnVuY3Rpb24oa2luZCwgY2FsbGJhY2spIHtcbiAgdmFyIHdzID0gdGhpcy5fd3JpdGFibGVTdGF0ZTtcblxuICBpZiAodHlwZW9mIGtpbmQgPT09ICdmdW5jdGlvbicgfHwgKGtpbmQgPT09IHZvaWQgMCAmJiAhY2FsbGJhY2spKSB7XG4gICAgY2FsbGJhY2sgPSBraW5kO1xuICAgIGtpbmQgPSBiaW5kaW5nLlpfRlVMTF9GTFVTSDtcbiAgfVxuXG4gIGlmICh3cy5lbmRlZCkge1xuICAgIGlmIChjYWxsYmFjaylcbiAgICAgIHByb2Nlc3MubmV4dFRpY2soY2FsbGJhY2spO1xuICB9IGVsc2UgaWYgKHdzLmVuZGluZykge1xuICAgIGlmIChjYWxsYmFjaylcbiAgICAgIHRoaXMub25jZSgnZW5kJywgY2FsbGJhY2spO1xuICB9IGVsc2UgaWYgKHdzLm5lZWREcmFpbikge1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICB0aGlzLm9uY2UoJ2RyYWluJywgZnVuY3Rpb24oKSB7XG4gICAgICBzZWxmLmZsdXNoKGNhbGxiYWNrKTtcbiAgICB9KTtcbiAgfSBlbHNlIHtcbiAgICB0aGlzLl9mbHVzaEZsYWcgPSBraW5kO1xuICAgIHRoaXMud3JpdGUobmV3IEJ1ZmZlcigwKSwgJycsIGNhbGxiYWNrKTtcbiAgfVxufTtcblxuWmxpYi5wcm90b3R5cGUuY2xvc2UgPSBmdW5jdGlvbihjYWxsYmFjaykge1xuICBpZiAoY2FsbGJhY2spXG4gICAgcHJvY2Vzcy5uZXh0VGljayhjYWxsYmFjayk7XG5cbiAgaWYgKHRoaXMuX2Nsb3NlZClcbiAgICByZXR1cm47XG5cbiAgdGhpcy5fY2xvc2VkID0gdHJ1ZTtcblxuICB0aGlzLl9iaW5kaW5nLmNsb3NlKCk7XG5cbiAgdmFyIHNlbGYgPSB0aGlzO1xuICBwcm9jZXNzLm5leHRUaWNrKGZ1bmN0aW9uKCkge1xuICAgIHNlbGYuZW1pdCgnY2xvc2UnKTtcbiAgfSk7XG59O1xuXG5abGliLnByb3RvdHlwZS5fdHJhbnNmb3JtID0gZnVuY3Rpb24oY2h1bmssIGVuY29kaW5nLCBjYikge1xuICB2YXIgZmx1c2hGbGFnO1xuICB2YXIgd3MgPSB0aGlzLl93cml0YWJsZVN0YXRlO1xuICB2YXIgZW5kaW5nID0gd3MuZW5kaW5nIHx8IHdzLmVuZGVkO1xuICB2YXIgbGFzdCA9IGVuZGluZyAmJiAoIWNodW5rIHx8IHdzLmxlbmd0aCA9PT0gY2h1bmsubGVuZ3RoKTtcblxuICBpZiAoIWNodW5rID09PSBudWxsICYmICFCdWZmZXIuaXNCdWZmZXIoY2h1bmspKVxuICAgIHJldHVybiBjYihuZXcgRXJyb3IoJ2ludmFsaWQgaW5wdXQnKSk7XG5cbiAgLy8gSWYgaXQncyB0aGUgbGFzdCBjaHVuaywgb3IgYSBmaW5hbCBmbHVzaCwgd2UgdXNlIHRoZSBaX0ZJTklTSCBmbHVzaCBmbGFnLlxuICAvLyBJZiBpdCdzIGV4cGxpY2l0bHkgZmx1c2hpbmcgYXQgc29tZSBvdGhlciB0aW1lLCB0aGVuIHdlIHVzZVxuICAvLyBaX0ZVTExfRkxVU0guIE90aGVyd2lzZSwgdXNlIFpfTk9fRkxVU0ggZm9yIG1heGltdW0gY29tcHJlc3Npb25cbiAgLy8gZ29vZG5lc3MuXG4gIGlmIChsYXN0KVxuICAgIGZsdXNoRmxhZyA9IGJpbmRpbmcuWl9GSU5JU0g7XG4gIGVsc2Uge1xuICAgIGZsdXNoRmxhZyA9IHRoaXMuX2ZsdXNoRmxhZztcbiAgICAvLyBvbmNlIHdlJ3ZlIGZsdXNoZWQgdGhlIGxhc3Qgb2YgdGhlIHF1ZXVlLCBzdG9wIGZsdXNoaW5nIGFuZFxuICAgIC8vIGdvIGJhY2sgdG8gdGhlIG5vcm1hbCBiZWhhdmlvci5cbiAgICBpZiAoY2h1bmsubGVuZ3RoID49IHdzLmxlbmd0aCkge1xuICAgICAgdGhpcy5fZmx1c2hGbGFnID0gdGhpcy5fb3B0cy5mbHVzaCB8fCBiaW5kaW5nLlpfTk9fRkxVU0g7XG4gICAgfVxuICB9XG5cbiAgdmFyIHNlbGYgPSB0aGlzO1xuICB0aGlzLl9wcm9jZXNzQ2h1bmsoY2h1bmssIGZsdXNoRmxhZywgY2IpO1xufTtcblxuWmxpYi5wcm90b3R5cGUuX3Byb2Nlc3NDaHVuayA9IGZ1bmN0aW9uKGNodW5rLCBmbHVzaEZsYWcsIGNiKSB7XG4gIHZhciBhdmFpbEluQmVmb3JlID0gY2h1bmsgJiYgY2h1bmsubGVuZ3RoO1xuICB2YXIgYXZhaWxPdXRCZWZvcmUgPSB0aGlzLl9jaHVua1NpemUgLSB0aGlzLl9vZmZzZXQ7XG4gIHZhciBpbk9mZiA9IDA7XG5cbiAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gIHZhciBhc3luYyA9IHR5cGVvZiBjYiA9PT0gJ2Z1bmN0aW9uJztcblxuICBpZiAoIWFzeW5jKSB7XG4gICAgdmFyIGJ1ZmZlcnMgPSBbXTtcbiAgICB2YXIgbnJlYWQgPSAwO1xuXG4gICAgdmFyIGVycm9yO1xuICAgIHRoaXMub24oJ2Vycm9yJywgZnVuY3Rpb24oZXIpIHtcbiAgICAgIGVycm9yID0gZXI7XG4gICAgfSk7XG5cbiAgICBkbyB7XG4gICAgICB2YXIgcmVzID0gdGhpcy5fYmluZGluZy53cml0ZVN5bmMoZmx1c2hGbGFnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNodW5rLCAvLyBpblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGluT2ZmLCAvLyBpbl9vZmZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhdmFpbEluQmVmb3JlLCAvLyBpbl9sZW5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9idWZmZXIsIC8vIG91dFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX29mZnNldCwgLy9vdXRfb2ZmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXZhaWxPdXRCZWZvcmUpOyAvLyBvdXRfbGVuXG4gICAgfSB3aGlsZSAoIXRoaXMuX2hhZEVycm9yICYmIGNhbGxiYWNrKHJlc1swXSwgcmVzWzFdKSk7XG5cbiAgICBpZiAodGhpcy5faGFkRXJyb3IpIHtcbiAgICAgIHRocm93IGVycm9yO1xuICAgIH1cblxuICAgIHZhciBidWYgPSBCdWZmZXIuY29uY2F0KGJ1ZmZlcnMsIG5yZWFkKTtcbiAgICB0aGlzLmNsb3NlKCk7XG5cbiAgICByZXR1cm4gYnVmO1xuICB9XG5cbiAgdmFyIHJlcSA9IHRoaXMuX2JpbmRpbmcud3JpdGUoZmx1c2hGbGFnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjaHVuaywgLy8gaW5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5PZmYsIC8vIGluX29mZlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhdmFpbEluQmVmb3JlLCAvLyBpbl9sZW5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fYnVmZmVyLCAvLyBvdXRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fb2Zmc2V0LCAvL291dF9vZmZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXZhaWxPdXRCZWZvcmUpOyAvLyBvdXRfbGVuXG5cbiAgcmVxLmJ1ZmZlciA9IGNodW5rO1xuICByZXEuY2FsbGJhY2sgPSBjYWxsYmFjaztcblxuICBmdW5jdGlvbiBjYWxsYmFjayhhdmFpbEluQWZ0ZXIsIGF2YWlsT3V0QWZ0ZXIpIHtcbiAgICBpZiAoc2VsZi5faGFkRXJyb3IpXG4gICAgICByZXR1cm47XG5cbiAgICB2YXIgaGF2ZSA9IGF2YWlsT3V0QmVmb3JlIC0gYXZhaWxPdXRBZnRlcjtcbiAgICBhc3NlcnQoaGF2ZSA+PSAwLCAnaGF2ZSBzaG91bGQgbm90IGdvIGRvd24nKTtcblxuICAgIGlmIChoYXZlID4gMCkge1xuICAgICAgdmFyIG91dCA9IHNlbGYuX2J1ZmZlci5zbGljZShzZWxmLl9vZmZzZXQsIHNlbGYuX29mZnNldCArIGhhdmUpO1xuICAgICAgc2VsZi5fb2Zmc2V0ICs9IGhhdmU7XG4gICAgICAvLyBzZXJ2ZSBzb21lIG91dHB1dCB0byB0aGUgY29uc3VtZXIuXG4gICAgICBpZiAoYXN5bmMpIHtcbiAgICAgICAgc2VsZi5wdXNoKG91dCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBidWZmZXJzLnB1c2gob3V0KTtcbiAgICAgICAgbnJlYWQgKz0gb3V0Lmxlbmd0aDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBleGhhdXN0ZWQgdGhlIG91dHB1dCBidWZmZXIsIG9yIHVzZWQgYWxsIHRoZSBpbnB1dCBjcmVhdGUgYSBuZXcgb25lLlxuICAgIGlmIChhdmFpbE91dEFmdGVyID09PSAwIHx8IHNlbGYuX29mZnNldCA+PSBzZWxmLl9jaHVua1NpemUpIHtcbiAgICAgIGF2YWlsT3V0QmVmb3JlID0gc2VsZi5fY2h1bmtTaXplO1xuICAgICAgc2VsZi5fb2Zmc2V0ID0gMDtcbiAgICAgIHNlbGYuX2J1ZmZlciA9IG5ldyBCdWZmZXIoc2VsZi5fY2h1bmtTaXplKTtcbiAgICB9XG5cbiAgICBpZiAoYXZhaWxPdXRBZnRlciA9PT0gMCkge1xuICAgICAgLy8gTm90IGFjdHVhbGx5IGRvbmUuICBOZWVkIHRvIHJlcHJvY2Vzcy5cbiAgICAgIC8vIEFsc28sIHVwZGF0ZSB0aGUgYXZhaWxJbkJlZm9yZSB0byB0aGUgYXZhaWxJbkFmdGVyIHZhbHVlLFxuICAgICAgLy8gc28gdGhhdCBpZiB3ZSBoYXZlIHRvIGhpdCBpdCBhIHRoaXJkIChmb3VydGgsIGV0Yy4pIHRpbWUsXG4gICAgICAvLyBpdCdsbCBoYXZlIHRoZSBjb3JyZWN0IGJ5dGUgY291bnRzLlxuICAgICAgaW5PZmYgKz0gKGF2YWlsSW5CZWZvcmUgLSBhdmFpbEluQWZ0ZXIpO1xuICAgICAgYXZhaWxJbkJlZm9yZSA9IGF2YWlsSW5BZnRlcjtcblxuICAgICAgaWYgKCFhc3luYylcbiAgICAgICAgcmV0dXJuIHRydWU7XG5cbiAgICAgIHZhciBuZXdSZXEgPSBzZWxmLl9iaW5kaW5nLndyaXRlKGZsdXNoRmxhZyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNodW5rLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5PZmYsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhdmFpbEluQmVmb3JlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5fYnVmZmVyLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5fb2Zmc2V0LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5fY2h1bmtTaXplKTtcbiAgICAgIG5ld1JlcS5jYWxsYmFjayA9IGNhbGxiYWNrOyAvLyB0aGlzIHNhbWUgZnVuY3Rpb25cbiAgICAgIG5ld1JlcS5idWZmZXIgPSBjaHVuaztcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAoIWFzeW5jKVxuICAgICAgcmV0dXJuIGZhbHNlO1xuXG4gICAgLy8gZmluaXNoZWQgd2l0aCB0aGUgY2h1bmsuXG4gICAgY2IoKTtcbiAgfVxufTtcblxudXRpbC5pbmhlcml0cyhEZWZsYXRlLCBabGliKTtcbnV0aWwuaW5oZXJpdHMoSW5mbGF0ZSwgWmxpYik7XG51dGlsLmluaGVyaXRzKEd6aXAsIFpsaWIpO1xudXRpbC5pbmhlcml0cyhHdW56aXAsIFpsaWIpO1xudXRpbC5pbmhlcml0cyhEZWZsYXRlUmF3LCBabGliKTtcbnV0aWwuaW5oZXJpdHMoSW5mbGF0ZVJhdywgWmxpYik7XG51dGlsLmluaGVyaXRzKFVuemlwLCBabGliKTtcblxufSkuY2FsbCh0aGlzLHJlcXVpcmUoXCI3WUtJUGVcIikscmVxdWlyZShcImJ1ZmZlclwiKS5CdWZmZXIpIiwiLy8gaHR0cDovL3dpa2kuY29tbW9uanMub3JnL3dpa2kvVW5pdF9UZXN0aW5nLzEuMFxuLy9cbi8vIFRISVMgSVMgTk9UIFRFU1RFRCBOT1IgTElLRUxZIFRPIFdPUksgT1VUU0lERSBWOCFcbi8vXG4vLyBPcmlnaW5hbGx5IGZyb20gbmFyd2hhbC5qcyAoaHR0cDovL25hcndoYWxqcy5vcmcpXG4vLyBDb3B5cmlnaHQgKGMpIDIwMDkgVGhvbWFzIFJvYmluc29uIDwyODBub3J0aC5jb20+XG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weVxuLy8gb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgJ1NvZnR3YXJlJyksIHRvXG4vLyBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZVxuLy8gcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yXG4vLyBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpc1xuLy8gZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpblxuLy8gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEICdBUyBJUycsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1Jcbi8vIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxuLy8gRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFXG4vLyBBVVRIT1JTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTlxuLy8gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTlxuLy8gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG5cbi8vIHdoZW4gdXNlZCBpbiBub2RlLCB0aGlzIHdpbGwgYWN0dWFsbHkgbG9hZCB0aGUgdXRpbCBtb2R1bGUgd2UgZGVwZW5kIG9uXG4vLyB2ZXJzdXMgbG9hZGluZyB0aGUgYnVpbHRpbiB1dGlsIG1vZHVsZSBhcyBoYXBwZW5zIG90aGVyd2lzZVxuLy8gdGhpcyBpcyBhIGJ1ZyBpbiBub2RlIG1vZHVsZSBsb2FkaW5nIGFzIGZhciBhcyBJIGFtIGNvbmNlcm5lZFxudmFyIHV0aWwgPSByZXF1aXJlKCd1dGlsLycpO1xuXG52YXIgcFNsaWNlID0gQXJyYXkucHJvdG90eXBlLnNsaWNlO1xudmFyIGhhc093biA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG5cbi8vIDEuIFRoZSBhc3NlcnQgbW9kdWxlIHByb3ZpZGVzIGZ1bmN0aW9ucyB0aGF0IHRocm93XG4vLyBBc3NlcnRpb25FcnJvcidzIHdoZW4gcGFydGljdWxhciBjb25kaXRpb25zIGFyZSBub3QgbWV0LiBUaGVcbi8vIGFzc2VydCBtb2R1bGUgbXVzdCBjb25mb3JtIHRvIHRoZSBmb2xsb3dpbmcgaW50ZXJmYWNlLlxuXG52YXIgYXNzZXJ0ID0gbW9kdWxlLmV4cG9ydHMgPSBvaztcblxuLy8gMi4gVGhlIEFzc2VydGlvbkVycm9yIGlzIGRlZmluZWQgaW4gYXNzZXJ0LlxuLy8gbmV3IGFzc2VydC5Bc3NlcnRpb25FcnJvcih7IG1lc3NhZ2U6IG1lc3NhZ2UsXG4vLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYWN0dWFsOiBhY3R1YWwsXG4vLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZXhwZWN0ZWQ6IGV4cGVjdGVkIH0pXG5cbmFzc2VydC5Bc3NlcnRpb25FcnJvciA9IGZ1bmN0aW9uIEFzc2VydGlvbkVycm9yKG9wdGlvbnMpIHtcbiAgdGhpcy5uYW1lID0gJ0Fzc2VydGlvbkVycm9yJztcbiAgdGhpcy5hY3R1YWwgPSBvcHRpb25zLmFjdHVhbDtcbiAgdGhpcy5leHBlY3RlZCA9IG9wdGlvbnMuZXhwZWN0ZWQ7XG4gIHRoaXMub3BlcmF0b3IgPSBvcHRpb25zLm9wZXJhdG9yO1xuICBpZiAob3B0aW9ucy5tZXNzYWdlKSB7XG4gICAgdGhpcy5tZXNzYWdlID0gb3B0aW9ucy5tZXNzYWdlO1xuICAgIHRoaXMuZ2VuZXJhdGVkTWVzc2FnZSA9IGZhbHNlO1xuICB9IGVsc2Uge1xuICAgIHRoaXMubWVzc2FnZSA9IGdldE1lc3NhZ2UodGhpcyk7XG4gICAgdGhpcy5nZW5lcmF0ZWRNZXNzYWdlID0gdHJ1ZTtcbiAgfVxuICB2YXIgc3RhY2tTdGFydEZ1bmN0aW9uID0gb3B0aW9ucy5zdGFja1N0YXJ0RnVuY3Rpb24gfHwgZmFpbDtcblxuICBpZiAoRXJyb3IuY2FwdHVyZVN0YWNrVHJhY2UpIHtcbiAgICBFcnJvci5jYXB0dXJlU3RhY2tUcmFjZSh0aGlzLCBzdGFja1N0YXJ0RnVuY3Rpb24pO1xuICB9XG4gIGVsc2Uge1xuICAgIC8vIG5vbiB2OCBicm93c2VycyBzbyB3ZSBjYW4gaGF2ZSBhIHN0YWNrdHJhY2VcbiAgICB2YXIgZXJyID0gbmV3IEVycm9yKCk7XG4gICAgaWYgKGVyci5zdGFjaykge1xuICAgICAgdmFyIG91dCA9IGVyci5zdGFjaztcblxuICAgICAgLy8gdHJ5IHRvIHN0cmlwIHVzZWxlc3MgZnJhbWVzXG4gICAgICB2YXIgZm5fbmFtZSA9IHN0YWNrU3RhcnRGdW5jdGlvbi5uYW1lO1xuICAgICAgdmFyIGlkeCA9IG91dC5pbmRleE9mKCdcXG4nICsgZm5fbmFtZSk7XG4gICAgICBpZiAoaWR4ID49IDApIHtcbiAgICAgICAgLy8gb25jZSB3ZSBoYXZlIGxvY2F0ZWQgdGhlIGZ1bmN0aW9uIGZyYW1lXG4gICAgICAgIC8vIHdlIG5lZWQgdG8gc3RyaXAgb3V0IGV2ZXJ5dGhpbmcgYmVmb3JlIGl0IChhbmQgaXRzIGxpbmUpXG4gICAgICAgIHZhciBuZXh0X2xpbmUgPSBvdXQuaW5kZXhPZignXFxuJywgaWR4ICsgMSk7XG4gICAgICAgIG91dCA9IG91dC5zdWJzdHJpbmcobmV4dF9saW5lICsgMSk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuc3RhY2sgPSBvdXQ7XG4gICAgfVxuICB9XG59O1xuXG4vLyBhc3NlcnQuQXNzZXJ0aW9uRXJyb3IgaW5zdGFuY2VvZiBFcnJvclxudXRpbC5pbmhlcml0cyhhc3NlcnQuQXNzZXJ0aW9uRXJyb3IsIEVycm9yKTtcblxuZnVuY3Rpb24gcmVwbGFjZXIoa2V5LCB2YWx1ZSkge1xuICBpZiAodXRpbC5pc1VuZGVmaW5lZCh2YWx1ZSkpIHtcbiAgICByZXR1cm4gJycgKyB2YWx1ZTtcbiAgfVxuICBpZiAodXRpbC5pc051bWJlcih2YWx1ZSkgJiYgKGlzTmFOKHZhbHVlKSB8fCAhaXNGaW5pdGUodmFsdWUpKSkge1xuICAgIHJldHVybiB2YWx1ZS50b1N0cmluZygpO1xuICB9XG4gIGlmICh1dGlsLmlzRnVuY3Rpb24odmFsdWUpIHx8IHV0aWwuaXNSZWdFeHAodmFsdWUpKSB7XG4gICAgcmV0dXJuIHZhbHVlLnRvU3RyaW5nKCk7XG4gIH1cbiAgcmV0dXJuIHZhbHVlO1xufVxuXG5mdW5jdGlvbiB0cnVuY2F0ZShzLCBuKSB7XG4gIGlmICh1dGlsLmlzU3RyaW5nKHMpKSB7XG4gICAgcmV0dXJuIHMubGVuZ3RoIDwgbiA/IHMgOiBzLnNsaWNlKDAsIG4pO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBzO1xuICB9XG59XG5cbmZ1bmN0aW9uIGdldE1lc3NhZ2Uoc2VsZikge1xuICByZXR1cm4gdHJ1bmNhdGUoSlNPTi5zdHJpbmdpZnkoc2VsZi5hY3R1YWwsIHJlcGxhY2VyKSwgMTI4KSArICcgJyArXG4gICAgICAgICBzZWxmLm9wZXJhdG9yICsgJyAnICtcbiAgICAgICAgIHRydW5jYXRlKEpTT04uc3RyaW5naWZ5KHNlbGYuZXhwZWN0ZWQsIHJlcGxhY2VyKSwgMTI4KTtcbn1cblxuLy8gQXQgcHJlc2VudCBvbmx5IHRoZSB0aHJlZSBrZXlzIG1lbnRpb25lZCBhYm92ZSBhcmUgdXNlZCBhbmRcbi8vIHVuZGVyc3Rvb2QgYnkgdGhlIHNwZWMuIEltcGxlbWVudGF0aW9ucyBvciBzdWIgbW9kdWxlcyBjYW4gcGFzc1xuLy8gb3RoZXIga2V5cyB0byB0aGUgQXNzZXJ0aW9uRXJyb3IncyBjb25zdHJ1Y3RvciAtIHRoZXkgd2lsbCBiZVxuLy8gaWdub3JlZC5cblxuLy8gMy4gQWxsIG9mIHRoZSBmb2xsb3dpbmcgZnVuY3Rpb25zIG11c3QgdGhyb3cgYW4gQXNzZXJ0aW9uRXJyb3Jcbi8vIHdoZW4gYSBjb3JyZXNwb25kaW5nIGNvbmRpdGlvbiBpcyBub3QgbWV0LCB3aXRoIGEgbWVzc2FnZSB0aGF0XG4vLyBtYXkgYmUgdW5kZWZpbmVkIGlmIG5vdCBwcm92aWRlZC4gIEFsbCBhc3NlcnRpb24gbWV0aG9kcyBwcm92aWRlXG4vLyBib3RoIHRoZSBhY3R1YWwgYW5kIGV4cGVjdGVkIHZhbHVlcyB0byB0aGUgYXNzZXJ0aW9uIGVycm9yIGZvclxuLy8gZGlzcGxheSBwdXJwb3Nlcy5cblxuZnVuY3Rpb24gZmFpbChhY3R1YWwsIGV4cGVjdGVkLCBtZXNzYWdlLCBvcGVyYXRvciwgc3RhY2tTdGFydEZ1bmN0aW9uKSB7XG4gIHRocm93IG5ldyBhc3NlcnQuQXNzZXJ0aW9uRXJyb3Ioe1xuICAgIG1lc3NhZ2U6IG1lc3NhZ2UsXG4gICAgYWN0dWFsOiBhY3R1YWwsXG4gICAgZXhwZWN0ZWQ6IGV4cGVjdGVkLFxuICAgIG9wZXJhdG9yOiBvcGVyYXRvcixcbiAgICBzdGFja1N0YXJ0RnVuY3Rpb246IHN0YWNrU3RhcnRGdW5jdGlvblxuICB9KTtcbn1cblxuLy8gRVhURU5TSU9OISBhbGxvd3MgZm9yIHdlbGwgYmVoYXZlZCBlcnJvcnMgZGVmaW5lZCBlbHNld2hlcmUuXG5hc3NlcnQuZmFpbCA9IGZhaWw7XG5cbi8vIDQuIFB1cmUgYXNzZXJ0aW9uIHRlc3RzIHdoZXRoZXIgYSB2YWx1ZSBpcyB0cnV0aHksIGFzIGRldGVybWluZWRcbi8vIGJ5ICEhZ3VhcmQuXG4vLyBhc3NlcnQub2soZ3VhcmQsIG1lc3NhZ2Vfb3B0KTtcbi8vIFRoaXMgc3RhdGVtZW50IGlzIGVxdWl2YWxlbnQgdG8gYXNzZXJ0LmVxdWFsKHRydWUsICEhZ3VhcmQsXG4vLyBtZXNzYWdlX29wdCk7LiBUbyB0ZXN0IHN0cmljdGx5IGZvciB0aGUgdmFsdWUgdHJ1ZSwgdXNlXG4vLyBhc3NlcnQuc3RyaWN0RXF1YWwodHJ1ZSwgZ3VhcmQsIG1lc3NhZ2Vfb3B0KTsuXG5cbmZ1bmN0aW9uIG9rKHZhbHVlLCBtZXNzYWdlKSB7XG4gIGlmICghdmFsdWUpIGZhaWwodmFsdWUsIHRydWUsIG1lc3NhZ2UsICc9PScsIGFzc2VydC5vayk7XG59XG5hc3NlcnQub2sgPSBvaztcblxuLy8gNS4gVGhlIGVxdWFsaXR5IGFzc2VydGlvbiB0ZXN0cyBzaGFsbG93LCBjb2VyY2l2ZSBlcXVhbGl0eSB3aXRoXG4vLyA9PS5cbi8vIGFzc2VydC5lcXVhbChhY3R1YWwsIGV4cGVjdGVkLCBtZXNzYWdlX29wdCk7XG5cbmFzc2VydC5lcXVhbCA9IGZ1bmN0aW9uIGVxdWFsKGFjdHVhbCwgZXhwZWN0ZWQsIG1lc3NhZ2UpIHtcbiAgaWYgKGFjdHVhbCAhPSBleHBlY3RlZCkgZmFpbChhY3R1YWwsIGV4cGVjdGVkLCBtZXNzYWdlLCAnPT0nLCBhc3NlcnQuZXF1YWwpO1xufTtcblxuLy8gNi4gVGhlIG5vbi1lcXVhbGl0eSBhc3NlcnRpb24gdGVzdHMgZm9yIHdoZXRoZXIgdHdvIG9iamVjdHMgYXJlIG5vdCBlcXVhbFxuLy8gd2l0aCAhPSBhc3NlcnQubm90RXF1YWwoYWN0dWFsLCBleHBlY3RlZCwgbWVzc2FnZV9vcHQpO1xuXG5hc3NlcnQubm90RXF1YWwgPSBmdW5jdGlvbiBub3RFcXVhbChhY3R1YWwsIGV4cGVjdGVkLCBtZXNzYWdlKSB7XG4gIGlmIChhY3R1YWwgPT0gZXhwZWN0ZWQpIHtcbiAgICBmYWlsKGFjdHVhbCwgZXhwZWN0ZWQsIG1lc3NhZ2UsICchPScsIGFzc2VydC5ub3RFcXVhbCk7XG4gIH1cbn07XG5cbi8vIDcuIFRoZSBlcXVpdmFsZW5jZSBhc3NlcnRpb24gdGVzdHMgYSBkZWVwIGVxdWFsaXR5IHJlbGF0aW9uLlxuLy8gYXNzZXJ0LmRlZXBFcXVhbChhY3R1YWwsIGV4cGVjdGVkLCBtZXNzYWdlX29wdCk7XG5cbmFzc2VydC5kZWVwRXF1YWwgPSBmdW5jdGlvbiBkZWVwRXF1YWwoYWN0dWFsLCBleHBlY3RlZCwgbWVzc2FnZSkge1xuICBpZiAoIV9kZWVwRXF1YWwoYWN0dWFsLCBleHBlY3RlZCkpIHtcbiAgICBmYWlsKGFjdHVhbCwgZXhwZWN0ZWQsIG1lc3NhZ2UsICdkZWVwRXF1YWwnLCBhc3NlcnQuZGVlcEVxdWFsKTtcbiAgfVxufTtcblxuZnVuY3Rpb24gX2RlZXBFcXVhbChhY3R1YWwsIGV4cGVjdGVkKSB7XG4gIC8vIDcuMS4gQWxsIGlkZW50aWNhbCB2YWx1ZXMgYXJlIGVxdWl2YWxlbnQsIGFzIGRldGVybWluZWQgYnkgPT09LlxuICBpZiAoYWN0dWFsID09PSBleHBlY3RlZCkge1xuICAgIHJldHVybiB0cnVlO1xuXG4gIH0gZWxzZSBpZiAodXRpbC5pc0J1ZmZlcihhY3R1YWwpICYmIHV0aWwuaXNCdWZmZXIoZXhwZWN0ZWQpKSB7XG4gICAgaWYgKGFjdHVhbC5sZW5ndGggIT0gZXhwZWN0ZWQubGVuZ3RoKSByZXR1cm4gZmFsc2U7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFjdHVhbC5sZW5ndGg7IGkrKykge1xuICAgICAgaWYgKGFjdHVhbFtpXSAhPT0gZXhwZWN0ZWRbaV0pIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICByZXR1cm4gdHJ1ZTtcblxuICAvLyA3LjIuIElmIHRoZSBleHBlY3RlZCB2YWx1ZSBpcyBhIERhdGUgb2JqZWN0LCB0aGUgYWN0dWFsIHZhbHVlIGlzXG4gIC8vIGVxdWl2YWxlbnQgaWYgaXQgaXMgYWxzbyBhIERhdGUgb2JqZWN0IHRoYXQgcmVmZXJzIHRvIHRoZSBzYW1lIHRpbWUuXG4gIH0gZWxzZSBpZiAodXRpbC5pc0RhdGUoYWN0dWFsKSAmJiB1dGlsLmlzRGF0ZShleHBlY3RlZCkpIHtcbiAgICByZXR1cm4gYWN0dWFsLmdldFRpbWUoKSA9PT0gZXhwZWN0ZWQuZ2V0VGltZSgpO1xuXG4gIC8vIDcuMyBJZiB0aGUgZXhwZWN0ZWQgdmFsdWUgaXMgYSBSZWdFeHAgb2JqZWN0LCB0aGUgYWN0dWFsIHZhbHVlIGlzXG4gIC8vIGVxdWl2YWxlbnQgaWYgaXQgaXMgYWxzbyBhIFJlZ0V4cCBvYmplY3Qgd2l0aCB0aGUgc2FtZSBzb3VyY2UgYW5kXG4gIC8vIHByb3BlcnRpZXMgKGBnbG9iYWxgLCBgbXVsdGlsaW5lYCwgYGxhc3RJbmRleGAsIGBpZ25vcmVDYXNlYCkuXG4gIH0gZWxzZSBpZiAodXRpbC5pc1JlZ0V4cChhY3R1YWwpICYmIHV0aWwuaXNSZWdFeHAoZXhwZWN0ZWQpKSB7XG4gICAgcmV0dXJuIGFjdHVhbC5zb3VyY2UgPT09IGV4cGVjdGVkLnNvdXJjZSAmJlxuICAgICAgICAgICBhY3R1YWwuZ2xvYmFsID09PSBleHBlY3RlZC5nbG9iYWwgJiZcbiAgICAgICAgICAgYWN0dWFsLm11bHRpbGluZSA9PT0gZXhwZWN0ZWQubXVsdGlsaW5lICYmXG4gICAgICAgICAgIGFjdHVhbC5sYXN0SW5kZXggPT09IGV4cGVjdGVkLmxhc3RJbmRleCAmJlxuICAgICAgICAgICBhY3R1YWwuaWdub3JlQ2FzZSA9PT0gZXhwZWN0ZWQuaWdub3JlQ2FzZTtcblxuICAvLyA3LjQuIE90aGVyIHBhaXJzIHRoYXQgZG8gbm90IGJvdGggcGFzcyB0eXBlb2YgdmFsdWUgPT0gJ29iamVjdCcsXG4gIC8vIGVxdWl2YWxlbmNlIGlzIGRldGVybWluZWQgYnkgPT0uXG4gIH0gZWxzZSBpZiAoIXV0aWwuaXNPYmplY3QoYWN0dWFsKSAmJiAhdXRpbC5pc09iamVjdChleHBlY3RlZCkpIHtcbiAgICByZXR1cm4gYWN0dWFsID09IGV4cGVjdGVkO1xuXG4gIC8vIDcuNSBGb3IgYWxsIG90aGVyIE9iamVjdCBwYWlycywgaW5jbHVkaW5nIEFycmF5IG9iamVjdHMsIGVxdWl2YWxlbmNlIGlzXG4gIC8vIGRldGVybWluZWQgYnkgaGF2aW5nIHRoZSBzYW1lIG51bWJlciBvZiBvd25lZCBwcm9wZXJ0aWVzIChhcyB2ZXJpZmllZFxuICAvLyB3aXRoIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCksIHRoZSBzYW1lIHNldCBvZiBrZXlzXG4gIC8vIChhbHRob3VnaCBub3QgbmVjZXNzYXJpbHkgdGhlIHNhbWUgb3JkZXIpLCBlcXVpdmFsZW50IHZhbHVlcyBmb3IgZXZlcnlcbiAgLy8gY29ycmVzcG9uZGluZyBrZXksIGFuZCBhbiBpZGVudGljYWwgJ3Byb3RvdHlwZScgcHJvcGVydHkuIE5vdGU6IHRoaXNcbiAgLy8gYWNjb3VudHMgZm9yIGJvdGggbmFtZWQgYW5kIGluZGV4ZWQgcHJvcGVydGllcyBvbiBBcnJheXMuXG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIG9iakVxdWl2KGFjdHVhbCwgZXhwZWN0ZWQpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGlzQXJndW1lbnRzKG9iamVjdCkge1xuICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG9iamVjdCkgPT0gJ1tvYmplY3QgQXJndW1lbnRzXSc7XG59XG5cbmZ1bmN0aW9uIG9iakVxdWl2KGEsIGIpIHtcbiAgaWYgKHV0aWwuaXNOdWxsT3JVbmRlZmluZWQoYSkgfHwgdXRpbC5pc051bGxPclVuZGVmaW5lZChiKSlcbiAgICByZXR1cm4gZmFsc2U7XG4gIC8vIGFuIGlkZW50aWNhbCAncHJvdG90eXBlJyBwcm9wZXJ0eS5cbiAgaWYgKGEucHJvdG90eXBlICE9PSBiLnByb3RvdHlwZSkgcmV0dXJuIGZhbHNlO1xuICAvL35+fkkndmUgbWFuYWdlZCB0byBicmVhayBPYmplY3Qua2V5cyB0aHJvdWdoIHNjcmV3eSBhcmd1bWVudHMgcGFzc2luZy5cbiAgLy8gICBDb252ZXJ0aW5nIHRvIGFycmF5IHNvbHZlcyB0aGUgcHJvYmxlbS5cbiAgaWYgKGlzQXJndW1lbnRzKGEpKSB7XG4gICAgaWYgKCFpc0FyZ3VtZW50cyhiKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBhID0gcFNsaWNlLmNhbGwoYSk7XG4gICAgYiA9IHBTbGljZS5jYWxsKGIpO1xuICAgIHJldHVybiBfZGVlcEVxdWFsKGEsIGIpO1xuICB9XG4gIHRyeSB7XG4gICAgdmFyIGthID0gb2JqZWN0S2V5cyhhKSxcbiAgICAgICAga2IgPSBvYmplY3RLZXlzKGIpLFxuICAgICAgICBrZXksIGk7XG4gIH0gY2F0Y2ggKGUpIHsvL2hhcHBlbnMgd2hlbiBvbmUgaXMgYSBzdHJpbmcgbGl0ZXJhbCBhbmQgdGhlIG90aGVyIGlzbid0XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIC8vIGhhdmluZyB0aGUgc2FtZSBudW1iZXIgb2Ygb3duZWQgcHJvcGVydGllcyAoa2V5cyBpbmNvcnBvcmF0ZXNcbiAgLy8gaGFzT3duUHJvcGVydHkpXG4gIGlmIChrYS5sZW5ndGggIT0ga2IubGVuZ3RoKVxuICAgIHJldHVybiBmYWxzZTtcbiAgLy90aGUgc2FtZSBzZXQgb2Yga2V5cyAoYWx0aG91Z2ggbm90IG5lY2Vzc2FyaWx5IHRoZSBzYW1lIG9yZGVyKSxcbiAga2Euc29ydCgpO1xuICBrYi5zb3J0KCk7XG4gIC8vfn5+Y2hlYXAga2V5IHRlc3RcbiAgZm9yIChpID0ga2EubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICBpZiAoa2FbaV0gIT0ga2JbaV0pXG4gICAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgLy9lcXVpdmFsZW50IHZhbHVlcyBmb3IgZXZlcnkgY29ycmVzcG9uZGluZyBrZXksIGFuZFxuICAvL35+fnBvc3NpYmx5IGV4cGVuc2l2ZSBkZWVwIHRlc3RcbiAgZm9yIChpID0ga2EubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICBrZXkgPSBrYVtpXTtcbiAgICBpZiAoIV9kZWVwRXF1YWwoYVtrZXldLCBiW2tleV0pKSByZXR1cm4gZmFsc2U7XG4gIH1cbiAgcmV0dXJuIHRydWU7XG59XG5cbi8vIDguIFRoZSBub24tZXF1aXZhbGVuY2UgYXNzZXJ0aW9uIHRlc3RzIGZvciBhbnkgZGVlcCBpbmVxdWFsaXR5LlxuLy8gYXNzZXJ0Lm5vdERlZXBFcXVhbChhY3R1YWwsIGV4cGVjdGVkLCBtZXNzYWdlX29wdCk7XG5cbmFzc2VydC5ub3REZWVwRXF1YWwgPSBmdW5jdGlvbiBub3REZWVwRXF1YWwoYWN0dWFsLCBleHBlY3RlZCwgbWVzc2FnZSkge1xuICBpZiAoX2RlZXBFcXVhbChhY3R1YWwsIGV4cGVjdGVkKSkge1xuICAgIGZhaWwoYWN0dWFsLCBleHBlY3RlZCwgbWVzc2FnZSwgJ25vdERlZXBFcXVhbCcsIGFzc2VydC5ub3REZWVwRXF1YWwpO1xuICB9XG59O1xuXG4vLyA5LiBUaGUgc3RyaWN0IGVxdWFsaXR5IGFzc2VydGlvbiB0ZXN0cyBzdHJpY3QgZXF1YWxpdHksIGFzIGRldGVybWluZWQgYnkgPT09LlxuLy8gYXNzZXJ0LnN0cmljdEVxdWFsKGFjdHVhbCwgZXhwZWN0ZWQsIG1lc3NhZ2Vfb3B0KTtcblxuYXNzZXJ0LnN0cmljdEVxdWFsID0gZnVuY3Rpb24gc3RyaWN0RXF1YWwoYWN0dWFsLCBleHBlY3RlZCwgbWVzc2FnZSkge1xuICBpZiAoYWN0dWFsICE9PSBleHBlY3RlZCkge1xuICAgIGZhaWwoYWN0dWFsLCBleHBlY3RlZCwgbWVzc2FnZSwgJz09PScsIGFzc2VydC5zdHJpY3RFcXVhbCk7XG4gIH1cbn07XG5cbi8vIDEwLiBUaGUgc3RyaWN0IG5vbi1lcXVhbGl0eSBhc3NlcnRpb24gdGVzdHMgZm9yIHN0cmljdCBpbmVxdWFsaXR5LCBhc1xuLy8gZGV0ZXJtaW5lZCBieSAhPT0uICBhc3NlcnQubm90U3RyaWN0RXF1YWwoYWN0dWFsLCBleHBlY3RlZCwgbWVzc2FnZV9vcHQpO1xuXG5hc3NlcnQubm90U3RyaWN0RXF1YWwgPSBmdW5jdGlvbiBub3RTdHJpY3RFcXVhbChhY3R1YWwsIGV4cGVjdGVkLCBtZXNzYWdlKSB7XG4gIGlmIChhY3R1YWwgPT09IGV4cGVjdGVkKSB7XG4gICAgZmFpbChhY3R1YWwsIGV4cGVjdGVkLCBtZXNzYWdlLCAnIT09JywgYXNzZXJ0Lm5vdFN0cmljdEVxdWFsKTtcbiAgfVxufTtcblxuZnVuY3Rpb24gZXhwZWN0ZWRFeGNlcHRpb24oYWN0dWFsLCBleHBlY3RlZCkge1xuICBpZiAoIWFjdHVhbCB8fCAhZXhwZWN0ZWQpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBpZiAoT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGV4cGVjdGVkKSA9PSAnW29iamVjdCBSZWdFeHBdJykge1xuICAgIHJldHVybiBleHBlY3RlZC50ZXN0KGFjdHVhbCk7XG4gIH0gZWxzZSBpZiAoYWN0dWFsIGluc3RhbmNlb2YgZXhwZWN0ZWQpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSBlbHNlIGlmIChleHBlY3RlZC5jYWxsKHt9LCBhY3R1YWwpID09PSB0cnVlKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIF90aHJvd3Moc2hvdWxkVGhyb3csIGJsb2NrLCBleHBlY3RlZCwgbWVzc2FnZSkge1xuICB2YXIgYWN0dWFsO1xuXG4gIGlmICh1dGlsLmlzU3RyaW5nKGV4cGVjdGVkKSkge1xuICAgIG1lc3NhZ2UgPSBleHBlY3RlZDtcbiAgICBleHBlY3RlZCA9IG51bGw7XG4gIH1cblxuICB0cnkge1xuICAgIGJsb2NrKCk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICBhY3R1YWwgPSBlO1xuICB9XG5cbiAgbWVzc2FnZSA9IChleHBlY3RlZCAmJiBleHBlY3RlZC5uYW1lID8gJyAoJyArIGV4cGVjdGVkLm5hbWUgKyAnKS4nIDogJy4nKSArXG4gICAgICAgICAgICAobWVzc2FnZSA/ICcgJyArIG1lc3NhZ2UgOiAnLicpO1xuXG4gIGlmIChzaG91bGRUaHJvdyAmJiAhYWN0dWFsKSB7XG4gICAgZmFpbChhY3R1YWwsIGV4cGVjdGVkLCAnTWlzc2luZyBleHBlY3RlZCBleGNlcHRpb24nICsgbWVzc2FnZSk7XG4gIH1cblxuICBpZiAoIXNob3VsZFRocm93ICYmIGV4cGVjdGVkRXhjZXB0aW9uKGFjdHVhbCwgZXhwZWN0ZWQpKSB7XG4gICAgZmFpbChhY3R1YWwsIGV4cGVjdGVkLCAnR290IHVud2FudGVkIGV4Y2VwdGlvbicgKyBtZXNzYWdlKTtcbiAgfVxuXG4gIGlmICgoc2hvdWxkVGhyb3cgJiYgYWN0dWFsICYmIGV4cGVjdGVkICYmXG4gICAgICAhZXhwZWN0ZWRFeGNlcHRpb24oYWN0dWFsLCBleHBlY3RlZCkpIHx8ICghc2hvdWxkVGhyb3cgJiYgYWN0dWFsKSkge1xuICAgIHRocm93IGFjdHVhbDtcbiAgfVxufVxuXG4vLyAxMS4gRXhwZWN0ZWQgdG8gdGhyb3cgYW4gZXJyb3I6XG4vLyBhc3NlcnQudGhyb3dzKGJsb2NrLCBFcnJvcl9vcHQsIG1lc3NhZ2Vfb3B0KTtcblxuYXNzZXJ0LnRocm93cyA9IGZ1bmN0aW9uKGJsb2NrLCAvKm9wdGlvbmFsKi9lcnJvciwgLypvcHRpb25hbCovbWVzc2FnZSkge1xuICBfdGhyb3dzLmFwcGx5KHRoaXMsIFt0cnVlXS5jb25jYXQocFNsaWNlLmNhbGwoYXJndW1lbnRzKSkpO1xufTtcblxuLy8gRVhURU5TSU9OISBUaGlzIGlzIGFubm95aW5nIHRvIHdyaXRlIG91dHNpZGUgdGhpcyBtb2R1bGUuXG5hc3NlcnQuZG9lc05vdFRocm93ID0gZnVuY3Rpb24oYmxvY2ssIC8qb3B0aW9uYWwqL21lc3NhZ2UpIHtcbiAgX3Rocm93cy5hcHBseSh0aGlzLCBbZmFsc2VdLmNvbmNhdChwU2xpY2UuY2FsbChhcmd1bWVudHMpKSk7XG59O1xuXG5hc3NlcnQuaWZFcnJvciA9IGZ1bmN0aW9uKGVycikgeyBpZiAoZXJyKSB7dGhyb3cgZXJyO319O1xuXG52YXIgb2JqZWN0S2V5cyA9IE9iamVjdC5rZXlzIHx8IGZ1bmN0aW9uIChvYmopIHtcbiAgdmFyIGtleXMgPSBbXTtcbiAgZm9yICh2YXIga2V5IGluIG9iaikge1xuICAgIGlmIChoYXNPd24uY2FsbChvYmosIGtleSkpIGtleXMucHVzaChrZXkpO1xuICB9XG4gIHJldHVybiBrZXlzO1xufTtcbiIsInZhciBsb29rdXAgPSAnQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVphYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ejAxMjM0NTY3ODkrLyc7XG5cbjsoZnVuY3Rpb24gKGV4cG9ydHMpIHtcblx0J3VzZSBzdHJpY3QnO1xuXG4gIHZhciBBcnIgPSAodHlwZW9mIFVpbnQ4QXJyYXkgIT09ICd1bmRlZmluZWQnKVxuICAgID8gVWludDhBcnJheVxuICAgIDogQXJyYXlcblxuXHR2YXIgUExVUyAgID0gJysnLmNoYXJDb2RlQXQoMClcblx0dmFyIFNMQVNIICA9ICcvJy5jaGFyQ29kZUF0KDApXG5cdHZhciBOVU1CRVIgPSAnMCcuY2hhckNvZGVBdCgwKVxuXHR2YXIgTE9XRVIgID0gJ2EnLmNoYXJDb2RlQXQoMClcblx0dmFyIFVQUEVSICA9ICdBJy5jaGFyQ29kZUF0KDApXG5cdHZhciBQTFVTX1VSTF9TQUZFID0gJy0nLmNoYXJDb2RlQXQoMClcblx0dmFyIFNMQVNIX1VSTF9TQUZFID0gJ18nLmNoYXJDb2RlQXQoMClcblxuXHRmdW5jdGlvbiBkZWNvZGUgKGVsdCkge1xuXHRcdHZhciBjb2RlID0gZWx0LmNoYXJDb2RlQXQoMClcblx0XHRpZiAoY29kZSA9PT0gUExVUyB8fFxuXHRcdCAgICBjb2RlID09PSBQTFVTX1VSTF9TQUZFKVxuXHRcdFx0cmV0dXJuIDYyIC8vICcrJ1xuXHRcdGlmIChjb2RlID09PSBTTEFTSCB8fFxuXHRcdCAgICBjb2RlID09PSBTTEFTSF9VUkxfU0FGRSlcblx0XHRcdHJldHVybiA2MyAvLyAnLydcblx0XHRpZiAoY29kZSA8IE5VTUJFUilcblx0XHRcdHJldHVybiAtMSAvL25vIG1hdGNoXG5cdFx0aWYgKGNvZGUgPCBOVU1CRVIgKyAxMClcblx0XHRcdHJldHVybiBjb2RlIC0gTlVNQkVSICsgMjYgKyAyNlxuXHRcdGlmIChjb2RlIDwgVVBQRVIgKyAyNilcblx0XHRcdHJldHVybiBjb2RlIC0gVVBQRVJcblx0XHRpZiAoY29kZSA8IExPV0VSICsgMjYpXG5cdFx0XHRyZXR1cm4gY29kZSAtIExPV0VSICsgMjZcblx0fVxuXG5cdGZ1bmN0aW9uIGI2NFRvQnl0ZUFycmF5IChiNjQpIHtcblx0XHR2YXIgaSwgaiwgbCwgdG1wLCBwbGFjZUhvbGRlcnMsIGFyclxuXG5cdFx0aWYgKGI2NC5sZW5ndGggJSA0ID4gMCkge1xuXHRcdFx0dGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIHN0cmluZy4gTGVuZ3RoIG11c3QgYmUgYSBtdWx0aXBsZSBvZiA0Jylcblx0XHR9XG5cblx0XHQvLyB0aGUgbnVtYmVyIG9mIGVxdWFsIHNpZ25zIChwbGFjZSBob2xkZXJzKVxuXHRcdC8vIGlmIHRoZXJlIGFyZSB0d28gcGxhY2Vob2xkZXJzLCB0aGFuIHRoZSB0d28gY2hhcmFjdGVycyBiZWZvcmUgaXRcblx0XHQvLyByZXByZXNlbnQgb25lIGJ5dGVcblx0XHQvLyBpZiB0aGVyZSBpcyBvbmx5IG9uZSwgdGhlbiB0aGUgdGhyZWUgY2hhcmFjdGVycyBiZWZvcmUgaXQgcmVwcmVzZW50IDIgYnl0ZXNcblx0XHQvLyB0aGlzIGlzIGp1c3QgYSBjaGVhcCBoYWNrIHRvIG5vdCBkbyBpbmRleE9mIHR3aWNlXG5cdFx0dmFyIGxlbiA9IGI2NC5sZW5ndGhcblx0XHRwbGFjZUhvbGRlcnMgPSAnPScgPT09IGI2NC5jaGFyQXQobGVuIC0gMikgPyAyIDogJz0nID09PSBiNjQuY2hhckF0KGxlbiAtIDEpID8gMSA6IDBcblxuXHRcdC8vIGJhc2U2NCBpcyA0LzMgKyB1cCB0byB0d28gY2hhcmFjdGVycyBvZiB0aGUgb3JpZ2luYWwgZGF0YVxuXHRcdGFyciA9IG5ldyBBcnIoYjY0Lmxlbmd0aCAqIDMgLyA0IC0gcGxhY2VIb2xkZXJzKVxuXG5cdFx0Ly8gaWYgdGhlcmUgYXJlIHBsYWNlaG9sZGVycywgb25seSBnZXQgdXAgdG8gdGhlIGxhc3QgY29tcGxldGUgNCBjaGFyc1xuXHRcdGwgPSBwbGFjZUhvbGRlcnMgPiAwID8gYjY0Lmxlbmd0aCAtIDQgOiBiNjQubGVuZ3RoXG5cblx0XHR2YXIgTCA9IDBcblxuXHRcdGZ1bmN0aW9uIHB1c2ggKHYpIHtcblx0XHRcdGFycltMKytdID0gdlxuXHRcdH1cblxuXHRcdGZvciAoaSA9IDAsIGogPSAwOyBpIDwgbDsgaSArPSA0LCBqICs9IDMpIHtcblx0XHRcdHRtcCA9IChkZWNvZGUoYjY0LmNoYXJBdChpKSkgPDwgMTgpIHwgKGRlY29kZShiNjQuY2hhckF0KGkgKyAxKSkgPDwgMTIpIHwgKGRlY29kZShiNjQuY2hhckF0KGkgKyAyKSkgPDwgNikgfCBkZWNvZGUoYjY0LmNoYXJBdChpICsgMykpXG5cdFx0XHRwdXNoKCh0bXAgJiAweEZGMDAwMCkgPj4gMTYpXG5cdFx0XHRwdXNoKCh0bXAgJiAweEZGMDApID4+IDgpXG5cdFx0XHRwdXNoKHRtcCAmIDB4RkYpXG5cdFx0fVxuXG5cdFx0aWYgKHBsYWNlSG9sZGVycyA9PT0gMikge1xuXHRcdFx0dG1wID0gKGRlY29kZShiNjQuY2hhckF0KGkpKSA8PCAyKSB8IChkZWNvZGUoYjY0LmNoYXJBdChpICsgMSkpID4+IDQpXG5cdFx0XHRwdXNoKHRtcCAmIDB4RkYpXG5cdFx0fSBlbHNlIGlmIChwbGFjZUhvbGRlcnMgPT09IDEpIHtcblx0XHRcdHRtcCA9IChkZWNvZGUoYjY0LmNoYXJBdChpKSkgPDwgMTApIHwgKGRlY29kZShiNjQuY2hhckF0KGkgKyAxKSkgPDwgNCkgfCAoZGVjb2RlKGI2NC5jaGFyQXQoaSArIDIpKSA+PiAyKVxuXHRcdFx0cHVzaCgodG1wID4+IDgpICYgMHhGRilcblx0XHRcdHB1c2godG1wICYgMHhGRilcblx0XHR9XG5cblx0XHRyZXR1cm4gYXJyXG5cdH1cblxuXHRmdW5jdGlvbiB1aW50OFRvQmFzZTY0ICh1aW50OCkge1xuXHRcdHZhciBpLFxuXHRcdFx0ZXh0cmFCeXRlcyA9IHVpbnQ4Lmxlbmd0aCAlIDMsIC8vIGlmIHdlIGhhdmUgMSBieXRlIGxlZnQsIHBhZCAyIGJ5dGVzXG5cdFx0XHRvdXRwdXQgPSBcIlwiLFxuXHRcdFx0dGVtcCwgbGVuZ3RoXG5cblx0XHRmdW5jdGlvbiBlbmNvZGUgKG51bSkge1xuXHRcdFx0cmV0dXJuIGxvb2t1cC5jaGFyQXQobnVtKVxuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIHRyaXBsZXRUb0Jhc2U2NCAobnVtKSB7XG5cdFx0XHRyZXR1cm4gZW5jb2RlKG51bSA+PiAxOCAmIDB4M0YpICsgZW5jb2RlKG51bSA+PiAxMiAmIDB4M0YpICsgZW5jb2RlKG51bSA+PiA2ICYgMHgzRikgKyBlbmNvZGUobnVtICYgMHgzRilcblx0XHR9XG5cblx0XHQvLyBnbyB0aHJvdWdoIHRoZSBhcnJheSBldmVyeSB0aHJlZSBieXRlcywgd2UnbGwgZGVhbCB3aXRoIHRyYWlsaW5nIHN0dWZmIGxhdGVyXG5cdFx0Zm9yIChpID0gMCwgbGVuZ3RoID0gdWludDgubGVuZ3RoIC0gZXh0cmFCeXRlczsgaSA8IGxlbmd0aDsgaSArPSAzKSB7XG5cdFx0XHR0ZW1wID0gKHVpbnQ4W2ldIDw8IDE2KSArICh1aW50OFtpICsgMV0gPDwgOCkgKyAodWludDhbaSArIDJdKVxuXHRcdFx0b3V0cHV0ICs9IHRyaXBsZXRUb0Jhc2U2NCh0ZW1wKVxuXHRcdH1cblxuXHRcdC8vIHBhZCB0aGUgZW5kIHdpdGggemVyb3MsIGJ1dCBtYWtlIHN1cmUgdG8gbm90IGZvcmdldCB0aGUgZXh0cmEgYnl0ZXNcblx0XHRzd2l0Y2ggKGV4dHJhQnl0ZXMpIHtcblx0XHRcdGNhc2UgMTpcblx0XHRcdFx0dGVtcCA9IHVpbnQ4W3VpbnQ4Lmxlbmd0aCAtIDFdXG5cdFx0XHRcdG91dHB1dCArPSBlbmNvZGUodGVtcCA+PiAyKVxuXHRcdFx0XHRvdXRwdXQgKz0gZW5jb2RlKCh0ZW1wIDw8IDQpICYgMHgzRilcblx0XHRcdFx0b3V0cHV0ICs9ICc9PSdcblx0XHRcdFx0YnJlYWtcblx0XHRcdGNhc2UgMjpcblx0XHRcdFx0dGVtcCA9ICh1aW50OFt1aW50OC5sZW5ndGggLSAyXSA8PCA4KSArICh1aW50OFt1aW50OC5sZW5ndGggLSAxXSlcblx0XHRcdFx0b3V0cHV0ICs9IGVuY29kZSh0ZW1wID4+IDEwKVxuXHRcdFx0XHRvdXRwdXQgKz0gZW5jb2RlKCh0ZW1wID4+IDQpICYgMHgzRilcblx0XHRcdFx0b3V0cHV0ICs9IGVuY29kZSgodGVtcCA8PCAyKSAmIDB4M0YpXG5cdFx0XHRcdG91dHB1dCArPSAnPSdcblx0XHRcdFx0YnJlYWtcblx0XHR9XG5cblx0XHRyZXR1cm4gb3V0cHV0XG5cdH1cblxuXHRleHBvcnRzLnRvQnl0ZUFycmF5ID0gYjY0VG9CeXRlQXJyYXlcblx0ZXhwb3J0cy5mcm9tQnl0ZUFycmF5ID0gdWludDhUb0Jhc2U2NFxufSh0eXBlb2YgZXhwb3J0cyA9PT0gJ3VuZGVmaW5lZCcgPyAodGhpcy5iYXNlNjRqcyA9IHt9KSA6IGV4cG9ydHMpKVxuIixudWxsLCIvKiFcbiAqIFRoZSBidWZmZXIgbW9kdWxlIGZyb20gbm9kZS5qcywgZm9yIHRoZSBicm93c2VyLlxuICpcbiAqIEBhdXRob3IgICBGZXJvc3MgQWJvdWtoYWRpamVoIDxmZXJvc3NAZmVyb3NzLm9yZz4gPGh0dHA6Ly9mZXJvc3Mub3JnPlxuICogQGxpY2Vuc2UgIE1JVFxuICovXG5cbnZhciBiYXNlNjQgPSByZXF1aXJlKCdiYXNlNjQtanMnKVxudmFyIGllZWU3NTQgPSByZXF1aXJlKCdpZWVlNzU0JylcblxuZXhwb3J0cy5CdWZmZXIgPSBCdWZmZXJcbmV4cG9ydHMuU2xvd0J1ZmZlciA9IEJ1ZmZlclxuZXhwb3J0cy5JTlNQRUNUX01BWF9CWVRFUyA9IDUwXG5CdWZmZXIucG9vbFNpemUgPSA4MTkyXG5cbi8qKlxuICogSWYgYEJ1ZmZlci5fdXNlVHlwZWRBcnJheXNgOlxuICogICA9PT0gdHJ1ZSAgICBVc2UgVWludDhBcnJheSBpbXBsZW1lbnRhdGlvbiAoZmFzdGVzdClcbiAqICAgPT09IGZhbHNlICAgVXNlIE9iamVjdCBpbXBsZW1lbnRhdGlvbiAoY29tcGF0aWJsZSBkb3duIHRvIElFNilcbiAqL1xuQnVmZmVyLl91c2VUeXBlZEFycmF5cyA9IChmdW5jdGlvbiAoKSB7XG4gIC8vIERldGVjdCBpZiBicm93c2VyIHN1cHBvcnRzIFR5cGVkIEFycmF5cy4gU3VwcG9ydGVkIGJyb3dzZXJzIGFyZSBJRSAxMCssIEZpcmVmb3ggNCssXG4gIC8vIENocm9tZSA3KywgU2FmYXJpIDUuMSssIE9wZXJhIDExLjYrLCBpT1MgNC4yKy4gSWYgdGhlIGJyb3dzZXIgZG9lcyBub3Qgc3VwcG9ydCBhZGRpbmdcbiAgLy8gcHJvcGVydGllcyB0byBgVWludDhBcnJheWAgaW5zdGFuY2VzLCB0aGVuIHRoYXQncyB0aGUgc2FtZSBhcyBubyBgVWludDhBcnJheWAgc3VwcG9ydFxuICAvLyBiZWNhdXNlIHdlIG5lZWQgdG8gYmUgYWJsZSB0byBhZGQgYWxsIHRoZSBub2RlIEJ1ZmZlciBBUEkgbWV0aG9kcy4gVGhpcyBpcyBhbiBpc3N1ZVxuICAvLyBpbiBGaXJlZm94IDQtMjkuIE5vdyBmaXhlZDogaHR0cHM6Ly9idWd6aWxsYS5tb3ppbGxhLm9yZy9zaG93X2J1Zy5jZ2k/aWQ9Njk1NDM4XG4gIHRyeSB7XG4gICAgdmFyIGJ1ZiA9IG5ldyBBcnJheUJ1ZmZlcigwKVxuICAgIHZhciBhcnIgPSBuZXcgVWludDhBcnJheShidWYpXG4gICAgYXJyLmZvbyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIDQyIH1cbiAgICByZXR1cm4gNDIgPT09IGFyci5mb28oKSAmJlxuICAgICAgICB0eXBlb2YgYXJyLnN1YmFycmF5ID09PSAnZnVuY3Rpb24nIC8vIENocm9tZSA5LTEwIGxhY2sgYHN1YmFycmF5YFxuICB9IGNhdGNoIChlKSB7XG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cbn0pKClcblxuLyoqXG4gKiBDbGFzczogQnVmZmVyXG4gKiA9PT09PT09PT09PT09XG4gKlxuICogVGhlIEJ1ZmZlciBjb25zdHJ1Y3RvciByZXR1cm5zIGluc3RhbmNlcyBvZiBgVWludDhBcnJheWAgdGhhdCBhcmUgYXVnbWVudGVkXG4gKiB3aXRoIGZ1bmN0aW9uIHByb3BlcnRpZXMgZm9yIGFsbCB0aGUgbm9kZSBgQnVmZmVyYCBBUEkgZnVuY3Rpb25zLiBXZSB1c2VcbiAqIGBVaW50OEFycmF5YCBzbyB0aGF0IHNxdWFyZSBicmFja2V0IG5vdGF0aW9uIHdvcmtzIGFzIGV4cGVjdGVkIC0tIGl0IHJldHVybnNcbiAqIGEgc2luZ2xlIG9jdGV0LlxuICpcbiAqIEJ5IGF1Z21lbnRpbmcgdGhlIGluc3RhbmNlcywgd2UgY2FuIGF2b2lkIG1vZGlmeWluZyB0aGUgYFVpbnQ4QXJyYXlgXG4gKiBwcm90b3R5cGUuXG4gKi9cbmZ1bmN0aW9uIEJ1ZmZlciAoc3ViamVjdCwgZW5jb2RpbmcsIG5vWmVybykge1xuICBpZiAoISh0aGlzIGluc3RhbmNlb2YgQnVmZmVyKSlcbiAgICByZXR1cm4gbmV3IEJ1ZmZlcihzdWJqZWN0LCBlbmNvZGluZywgbm9aZXJvKVxuXG4gIHZhciB0eXBlID0gdHlwZW9mIHN1YmplY3RcblxuICAvLyBXb3JrYXJvdW5kOiBub2RlJ3MgYmFzZTY0IGltcGxlbWVudGF0aW9uIGFsbG93cyBmb3Igbm9uLXBhZGRlZCBzdHJpbmdzXG4gIC8vIHdoaWxlIGJhc2U2NC1qcyBkb2VzIG5vdC5cbiAgaWYgKGVuY29kaW5nID09PSAnYmFzZTY0JyAmJiB0eXBlID09PSAnc3RyaW5nJykge1xuICAgIHN1YmplY3QgPSBzdHJpbmd0cmltKHN1YmplY3QpXG4gICAgd2hpbGUgKHN1YmplY3QubGVuZ3RoICUgNCAhPT0gMCkge1xuICAgICAgc3ViamVjdCA9IHN1YmplY3QgKyAnPSdcbiAgICB9XG4gIH1cblxuICAvLyBGaW5kIHRoZSBsZW5ndGhcbiAgdmFyIGxlbmd0aFxuICBpZiAodHlwZSA9PT0gJ251bWJlcicpXG4gICAgbGVuZ3RoID0gY29lcmNlKHN1YmplY3QpXG4gIGVsc2UgaWYgKHR5cGUgPT09ICdzdHJpbmcnKVxuICAgIGxlbmd0aCA9IEJ1ZmZlci5ieXRlTGVuZ3RoKHN1YmplY3QsIGVuY29kaW5nKVxuICBlbHNlIGlmICh0eXBlID09PSAnb2JqZWN0JylcbiAgICBsZW5ndGggPSBjb2VyY2Uoc3ViamVjdC5sZW5ndGgpIC8vIGFzc3VtZSB0aGF0IG9iamVjdCBpcyBhcnJheS1saWtlXG4gIGVsc2VcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0ZpcnN0IGFyZ3VtZW50IG5lZWRzIHRvIGJlIGEgbnVtYmVyLCBhcnJheSBvciBzdHJpbmcuJylcblxuICB2YXIgYnVmXG4gIGlmIChCdWZmZXIuX3VzZVR5cGVkQXJyYXlzKSB7XG4gICAgLy8gUHJlZmVycmVkOiBSZXR1cm4gYW4gYXVnbWVudGVkIGBVaW50OEFycmF5YCBpbnN0YW5jZSBmb3IgYmVzdCBwZXJmb3JtYW5jZVxuICAgIGJ1ZiA9IEJ1ZmZlci5fYXVnbWVudChuZXcgVWludDhBcnJheShsZW5ndGgpKVxuICB9IGVsc2Uge1xuICAgIC8vIEZhbGxiYWNrOiBSZXR1cm4gVEhJUyBpbnN0YW5jZSBvZiBCdWZmZXIgKGNyZWF0ZWQgYnkgYG5ld2ApXG4gICAgYnVmID0gdGhpc1xuICAgIGJ1Zi5sZW5ndGggPSBsZW5ndGhcbiAgICBidWYuX2lzQnVmZmVyID0gdHJ1ZVxuICB9XG5cbiAgdmFyIGlcbiAgaWYgKEJ1ZmZlci5fdXNlVHlwZWRBcnJheXMgJiYgdHlwZW9mIHN1YmplY3QuYnl0ZUxlbmd0aCA9PT0gJ251bWJlcicpIHtcbiAgICAvLyBTcGVlZCBvcHRpbWl6YXRpb24gLS0gdXNlIHNldCBpZiB3ZSdyZSBjb3B5aW5nIGZyb20gYSB0eXBlZCBhcnJheVxuICAgIGJ1Zi5fc2V0KHN1YmplY3QpXG4gIH0gZWxzZSBpZiAoaXNBcnJheWlzaChzdWJqZWN0KSkge1xuICAgIC8vIFRyZWF0IGFycmF5LWlzaCBvYmplY3RzIGFzIGEgYnl0ZSBhcnJheVxuICAgIGZvciAoaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgaWYgKEJ1ZmZlci5pc0J1ZmZlcihzdWJqZWN0KSlcbiAgICAgICAgYnVmW2ldID0gc3ViamVjdC5yZWFkVUludDgoaSlcbiAgICAgIGVsc2VcbiAgICAgICAgYnVmW2ldID0gc3ViamVjdFtpXVxuICAgIH1cbiAgfSBlbHNlIGlmICh0eXBlID09PSAnc3RyaW5nJykge1xuICAgIGJ1Zi53cml0ZShzdWJqZWN0LCAwLCBlbmNvZGluZylcbiAgfSBlbHNlIGlmICh0eXBlID09PSAnbnVtYmVyJyAmJiAhQnVmZmVyLl91c2VUeXBlZEFycmF5cyAmJiAhbm9aZXJvKSB7XG4gICAgZm9yIChpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICBidWZbaV0gPSAwXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGJ1ZlxufVxuXG4vLyBTVEFUSUMgTUVUSE9EU1xuLy8gPT09PT09PT09PT09PT1cblxuQnVmZmVyLmlzRW5jb2RpbmcgPSBmdW5jdGlvbiAoZW5jb2RpbmcpIHtcbiAgc3dpdGNoIChTdHJpbmcoZW5jb2RpbmcpLnRvTG93ZXJDYXNlKCkpIHtcbiAgICBjYXNlICdoZXgnOlxuICAgIGNhc2UgJ3V0ZjgnOlxuICAgIGNhc2UgJ3V0Zi04JzpcbiAgICBjYXNlICdhc2NpaSc6XG4gICAgY2FzZSAnYmluYXJ5JzpcbiAgICBjYXNlICdiYXNlNjQnOlxuICAgIGNhc2UgJ3Jhdyc6XG4gICAgY2FzZSAndWNzMic6XG4gICAgY2FzZSAndWNzLTInOlxuICAgIGNhc2UgJ3V0ZjE2bGUnOlxuICAgIGNhc2UgJ3V0Zi0xNmxlJzpcbiAgICAgIHJldHVybiB0cnVlXG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBmYWxzZVxuICB9XG59XG5cbkJ1ZmZlci5pc0J1ZmZlciA9IGZ1bmN0aW9uIChiKSB7XG4gIHJldHVybiAhIShiICE9PSBudWxsICYmIGIgIT09IHVuZGVmaW5lZCAmJiBiLl9pc0J1ZmZlcilcbn1cblxuQnVmZmVyLmJ5dGVMZW5ndGggPSBmdW5jdGlvbiAoc3RyLCBlbmNvZGluZykge1xuICB2YXIgcmV0XG4gIHN0ciA9IHN0ciArICcnXG4gIHN3aXRjaCAoZW5jb2RpbmcgfHwgJ3V0ZjgnKSB7XG4gICAgY2FzZSAnaGV4JzpcbiAgICAgIHJldCA9IHN0ci5sZW5ndGggLyAyXG4gICAgICBicmVha1xuICAgIGNhc2UgJ3V0ZjgnOlxuICAgIGNhc2UgJ3V0Zi04JzpcbiAgICAgIHJldCA9IHV0ZjhUb0J5dGVzKHN0cikubGVuZ3RoXG4gICAgICBicmVha1xuICAgIGNhc2UgJ2FzY2lpJzpcbiAgICBjYXNlICdiaW5hcnknOlxuICAgIGNhc2UgJ3Jhdyc6XG4gICAgICByZXQgPSBzdHIubGVuZ3RoXG4gICAgICBicmVha1xuICAgIGNhc2UgJ2Jhc2U2NCc6XG4gICAgICByZXQgPSBiYXNlNjRUb0J5dGVzKHN0cikubGVuZ3RoXG4gICAgICBicmVha1xuICAgIGNhc2UgJ3VjczInOlxuICAgIGNhc2UgJ3Vjcy0yJzpcbiAgICBjYXNlICd1dGYxNmxlJzpcbiAgICBjYXNlICd1dGYtMTZsZSc6XG4gICAgICByZXQgPSBzdHIubGVuZ3RoICogMlxuICAgICAgYnJlYWtcbiAgICBkZWZhdWx0OlxuICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbmtub3duIGVuY29kaW5nJylcbiAgfVxuICByZXR1cm4gcmV0XG59XG5cbkJ1ZmZlci5jb25jYXQgPSBmdW5jdGlvbiAobGlzdCwgdG90YWxMZW5ndGgpIHtcbiAgYXNzZXJ0KGlzQXJyYXkobGlzdCksICdVc2FnZTogQnVmZmVyLmNvbmNhdChsaXN0LCBbdG90YWxMZW5ndGhdKVxcbicgK1xuICAgICAgJ2xpc3Qgc2hvdWxkIGJlIGFuIEFycmF5LicpXG5cbiAgaWYgKGxpc3QubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIG5ldyBCdWZmZXIoMClcbiAgfSBlbHNlIGlmIChsaXN0Lmxlbmd0aCA9PT0gMSkge1xuICAgIHJldHVybiBsaXN0WzBdXG4gIH1cblxuICB2YXIgaVxuICBpZiAodHlwZW9mIHRvdGFsTGVuZ3RoICE9PSAnbnVtYmVyJykge1xuICAgIHRvdGFsTGVuZ3RoID0gMFxuICAgIGZvciAoaSA9IDA7IGkgPCBsaXN0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICB0b3RhbExlbmd0aCArPSBsaXN0W2ldLmxlbmd0aFxuICAgIH1cbiAgfVxuXG4gIHZhciBidWYgPSBuZXcgQnVmZmVyKHRvdGFsTGVuZ3RoKVxuICB2YXIgcG9zID0gMFxuICBmb3IgKGkgPSAwOyBpIDwgbGlzdC5sZW5ndGg7IGkrKykge1xuICAgIHZhciBpdGVtID0gbGlzdFtpXVxuICAgIGl0ZW0uY29weShidWYsIHBvcylcbiAgICBwb3MgKz0gaXRlbS5sZW5ndGhcbiAgfVxuICByZXR1cm4gYnVmXG59XG5cbi8vIEJVRkZFUiBJTlNUQU5DRSBNRVRIT0RTXG4vLyA9PT09PT09PT09PT09PT09PT09PT09PVxuXG5mdW5jdGlvbiBfaGV4V3JpdGUgKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkge1xuICBvZmZzZXQgPSBOdW1iZXIob2Zmc2V0KSB8fCAwXG4gIHZhciByZW1haW5pbmcgPSBidWYubGVuZ3RoIC0gb2Zmc2V0XG4gIGlmICghbGVuZ3RoKSB7XG4gICAgbGVuZ3RoID0gcmVtYWluaW5nXG4gIH0gZWxzZSB7XG4gICAgbGVuZ3RoID0gTnVtYmVyKGxlbmd0aClcbiAgICBpZiAobGVuZ3RoID4gcmVtYWluaW5nKSB7XG4gICAgICBsZW5ndGggPSByZW1haW5pbmdcbiAgICB9XG4gIH1cblxuICAvLyBtdXN0IGJlIGFuIGV2ZW4gbnVtYmVyIG9mIGRpZ2l0c1xuICB2YXIgc3RyTGVuID0gc3RyaW5nLmxlbmd0aFxuICBhc3NlcnQoc3RyTGVuICUgMiA9PT0gMCwgJ0ludmFsaWQgaGV4IHN0cmluZycpXG5cbiAgaWYgKGxlbmd0aCA+IHN0ckxlbiAvIDIpIHtcbiAgICBsZW5ndGggPSBzdHJMZW4gLyAyXG4gIH1cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgIHZhciBieXRlID0gcGFyc2VJbnQoc3RyaW5nLnN1YnN0cihpICogMiwgMiksIDE2KVxuICAgIGFzc2VydCghaXNOYU4oYnl0ZSksICdJbnZhbGlkIGhleCBzdHJpbmcnKVxuICAgIGJ1ZltvZmZzZXQgKyBpXSA9IGJ5dGVcbiAgfVxuICBCdWZmZXIuX2NoYXJzV3JpdHRlbiA9IGkgKiAyXG4gIHJldHVybiBpXG59XG5cbmZ1bmN0aW9uIF91dGY4V3JpdGUgKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkge1xuICB2YXIgY2hhcnNXcml0dGVuID0gQnVmZmVyLl9jaGFyc1dyaXR0ZW4gPVxuICAgIGJsaXRCdWZmZXIodXRmOFRvQnl0ZXMoc3RyaW5nKSwgYnVmLCBvZmZzZXQsIGxlbmd0aClcbiAgcmV0dXJuIGNoYXJzV3JpdHRlblxufVxuXG5mdW5jdGlvbiBfYXNjaWlXcml0ZSAoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIHZhciBjaGFyc1dyaXR0ZW4gPSBCdWZmZXIuX2NoYXJzV3JpdHRlbiA9XG4gICAgYmxpdEJ1ZmZlcihhc2NpaVRvQnl0ZXMoc3RyaW5nKSwgYnVmLCBvZmZzZXQsIGxlbmd0aClcbiAgcmV0dXJuIGNoYXJzV3JpdHRlblxufVxuXG5mdW5jdGlvbiBfYmluYXJ5V3JpdGUgKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkge1xuICByZXR1cm4gX2FzY2lpV3JpdGUoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxufVxuXG5mdW5jdGlvbiBfYmFzZTY0V3JpdGUgKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkge1xuICB2YXIgY2hhcnNXcml0dGVuID0gQnVmZmVyLl9jaGFyc1dyaXR0ZW4gPVxuICAgIGJsaXRCdWZmZXIoYmFzZTY0VG9CeXRlcyhzdHJpbmcpLCBidWYsIG9mZnNldCwgbGVuZ3RoKVxuICByZXR1cm4gY2hhcnNXcml0dGVuXG59XG5cbmZ1bmN0aW9uIF91dGYxNmxlV3JpdGUgKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkge1xuICB2YXIgY2hhcnNXcml0dGVuID0gQnVmZmVyLl9jaGFyc1dyaXR0ZW4gPVxuICAgIGJsaXRCdWZmZXIodXRmMTZsZVRvQnl0ZXMoc3RyaW5nKSwgYnVmLCBvZmZzZXQsIGxlbmd0aClcbiAgcmV0dXJuIGNoYXJzV3JpdHRlblxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlID0gZnVuY3Rpb24gKHN0cmluZywgb2Zmc2V0LCBsZW5ndGgsIGVuY29kaW5nKSB7XG4gIC8vIFN1cHBvcnQgYm90aCAoc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCwgZW5jb2RpbmcpXG4gIC8vIGFuZCB0aGUgbGVnYWN5IChzdHJpbmcsIGVuY29kaW5nLCBvZmZzZXQsIGxlbmd0aClcbiAgaWYgKGlzRmluaXRlKG9mZnNldCkpIHtcbiAgICBpZiAoIWlzRmluaXRlKGxlbmd0aCkpIHtcbiAgICAgIGVuY29kaW5nID0gbGVuZ3RoXG4gICAgICBsZW5ndGggPSB1bmRlZmluZWRcbiAgICB9XG4gIH0gZWxzZSB7ICAvLyBsZWdhY3lcbiAgICB2YXIgc3dhcCA9IGVuY29kaW5nXG4gICAgZW5jb2RpbmcgPSBvZmZzZXRcbiAgICBvZmZzZXQgPSBsZW5ndGhcbiAgICBsZW5ndGggPSBzd2FwXG4gIH1cblxuICBvZmZzZXQgPSBOdW1iZXIob2Zmc2V0KSB8fCAwXG4gIHZhciByZW1haW5pbmcgPSB0aGlzLmxlbmd0aCAtIG9mZnNldFxuICBpZiAoIWxlbmd0aCkge1xuICAgIGxlbmd0aCA9IHJlbWFpbmluZ1xuICB9IGVsc2Uge1xuICAgIGxlbmd0aCA9IE51bWJlcihsZW5ndGgpXG4gICAgaWYgKGxlbmd0aCA+IHJlbWFpbmluZykge1xuICAgICAgbGVuZ3RoID0gcmVtYWluaW5nXG4gICAgfVxuICB9XG4gIGVuY29kaW5nID0gU3RyaW5nKGVuY29kaW5nIHx8ICd1dGY4JykudG9Mb3dlckNhc2UoKVxuXG4gIHZhciByZXRcbiAgc3dpdGNoIChlbmNvZGluZykge1xuICAgIGNhc2UgJ2hleCc6XG4gICAgICByZXQgPSBfaGV4V3JpdGUodGhpcywgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcbiAgICAgIGJyZWFrXG4gICAgY2FzZSAndXRmOCc6XG4gICAgY2FzZSAndXRmLTgnOlxuICAgICAgcmV0ID0gX3V0ZjhXcml0ZSh0aGlzLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxuICAgICAgYnJlYWtcbiAgICBjYXNlICdhc2NpaSc6XG4gICAgICByZXQgPSBfYXNjaWlXcml0ZSh0aGlzLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxuICAgICAgYnJlYWtcbiAgICBjYXNlICdiaW5hcnknOlxuICAgICAgcmV0ID0gX2JpbmFyeVdyaXRlKHRoaXMsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG4gICAgICBicmVha1xuICAgIGNhc2UgJ2Jhc2U2NCc6XG4gICAgICByZXQgPSBfYmFzZTY0V3JpdGUodGhpcywgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcbiAgICAgIGJyZWFrXG4gICAgY2FzZSAndWNzMic6XG4gICAgY2FzZSAndWNzLTInOlxuICAgIGNhc2UgJ3V0ZjE2bGUnOlxuICAgIGNhc2UgJ3V0Zi0xNmxlJzpcbiAgICAgIHJldCA9IF91dGYxNmxlV3JpdGUodGhpcywgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcbiAgICAgIGJyZWFrXG4gICAgZGVmYXVsdDpcbiAgICAgIHRocm93IG5ldyBFcnJvcignVW5rbm93biBlbmNvZGluZycpXG4gIH1cbiAgcmV0dXJuIHJldFxufVxuXG5CdWZmZXIucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gKGVuY29kaW5nLCBzdGFydCwgZW5kKSB7XG4gIHZhciBzZWxmID0gdGhpc1xuXG4gIGVuY29kaW5nID0gU3RyaW5nKGVuY29kaW5nIHx8ICd1dGY4JykudG9Mb3dlckNhc2UoKVxuICBzdGFydCA9IE51bWJlcihzdGFydCkgfHwgMFxuICBlbmQgPSAoZW5kICE9PSB1bmRlZmluZWQpXG4gICAgPyBOdW1iZXIoZW5kKVxuICAgIDogZW5kID0gc2VsZi5sZW5ndGhcblxuICAvLyBGYXN0cGF0aCBlbXB0eSBzdHJpbmdzXG4gIGlmIChlbmQgPT09IHN0YXJ0KVxuICAgIHJldHVybiAnJ1xuXG4gIHZhciByZXRcbiAgc3dpdGNoIChlbmNvZGluZykge1xuICAgIGNhc2UgJ2hleCc6XG4gICAgICByZXQgPSBfaGV4U2xpY2Uoc2VsZiwgc3RhcnQsIGVuZClcbiAgICAgIGJyZWFrXG4gICAgY2FzZSAndXRmOCc6XG4gICAgY2FzZSAndXRmLTgnOlxuICAgICAgcmV0ID0gX3V0ZjhTbGljZShzZWxmLCBzdGFydCwgZW5kKVxuICAgICAgYnJlYWtcbiAgICBjYXNlICdhc2NpaSc6XG4gICAgICByZXQgPSBfYXNjaWlTbGljZShzZWxmLCBzdGFydCwgZW5kKVxuICAgICAgYnJlYWtcbiAgICBjYXNlICdiaW5hcnknOlxuICAgICAgcmV0ID0gX2JpbmFyeVNsaWNlKHNlbGYsIHN0YXJ0LCBlbmQpXG4gICAgICBicmVha1xuICAgIGNhc2UgJ2Jhc2U2NCc6XG4gICAgICByZXQgPSBfYmFzZTY0U2xpY2Uoc2VsZiwgc3RhcnQsIGVuZClcbiAgICAgIGJyZWFrXG4gICAgY2FzZSAndWNzMic6XG4gICAgY2FzZSAndWNzLTInOlxuICAgIGNhc2UgJ3V0ZjE2bGUnOlxuICAgIGNhc2UgJ3V0Zi0xNmxlJzpcbiAgICAgIHJldCA9IF91dGYxNmxlU2xpY2Uoc2VsZiwgc3RhcnQsIGVuZClcbiAgICAgIGJyZWFrXG4gICAgZGVmYXVsdDpcbiAgICAgIHRocm93IG5ldyBFcnJvcignVW5rbm93biBlbmNvZGluZycpXG4gIH1cbiAgcmV0dXJuIHJldFxufVxuXG5CdWZmZXIucHJvdG90eXBlLnRvSlNPTiA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHtcbiAgICB0eXBlOiAnQnVmZmVyJyxcbiAgICBkYXRhOiBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbCh0aGlzLl9hcnIgfHwgdGhpcywgMClcbiAgfVxufVxuXG4vLyBjb3B5KHRhcmdldEJ1ZmZlciwgdGFyZ2V0U3RhcnQ9MCwgc291cmNlU3RhcnQ9MCwgc291cmNlRW5kPWJ1ZmZlci5sZW5ndGgpXG5CdWZmZXIucHJvdG90eXBlLmNvcHkgPSBmdW5jdGlvbiAodGFyZ2V0LCB0YXJnZXRfc3RhcnQsIHN0YXJ0LCBlbmQpIHtcbiAgdmFyIHNvdXJjZSA9IHRoaXNcblxuICBpZiAoIXN0YXJ0KSBzdGFydCA9IDBcbiAgaWYgKCFlbmQgJiYgZW5kICE9PSAwKSBlbmQgPSB0aGlzLmxlbmd0aFxuICBpZiAoIXRhcmdldF9zdGFydCkgdGFyZ2V0X3N0YXJ0ID0gMFxuXG4gIC8vIENvcHkgMCBieXRlczsgd2UncmUgZG9uZVxuICBpZiAoZW5kID09PSBzdGFydCkgcmV0dXJuXG4gIGlmICh0YXJnZXQubGVuZ3RoID09PSAwIHx8IHNvdXJjZS5sZW5ndGggPT09IDApIHJldHVyblxuXG4gIC8vIEZhdGFsIGVycm9yIGNvbmRpdGlvbnNcbiAgYXNzZXJ0KGVuZCA+PSBzdGFydCwgJ3NvdXJjZUVuZCA8IHNvdXJjZVN0YXJ0JylcbiAgYXNzZXJ0KHRhcmdldF9zdGFydCA+PSAwICYmIHRhcmdldF9zdGFydCA8IHRhcmdldC5sZW5ndGgsXG4gICAgICAndGFyZ2V0U3RhcnQgb3V0IG9mIGJvdW5kcycpXG4gIGFzc2VydChzdGFydCA+PSAwICYmIHN0YXJ0IDwgc291cmNlLmxlbmd0aCwgJ3NvdXJjZVN0YXJ0IG91dCBvZiBib3VuZHMnKVxuICBhc3NlcnQoZW5kID49IDAgJiYgZW5kIDw9IHNvdXJjZS5sZW5ndGgsICdzb3VyY2VFbmQgb3V0IG9mIGJvdW5kcycpXG5cbiAgLy8gQXJlIHdlIG9vYj9cbiAgaWYgKGVuZCA+IHRoaXMubGVuZ3RoKVxuICAgIGVuZCA9IHRoaXMubGVuZ3RoXG4gIGlmICh0YXJnZXQubGVuZ3RoIC0gdGFyZ2V0X3N0YXJ0IDwgZW5kIC0gc3RhcnQpXG4gICAgZW5kID0gdGFyZ2V0Lmxlbmd0aCAtIHRhcmdldF9zdGFydCArIHN0YXJ0XG5cbiAgdmFyIGxlbiA9IGVuZCAtIHN0YXJ0XG5cbiAgaWYgKGxlbiA8IDEwMCB8fCAhQnVmZmVyLl91c2VUeXBlZEFycmF5cykge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspXG4gICAgICB0YXJnZXRbaSArIHRhcmdldF9zdGFydF0gPSB0aGlzW2kgKyBzdGFydF1cbiAgfSBlbHNlIHtcbiAgICB0YXJnZXQuX3NldCh0aGlzLnN1YmFycmF5KHN0YXJ0LCBzdGFydCArIGxlbiksIHRhcmdldF9zdGFydClcbiAgfVxufVxuXG5mdW5jdGlvbiBfYmFzZTY0U2xpY2UgKGJ1Ziwgc3RhcnQsIGVuZCkge1xuICBpZiAoc3RhcnQgPT09IDAgJiYgZW5kID09PSBidWYubGVuZ3RoKSB7XG4gICAgcmV0dXJuIGJhc2U2NC5mcm9tQnl0ZUFycmF5KGJ1ZilcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gYmFzZTY0LmZyb21CeXRlQXJyYXkoYnVmLnNsaWNlKHN0YXJ0LCBlbmQpKVxuICB9XG59XG5cbmZ1bmN0aW9uIF91dGY4U2xpY2UgKGJ1Ziwgc3RhcnQsIGVuZCkge1xuICB2YXIgcmVzID0gJydcbiAgdmFyIHRtcCA9ICcnXG4gIGVuZCA9IE1hdGgubWluKGJ1Zi5sZW5ndGgsIGVuZClcblxuICBmb3IgKHZhciBpID0gc3RhcnQ7IGkgPCBlbmQ7IGkrKykge1xuICAgIGlmIChidWZbaV0gPD0gMHg3Rikge1xuICAgICAgcmVzICs9IGRlY29kZVV0ZjhDaGFyKHRtcCkgKyBTdHJpbmcuZnJvbUNoYXJDb2RlKGJ1ZltpXSlcbiAgICAgIHRtcCA9ICcnXG4gICAgfSBlbHNlIHtcbiAgICAgIHRtcCArPSAnJScgKyBidWZbaV0udG9TdHJpbmcoMTYpXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHJlcyArIGRlY29kZVV0ZjhDaGFyKHRtcClcbn1cblxuZnVuY3Rpb24gX2FzY2lpU2xpY2UgKGJ1Ziwgc3RhcnQsIGVuZCkge1xuICB2YXIgcmV0ID0gJydcbiAgZW5kID0gTWF0aC5taW4oYnVmLmxlbmd0aCwgZW5kKVxuXG4gIGZvciAodmFyIGkgPSBzdGFydDsgaSA8IGVuZDsgaSsrKVxuICAgIHJldCArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGJ1ZltpXSlcbiAgcmV0dXJuIHJldFxufVxuXG5mdW5jdGlvbiBfYmluYXJ5U2xpY2UgKGJ1Ziwgc3RhcnQsIGVuZCkge1xuICByZXR1cm4gX2FzY2lpU2xpY2UoYnVmLCBzdGFydCwgZW5kKVxufVxuXG5mdW5jdGlvbiBfaGV4U2xpY2UgKGJ1Ziwgc3RhcnQsIGVuZCkge1xuICB2YXIgbGVuID0gYnVmLmxlbmd0aFxuXG4gIGlmICghc3RhcnQgfHwgc3RhcnQgPCAwKSBzdGFydCA9IDBcbiAgaWYgKCFlbmQgfHwgZW5kIDwgMCB8fCBlbmQgPiBsZW4pIGVuZCA9IGxlblxuXG4gIHZhciBvdXQgPSAnJ1xuICBmb3IgKHZhciBpID0gc3RhcnQ7IGkgPCBlbmQ7IGkrKykge1xuICAgIG91dCArPSB0b0hleChidWZbaV0pXG4gIH1cbiAgcmV0dXJuIG91dFxufVxuXG5mdW5jdGlvbiBfdXRmMTZsZVNsaWNlIChidWYsIHN0YXJ0LCBlbmQpIHtcbiAgdmFyIGJ5dGVzID0gYnVmLnNsaWNlKHN0YXJ0LCBlbmQpXG4gIHZhciByZXMgPSAnJ1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGJ5dGVzLmxlbmd0aDsgaSArPSAyKSB7XG4gICAgcmVzICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoYnl0ZXNbaV0gKyBieXRlc1tpKzFdICogMjU2KVxuICB9XG4gIHJldHVybiByZXNcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5zbGljZSA9IGZ1bmN0aW9uIChzdGFydCwgZW5kKSB7XG4gIHZhciBsZW4gPSB0aGlzLmxlbmd0aFxuICBzdGFydCA9IGNsYW1wKHN0YXJ0LCBsZW4sIDApXG4gIGVuZCA9IGNsYW1wKGVuZCwgbGVuLCBsZW4pXG5cbiAgaWYgKEJ1ZmZlci5fdXNlVHlwZWRBcnJheXMpIHtcbiAgICByZXR1cm4gQnVmZmVyLl9hdWdtZW50KHRoaXMuc3ViYXJyYXkoc3RhcnQsIGVuZCkpXG4gIH0gZWxzZSB7XG4gICAgdmFyIHNsaWNlTGVuID0gZW5kIC0gc3RhcnRcbiAgICB2YXIgbmV3QnVmID0gbmV3IEJ1ZmZlcihzbGljZUxlbiwgdW5kZWZpbmVkLCB0cnVlKVxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc2xpY2VMZW47IGkrKykge1xuICAgICAgbmV3QnVmW2ldID0gdGhpc1tpICsgc3RhcnRdXG4gICAgfVxuICAgIHJldHVybiBuZXdCdWZcbiAgfVxufVxuXG4vLyBgZ2V0YCB3aWxsIGJlIHJlbW92ZWQgaW4gTm9kZSAwLjEzK1xuQnVmZmVyLnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbiAob2Zmc2V0KSB7XG4gIGNvbnNvbGUubG9nKCcuZ2V0KCkgaXMgZGVwcmVjYXRlZC4gQWNjZXNzIHVzaW5nIGFycmF5IGluZGV4ZXMgaW5zdGVhZC4nKVxuICByZXR1cm4gdGhpcy5yZWFkVUludDgob2Zmc2V0KVxufVxuXG4vLyBgc2V0YCB3aWxsIGJlIHJlbW92ZWQgaW4gTm9kZSAwLjEzK1xuQnVmZmVyLnByb3RvdHlwZS5zZXQgPSBmdW5jdGlvbiAodiwgb2Zmc2V0KSB7XG4gIGNvbnNvbGUubG9nKCcuc2V0KCkgaXMgZGVwcmVjYXRlZC4gQWNjZXNzIHVzaW5nIGFycmF5IGluZGV4ZXMgaW5zdGVhZC4nKVxuICByZXR1cm4gdGhpcy53cml0ZVVJbnQ4KHYsIG9mZnNldClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDggPSBmdW5jdGlvbiAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgYXNzZXJ0KG9mZnNldCAhPT0gdW5kZWZpbmVkICYmIG9mZnNldCAhPT0gbnVsbCwgJ21pc3Npbmcgb2Zmc2V0JylcbiAgICBhc3NlcnQob2Zmc2V0IDwgdGhpcy5sZW5ndGgsICdUcnlpbmcgdG8gcmVhZCBiZXlvbmQgYnVmZmVyIGxlbmd0aCcpXG4gIH1cblxuICBpZiAob2Zmc2V0ID49IHRoaXMubGVuZ3RoKVxuICAgIHJldHVyblxuXG4gIHJldHVybiB0aGlzW29mZnNldF1cbn1cblxuZnVuY3Rpb24gX3JlYWRVSW50MTYgKGJ1Ziwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4sIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICBhc3NlcnQodHlwZW9mIGxpdHRsZUVuZGlhbiA9PT0gJ2Jvb2xlYW4nLCAnbWlzc2luZyBvciBpbnZhbGlkIGVuZGlhbicpXG4gICAgYXNzZXJ0KG9mZnNldCAhPT0gdW5kZWZpbmVkICYmIG9mZnNldCAhPT0gbnVsbCwgJ21pc3Npbmcgb2Zmc2V0JylcbiAgICBhc3NlcnQob2Zmc2V0ICsgMSA8IGJ1Zi5sZW5ndGgsICdUcnlpbmcgdG8gcmVhZCBiZXlvbmQgYnVmZmVyIGxlbmd0aCcpXG4gIH1cblxuICB2YXIgbGVuID0gYnVmLmxlbmd0aFxuICBpZiAob2Zmc2V0ID49IGxlbilcbiAgICByZXR1cm5cblxuICB2YXIgdmFsXG4gIGlmIChsaXR0bGVFbmRpYW4pIHtcbiAgICB2YWwgPSBidWZbb2Zmc2V0XVxuICAgIGlmIChvZmZzZXQgKyAxIDwgbGVuKVxuICAgICAgdmFsIHw9IGJ1ZltvZmZzZXQgKyAxXSA8PCA4XG4gIH0gZWxzZSB7XG4gICAgdmFsID0gYnVmW29mZnNldF0gPDwgOFxuICAgIGlmIChvZmZzZXQgKyAxIDwgbGVuKVxuICAgICAgdmFsIHw9IGJ1ZltvZmZzZXQgKyAxXVxuICB9XG4gIHJldHVybiB2YWxcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDE2TEUgPSBmdW5jdGlvbiAob2Zmc2V0LCBub0Fzc2VydCkge1xuICByZXR1cm4gX3JlYWRVSW50MTYodGhpcywgb2Zmc2V0LCB0cnVlLCBub0Fzc2VydClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDE2QkUgPSBmdW5jdGlvbiAob2Zmc2V0LCBub0Fzc2VydCkge1xuICByZXR1cm4gX3JlYWRVSW50MTYodGhpcywgb2Zmc2V0LCBmYWxzZSwgbm9Bc3NlcnQpXG59XG5cbmZ1bmN0aW9uIF9yZWFkVUludDMyIChidWYsIG9mZnNldCwgbGl0dGxlRW5kaWFuLCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgYXNzZXJ0KHR5cGVvZiBsaXR0bGVFbmRpYW4gPT09ICdib29sZWFuJywgJ21pc3Npbmcgb3IgaW52YWxpZCBlbmRpYW4nKVxuICAgIGFzc2VydChvZmZzZXQgIT09IHVuZGVmaW5lZCAmJiBvZmZzZXQgIT09IG51bGwsICdtaXNzaW5nIG9mZnNldCcpXG4gICAgYXNzZXJ0KG9mZnNldCArIDMgPCBidWYubGVuZ3RoLCAnVHJ5aW5nIHRvIHJlYWQgYmV5b25kIGJ1ZmZlciBsZW5ndGgnKVxuICB9XG5cbiAgdmFyIGxlbiA9IGJ1Zi5sZW5ndGhcbiAgaWYgKG9mZnNldCA+PSBsZW4pXG4gICAgcmV0dXJuXG5cbiAgdmFyIHZhbFxuICBpZiAobGl0dGxlRW5kaWFuKSB7XG4gICAgaWYgKG9mZnNldCArIDIgPCBsZW4pXG4gICAgICB2YWwgPSBidWZbb2Zmc2V0ICsgMl0gPDwgMTZcbiAgICBpZiAob2Zmc2V0ICsgMSA8IGxlbilcbiAgICAgIHZhbCB8PSBidWZbb2Zmc2V0ICsgMV0gPDwgOFxuICAgIHZhbCB8PSBidWZbb2Zmc2V0XVxuICAgIGlmIChvZmZzZXQgKyAzIDwgbGVuKVxuICAgICAgdmFsID0gdmFsICsgKGJ1ZltvZmZzZXQgKyAzXSA8PCAyNCA+Pj4gMClcbiAgfSBlbHNlIHtcbiAgICBpZiAob2Zmc2V0ICsgMSA8IGxlbilcbiAgICAgIHZhbCA9IGJ1ZltvZmZzZXQgKyAxXSA8PCAxNlxuICAgIGlmIChvZmZzZXQgKyAyIDwgbGVuKVxuICAgICAgdmFsIHw9IGJ1ZltvZmZzZXQgKyAyXSA8PCA4XG4gICAgaWYgKG9mZnNldCArIDMgPCBsZW4pXG4gICAgICB2YWwgfD0gYnVmW29mZnNldCArIDNdXG4gICAgdmFsID0gdmFsICsgKGJ1ZltvZmZzZXRdIDw8IDI0ID4+PiAwKVxuICB9XG4gIHJldHVybiB2YWxcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDMyTEUgPSBmdW5jdGlvbiAob2Zmc2V0LCBub0Fzc2VydCkge1xuICByZXR1cm4gX3JlYWRVSW50MzIodGhpcywgb2Zmc2V0LCB0cnVlLCBub0Fzc2VydClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDMyQkUgPSBmdW5jdGlvbiAob2Zmc2V0LCBub0Fzc2VydCkge1xuICByZXR1cm4gX3JlYWRVSW50MzIodGhpcywgb2Zmc2V0LCBmYWxzZSwgbm9Bc3NlcnQpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludDggPSBmdW5jdGlvbiAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgYXNzZXJ0KG9mZnNldCAhPT0gdW5kZWZpbmVkICYmIG9mZnNldCAhPT0gbnVsbCxcbiAgICAgICAgJ21pc3Npbmcgb2Zmc2V0JylcbiAgICBhc3NlcnQob2Zmc2V0IDwgdGhpcy5sZW5ndGgsICdUcnlpbmcgdG8gcmVhZCBiZXlvbmQgYnVmZmVyIGxlbmd0aCcpXG4gIH1cblxuICBpZiAob2Zmc2V0ID49IHRoaXMubGVuZ3RoKVxuICAgIHJldHVyblxuXG4gIHZhciBuZWcgPSB0aGlzW29mZnNldF0gJiAweDgwXG4gIGlmIChuZWcpXG4gICAgcmV0dXJuICgweGZmIC0gdGhpc1tvZmZzZXRdICsgMSkgKiAtMVxuICBlbHNlXG4gICAgcmV0dXJuIHRoaXNbb2Zmc2V0XVxufVxuXG5mdW5jdGlvbiBfcmVhZEludDE2IChidWYsIG9mZnNldCwgbGl0dGxlRW5kaWFuLCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgYXNzZXJ0KHR5cGVvZiBsaXR0bGVFbmRpYW4gPT09ICdib29sZWFuJywgJ21pc3Npbmcgb3IgaW52YWxpZCBlbmRpYW4nKVxuICAgIGFzc2VydChvZmZzZXQgIT09IHVuZGVmaW5lZCAmJiBvZmZzZXQgIT09IG51bGwsICdtaXNzaW5nIG9mZnNldCcpXG4gICAgYXNzZXJ0KG9mZnNldCArIDEgPCBidWYubGVuZ3RoLCAnVHJ5aW5nIHRvIHJlYWQgYmV5b25kIGJ1ZmZlciBsZW5ndGgnKVxuICB9XG5cbiAgdmFyIGxlbiA9IGJ1Zi5sZW5ndGhcbiAgaWYgKG9mZnNldCA+PSBsZW4pXG4gICAgcmV0dXJuXG5cbiAgdmFyIHZhbCA9IF9yZWFkVUludDE2KGJ1Ziwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4sIHRydWUpXG4gIHZhciBuZWcgPSB2YWwgJiAweDgwMDBcbiAgaWYgKG5lZylcbiAgICByZXR1cm4gKDB4ZmZmZiAtIHZhbCArIDEpICogLTFcbiAgZWxzZVxuICAgIHJldHVybiB2YWxcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50MTZMRSA9IGZ1bmN0aW9uIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHJldHVybiBfcmVhZEludDE2KHRoaXMsIG9mZnNldCwgdHJ1ZSwgbm9Bc3NlcnQpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludDE2QkUgPSBmdW5jdGlvbiAob2Zmc2V0LCBub0Fzc2VydCkge1xuICByZXR1cm4gX3JlYWRJbnQxNih0aGlzLCBvZmZzZXQsIGZhbHNlLCBub0Fzc2VydClcbn1cblxuZnVuY3Rpb24gX3JlYWRJbnQzMiAoYnVmLCBvZmZzZXQsIGxpdHRsZUVuZGlhbiwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIGFzc2VydCh0eXBlb2YgbGl0dGxlRW5kaWFuID09PSAnYm9vbGVhbicsICdtaXNzaW5nIG9yIGludmFsaWQgZW5kaWFuJylcbiAgICBhc3NlcnQob2Zmc2V0ICE9PSB1bmRlZmluZWQgJiYgb2Zmc2V0ICE9PSBudWxsLCAnbWlzc2luZyBvZmZzZXQnKVxuICAgIGFzc2VydChvZmZzZXQgKyAzIDwgYnVmLmxlbmd0aCwgJ1RyeWluZyB0byByZWFkIGJleW9uZCBidWZmZXIgbGVuZ3RoJylcbiAgfVxuXG4gIHZhciBsZW4gPSBidWYubGVuZ3RoXG4gIGlmIChvZmZzZXQgPj0gbGVuKVxuICAgIHJldHVyblxuXG4gIHZhciB2YWwgPSBfcmVhZFVJbnQzMihidWYsIG9mZnNldCwgbGl0dGxlRW5kaWFuLCB0cnVlKVxuICB2YXIgbmVnID0gdmFsICYgMHg4MDAwMDAwMFxuICBpZiAobmVnKVxuICAgIHJldHVybiAoMHhmZmZmZmZmZiAtIHZhbCArIDEpICogLTFcbiAgZWxzZVxuICAgIHJldHVybiB2YWxcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50MzJMRSA9IGZ1bmN0aW9uIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHJldHVybiBfcmVhZEludDMyKHRoaXMsIG9mZnNldCwgdHJ1ZSwgbm9Bc3NlcnQpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludDMyQkUgPSBmdW5jdGlvbiAob2Zmc2V0LCBub0Fzc2VydCkge1xuICByZXR1cm4gX3JlYWRJbnQzMih0aGlzLCBvZmZzZXQsIGZhbHNlLCBub0Fzc2VydClcbn1cblxuZnVuY3Rpb24gX3JlYWRGbG9hdCAoYnVmLCBvZmZzZXQsIGxpdHRsZUVuZGlhbiwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIGFzc2VydCh0eXBlb2YgbGl0dGxlRW5kaWFuID09PSAnYm9vbGVhbicsICdtaXNzaW5nIG9yIGludmFsaWQgZW5kaWFuJylcbiAgICBhc3NlcnQob2Zmc2V0ICsgMyA8IGJ1Zi5sZW5ndGgsICdUcnlpbmcgdG8gcmVhZCBiZXlvbmQgYnVmZmVyIGxlbmd0aCcpXG4gIH1cblxuICByZXR1cm4gaWVlZTc1NC5yZWFkKGJ1Ziwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4sIDIzLCA0KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRGbG9hdExFID0gZnVuY3Rpb24gKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgcmV0dXJuIF9yZWFkRmxvYXQodGhpcywgb2Zmc2V0LCB0cnVlLCBub0Fzc2VydClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkRmxvYXRCRSA9IGZ1bmN0aW9uIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHJldHVybiBfcmVhZEZsb2F0KHRoaXMsIG9mZnNldCwgZmFsc2UsIG5vQXNzZXJ0KVxufVxuXG5mdW5jdGlvbiBfcmVhZERvdWJsZSAoYnVmLCBvZmZzZXQsIGxpdHRsZUVuZGlhbiwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIGFzc2VydCh0eXBlb2YgbGl0dGxlRW5kaWFuID09PSAnYm9vbGVhbicsICdtaXNzaW5nIG9yIGludmFsaWQgZW5kaWFuJylcbiAgICBhc3NlcnQob2Zmc2V0ICsgNyA8IGJ1Zi5sZW5ndGgsICdUcnlpbmcgdG8gcmVhZCBiZXlvbmQgYnVmZmVyIGxlbmd0aCcpXG4gIH1cblxuICByZXR1cm4gaWVlZTc1NC5yZWFkKGJ1Ziwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4sIDUyLCA4KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWREb3VibGVMRSA9IGZ1bmN0aW9uIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHJldHVybiBfcmVhZERvdWJsZSh0aGlzLCBvZmZzZXQsIHRydWUsIG5vQXNzZXJ0KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWREb3VibGVCRSA9IGZ1bmN0aW9uIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHJldHVybiBfcmVhZERvdWJsZSh0aGlzLCBvZmZzZXQsIGZhbHNlLCBub0Fzc2VydClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQ4ID0gZnVuY3Rpb24gKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICBhc3NlcnQodmFsdWUgIT09IHVuZGVmaW5lZCAmJiB2YWx1ZSAhPT0gbnVsbCwgJ21pc3NpbmcgdmFsdWUnKVxuICAgIGFzc2VydChvZmZzZXQgIT09IHVuZGVmaW5lZCAmJiBvZmZzZXQgIT09IG51bGwsICdtaXNzaW5nIG9mZnNldCcpXG4gICAgYXNzZXJ0KG9mZnNldCA8IHRoaXMubGVuZ3RoLCAndHJ5aW5nIHRvIHdyaXRlIGJleW9uZCBidWZmZXIgbGVuZ3RoJylcbiAgICB2ZXJpZnVpbnQodmFsdWUsIDB4ZmYpXG4gIH1cblxuICBpZiAob2Zmc2V0ID49IHRoaXMubGVuZ3RoKSByZXR1cm5cblxuICB0aGlzW29mZnNldF0gPSB2YWx1ZVxufVxuXG5mdW5jdGlvbiBfd3JpdGVVSW50MTYgKGJ1ZiwgdmFsdWUsIG9mZnNldCwgbGl0dGxlRW5kaWFuLCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgYXNzZXJ0KHZhbHVlICE9PSB1bmRlZmluZWQgJiYgdmFsdWUgIT09IG51bGwsICdtaXNzaW5nIHZhbHVlJylcbiAgICBhc3NlcnQodHlwZW9mIGxpdHRsZUVuZGlhbiA9PT0gJ2Jvb2xlYW4nLCAnbWlzc2luZyBvciBpbnZhbGlkIGVuZGlhbicpXG4gICAgYXNzZXJ0KG9mZnNldCAhPT0gdW5kZWZpbmVkICYmIG9mZnNldCAhPT0gbnVsbCwgJ21pc3Npbmcgb2Zmc2V0JylcbiAgICBhc3NlcnQob2Zmc2V0ICsgMSA8IGJ1Zi5sZW5ndGgsICd0cnlpbmcgdG8gd3JpdGUgYmV5b25kIGJ1ZmZlciBsZW5ndGgnKVxuICAgIHZlcmlmdWludCh2YWx1ZSwgMHhmZmZmKVxuICB9XG5cbiAgdmFyIGxlbiA9IGJ1Zi5sZW5ndGhcbiAgaWYgKG9mZnNldCA+PSBsZW4pXG4gICAgcmV0dXJuXG5cbiAgZm9yICh2YXIgaSA9IDAsIGogPSBNYXRoLm1pbihsZW4gLSBvZmZzZXQsIDIpOyBpIDwgajsgaSsrKSB7XG4gICAgYnVmW29mZnNldCArIGldID1cbiAgICAgICAgKHZhbHVlICYgKDB4ZmYgPDwgKDggKiAobGl0dGxlRW5kaWFuID8gaSA6IDEgLSBpKSkpKSA+Pj5cbiAgICAgICAgICAgIChsaXR0bGVFbmRpYW4gPyBpIDogMSAtIGkpICogOFxuICB9XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50MTZMRSA9IGZ1bmN0aW9uICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICBfd3JpdGVVSW50MTYodGhpcywgdmFsdWUsIG9mZnNldCwgdHJ1ZSwgbm9Bc3NlcnQpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50MTZCRSA9IGZ1bmN0aW9uICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICBfd3JpdGVVSW50MTYodGhpcywgdmFsdWUsIG9mZnNldCwgZmFsc2UsIG5vQXNzZXJ0KVxufVxuXG5mdW5jdGlvbiBfd3JpdGVVSW50MzIgKGJ1ZiwgdmFsdWUsIG9mZnNldCwgbGl0dGxlRW5kaWFuLCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgYXNzZXJ0KHZhbHVlICE9PSB1bmRlZmluZWQgJiYgdmFsdWUgIT09IG51bGwsICdtaXNzaW5nIHZhbHVlJylcbiAgICBhc3NlcnQodHlwZW9mIGxpdHRsZUVuZGlhbiA9PT0gJ2Jvb2xlYW4nLCAnbWlzc2luZyBvciBpbnZhbGlkIGVuZGlhbicpXG4gICAgYXNzZXJ0KG9mZnNldCAhPT0gdW5kZWZpbmVkICYmIG9mZnNldCAhPT0gbnVsbCwgJ21pc3Npbmcgb2Zmc2V0JylcbiAgICBhc3NlcnQob2Zmc2V0ICsgMyA8IGJ1Zi5sZW5ndGgsICd0cnlpbmcgdG8gd3JpdGUgYmV5b25kIGJ1ZmZlciBsZW5ndGgnKVxuICAgIHZlcmlmdWludCh2YWx1ZSwgMHhmZmZmZmZmZilcbiAgfVxuXG4gIHZhciBsZW4gPSBidWYubGVuZ3RoXG4gIGlmIChvZmZzZXQgPj0gbGVuKVxuICAgIHJldHVyblxuXG4gIGZvciAodmFyIGkgPSAwLCBqID0gTWF0aC5taW4obGVuIC0gb2Zmc2V0LCA0KTsgaSA8IGo7IGkrKykge1xuICAgIGJ1ZltvZmZzZXQgKyBpXSA9XG4gICAgICAgICh2YWx1ZSA+Pj4gKGxpdHRsZUVuZGlhbiA/IGkgOiAzIC0gaSkgKiA4KSAmIDB4ZmZcbiAgfVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludDMyTEUgPSBmdW5jdGlvbiAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgX3dyaXRlVUludDMyKHRoaXMsIHZhbHVlLCBvZmZzZXQsIHRydWUsIG5vQXNzZXJ0KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludDMyQkUgPSBmdW5jdGlvbiAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgX3dyaXRlVUludDMyKHRoaXMsIHZhbHVlLCBvZmZzZXQsIGZhbHNlLCBub0Fzc2VydClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludDggPSBmdW5jdGlvbiAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIGFzc2VydCh2YWx1ZSAhPT0gdW5kZWZpbmVkICYmIHZhbHVlICE9PSBudWxsLCAnbWlzc2luZyB2YWx1ZScpXG4gICAgYXNzZXJ0KG9mZnNldCAhPT0gdW5kZWZpbmVkICYmIG9mZnNldCAhPT0gbnVsbCwgJ21pc3Npbmcgb2Zmc2V0JylcbiAgICBhc3NlcnQob2Zmc2V0IDwgdGhpcy5sZW5ndGgsICdUcnlpbmcgdG8gd3JpdGUgYmV5b25kIGJ1ZmZlciBsZW5ndGgnKVxuICAgIHZlcmlmc2ludCh2YWx1ZSwgMHg3ZiwgLTB4ODApXG4gIH1cblxuICBpZiAob2Zmc2V0ID49IHRoaXMubGVuZ3RoKVxuICAgIHJldHVyblxuXG4gIGlmICh2YWx1ZSA+PSAwKVxuICAgIHRoaXMud3JpdGVVSW50OCh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydClcbiAgZWxzZVxuICAgIHRoaXMud3JpdGVVSW50OCgweGZmICsgdmFsdWUgKyAxLCBvZmZzZXQsIG5vQXNzZXJ0KVxufVxuXG5mdW5jdGlvbiBfd3JpdGVJbnQxNiAoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4sIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICBhc3NlcnQodmFsdWUgIT09IHVuZGVmaW5lZCAmJiB2YWx1ZSAhPT0gbnVsbCwgJ21pc3NpbmcgdmFsdWUnKVxuICAgIGFzc2VydCh0eXBlb2YgbGl0dGxlRW5kaWFuID09PSAnYm9vbGVhbicsICdtaXNzaW5nIG9yIGludmFsaWQgZW5kaWFuJylcbiAgICBhc3NlcnQob2Zmc2V0ICE9PSB1bmRlZmluZWQgJiYgb2Zmc2V0ICE9PSBudWxsLCAnbWlzc2luZyBvZmZzZXQnKVxuICAgIGFzc2VydChvZmZzZXQgKyAxIDwgYnVmLmxlbmd0aCwgJ1RyeWluZyB0byB3cml0ZSBiZXlvbmQgYnVmZmVyIGxlbmd0aCcpXG4gICAgdmVyaWZzaW50KHZhbHVlLCAweDdmZmYsIC0weDgwMDApXG4gIH1cblxuICB2YXIgbGVuID0gYnVmLmxlbmd0aFxuICBpZiAob2Zmc2V0ID49IGxlbilcbiAgICByZXR1cm5cblxuICBpZiAodmFsdWUgPj0gMClcbiAgICBfd3JpdGVVSW50MTYoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4sIG5vQXNzZXJ0KVxuICBlbHNlXG4gICAgX3dyaXRlVUludDE2KGJ1ZiwgMHhmZmZmICsgdmFsdWUgKyAxLCBvZmZzZXQsIGxpdHRsZUVuZGlhbiwgbm9Bc3NlcnQpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQxNkxFID0gZnVuY3Rpb24gKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIF93cml0ZUludDE2KHRoaXMsIHZhbHVlLCBvZmZzZXQsIHRydWUsIG5vQXNzZXJ0KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50MTZCRSA9IGZ1bmN0aW9uICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICBfd3JpdGVJbnQxNih0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBmYWxzZSwgbm9Bc3NlcnQpXG59XG5cbmZ1bmN0aW9uIF93cml0ZUludDMyIChidWYsIHZhbHVlLCBvZmZzZXQsIGxpdHRsZUVuZGlhbiwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIGFzc2VydCh2YWx1ZSAhPT0gdW5kZWZpbmVkICYmIHZhbHVlICE9PSBudWxsLCAnbWlzc2luZyB2YWx1ZScpXG4gICAgYXNzZXJ0KHR5cGVvZiBsaXR0bGVFbmRpYW4gPT09ICdib29sZWFuJywgJ21pc3Npbmcgb3IgaW52YWxpZCBlbmRpYW4nKVxuICAgIGFzc2VydChvZmZzZXQgIT09IHVuZGVmaW5lZCAmJiBvZmZzZXQgIT09IG51bGwsICdtaXNzaW5nIG9mZnNldCcpXG4gICAgYXNzZXJ0KG9mZnNldCArIDMgPCBidWYubGVuZ3RoLCAnVHJ5aW5nIHRvIHdyaXRlIGJleW9uZCBidWZmZXIgbGVuZ3RoJylcbiAgICB2ZXJpZnNpbnQodmFsdWUsIDB4N2ZmZmZmZmYsIC0weDgwMDAwMDAwKVxuICB9XG5cbiAgdmFyIGxlbiA9IGJ1Zi5sZW5ndGhcbiAgaWYgKG9mZnNldCA+PSBsZW4pXG4gICAgcmV0dXJuXG5cbiAgaWYgKHZhbHVlID49IDApXG4gICAgX3dyaXRlVUludDMyKGJ1ZiwgdmFsdWUsIG9mZnNldCwgbGl0dGxlRW5kaWFuLCBub0Fzc2VydClcbiAgZWxzZVxuICAgIF93cml0ZVVJbnQzMihidWYsIDB4ZmZmZmZmZmYgKyB2YWx1ZSArIDEsIG9mZnNldCwgbGl0dGxlRW5kaWFuLCBub0Fzc2VydClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludDMyTEUgPSBmdW5jdGlvbiAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgX3dyaXRlSW50MzIodGhpcywgdmFsdWUsIG9mZnNldCwgdHJ1ZSwgbm9Bc3NlcnQpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQzMkJFID0gZnVuY3Rpb24gKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIF93cml0ZUludDMyKHRoaXMsIHZhbHVlLCBvZmZzZXQsIGZhbHNlLCBub0Fzc2VydClcbn1cblxuZnVuY3Rpb24gX3dyaXRlRmxvYXQgKGJ1ZiwgdmFsdWUsIG9mZnNldCwgbGl0dGxlRW5kaWFuLCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgYXNzZXJ0KHZhbHVlICE9PSB1bmRlZmluZWQgJiYgdmFsdWUgIT09IG51bGwsICdtaXNzaW5nIHZhbHVlJylcbiAgICBhc3NlcnQodHlwZW9mIGxpdHRsZUVuZGlhbiA9PT0gJ2Jvb2xlYW4nLCAnbWlzc2luZyBvciBpbnZhbGlkIGVuZGlhbicpXG4gICAgYXNzZXJ0KG9mZnNldCAhPT0gdW5kZWZpbmVkICYmIG9mZnNldCAhPT0gbnVsbCwgJ21pc3Npbmcgb2Zmc2V0JylcbiAgICBhc3NlcnQob2Zmc2V0ICsgMyA8IGJ1Zi5sZW5ndGgsICdUcnlpbmcgdG8gd3JpdGUgYmV5b25kIGJ1ZmZlciBsZW5ndGgnKVxuICAgIHZlcmlmSUVFRTc1NCh2YWx1ZSwgMy40MDI4MjM0NjYzODUyODg2ZSszOCwgLTMuNDAyODIzNDY2Mzg1Mjg4NmUrMzgpXG4gIH1cblxuICB2YXIgbGVuID0gYnVmLmxlbmd0aFxuICBpZiAob2Zmc2V0ID49IGxlbilcbiAgICByZXR1cm5cblxuICBpZWVlNzU0LndyaXRlKGJ1ZiwgdmFsdWUsIG9mZnNldCwgbGl0dGxlRW5kaWFuLCAyMywgNClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUZsb2F0TEUgPSBmdW5jdGlvbiAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgX3dyaXRlRmxvYXQodGhpcywgdmFsdWUsIG9mZnNldCwgdHJ1ZSwgbm9Bc3NlcnQpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVGbG9hdEJFID0gZnVuY3Rpb24gKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIF93cml0ZUZsb2F0KHRoaXMsIHZhbHVlLCBvZmZzZXQsIGZhbHNlLCBub0Fzc2VydClcbn1cblxuZnVuY3Rpb24gX3dyaXRlRG91YmxlIChidWYsIHZhbHVlLCBvZmZzZXQsIGxpdHRsZUVuZGlhbiwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIGFzc2VydCh2YWx1ZSAhPT0gdW5kZWZpbmVkICYmIHZhbHVlICE9PSBudWxsLCAnbWlzc2luZyB2YWx1ZScpXG4gICAgYXNzZXJ0KHR5cGVvZiBsaXR0bGVFbmRpYW4gPT09ICdib29sZWFuJywgJ21pc3Npbmcgb3IgaW52YWxpZCBlbmRpYW4nKVxuICAgIGFzc2VydChvZmZzZXQgIT09IHVuZGVmaW5lZCAmJiBvZmZzZXQgIT09IG51bGwsICdtaXNzaW5nIG9mZnNldCcpXG4gICAgYXNzZXJ0KG9mZnNldCArIDcgPCBidWYubGVuZ3RoLFxuICAgICAgICAnVHJ5aW5nIHRvIHdyaXRlIGJleW9uZCBidWZmZXIgbGVuZ3RoJylcbiAgICB2ZXJpZklFRUU3NTQodmFsdWUsIDEuNzk3NjkzMTM0ODYyMzE1N0UrMzA4LCAtMS43OTc2OTMxMzQ4NjIzMTU3RSszMDgpXG4gIH1cblxuICB2YXIgbGVuID0gYnVmLmxlbmd0aFxuICBpZiAob2Zmc2V0ID49IGxlbilcbiAgICByZXR1cm5cblxuICBpZWVlNzU0LndyaXRlKGJ1ZiwgdmFsdWUsIG9mZnNldCwgbGl0dGxlRW5kaWFuLCA1MiwgOClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZURvdWJsZUxFID0gZnVuY3Rpb24gKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIF93cml0ZURvdWJsZSh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCB0cnVlLCBub0Fzc2VydClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZURvdWJsZUJFID0gZnVuY3Rpb24gKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIF93cml0ZURvdWJsZSh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBmYWxzZSwgbm9Bc3NlcnQpXG59XG5cbi8vIGZpbGwodmFsdWUsIHN0YXJ0PTAsIGVuZD1idWZmZXIubGVuZ3RoKVxuQnVmZmVyLnByb3RvdHlwZS5maWxsID0gZnVuY3Rpb24gKHZhbHVlLCBzdGFydCwgZW5kKSB7XG4gIGlmICghdmFsdWUpIHZhbHVlID0gMFxuICBpZiAoIXN0YXJ0KSBzdGFydCA9IDBcbiAgaWYgKCFlbmQpIGVuZCA9IHRoaXMubGVuZ3RoXG5cbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpIHtcbiAgICB2YWx1ZSA9IHZhbHVlLmNoYXJDb2RlQXQoMClcbiAgfVxuXG4gIGFzc2VydCh0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInICYmICFpc05hTih2YWx1ZSksICd2YWx1ZSBpcyBub3QgYSBudW1iZXInKVxuICBhc3NlcnQoZW5kID49IHN0YXJ0LCAnZW5kIDwgc3RhcnQnKVxuXG4gIC8vIEZpbGwgMCBieXRlczsgd2UncmUgZG9uZVxuICBpZiAoZW5kID09PSBzdGFydCkgcmV0dXJuXG4gIGlmICh0aGlzLmxlbmd0aCA9PT0gMCkgcmV0dXJuXG5cbiAgYXNzZXJ0KHN0YXJ0ID49IDAgJiYgc3RhcnQgPCB0aGlzLmxlbmd0aCwgJ3N0YXJ0IG91dCBvZiBib3VuZHMnKVxuICBhc3NlcnQoZW5kID49IDAgJiYgZW5kIDw9IHRoaXMubGVuZ3RoLCAnZW5kIG91dCBvZiBib3VuZHMnKVxuXG4gIGZvciAodmFyIGkgPSBzdGFydDsgaSA8IGVuZDsgaSsrKSB7XG4gICAgdGhpc1tpXSA9IHZhbHVlXG4gIH1cbn1cblxuQnVmZmVyLnByb3RvdHlwZS5pbnNwZWN0ID0gZnVuY3Rpb24gKCkge1xuICB2YXIgb3V0ID0gW11cbiAgdmFyIGxlbiA9IHRoaXMubGVuZ3RoXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICBvdXRbaV0gPSB0b0hleCh0aGlzW2ldKVxuICAgIGlmIChpID09PSBleHBvcnRzLklOU1BFQ1RfTUFYX0JZVEVTKSB7XG4gICAgICBvdXRbaSArIDFdID0gJy4uLidcbiAgICAgIGJyZWFrXG4gICAgfVxuICB9XG4gIHJldHVybiAnPEJ1ZmZlciAnICsgb3V0LmpvaW4oJyAnKSArICc+J1xufVxuXG4vKipcbiAqIENyZWF0ZXMgYSBuZXcgYEFycmF5QnVmZmVyYCB3aXRoIHRoZSAqY29waWVkKiBtZW1vcnkgb2YgdGhlIGJ1ZmZlciBpbnN0YW5jZS5cbiAqIEFkZGVkIGluIE5vZGUgMC4xMi4gT25seSBhdmFpbGFibGUgaW4gYnJvd3NlcnMgdGhhdCBzdXBwb3J0IEFycmF5QnVmZmVyLlxuICovXG5CdWZmZXIucHJvdG90eXBlLnRvQXJyYXlCdWZmZXIgPSBmdW5jdGlvbiAoKSB7XG4gIGlmICh0eXBlb2YgVWludDhBcnJheSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICBpZiAoQnVmZmVyLl91c2VUeXBlZEFycmF5cykge1xuICAgICAgcmV0dXJuIChuZXcgQnVmZmVyKHRoaXMpKS5idWZmZXJcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIGJ1ZiA9IG5ldyBVaW50OEFycmF5KHRoaXMubGVuZ3RoKVxuICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IGJ1Zi5sZW5ndGg7IGkgPCBsZW47IGkgKz0gMSlcbiAgICAgICAgYnVmW2ldID0gdGhpc1tpXVxuICAgICAgcmV0dXJuIGJ1Zi5idWZmZXJcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdCdWZmZXIudG9BcnJheUJ1ZmZlciBub3Qgc3VwcG9ydGVkIGluIHRoaXMgYnJvd3NlcicpXG4gIH1cbn1cblxuLy8gSEVMUEVSIEZVTkNUSU9OU1xuLy8gPT09PT09PT09PT09PT09PVxuXG5mdW5jdGlvbiBzdHJpbmd0cmltIChzdHIpIHtcbiAgaWYgKHN0ci50cmltKSByZXR1cm4gc3RyLnRyaW0oKVxuICByZXR1cm4gc3RyLnJlcGxhY2UoL15cXHMrfFxccyskL2csICcnKVxufVxuXG52YXIgQlAgPSBCdWZmZXIucHJvdG90eXBlXG5cbi8qKlxuICogQXVnbWVudCBhIFVpbnQ4QXJyYXkgKmluc3RhbmNlKiAobm90IHRoZSBVaW50OEFycmF5IGNsYXNzISkgd2l0aCBCdWZmZXIgbWV0aG9kc1xuICovXG5CdWZmZXIuX2F1Z21lbnQgPSBmdW5jdGlvbiAoYXJyKSB7XG4gIGFyci5faXNCdWZmZXIgPSB0cnVlXG5cbiAgLy8gc2F2ZSByZWZlcmVuY2UgdG8gb3JpZ2luYWwgVWludDhBcnJheSBnZXQvc2V0IG1ldGhvZHMgYmVmb3JlIG92ZXJ3cml0aW5nXG4gIGFyci5fZ2V0ID0gYXJyLmdldFxuICBhcnIuX3NldCA9IGFyci5zZXRcblxuICAvLyBkZXByZWNhdGVkLCB3aWxsIGJlIHJlbW92ZWQgaW4gbm9kZSAwLjEzK1xuICBhcnIuZ2V0ID0gQlAuZ2V0XG4gIGFyci5zZXQgPSBCUC5zZXRcblxuICBhcnIud3JpdGUgPSBCUC53cml0ZVxuICBhcnIudG9TdHJpbmcgPSBCUC50b1N0cmluZ1xuICBhcnIudG9Mb2NhbGVTdHJpbmcgPSBCUC50b1N0cmluZ1xuICBhcnIudG9KU09OID0gQlAudG9KU09OXG4gIGFyci5jb3B5ID0gQlAuY29weVxuICBhcnIuc2xpY2UgPSBCUC5zbGljZVxuICBhcnIucmVhZFVJbnQ4ID0gQlAucmVhZFVJbnQ4XG4gIGFyci5yZWFkVUludDE2TEUgPSBCUC5yZWFkVUludDE2TEVcbiAgYXJyLnJlYWRVSW50MTZCRSA9IEJQLnJlYWRVSW50MTZCRVxuICBhcnIucmVhZFVJbnQzMkxFID0gQlAucmVhZFVJbnQzMkxFXG4gIGFyci5yZWFkVUludDMyQkUgPSBCUC5yZWFkVUludDMyQkVcbiAgYXJyLnJlYWRJbnQ4ID0gQlAucmVhZEludDhcbiAgYXJyLnJlYWRJbnQxNkxFID0gQlAucmVhZEludDE2TEVcbiAgYXJyLnJlYWRJbnQxNkJFID0gQlAucmVhZEludDE2QkVcbiAgYXJyLnJlYWRJbnQzMkxFID0gQlAucmVhZEludDMyTEVcbiAgYXJyLnJlYWRJbnQzMkJFID0gQlAucmVhZEludDMyQkVcbiAgYXJyLnJlYWRGbG9hdExFID0gQlAucmVhZEZsb2F0TEVcbiAgYXJyLnJlYWRGbG9hdEJFID0gQlAucmVhZEZsb2F0QkVcbiAgYXJyLnJlYWREb3VibGVMRSA9IEJQLnJlYWREb3VibGVMRVxuICBhcnIucmVhZERvdWJsZUJFID0gQlAucmVhZERvdWJsZUJFXG4gIGFyci53cml0ZVVJbnQ4ID0gQlAud3JpdGVVSW50OFxuICBhcnIud3JpdGVVSW50MTZMRSA9IEJQLndyaXRlVUludDE2TEVcbiAgYXJyLndyaXRlVUludDE2QkUgPSBCUC53cml0ZVVJbnQxNkJFXG4gIGFyci53cml0ZVVJbnQzMkxFID0gQlAud3JpdGVVSW50MzJMRVxuICBhcnIud3JpdGVVSW50MzJCRSA9IEJQLndyaXRlVUludDMyQkVcbiAgYXJyLndyaXRlSW50OCA9IEJQLndyaXRlSW50OFxuICBhcnIud3JpdGVJbnQxNkxFID0gQlAud3JpdGVJbnQxNkxFXG4gIGFyci53cml0ZUludDE2QkUgPSBCUC53cml0ZUludDE2QkVcbiAgYXJyLndyaXRlSW50MzJMRSA9IEJQLndyaXRlSW50MzJMRVxuICBhcnIud3JpdGVJbnQzMkJFID0gQlAud3JpdGVJbnQzMkJFXG4gIGFyci53cml0ZUZsb2F0TEUgPSBCUC53cml0ZUZsb2F0TEVcbiAgYXJyLndyaXRlRmxvYXRCRSA9IEJQLndyaXRlRmxvYXRCRVxuICBhcnIud3JpdGVEb3VibGVMRSA9IEJQLndyaXRlRG91YmxlTEVcbiAgYXJyLndyaXRlRG91YmxlQkUgPSBCUC53cml0ZURvdWJsZUJFXG4gIGFyci5maWxsID0gQlAuZmlsbFxuICBhcnIuaW5zcGVjdCA9IEJQLmluc3BlY3RcbiAgYXJyLnRvQXJyYXlCdWZmZXIgPSBCUC50b0FycmF5QnVmZmVyXG5cbiAgcmV0dXJuIGFyclxufVxuXG4vLyBzbGljZShzdGFydCwgZW5kKVxuZnVuY3Rpb24gY2xhbXAgKGluZGV4LCBsZW4sIGRlZmF1bHRWYWx1ZSkge1xuICBpZiAodHlwZW9mIGluZGV4ICE9PSAnbnVtYmVyJykgcmV0dXJuIGRlZmF1bHRWYWx1ZVxuICBpbmRleCA9IH5+aW5kZXg7ICAvLyBDb2VyY2UgdG8gaW50ZWdlci5cbiAgaWYgKGluZGV4ID49IGxlbikgcmV0dXJuIGxlblxuICBpZiAoaW5kZXggPj0gMCkgcmV0dXJuIGluZGV4XG4gIGluZGV4ICs9IGxlblxuICBpZiAoaW5kZXggPj0gMCkgcmV0dXJuIGluZGV4XG4gIHJldHVybiAwXG59XG5cbmZ1bmN0aW9uIGNvZXJjZSAobGVuZ3RoKSB7XG4gIC8vIENvZXJjZSBsZW5ndGggdG8gYSBudW1iZXIgKHBvc3NpYmx5IE5hTiksIHJvdW5kIHVwXG4gIC8vIGluIGNhc2UgaXQncyBmcmFjdGlvbmFsIChlLmcuIDEyMy40NTYpIHRoZW4gZG8gYVxuICAvLyBkb3VibGUgbmVnYXRlIHRvIGNvZXJjZSBhIE5hTiB0byAwLiBFYXN5LCByaWdodD9cbiAgbGVuZ3RoID0gfn5NYXRoLmNlaWwoK2xlbmd0aClcbiAgcmV0dXJuIGxlbmd0aCA8IDAgPyAwIDogbGVuZ3RoXG59XG5cbmZ1bmN0aW9uIGlzQXJyYXkgKHN1YmplY3QpIHtcbiAgcmV0dXJuIChBcnJheS5pc0FycmF5IHx8IGZ1bmN0aW9uIChzdWJqZWN0KSB7XG4gICAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChzdWJqZWN0KSA9PT0gJ1tvYmplY3QgQXJyYXldJ1xuICB9KShzdWJqZWN0KVxufVxuXG5mdW5jdGlvbiBpc0FycmF5aXNoIChzdWJqZWN0KSB7XG4gIHJldHVybiBpc0FycmF5KHN1YmplY3QpIHx8IEJ1ZmZlci5pc0J1ZmZlcihzdWJqZWN0KSB8fFxuICAgICAgc3ViamVjdCAmJiB0eXBlb2Ygc3ViamVjdCA9PT0gJ29iamVjdCcgJiZcbiAgICAgIHR5cGVvZiBzdWJqZWN0Lmxlbmd0aCA9PT0gJ251bWJlcidcbn1cblxuZnVuY3Rpb24gdG9IZXggKG4pIHtcbiAgaWYgKG4gPCAxNikgcmV0dXJuICcwJyArIG4udG9TdHJpbmcoMTYpXG4gIHJldHVybiBuLnRvU3RyaW5nKDE2KVxufVxuXG5mdW5jdGlvbiB1dGY4VG9CeXRlcyAoc3RyKSB7XG4gIHZhciBieXRlQXJyYXkgPSBbXVxuICBmb3IgKHZhciBpID0gMDsgaSA8IHN0ci5sZW5ndGg7IGkrKykge1xuICAgIHZhciBiID0gc3RyLmNoYXJDb2RlQXQoaSlcbiAgICBpZiAoYiA8PSAweDdGKVxuICAgICAgYnl0ZUFycmF5LnB1c2goc3RyLmNoYXJDb2RlQXQoaSkpXG4gICAgZWxzZSB7XG4gICAgICB2YXIgc3RhcnQgPSBpXG4gICAgICBpZiAoYiA+PSAweEQ4MDAgJiYgYiA8PSAweERGRkYpIGkrK1xuICAgICAgdmFyIGggPSBlbmNvZGVVUklDb21wb25lbnQoc3RyLnNsaWNlKHN0YXJ0LCBpKzEpKS5zdWJzdHIoMSkuc3BsaXQoJyUnKVxuICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBoLmxlbmd0aDsgaisrKVxuICAgICAgICBieXRlQXJyYXkucHVzaChwYXJzZUludChoW2pdLCAxNikpXG4gICAgfVxuICB9XG4gIHJldHVybiBieXRlQXJyYXlcbn1cblxuZnVuY3Rpb24gYXNjaWlUb0J5dGVzIChzdHIpIHtcbiAgdmFyIGJ5dGVBcnJheSA9IFtdXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgc3RyLmxlbmd0aDsgaSsrKSB7XG4gICAgLy8gTm9kZSdzIGNvZGUgc2VlbXMgdG8gYmUgZG9pbmcgdGhpcyBhbmQgbm90ICYgMHg3Ri4uXG4gICAgYnl0ZUFycmF5LnB1c2goc3RyLmNoYXJDb2RlQXQoaSkgJiAweEZGKVxuICB9XG4gIHJldHVybiBieXRlQXJyYXlcbn1cblxuZnVuY3Rpb24gdXRmMTZsZVRvQnl0ZXMgKHN0cikge1xuICB2YXIgYywgaGksIGxvXG4gIHZhciBieXRlQXJyYXkgPSBbXVxuICBmb3IgKHZhciBpID0gMDsgaSA8IHN0ci5sZW5ndGg7IGkrKykge1xuICAgIGMgPSBzdHIuY2hhckNvZGVBdChpKVxuICAgIGhpID0gYyA+PiA4XG4gICAgbG8gPSBjICUgMjU2XG4gICAgYnl0ZUFycmF5LnB1c2gobG8pXG4gICAgYnl0ZUFycmF5LnB1c2goaGkpXG4gIH1cblxuICByZXR1cm4gYnl0ZUFycmF5XG59XG5cbmZ1bmN0aW9uIGJhc2U2NFRvQnl0ZXMgKHN0cikge1xuICByZXR1cm4gYmFzZTY0LnRvQnl0ZUFycmF5KHN0cilcbn1cblxuZnVuY3Rpb24gYmxpdEJ1ZmZlciAoc3JjLCBkc3QsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIHZhciBwb3NcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgIGlmICgoaSArIG9mZnNldCA+PSBkc3QubGVuZ3RoKSB8fCAoaSA+PSBzcmMubGVuZ3RoKSlcbiAgICAgIGJyZWFrXG4gICAgZHN0W2kgKyBvZmZzZXRdID0gc3JjW2ldXG4gIH1cbiAgcmV0dXJuIGlcbn1cblxuZnVuY3Rpb24gZGVjb2RlVXRmOENoYXIgKHN0cikge1xuICB0cnkge1xuICAgIHJldHVybiBkZWNvZGVVUklDb21wb25lbnQoc3RyKVxuICB9IGNhdGNoIChlcnIpIHtcbiAgICByZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZSgweEZGRkQpIC8vIFVURiA4IGludmFsaWQgY2hhclxuICB9XG59XG5cbi8qXG4gKiBXZSBoYXZlIHRvIG1ha2Ugc3VyZSB0aGF0IHRoZSB2YWx1ZSBpcyBhIHZhbGlkIGludGVnZXIuIFRoaXMgbWVhbnMgdGhhdCBpdFxuICogaXMgbm9uLW5lZ2F0aXZlLiBJdCBoYXMgbm8gZnJhY3Rpb25hbCBjb21wb25lbnQgYW5kIHRoYXQgaXQgZG9lcyBub3RcbiAqIGV4Y2VlZCB0aGUgbWF4aW11bSBhbGxvd2VkIHZhbHVlLlxuICovXG5mdW5jdGlvbiB2ZXJpZnVpbnQgKHZhbHVlLCBtYXgpIHtcbiAgYXNzZXJ0KHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicsICdjYW5ub3Qgd3JpdGUgYSBub24tbnVtYmVyIGFzIGEgbnVtYmVyJylcbiAgYXNzZXJ0KHZhbHVlID49IDAsICdzcGVjaWZpZWQgYSBuZWdhdGl2ZSB2YWx1ZSBmb3Igd3JpdGluZyBhbiB1bnNpZ25lZCB2YWx1ZScpXG4gIGFzc2VydCh2YWx1ZSA8PSBtYXgsICd2YWx1ZSBpcyBsYXJnZXIgdGhhbiBtYXhpbXVtIHZhbHVlIGZvciB0eXBlJylcbiAgYXNzZXJ0KE1hdGguZmxvb3IodmFsdWUpID09PSB2YWx1ZSwgJ3ZhbHVlIGhhcyBhIGZyYWN0aW9uYWwgY29tcG9uZW50Jylcbn1cblxuZnVuY3Rpb24gdmVyaWZzaW50ICh2YWx1ZSwgbWF4LCBtaW4pIHtcbiAgYXNzZXJ0KHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicsICdjYW5ub3Qgd3JpdGUgYSBub24tbnVtYmVyIGFzIGEgbnVtYmVyJylcbiAgYXNzZXJ0KHZhbHVlIDw9IG1heCwgJ3ZhbHVlIGxhcmdlciB0aGFuIG1heGltdW0gYWxsb3dlZCB2YWx1ZScpXG4gIGFzc2VydCh2YWx1ZSA+PSBtaW4sICd2YWx1ZSBzbWFsbGVyIHRoYW4gbWluaW11bSBhbGxvd2VkIHZhbHVlJylcbiAgYXNzZXJ0KE1hdGguZmxvb3IodmFsdWUpID09PSB2YWx1ZSwgJ3ZhbHVlIGhhcyBhIGZyYWN0aW9uYWwgY29tcG9uZW50Jylcbn1cblxuZnVuY3Rpb24gdmVyaWZJRUVFNzU0ICh2YWx1ZSwgbWF4LCBtaW4pIHtcbiAgYXNzZXJ0KHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicsICdjYW5ub3Qgd3JpdGUgYSBub24tbnVtYmVyIGFzIGEgbnVtYmVyJylcbiAgYXNzZXJ0KHZhbHVlIDw9IG1heCwgJ3ZhbHVlIGxhcmdlciB0aGFuIG1heGltdW0gYWxsb3dlZCB2YWx1ZScpXG4gIGFzc2VydCh2YWx1ZSA+PSBtaW4sICd2YWx1ZSBzbWFsbGVyIHRoYW4gbWluaW11bSBhbGxvd2VkIHZhbHVlJylcbn1cblxuZnVuY3Rpb24gYXNzZXJ0ICh0ZXN0LCBtZXNzYWdlKSB7XG4gIGlmICghdGVzdCkgdGhyb3cgbmV3IEVycm9yKG1lc3NhZ2UgfHwgJ0ZhaWxlZCBhc3NlcnRpb24nKVxufVxuIiwidmFyIEJ1ZmZlciA9IHJlcXVpcmUoJ2J1ZmZlcicpLkJ1ZmZlcjtcbnZhciBpbnRTaXplID0gNDtcbnZhciB6ZXJvQnVmZmVyID0gbmV3IEJ1ZmZlcihpbnRTaXplKTsgemVyb0J1ZmZlci5maWxsKDApO1xudmFyIGNocnN6ID0gODtcblxuZnVuY3Rpb24gdG9BcnJheShidWYsIGJpZ0VuZGlhbikge1xuICBpZiAoKGJ1Zi5sZW5ndGggJSBpbnRTaXplKSAhPT0gMCkge1xuICAgIHZhciBsZW4gPSBidWYubGVuZ3RoICsgKGludFNpemUgLSAoYnVmLmxlbmd0aCAlIGludFNpemUpKTtcbiAgICBidWYgPSBCdWZmZXIuY29uY2F0KFtidWYsIHplcm9CdWZmZXJdLCBsZW4pO1xuICB9XG5cbiAgdmFyIGFyciA9IFtdO1xuICB2YXIgZm4gPSBiaWdFbmRpYW4gPyBidWYucmVhZEludDMyQkUgOiBidWYucmVhZEludDMyTEU7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgYnVmLmxlbmd0aDsgaSArPSBpbnRTaXplKSB7XG4gICAgYXJyLnB1c2goZm4uY2FsbChidWYsIGkpKTtcbiAgfVxuICByZXR1cm4gYXJyO1xufVxuXG5mdW5jdGlvbiB0b0J1ZmZlcihhcnIsIHNpemUsIGJpZ0VuZGlhbikge1xuICB2YXIgYnVmID0gbmV3IEJ1ZmZlcihzaXplKTtcbiAgdmFyIGZuID0gYmlnRW5kaWFuID8gYnVmLndyaXRlSW50MzJCRSA6IGJ1Zi53cml0ZUludDMyTEU7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgYXJyLmxlbmd0aDsgaSsrKSB7XG4gICAgZm4uY2FsbChidWYsIGFycltpXSwgaSAqIDQsIHRydWUpO1xuICB9XG4gIHJldHVybiBidWY7XG59XG5cbmZ1bmN0aW9uIGhhc2goYnVmLCBmbiwgaGFzaFNpemUsIGJpZ0VuZGlhbikge1xuICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcihidWYpKSBidWYgPSBuZXcgQnVmZmVyKGJ1Zik7XG4gIHZhciBhcnIgPSBmbih0b0FycmF5KGJ1ZiwgYmlnRW5kaWFuKSwgYnVmLmxlbmd0aCAqIGNocnN6KTtcbiAgcmV0dXJuIHRvQnVmZmVyKGFyciwgaGFzaFNpemUsIGJpZ0VuZGlhbik7XG59XG5cbm1vZHVsZS5leHBvcnRzID0geyBoYXNoOiBoYXNoIH07XG4iLCJ2YXIgQnVmZmVyID0gcmVxdWlyZSgnYnVmZmVyJykuQnVmZmVyXG52YXIgc2hhID0gcmVxdWlyZSgnLi9zaGEnKVxudmFyIHNoYTI1NiA9IHJlcXVpcmUoJy4vc2hhMjU2JylcbnZhciBybmcgPSByZXF1aXJlKCcuL3JuZycpXG52YXIgbWQ1ID0gcmVxdWlyZSgnLi9tZDUnKVxuXG52YXIgYWxnb3JpdGhtcyA9IHtcbiAgc2hhMTogc2hhLFxuICBzaGEyNTY6IHNoYTI1NixcbiAgbWQ1OiBtZDVcbn1cblxudmFyIGJsb2Nrc2l6ZSA9IDY0XG52YXIgemVyb0J1ZmZlciA9IG5ldyBCdWZmZXIoYmxvY2tzaXplKTsgemVyb0J1ZmZlci5maWxsKDApXG5mdW5jdGlvbiBobWFjKGZuLCBrZXksIGRhdGEpIHtcbiAgaWYoIUJ1ZmZlci5pc0J1ZmZlcihrZXkpKSBrZXkgPSBuZXcgQnVmZmVyKGtleSlcbiAgaWYoIUJ1ZmZlci5pc0J1ZmZlcihkYXRhKSkgZGF0YSA9IG5ldyBCdWZmZXIoZGF0YSlcblxuICBpZihrZXkubGVuZ3RoID4gYmxvY2tzaXplKSB7XG4gICAga2V5ID0gZm4oa2V5KVxuICB9IGVsc2UgaWYoa2V5Lmxlbmd0aCA8IGJsb2Nrc2l6ZSkge1xuICAgIGtleSA9IEJ1ZmZlci5jb25jYXQoW2tleSwgemVyb0J1ZmZlcl0sIGJsb2Nrc2l6ZSlcbiAgfVxuXG4gIHZhciBpcGFkID0gbmV3IEJ1ZmZlcihibG9ja3NpemUpLCBvcGFkID0gbmV3IEJ1ZmZlcihibG9ja3NpemUpXG4gIGZvcih2YXIgaSA9IDA7IGkgPCBibG9ja3NpemU7IGkrKykge1xuICAgIGlwYWRbaV0gPSBrZXlbaV0gXiAweDM2XG4gICAgb3BhZFtpXSA9IGtleVtpXSBeIDB4NUNcbiAgfVxuXG4gIHZhciBoYXNoID0gZm4oQnVmZmVyLmNvbmNhdChbaXBhZCwgZGF0YV0pKVxuICByZXR1cm4gZm4oQnVmZmVyLmNvbmNhdChbb3BhZCwgaGFzaF0pKVxufVxuXG5mdW5jdGlvbiBoYXNoKGFsZywga2V5KSB7XG4gIGFsZyA9IGFsZyB8fCAnc2hhMSdcbiAgdmFyIGZuID0gYWxnb3JpdGhtc1thbGddXG4gIHZhciBidWZzID0gW11cbiAgdmFyIGxlbmd0aCA9IDBcbiAgaWYoIWZuKSBlcnJvcignYWxnb3JpdGhtOicsIGFsZywgJ2lzIG5vdCB5ZXQgc3VwcG9ydGVkJylcbiAgcmV0dXJuIHtcbiAgICB1cGRhdGU6IGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgICBpZighQnVmZmVyLmlzQnVmZmVyKGRhdGEpKSBkYXRhID0gbmV3IEJ1ZmZlcihkYXRhKVxuICAgICAgICBcbiAgICAgIGJ1ZnMucHVzaChkYXRhKVxuICAgICAgbGVuZ3RoICs9IGRhdGEubGVuZ3RoXG4gICAgICByZXR1cm4gdGhpc1xuICAgIH0sXG4gICAgZGlnZXN0OiBmdW5jdGlvbiAoZW5jKSB7XG4gICAgICB2YXIgYnVmID0gQnVmZmVyLmNvbmNhdChidWZzKVxuICAgICAgdmFyIHIgPSBrZXkgPyBobWFjKGZuLCBrZXksIGJ1ZikgOiBmbihidWYpXG4gICAgICBidWZzID0gbnVsbFxuICAgICAgcmV0dXJuIGVuYyA/IHIudG9TdHJpbmcoZW5jKSA6IHJcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gZXJyb3IgKCkge1xuICB2YXIgbSA9IFtdLnNsaWNlLmNhbGwoYXJndW1lbnRzKS5qb2luKCcgJylcbiAgdGhyb3cgbmV3IEVycm9yKFtcbiAgICBtLFxuICAgICd3ZSBhY2NlcHQgcHVsbCByZXF1ZXN0cycsXG4gICAgJ2h0dHA6Ly9naXRodWIuY29tL2RvbWluaWN0YXJyL2NyeXB0by1icm93c2VyaWZ5J1xuICAgIF0uam9pbignXFxuJykpXG59XG5cbmV4cG9ydHMuY3JlYXRlSGFzaCA9IGZ1bmN0aW9uIChhbGcpIHsgcmV0dXJuIGhhc2goYWxnKSB9XG5leHBvcnRzLmNyZWF0ZUhtYWMgPSBmdW5jdGlvbiAoYWxnLCBrZXkpIHsgcmV0dXJuIGhhc2goYWxnLCBrZXkpIH1cbmV4cG9ydHMucmFuZG9tQnl0ZXMgPSBmdW5jdGlvbihzaXplLCBjYWxsYmFjaykge1xuICBpZiAoY2FsbGJhY2sgJiYgY2FsbGJhY2suY2FsbCkge1xuICAgIHRyeSB7XG4gICAgICBjYWxsYmFjay5jYWxsKHRoaXMsIHVuZGVmaW5lZCwgbmV3IEJ1ZmZlcihybmcoc2l6ZSkpKVxuICAgIH0gY2F0Y2ggKGVycikgeyBjYWxsYmFjayhlcnIpIH1cbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gbmV3IEJ1ZmZlcihybmcoc2l6ZSkpXG4gIH1cbn1cblxuZnVuY3Rpb24gZWFjaChhLCBmKSB7XG4gIGZvcih2YXIgaSBpbiBhKVxuICAgIGYoYVtpXSwgaSlcbn1cblxuLy8gdGhlIGxlYXN0IEkgY2FuIGRvIGlzIG1ha2UgZXJyb3IgbWVzc2FnZXMgZm9yIHRoZSByZXN0IG9mIHRoZSBub2RlLmpzL2NyeXB0byBhcGkuXG5lYWNoKFsnY3JlYXRlQ3JlZGVudGlhbHMnXG4sICdjcmVhdGVDaXBoZXInXG4sICdjcmVhdGVDaXBoZXJpdidcbiwgJ2NyZWF0ZURlY2lwaGVyJ1xuLCAnY3JlYXRlRGVjaXBoZXJpdidcbiwgJ2NyZWF0ZVNpZ24nXG4sICdjcmVhdGVWZXJpZnknXG4sICdjcmVhdGVEaWZmaWVIZWxsbWFuJ1xuLCAncGJrZGYyJ10sIGZ1bmN0aW9uIChuYW1lKSB7XG4gIGV4cG9ydHNbbmFtZV0gPSBmdW5jdGlvbiAoKSB7XG4gICAgZXJyb3IoJ3NvcnJ5LCcsIG5hbWUsICdpcyBub3QgaW1wbGVtZW50ZWQgeWV0JylcbiAgfVxufSlcbiIsIi8qXHJcbiAqIEEgSmF2YVNjcmlwdCBpbXBsZW1lbnRhdGlvbiBvZiB0aGUgUlNBIERhdGEgU2VjdXJpdHksIEluYy4gTUQ1IE1lc3NhZ2VcclxuICogRGlnZXN0IEFsZ29yaXRobSwgYXMgZGVmaW5lZCBpbiBSRkMgMTMyMS5cclxuICogVmVyc2lvbiAyLjEgQ29weXJpZ2h0IChDKSBQYXVsIEpvaG5zdG9uIDE5OTkgLSAyMDAyLlxyXG4gKiBPdGhlciBjb250cmlidXRvcnM6IEdyZWcgSG9sdCwgQW5kcmV3IEtlcGVydCwgWWRuYXIsIExvc3RpbmV0XHJcbiAqIERpc3RyaWJ1dGVkIHVuZGVyIHRoZSBCU0QgTGljZW5zZVxyXG4gKiBTZWUgaHR0cDovL3BhamhvbWUub3JnLnVrL2NyeXB0L21kNSBmb3IgbW9yZSBpbmZvLlxyXG4gKi9cclxuXHJcbnZhciBoZWxwZXJzID0gcmVxdWlyZSgnLi9oZWxwZXJzJyk7XHJcblxyXG4vKlxyXG4gKiBQZXJmb3JtIGEgc2ltcGxlIHNlbGYtdGVzdCB0byBzZWUgaWYgdGhlIFZNIGlzIHdvcmtpbmdcclxuICovXHJcbmZ1bmN0aW9uIG1kNV92bV90ZXN0KClcclxue1xyXG4gIHJldHVybiBoZXhfbWQ1KFwiYWJjXCIpID09IFwiOTAwMTUwOTgzY2QyNGZiMGQ2OTYzZjdkMjhlMTdmNzJcIjtcclxufVxyXG5cclxuLypcclxuICogQ2FsY3VsYXRlIHRoZSBNRDUgb2YgYW4gYXJyYXkgb2YgbGl0dGxlLWVuZGlhbiB3b3JkcywgYW5kIGEgYml0IGxlbmd0aFxyXG4gKi9cclxuZnVuY3Rpb24gY29yZV9tZDUoeCwgbGVuKVxyXG57XHJcbiAgLyogYXBwZW5kIHBhZGRpbmcgKi9cclxuICB4W2xlbiA+PiA1XSB8PSAweDgwIDw8ICgobGVuKSAlIDMyKTtcclxuICB4WygoKGxlbiArIDY0KSA+Pj4gOSkgPDwgNCkgKyAxNF0gPSBsZW47XHJcblxyXG4gIHZhciBhID0gIDE3MzI1ODQxOTM7XHJcbiAgdmFyIGIgPSAtMjcxNzMzODc5O1xyXG4gIHZhciBjID0gLTE3MzI1ODQxOTQ7XHJcbiAgdmFyIGQgPSAgMjcxNzMzODc4O1xyXG5cclxuICBmb3IodmFyIGkgPSAwOyBpIDwgeC5sZW5ndGg7IGkgKz0gMTYpXHJcbiAge1xyXG4gICAgdmFyIG9sZGEgPSBhO1xyXG4gICAgdmFyIG9sZGIgPSBiO1xyXG4gICAgdmFyIG9sZGMgPSBjO1xyXG4gICAgdmFyIG9sZGQgPSBkO1xyXG5cclxuICAgIGEgPSBtZDVfZmYoYSwgYiwgYywgZCwgeFtpKyAwXSwgNyAsIC02ODA4NzY5MzYpO1xyXG4gICAgZCA9IG1kNV9mZihkLCBhLCBiLCBjLCB4W2krIDFdLCAxMiwgLTM4OTU2NDU4Nik7XHJcbiAgICBjID0gbWQ1X2ZmKGMsIGQsIGEsIGIsIHhbaSsgMl0sIDE3LCAgNjA2MTA1ODE5KTtcclxuICAgIGIgPSBtZDVfZmYoYiwgYywgZCwgYSwgeFtpKyAzXSwgMjIsIC0xMDQ0NTI1MzMwKTtcclxuICAgIGEgPSBtZDVfZmYoYSwgYiwgYywgZCwgeFtpKyA0XSwgNyAsIC0xNzY0MTg4OTcpO1xyXG4gICAgZCA9IG1kNV9mZihkLCBhLCBiLCBjLCB4W2krIDVdLCAxMiwgIDEyMDAwODA0MjYpO1xyXG4gICAgYyA9IG1kNV9mZihjLCBkLCBhLCBiLCB4W2krIDZdLCAxNywgLTE0NzMyMzEzNDEpO1xyXG4gICAgYiA9IG1kNV9mZihiLCBjLCBkLCBhLCB4W2krIDddLCAyMiwgLTQ1NzA1OTgzKTtcclxuICAgIGEgPSBtZDVfZmYoYSwgYiwgYywgZCwgeFtpKyA4XSwgNyAsICAxNzcwMDM1NDE2KTtcclxuICAgIGQgPSBtZDVfZmYoZCwgYSwgYiwgYywgeFtpKyA5XSwgMTIsIC0xOTU4NDE0NDE3KTtcclxuICAgIGMgPSBtZDVfZmYoYywgZCwgYSwgYiwgeFtpKzEwXSwgMTcsIC00MjA2Myk7XHJcbiAgICBiID0gbWQ1X2ZmKGIsIGMsIGQsIGEsIHhbaSsxMV0sIDIyLCAtMTk5MDQwNDE2Mik7XHJcbiAgICBhID0gbWQ1X2ZmKGEsIGIsIGMsIGQsIHhbaSsxMl0sIDcgLCAgMTgwNDYwMzY4Mik7XHJcbiAgICBkID0gbWQ1X2ZmKGQsIGEsIGIsIGMsIHhbaSsxM10sIDEyLCAtNDAzNDExMDEpO1xyXG4gICAgYyA9IG1kNV9mZihjLCBkLCBhLCBiLCB4W2krMTRdLCAxNywgLTE1MDIwMDIyOTApO1xyXG4gICAgYiA9IG1kNV9mZihiLCBjLCBkLCBhLCB4W2krMTVdLCAyMiwgIDEyMzY1MzUzMjkpO1xyXG5cclxuICAgIGEgPSBtZDVfZ2coYSwgYiwgYywgZCwgeFtpKyAxXSwgNSAsIC0xNjU3OTY1MTApO1xyXG4gICAgZCA9IG1kNV9nZyhkLCBhLCBiLCBjLCB4W2krIDZdLCA5ICwgLTEwNjk1MDE2MzIpO1xyXG4gICAgYyA9IG1kNV9nZyhjLCBkLCBhLCBiLCB4W2krMTFdLCAxNCwgIDY0MzcxNzcxMyk7XHJcbiAgICBiID0gbWQ1X2dnKGIsIGMsIGQsIGEsIHhbaSsgMF0sIDIwLCAtMzczODk3MzAyKTtcclxuICAgIGEgPSBtZDVfZ2coYSwgYiwgYywgZCwgeFtpKyA1XSwgNSAsIC03MDE1NTg2OTEpO1xyXG4gICAgZCA9IG1kNV9nZyhkLCBhLCBiLCBjLCB4W2krMTBdLCA5ICwgIDM4MDE2MDgzKTtcclxuICAgIGMgPSBtZDVfZ2coYywgZCwgYSwgYiwgeFtpKzE1XSwgMTQsIC02NjA0NzgzMzUpO1xyXG4gICAgYiA9IG1kNV9nZyhiLCBjLCBkLCBhLCB4W2krIDRdLCAyMCwgLTQwNTUzNzg0OCk7XHJcbiAgICBhID0gbWQ1X2dnKGEsIGIsIGMsIGQsIHhbaSsgOV0sIDUgLCAgNTY4NDQ2NDM4KTtcclxuICAgIGQgPSBtZDVfZ2coZCwgYSwgYiwgYywgeFtpKzE0XSwgOSAsIC0xMDE5ODAzNjkwKTtcclxuICAgIGMgPSBtZDVfZ2coYywgZCwgYSwgYiwgeFtpKyAzXSwgMTQsIC0xODczNjM5NjEpO1xyXG4gICAgYiA9IG1kNV9nZyhiLCBjLCBkLCBhLCB4W2krIDhdLCAyMCwgIDExNjM1MzE1MDEpO1xyXG4gICAgYSA9IG1kNV9nZyhhLCBiLCBjLCBkLCB4W2krMTNdLCA1ICwgLTE0NDQ2ODE0NjcpO1xyXG4gICAgZCA9IG1kNV9nZyhkLCBhLCBiLCBjLCB4W2krIDJdLCA5ICwgLTUxNDAzNzg0KTtcclxuICAgIGMgPSBtZDVfZ2coYywgZCwgYSwgYiwgeFtpKyA3XSwgMTQsICAxNzM1MzI4NDczKTtcclxuICAgIGIgPSBtZDVfZ2coYiwgYywgZCwgYSwgeFtpKzEyXSwgMjAsIC0xOTI2NjA3NzM0KTtcclxuXHJcbiAgICBhID0gbWQ1X2hoKGEsIGIsIGMsIGQsIHhbaSsgNV0sIDQgLCAtMzc4NTU4KTtcclxuICAgIGQgPSBtZDVfaGgoZCwgYSwgYiwgYywgeFtpKyA4XSwgMTEsIC0yMDIyNTc0NDYzKTtcclxuICAgIGMgPSBtZDVfaGgoYywgZCwgYSwgYiwgeFtpKzExXSwgMTYsICAxODM5MDMwNTYyKTtcclxuICAgIGIgPSBtZDVfaGgoYiwgYywgZCwgYSwgeFtpKzE0XSwgMjMsIC0zNTMwOTU1Nik7XHJcbiAgICBhID0gbWQ1X2hoKGEsIGIsIGMsIGQsIHhbaSsgMV0sIDQgLCAtMTUzMDk5MjA2MCk7XHJcbiAgICBkID0gbWQ1X2hoKGQsIGEsIGIsIGMsIHhbaSsgNF0sIDExLCAgMTI3Mjg5MzM1Myk7XHJcbiAgICBjID0gbWQ1X2hoKGMsIGQsIGEsIGIsIHhbaSsgN10sIDE2LCAtMTU1NDk3NjMyKTtcclxuICAgIGIgPSBtZDVfaGgoYiwgYywgZCwgYSwgeFtpKzEwXSwgMjMsIC0xMDk0NzMwNjQwKTtcclxuICAgIGEgPSBtZDVfaGgoYSwgYiwgYywgZCwgeFtpKzEzXSwgNCAsICA2ODEyNzkxNzQpO1xyXG4gICAgZCA9IG1kNV9oaChkLCBhLCBiLCBjLCB4W2krIDBdLCAxMSwgLTM1ODUzNzIyMik7XHJcbiAgICBjID0gbWQ1X2hoKGMsIGQsIGEsIGIsIHhbaSsgM10sIDE2LCAtNzIyNTIxOTc5KTtcclxuICAgIGIgPSBtZDVfaGgoYiwgYywgZCwgYSwgeFtpKyA2XSwgMjMsICA3NjAyOTE4OSk7XHJcbiAgICBhID0gbWQ1X2hoKGEsIGIsIGMsIGQsIHhbaSsgOV0sIDQgLCAtNjQwMzY0NDg3KTtcclxuICAgIGQgPSBtZDVfaGgoZCwgYSwgYiwgYywgeFtpKzEyXSwgMTEsIC00MjE4MTU4MzUpO1xyXG4gICAgYyA9IG1kNV9oaChjLCBkLCBhLCBiLCB4W2krMTVdLCAxNiwgIDUzMDc0MjUyMCk7XHJcbiAgICBiID0gbWQ1X2hoKGIsIGMsIGQsIGEsIHhbaSsgMl0sIDIzLCAtOTk1MzM4NjUxKTtcclxuXHJcbiAgICBhID0gbWQ1X2lpKGEsIGIsIGMsIGQsIHhbaSsgMF0sIDYgLCAtMTk4NjMwODQ0KTtcclxuICAgIGQgPSBtZDVfaWkoZCwgYSwgYiwgYywgeFtpKyA3XSwgMTAsICAxMTI2ODkxNDE1KTtcclxuICAgIGMgPSBtZDVfaWkoYywgZCwgYSwgYiwgeFtpKzE0XSwgMTUsIC0xNDE2MzU0OTA1KTtcclxuICAgIGIgPSBtZDVfaWkoYiwgYywgZCwgYSwgeFtpKyA1XSwgMjEsIC01NzQzNDA1NSk7XHJcbiAgICBhID0gbWQ1X2lpKGEsIGIsIGMsIGQsIHhbaSsxMl0sIDYgLCAgMTcwMDQ4NTU3MSk7XHJcbiAgICBkID0gbWQ1X2lpKGQsIGEsIGIsIGMsIHhbaSsgM10sIDEwLCAtMTg5NDk4NjYwNik7XHJcbiAgICBjID0gbWQ1X2lpKGMsIGQsIGEsIGIsIHhbaSsxMF0sIDE1LCAtMTA1MTUyMyk7XHJcbiAgICBiID0gbWQ1X2lpKGIsIGMsIGQsIGEsIHhbaSsgMV0sIDIxLCAtMjA1NDkyMjc5OSk7XHJcbiAgICBhID0gbWQ1X2lpKGEsIGIsIGMsIGQsIHhbaSsgOF0sIDYgLCAgMTg3MzMxMzM1OSk7XHJcbiAgICBkID0gbWQ1X2lpKGQsIGEsIGIsIGMsIHhbaSsxNV0sIDEwLCAtMzA2MTE3NDQpO1xyXG4gICAgYyA9IG1kNV9paShjLCBkLCBhLCBiLCB4W2krIDZdLCAxNSwgLTE1NjAxOTgzODApO1xyXG4gICAgYiA9IG1kNV9paShiLCBjLCBkLCBhLCB4W2krMTNdLCAyMSwgIDEzMDkxNTE2NDkpO1xyXG4gICAgYSA9IG1kNV9paShhLCBiLCBjLCBkLCB4W2krIDRdLCA2ICwgLTE0NTUyMzA3MCk7XHJcbiAgICBkID0gbWQ1X2lpKGQsIGEsIGIsIGMsIHhbaSsxMV0sIDEwLCAtMTEyMDIxMDM3OSk7XHJcbiAgICBjID0gbWQ1X2lpKGMsIGQsIGEsIGIsIHhbaSsgMl0sIDE1LCAgNzE4Nzg3MjU5KTtcclxuICAgIGIgPSBtZDVfaWkoYiwgYywgZCwgYSwgeFtpKyA5XSwgMjEsIC0zNDM0ODU1NTEpO1xyXG5cclxuICAgIGEgPSBzYWZlX2FkZChhLCBvbGRhKTtcclxuICAgIGIgPSBzYWZlX2FkZChiLCBvbGRiKTtcclxuICAgIGMgPSBzYWZlX2FkZChjLCBvbGRjKTtcclxuICAgIGQgPSBzYWZlX2FkZChkLCBvbGRkKTtcclxuICB9XHJcbiAgcmV0dXJuIEFycmF5KGEsIGIsIGMsIGQpO1xyXG5cclxufVxyXG5cclxuLypcclxuICogVGhlc2UgZnVuY3Rpb25zIGltcGxlbWVudCB0aGUgZm91ciBiYXNpYyBvcGVyYXRpb25zIHRoZSBhbGdvcml0aG0gdXNlcy5cclxuICovXHJcbmZ1bmN0aW9uIG1kNV9jbW4ocSwgYSwgYiwgeCwgcywgdClcclxue1xyXG4gIHJldHVybiBzYWZlX2FkZChiaXRfcm9sKHNhZmVfYWRkKHNhZmVfYWRkKGEsIHEpLCBzYWZlX2FkZCh4LCB0KSksIHMpLGIpO1xyXG59XHJcbmZ1bmN0aW9uIG1kNV9mZihhLCBiLCBjLCBkLCB4LCBzLCB0KVxyXG57XHJcbiAgcmV0dXJuIG1kNV9jbW4oKGIgJiBjKSB8ICgofmIpICYgZCksIGEsIGIsIHgsIHMsIHQpO1xyXG59XHJcbmZ1bmN0aW9uIG1kNV9nZyhhLCBiLCBjLCBkLCB4LCBzLCB0KVxyXG57XHJcbiAgcmV0dXJuIG1kNV9jbW4oKGIgJiBkKSB8IChjICYgKH5kKSksIGEsIGIsIHgsIHMsIHQpO1xyXG59XHJcbmZ1bmN0aW9uIG1kNV9oaChhLCBiLCBjLCBkLCB4LCBzLCB0KVxyXG57XHJcbiAgcmV0dXJuIG1kNV9jbW4oYiBeIGMgXiBkLCBhLCBiLCB4LCBzLCB0KTtcclxufVxyXG5mdW5jdGlvbiBtZDVfaWkoYSwgYiwgYywgZCwgeCwgcywgdClcclxue1xyXG4gIHJldHVybiBtZDVfY21uKGMgXiAoYiB8ICh+ZCkpLCBhLCBiLCB4LCBzLCB0KTtcclxufVxyXG5cclxuLypcclxuICogQWRkIGludGVnZXJzLCB3cmFwcGluZyBhdCAyXjMyLiBUaGlzIHVzZXMgMTYtYml0IG9wZXJhdGlvbnMgaW50ZXJuYWxseVxyXG4gKiB0byB3b3JrIGFyb3VuZCBidWdzIGluIHNvbWUgSlMgaW50ZXJwcmV0ZXJzLlxyXG4gKi9cclxuZnVuY3Rpb24gc2FmZV9hZGQoeCwgeSlcclxue1xyXG4gIHZhciBsc3cgPSAoeCAmIDB4RkZGRikgKyAoeSAmIDB4RkZGRik7XHJcbiAgdmFyIG1zdyA9ICh4ID4+IDE2KSArICh5ID4+IDE2KSArIChsc3cgPj4gMTYpO1xyXG4gIHJldHVybiAobXN3IDw8IDE2KSB8IChsc3cgJiAweEZGRkYpO1xyXG59XHJcblxyXG4vKlxyXG4gKiBCaXR3aXNlIHJvdGF0ZSBhIDMyLWJpdCBudW1iZXIgdG8gdGhlIGxlZnQuXHJcbiAqL1xyXG5mdW5jdGlvbiBiaXRfcm9sKG51bSwgY250KVxyXG57XHJcbiAgcmV0dXJuIChudW0gPDwgY250KSB8IChudW0gPj4+ICgzMiAtIGNudCkpO1xyXG59XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIG1kNShidWYpIHtcclxuICByZXR1cm4gaGVscGVycy5oYXNoKGJ1ZiwgY29yZV9tZDUsIDE2KTtcclxufTtcclxuIiwiLy8gT3JpZ2luYWwgY29kZSBhZGFwdGVkIGZyb20gUm9iZXJ0IEtpZWZmZXIuXG4vLyBkZXRhaWxzIGF0IGh0dHBzOi8vZ2l0aHViLmNvbS9icm9vZmEvbm9kZS11dWlkXG4oZnVuY3Rpb24oKSB7XG4gIHZhciBfZ2xvYmFsID0gdGhpcztcblxuICB2YXIgbWF0aFJORywgd2hhdHdnUk5HO1xuXG4gIC8vIE5PVEU6IE1hdGgucmFuZG9tKCkgZG9lcyBub3QgZ3VhcmFudGVlIFwiY3J5cHRvZ3JhcGhpYyBxdWFsaXR5XCJcbiAgbWF0aFJORyA9IGZ1bmN0aW9uKHNpemUpIHtcbiAgICB2YXIgYnl0ZXMgPSBuZXcgQXJyYXkoc2l6ZSk7XG4gICAgdmFyIHI7XG5cbiAgICBmb3IgKHZhciBpID0gMCwgcjsgaSA8IHNpemU7IGkrKykge1xuICAgICAgaWYgKChpICYgMHgwMykgPT0gMCkgciA9IE1hdGgucmFuZG9tKCkgKiAweDEwMDAwMDAwMDtcbiAgICAgIGJ5dGVzW2ldID0gciA+Pj4gKChpICYgMHgwMykgPDwgMykgJiAweGZmO1xuICAgIH1cblxuICAgIHJldHVybiBieXRlcztcbiAgfVxuXG4gIGlmIChfZ2xvYmFsLmNyeXB0byAmJiBjcnlwdG8uZ2V0UmFuZG9tVmFsdWVzKSB7XG4gICAgd2hhdHdnUk5HID0gZnVuY3Rpb24oc2l6ZSkge1xuICAgICAgdmFyIGJ5dGVzID0gbmV3IFVpbnQ4QXJyYXkoc2l6ZSk7XG4gICAgICBjcnlwdG8uZ2V0UmFuZG9tVmFsdWVzKGJ5dGVzKTtcbiAgICAgIHJldHVybiBieXRlcztcbiAgICB9XG4gIH1cblxuICBtb2R1bGUuZXhwb3J0cyA9IHdoYXR3Z1JORyB8fCBtYXRoUk5HO1xuXG59KCkpXG4iLCIvKlxuICogQSBKYXZhU2NyaXB0IGltcGxlbWVudGF0aW9uIG9mIHRoZSBTZWN1cmUgSGFzaCBBbGdvcml0aG0sIFNIQS0xLCBhcyBkZWZpbmVkXG4gKiBpbiBGSVBTIFBVQiAxODAtMVxuICogVmVyc2lvbiAyLjFhIENvcHlyaWdodCBQYXVsIEpvaG5zdG9uIDIwMDAgLSAyMDAyLlxuICogT3RoZXIgY29udHJpYnV0b3JzOiBHcmVnIEhvbHQsIEFuZHJldyBLZXBlcnQsIFlkbmFyLCBMb3N0aW5ldFxuICogRGlzdHJpYnV0ZWQgdW5kZXIgdGhlIEJTRCBMaWNlbnNlXG4gKiBTZWUgaHR0cDovL3BhamhvbWUub3JnLnVrL2NyeXB0L21kNSBmb3IgZGV0YWlscy5cbiAqL1xuXG52YXIgaGVscGVycyA9IHJlcXVpcmUoJy4vaGVscGVycycpO1xuXG4vKlxuICogQ2FsY3VsYXRlIHRoZSBTSEEtMSBvZiBhbiBhcnJheSBvZiBiaWctZW5kaWFuIHdvcmRzLCBhbmQgYSBiaXQgbGVuZ3RoXG4gKi9cbmZ1bmN0aW9uIGNvcmVfc2hhMSh4LCBsZW4pXG57XG4gIC8qIGFwcGVuZCBwYWRkaW5nICovXG4gIHhbbGVuID4+IDVdIHw9IDB4ODAgPDwgKDI0IC0gbGVuICUgMzIpO1xuICB4WygobGVuICsgNjQgPj4gOSkgPDwgNCkgKyAxNV0gPSBsZW47XG5cbiAgdmFyIHcgPSBBcnJheSg4MCk7XG4gIHZhciBhID0gIDE3MzI1ODQxOTM7XG4gIHZhciBiID0gLTI3MTczMzg3OTtcbiAgdmFyIGMgPSAtMTczMjU4NDE5NDtcbiAgdmFyIGQgPSAgMjcxNzMzODc4O1xuICB2YXIgZSA9IC0xMDA5NTg5Nzc2O1xuXG4gIGZvcih2YXIgaSA9IDA7IGkgPCB4Lmxlbmd0aDsgaSArPSAxNilcbiAge1xuICAgIHZhciBvbGRhID0gYTtcbiAgICB2YXIgb2xkYiA9IGI7XG4gICAgdmFyIG9sZGMgPSBjO1xuICAgIHZhciBvbGRkID0gZDtcbiAgICB2YXIgb2xkZSA9IGU7XG5cbiAgICBmb3IodmFyIGogPSAwOyBqIDwgODA7IGorKylcbiAgICB7XG4gICAgICBpZihqIDwgMTYpIHdbal0gPSB4W2kgKyBqXTtcbiAgICAgIGVsc2Ugd1tqXSA9IHJvbCh3W2otM10gXiB3W2otOF0gXiB3W2otMTRdIF4gd1tqLTE2XSwgMSk7XG4gICAgICB2YXIgdCA9IHNhZmVfYWRkKHNhZmVfYWRkKHJvbChhLCA1KSwgc2hhMV9mdChqLCBiLCBjLCBkKSksXG4gICAgICAgICAgICAgICAgICAgICAgIHNhZmVfYWRkKHNhZmVfYWRkKGUsIHdbal0pLCBzaGExX2t0KGopKSk7XG4gICAgICBlID0gZDtcbiAgICAgIGQgPSBjO1xuICAgICAgYyA9IHJvbChiLCAzMCk7XG4gICAgICBiID0gYTtcbiAgICAgIGEgPSB0O1xuICAgIH1cblxuICAgIGEgPSBzYWZlX2FkZChhLCBvbGRhKTtcbiAgICBiID0gc2FmZV9hZGQoYiwgb2xkYik7XG4gICAgYyA9IHNhZmVfYWRkKGMsIG9sZGMpO1xuICAgIGQgPSBzYWZlX2FkZChkLCBvbGRkKTtcbiAgICBlID0gc2FmZV9hZGQoZSwgb2xkZSk7XG4gIH1cbiAgcmV0dXJuIEFycmF5KGEsIGIsIGMsIGQsIGUpO1xuXG59XG5cbi8qXG4gKiBQZXJmb3JtIHRoZSBhcHByb3ByaWF0ZSB0cmlwbGV0IGNvbWJpbmF0aW9uIGZ1bmN0aW9uIGZvciB0aGUgY3VycmVudFxuICogaXRlcmF0aW9uXG4gKi9cbmZ1bmN0aW9uIHNoYTFfZnQodCwgYiwgYywgZClcbntcbiAgaWYodCA8IDIwKSByZXR1cm4gKGIgJiBjKSB8ICgofmIpICYgZCk7XG4gIGlmKHQgPCA0MCkgcmV0dXJuIGIgXiBjIF4gZDtcbiAgaWYodCA8IDYwKSByZXR1cm4gKGIgJiBjKSB8IChiICYgZCkgfCAoYyAmIGQpO1xuICByZXR1cm4gYiBeIGMgXiBkO1xufVxuXG4vKlxuICogRGV0ZXJtaW5lIHRoZSBhcHByb3ByaWF0ZSBhZGRpdGl2ZSBjb25zdGFudCBmb3IgdGhlIGN1cnJlbnQgaXRlcmF0aW9uXG4gKi9cbmZ1bmN0aW9uIHNoYTFfa3QodClcbntcbiAgcmV0dXJuICh0IDwgMjApID8gIDE1MTg1MDAyNDkgOiAodCA8IDQwKSA/ICAxODU5Nzc1MzkzIDpcbiAgICAgICAgICh0IDwgNjApID8gLTE4OTQwMDc1ODggOiAtODk5NDk3NTE0O1xufVxuXG4vKlxuICogQWRkIGludGVnZXJzLCB3cmFwcGluZyBhdCAyXjMyLiBUaGlzIHVzZXMgMTYtYml0IG9wZXJhdGlvbnMgaW50ZXJuYWxseVxuICogdG8gd29yayBhcm91bmQgYnVncyBpbiBzb21lIEpTIGludGVycHJldGVycy5cbiAqL1xuZnVuY3Rpb24gc2FmZV9hZGQoeCwgeSlcbntcbiAgdmFyIGxzdyA9ICh4ICYgMHhGRkZGKSArICh5ICYgMHhGRkZGKTtcbiAgdmFyIG1zdyA9ICh4ID4+IDE2KSArICh5ID4+IDE2KSArIChsc3cgPj4gMTYpO1xuICByZXR1cm4gKG1zdyA8PCAxNikgfCAobHN3ICYgMHhGRkZGKTtcbn1cblxuLypcbiAqIEJpdHdpc2Ugcm90YXRlIGEgMzItYml0IG51bWJlciB0byB0aGUgbGVmdC5cbiAqL1xuZnVuY3Rpb24gcm9sKG51bSwgY250KVxue1xuICByZXR1cm4gKG51bSA8PCBjbnQpIHwgKG51bSA+Pj4gKDMyIC0gY250KSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gc2hhMShidWYpIHtcbiAgcmV0dXJuIGhlbHBlcnMuaGFzaChidWYsIGNvcmVfc2hhMSwgMjAsIHRydWUpO1xufTtcbiIsIlxuLyoqXG4gKiBBIEphdmFTY3JpcHQgaW1wbGVtZW50YXRpb24gb2YgdGhlIFNlY3VyZSBIYXNoIEFsZ29yaXRobSwgU0hBLTI1NiwgYXMgZGVmaW5lZFxuICogaW4gRklQUyAxODAtMlxuICogVmVyc2lvbiAyLjItYmV0YSBDb3B5cmlnaHQgQW5nZWwgTWFyaW4sIFBhdWwgSm9obnN0b24gMjAwMCAtIDIwMDkuXG4gKiBPdGhlciBjb250cmlidXRvcnM6IEdyZWcgSG9sdCwgQW5kcmV3IEtlcGVydCwgWWRuYXIsIExvc3RpbmV0XG4gKlxuICovXG5cbnZhciBoZWxwZXJzID0gcmVxdWlyZSgnLi9oZWxwZXJzJyk7XG5cbnZhciBzYWZlX2FkZCA9IGZ1bmN0aW9uKHgsIHkpIHtcbiAgdmFyIGxzdyA9ICh4ICYgMHhGRkZGKSArICh5ICYgMHhGRkZGKTtcbiAgdmFyIG1zdyA9ICh4ID4+IDE2KSArICh5ID4+IDE2KSArIChsc3cgPj4gMTYpO1xuICByZXR1cm4gKG1zdyA8PCAxNikgfCAobHN3ICYgMHhGRkZGKTtcbn07XG5cbnZhciBTID0gZnVuY3Rpb24oWCwgbikge1xuICByZXR1cm4gKFggPj4+IG4pIHwgKFggPDwgKDMyIC0gbikpO1xufTtcblxudmFyIFIgPSBmdW5jdGlvbihYLCBuKSB7XG4gIHJldHVybiAoWCA+Pj4gbik7XG59O1xuXG52YXIgQ2ggPSBmdW5jdGlvbih4LCB5LCB6KSB7XG4gIHJldHVybiAoKHggJiB5KSBeICgofngpICYgeikpO1xufTtcblxudmFyIE1haiA9IGZ1bmN0aW9uKHgsIHksIHopIHtcbiAgcmV0dXJuICgoeCAmIHkpIF4gKHggJiB6KSBeICh5ICYgeikpO1xufTtcblxudmFyIFNpZ21hMDI1NiA9IGZ1bmN0aW9uKHgpIHtcbiAgcmV0dXJuIChTKHgsIDIpIF4gUyh4LCAxMykgXiBTKHgsIDIyKSk7XG59O1xuXG52YXIgU2lnbWExMjU2ID0gZnVuY3Rpb24oeCkge1xuICByZXR1cm4gKFMoeCwgNikgXiBTKHgsIDExKSBeIFMoeCwgMjUpKTtcbn07XG5cbnZhciBHYW1tYTAyNTYgPSBmdW5jdGlvbih4KSB7XG4gIHJldHVybiAoUyh4LCA3KSBeIFMoeCwgMTgpIF4gUih4LCAzKSk7XG59O1xuXG52YXIgR2FtbWExMjU2ID0gZnVuY3Rpb24oeCkge1xuICByZXR1cm4gKFMoeCwgMTcpIF4gUyh4LCAxOSkgXiBSKHgsIDEwKSk7XG59O1xuXG52YXIgY29yZV9zaGEyNTYgPSBmdW5jdGlvbihtLCBsKSB7XG4gIHZhciBLID0gbmV3IEFycmF5KDB4NDI4QTJGOTgsMHg3MTM3NDQ5MSwweEI1QzBGQkNGLDB4RTlCNURCQTUsMHgzOTU2QzI1QiwweDU5RjExMUYxLDB4OTIzRjgyQTQsMHhBQjFDNUVENSwweEQ4MDdBQTk4LDB4MTI4MzVCMDEsMHgyNDMxODVCRSwweDU1MEM3REMzLDB4NzJCRTVENzQsMHg4MERFQjFGRSwweDlCREMwNkE3LDB4QzE5QkYxNzQsMHhFNDlCNjlDMSwweEVGQkU0Nzg2LDB4RkMxOURDNiwweDI0MENBMUNDLDB4MkRFOTJDNkYsMHg0QTc0ODRBQSwweDVDQjBBOURDLDB4NzZGOTg4REEsMHg5ODNFNTE1MiwweEE4MzFDNjZELDB4QjAwMzI3QzgsMHhCRjU5N0ZDNywweEM2RTAwQkYzLDB4RDVBNzkxNDcsMHg2Q0E2MzUxLDB4MTQyOTI5NjcsMHgyN0I3MEE4NSwweDJFMUIyMTM4LDB4NEQyQzZERkMsMHg1MzM4MEQxMywweDY1MEE3MzU0LDB4NzY2QTBBQkIsMHg4MUMyQzkyRSwweDkyNzIyQzg1LDB4QTJCRkU4QTEsMHhBODFBNjY0QiwweEMyNEI4QjcwLDB4Qzc2QzUxQTMsMHhEMTkyRTgxOSwweEQ2OTkwNjI0LDB4RjQwRTM1ODUsMHgxMDZBQTA3MCwweDE5QTRDMTE2LDB4MUUzNzZDMDgsMHgyNzQ4Nzc0QywweDM0QjBCQ0I1LDB4MzkxQzBDQjMsMHg0RUQ4QUE0QSwweDVCOUNDQTRGLDB4NjgyRTZGRjMsMHg3NDhGODJFRSwweDc4QTU2MzZGLDB4ODRDODc4MTQsMHg4Q0M3MDIwOCwweDkwQkVGRkZBLDB4QTQ1MDZDRUIsMHhCRUY5QTNGNywweEM2NzE3OEYyKTtcbiAgdmFyIEhBU0ggPSBuZXcgQXJyYXkoMHg2QTA5RTY2NywgMHhCQjY3QUU4NSwgMHgzQzZFRjM3MiwgMHhBNTRGRjUzQSwgMHg1MTBFNTI3RiwgMHg5QjA1Njg4QywgMHgxRjgzRDlBQiwgMHg1QkUwQ0QxOSk7XG4gICAgdmFyIFcgPSBuZXcgQXJyYXkoNjQpO1xuICAgIHZhciBhLCBiLCBjLCBkLCBlLCBmLCBnLCBoLCBpLCBqO1xuICAgIHZhciBUMSwgVDI7XG4gIC8qIGFwcGVuZCBwYWRkaW5nICovXG4gIG1bbCA+PiA1XSB8PSAweDgwIDw8ICgyNCAtIGwgJSAzMik7XG4gIG1bKChsICsgNjQgPj4gOSkgPDwgNCkgKyAxNV0gPSBsO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IG0ubGVuZ3RoOyBpICs9IDE2KSB7XG4gICAgYSA9IEhBU0hbMF07IGIgPSBIQVNIWzFdOyBjID0gSEFTSFsyXTsgZCA9IEhBU0hbM107IGUgPSBIQVNIWzRdOyBmID0gSEFTSFs1XTsgZyA9IEhBU0hbNl07IGggPSBIQVNIWzddO1xuICAgIGZvciAodmFyIGogPSAwOyBqIDwgNjQ7IGorKykge1xuICAgICAgaWYgKGogPCAxNikge1xuICAgICAgICBXW2pdID0gbVtqICsgaV07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBXW2pdID0gc2FmZV9hZGQoc2FmZV9hZGQoc2FmZV9hZGQoR2FtbWExMjU2KFdbaiAtIDJdKSwgV1tqIC0gN10pLCBHYW1tYTAyNTYoV1tqIC0gMTVdKSksIFdbaiAtIDE2XSk7XG4gICAgICB9XG4gICAgICBUMSA9IHNhZmVfYWRkKHNhZmVfYWRkKHNhZmVfYWRkKHNhZmVfYWRkKGgsIFNpZ21hMTI1NihlKSksIENoKGUsIGYsIGcpKSwgS1tqXSksIFdbal0pO1xuICAgICAgVDIgPSBzYWZlX2FkZChTaWdtYTAyNTYoYSksIE1haihhLCBiLCBjKSk7XG4gICAgICBoID0gZzsgZyA9IGY7IGYgPSBlOyBlID0gc2FmZV9hZGQoZCwgVDEpOyBkID0gYzsgYyA9IGI7IGIgPSBhOyBhID0gc2FmZV9hZGQoVDEsIFQyKTtcbiAgICB9XG4gICAgSEFTSFswXSA9IHNhZmVfYWRkKGEsIEhBU0hbMF0pOyBIQVNIWzFdID0gc2FmZV9hZGQoYiwgSEFTSFsxXSk7IEhBU0hbMl0gPSBzYWZlX2FkZChjLCBIQVNIWzJdKTsgSEFTSFszXSA9IHNhZmVfYWRkKGQsIEhBU0hbM10pO1xuICAgIEhBU0hbNF0gPSBzYWZlX2FkZChlLCBIQVNIWzRdKTsgSEFTSFs1XSA9IHNhZmVfYWRkKGYsIEhBU0hbNV0pOyBIQVNIWzZdID0gc2FmZV9hZGQoZywgSEFTSFs2XSk7IEhBU0hbN10gPSBzYWZlX2FkZChoLCBIQVNIWzddKTtcbiAgfVxuICByZXR1cm4gSEFTSDtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gc2hhMjU2KGJ1Zikge1xuICByZXR1cm4gaGVscGVycy5oYXNoKGJ1ZiwgY29yZV9zaGEyNTYsIDMyLCB0cnVlKTtcbn07XG4iLCIvLyBDb3B5cmlnaHQgSm95ZW50LCBJbmMuIGFuZCBvdGhlciBOb2RlIGNvbnRyaWJ1dG9ycy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxuLy8gY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxuLy8gXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXG4vLyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXG4vLyBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0XG4vLyBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGVcbi8vIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkXG4vLyBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTXG4vLyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4vLyBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOXG4vLyBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSxcbi8vIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUlxuLy8gT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRVxuLy8gVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cblxuZnVuY3Rpb24gRXZlbnRFbWl0dGVyKCkge1xuICB0aGlzLl9ldmVudHMgPSB0aGlzLl9ldmVudHMgfHwge307XG4gIHRoaXMuX21heExpc3RlbmVycyA9IHRoaXMuX21heExpc3RlbmVycyB8fCB1bmRlZmluZWQ7XG59XG5tb2R1bGUuZXhwb3J0cyA9IEV2ZW50RW1pdHRlcjtcblxuLy8gQmFja3dhcmRzLWNvbXBhdCB3aXRoIG5vZGUgMC4xMC54XG5FdmVudEVtaXR0ZXIuRXZlbnRFbWl0dGVyID0gRXZlbnRFbWl0dGVyO1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLl9ldmVudHMgPSB1bmRlZmluZWQ7XG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLl9tYXhMaXN0ZW5lcnMgPSB1bmRlZmluZWQ7XG5cbi8vIEJ5IGRlZmF1bHQgRXZlbnRFbWl0dGVycyB3aWxsIHByaW50IGEgd2FybmluZyBpZiBtb3JlIHRoYW4gMTAgbGlzdGVuZXJzIGFyZVxuLy8gYWRkZWQgdG8gaXQuIFRoaXMgaXMgYSB1c2VmdWwgZGVmYXVsdCB3aGljaCBoZWxwcyBmaW5kaW5nIG1lbW9yeSBsZWFrcy5cbkV2ZW50RW1pdHRlci5kZWZhdWx0TWF4TGlzdGVuZXJzID0gMTA7XG5cbi8vIE9idmlvdXNseSBub3QgYWxsIEVtaXR0ZXJzIHNob3VsZCBiZSBsaW1pdGVkIHRvIDEwLiBUaGlzIGZ1bmN0aW9uIGFsbG93c1xuLy8gdGhhdCB0byBiZSBpbmNyZWFzZWQuIFNldCB0byB6ZXJvIGZvciB1bmxpbWl0ZWQuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLnNldE1heExpc3RlbmVycyA9IGZ1bmN0aW9uKG4pIHtcbiAgaWYgKCFpc051bWJlcihuKSB8fCBuIDwgMCB8fCBpc05hTihuKSlcbiAgICB0aHJvdyBUeXBlRXJyb3IoJ24gbXVzdCBiZSBhIHBvc2l0aXZlIG51bWJlcicpO1xuICB0aGlzLl9tYXhMaXN0ZW5lcnMgPSBuO1xuICByZXR1cm4gdGhpcztcbn07XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuZW1pdCA9IGZ1bmN0aW9uKHR5cGUpIHtcbiAgdmFyIGVyLCBoYW5kbGVyLCBsZW4sIGFyZ3MsIGksIGxpc3RlbmVycztcblxuICBpZiAoIXRoaXMuX2V2ZW50cylcbiAgICB0aGlzLl9ldmVudHMgPSB7fTtcblxuICAvLyBJZiB0aGVyZSBpcyBubyAnZXJyb3InIGV2ZW50IGxpc3RlbmVyIHRoZW4gdGhyb3cuXG4gIGlmICh0eXBlID09PSAnZXJyb3InKSB7XG4gICAgaWYgKCF0aGlzLl9ldmVudHMuZXJyb3IgfHxcbiAgICAgICAgKGlzT2JqZWN0KHRoaXMuX2V2ZW50cy5lcnJvcikgJiYgIXRoaXMuX2V2ZW50cy5lcnJvci5sZW5ndGgpKSB7XG4gICAgICBlciA9IGFyZ3VtZW50c1sxXTtcbiAgICAgIGlmIChlciBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgICAgIHRocm93IGVyOyAvLyBVbmhhbmRsZWQgJ2Vycm9yJyBldmVudFxuICAgICAgfVxuICAgICAgdGhyb3cgVHlwZUVycm9yKCdVbmNhdWdodCwgdW5zcGVjaWZpZWQgXCJlcnJvclwiIGV2ZW50LicpO1xuICAgIH1cbiAgfVxuXG4gIGhhbmRsZXIgPSB0aGlzLl9ldmVudHNbdHlwZV07XG5cbiAgaWYgKGlzVW5kZWZpbmVkKGhhbmRsZXIpKVxuICAgIHJldHVybiBmYWxzZTtcblxuICBpZiAoaXNGdW5jdGlvbihoYW5kbGVyKSkge1xuICAgIHN3aXRjaCAoYXJndW1lbnRzLmxlbmd0aCkge1xuICAgICAgLy8gZmFzdCBjYXNlc1xuICAgICAgY2FzZSAxOlxuICAgICAgICBoYW5kbGVyLmNhbGwodGhpcyk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAyOlxuICAgICAgICBoYW5kbGVyLmNhbGwodGhpcywgYXJndW1lbnRzWzFdKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIDM6XG4gICAgICAgIGhhbmRsZXIuY2FsbCh0aGlzLCBhcmd1bWVudHNbMV0sIGFyZ3VtZW50c1syXSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgLy8gc2xvd2VyXG4gICAgICBkZWZhdWx0OlxuICAgICAgICBsZW4gPSBhcmd1bWVudHMubGVuZ3RoO1xuICAgICAgICBhcmdzID0gbmV3IEFycmF5KGxlbiAtIDEpO1xuICAgICAgICBmb3IgKGkgPSAxOyBpIDwgbGVuOyBpKyspXG4gICAgICAgICAgYXJnc1tpIC0gMV0gPSBhcmd1bWVudHNbaV07XG4gICAgICAgIGhhbmRsZXIuYXBwbHkodGhpcywgYXJncyk7XG4gICAgfVxuICB9IGVsc2UgaWYgKGlzT2JqZWN0KGhhbmRsZXIpKSB7XG4gICAgbGVuID0gYXJndW1lbnRzLmxlbmd0aDtcbiAgICBhcmdzID0gbmV3IEFycmF5KGxlbiAtIDEpO1xuICAgIGZvciAoaSA9IDE7IGkgPCBsZW47IGkrKylcbiAgICAgIGFyZ3NbaSAtIDFdID0gYXJndW1lbnRzW2ldO1xuXG4gICAgbGlzdGVuZXJzID0gaGFuZGxlci5zbGljZSgpO1xuICAgIGxlbiA9IGxpc3RlbmVycy5sZW5ndGg7XG4gICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSsrKVxuICAgICAgbGlzdGVuZXJzW2ldLmFwcGx5KHRoaXMsIGFyZ3MpO1xuICB9XG5cbiAgcmV0dXJuIHRydWU7XG59O1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLmFkZExpc3RlbmVyID0gZnVuY3Rpb24odHlwZSwgbGlzdGVuZXIpIHtcbiAgdmFyIG07XG5cbiAgaWYgKCFpc0Z1bmN0aW9uKGxpc3RlbmVyKSlcbiAgICB0aHJvdyBUeXBlRXJyb3IoJ2xpc3RlbmVyIG11c3QgYmUgYSBmdW5jdGlvbicpO1xuXG4gIGlmICghdGhpcy5fZXZlbnRzKVxuICAgIHRoaXMuX2V2ZW50cyA9IHt9O1xuXG4gIC8vIFRvIGF2b2lkIHJlY3Vyc2lvbiBpbiB0aGUgY2FzZSB0aGF0IHR5cGUgPT09IFwibmV3TGlzdGVuZXJcIiEgQmVmb3JlXG4gIC8vIGFkZGluZyBpdCB0byB0aGUgbGlzdGVuZXJzLCBmaXJzdCBlbWl0IFwibmV3TGlzdGVuZXJcIi5cbiAgaWYgKHRoaXMuX2V2ZW50cy5uZXdMaXN0ZW5lcilcbiAgICB0aGlzLmVtaXQoJ25ld0xpc3RlbmVyJywgdHlwZSxcbiAgICAgICAgICAgICAgaXNGdW5jdGlvbihsaXN0ZW5lci5saXN0ZW5lcikgP1xuICAgICAgICAgICAgICBsaXN0ZW5lci5saXN0ZW5lciA6IGxpc3RlbmVyKTtcblxuICBpZiAoIXRoaXMuX2V2ZW50c1t0eXBlXSlcbiAgICAvLyBPcHRpbWl6ZSB0aGUgY2FzZSBvZiBvbmUgbGlzdGVuZXIuIERvbid0IG5lZWQgdGhlIGV4dHJhIGFycmF5IG9iamVjdC5cbiAgICB0aGlzLl9ldmVudHNbdHlwZV0gPSBsaXN0ZW5lcjtcbiAgZWxzZSBpZiAoaXNPYmplY3QodGhpcy5fZXZlbnRzW3R5cGVdKSlcbiAgICAvLyBJZiB3ZSd2ZSBhbHJlYWR5IGdvdCBhbiBhcnJheSwganVzdCBhcHBlbmQuXG4gICAgdGhpcy5fZXZlbnRzW3R5cGVdLnB1c2gobGlzdGVuZXIpO1xuICBlbHNlXG4gICAgLy8gQWRkaW5nIHRoZSBzZWNvbmQgZWxlbWVudCwgbmVlZCB0byBjaGFuZ2UgdG8gYXJyYXkuXG4gICAgdGhpcy5fZXZlbnRzW3R5cGVdID0gW3RoaXMuX2V2ZW50c1t0eXBlXSwgbGlzdGVuZXJdO1xuXG4gIC8vIENoZWNrIGZvciBsaXN0ZW5lciBsZWFrXG4gIGlmIChpc09iamVjdCh0aGlzLl9ldmVudHNbdHlwZV0pICYmICF0aGlzLl9ldmVudHNbdHlwZV0ud2FybmVkKSB7XG4gICAgdmFyIG07XG4gICAgaWYgKCFpc1VuZGVmaW5lZCh0aGlzLl9tYXhMaXN0ZW5lcnMpKSB7XG4gICAgICBtID0gdGhpcy5fbWF4TGlzdGVuZXJzO1xuICAgIH0gZWxzZSB7XG4gICAgICBtID0gRXZlbnRFbWl0dGVyLmRlZmF1bHRNYXhMaXN0ZW5lcnM7XG4gICAgfVxuXG4gICAgaWYgKG0gJiYgbSA+IDAgJiYgdGhpcy5fZXZlbnRzW3R5cGVdLmxlbmd0aCA+IG0pIHtcbiAgICAgIHRoaXMuX2V2ZW50c1t0eXBlXS53YXJuZWQgPSB0cnVlO1xuICAgICAgY29uc29sZS5lcnJvcignKG5vZGUpIHdhcm5pbmc6IHBvc3NpYmxlIEV2ZW50RW1pdHRlciBtZW1vcnkgJyArXG4gICAgICAgICAgICAgICAgICAgICdsZWFrIGRldGVjdGVkLiAlZCBsaXN0ZW5lcnMgYWRkZWQuICcgK1xuICAgICAgICAgICAgICAgICAgICAnVXNlIGVtaXR0ZXIuc2V0TWF4TGlzdGVuZXJzKCkgdG8gaW5jcmVhc2UgbGltaXQuJyxcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fZXZlbnRzW3R5cGVdLmxlbmd0aCk7XG4gICAgICBpZiAodHlwZW9mIGNvbnNvbGUudHJhY2UgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgLy8gbm90IHN1cHBvcnRlZCBpbiBJRSAxMFxuICAgICAgICBjb25zb2xlLnRyYWNlKCk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLm9uID0gRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5hZGRMaXN0ZW5lcjtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5vbmNlID0gZnVuY3Rpb24odHlwZSwgbGlzdGVuZXIpIHtcbiAgaWYgKCFpc0Z1bmN0aW9uKGxpc3RlbmVyKSlcbiAgICB0aHJvdyBUeXBlRXJyb3IoJ2xpc3RlbmVyIG11c3QgYmUgYSBmdW5jdGlvbicpO1xuXG4gIHZhciBmaXJlZCA9IGZhbHNlO1xuXG4gIGZ1bmN0aW9uIGcoKSB7XG4gICAgdGhpcy5yZW1vdmVMaXN0ZW5lcih0eXBlLCBnKTtcblxuICAgIGlmICghZmlyZWQpIHtcbiAgICAgIGZpcmVkID0gdHJ1ZTtcbiAgICAgIGxpc3RlbmVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuICB9XG5cbiAgZy5saXN0ZW5lciA9IGxpc3RlbmVyO1xuICB0aGlzLm9uKHR5cGUsIGcpO1xuXG4gIHJldHVybiB0aGlzO1xufTtcblxuLy8gZW1pdHMgYSAncmVtb3ZlTGlzdGVuZXInIGV2ZW50IGlmZiB0aGUgbGlzdGVuZXIgd2FzIHJlbW92ZWRcbkV2ZW50RW1pdHRlci5wcm90b3R5cGUucmVtb3ZlTGlzdGVuZXIgPSBmdW5jdGlvbih0eXBlLCBsaXN0ZW5lcikge1xuICB2YXIgbGlzdCwgcG9zaXRpb24sIGxlbmd0aCwgaTtcblxuICBpZiAoIWlzRnVuY3Rpb24obGlzdGVuZXIpKVxuICAgIHRocm93IFR5cGVFcnJvcignbGlzdGVuZXIgbXVzdCBiZSBhIGZ1bmN0aW9uJyk7XG5cbiAgaWYgKCF0aGlzLl9ldmVudHMgfHwgIXRoaXMuX2V2ZW50c1t0eXBlXSlcbiAgICByZXR1cm4gdGhpcztcblxuICBsaXN0ID0gdGhpcy5fZXZlbnRzW3R5cGVdO1xuICBsZW5ndGggPSBsaXN0Lmxlbmd0aDtcbiAgcG9zaXRpb24gPSAtMTtcblxuICBpZiAobGlzdCA9PT0gbGlzdGVuZXIgfHxcbiAgICAgIChpc0Z1bmN0aW9uKGxpc3QubGlzdGVuZXIpICYmIGxpc3QubGlzdGVuZXIgPT09IGxpc3RlbmVyKSkge1xuICAgIGRlbGV0ZSB0aGlzLl9ldmVudHNbdHlwZV07XG4gICAgaWYgKHRoaXMuX2V2ZW50cy5yZW1vdmVMaXN0ZW5lcilcbiAgICAgIHRoaXMuZW1pdCgncmVtb3ZlTGlzdGVuZXInLCB0eXBlLCBsaXN0ZW5lcik7XG5cbiAgfSBlbHNlIGlmIChpc09iamVjdChsaXN0KSkge1xuICAgIGZvciAoaSA9IGxlbmd0aDsgaS0tID4gMDspIHtcbiAgICAgIGlmIChsaXN0W2ldID09PSBsaXN0ZW5lciB8fFxuICAgICAgICAgIChsaXN0W2ldLmxpc3RlbmVyICYmIGxpc3RbaV0ubGlzdGVuZXIgPT09IGxpc3RlbmVyKSkge1xuICAgICAgICBwb3NpdGlvbiA9IGk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChwb3NpdGlvbiA8IDApXG4gICAgICByZXR1cm4gdGhpcztcblxuICAgIGlmIChsaXN0Lmxlbmd0aCA9PT0gMSkge1xuICAgICAgbGlzdC5sZW5ndGggPSAwO1xuICAgICAgZGVsZXRlIHRoaXMuX2V2ZW50c1t0eXBlXTtcbiAgICB9IGVsc2Uge1xuICAgICAgbGlzdC5zcGxpY2UocG9zaXRpb24sIDEpO1xuICAgIH1cblxuICAgIGlmICh0aGlzLl9ldmVudHMucmVtb3ZlTGlzdGVuZXIpXG4gICAgICB0aGlzLmVtaXQoJ3JlbW92ZUxpc3RlbmVyJywgdHlwZSwgbGlzdGVuZXIpO1xuICB9XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLnJlbW92ZUFsbExpc3RlbmVycyA9IGZ1bmN0aW9uKHR5cGUpIHtcbiAgdmFyIGtleSwgbGlzdGVuZXJzO1xuXG4gIGlmICghdGhpcy5fZXZlbnRzKVxuICAgIHJldHVybiB0aGlzO1xuXG4gIC8vIG5vdCBsaXN0ZW5pbmcgZm9yIHJlbW92ZUxpc3RlbmVyLCBubyBuZWVkIHRvIGVtaXRcbiAgaWYgKCF0aGlzLl9ldmVudHMucmVtb3ZlTGlzdGVuZXIpIHtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMClcbiAgICAgIHRoaXMuX2V2ZW50cyA9IHt9O1xuICAgIGVsc2UgaWYgKHRoaXMuX2V2ZW50c1t0eXBlXSlcbiAgICAgIGRlbGV0ZSB0aGlzLl9ldmVudHNbdHlwZV07XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvLyBlbWl0IHJlbW92ZUxpc3RlbmVyIGZvciBhbGwgbGlzdGVuZXJzIG9uIGFsbCBldmVudHNcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApIHtcbiAgICBmb3IgKGtleSBpbiB0aGlzLl9ldmVudHMpIHtcbiAgICAgIGlmIChrZXkgPT09ICdyZW1vdmVMaXN0ZW5lcicpIGNvbnRpbnVlO1xuICAgICAgdGhpcy5yZW1vdmVBbGxMaXN0ZW5lcnMoa2V5KTtcbiAgICB9XG4gICAgdGhpcy5yZW1vdmVBbGxMaXN0ZW5lcnMoJ3JlbW92ZUxpc3RlbmVyJyk7XG4gICAgdGhpcy5fZXZlbnRzID0ge307XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICBsaXN0ZW5lcnMgPSB0aGlzLl9ldmVudHNbdHlwZV07XG5cbiAgaWYgKGlzRnVuY3Rpb24obGlzdGVuZXJzKSkge1xuICAgIHRoaXMucmVtb3ZlTGlzdGVuZXIodHlwZSwgbGlzdGVuZXJzKTtcbiAgfSBlbHNlIHtcbiAgICAvLyBMSUZPIG9yZGVyXG4gICAgd2hpbGUgKGxpc3RlbmVycy5sZW5ndGgpXG4gICAgICB0aGlzLnJlbW92ZUxpc3RlbmVyKHR5cGUsIGxpc3RlbmVyc1tsaXN0ZW5lcnMubGVuZ3RoIC0gMV0pO1xuICB9XG4gIGRlbGV0ZSB0aGlzLl9ldmVudHNbdHlwZV07XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLmxpc3RlbmVycyA9IGZ1bmN0aW9uKHR5cGUpIHtcbiAgdmFyIHJldDtcbiAgaWYgKCF0aGlzLl9ldmVudHMgfHwgIXRoaXMuX2V2ZW50c1t0eXBlXSlcbiAgICByZXQgPSBbXTtcbiAgZWxzZSBpZiAoaXNGdW5jdGlvbih0aGlzLl9ldmVudHNbdHlwZV0pKVxuICAgIHJldCA9IFt0aGlzLl9ldmVudHNbdHlwZV1dO1xuICBlbHNlXG4gICAgcmV0ID0gdGhpcy5fZXZlbnRzW3R5cGVdLnNsaWNlKCk7XG4gIHJldHVybiByZXQ7XG59O1xuXG5FdmVudEVtaXR0ZXIubGlzdGVuZXJDb3VudCA9IGZ1bmN0aW9uKGVtaXR0ZXIsIHR5cGUpIHtcbiAgdmFyIHJldDtcbiAgaWYgKCFlbWl0dGVyLl9ldmVudHMgfHwgIWVtaXR0ZXIuX2V2ZW50c1t0eXBlXSlcbiAgICByZXQgPSAwO1xuICBlbHNlIGlmIChpc0Z1bmN0aW9uKGVtaXR0ZXIuX2V2ZW50c1t0eXBlXSkpXG4gICAgcmV0ID0gMTtcbiAgZWxzZVxuICAgIHJldCA9IGVtaXR0ZXIuX2V2ZW50c1t0eXBlXS5sZW5ndGg7XG4gIHJldHVybiByZXQ7XG59O1xuXG5mdW5jdGlvbiBpc0Z1bmN0aW9uKGFyZykge1xuICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ2Z1bmN0aW9uJztcbn1cblxuZnVuY3Rpb24gaXNOdW1iZXIoYXJnKSB7XG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnbnVtYmVyJztcbn1cblxuZnVuY3Rpb24gaXNPYmplY3QoYXJnKSB7XG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnb2JqZWN0JyAmJiBhcmcgIT09IG51bGw7XG59XG5cbmZ1bmN0aW9uIGlzVW5kZWZpbmVkKGFyZykge1xuICByZXR1cm4gYXJnID09PSB2b2lkIDA7XG59XG4iLCIvLyBzaGltIGZvciB1c2luZyBwcm9jZXNzIGluIGJyb3dzZXJcblxudmFyIHByb2Nlc3MgPSBtb2R1bGUuZXhwb3J0cyA9IHt9O1xuXG5wcm9jZXNzLm5leHRUaWNrID0gKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgY2FuU2V0SW1tZWRpYXRlID0gdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCdcbiAgICAmJiB3aW5kb3cuc2V0SW1tZWRpYXRlO1xuICAgIHZhciBjYW5Qb3N0ID0gdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCdcbiAgICAmJiB3aW5kb3cucG9zdE1lc3NhZ2UgJiYgd2luZG93LmFkZEV2ZW50TGlzdGVuZXJcbiAgICA7XG5cbiAgICBpZiAoY2FuU2V0SW1tZWRpYXRlKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoZikgeyByZXR1cm4gd2luZG93LnNldEltbWVkaWF0ZShmKSB9O1xuICAgIH1cblxuICAgIGlmIChjYW5Qb3N0KSB7XG4gICAgICAgIHZhciBxdWV1ZSA9IFtdO1xuICAgICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcignbWVzc2FnZScsIGZ1bmN0aW9uIChldikge1xuICAgICAgICAgICAgdmFyIHNvdXJjZSA9IGV2LnNvdXJjZTtcbiAgICAgICAgICAgIGlmICgoc291cmNlID09PSB3aW5kb3cgfHwgc291cmNlID09PSBudWxsKSAmJiBldi5kYXRhID09PSAncHJvY2Vzcy10aWNrJykge1xuICAgICAgICAgICAgICAgIGV2LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICAgICAgICAgIGlmIChxdWV1ZS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBmbiA9IHF1ZXVlLnNoaWZ0KCk7XG4gICAgICAgICAgICAgICAgICAgIGZuKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9LCB0cnVlKTtcblxuICAgICAgICByZXR1cm4gZnVuY3Rpb24gbmV4dFRpY2soZm4pIHtcbiAgICAgICAgICAgIHF1ZXVlLnB1c2goZm4pO1xuICAgICAgICAgICAgd2luZG93LnBvc3RNZXNzYWdlKCdwcm9jZXNzLXRpY2snLCAnKicpO1xuICAgICAgICB9O1xuICAgIH1cblxuICAgIHJldHVybiBmdW5jdGlvbiBuZXh0VGljayhmbikge1xuICAgICAgICBzZXRUaW1lb3V0KGZuLCAwKTtcbiAgICB9O1xufSkoKTtcblxucHJvY2Vzcy50aXRsZSA9ICdicm93c2VyJztcbnByb2Nlc3MuYnJvd3NlciA9IHRydWU7XG5wcm9jZXNzLmVudiA9IHt9O1xucHJvY2Vzcy5hcmd2ID0gW107XG5cbmZ1bmN0aW9uIG5vb3AoKSB7fVxuXG5wcm9jZXNzLm9uID0gbm9vcDtcbnByb2Nlc3MuYWRkTGlzdGVuZXIgPSBub29wO1xucHJvY2Vzcy5vbmNlID0gbm9vcDtcbnByb2Nlc3Mub2ZmID0gbm9vcDtcbnByb2Nlc3MucmVtb3ZlTGlzdGVuZXIgPSBub29wO1xucHJvY2Vzcy5yZW1vdmVBbGxMaXN0ZW5lcnMgPSBub29wO1xucHJvY2Vzcy5lbWl0ID0gbm9vcDtcblxucHJvY2Vzcy5iaW5kaW5nID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3Byb2Nlc3MuYmluZGluZyBpcyBub3Qgc3VwcG9ydGVkJyk7XG59XG5cbi8vIFRPRE8oc2h0eWxtYW4pXG5wcm9jZXNzLmN3ZCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuICcvJyB9O1xucHJvY2Vzcy5jaGRpciA9IGZ1bmN0aW9uIChkaXIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3Byb2Nlc3MuY2hkaXIgaXMgbm90IHN1cHBvcnRlZCcpO1xufTtcbiIsIihmdW5jdGlvbiAoZ2xvYmFsKXtcbi8qISBodHRwOi8vbXRocy5iZS9wdW55Y29kZSB2MS4yLjQgYnkgQG1hdGhpYXMgKi9cbjsoZnVuY3Rpb24ocm9vdCkge1xuXG5cdC8qKiBEZXRlY3QgZnJlZSB2YXJpYWJsZXMgKi9cblx0dmFyIGZyZWVFeHBvcnRzID0gdHlwZW9mIGV4cG9ydHMgPT0gJ29iamVjdCcgJiYgZXhwb3J0cztcblx0dmFyIGZyZWVNb2R1bGUgPSB0eXBlb2YgbW9kdWxlID09ICdvYmplY3QnICYmIG1vZHVsZSAmJlxuXHRcdG1vZHVsZS5leHBvcnRzID09IGZyZWVFeHBvcnRzICYmIG1vZHVsZTtcblx0dmFyIGZyZWVHbG9iYWwgPSB0eXBlb2YgZ2xvYmFsID09ICdvYmplY3QnICYmIGdsb2JhbDtcblx0aWYgKGZyZWVHbG9iYWwuZ2xvYmFsID09PSBmcmVlR2xvYmFsIHx8IGZyZWVHbG9iYWwud2luZG93ID09PSBmcmVlR2xvYmFsKSB7XG5cdFx0cm9vdCA9IGZyZWVHbG9iYWw7XG5cdH1cblxuXHQvKipcblx0ICogVGhlIGBwdW55Y29kZWAgb2JqZWN0LlxuXHQgKiBAbmFtZSBwdW55Y29kZVxuXHQgKiBAdHlwZSBPYmplY3Rcblx0ICovXG5cdHZhciBwdW55Y29kZSxcblxuXHQvKiogSGlnaGVzdCBwb3NpdGl2ZSBzaWduZWQgMzItYml0IGZsb2F0IHZhbHVlICovXG5cdG1heEludCA9IDIxNDc0ODM2NDcsIC8vIGFrYS4gMHg3RkZGRkZGRiBvciAyXjMxLTFcblxuXHQvKiogQm9vdHN0cmluZyBwYXJhbWV0ZXJzICovXG5cdGJhc2UgPSAzNixcblx0dE1pbiA9IDEsXG5cdHRNYXggPSAyNixcblx0c2tldyA9IDM4LFxuXHRkYW1wID0gNzAwLFxuXHRpbml0aWFsQmlhcyA9IDcyLFxuXHRpbml0aWFsTiA9IDEyOCwgLy8gMHg4MFxuXHRkZWxpbWl0ZXIgPSAnLScsIC8vICdcXHgyRCdcblxuXHQvKiogUmVndWxhciBleHByZXNzaW9ucyAqL1xuXHRyZWdleFB1bnljb2RlID0gL154bi0tLyxcblx0cmVnZXhOb25BU0NJSSA9IC9bXiAtfl0vLCAvLyB1bnByaW50YWJsZSBBU0NJSSBjaGFycyArIG5vbi1BU0NJSSBjaGFyc1xuXHRyZWdleFNlcGFyYXRvcnMgPSAvXFx4MkV8XFx1MzAwMnxcXHVGRjBFfFxcdUZGNjEvZywgLy8gUkZDIDM0OTAgc2VwYXJhdG9yc1xuXG5cdC8qKiBFcnJvciBtZXNzYWdlcyAqL1xuXHRlcnJvcnMgPSB7XG5cdFx0J292ZXJmbG93JzogJ092ZXJmbG93OiBpbnB1dCBuZWVkcyB3aWRlciBpbnRlZ2VycyB0byBwcm9jZXNzJyxcblx0XHQnbm90LWJhc2ljJzogJ0lsbGVnYWwgaW5wdXQgPj0gMHg4MCAobm90IGEgYmFzaWMgY29kZSBwb2ludCknLFxuXHRcdCdpbnZhbGlkLWlucHV0JzogJ0ludmFsaWQgaW5wdXQnXG5cdH0sXG5cblx0LyoqIENvbnZlbmllbmNlIHNob3J0Y3V0cyAqL1xuXHRiYXNlTWludXNUTWluID0gYmFzZSAtIHRNaW4sXG5cdGZsb29yID0gTWF0aC5mbG9vcixcblx0c3RyaW5nRnJvbUNoYXJDb2RlID0gU3RyaW5nLmZyb21DaGFyQ29kZSxcblxuXHQvKiogVGVtcG9yYXJ5IHZhcmlhYmxlICovXG5cdGtleTtcblxuXHQvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuXHQvKipcblx0ICogQSBnZW5lcmljIGVycm9yIHV0aWxpdHkgZnVuY3Rpb24uXG5cdCAqIEBwcml2YXRlXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlIFRoZSBlcnJvciB0eXBlLlxuXHQgKiBAcmV0dXJucyB7RXJyb3J9IFRocm93cyBhIGBSYW5nZUVycm9yYCB3aXRoIHRoZSBhcHBsaWNhYmxlIGVycm9yIG1lc3NhZ2UuXG5cdCAqL1xuXHRmdW5jdGlvbiBlcnJvcih0eXBlKSB7XG5cdFx0dGhyb3cgUmFuZ2VFcnJvcihlcnJvcnNbdHlwZV0pO1xuXHR9XG5cblx0LyoqXG5cdCAqIEEgZ2VuZXJpYyBgQXJyYXkjbWFwYCB1dGlsaXR5IGZ1bmN0aW9uLlxuXHQgKiBAcHJpdmF0ZVxuXHQgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gaXRlcmF0ZSBvdmVyLlxuXHQgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayBUaGUgZnVuY3Rpb24gdGhhdCBnZXRzIGNhbGxlZCBmb3IgZXZlcnkgYXJyYXlcblx0ICogaXRlbS5cblx0ICogQHJldHVybnMge0FycmF5fSBBIG5ldyBhcnJheSBvZiB2YWx1ZXMgcmV0dXJuZWQgYnkgdGhlIGNhbGxiYWNrIGZ1bmN0aW9uLlxuXHQgKi9cblx0ZnVuY3Rpb24gbWFwKGFycmF5LCBmbikge1xuXHRcdHZhciBsZW5ndGggPSBhcnJheS5sZW5ndGg7XG5cdFx0d2hpbGUgKGxlbmd0aC0tKSB7XG5cdFx0XHRhcnJheVtsZW5ndGhdID0gZm4oYXJyYXlbbGVuZ3RoXSk7XG5cdFx0fVxuXHRcdHJldHVybiBhcnJheTtcblx0fVxuXG5cdC8qKlxuXHQgKiBBIHNpbXBsZSBgQXJyYXkjbWFwYC1saWtlIHdyYXBwZXIgdG8gd29yayB3aXRoIGRvbWFpbiBuYW1lIHN0cmluZ3MuXG5cdCAqIEBwcml2YXRlXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBkb21haW4gVGhlIGRvbWFpbiBuYW1lLlxuXHQgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayBUaGUgZnVuY3Rpb24gdGhhdCBnZXRzIGNhbGxlZCBmb3IgZXZlcnlcblx0ICogY2hhcmFjdGVyLlxuXHQgKiBAcmV0dXJucyB7QXJyYXl9IEEgbmV3IHN0cmluZyBvZiBjaGFyYWN0ZXJzIHJldHVybmVkIGJ5IHRoZSBjYWxsYmFja1xuXHQgKiBmdW5jdGlvbi5cblx0ICovXG5cdGZ1bmN0aW9uIG1hcERvbWFpbihzdHJpbmcsIGZuKSB7XG5cdFx0cmV0dXJuIG1hcChzdHJpbmcuc3BsaXQocmVnZXhTZXBhcmF0b3JzKSwgZm4pLmpvaW4oJy4nKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBDcmVhdGVzIGFuIGFycmF5IGNvbnRhaW5pbmcgdGhlIG51bWVyaWMgY29kZSBwb2ludHMgb2YgZWFjaCBVbmljb2RlXG5cdCAqIGNoYXJhY3RlciBpbiB0aGUgc3RyaW5nLiBXaGlsZSBKYXZhU2NyaXB0IHVzZXMgVUNTLTIgaW50ZXJuYWxseSxcblx0ICogdGhpcyBmdW5jdGlvbiB3aWxsIGNvbnZlcnQgYSBwYWlyIG9mIHN1cnJvZ2F0ZSBoYWx2ZXMgKGVhY2ggb2Ygd2hpY2hcblx0ICogVUNTLTIgZXhwb3NlcyBhcyBzZXBhcmF0ZSBjaGFyYWN0ZXJzKSBpbnRvIGEgc2luZ2xlIGNvZGUgcG9pbnQsXG5cdCAqIG1hdGNoaW5nIFVURi0xNi5cblx0ICogQHNlZSBgcHVueWNvZGUudWNzMi5lbmNvZGVgXG5cdCAqIEBzZWUgPGh0dHA6Ly9tYXRoaWFzYnluZW5zLmJlL25vdGVzL2phdmFzY3JpcHQtZW5jb2Rpbmc+XG5cdCAqIEBtZW1iZXJPZiBwdW55Y29kZS51Y3MyXG5cdCAqIEBuYW1lIGRlY29kZVxuXHQgKiBAcGFyYW0ge1N0cmluZ30gc3RyaW5nIFRoZSBVbmljb2RlIGlucHV0IHN0cmluZyAoVUNTLTIpLlxuXHQgKiBAcmV0dXJucyB7QXJyYXl9IFRoZSBuZXcgYXJyYXkgb2YgY29kZSBwb2ludHMuXG5cdCAqL1xuXHRmdW5jdGlvbiB1Y3MyZGVjb2RlKHN0cmluZykge1xuXHRcdHZhciBvdXRwdXQgPSBbXSxcblx0XHQgICAgY291bnRlciA9IDAsXG5cdFx0ICAgIGxlbmd0aCA9IHN0cmluZy5sZW5ndGgsXG5cdFx0ICAgIHZhbHVlLFxuXHRcdCAgICBleHRyYTtcblx0XHR3aGlsZSAoY291bnRlciA8IGxlbmd0aCkge1xuXHRcdFx0dmFsdWUgPSBzdHJpbmcuY2hhckNvZGVBdChjb3VudGVyKyspO1xuXHRcdFx0aWYgKHZhbHVlID49IDB4RDgwMCAmJiB2YWx1ZSA8PSAweERCRkYgJiYgY291bnRlciA8IGxlbmd0aCkge1xuXHRcdFx0XHQvLyBoaWdoIHN1cnJvZ2F0ZSwgYW5kIHRoZXJlIGlzIGEgbmV4dCBjaGFyYWN0ZXJcblx0XHRcdFx0ZXh0cmEgPSBzdHJpbmcuY2hhckNvZGVBdChjb3VudGVyKyspO1xuXHRcdFx0XHRpZiAoKGV4dHJhICYgMHhGQzAwKSA9PSAweERDMDApIHsgLy8gbG93IHN1cnJvZ2F0ZVxuXHRcdFx0XHRcdG91dHB1dC5wdXNoKCgodmFsdWUgJiAweDNGRikgPDwgMTApICsgKGV4dHJhICYgMHgzRkYpICsgMHgxMDAwMCk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0Ly8gdW5tYXRjaGVkIHN1cnJvZ2F0ZTsgb25seSBhcHBlbmQgdGhpcyBjb2RlIHVuaXQsIGluIGNhc2UgdGhlIG5leHRcblx0XHRcdFx0XHQvLyBjb2RlIHVuaXQgaXMgdGhlIGhpZ2ggc3Vycm9nYXRlIG9mIGEgc3Vycm9nYXRlIHBhaXJcblx0XHRcdFx0XHRvdXRwdXQucHVzaCh2YWx1ZSk7XG5cdFx0XHRcdFx0Y291bnRlci0tO1xuXHRcdFx0XHR9XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRvdXRwdXQucHVzaCh2YWx1ZSk7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHJldHVybiBvdXRwdXQ7XG5cdH1cblxuXHQvKipcblx0ICogQ3JlYXRlcyBhIHN0cmluZyBiYXNlZCBvbiBhbiBhcnJheSBvZiBudW1lcmljIGNvZGUgcG9pbnRzLlxuXHQgKiBAc2VlIGBwdW55Y29kZS51Y3MyLmRlY29kZWBcblx0ICogQG1lbWJlck9mIHB1bnljb2RlLnVjczJcblx0ICogQG5hbWUgZW5jb2RlXG5cdCAqIEBwYXJhbSB7QXJyYXl9IGNvZGVQb2ludHMgVGhlIGFycmF5IG9mIG51bWVyaWMgY29kZSBwb2ludHMuXG5cdCAqIEByZXR1cm5zIHtTdHJpbmd9IFRoZSBuZXcgVW5pY29kZSBzdHJpbmcgKFVDUy0yKS5cblx0ICovXG5cdGZ1bmN0aW9uIHVjczJlbmNvZGUoYXJyYXkpIHtcblx0XHRyZXR1cm4gbWFwKGFycmF5LCBmdW5jdGlvbih2YWx1ZSkge1xuXHRcdFx0dmFyIG91dHB1dCA9ICcnO1xuXHRcdFx0aWYgKHZhbHVlID4gMHhGRkZGKSB7XG5cdFx0XHRcdHZhbHVlIC09IDB4MTAwMDA7XG5cdFx0XHRcdG91dHB1dCArPSBzdHJpbmdGcm9tQ2hhckNvZGUodmFsdWUgPj4+IDEwICYgMHgzRkYgfCAweEQ4MDApO1xuXHRcdFx0XHR2YWx1ZSA9IDB4REMwMCB8IHZhbHVlICYgMHgzRkY7XG5cdFx0XHR9XG5cdFx0XHRvdXRwdXQgKz0gc3RyaW5nRnJvbUNoYXJDb2RlKHZhbHVlKTtcblx0XHRcdHJldHVybiBvdXRwdXQ7XG5cdFx0fSkuam9pbignJyk7XG5cdH1cblxuXHQvKipcblx0ICogQ29udmVydHMgYSBiYXNpYyBjb2RlIHBvaW50IGludG8gYSBkaWdpdC9pbnRlZ2VyLlxuXHQgKiBAc2VlIGBkaWdpdFRvQmFzaWMoKWBcblx0ICogQHByaXZhdGVcblx0ICogQHBhcmFtIHtOdW1iZXJ9IGNvZGVQb2ludCBUaGUgYmFzaWMgbnVtZXJpYyBjb2RlIHBvaW50IHZhbHVlLlxuXHQgKiBAcmV0dXJucyB7TnVtYmVyfSBUaGUgbnVtZXJpYyB2YWx1ZSBvZiBhIGJhc2ljIGNvZGUgcG9pbnQgKGZvciB1c2UgaW5cblx0ICogcmVwcmVzZW50aW5nIGludGVnZXJzKSBpbiB0aGUgcmFuZ2UgYDBgIHRvIGBiYXNlIC0gMWAsIG9yIGBiYXNlYCBpZlxuXHQgKiB0aGUgY29kZSBwb2ludCBkb2VzIG5vdCByZXByZXNlbnQgYSB2YWx1ZS5cblx0ICovXG5cdGZ1bmN0aW9uIGJhc2ljVG9EaWdpdChjb2RlUG9pbnQpIHtcblx0XHRpZiAoY29kZVBvaW50IC0gNDggPCAxMCkge1xuXHRcdFx0cmV0dXJuIGNvZGVQb2ludCAtIDIyO1xuXHRcdH1cblx0XHRpZiAoY29kZVBvaW50IC0gNjUgPCAyNikge1xuXHRcdFx0cmV0dXJuIGNvZGVQb2ludCAtIDY1O1xuXHRcdH1cblx0XHRpZiAoY29kZVBvaW50IC0gOTcgPCAyNikge1xuXHRcdFx0cmV0dXJuIGNvZGVQb2ludCAtIDk3O1xuXHRcdH1cblx0XHRyZXR1cm4gYmFzZTtcblx0fVxuXG5cdC8qKlxuXHQgKiBDb252ZXJ0cyBhIGRpZ2l0L2ludGVnZXIgaW50byBhIGJhc2ljIGNvZGUgcG9pbnQuXG5cdCAqIEBzZWUgYGJhc2ljVG9EaWdpdCgpYFxuXHQgKiBAcHJpdmF0ZVxuXHQgKiBAcGFyYW0ge051bWJlcn0gZGlnaXQgVGhlIG51bWVyaWMgdmFsdWUgb2YgYSBiYXNpYyBjb2RlIHBvaW50LlxuXHQgKiBAcmV0dXJucyB7TnVtYmVyfSBUaGUgYmFzaWMgY29kZSBwb2ludCB3aG9zZSB2YWx1ZSAod2hlbiB1c2VkIGZvclxuXHQgKiByZXByZXNlbnRpbmcgaW50ZWdlcnMpIGlzIGBkaWdpdGAsIHdoaWNoIG5lZWRzIHRvIGJlIGluIHRoZSByYW5nZVxuXHQgKiBgMGAgdG8gYGJhc2UgLSAxYC4gSWYgYGZsYWdgIGlzIG5vbi16ZXJvLCB0aGUgdXBwZXJjYXNlIGZvcm0gaXNcblx0ICogdXNlZDsgZWxzZSwgdGhlIGxvd2VyY2FzZSBmb3JtIGlzIHVzZWQuIFRoZSBiZWhhdmlvciBpcyB1bmRlZmluZWRcblx0ICogaWYgYGZsYWdgIGlzIG5vbi16ZXJvIGFuZCBgZGlnaXRgIGhhcyBubyB1cHBlcmNhc2UgZm9ybS5cblx0ICovXG5cdGZ1bmN0aW9uIGRpZ2l0VG9CYXNpYyhkaWdpdCwgZmxhZykge1xuXHRcdC8vICAwLi4yNSBtYXAgdG8gQVNDSUkgYS4ueiBvciBBLi5aXG5cdFx0Ly8gMjYuLjM1IG1hcCB0byBBU0NJSSAwLi45XG5cdFx0cmV0dXJuIGRpZ2l0ICsgMjIgKyA3NSAqIChkaWdpdCA8IDI2KSAtICgoZmxhZyAhPSAwKSA8PCA1KTtcblx0fVxuXG5cdC8qKlxuXHQgKiBCaWFzIGFkYXB0YXRpb24gZnVuY3Rpb24gYXMgcGVyIHNlY3Rpb24gMy40IG9mIFJGQyAzNDkyLlxuXHQgKiBodHRwOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmMzNDkyI3NlY3Rpb24tMy40XG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuXHRmdW5jdGlvbiBhZGFwdChkZWx0YSwgbnVtUG9pbnRzLCBmaXJzdFRpbWUpIHtcblx0XHR2YXIgayA9IDA7XG5cdFx0ZGVsdGEgPSBmaXJzdFRpbWUgPyBmbG9vcihkZWx0YSAvIGRhbXApIDogZGVsdGEgPj4gMTtcblx0XHRkZWx0YSArPSBmbG9vcihkZWx0YSAvIG51bVBvaW50cyk7XG5cdFx0Zm9yICgvKiBubyBpbml0aWFsaXphdGlvbiAqLzsgZGVsdGEgPiBiYXNlTWludXNUTWluICogdE1heCA+PiAxOyBrICs9IGJhc2UpIHtcblx0XHRcdGRlbHRhID0gZmxvb3IoZGVsdGEgLyBiYXNlTWludXNUTWluKTtcblx0XHR9XG5cdFx0cmV0dXJuIGZsb29yKGsgKyAoYmFzZU1pbnVzVE1pbiArIDEpICogZGVsdGEgLyAoZGVsdGEgKyBza2V3KSk7XG5cdH1cblxuXHQvKipcblx0ICogQ29udmVydHMgYSBQdW55Y29kZSBzdHJpbmcgb2YgQVNDSUktb25seSBzeW1ib2xzIHRvIGEgc3RyaW5nIG9mIFVuaWNvZGVcblx0ICogc3ltYm9scy5cblx0ICogQG1lbWJlck9mIHB1bnljb2RlXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBpbnB1dCBUaGUgUHVueWNvZGUgc3RyaW5nIG9mIEFTQ0lJLW9ubHkgc3ltYm9scy5cblx0ICogQHJldHVybnMge1N0cmluZ30gVGhlIHJlc3VsdGluZyBzdHJpbmcgb2YgVW5pY29kZSBzeW1ib2xzLlxuXHQgKi9cblx0ZnVuY3Rpb24gZGVjb2RlKGlucHV0KSB7XG5cdFx0Ly8gRG9uJ3QgdXNlIFVDUy0yXG5cdFx0dmFyIG91dHB1dCA9IFtdLFxuXHRcdCAgICBpbnB1dExlbmd0aCA9IGlucHV0Lmxlbmd0aCxcblx0XHQgICAgb3V0LFxuXHRcdCAgICBpID0gMCxcblx0XHQgICAgbiA9IGluaXRpYWxOLFxuXHRcdCAgICBiaWFzID0gaW5pdGlhbEJpYXMsXG5cdFx0ICAgIGJhc2ljLFxuXHRcdCAgICBqLFxuXHRcdCAgICBpbmRleCxcblx0XHQgICAgb2xkaSxcblx0XHQgICAgdyxcblx0XHQgICAgayxcblx0XHQgICAgZGlnaXQsXG5cdFx0ICAgIHQsXG5cdFx0ICAgIC8qKiBDYWNoZWQgY2FsY3VsYXRpb24gcmVzdWx0cyAqL1xuXHRcdCAgICBiYXNlTWludXNUO1xuXG5cdFx0Ly8gSGFuZGxlIHRoZSBiYXNpYyBjb2RlIHBvaW50czogbGV0IGBiYXNpY2AgYmUgdGhlIG51bWJlciBvZiBpbnB1dCBjb2RlXG5cdFx0Ly8gcG9pbnRzIGJlZm9yZSB0aGUgbGFzdCBkZWxpbWl0ZXIsIG9yIGAwYCBpZiB0aGVyZSBpcyBub25lLCB0aGVuIGNvcHlcblx0XHQvLyB0aGUgZmlyc3QgYmFzaWMgY29kZSBwb2ludHMgdG8gdGhlIG91dHB1dC5cblxuXHRcdGJhc2ljID0gaW5wdXQubGFzdEluZGV4T2YoZGVsaW1pdGVyKTtcblx0XHRpZiAoYmFzaWMgPCAwKSB7XG5cdFx0XHRiYXNpYyA9IDA7XG5cdFx0fVxuXG5cdFx0Zm9yIChqID0gMDsgaiA8IGJhc2ljOyArK2opIHtcblx0XHRcdC8vIGlmIGl0J3Mgbm90IGEgYmFzaWMgY29kZSBwb2ludFxuXHRcdFx0aWYgKGlucHV0LmNoYXJDb2RlQXQoaikgPj0gMHg4MCkge1xuXHRcdFx0XHRlcnJvcignbm90LWJhc2ljJyk7XG5cdFx0XHR9XG5cdFx0XHRvdXRwdXQucHVzaChpbnB1dC5jaGFyQ29kZUF0KGopKTtcblx0XHR9XG5cblx0XHQvLyBNYWluIGRlY29kaW5nIGxvb3A6IHN0YXJ0IGp1c3QgYWZ0ZXIgdGhlIGxhc3QgZGVsaW1pdGVyIGlmIGFueSBiYXNpYyBjb2RlXG5cdFx0Ly8gcG9pbnRzIHdlcmUgY29waWVkOyBzdGFydCBhdCB0aGUgYmVnaW5uaW5nIG90aGVyd2lzZS5cblxuXHRcdGZvciAoaW5kZXggPSBiYXNpYyA+IDAgPyBiYXNpYyArIDEgOiAwOyBpbmRleCA8IGlucHV0TGVuZ3RoOyAvKiBubyBmaW5hbCBleHByZXNzaW9uICovKSB7XG5cblx0XHRcdC8vIGBpbmRleGAgaXMgdGhlIGluZGV4IG9mIHRoZSBuZXh0IGNoYXJhY3RlciB0byBiZSBjb25zdW1lZC5cblx0XHRcdC8vIERlY29kZSBhIGdlbmVyYWxpemVkIHZhcmlhYmxlLWxlbmd0aCBpbnRlZ2VyIGludG8gYGRlbHRhYCxcblx0XHRcdC8vIHdoaWNoIGdldHMgYWRkZWQgdG8gYGlgLiBUaGUgb3ZlcmZsb3cgY2hlY2tpbmcgaXMgZWFzaWVyXG5cdFx0XHQvLyBpZiB3ZSBpbmNyZWFzZSBgaWAgYXMgd2UgZ28sIHRoZW4gc3VidHJhY3Qgb2ZmIGl0cyBzdGFydGluZ1xuXHRcdFx0Ly8gdmFsdWUgYXQgdGhlIGVuZCB0byBvYnRhaW4gYGRlbHRhYC5cblx0XHRcdGZvciAob2xkaSA9IGksIHcgPSAxLCBrID0gYmFzZTsgLyogbm8gY29uZGl0aW9uICovOyBrICs9IGJhc2UpIHtcblxuXHRcdFx0XHRpZiAoaW5kZXggPj0gaW5wdXRMZW5ndGgpIHtcblx0XHRcdFx0XHRlcnJvcignaW52YWxpZC1pbnB1dCcpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0ZGlnaXQgPSBiYXNpY1RvRGlnaXQoaW5wdXQuY2hhckNvZGVBdChpbmRleCsrKSk7XG5cblx0XHRcdFx0aWYgKGRpZ2l0ID49IGJhc2UgfHwgZGlnaXQgPiBmbG9vcigobWF4SW50IC0gaSkgLyB3KSkge1xuXHRcdFx0XHRcdGVycm9yKCdvdmVyZmxvdycpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0aSArPSBkaWdpdCAqIHc7XG5cdFx0XHRcdHQgPSBrIDw9IGJpYXMgPyB0TWluIDogKGsgPj0gYmlhcyArIHRNYXggPyB0TWF4IDogayAtIGJpYXMpO1xuXG5cdFx0XHRcdGlmIChkaWdpdCA8IHQpIHtcblx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGJhc2VNaW51c1QgPSBiYXNlIC0gdDtcblx0XHRcdFx0aWYgKHcgPiBmbG9vcihtYXhJbnQgLyBiYXNlTWludXNUKSkge1xuXHRcdFx0XHRcdGVycm9yKCdvdmVyZmxvdycpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0dyAqPSBiYXNlTWludXNUO1xuXG5cdFx0XHR9XG5cblx0XHRcdG91dCA9IG91dHB1dC5sZW5ndGggKyAxO1xuXHRcdFx0YmlhcyA9IGFkYXB0KGkgLSBvbGRpLCBvdXQsIG9sZGkgPT0gMCk7XG5cblx0XHRcdC8vIGBpYCB3YXMgc3VwcG9zZWQgdG8gd3JhcCBhcm91bmQgZnJvbSBgb3V0YCB0byBgMGAsXG5cdFx0XHQvLyBpbmNyZW1lbnRpbmcgYG5gIGVhY2ggdGltZSwgc28gd2UnbGwgZml4IHRoYXQgbm93OlxuXHRcdFx0aWYgKGZsb29yKGkgLyBvdXQpID4gbWF4SW50IC0gbikge1xuXHRcdFx0XHRlcnJvcignb3ZlcmZsb3cnKTtcblx0XHRcdH1cblxuXHRcdFx0biArPSBmbG9vcihpIC8gb3V0KTtcblx0XHRcdGkgJT0gb3V0O1xuXG5cdFx0XHQvLyBJbnNlcnQgYG5gIGF0IHBvc2l0aW9uIGBpYCBvZiB0aGUgb3V0cHV0XG5cdFx0XHRvdXRwdXQuc3BsaWNlKGkrKywgMCwgbik7XG5cblx0XHR9XG5cblx0XHRyZXR1cm4gdWNzMmVuY29kZShvdXRwdXQpO1xuXHR9XG5cblx0LyoqXG5cdCAqIENvbnZlcnRzIGEgc3RyaW5nIG9mIFVuaWNvZGUgc3ltYm9scyB0byBhIFB1bnljb2RlIHN0cmluZyBvZiBBU0NJSS1vbmx5XG5cdCAqIHN5bWJvbHMuXG5cdCAqIEBtZW1iZXJPZiBwdW55Y29kZVxuXHQgKiBAcGFyYW0ge1N0cmluZ30gaW5wdXQgVGhlIHN0cmluZyBvZiBVbmljb2RlIHN5bWJvbHMuXG5cdCAqIEByZXR1cm5zIHtTdHJpbmd9IFRoZSByZXN1bHRpbmcgUHVueWNvZGUgc3RyaW5nIG9mIEFTQ0lJLW9ubHkgc3ltYm9scy5cblx0ICovXG5cdGZ1bmN0aW9uIGVuY29kZShpbnB1dCkge1xuXHRcdHZhciBuLFxuXHRcdCAgICBkZWx0YSxcblx0XHQgICAgaGFuZGxlZENQQ291bnQsXG5cdFx0ICAgIGJhc2ljTGVuZ3RoLFxuXHRcdCAgICBiaWFzLFxuXHRcdCAgICBqLFxuXHRcdCAgICBtLFxuXHRcdCAgICBxLFxuXHRcdCAgICBrLFxuXHRcdCAgICB0LFxuXHRcdCAgICBjdXJyZW50VmFsdWUsXG5cdFx0ICAgIG91dHB1dCA9IFtdLFxuXHRcdCAgICAvKiogYGlucHV0TGVuZ3RoYCB3aWxsIGhvbGQgdGhlIG51bWJlciBvZiBjb2RlIHBvaW50cyBpbiBgaW5wdXRgLiAqL1xuXHRcdCAgICBpbnB1dExlbmd0aCxcblx0XHQgICAgLyoqIENhY2hlZCBjYWxjdWxhdGlvbiByZXN1bHRzICovXG5cdFx0ICAgIGhhbmRsZWRDUENvdW50UGx1c09uZSxcblx0XHQgICAgYmFzZU1pbnVzVCxcblx0XHQgICAgcU1pbnVzVDtcblxuXHRcdC8vIENvbnZlcnQgdGhlIGlucHV0IGluIFVDUy0yIHRvIFVuaWNvZGVcblx0XHRpbnB1dCA9IHVjczJkZWNvZGUoaW5wdXQpO1xuXG5cdFx0Ly8gQ2FjaGUgdGhlIGxlbmd0aFxuXHRcdGlucHV0TGVuZ3RoID0gaW5wdXQubGVuZ3RoO1xuXG5cdFx0Ly8gSW5pdGlhbGl6ZSB0aGUgc3RhdGVcblx0XHRuID0gaW5pdGlhbE47XG5cdFx0ZGVsdGEgPSAwO1xuXHRcdGJpYXMgPSBpbml0aWFsQmlhcztcblxuXHRcdC8vIEhhbmRsZSB0aGUgYmFzaWMgY29kZSBwb2ludHNcblx0XHRmb3IgKGogPSAwOyBqIDwgaW5wdXRMZW5ndGg7ICsraikge1xuXHRcdFx0Y3VycmVudFZhbHVlID0gaW5wdXRbal07XG5cdFx0XHRpZiAoY3VycmVudFZhbHVlIDwgMHg4MCkge1xuXHRcdFx0XHRvdXRwdXQucHVzaChzdHJpbmdGcm9tQ2hhckNvZGUoY3VycmVudFZhbHVlKSk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0aGFuZGxlZENQQ291bnQgPSBiYXNpY0xlbmd0aCA9IG91dHB1dC5sZW5ndGg7XG5cblx0XHQvLyBgaGFuZGxlZENQQ291bnRgIGlzIHRoZSBudW1iZXIgb2YgY29kZSBwb2ludHMgdGhhdCBoYXZlIGJlZW4gaGFuZGxlZDtcblx0XHQvLyBgYmFzaWNMZW5ndGhgIGlzIHRoZSBudW1iZXIgb2YgYmFzaWMgY29kZSBwb2ludHMuXG5cblx0XHQvLyBGaW5pc2ggdGhlIGJhc2ljIHN0cmluZyAtIGlmIGl0IGlzIG5vdCBlbXB0eSAtIHdpdGggYSBkZWxpbWl0ZXJcblx0XHRpZiAoYmFzaWNMZW5ndGgpIHtcblx0XHRcdG91dHB1dC5wdXNoKGRlbGltaXRlcik7XG5cdFx0fVxuXG5cdFx0Ly8gTWFpbiBlbmNvZGluZyBsb29wOlxuXHRcdHdoaWxlIChoYW5kbGVkQ1BDb3VudCA8IGlucHV0TGVuZ3RoKSB7XG5cblx0XHRcdC8vIEFsbCBub24tYmFzaWMgY29kZSBwb2ludHMgPCBuIGhhdmUgYmVlbiBoYW5kbGVkIGFscmVhZHkuIEZpbmQgdGhlIG5leHRcblx0XHRcdC8vIGxhcmdlciBvbmU6XG5cdFx0XHRmb3IgKG0gPSBtYXhJbnQsIGogPSAwOyBqIDwgaW5wdXRMZW5ndGg7ICsraikge1xuXHRcdFx0XHRjdXJyZW50VmFsdWUgPSBpbnB1dFtqXTtcblx0XHRcdFx0aWYgKGN1cnJlbnRWYWx1ZSA+PSBuICYmIGN1cnJlbnRWYWx1ZSA8IG0pIHtcblx0XHRcdFx0XHRtID0gY3VycmVudFZhbHVlO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdC8vIEluY3JlYXNlIGBkZWx0YWAgZW5vdWdoIHRvIGFkdmFuY2UgdGhlIGRlY29kZXIncyA8bixpPiBzdGF0ZSB0byA8bSwwPixcblx0XHRcdC8vIGJ1dCBndWFyZCBhZ2FpbnN0IG92ZXJmbG93XG5cdFx0XHRoYW5kbGVkQ1BDb3VudFBsdXNPbmUgPSBoYW5kbGVkQ1BDb3VudCArIDE7XG5cdFx0XHRpZiAobSAtIG4gPiBmbG9vcigobWF4SW50IC0gZGVsdGEpIC8gaGFuZGxlZENQQ291bnRQbHVzT25lKSkge1xuXHRcdFx0XHRlcnJvcignb3ZlcmZsb3cnKTtcblx0XHRcdH1cblxuXHRcdFx0ZGVsdGEgKz0gKG0gLSBuKSAqIGhhbmRsZWRDUENvdW50UGx1c09uZTtcblx0XHRcdG4gPSBtO1xuXG5cdFx0XHRmb3IgKGogPSAwOyBqIDwgaW5wdXRMZW5ndGg7ICsraikge1xuXHRcdFx0XHRjdXJyZW50VmFsdWUgPSBpbnB1dFtqXTtcblxuXHRcdFx0XHRpZiAoY3VycmVudFZhbHVlIDwgbiAmJiArK2RlbHRhID4gbWF4SW50KSB7XG5cdFx0XHRcdFx0ZXJyb3IoJ292ZXJmbG93Jyk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpZiAoY3VycmVudFZhbHVlID09IG4pIHtcblx0XHRcdFx0XHQvLyBSZXByZXNlbnQgZGVsdGEgYXMgYSBnZW5lcmFsaXplZCB2YXJpYWJsZS1sZW5ndGggaW50ZWdlclxuXHRcdFx0XHRcdGZvciAocSA9IGRlbHRhLCBrID0gYmFzZTsgLyogbm8gY29uZGl0aW9uICovOyBrICs9IGJhc2UpIHtcblx0XHRcdFx0XHRcdHQgPSBrIDw9IGJpYXMgPyB0TWluIDogKGsgPj0gYmlhcyArIHRNYXggPyB0TWF4IDogayAtIGJpYXMpO1xuXHRcdFx0XHRcdFx0aWYgKHEgPCB0KSB7XG5cdFx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0cU1pbnVzVCA9IHEgLSB0O1xuXHRcdFx0XHRcdFx0YmFzZU1pbnVzVCA9IGJhc2UgLSB0O1xuXHRcdFx0XHRcdFx0b3V0cHV0LnB1c2goXG5cdFx0XHRcdFx0XHRcdHN0cmluZ0Zyb21DaGFyQ29kZShkaWdpdFRvQmFzaWModCArIHFNaW51c1QgJSBiYXNlTWludXNULCAwKSlcblx0XHRcdFx0XHRcdCk7XG5cdFx0XHRcdFx0XHRxID0gZmxvb3IocU1pbnVzVCAvIGJhc2VNaW51c1QpO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdG91dHB1dC5wdXNoKHN0cmluZ0Zyb21DaGFyQ29kZShkaWdpdFRvQmFzaWMocSwgMCkpKTtcblx0XHRcdFx0XHRiaWFzID0gYWRhcHQoZGVsdGEsIGhhbmRsZWRDUENvdW50UGx1c09uZSwgaGFuZGxlZENQQ291bnQgPT0gYmFzaWNMZW5ndGgpO1xuXHRcdFx0XHRcdGRlbHRhID0gMDtcblx0XHRcdFx0XHQrK2hhbmRsZWRDUENvdW50O1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdCsrZGVsdGE7XG5cdFx0XHQrK247XG5cblx0XHR9XG5cdFx0cmV0dXJuIG91dHB1dC5qb2luKCcnKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBDb252ZXJ0cyBhIFB1bnljb2RlIHN0cmluZyByZXByZXNlbnRpbmcgYSBkb21haW4gbmFtZSB0byBVbmljb2RlLiBPbmx5IHRoZVxuXHQgKiBQdW55Y29kZWQgcGFydHMgb2YgdGhlIGRvbWFpbiBuYW1lIHdpbGwgYmUgY29udmVydGVkLCBpLmUuIGl0IGRvZXNuJ3Rcblx0ICogbWF0dGVyIGlmIHlvdSBjYWxsIGl0IG9uIGEgc3RyaW5nIHRoYXQgaGFzIGFscmVhZHkgYmVlbiBjb252ZXJ0ZWQgdG9cblx0ICogVW5pY29kZS5cblx0ICogQG1lbWJlck9mIHB1bnljb2RlXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBkb21haW4gVGhlIFB1bnljb2RlIGRvbWFpbiBuYW1lIHRvIGNvbnZlcnQgdG8gVW5pY29kZS5cblx0ICogQHJldHVybnMge1N0cmluZ30gVGhlIFVuaWNvZGUgcmVwcmVzZW50YXRpb24gb2YgdGhlIGdpdmVuIFB1bnljb2RlXG5cdCAqIHN0cmluZy5cblx0ICovXG5cdGZ1bmN0aW9uIHRvVW5pY29kZShkb21haW4pIHtcblx0XHRyZXR1cm4gbWFwRG9tYWluKGRvbWFpbiwgZnVuY3Rpb24oc3RyaW5nKSB7XG5cdFx0XHRyZXR1cm4gcmVnZXhQdW55Y29kZS50ZXN0KHN0cmluZylcblx0XHRcdFx0PyBkZWNvZGUoc3RyaW5nLnNsaWNlKDQpLnRvTG93ZXJDYXNlKCkpXG5cdFx0XHRcdDogc3RyaW5nO1xuXHRcdH0pO1xuXHR9XG5cblx0LyoqXG5cdCAqIENvbnZlcnRzIGEgVW5pY29kZSBzdHJpbmcgcmVwcmVzZW50aW5nIGEgZG9tYWluIG5hbWUgdG8gUHVueWNvZGUuIE9ubHkgdGhlXG5cdCAqIG5vbi1BU0NJSSBwYXJ0cyBvZiB0aGUgZG9tYWluIG5hbWUgd2lsbCBiZSBjb252ZXJ0ZWQsIGkuZS4gaXQgZG9lc24ndFxuXHQgKiBtYXR0ZXIgaWYgeW91IGNhbGwgaXQgd2l0aCBhIGRvbWFpbiB0aGF0J3MgYWxyZWFkeSBpbiBBU0NJSS5cblx0ICogQG1lbWJlck9mIHB1bnljb2RlXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBkb21haW4gVGhlIGRvbWFpbiBuYW1lIHRvIGNvbnZlcnQsIGFzIGEgVW5pY29kZSBzdHJpbmcuXG5cdCAqIEByZXR1cm5zIHtTdHJpbmd9IFRoZSBQdW55Y29kZSByZXByZXNlbnRhdGlvbiBvZiB0aGUgZ2l2ZW4gZG9tYWluIG5hbWUuXG5cdCAqL1xuXHRmdW5jdGlvbiB0b0FTQ0lJKGRvbWFpbikge1xuXHRcdHJldHVybiBtYXBEb21haW4oZG9tYWluLCBmdW5jdGlvbihzdHJpbmcpIHtcblx0XHRcdHJldHVybiByZWdleE5vbkFTQ0lJLnRlc3Qoc3RyaW5nKVxuXHRcdFx0XHQ/ICd4bi0tJyArIGVuY29kZShzdHJpbmcpXG5cdFx0XHRcdDogc3RyaW5nO1xuXHRcdH0pO1xuXHR9XG5cblx0LyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cblx0LyoqIERlZmluZSB0aGUgcHVibGljIEFQSSAqL1xuXHRwdW55Y29kZSA9IHtcblx0XHQvKipcblx0XHQgKiBBIHN0cmluZyByZXByZXNlbnRpbmcgdGhlIGN1cnJlbnQgUHVueWNvZGUuanMgdmVyc2lvbiBudW1iZXIuXG5cdFx0ICogQG1lbWJlck9mIHB1bnljb2RlXG5cdFx0ICogQHR5cGUgU3RyaW5nXG5cdFx0ICovXG5cdFx0J3ZlcnNpb24nOiAnMS4yLjQnLFxuXHRcdC8qKlxuXHRcdCAqIEFuIG9iamVjdCBvZiBtZXRob2RzIHRvIGNvbnZlcnQgZnJvbSBKYXZhU2NyaXB0J3MgaW50ZXJuYWwgY2hhcmFjdGVyXG5cdFx0ICogcmVwcmVzZW50YXRpb24gKFVDUy0yKSB0byBVbmljb2RlIGNvZGUgcG9pbnRzLCBhbmQgYmFjay5cblx0XHQgKiBAc2VlIDxodHRwOi8vbWF0aGlhc2J5bmVucy5iZS9ub3Rlcy9qYXZhc2NyaXB0LWVuY29kaW5nPlxuXHRcdCAqIEBtZW1iZXJPZiBwdW55Y29kZVxuXHRcdCAqIEB0eXBlIE9iamVjdFxuXHRcdCAqL1xuXHRcdCd1Y3MyJzoge1xuXHRcdFx0J2RlY29kZSc6IHVjczJkZWNvZGUsXG5cdFx0XHQnZW5jb2RlJzogdWNzMmVuY29kZVxuXHRcdH0sXG5cdFx0J2RlY29kZSc6IGRlY29kZSxcblx0XHQnZW5jb2RlJzogZW5jb2RlLFxuXHRcdCd0b0FTQ0lJJzogdG9BU0NJSSxcblx0XHQndG9Vbmljb2RlJzogdG9Vbmljb2RlXG5cdH07XG5cblx0LyoqIEV4cG9zZSBgcHVueWNvZGVgICovXG5cdC8vIFNvbWUgQU1EIGJ1aWxkIG9wdGltaXplcnMsIGxpa2Ugci5qcywgY2hlY2sgZm9yIHNwZWNpZmljIGNvbmRpdGlvbiBwYXR0ZXJuc1xuXHQvLyBsaWtlIHRoZSBmb2xsb3dpbmc6XG5cdGlmIChcblx0XHR0eXBlb2YgZGVmaW5lID09ICdmdW5jdGlvbicgJiZcblx0XHR0eXBlb2YgZGVmaW5lLmFtZCA9PSAnb2JqZWN0JyAmJlxuXHRcdGRlZmluZS5hbWRcblx0KSB7XG5cdFx0ZGVmaW5lKCdwdW55Y29kZScsIGZ1bmN0aW9uKCkge1xuXHRcdFx0cmV0dXJuIHB1bnljb2RlO1xuXHRcdH0pO1xuXHR9IGVsc2UgaWYgKGZyZWVFeHBvcnRzICYmICFmcmVlRXhwb3J0cy5ub2RlVHlwZSkge1xuXHRcdGlmIChmcmVlTW9kdWxlKSB7IC8vIGluIE5vZGUuanMgb3IgUmluZ29KUyB2MC44LjArXG5cdFx0XHRmcmVlTW9kdWxlLmV4cG9ydHMgPSBwdW55Y29kZTtcblx0XHR9IGVsc2UgeyAvLyBpbiBOYXJ3aGFsIG9yIFJpbmdvSlMgdjAuNy4wLVxuXHRcdFx0Zm9yIChrZXkgaW4gcHVueWNvZGUpIHtcblx0XHRcdFx0cHVueWNvZGUuaGFzT3duUHJvcGVydHkoa2V5KSAmJiAoZnJlZUV4cG9ydHNba2V5XSA9IHB1bnljb2RlW2tleV0pO1xuXHRcdFx0fVxuXHRcdH1cblx0fSBlbHNlIHsgLy8gaW4gUmhpbm8gb3IgYSB3ZWIgYnJvd3NlclxuXHRcdHJvb3QucHVueWNvZGUgPSBwdW55Y29kZTtcblx0fVxuXG59KHRoaXMpKTtcblxufSkuY2FsbCh0aGlzLHR5cGVvZiBzZWxmICE9PSBcInVuZGVmaW5lZFwiID8gc2VsZiA6IHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3cgOiB7fSkiLCIvLyBDb3B5cmlnaHQgSm95ZW50LCBJbmMuIGFuZCBvdGhlciBOb2RlIGNvbnRyaWJ1dG9ycy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxuLy8gY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxuLy8gXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXG4vLyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXG4vLyBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0XG4vLyBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGVcbi8vIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkXG4vLyBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTXG4vLyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4vLyBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOXG4vLyBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSxcbi8vIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUlxuLy8gT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRVxuLy8gVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cblxuJ3VzZSBzdHJpY3QnO1xuXG4vLyBJZiBvYmouaGFzT3duUHJvcGVydHkgaGFzIGJlZW4gb3ZlcnJpZGRlbiwgdGhlbiBjYWxsaW5nXG4vLyBvYmouaGFzT3duUHJvcGVydHkocHJvcCkgd2lsbCBicmVhay5cbi8vIFNlZTogaHR0cHM6Ly9naXRodWIuY29tL2pveWVudC9ub2RlL2lzc3Vlcy8xNzA3XG5mdW5jdGlvbiBoYXNPd25Qcm9wZXJ0eShvYmosIHByb3ApIHtcbiAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIHByb3ApO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKHFzLCBzZXAsIGVxLCBvcHRpb25zKSB7XG4gIHNlcCA9IHNlcCB8fCAnJic7XG4gIGVxID0gZXEgfHwgJz0nO1xuICB2YXIgb2JqID0ge307XG5cbiAgaWYgKHR5cGVvZiBxcyAhPT0gJ3N0cmluZycgfHwgcXMubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIG9iajtcbiAgfVxuXG4gIHZhciByZWdleHAgPSAvXFwrL2c7XG4gIHFzID0gcXMuc3BsaXQoc2VwKTtcblxuICB2YXIgbWF4S2V5cyA9IDEwMDA7XG4gIGlmIChvcHRpb25zICYmIHR5cGVvZiBvcHRpb25zLm1heEtleXMgPT09ICdudW1iZXInKSB7XG4gICAgbWF4S2V5cyA9IG9wdGlvbnMubWF4S2V5cztcbiAgfVxuXG4gIHZhciBsZW4gPSBxcy5sZW5ndGg7XG4gIC8vIG1heEtleXMgPD0gMCBtZWFucyB0aGF0IHdlIHNob3VsZCBub3QgbGltaXQga2V5cyBjb3VudFxuICBpZiAobWF4S2V5cyA+IDAgJiYgbGVuID4gbWF4S2V5cykge1xuICAgIGxlbiA9IG1heEtleXM7XG4gIH1cblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgKytpKSB7XG4gICAgdmFyIHggPSBxc1tpXS5yZXBsYWNlKHJlZ2V4cCwgJyUyMCcpLFxuICAgICAgICBpZHggPSB4LmluZGV4T2YoZXEpLFxuICAgICAgICBrc3RyLCB2c3RyLCBrLCB2O1xuXG4gICAgaWYgKGlkeCA+PSAwKSB7XG4gICAgICBrc3RyID0geC5zdWJzdHIoMCwgaWR4KTtcbiAgICAgIHZzdHIgPSB4LnN1YnN0cihpZHggKyAxKTtcbiAgICB9IGVsc2Uge1xuICAgICAga3N0ciA9IHg7XG4gICAgICB2c3RyID0gJyc7XG4gICAgfVxuXG4gICAgayA9IGRlY29kZVVSSUNvbXBvbmVudChrc3RyKTtcbiAgICB2ID0gZGVjb2RlVVJJQ29tcG9uZW50KHZzdHIpO1xuXG4gICAgaWYgKCFoYXNPd25Qcm9wZXJ0eShvYmosIGspKSB7XG4gICAgICBvYmpba10gPSB2O1xuICAgIH0gZWxzZSBpZiAoaXNBcnJheShvYmpba10pKSB7XG4gICAgICBvYmpba10ucHVzaCh2KTtcbiAgICB9IGVsc2Uge1xuICAgICAgb2JqW2tdID0gW29ialtrXSwgdl07XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG9iajtcbn07XG5cbnZhciBpc0FycmF5ID0gQXJyYXkuaXNBcnJheSB8fCBmdW5jdGlvbiAoeHMpIHtcbiAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh4cykgPT09ICdbb2JqZWN0IEFycmF5XSc7XG59O1xuIiwiLy8gQ29weXJpZ2h0IEpveWVudCwgSW5jLiBhbmQgb3RoZXIgTm9kZSBjb250cmlidXRvcnMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGFcbi8vIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcbi8vIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xuLy8gd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxuLy8gZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdFxuLy8gcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlXG4vLyBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZFxuLy8gaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTU1xuLy8gT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuLy8gTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTlxuLy8gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sXG4vLyBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1Jcbi8vIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEVcbi8vIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIHN0cmluZ2lmeVByaW1pdGl2ZSA9IGZ1bmN0aW9uKHYpIHtcbiAgc3dpdGNoICh0eXBlb2Ygdikge1xuICAgIGNhc2UgJ3N0cmluZyc6XG4gICAgICByZXR1cm4gdjtcblxuICAgIGNhc2UgJ2Jvb2xlYW4nOlxuICAgICAgcmV0dXJuIHYgPyAndHJ1ZScgOiAnZmFsc2UnO1xuXG4gICAgY2FzZSAnbnVtYmVyJzpcbiAgICAgIHJldHVybiBpc0Zpbml0ZSh2KSA/IHYgOiAnJztcblxuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gJyc7XG4gIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24ob2JqLCBzZXAsIGVxLCBuYW1lKSB7XG4gIHNlcCA9IHNlcCB8fCAnJic7XG4gIGVxID0gZXEgfHwgJz0nO1xuICBpZiAob2JqID09PSBudWxsKSB7XG4gICAgb2JqID0gdW5kZWZpbmVkO1xuICB9XG5cbiAgaWYgKHR5cGVvZiBvYmogPT09ICdvYmplY3QnKSB7XG4gICAgcmV0dXJuIG1hcChvYmplY3RLZXlzKG9iaiksIGZ1bmN0aW9uKGspIHtcbiAgICAgIHZhciBrcyA9IGVuY29kZVVSSUNvbXBvbmVudChzdHJpbmdpZnlQcmltaXRpdmUoaykpICsgZXE7XG4gICAgICBpZiAoaXNBcnJheShvYmpba10pKSB7XG4gICAgICAgIHJldHVybiBvYmpba10ubWFwKGZ1bmN0aW9uKHYpIHtcbiAgICAgICAgICByZXR1cm4ga3MgKyBlbmNvZGVVUklDb21wb25lbnQoc3RyaW5naWZ5UHJpbWl0aXZlKHYpKTtcbiAgICAgICAgfSkuam9pbihzZXApO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGtzICsgZW5jb2RlVVJJQ29tcG9uZW50KHN0cmluZ2lmeVByaW1pdGl2ZShvYmpba10pKTtcbiAgICAgIH1cbiAgICB9KS5qb2luKHNlcCk7XG5cbiAgfVxuXG4gIGlmICghbmFtZSkgcmV0dXJuICcnO1xuICByZXR1cm4gZW5jb2RlVVJJQ29tcG9uZW50KHN0cmluZ2lmeVByaW1pdGl2ZShuYW1lKSkgKyBlcSArXG4gICAgICAgICBlbmNvZGVVUklDb21wb25lbnQoc3RyaW5naWZ5UHJpbWl0aXZlKG9iaikpO1xufTtcblxudmFyIGlzQXJyYXkgPSBBcnJheS5pc0FycmF5IHx8IGZ1bmN0aW9uICh4cykge1xuICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHhzKSA9PT0gJ1tvYmplY3QgQXJyYXldJztcbn07XG5cbmZ1bmN0aW9uIG1hcCAoeHMsIGYpIHtcbiAgaWYgKHhzLm1hcCkgcmV0dXJuIHhzLm1hcChmKTtcbiAgdmFyIHJlcyA9IFtdO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHhzLmxlbmd0aDsgaSsrKSB7XG4gICAgcmVzLnB1c2goZih4c1tpXSwgaSkpO1xuICB9XG4gIHJldHVybiByZXM7XG59XG5cbnZhciBvYmplY3RLZXlzID0gT2JqZWN0LmtleXMgfHwgZnVuY3Rpb24gKG9iaikge1xuICB2YXIgcmVzID0gW107XG4gIGZvciAodmFyIGtleSBpbiBvYmopIHtcbiAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwga2V5KSkgcmVzLnB1c2goa2V5KTtcbiAgfVxuICByZXR1cm4gcmVzO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxuZXhwb3J0cy5kZWNvZGUgPSBleHBvcnRzLnBhcnNlID0gcmVxdWlyZSgnLi9kZWNvZGUnKTtcbmV4cG9ydHMuZW5jb2RlID0gZXhwb3J0cy5zdHJpbmdpZnkgPSByZXF1aXJlKCcuL2VuY29kZScpO1xuIiwiLy8gQ29weXJpZ2h0IEpveWVudCwgSW5jLiBhbmQgb3RoZXIgTm9kZSBjb250cmlidXRvcnMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGFcbi8vIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcbi8vIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xuLy8gd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxuLy8gZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdFxuLy8gcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlXG4vLyBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZFxuLy8gaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTU1xuLy8gT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuLy8gTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTlxuLy8gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sXG4vLyBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1Jcbi8vIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEVcbi8vIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG5cbi8vIGEgZHVwbGV4IHN0cmVhbSBpcyBqdXN0IGEgc3RyZWFtIHRoYXQgaXMgYm90aCByZWFkYWJsZSBhbmQgd3JpdGFibGUuXG4vLyBTaW5jZSBKUyBkb2Vzbid0IGhhdmUgbXVsdGlwbGUgcHJvdG90eXBhbCBpbmhlcml0YW5jZSwgdGhpcyBjbGFzc1xuLy8gcHJvdG90eXBhbGx5IGluaGVyaXRzIGZyb20gUmVhZGFibGUsIGFuZCB0aGVuIHBhcmFzaXRpY2FsbHkgZnJvbVxuLy8gV3JpdGFibGUuXG5cbm1vZHVsZS5leHBvcnRzID0gRHVwbGV4O1xudmFyIGluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKTtcbnZhciBzZXRJbW1lZGlhdGUgPSByZXF1aXJlKCdwcm9jZXNzL2Jyb3dzZXIuanMnKS5uZXh0VGljaztcbnZhciBSZWFkYWJsZSA9IHJlcXVpcmUoJy4vcmVhZGFibGUuanMnKTtcbnZhciBXcml0YWJsZSA9IHJlcXVpcmUoJy4vd3JpdGFibGUuanMnKTtcblxuaW5oZXJpdHMoRHVwbGV4LCBSZWFkYWJsZSk7XG5cbkR1cGxleC5wcm90b3R5cGUud3JpdGUgPSBXcml0YWJsZS5wcm90b3R5cGUud3JpdGU7XG5EdXBsZXgucHJvdG90eXBlLmVuZCA9IFdyaXRhYmxlLnByb3RvdHlwZS5lbmQ7XG5EdXBsZXgucHJvdG90eXBlLl93cml0ZSA9IFdyaXRhYmxlLnByb3RvdHlwZS5fd3JpdGU7XG5cbmZ1bmN0aW9uIER1cGxleChvcHRpb25zKSB7XG4gIGlmICghKHRoaXMgaW5zdGFuY2VvZiBEdXBsZXgpKVxuICAgIHJldHVybiBuZXcgRHVwbGV4KG9wdGlvbnMpO1xuXG4gIFJlYWRhYmxlLmNhbGwodGhpcywgb3B0aW9ucyk7XG4gIFdyaXRhYmxlLmNhbGwodGhpcywgb3B0aW9ucyk7XG5cbiAgaWYgKG9wdGlvbnMgJiYgb3B0aW9ucy5yZWFkYWJsZSA9PT0gZmFsc2UpXG4gICAgdGhpcy5yZWFkYWJsZSA9IGZhbHNlO1xuXG4gIGlmIChvcHRpb25zICYmIG9wdGlvbnMud3JpdGFibGUgPT09IGZhbHNlKVxuICAgIHRoaXMud3JpdGFibGUgPSBmYWxzZTtcblxuICB0aGlzLmFsbG93SGFsZk9wZW4gPSB0cnVlO1xuICBpZiAob3B0aW9ucyAmJiBvcHRpb25zLmFsbG93SGFsZk9wZW4gPT09IGZhbHNlKVxuICAgIHRoaXMuYWxsb3dIYWxmT3BlbiA9IGZhbHNlO1xuXG4gIHRoaXMub25jZSgnZW5kJywgb25lbmQpO1xufVxuXG4vLyB0aGUgbm8taGFsZi1vcGVuIGVuZm9yY2VyXG5mdW5jdGlvbiBvbmVuZCgpIHtcbiAgLy8gaWYgd2UgYWxsb3cgaGFsZi1vcGVuIHN0YXRlLCBvciBpZiB0aGUgd3JpdGFibGUgc2lkZSBlbmRlZCxcbiAgLy8gdGhlbiB3ZSdyZSBvay5cbiAgaWYgKHRoaXMuYWxsb3dIYWxmT3BlbiB8fCB0aGlzLl93cml0YWJsZVN0YXRlLmVuZGVkKVxuICAgIHJldHVybjtcblxuICAvLyBubyBtb3JlIGRhdGEgY2FuIGJlIHdyaXR0ZW4uXG4gIC8vIEJ1dCBhbGxvdyBtb3JlIHdyaXRlcyB0byBoYXBwZW4gaW4gdGhpcyB0aWNrLlxuICB2YXIgc2VsZiA9IHRoaXM7XG4gIHNldEltbWVkaWF0ZShmdW5jdGlvbiAoKSB7XG4gICAgc2VsZi5lbmQoKTtcbiAgfSk7XG59XG4iLCIvLyBDb3B5cmlnaHQgSm95ZW50LCBJbmMuIGFuZCBvdGhlciBOb2RlIGNvbnRyaWJ1dG9ycy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxuLy8gY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxuLy8gXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXG4vLyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXG4vLyBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0XG4vLyBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGVcbi8vIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkXG4vLyBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTXG4vLyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4vLyBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOXG4vLyBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSxcbi8vIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUlxuLy8gT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRVxuLy8gVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cblxubW9kdWxlLmV4cG9ydHMgPSBTdHJlYW07XG5cbnZhciBFRSA9IHJlcXVpcmUoJ2V2ZW50cycpLkV2ZW50RW1pdHRlcjtcbnZhciBpbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJyk7XG5cbmluaGVyaXRzKFN0cmVhbSwgRUUpO1xuU3RyZWFtLlJlYWRhYmxlID0gcmVxdWlyZSgnLi9yZWFkYWJsZS5qcycpO1xuU3RyZWFtLldyaXRhYmxlID0gcmVxdWlyZSgnLi93cml0YWJsZS5qcycpO1xuU3RyZWFtLkR1cGxleCA9IHJlcXVpcmUoJy4vZHVwbGV4LmpzJyk7XG5TdHJlYW0uVHJhbnNmb3JtID0gcmVxdWlyZSgnLi90cmFuc2Zvcm0uanMnKTtcblN0cmVhbS5QYXNzVGhyb3VnaCA9IHJlcXVpcmUoJy4vcGFzc3Rocm91Z2guanMnKTtcblxuLy8gQmFja3dhcmRzLWNvbXBhdCB3aXRoIG5vZGUgMC40LnhcblN0cmVhbS5TdHJlYW0gPSBTdHJlYW07XG5cblxuXG4vLyBvbGQtc3R5bGUgc3RyZWFtcy4gIE5vdGUgdGhhdCB0aGUgcGlwZSBtZXRob2QgKHRoZSBvbmx5IHJlbGV2YW50XG4vLyBwYXJ0IG9mIHRoaXMgY2xhc3MpIGlzIG92ZXJyaWRkZW4gaW4gdGhlIFJlYWRhYmxlIGNsYXNzLlxuXG5mdW5jdGlvbiBTdHJlYW0oKSB7XG4gIEVFLmNhbGwodGhpcyk7XG59XG5cblN0cmVhbS5wcm90b3R5cGUucGlwZSA9IGZ1bmN0aW9uKGRlc3QsIG9wdGlvbnMpIHtcbiAgdmFyIHNvdXJjZSA9IHRoaXM7XG5cbiAgZnVuY3Rpb24gb25kYXRhKGNodW5rKSB7XG4gICAgaWYgKGRlc3Qud3JpdGFibGUpIHtcbiAgICAgIGlmIChmYWxzZSA9PT0gZGVzdC53cml0ZShjaHVuaykgJiYgc291cmNlLnBhdXNlKSB7XG4gICAgICAgIHNvdXJjZS5wYXVzZSgpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHNvdXJjZS5vbignZGF0YScsIG9uZGF0YSk7XG5cbiAgZnVuY3Rpb24gb25kcmFpbigpIHtcbiAgICBpZiAoc291cmNlLnJlYWRhYmxlICYmIHNvdXJjZS5yZXN1bWUpIHtcbiAgICAgIHNvdXJjZS5yZXN1bWUoKTtcbiAgICB9XG4gIH1cblxuICBkZXN0Lm9uKCdkcmFpbicsIG9uZHJhaW4pO1xuXG4gIC8vIElmIHRoZSAnZW5kJyBvcHRpb24gaXMgbm90IHN1cHBsaWVkLCBkZXN0LmVuZCgpIHdpbGwgYmUgY2FsbGVkIHdoZW5cbiAgLy8gc291cmNlIGdldHMgdGhlICdlbmQnIG9yICdjbG9zZScgZXZlbnRzLiAgT25seSBkZXN0LmVuZCgpIG9uY2UuXG4gIGlmICghZGVzdC5faXNTdGRpbyAmJiAoIW9wdGlvbnMgfHwgb3B0aW9ucy5lbmQgIT09IGZhbHNlKSkge1xuICAgIHNvdXJjZS5vbignZW5kJywgb25lbmQpO1xuICAgIHNvdXJjZS5vbignY2xvc2UnLCBvbmNsb3NlKTtcbiAgfVxuXG4gIHZhciBkaWRPbkVuZCA9IGZhbHNlO1xuICBmdW5jdGlvbiBvbmVuZCgpIHtcbiAgICBpZiAoZGlkT25FbmQpIHJldHVybjtcbiAgICBkaWRPbkVuZCA9IHRydWU7XG5cbiAgICBkZXN0LmVuZCgpO1xuICB9XG5cblxuICBmdW5jdGlvbiBvbmNsb3NlKCkge1xuICAgIGlmIChkaWRPbkVuZCkgcmV0dXJuO1xuICAgIGRpZE9uRW5kID0gdHJ1ZTtcblxuICAgIGlmICh0eXBlb2YgZGVzdC5kZXN0cm95ID09PSAnZnVuY3Rpb24nKSBkZXN0LmRlc3Ryb3koKTtcbiAgfVxuXG4gIC8vIGRvbid0IGxlYXZlIGRhbmdsaW5nIHBpcGVzIHdoZW4gdGhlcmUgYXJlIGVycm9ycy5cbiAgZnVuY3Rpb24gb25lcnJvcihlcikge1xuICAgIGNsZWFudXAoKTtcbiAgICBpZiAoRUUubGlzdGVuZXJDb3VudCh0aGlzLCAnZXJyb3InKSA9PT0gMCkge1xuICAgICAgdGhyb3cgZXI7IC8vIFVuaGFuZGxlZCBzdHJlYW0gZXJyb3IgaW4gcGlwZS5cbiAgICB9XG4gIH1cblxuICBzb3VyY2Uub24oJ2Vycm9yJywgb25lcnJvcik7XG4gIGRlc3Qub24oJ2Vycm9yJywgb25lcnJvcik7XG5cbiAgLy8gcmVtb3ZlIGFsbCB0aGUgZXZlbnQgbGlzdGVuZXJzIHRoYXQgd2VyZSBhZGRlZC5cbiAgZnVuY3Rpb24gY2xlYW51cCgpIHtcbiAgICBzb3VyY2UucmVtb3ZlTGlzdGVuZXIoJ2RhdGEnLCBvbmRhdGEpO1xuICAgIGRlc3QucmVtb3ZlTGlzdGVuZXIoJ2RyYWluJywgb25kcmFpbik7XG5cbiAgICBzb3VyY2UucmVtb3ZlTGlzdGVuZXIoJ2VuZCcsIG9uZW5kKTtcbiAgICBzb3VyY2UucmVtb3ZlTGlzdGVuZXIoJ2Nsb3NlJywgb25jbG9zZSk7XG5cbiAgICBzb3VyY2UucmVtb3ZlTGlzdGVuZXIoJ2Vycm9yJywgb25lcnJvcik7XG4gICAgZGVzdC5yZW1vdmVMaXN0ZW5lcignZXJyb3InLCBvbmVycm9yKTtcblxuICAgIHNvdXJjZS5yZW1vdmVMaXN0ZW5lcignZW5kJywgY2xlYW51cCk7XG4gICAgc291cmNlLnJlbW92ZUxpc3RlbmVyKCdjbG9zZScsIGNsZWFudXApO1xuXG4gICAgZGVzdC5yZW1vdmVMaXN0ZW5lcignY2xvc2UnLCBjbGVhbnVwKTtcbiAgfVxuXG4gIHNvdXJjZS5vbignZW5kJywgY2xlYW51cCk7XG4gIHNvdXJjZS5vbignY2xvc2UnLCBjbGVhbnVwKTtcblxuICBkZXN0Lm9uKCdjbG9zZScsIGNsZWFudXApO1xuXG4gIGRlc3QuZW1pdCgncGlwZScsIHNvdXJjZSk7XG5cbiAgLy8gQWxsb3cgZm9yIHVuaXgtbGlrZSB1c2FnZTogQS5waXBlKEIpLnBpcGUoQylcbiAgcmV0dXJuIGRlc3Q7XG59O1xuIiwiLy8gc2hpbSBmb3IgdXNpbmcgcHJvY2VzcyBpbiBicm93c2VyXG5cbnZhciBwcm9jZXNzID0gbW9kdWxlLmV4cG9ydHMgPSB7fTtcblxucHJvY2Vzcy5uZXh0VGljayA9IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGNhblNldEltbWVkaWF0ZSA9IHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnXG4gICAgJiYgd2luZG93LnNldEltbWVkaWF0ZTtcbiAgICB2YXIgY2FuUG9zdCA9IHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnXG4gICAgJiYgd2luZG93LnBvc3RNZXNzYWdlICYmIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyXG4gICAgO1xuXG4gICAgaWYgKGNhblNldEltbWVkaWF0ZSkge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKGYpIHsgcmV0dXJuIHdpbmRvdy5zZXRJbW1lZGlhdGUoZikgfTtcbiAgICB9XG5cbiAgICBpZiAoY2FuUG9zdCkge1xuICAgICAgICB2YXIgcXVldWUgPSBbXTtcbiAgICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ21lc3NhZ2UnLCBmdW5jdGlvbiAoZXYpIHtcbiAgICAgICAgICAgIHZhciBzb3VyY2UgPSBldi5zb3VyY2U7XG4gICAgICAgICAgICBpZiAoKHNvdXJjZSA9PT0gd2luZG93IHx8IHNvdXJjZSA9PT0gbnVsbCkgJiYgZXYuZGF0YSA9PT0gJ3Byb2Nlc3MtdGljaycpIHtcbiAgICAgICAgICAgICAgICBldi5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgICAgICAgICBpZiAocXVldWUubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgZm4gPSBxdWV1ZS5zaGlmdCgpO1xuICAgICAgICAgICAgICAgICAgICBmbigpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSwgdHJ1ZSk7XG5cbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIG5leHRUaWNrKGZuKSB7XG4gICAgICAgICAgICBxdWV1ZS5wdXNoKGZuKTtcbiAgICAgICAgICAgIHdpbmRvdy5wb3N0TWVzc2FnZSgncHJvY2Vzcy10aWNrJywgJyonKTtcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICByZXR1cm4gZnVuY3Rpb24gbmV4dFRpY2soZm4pIHtcbiAgICAgICAgc2V0VGltZW91dChmbiwgMCk7XG4gICAgfTtcbn0pKCk7XG5cbnByb2Nlc3MudGl0bGUgPSAnYnJvd3Nlcic7XG5wcm9jZXNzLmJyb3dzZXIgPSB0cnVlO1xucHJvY2Vzcy5lbnYgPSB7fTtcbnByb2Nlc3MuYXJndiA9IFtdO1xuXG5wcm9jZXNzLmJpbmRpbmcgPSBmdW5jdGlvbiAobmFtZSkge1xuICAgIHRocm93IG5ldyBFcnJvcigncHJvY2Vzcy5iaW5kaW5nIGlzIG5vdCBzdXBwb3J0ZWQnKTtcbn1cblxuLy8gVE9ETyhzaHR5bG1hbilcbnByb2Nlc3MuY3dkID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gJy8nIH07XG5wcm9jZXNzLmNoZGlyID0gZnVuY3Rpb24gKGRpcikge1xuICAgIHRocm93IG5ldyBFcnJvcigncHJvY2Vzcy5jaGRpciBpcyBub3Qgc3VwcG9ydGVkJyk7XG59O1xuIiwiLy8gQ29weXJpZ2h0IEpveWVudCwgSW5jLiBhbmQgb3RoZXIgTm9kZSBjb250cmlidXRvcnMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGFcbi8vIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcbi8vIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xuLy8gd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxuLy8gZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdFxuLy8gcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlXG4vLyBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZFxuLy8gaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTU1xuLy8gT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuLy8gTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTlxuLy8gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sXG4vLyBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1Jcbi8vIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEVcbi8vIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG5cbi8vIGEgcGFzc3Rocm91Z2ggc3RyZWFtLlxuLy8gYmFzaWNhbGx5IGp1c3QgdGhlIG1vc3QgbWluaW1hbCBzb3J0IG9mIFRyYW5zZm9ybSBzdHJlYW0uXG4vLyBFdmVyeSB3cml0dGVuIGNodW5rIGdldHMgb3V0cHV0IGFzLWlzLlxuXG5tb2R1bGUuZXhwb3J0cyA9IFBhc3NUaHJvdWdoO1xuXG52YXIgVHJhbnNmb3JtID0gcmVxdWlyZSgnLi90cmFuc2Zvcm0uanMnKTtcbnZhciBpbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJyk7XG5pbmhlcml0cyhQYXNzVGhyb3VnaCwgVHJhbnNmb3JtKTtcblxuZnVuY3Rpb24gUGFzc1Rocm91Z2gob3B0aW9ucykge1xuICBpZiAoISh0aGlzIGluc3RhbmNlb2YgUGFzc1Rocm91Z2gpKVxuICAgIHJldHVybiBuZXcgUGFzc1Rocm91Z2gob3B0aW9ucyk7XG5cbiAgVHJhbnNmb3JtLmNhbGwodGhpcywgb3B0aW9ucyk7XG59XG5cblBhc3NUaHJvdWdoLnByb3RvdHlwZS5fdHJhbnNmb3JtID0gZnVuY3Rpb24oY2h1bmssIGVuY29kaW5nLCBjYikge1xuICBjYihudWxsLCBjaHVuayk7XG59O1xuIiwiKGZ1bmN0aW9uIChwcm9jZXNzKXtcbi8vIENvcHlyaWdodCBKb3llbnQsIEluYy4gYW5kIG90aGVyIE5vZGUgY29udHJpYnV0b3JzLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhXG4vLyBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlXG4vLyBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmdcbi8vIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCxcbi8vIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXRcbi8vIHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZVxuLy8gZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWRcbi8vIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1Ncbi8vIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0Zcbi8vIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU5cbi8vIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLFxuLy8gREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SXG4vLyBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFXG4vLyBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWRhYmxlO1xuUmVhZGFibGUuUmVhZGFibGVTdGF0ZSA9IFJlYWRhYmxlU3RhdGU7XG5cbnZhciBFRSA9IHJlcXVpcmUoJ2V2ZW50cycpLkV2ZW50RW1pdHRlcjtcbnZhciBTdHJlYW0gPSByZXF1aXJlKCcuL2luZGV4LmpzJyk7XG52YXIgQnVmZmVyID0gcmVxdWlyZSgnYnVmZmVyJykuQnVmZmVyO1xudmFyIHNldEltbWVkaWF0ZSA9IHJlcXVpcmUoJ3Byb2Nlc3MvYnJvd3Nlci5qcycpLm5leHRUaWNrO1xudmFyIFN0cmluZ0RlY29kZXI7XG5cbnZhciBpbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJyk7XG5pbmhlcml0cyhSZWFkYWJsZSwgU3RyZWFtKTtcblxuZnVuY3Rpb24gUmVhZGFibGVTdGF0ZShvcHRpb25zLCBzdHJlYW0pIHtcbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cbiAgLy8gdGhlIHBvaW50IGF0IHdoaWNoIGl0IHN0b3BzIGNhbGxpbmcgX3JlYWQoKSB0byBmaWxsIHRoZSBidWZmZXJcbiAgLy8gTm90ZTogMCBpcyBhIHZhbGlkIHZhbHVlLCBtZWFucyBcImRvbid0IGNhbGwgX3JlYWQgcHJlZW1wdGl2ZWx5IGV2ZXJcIlxuICB2YXIgaHdtID0gb3B0aW9ucy5oaWdoV2F0ZXJNYXJrO1xuICB0aGlzLmhpZ2hXYXRlck1hcmsgPSAoaHdtIHx8IGh3bSA9PT0gMCkgPyBod20gOiAxNiAqIDEwMjQ7XG5cbiAgLy8gY2FzdCB0byBpbnRzLlxuICB0aGlzLmhpZ2hXYXRlck1hcmsgPSB+fnRoaXMuaGlnaFdhdGVyTWFyaztcblxuICB0aGlzLmJ1ZmZlciA9IFtdO1xuICB0aGlzLmxlbmd0aCA9IDA7XG4gIHRoaXMucGlwZXMgPSBudWxsO1xuICB0aGlzLnBpcGVzQ291bnQgPSAwO1xuICB0aGlzLmZsb3dpbmcgPSBmYWxzZTtcbiAgdGhpcy5lbmRlZCA9IGZhbHNlO1xuICB0aGlzLmVuZEVtaXR0ZWQgPSBmYWxzZTtcbiAgdGhpcy5yZWFkaW5nID0gZmFsc2U7XG5cbiAgLy8gSW4gc3RyZWFtcyB0aGF0IG5ldmVyIGhhdmUgYW55IGRhdGEsIGFuZCBkbyBwdXNoKG51bGwpIHJpZ2h0IGF3YXksXG4gIC8vIHRoZSBjb25zdW1lciBjYW4gbWlzcyB0aGUgJ2VuZCcgZXZlbnQgaWYgdGhleSBkbyBzb21lIEkvTyBiZWZvcmVcbiAgLy8gY29uc3VtaW5nIHRoZSBzdHJlYW0uICBTbywgd2UgZG9uJ3QgZW1pdCgnZW5kJykgdW50aWwgc29tZSByZWFkaW5nXG4gIC8vIGhhcHBlbnMuXG4gIHRoaXMuY2FsbGVkUmVhZCA9IGZhbHNlO1xuXG4gIC8vIGEgZmxhZyB0byBiZSBhYmxlIHRvIHRlbGwgaWYgdGhlIG9ud3JpdGUgY2IgaXMgY2FsbGVkIGltbWVkaWF0ZWx5LFxuICAvLyBvciBvbiBhIGxhdGVyIHRpY2suICBXZSBzZXQgdGhpcyB0byB0cnVlIGF0IGZpcnN0LCBiZWN1YXNlIGFueVxuICAvLyBhY3Rpb25zIHRoYXQgc2hvdWxkbid0IGhhcHBlbiB1bnRpbCBcImxhdGVyXCIgc2hvdWxkIGdlbmVyYWxseSBhbHNvXG4gIC8vIG5vdCBoYXBwZW4gYmVmb3JlIHRoZSBmaXJzdCB3cml0ZSBjYWxsLlxuICB0aGlzLnN5bmMgPSB0cnVlO1xuXG4gIC8vIHdoZW5ldmVyIHdlIHJldHVybiBudWxsLCB0aGVuIHdlIHNldCBhIGZsYWcgdG8gc2F5XG4gIC8vIHRoYXQgd2UncmUgYXdhaXRpbmcgYSAncmVhZGFibGUnIGV2ZW50IGVtaXNzaW9uLlxuICB0aGlzLm5lZWRSZWFkYWJsZSA9IGZhbHNlO1xuICB0aGlzLmVtaXR0ZWRSZWFkYWJsZSA9IGZhbHNlO1xuICB0aGlzLnJlYWRhYmxlTGlzdGVuaW5nID0gZmFsc2U7XG5cblxuICAvLyBvYmplY3Qgc3RyZWFtIGZsYWcuIFVzZWQgdG8gbWFrZSByZWFkKG4pIGlnbm9yZSBuIGFuZCB0b1xuICAvLyBtYWtlIGFsbCB0aGUgYnVmZmVyIG1lcmdpbmcgYW5kIGxlbmd0aCBjaGVja3MgZ28gYXdheVxuICB0aGlzLm9iamVjdE1vZGUgPSAhIW9wdGlvbnMub2JqZWN0TW9kZTtcblxuICAvLyBDcnlwdG8gaXMga2luZCBvZiBvbGQgYW5kIGNydXN0eS4gIEhpc3RvcmljYWxseSwgaXRzIGRlZmF1bHQgc3RyaW5nXG4gIC8vIGVuY29kaW5nIGlzICdiaW5hcnknIHNvIHdlIGhhdmUgdG8gbWFrZSB0aGlzIGNvbmZpZ3VyYWJsZS5cbiAgLy8gRXZlcnl0aGluZyBlbHNlIGluIHRoZSB1bml2ZXJzZSB1c2VzICd1dGY4JywgdGhvdWdoLlxuICB0aGlzLmRlZmF1bHRFbmNvZGluZyA9IG9wdGlvbnMuZGVmYXVsdEVuY29kaW5nIHx8ICd1dGY4JztcblxuICAvLyB3aGVuIHBpcGluZywgd2Ugb25seSBjYXJlIGFib3V0ICdyZWFkYWJsZScgZXZlbnRzIHRoYXQgaGFwcGVuXG4gIC8vIGFmdGVyIHJlYWQoKWluZyBhbGwgdGhlIGJ5dGVzIGFuZCBub3QgZ2V0dGluZyBhbnkgcHVzaGJhY2suXG4gIHRoaXMucmFuT3V0ID0gZmFsc2U7XG5cbiAgLy8gdGhlIG51bWJlciBvZiB3cml0ZXJzIHRoYXQgYXJlIGF3YWl0aW5nIGEgZHJhaW4gZXZlbnQgaW4gLnBpcGUoKXNcbiAgdGhpcy5hd2FpdERyYWluID0gMDtcblxuICAvLyBpZiB0cnVlLCBhIG1heWJlUmVhZE1vcmUgaGFzIGJlZW4gc2NoZWR1bGVkXG4gIHRoaXMucmVhZGluZ01vcmUgPSBmYWxzZTtcblxuICB0aGlzLmRlY29kZXIgPSBudWxsO1xuICB0aGlzLmVuY29kaW5nID0gbnVsbDtcbiAgaWYgKG9wdGlvbnMuZW5jb2RpbmcpIHtcbiAgICBpZiAoIVN0cmluZ0RlY29kZXIpXG4gICAgICBTdHJpbmdEZWNvZGVyID0gcmVxdWlyZSgnc3RyaW5nX2RlY29kZXInKS5TdHJpbmdEZWNvZGVyO1xuICAgIHRoaXMuZGVjb2RlciA9IG5ldyBTdHJpbmdEZWNvZGVyKG9wdGlvbnMuZW5jb2RpbmcpO1xuICAgIHRoaXMuZW5jb2RpbmcgPSBvcHRpb25zLmVuY29kaW5nO1xuICB9XG59XG5cbmZ1bmN0aW9uIFJlYWRhYmxlKG9wdGlvbnMpIHtcbiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIFJlYWRhYmxlKSlcbiAgICByZXR1cm4gbmV3IFJlYWRhYmxlKG9wdGlvbnMpO1xuXG4gIHRoaXMuX3JlYWRhYmxlU3RhdGUgPSBuZXcgUmVhZGFibGVTdGF0ZShvcHRpb25zLCB0aGlzKTtcblxuICAvLyBsZWdhY3lcbiAgdGhpcy5yZWFkYWJsZSA9IHRydWU7XG5cbiAgU3RyZWFtLmNhbGwodGhpcyk7XG59XG5cbi8vIE1hbnVhbGx5IHNob3ZlIHNvbWV0aGluZyBpbnRvIHRoZSByZWFkKCkgYnVmZmVyLlxuLy8gVGhpcyByZXR1cm5zIHRydWUgaWYgdGhlIGhpZ2hXYXRlck1hcmsgaGFzIG5vdCBiZWVuIGhpdCB5ZXQsXG4vLyBzaW1pbGFyIHRvIGhvdyBXcml0YWJsZS53cml0ZSgpIHJldHVybnMgdHJ1ZSBpZiB5b3Ugc2hvdWxkXG4vLyB3cml0ZSgpIHNvbWUgbW9yZS5cblJlYWRhYmxlLnByb3RvdHlwZS5wdXNoID0gZnVuY3Rpb24oY2h1bmssIGVuY29kaW5nKSB7XG4gIHZhciBzdGF0ZSA9IHRoaXMuX3JlYWRhYmxlU3RhdGU7XG5cbiAgaWYgKHR5cGVvZiBjaHVuayA9PT0gJ3N0cmluZycgJiYgIXN0YXRlLm9iamVjdE1vZGUpIHtcbiAgICBlbmNvZGluZyA9IGVuY29kaW5nIHx8IHN0YXRlLmRlZmF1bHRFbmNvZGluZztcbiAgICBpZiAoZW5jb2RpbmcgIT09IHN0YXRlLmVuY29kaW5nKSB7XG4gICAgICBjaHVuayA9IG5ldyBCdWZmZXIoY2h1bmssIGVuY29kaW5nKTtcbiAgICAgIGVuY29kaW5nID0gJyc7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHJlYWRhYmxlQWRkQ2h1bmsodGhpcywgc3RhdGUsIGNodW5rLCBlbmNvZGluZywgZmFsc2UpO1xufTtcblxuLy8gVW5zaGlmdCBzaG91bGQgKmFsd2F5cyogYmUgc29tZXRoaW5nIGRpcmVjdGx5IG91dCBvZiByZWFkKClcblJlYWRhYmxlLnByb3RvdHlwZS51bnNoaWZ0ID0gZnVuY3Rpb24oY2h1bmspIHtcbiAgdmFyIHN0YXRlID0gdGhpcy5fcmVhZGFibGVTdGF0ZTtcbiAgcmV0dXJuIHJlYWRhYmxlQWRkQ2h1bmsodGhpcywgc3RhdGUsIGNodW5rLCAnJywgdHJ1ZSk7XG59O1xuXG5mdW5jdGlvbiByZWFkYWJsZUFkZENodW5rKHN0cmVhbSwgc3RhdGUsIGNodW5rLCBlbmNvZGluZywgYWRkVG9Gcm9udCkge1xuICB2YXIgZXIgPSBjaHVua0ludmFsaWQoc3RhdGUsIGNodW5rKTtcbiAgaWYgKGVyKSB7XG4gICAgc3RyZWFtLmVtaXQoJ2Vycm9yJywgZXIpO1xuICB9IGVsc2UgaWYgKGNodW5rID09PSBudWxsIHx8IGNodW5rID09PSB1bmRlZmluZWQpIHtcbiAgICBzdGF0ZS5yZWFkaW5nID0gZmFsc2U7XG4gICAgaWYgKCFzdGF0ZS5lbmRlZClcbiAgICAgIG9uRW9mQ2h1bmsoc3RyZWFtLCBzdGF0ZSk7XG4gIH0gZWxzZSBpZiAoc3RhdGUub2JqZWN0TW9kZSB8fCBjaHVuayAmJiBjaHVuay5sZW5ndGggPiAwKSB7XG4gICAgaWYgKHN0YXRlLmVuZGVkICYmICFhZGRUb0Zyb250KSB7XG4gICAgICB2YXIgZSA9IG5ldyBFcnJvcignc3RyZWFtLnB1c2goKSBhZnRlciBFT0YnKTtcbiAgICAgIHN0cmVhbS5lbWl0KCdlcnJvcicsIGUpO1xuICAgIH0gZWxzZSBpZiAoc3RhdGUuZW5kRW1pdHRlZCAmJiBhZGRUb0Zyb250KSB7XG4gICAgICB2YXIgZSA9IG5ldyBFcnJvcignc3RyZWFtLnVuc2hpZnQoKSBhZnRlciBlbmQgZXZlbnQnKTtcbiAgICAgIHN0cmVhbS5lbWl0KCdlcnJvcicsIGUpO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoc3RhdGUuZGVjb2RlciAmJiAhYWRkVG9Gcm9udCAmJiAhZW5jb2RpbmcpXG4gICAgICAgIGNodW5rID0gc3RhdGUuZGVjb2Rlci53cml0ZShjaHVuayk7XG5cbiAgICAgIC8vIHVwZGF0ZSB0aGUgYnVmZmVyIGluZm8uXG4gICAgICBzdGF0ZS5sZW5ndGggKz0gc3RhdGUub2JqZWN0TW9kZSA/IDEgOiBjaHVuay5sZW5ndGg7XG4gICAgICBpZiAoYWRkVG9Gcm9udCkge1xuICAgICAgICBzdGF0ZS5idWZmZXIudW5zaGlmdChjaHVuayk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzdGF0ZS5yZWFkaW5nID0gZmFsc2U7XG4gICAgICAgIHN0YXRlLmJ1ZmZlci5wdXNoKGNodW5rKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHN0YXRlLm5lZWRSZWFkYWJsZSlcbiAgICAgICAgZW1pdFJlYWRhYmxlKHN0cmVhbSk7XG5cbiAgICAgIG1heWJlUmVhZE1vcmUoc3RyZWFtLCBzdGF0ZSk7XG4gICAgfVxuICB9IGVsc2UgaWYgKCFhZGRUb0Zyb250KSB7XG4gICAgc3RhdGUucmVhZGluZyA9IGZhbHNlO1xuICB9XG5cbiAgcmV0dXJuIG5lZWRNb3JlRGF0YShzdGF0ZSk7XG59XG5cblxuXG4vLyBpZiBpdCdzIHBhc3QgdGhlIGhpZ2ggd2F0ZXIgbWFyaywgd2UgY2FuIHB1c2ggaW4gc29tZSBtb3JlLlxuLy8gQWxzbywgaWYgd2UgaGF2ZSBubyBkYXRhIHlldCwgd2UgY2FuIHN0YW5kIHNvbWVcbi8vIG1vcmUgYnl0ZXMuICBUaGlzIGlzIHRvIHdvcmsgYXJvdW5kIGNhc2VzIHdoZXJlIGh3bT0wLFxuLy8gc3VjaCBhcyB0aGUgcmVwbC4gIEFsc28sIGlmIHRoZSBwdXNoKCkgdHJpZ2dlcmVkIGFcbi8vIHJlYWRhYmxlIGV2ZW50LCBhbmQgdGhlIHVzZXIgY2FsbGVkIHJlYWQobGFyZ2VOdW1iZXIpIHN1Y2ggdGhhdFxuLy8gbmVlZFJlYWRhYmxlIHdhcyBzZXQsIHRoZW4gd2Ugb3VnaHQgdG8gcHVzaCBtb3JlLCBzbyB0aGF0IGFub3RoZXJcbi8vICdyZWFkYWJsZScgZXZlbnQgd2lsbCBiZSB0cmlnZ2VyZWQuXG5mdW5jdGlvbiBuZWVkTW9yZURhdGEoc3RhdGUpIHtcbiAgcmV0dXJuICFzdGF0ZS5lbmRlZCAmJlxuICAgICAgICAgKHN0YXRlLm5lZWRSZWFkYWJsZSB8fFxuICAgICAgICAgIHN0YXRlLmxlbmd0aCA8IHN0YXRlLmhpZ2hXYXRlck1hcmsgfHxcbiAgICAgICAgICBzdGF0ZS5sZW5ndGggPT09IDApO1xufVxuXG4vLyBiYWNrd2FyZHMgY29tcGF0aWJpbGl0eS5cblJlYWRhYmxlLnByb3RvdHlwZS5zZXRFbmNvZGluZyA9IGZ1bmN0aW9uKGVuYykge1xuICBpZiAoIVN0cmluZ0RlY29kZXIpXG4gICAgU3RyaW5nRGVjb2RlciA9IHJlcXVpcmUoJ3N0cmluZ19kZWNvZGVyJykuU3RyaW5nRGVjb2RlcjtcbiAgdGhpcy5fcmVhZGFibGVTdGF0ZS5kZWNvZGVyID0gbmV3IFN0cmluZ0RlY29kZXIoZW5jKTtcbiAgdGhpcy5fcmVhZGFibGVTdGF0ZS5lbmNvZGluZyA9IGVuYztcbn07XG5cbi8vIERvbid0IHJhaXNlIHRoZSBod20gPiAxMjhNQlxudmFyIE1BWF9IV00gPSAweDgwMDAwMDtcbmZ1bmN0aW9uIHJvdW5kVXBUb05leHRQb3dlck9mMihuKSB7XG4gIGlmIChuID49IE1BWF9IV00pIHtcbiAgICBuID0gTUFYX0hXTTtcbiAgfSBlbHNlIHtcbiAgICAvLyBHZXQgdGhlIG5leHQgaGlnaGVzdCBwb3dlciBvZiAyXG4gICAgbi0tO1xuICAgIGZvciAodmFyIHAgPSAxOyBwIDwgMzI7IHAgPDw9IDEpIG4gfD0gbiA+PiBwO1xuICAgIG4rKztcbiAgfVxuICByZXR1cm4gbjtcbn1cblxuZnVuY3Rpb24gaG93TXVjaFRvUmVhZChuLCBzdGF0ZSkge1xuICBpZiAoc3RhdGUubGVuZ3RoID09PSAwICYmIHN0YXRlLmVuZGVkKVxuICAgIHJldHVybiAwO1xuXG4gIGlmIChzdGF0ZS5vYmplY3RNb2RlKVxuICAgIHJldHVybiBuID09PSAwID8gMCA6IDE7XG5cbiAgaWYgKGlzTmFOKG4pIHx8IG4gPT09IG51bGwpIHtcbiAgICAvLyBvbmx5IGZsb3cgb25lIGJ1ZmZlciBhdCBhIHRpbWVcbiAgICBpZiAoc3RhdGUuZmxvd2luZyAmJiBzdGF0ZS5idWZmZXIubGVuZ3RoKVxuICAgICAgcmV0dXJuIHN0YXRlLmJ1ZmZlclswXS5sZW5ndGg7XG4gICAgZWxzZVxuICAgICAgcmV0dXJuIHN0YXRlLmxlbmd0aDtcbiAgfVxuXG4gIGlmIChuIDw9IDApXG4gICAgcmV0dXJuIDA7XG5cbiAgLy8gSWYgd2UncmUgYXNraW5nIGZvciBtb3JlIHRoYW4gdGhlIHRhcmdldCBidWZmZXIgbGV2ZWwsXG4gIC8vIHRoZW4gcmFpc2UgdGhlIHdhdGVyIG1hcmsuICBCdW1wIHVwIHRvIHRoZSBuZXh0IGhpZ2hlc3RcbiAgLy8gcG93ZXIgb2YgMiwgdG8gcHJldmVudCBpbmNyZWFzaW5nIGl0IGV4Y2Vzc2l2ZWx5IGluIHRpbnlcbiAgLy8gYW1vdW50cy5cbiAgaWYgKG4gPiBzdGF0ZS5oaWdoV2F0ZXJNYXJrKVxuICAgIHN0YXRlLmhpZ2hXYXRlck1hcmsgPSByb3VuZFVwVG9OZXh0UG93ZXJPZjIobik7XG5cbiAgLy8gZG9uJ3QgaGF2ZSB0aGF0IG11Y2guICByZXR1cm4gbnVsbCwgdW5sZXNzIHdlJ3ZlIGVuZGVkLlxuICBpZiAobiA+IHN0YXRlLmxlbmd0aCkge1xuICAgIGlmICghc3RhdGUuZW5kZWQpIHtcbiAgICAgIHN0YXRlLm5lZWRSZWFkYWJsZSA9IHRydWU7XG4gICAgICByZXR1cm4gMDtcbiAgICB9IGVsc2VcbiAgICAgIHJldHVybiBzdGF0ZS5sZW5ndGg7XG4gIH1cblxuICByZXR1cm4gbjtcbn1cblxuLy8geW91IGNhbiBvdmVycmlkZSBlaXRoZXIgdGhpcyBtZXRob2QsIG9yIHRoZSBhc3luYyBfcmVhZChuKSBiZWxvdy5cblJlYWRhYmxlLnByb3RvdHlwZS5yZWFkID0gZnVuY3Rpb24obikge1xuICB2YXIgc3RhdGUgPSB0aGlzLl9yZWFkYWJsZVN0YXRlO1xuICBzdGF0ZS5jYWxsZWRSZWFkID0gdHJ1ZTtcbiAgdmFyIG5PcmlnID0gbjtcblxuICBpZiAodHlwZW9mIG4gIT09ICdudW1iZXInIHx8IG4gPiAwKVxuICAgIHN0YXRlLmVtaXR0ZWRSZWFkYWJsZSA9IGZhbHNlO1xuXG4gIC8vIGlmIHdlJ3JlIGRvaW5nIHJlYWQoMCkgdG8gdHJpZ2dlciBhIHJlYWRhYmxlIGV2ZW50LCBidXQgd2VcbiAgLy8gYWxyZWFkeSBoYXZlIGEgYnVuY2ggb2YgZGF0YSBpbiB0aGUgYnVmZmVyLCB0aGVuIGp1c3QgdHJpZ2dlclxuICAvLyB0aGUgJ3JlYWRhYmxlJyBldmVudCBhbmQgbW92ZSBvbi5cbiAgaWYgKG4gPT09IDAgJiZcbiAgICAgIHN0YXRlLm5lZWRSZWFkYWJsZSAmJlxuICAgICAgKHN0YXRlLmxlbmd0aCA+PSBzdGF0ZS5oaWdoV2F0ZXJNYXJrIHx8IHN0YXRlLmVuZGVkKSkge1xuICAgIGVtaXRSZWFkYWJsZSh0aGlzKTtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIG4gPSBob3dNdWNoVG9SZWFkKG4sIHN0YXRlKTtcblxuICAvLyBpZiB3ZSd2ZSBlbmRlZCwgYW5kIHdlJ3JlIG5vdyBjbGVhciwgdGhlbiBmaW5pc2ggaXQgdXAuXG4gIGlmIChuID09PSAwICYmIHN0YXRlLmVuZGVkKSB7XG4gICAgaWYgKHN0YXRlLmxlbmd0aCA9PT0gMClcbiAgICAgIGVuZFJlYWRhYmxlKHRoaXMpO1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgLy8gQWxsIHRoZSBhY3R1YWwgY2h1bmsgZ2VuZXJhdGlvbiBsb2dpYyBuZWVkcyB0byBiZVxuICAvLyAqYmVsb3cqIHRoZSBjYWxsIHRvIF9yZWFkLiAgVGhlIHJlYXNvbiBpcyB0aGF0IGluIGNlcnRhaW5cbiAgLy8gc3ludGhldGljIHN0cmVhbSBjYXNlcywgc3VjaCBhcyBwYXNzdGhyb3VnaCBzdHJlYW1zLCBfcmVhZFxuICAvLyBtYXkgYmUgYSBjb21wbGV0ZWx5IHN5bmNocm9ub3VzIG9wZXJhdGlvbiB3aGljaCBtYXkgY2hhbmdlXG4gIC8vIHRoZSBzdGF0ZSBvZiB0aGUgcmVhZCBidWZmZXIsIHByb3ZpZGluZyBlbm91Z2ggZGF0YSB3aGVuXG4gIC8vIGJlZm9yZSB0aGVyZSB3YXMgKm5vdCogZW5vdWdoLlxuICAvL1xuICAvLyBTbywgdGhlIHN0ZXBzIGFyZTpcbiAgLy8gMS4gRmlndXJlIG91dCB3aGF0IHRoZSBzdGF0ZSBvZiB0aGluZ3Mgd2lsbCBiZSBhZnRlciB3ZSBkb1xuICAvLyBhIHJlYWQgZnJvbSB0aGUgYnVmZmVyLlxuICAvL1xuICAvLyAyLiBJZiB0aGF0IHJlc3VsdGluZyBzdGF0ZSB3aWxsIHRyaWdnZXIgYSBfcmVhZCwgdGhlbiBjYWxsIF9yZWFkLlxuICAvLyBOb3RlIHRoYXQgdGhpcyBtYXkgYmUgYXN5bmNocm9ub3VzLCBvciBzeW5jaHJvbm91cy4gIFllcywgaXQgaXNcbiAgLy8gZGVlcGx5IHVnbHkgdG8gd3JpdGUgQVBJcyB0aGlzIHdheSwgYnV0IHRoYXQgc3RpbGwgZG9lc24ndCBtZWFuXG4gIC8vIHRoYXQgdGhlIFJlYWRhYmxlIGNsYXNzIHNob3VsZCBiZWhhdmUgaW1wcm9wZXJseSwgYXMgc3RyZWFtcyBhcmVcbiAgLy8gZGVzaWduZWQgdG8gYmUgc3luYy9hc3luYyBhZ25vc3RpYy5cbiAgLy8gVGFrZSBub3RlIGlmIHRoZSBfcmVhZCBjYWxsIGlzIHN5bmMgb3IgYXN5bmMgKGllLCBpZiB0aGUgcmVhZCBjYWxsXG4gIC8vIGhhcyByZXR1cm5lZCB5ZXQpLCBzbyB0aGF0IHdlIGtub3cgd2hldGhlciBvciBub3QgaXQncyBzYWZlIHRvIGVtaXRcbiAgLy8gJ3JlYWRhYmxlJyBldGMuXG4gIC8vXG4gIC8vIDMuIEFjdHVhbGx5IHB1bGwgdGhlIHJlcXVlc3RlZCBjaHVua3Mgb3V0IG9mIHRoZSBidWZmZXIgYW5kIHJldHVybi5cblxuICAvLyBpZiB3ZSBuZWVkIGEgcmVhZGFibGUgZXZlbnQsIHRoZW4gd2UgbmVlZCB0byBkbyBzb21lIHJlYWRpbmcuXG4gIHZhciBkb1JlYWQgPSBzdGF0ZS5uZWVkUmVhZGFibGU7XG5cbiAgLy8gaWYgd2UgY3VycmVudGx5IGhhdmUgbGVzcyB0aGFuIHRoZSBoaWdoV2F0ZXJNYXJrLCB0aGVuIGFsc28gcmVhZCBzb21lXG4gIGlmIChzdGF0ZS5sZW5ndGggLSBuIDw9IHN0YXRlLmhpZ2hXYXRlck1hcmspXG4gICAgZG9SZWFkID0gdHJ1ZTtcblxuICAvLyBob3dldmVyLCBpZiB3ZSd2ZSBlbmRlZCwgdGhlbiB0aGVyZSdzIG5vIHBvaW50LCBhbmQgaWYgd2UncmUgYWxyZWFkeVxuICAvLyByZWFkaW5nLCB0aGVuIGl0J3MgdW5uZWNlc3NhcnkuXG4gIGlmIChzdGF0ZS5lbmRlZCB8fCBzdGF0ZS5yZWFkaW5nKVxuICAgIGRvUmVhZCA9IGZhbHNlO1xuXG4gIGlmIChkb1JlYWQpIHtcbiAgICBzdGF0ZS5yZWFkaW5nID0gdHJ1ZTtcbiAgICBzdGF0ZS5zeW5jID0gdHJ1ZTtcbiAgICAvLyBpZiB0aGUgbGVuZ3RoIGlzIGN1cnJlbnRseSB6ZXJvLCB0aGVuIHdlICpuZWVkKiBhIHJlYWRhYmxlIGV2ZW50LlxuICAgIGlmIChzdGF0ZS5sZW5ndGggPT09IDApXG4gICAgICBzdGF0ZS5uZWVkUmVhZGFibGUgPSB0cnVlO1xuICAgIC8vIGNhbGwgaW50ZXJuYWwgcmVhZCBtZXRob2RcbiAgICB0aGlzLl9yZWFkKHN0YXRlLmhpZ2hXYXRlck1hcmspO1xuICAgIHN0YXRlLnN5bmMgPSBmYWxzZTtcbiAgfVxuXG4gIC8vIElmIF9yZWFkIGNhbGxlZCBpdHMgY2FsbGJhY2sgc3luY2hyb25vdXNseSwgdGhlbiBgcmVhZGluZ2BcbiAgLy8gd2lsbCBiZSBmYWxzZSwgYW5kIHdlIG5lZWQgdG8gcmUtZXZhbHVhdGUgaG93IG11Y2ggZGF0YSB3ZVxuICAvLyBjYW4gcmV0dXJuIHRvIHRoZSB1c2VyLlxuICBpZiAoZG9SZWFkICYmICFzdGF0ZS5yZWFkaW5nKVxuICAgIG4gPSBob3dNdWNoVG9SZWFkKG5PcmlnLCBzdGF0ZSk7XG5cbiAgdmFyIHJldDtcbiAgaWYgKG4gPiAwKVxuICAgIHJldCA9IGZyb21MaXN0KG4sIHN0YXRlKTtcbiAgZWxzZVxuICAgIHJldCA9IG51bGw7XG5cbiAgaWYgKHJldCA9PT0gbnVsbCkge1xuICAgIHN0YXRlLm5lZWRSZWFkYWJsZSA9IHRydWU7XG4gICAgbiA9IDA7XG4gIH1cblxuICBzdGF0ZS5sZW5ndGggLT0gbjtcblxuICAvLyBJZiB3ZSBoYXZlIG5vdGhpbmcgaW4gdGhlIGJ1ZmZlciwgdGhlbiB3ZSB3YW50IHRvIGtub3dcbiAgLy8gYXMgc29vbiBhcyB3ZSAqZG8qIGdldCBzb21ldGhpbmcgaW50byB0aGUgYnVmZmVyLlxuICBpZiAoc3RhdGUubGVuZ3RoID09PSAwICYmICFzdGF0ZS5lbmRlZClcbiAgICBzdGF0ZS5uZWVkUmVhZGFibGUgPSB0cnVlO1xuXG4gIC8vIElmIHdlIGhhcHBlbmVkIHRvIHJlYWQoKSBleGFjdGx5IHRoZSByZW1haW5pbmcgYW1vdW50IGluIHRoZVxuICAvLyBidWZmZXIsIGFuZCB0aGUgRU9GIGhhcyBiZWVuIHNlZW4gYXQgdGhpcyBwb2ludCwgdGhlbiBtYWtlIHN1cmVcbiAgLy8gdGhhdCB3ZSBlbWl0ICdlbmQnIG9uIHRoZSB2ZXJ5IG5leHQgdGljay5cbiAgaWYgKHN0YXRlLmVuZGVkICYmICFzdGF0ZS5lbmRFbWl0dGVkICYmIHN0YXRlLmxlbmd0aCA9PT0gMClcbiAgICBlbmRSZWFkYWJsZSh0aGlzKTtcblxuICByZXR1cm4gcmV0O1xufTtcblxuZnVuY3Rpb24gY2h1bmtJbnZhbGlkKHN0YXRlLCBjaHVuaykge1xuICB2YXIgZXIgPSBudWxsO1xuICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcihjaHVuaykgJiZcbiAgICAgICdzdHJpbmcnICE9PSB0eXBlb2YgY2h1bmsgJiZcbiAgICAgIGNodW5rICE9PSBudWxsICYmXG4gICAgICBjaHVuayAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAhc3RhdGUub2JqZWN0TW9kZSAmJlxuICAgICAgIWVyKSB7XG4gICAgZXIgPSBuZXcgVHlwZUVycm9yKCdJbnZhbGlkIG5vbi1zdHJpbmcvYnVmZmVyIGNodW5rJyk7XG4gIH1cbiAgcmV0dXJuIGVyO1xufVxuXG5cbmZ1bmN0aW9uIG9uRW9mQ2h1bmsoc3RyZWFtLCBzdGF0ZSkge1xuICBpZiAoc3RhdGUuZGVjb2RlciAmJiAhc3RhdGUuZW5kZWQpIHtcbiAgICB2YXIgY2h1bmsgPSBzdGF0ZS5kZWNvZGVyLmVuZCgpO1xuICAgIGlmIChjaHVuayAmJiBjaHVuay5sZW5ndGgpIHtcbiAgICAgIHN0YXRlLmJ1ZmZlci5wdXNoKGNodW5rKTtcbiAgICAgIHN0YXRlLmxlbmd0aCArPSBzdGF0ZS5vYmplY3RNb2RlID8gMSA6IGNodW5rLmxlbmd0aDtcbiAgICB9XG4gIH1cbiAgc3RhdGUuZW5kZWQgPSB0cnVlO1xuXG4gIC8vIGlmIHdlJ3ZlIGVuZGVkIGFuZCB3ZSBoYXZlIHNvbWUgZGF0YSBsZWZ0LCB0aGVuIGVtaXRcbiAgLy8gJ3JlYWRhYmxlJyBub3cgdG8gbWFrZSBzdXJlIGl0IGdldHMgcGlja2VkIHVwLlxuICBpZiAoc3RhdGUubGVuZ3RoID4gMClcbiAgICBlbWl0UmVhZGFibGUoc3RyZWFtKTtcbiAgZWxzZVxuICAgIGVuZFJlYWRhYmxlKHN0cmVhbSk7XG59XG5cbi8vIERvbid0IGVtaXQgcmVhZGFibGUgcmlnaHQgYXdheSBpbiBzeW5jIG1vZGUsIGJlY2F1c2UgdGhpcyBjYW4gdHJpZ2dlclxuLy8gYW5vdGhlciByZWFkKCkgY2FsbCA9PiBzdGFjayBvdmVyZmxvdy4gIFRoaXMgd2F5LCBpdCBtaWdodCB0cmlnZ2VyXG4vLyBhIG5leHRUaWNrIHJlY3Vyc2lvbiB3YXJuaW5nLCBidXQgdGhhdCdzIG5vdCBzbyBiYWQuXG5mdW5jdGlvbiBlbWl0UmVhZGFibGUoc3RyZWFtKSB7XG4gIHZhciBzdGF0ZSA9IHN0cmVhbS5fcmVhZGFibGVTdGF0ZTtcbiAgc3RhdGUubmVlZFJlYWRhYmxlID0gZmFsc2U7XG4gIGlmIChzdGF0ZS5lbWl0dGVkUmVhZGFibGUpXG4gICAgcmV0dXJuO1xuXG4gIHN0YXRlLmVtaXR0ZWRSZWFkYWJsZSA9IHRydWU7XG4gIGlmIChzdGF0ZS5zeW5jKVxuICAgIHNldEltbWVkaWF0ZShmdW5jdGlvbigpIHtcbiAgICAgIGVtaXRSZWFkYWJsZV8oc3RyZWFtKTtcbiAgICB9KTtcbiAgZWxzZVxuICAgIGVtaXRSZWFkYWJsZV8oc3RyZWFtKTtcbn1cblxuZnVuY3Rpb24gZW1pdFJlYWRhYmxlXyhzdHJlYW0pIHtcbiAgc3RyZWFtLmVtaXQoJ3JlYWRhYmxlJyk7XG59XG5cblxuLy8gYXQgdGhpcyBwb2ludCwgdGhlIHVzZXIgaGFzIHByZXN1bWFibHkgc2VlbiB0aGUgJ3JlYWRhYmxlJyBldmVudCxcbi8vIGFuZCBjYWxsZWQgcmVhZCgpIHRvIGNvbnN1bWUgc29tZSBkYXRhLiAgdGhhdCBtYXkgaGF2ZSB0cmlnZ2VyZWRcbi8vIGluIHR1cm4gYW5vdGhlciBfcmVhZChuKSBjYWxsLCBpbiB3aGljaCBjYXNlIHJlYWRpbmcgPSB0cnVlIGlmXG4vLyBpdCdzIGluIHByb2dyZXNzLlxuLy8gSG93ZXZlciwgaWYgd2UncmUgbm90IGVuZGVkLCBvciByZWFkaW5nLCBhbmQgdGhlIGxlbmd0aCA8IGh3bSxcbi8vIHRoZW4gZ28gYWhlYWQgYW5kIHRyeSB0byByZWFkIHNvbWUgbW9yZSBwcmVlbXB0aXZlbHkuXG5mdW5jdGlvbiBtYXliZVJlYWRNb3JlKHN0cmVhbSwgc3RhdGUpIHtcbiAgaWYgKCFzdGF0ZS5yZWFkaW5nTW9yZSkge1xuICAgIHN0YXRlLnJlYWRpbmdNb3JlID0gdHJ1ZTtcbiAgICBzZXRJbW1lZGlhdGUoZnVuY3Rpb24oKSB7XG4gICAgICBtYXliZVJlYWRNb3JlXyhzdHJlYW0sIHN0YXRlKTtcbiAgICB9KTtcbiAgfVxufVxuXG5mdW5jdGlvbiBtYXliZVJlYWRNb3JlXyhzdHJlYW0sIHN0YXRlKSB7XG4gIHZhciBsZW4gPSBzdGF0ZS5sZW5ndGg7XG4gIHdoaWxlICghc3RhdGUucmVhZGluZyAmJiAhc3RhdGUuZmxvd2luZyAmJiAhc3RhdGUuZW5kZWQgJiZcbiAgICAgICAgIHN0YXRlLmxlbmd0aCA8IHN0YXRlLmhpZ2hXYXRlck1hcmspIHtcbiAgICBzdHJlYW0ucmVhZCgwKTtcbiAgICBpZiAobGVuID09PSBzdGF0ZS5sZW5ndGgpXG4gICAgICAvLyBkaWRuJ3QgZ2V0IGFueSBkYXRhLCBzdG9wIHNwaW5uaW5nLlxuICAgICAgYnJlYWs7XG4gICAgZWxzZVxuICAgICAgbGVuID0gc3RhdGUubGVuZ3RoO1xuICB9XG4gIHN0YXRlLnJlYWRpbmdNb3JlID0gZmFsc2U7XG59XG5cbi8vIGFic3RyYWN0IG1ldGhvZC4gIHRvIGJlIG92ZXJyaWRkZW4gaW4gc3BlY2lmaWMgaW1wbGVtZW50YXRpb24gY2xhc3Nlcy5cbi8vIGNhbGwgY2IoZXIsIGRhdGEpIHdoZXJlIGRhdGEgaXMgPD0gbiBpbiBsZW5ndGguXG4vLyBmb3IgdmlydHVhbCAobm9uLXN0cmluZywgbm9uLWJ1ZmZlcikgc3RyZWFtcywgXCJsZW5ndGhcIiBpcyBzb21ld2hhdFxuLy8gYXJiaXRyYXJ5LCBhbmQgcGVyaGFwcyBub3QgdmVyeSBtZWFuaW5nZnVsLlxuUmVhZGFibGUucHJvdG90eXBlLl9yZWFkID0gZnVuY3Rpb24obikge1xuICB0aGlzLmVtaXQoJ2Vycm9yJywgbmV3IEVycm9yKCdub3QgaW1wbGVtZW50ZWQnKSk7XG59O1xuXG5SZWFkYWJsZS5wcm90b3R5cGUucGlwZSA9IGZ1bmN0aW9uKGRlc3QsIHBpcGVPcHRzKSB7XG4gIHZhciBzcmMgPSB0aGlzO1xuICB2YXIgc3RhdGUgPSB0aGlzLl9yZWFkYWJsZVN0YXRlO1xuXG4gIHN3aXRjaCAoc3RhdGUucGlwZXNDb3VudCkge1xuICAgIGNhc2UgMDpcbiAgICAgIHN0YXRlLnBpcGVzID0gZGVzdDtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgMTpcbiAgICAgIHN0YXRlLnBpcGVzID0gW3N0YXRlLnBpcGVzLCBkZXN0XTtcbiAgICAgIGJyZWFrO1xuICAgIGRlZmF1bHQ6XG4gICAgICBzdGF0ZS5waXBlcy5wdXNoKGRlc3QpO1xuICAgICAgYnJlYWs7XG4gIH1cbiAgc3RhdGUucGlwZXNDb3VudCArPSAxO1xuXG4gIHZhciBkb0VuZCA9ICghcGlwZU9wdHMgfHwgcGlwZU9wdHMuZW5kICE9PSBmYWxzZSkgJiZcbiAgICAgICAgICAgICAgZGVzdCAhPT0gcHJvY2Vzcy5zdGRvdXQgJiZcbiAgICAgICAgICAgICAgZGVzdCAhPT0gcHJvY2Vzcy5zdGRlcnI7XG5cbiAgdmFyIGVuZEZuID0gZG9FbmQgPyBvbmVuZCA6IGNsZWFudXA7XG4gIGlmIChzdGF0ZS5lbmRFbWl0dGVkKVxuICAgIHNldEltbWVkaWF0ZShlbmRGbik7XG4gIGVsc2VcbiAgICBzcmMub25jZSgnZW5kJywgZW5kRm4pO1xuXG4gIGRlc3Qub24oJ3VucGlwZScsIG9udW5waXBlKTtcbiAgZnVuY3Rpb24gb251bnBpcGUocmVhZGFibGUpIHtcbiAgICBpZiAocmVhZGFibGUgIT09IHNyYykgcmV0dXJuO1xuICAgIGNsZWFudXAoKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIG9uZW5kKCkge1xuICAgIGRlc3QuZW5kKCk7XG4gIH1cblxuICAvLyB3aGVuIHRoZSBkZXN0IGRyYWlucywgaXQgcmVkdWNlcyB0aGUgYXdhaXREcmFpbiBjb3VudGVyXG4gIC8vIG9uIHRoZSBzb3VyY2UuICBUaGlzIHdvdWxkIGJlIG1vcmUgZWxlZ2FudCB3aXRoIGEgLm9uY2UoKVxuICAvLyBoYW5kbGVyIGluIGZsb3coKSwgYnV0IGFkZGluZyBhbmQgcmVtb3ZpbmcgcmVwZWF0ZWRseSBpc1xuICAvLyB0b28gc2xvdy5cbiAgdmFyIG9uZHJhaW4gPSBwaXBlT25EcmFpbihzcmMpO1xuICBkZXN0Lm9uKCdkcmFpbicsIG9uZHJhaW4pO1xuXG4gIGZ1bmN0aW9uIGNsZWFudXAoKSB7XG4gICAgLy8gY2xlYW51cCBldmVudCBoYW5kbGVycyBvbmNlIHRoZSBwaXBlIGlzIGJyb2tlblxuICAgIGRlc3QucmVtb3ZlTGlzdGVuZXIoJ2Nsb3NlJywgb25jbG9zZSk7XG4gICAgZGVzdC5yZW1vdmVMaXN0ZW5lcignZmluaXNoJywgb25maW5pc2gpO1xuICAgIGRlc3QucmVtb3ZlTGlzdGVuZXIoJ2RyYWluJywgb25kcmFpbik7XG4gICAgZGVzdC5yZW1vdmVMaXN0ZW5lcignZXJyb3InLCBvbmVycm9yKTtcbiAgICBkZXN0LnJlbW92ZUxpc3RlbmVyKCd1bnBpcGUnLCBvbnVucGlwZSk7XG4gICAgc3JjLnJlbW92ZUxpc3RlbmVyKCdlbmQnLCBvbmVuZCk7XG4gICAgc3JjLnJlbW92ZUxpc3RlbmVyKCdlbmQnLCBjbGVhbnVwKTtcblxuICAgIC8vIGlmIHRoZSByZWFkZXIgaXMgd2FpdGluZyBmb3IgYSBkcmFpbiBldmVudCBmcm9tIHRoaXNcbiAgICAvLyBzcGVjaWZpYyB3cml0ZXIsIHRoZW4gaXQgd291bGQgY2F1c2UgaXQgdG8gbmV2ZXIgc3RhcnRcbiAgICAvLyBmbG93aW5nIGFnYWluLlxuICAgIC8vIFNvLCBpZiB0aGlzIGlzIGF3YWl0aW5nIGEgZHJhaW4sIHRoZW4gd2UganVzdCBjYWxsIGl0IG5vdy5cbiAgICAvLyBJZiB3ZSBkb24ndCBrbm93LCB0aGVuIGFzc3VtZSB0aGF0IHdlIGFyZSB3YWl0aW5nIGZvciBvbmUuXG4gICAgaWYgKCFkZXN0Ll93cml0YWJsZVN0YXRlIHx8IGRlc3QuX3dyaXRhYmxlU3RhdGUubmVlZERyYWluKVxuICAgICAgb25kcmFpbigpO1xuICB9XG5cbiAgLy8gaWYgdGhlIGRlc3QgaGFzIGFuIGVycm9yLCB0aGVuIHN0b3AgcGlwaW5nIGludG8gaXQuXG4gIC8vIGhvd2V2ZXIsIGRvbid0IHN1cHByZXNzIHRoZSB0aHJvd2luZyBiZWhhdmlvciBmb3IgdGhpcy5cbiAgLy8gY2hlY2sgZm9yIGxpc3RlbmVycyBiZWZvcmUgZW1pdCByZW1vdmVzIG9uZS10aW1lIGxpc3RlbmVycy5cbiAgdmFyIGVyckxpc3RlbmVycyA9IEVFLmxpc3RlbmVyQ291bnQoZGVzdCwgJ2Vycm9yJyk7XG4gIGZ1bmN0aW9uIG9uZXJyb3IoZXIpIHtcbiAgICB1bnBpcGUoKTtcbiAgICBpZiAoZXJyTGlzdGVuZXJzID09PSAwICYmIEVFLmxpc3RlbmVyQ291bnQoZGVzdCwgJ2Vycm9yJykgPT09IDApXG4gICAgICBkZXN0LmVtaXQoJ2Vycm9yJywgZXIpO1xuICB9XG4gIGRlc3Qub25jZSgnZXJyb3InLCBvbmVycm9yKTtcblxuICAvLyBCb3RoIGNsb3NlIGFuZCBmaW5pc2ggc2hvdWxkIHRyaWdnZXIgdW5waXBlLCBidXQgb25seSBvbmNlLlxuICBmdW5jdGlvbiBvbmNsb3NlKCkge1xuICAgIGRlc3QucmVtb3ZlTGlzdGVuZXIoJ2ZpbmlzaCcsIG9uZmluaXNoKTtcbiAgICB1bnBpcGUoKTtcbiAgfVxuICBkZXN0Lm9uY2UoJ2Nsb3NlJywgb25jbG9zZSk7XG4gIGZ1bmN0aW9uIG9uZmluaXNoKCkge1xuICAgIGRlc3QucmVtb3ZlTGlzdGVuZXIoJ2Nsb3NlJywgb25jbG9zZSk7XG4gICAgdW5waXBlKCk7XG4gIH1cbiAgZGVzdC5vbmNlKCdmaW5pc2gnLCBvbmZpbmlzaCk7XG5cbiAgZnVuY3Rpb24gdW5waXBlKCkge1xuICAgIHNyYy51bnBpcGUoZGVzdCk7XG4gIH1cblxuICAvLyB0ZWxsIHRoZSBkZXN0IHRoYXQgaXQncyBiZWluZyBwaXBlZCB0b1xuICBkZXN0LmVtaXQoJ3BpcGUnLCBzcmMpO1xuXG4gIC8vIHN0YXJ0IHRoZSBmbG93IGlmIGl0IGhhc24ndCBiZWVuIHN0YXJ0ZWQgYWxyZWFkeS5cbiAgaWYgKCFzdGF0ZS5mbG93aW5nKSB7XG4gICAgLy8gdGhlIGhhbmRsZXIgdGhhdCB3YWl0cyBmb3IgcmVhZGFibGUgZXZlbnRzIGFmdGVyIGFsbFxuICAgIC8vIHRoZSBkYXRhIGdldHMgc3Vja2VkIG91dCBpbiBmbG93LlxuICAgIC8vIFRoaXMgd291bGQgYmUgZWFzaWVyIHRvIGZvbGxvdyB3aXRoIGEgLm9uY2UoKSBoYW5kbGVyXG4gICAgLy8gaW4gZmxvdygpLCBidXQgdGhhdCBpcyB0b28gc2xvdy5cbiAgICB0aGlzLm9uKCdyZWFkYWJsZScsIHBpcGVPblJlYWRhYmxlKTtcblxuICAgIHN0YXRlLmZsb3dpbmcgPSB0cnVlO1xuICAgIHNldEltbWVkaWF0ZShmdW5jdGlvbigpIHtcbiAgICAgIGZsb3coc3JjKTtcbiAgICB9KTtcbiAgfVxuXG4gIHJldHVybiBkZXN0O1xufTtcblxuZnVuY3Rpb24gcGlwZU9uRHJhaW4oc3JjKSB7XG4gIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICB2YXIgZGVzdCA9IHRoaXM7XG4gICAgdmFyIHN0YXRlID0gc3JjLl9yZWFkYWJsZVN0YXRlO1xuICAgIHN0YXRlLmF3YWl0RHJhaW4tLTtcbiAgICBpZiAoc3RhdGUuYXdhaXREcmFpbiA9PT0gMClcbiAgICAgIGZsb3coc3JjKTtcbiAgfTtcbn1cblxuZnVuY3Rpb24gZmxvdyhzcmMpIHtcbiAgdmFyIHN0YXRlID0gc3JjLl9yZWFkYWJsZVN0YXRlO1xuICB2YXIgY2h1bms7XG4gIHN0YXRlLmF3YWl0RHJhaW4gPSAwO1xuXG4gIGZ1bmN0aW9uIHdyaXRlKGRlc3QsIGksIGxpc3QpIHtcbiAgICB2YXIgd3JpdHRlbiA9IGRlc3Qud3JpdGUoY2h1bmspO1xuICAgIGlmIChmYWxzZSA9PT0gd3JpdHRlbikge1xuICAgICAgc3RhdGUuYXdhaXREcmFpbisrO1xuICAgIH1cbiAgfVxuXG4gIHdoaWxlIChzdGF0ZS5waXBlc0NvdW50ICYmIG51bGwgIT09IChjaHVuayA9IHNyYy5yZWFkKCkpKSB7XG5cbiAgICBpZiAoc3RhdGUucGlwZXNDb3VudCA9PT0gMSlcbiAgICAgIHdyaXRlKHN0YXRlLnBpcGVzLCAwLCBudWxsKTtcbiAgICBlbHNlXG4gICAgICBmb3JFYWNoKHN0YXRlLnBpcGVzLCB3cml0ZSk7XG5cbiAgICBzcmMuZW1pdCgnZGF0YScsIGNodW5rKTtcblxuICAgIC8vIGlmIGFueW9uZSBuZWVkcyBhIGRyYWluLCB0aGVuIHdlIGhhdmUgdG8gd2FpdCBmb3IgdGhhdC5cbiAgICBpZiAoc3RhdGUuYXdhaXREcmFpbiA+IDApXG4gICAgICByZXR1cm47XG4gIH1cblxuICAvLyBpZiBldmVyeSBkZXN0aW5hdGlvbiB3YXMgdW5waXBlZCwgZWl0aGVyIGJlZm9yZSBlbnRlcmluZyB0aGlzXG4gIC8vIGZ1bmN0aW9uLCBvciBpbiB0aGUgd2hpbGUgbG9vcCwgdGhlbiBzdG9wIGZsb3dpbmcuXG4gIC8vXG4gIC8vIE5COiBUaGlzIGlzIGEgcHJldHR5IHJhcmUgZWRnZSBjYXNlLlxuICBpZiAoc3RhdGUucGlwZXNDb3VudCA9PT0gMCkge1xuICAgIHN0YXRlLmZsb3dpbmcgPSBmYWxzZTtcblxuICAgIC8vIGlmIHRoZXJlIHdlcmUgZGF0YSBldmVudCBsaXN0ZW5lcnMgYWRkZWQsIHRoZW4gc3dpdGNoIHRvIG9sZCBtb2RlLlxuICAgIGlmIChFRS5saXN0ZW5lckNvdW50KHNyYywgJ2RhdGEnKSA+IDApXG4gICAgICBlbWl0RGF0YUV2ZW50cyhzcmMpO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIC8vIGF0IHRoaXMgcG9pbnQsIG5vIG9uZSBuZWVkZWQgYSBkcmFpbiwgc28gd2UganVzdCByYW4gb3V0IG9mIGRhdGFcbiAgLy8gb24gdGhlIG5leHQgcmVhZGFibGUgZXZlbnQsIHN0YXJ0IGl0IG92ZXIgYWdhaW4uXG4gIHN0YXRlLnJhbk91dCA9IHRydWU7XG59XG5cbmZ1bmN0aW9uIHBpcGVPblJlYWRhYmxlKCkge1xuICBpZiAodGhpcy5fcmVhZGFibGVTdGF0ZS5yYW5PdXQpIHtcbiAgICB0aGlzLl9yZWFkYWJsZVN0YXRlLnJhbk91dCA9IGZhbHNlO1xuICAgIGZsb3codGhpcyk7XG4gIH1cbn1cblxuXG5SZWFkYWJsZS5wcm90b3R5cGUudW5waXBlID0gZnVuY3Rpb24oZGVzdCkge1xuICB2YXIgc3RhdGUgPSB0aGlzLl9yZWFkYWJsZVN0YXRlO1xuXG4gIC8vIGlmIHdlJ3JlIG5vdCBwaXBpbmcgYW55d2hlcmUsIHRoZW4gZG8gbm90aGluZy5cbiAgaWYgKHN0YXRlLnBpcGVzQ291bnQgPT09IDApXG4gICAgcmV0dXJuIHRoaXM7XG5cbiAgLy8ganVzdCBvbmUgZGVzdGluYXRpb24uICBtb3N0IGNvbW1vbiBjYXNlLlxuICBpZiAoc3RhdGUucGlwZXNDb3VudCA9PT0gMSkge1xuICAgIC8vIHBhc3NlZCBpbiBvbmUsIGJ1dCBpdCdzIG5vdCB0aGUgcmlnaHQgb25lLlxuICAgIGlmIChkZXN0ICYmIGRlc3QgIT09IHN0YXRlLnBpcGVzKVxuICAgICAgcmV0dXJuIHRoaXM7XG5cbiAgICBpZiAoIWRlc3QpXG4gICAgICBkZXN0ID0gc3RhdGUucGlwZXM7XG5cbiAgICAvLyBnb3QgYSBtYXRjaC5cbiAgICBzdGF0ZS5waXBlcyA9IG51bGw7XG4gICAgc3RhdGUucGlwZXNDb3VudCA9IDA7XG4gICAgdGhpcy5yZW1vdmVMaXN0ZW5lcigncmVhZGFibGUnLCBwaXBlT25SZWFkYWJsZSk7XG4gICAgc3RhdGUuZmxvd2luZyA9IGZhbHNlO1xuICAgIGlmIChkZXN0KVxuICAgICAgZGVzdC5lbWl0KCd1bnBpcGUnLCB0aGlzKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8vIHNsb3cgY2FzZS4gbXVsdGlwbGUgcGlwZSBkZXN0aW5hdGlvbnMuXG5cbiAgaWYgKCFkZXN0KSB7XG4gICAgLy8gcmVtb3ZlIGFsbC5cbiAgICB2YXIgZGVzdHMgPSBzdGF0ZS5waXBlcztcbiAgICB2YXIgbGVuID0gc3RhdGUucGlwZXNDb3VudDtcbiAgICBzdGF0ZS5waXBlcyA9IG51bGw7XG4gICAgc3RhdGUucGlwZXNDb3VudCA9IDA7XG4gICAgdGhpcy5yZW1vdmVMaXN0ZW5lcigncmVhZGFibGUnLCBwaXBlT25SZWFkYWJsZSk7XG4gICAgc3RhdGUuZmxvd2luZyA9IGZhbHNlO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKylcbiAgICAgIGRlc3RzW2ldLmVtaXQoJ3VucGlwZScsIHRoaXMpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLy8gdHJ5IHRvIGZpbmQgdGhlIHJpZ2h0IG9uZS5cbiAgdmFyIGkgPSBpbmRleE9mKHN0YXRlLnBpcGVzLCBkZXN0KTtcbiAgaWYgKGkgPT09IC0xKVxuICAgIHJldHVybiB0aGlzO1xuXG4gIHN0YXRlLnBpcGVzLnNwbGljZShpLCAxKTtcbiAgc3RhdGUucGlwZXNDb3VudCAtPSAxO1xuICBpZiAoc3RhdGUucGlwZXNDb3VudCA9PT0gMSlcbiAgICBzdGF0ZS5waXBlcyA9IHN0YXRlLnBpcGVzWzBdO1xuXG4gIGRlc3QuZW1pdCgndW5waXBlJywgdGhpcyk7XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vLyBzZXQgdXAgZGF0YSBldmVudHMgaWYgdGhleSBhcmUgYXNrZWQgZm9yXG4vLyBFbnN1cmUgcmVhZGFibGUgbGlzdGVuZXJzIGV2ZW50dWFsbHkgZ2V0IHNvbWV0aGluZ1xuUmVhZGFibGUucHJvdG90eXBlLm9uID0gZnVuY3Rpb24oZXYsIGZuKSB7XG4gIHZhciByZXMgPSBTdHJlYW0ucHJvdG90eXBlLm9uLmNhbGwodGhpcywgZXYsIGZuKTtcblxuICBpZiAoZXYgPT09ICdkYXRhJyAmJiAhdGhpcy5fcmVhZGFibGVTdGF0ZS5mbG93aW5nKVxuICAgIGVtaXREYXRhRXZlbnRzKHRoaXMpO1xuXG4gIGlmIChldiA9PT0gJ3JlYWRhYmxlJyAmJiB0aGlzLnJlYWRhYmxlKSB7XG4gICAgdmFyIHN0YXRlID0gdGhpcy5fcmVhZGFibGVTdGF0ZTtcbiAgICBpZiAoIXN0YXRlLnJlYWRhYmxlTGlzdGVuaW5nKSB7XG4gICAgICBzdGF0ZS5yZWFkYWJsZUxpc3RlbmluZyA9IHRydWU7XG4gICAgICBzdGF0ZS5lbWl0dGVkUmVhZGFibGUgPSBmYWxzZTtcbiAgICAgIHN0YXRlLm5lZWRSZWFkYWJsZSA9IHRydWU7XG4gICAgICBpZiAoIXN0YXRlLnJlYWRpbmcpIHtcbiAgICAgICAgdGhpcy5yZWFkKDApO1xuICAgICAgfSBlbHNlIGlmIChzdGF0ZS5sZW5ndGgpIHtcbiAgICAgICAgZW1pdFJlYWRhYmxlKHRoaXMsIHN0YXRlKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gcmVzO1xufTtcblJlYWRhYmxlLnByb3RvdHlwZS5hZGRMaXN0ZW5lciA9IFJlYWRhYmxlLnByb3RvdHlwZS5vbjtcblxuLy8gcGF1c2UoKSBhbmQgcmVzdW1lKCkgYXJlIHJlbW5hbnRzIG9mIHRoZSBsZWdhY3kgcmVhZGFibGUgc3RyZWFtIEFQSVxuLy8gSWYgdGhlIHVzZXIgdXNlcyB0aGVtLCB0aGVuIHN3aXRjaCBpbnRvIG9sZCBtb2RlLlxuUmVhZGFibGUucHJvdG90eXBlLnJlc3VtZSA9IGZ1bmN0aW9uKCkge1xuICBlbWl0RGF0YUV2ZW50cyh0aGlzKTtcbiAgdGhpcy5yZWFkKDApO1xuICB0aGlzLmVtaXQoJ3Jlc3VtZScpO1xufTtcblxuUmVhZGFibGUucHJvdG90eXBlLnBhdXNlID0gZnVuY3Rpb24oKSB7XG4gIGVtaXREYXRhRXZlbnRzKHRoaXMsIHRydWUpO1xuICB0aGlzLmVtaXQoJ3BhdXNlJyk7XG59O1xuXG5mdW5jdGlvbiBlbWl0RGF0YUV2ZW50cyhzdHJlYW0sIHN0YXJ0UGF1c2VkKSB7XG4gIHZhciBzdGF0ZSA9IHN0cmVhbS5fcmVhZGFibGVTdGF0ZTtcblxuICBpZiAoc3RhdGUuZmxvd2luZykge1xuICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9pc2FhY3MvcmVhZGFibGUtc3RyZWFtL2lzc3Vlcy8xNlxuICAgIHRocm93IG5ldyBFcnJvcignQ2Fubm90IHN3aXRjaCB0byBvbGQgbW9kZSBub3cuJyk7XG4gIH1cblxuICB2YXIgcGF1c2VkID0gc3RhcnRQYXVzZWQgfHwgZmFsc2U7XG4gIHZhciByZWFkYWJsZSA9IGZhbHNlO1xuXG4gIC8vIGNvbnZlcnQgdG8gYW4gb2xkLXN0eWxlIHN0cmVhbS5cbiAgc3RyZWFtLnJlYWRhYmxlID0gdHJ1ZTtcbiAgc3RyZWFtLnBpcGUgPSBTdHJlYW0ucHJvdG90eXBlLnBpcGU7XG4gIHN0cmVhbS5vbiA9IHN0cmVhbS5hZGRMaXN0ZW5lciA9IFN0cmVhbS5wcm90b3R5cGUub247XG5cbiAgc3RyZWFtLm9uKCdyZWFkYWJsZScsIGZ1bmN0aW9uKCkge1xuICAgIHJlYWRhYmxlID0gdHJ1ZTtcblxuICAgIHZhciBjO1xuICAgIHdoaWxlICghcGF1c2VkICYmIChudWxsICE9PSAoYyA9IHN0cmVhbS5yZWFkKCkpKSlcbiAgICAgIHN0cmVhbS5lbWl0KCdkYXRhJywgYyk7XG5cbiAgICBpZiAoYyA9PT0gbnVsbCkge1xuICAgICAgcmVhZGFibGUgPSBmYWxzZTtcbiAgICAgIHN0cmVhbS5fcmVhZGFibGVTdGF0ZS5uZWVkUmVhZGFibGUgPSB0cnVlO1xuICAgIH1cbiAgfSk7XG5cbiAgc3RyZWFtLnBhdXNlID0gZnVuY3Rpb24oKSB7XG4gICAgcGF1c2VkID0gdHJ1ZTtcbiAgICB0aGlzLmVtaXQoJ3BhdXNlJyk7XG4gIH07XG5cbiAgc3RyZWFtLnJlc3VtZSA9IGZ1bmN0aW9uKCkge1xuICAgIHBhdXNlZCA9IGZhbHNlO1xuICAgIGlmIChyZWFkYWJsZSlcbiAgICAgIHNldEltbWVkaWF0ZShmdW5jdGlvbigpIHtcbiAgICAgICAgc3RyZWFtLmVtaXQoJ3JlYWRhYmxlJyk7XG4gICAgICB9KTtcbiAgICBlbHNlXG4gICAgICB0aGlzLnJlYWQoMCk7XG4gICAgdGhpcy5lbWl0KCdyZXN1bWUnKTtcbiAgfTtcblxuICAvLyBub3cgbWFrZSBpdCBzdGFydCwganVzdCBpbiBjYXNlIGl0IGhhZG4ndCBhbHJlYWR5LlxuICBzdHJlYW0uZW1pdCgncmVhZGFibGUnKTtcbn1cblxuLy8gd3JhcCBhbiBvbGQtc3R5bGUgc3RyZWFtIGFzIHRoZSBhc3luYyBkYXRhIHNvdXJjZS5cbi8vIFRoaXMgaXMgKm5vdCogcGFydCBvZiB0aGUgcmVhZGFibGUgc3RyZWFtIGludGVyZmFjZS5cbi8vIEl0IGlzIGFuIHVnbHkgdW5mb3J0dW5hdGUgbWVzcyBvZiBoaXN0b3J5LlxuUmVhZGFibGUucHJvdG90eXBlLndyYXAgPSBmdW5jdGlvbihzdHJlYW0pIHtcbiAgdmFyIHN0YXRlID0gdGhpcy5fcmVhZGFibGVTdGF0ZTtcbiAgdmFyIHBhdXNlZCA9IGZhbHNlO1xuXG4gIHZhciBzZWxmID0gdGhpcztcbiAgc3RyZWFtLm9uKCdlbmQnLCBmdW5jdGlvbigpIHtcbiAgICBpZiAoc3RhdGUuZGVjb2RlciAmJiAhc3RhdGUuZW5kZWQpIHtcbiAgICAgIHZhciBjaHVuayA9IHN0YXRlLmRlY29kZXIuZW5kKCk7XG4gICAgICBpZiAoY2h1bmsgJiYgY2h1bmsubGVuZ3RoKVxuICAgICAgICBzZWxmLnB1c2goY2h1bmspO1xuICAgIH1cblxuICAgIHNlbGYucHVzaChudWxsKTtcbiAgfSk7XG5cbiAgc3RyZWFtLm9uKCdkYXRhJywgZnVuY3Rpb24oY2h1bmspIHtcbiAgICBpZiAoc3RhdGUuZGVjb2RlcilcbiAgICAgIGNodW5rID0gc3RhdGUuZGVjb2Rlci53cml0ZShjaHVuayk7XG4gICAgaWYgKCFjaHVuayB8fCAhc3RhdGUub2JqZWN0TW9kZSAmJiAhY2h1bmsubGVuZ3RoKVxuICAgICAgcmV0dXJuO1xuXG4gICAgdmFyIHJldCA9IHNlbGYucHVzaChjaHVuayk7XG4gICAgaWYgKCFyZXQpIHtcbiAgICAgIHBhdXNlZCA9IHRydWU7XG4gICAgICBzdHJlYW0ucGF1c2UoKTtcbiAgICB9XG4gIH0pO1xuXG4gIC8vIHByb3h5IGFsbCB0aGUgb3RoZXIgbWV0aG9kcy5cbiAgLy8gaW1wb3J0YW50IHdoZW4gd3JhcHBpbmcgZmlsdGVycyBhbmQgZHVwbGV4ZXMuXG4gIGZvciAodmFyIGkgaW4gc3RyZWFtKSB7XG4gICAgaWYgKHR5cGVvZiBzdHJlYW1baV0gPT09ICdmdW5jdGlvbicgJiZcbiAgICAgICAgdHlwZW9mIHRoaXNbaV0gPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICB0aGlzW2ldID0gZnVuY3Rpb24obWV0aG9kKSB7IHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHN0cmVhbVttZXRob2RdLmFwcGx5KHN0cmVhbSwgYXJndW1lbnRzKTtcbiAgICAgIH19KGkpO1xuICAgIH1cbiAgfVxuXG4gIC8vIHByb3h5IGNlcnRhaW4gaW1wb3J0YW50IGV2ZW50cy5cbiAgdmFyIGV2ZW50cyA9IFsnZXJyb3InLCAnY2xvc2UnLCAnZGVzdHJveScsICdwYXVzZScsICdyZXN1bWUnXTtcbiAgZm9yRWFjaChldmVudHMsIGZ1bmN0aW9uKGV2KSB7XG4gICAgc3RyZWFtLm9uKGV2LCBmdW5jdGlvbiAoeCkge1xuICAgICAgcmV0dXJuIHNlbGYuZW1pdC5hcHBseShzZWxmLCBldiwgeCk7XG4gICAgfSk7XG4gIH0pO1xuXG4gIC8vIHdoZW4gd2UgdHJ5IHRvIGNvbnN1bWUgc29tZSBtb3JlIGJ5dGVzLCBzaW1wbHkgdW5wYXVzZSB0aGVcbiAgLy8gdW5kZXJseWluZyBzdHJlYW0uXG4gIHNlbGYuX3JlYWQgPSBmdW5jdGlvbihuKSB7XG4gICAgaWYgKHBhdXNlZCkge1xuICAgICAgcGF1c2VkID0gZmFsc2U7XG4gICAgICBzdHJlYW0ucmVzdW1lKCk7XG4gICAgfVxuICB9O1xuXG4gIHJldHVybiBzZWxmO1xufTtcblxuXG5cbi8vIGV4cG9zZWQgZm9yIHRlc3RpbmcgcHVycG9zZXMgb25seS5cblJlYWRhYmxlLl9mcm9tTGlzdCA9IGZyb21MaXN0O1xuXG4vLyBQbHVjayBvZmYgbiBieXRlcyBmcm9tIGFuIGFycmF5IG9mIGJ1ZmZlcnMuXG4vLyBMZW5ndGggaXMgdGhlIGNvbWJpbmVkIGxlbmd0aHMgb2YgYWxsIHRoZSBidWZmZXJzIGluIHRoZSBsaXN0LlxuZnVuY3Rpb24gZnJvbUxpc3Qobiwgc3RhdGUpIHtcbiAgdmFyIGxpc3QgPSBzdGF0ZS5idWZmZXI7XG4gIHZhciBsZW5ndGggPSBzdGF0ZS5sZW5ndGg7XG4gIHZhciBzdHJpbmdNb2RlID0gISFzdGF0ZS5kZWNvZGVyO1xuICB2YXIgb2JqZWN0TW9kZSA9ICEhc3RhdGUub2JqZWN0TW9kZTtcbiAgdmFyIHJldDtcblxuICAvLyBub3RoaW5nIGluIHRoZSBsaXN0LCBkZWZpbml0ZWx5IGVtcHR5LlxuICBpZiAobGlzdC5sZW5ndGggPT09IDApXG4gICAgcmV0dXJuIG51bGw7XG5cbiAgaWYgKGxlbmd0aCA9PT0gMClcbiAgICByZXQgPSBudWxsO1xuICBlbHNlIGlmIChvYmplY3RNb2RlKVxuICAgIHJldCA9IGxpc3Quc2hpZnQoKTtcbiAgZWxzZSBpZiAoIW4gfHwgbiA+PSBsZW5ndGgpIHtcbiAgICAvLyByZWFkIGl0IGFsbCwgdHJ1bmNhdGUgdGhlIGFycmF5LlxuICAgIGlmIChzdHJpbmdNb2RlKVxuICAgICAgcmV0ID0gbGlzdC5qb2luKCcnKTtcbiAgICBlbHNlXG4gICAgICByZXQgPSBCdWZmZXIuY29uY2F0KGxpc3QsIGxlbmd0aCk7XG4gICAgbGlzdC5sZW5ndGggPSAwO1xuICB9IGVsc2Uge1xuICAgIC8vIHJlYWQganVzdCBzb21lIG9mIGl0LlxuICAgIGlmIChuIDwgbGlzdFswXS5sZW5ndGgpIHtcbiAgICAgIC8vIGp1c3QgdGFrZSBhIHBhcnQgb2YgdGhlIGZpcnN0IGxpc3QgaXRlbS5cbiAgICAgIC8vIHNsaWNlIGlzIHRoZSBzYW1lIGZvciBidWZmZXJzIGFuZCBzdHJpbmdzLlxuICAgICAgdmFyIGJ1ZiA9IGxpc3RbMF07XG4gICAgICByZXQgPSBidWYuc2xpY2UoMCwgbik7XG4gICAgICBsaXN0WzBdID0gYnVmLnNsaWNlKG4pO1xuICAgIH0gZWxzZSBpZiAobiA9PT0gbGlzdFswXS5sZW5ndGgpIHtcbiAgICAgIC8vIGZpcnN0IGxpc3QgaXMgYSBwZXJmZWN0IG1hdGNoXG4gICAgICByZXQgPSBsaXN0LnNoaWZ0KCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIGNvbXBsZXggY2FzZS5cbiAgICAgIC8vIHdlIGhhdmUgZW5vdWdoIHRvIGNvdmVyIGl0LCBidXQgaXQgc3BhbnMgcGFzdCB0aGUgZmlyc3QgYnVmZmVyLlxuICAgICAgaWYgKHN0cmluZ01vZGUpXG4gICAgICAgIHJldCA9ICcnO1xuICAgICAgZWxzZVxuICAgICAgICByZXQgPSBuZXcgQnVmZmVyKG4pO1xuXG4gICAgICB2YXIgYyA9IDA7XG4gICAgICBmb3IgKHZhciBpID0gMCwgbCA9IGxpc3QubGVuZ3RoOyBpIDwgbCAmJiBjIDwgbjsgaSsrKSB7XG4gICAgICAgIHZhciBidWYgPSBsaXN0WzBdO1xuICAgICAgICB2YXIgY3B5ID0gTWF0aC5taW4obiAtIGMsIGJ1Zi5sZW5ndGgpO1xuXG4gICAgICAgIGlmIChzdHJpbmdNb2RlKVxuICAgICAgICAgIHJldCArPSBidWYuc2xpY2UoMCwgY3B5KTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgIGJ1Zi5jb3B5KHJldCwgYywgMCwgY3B5KTtcblxuICAgICAgICBpZiAoY3B5IDwgYnVmLmxlbmd0aClcbiAgICAgICAgICBsaXN0WzBdID0gYnVmLnNsaWNlKGNweSk7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICBsaXN0LnNoaWZ0KCk7XG5cbiAgICAgICAgYyArPSBjcHk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHJldDtcbn1cblxuZnVuY3Rpb24gZW5kUmVhZGFibGUoc3RyZWFtKSB7XG4gIHZhciBzdGF0ZSA9IHN0cmVhbS5fcmVhZGFibGVTdGF0ZTtcblxuICAvLyBJZiB3ZSBnZXQgaGVyZSBiZWZvcmUgY29uc3VtaW5nIGFsbCB0aGUgYnl0ZXMsIHRoZW4gdGhhdCBpcyBhXG4gIC8vIGJ1ZyBpbiBub2RlLiAgU2hvdWxkIG5ldmVyIGhhcHBlbi5cbiAgaWYgKHN0YXRlLmxlbmd0aCA+IDApXG4gICAgdGhyb3cgbmV3IEVycm9yKCdlbmRSZWFkYWJsZSBjYWxsZWQgb24gbm9uLWVtcHR5IHN0cmVhbScpO1xuXG4gIGlmICghc3RhdGUuZW5kRW1pdHRlZCAmJiBzdGF0ZS5jYWxsZWRSZWFkKSB7XG4gICAgc3RhdGUuZW5kZWQgPSB0cnVlO1xuICAgIHNldEltbWVkaWF0ZShmdW5jdGlvbigpIHtcbiAgICAgIC8vIENoZWNrIHRoYXQgd2UgZGlkbid0IGdldCBvbmUgbGFzdCB1bnNoaWZ0LlxuICAgICAgaWYgKCFzdGF0ZS5lbmRFbWl0dGVkICYmIHN0YXRlLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICBzdGF0ZS5lbmRFbWl0dGVkID0gdHJ1ZTtcbiAgICAgICAgc3RyZWFtLnJlYWRhYmxlID0gZmFsc2U7XG4gICAgICAgIHN0cmVhbS5lbWl0KCdlbmQnKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxufVxuXG5mdW5jdGlvbiBmb3JFYWNoICh4cywgZikge1xuICBmb3IgKHZhciBpID0gMCwgbCA9IHhzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgIGYoeHNbaV0sIGkpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGluZGV4T2YgKHhzLCB4KSB7XG4gIGZvciAodmFyIGkgPSAwLCBsID0geHMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgaWYgKHhzW2ldID09PSB4KSByZXR1cm4gaTtcbiAgfVxuICByZXR1cm4gLTE7XG59XG5cbn0pLmNhbGwodGhpcyxyZXF1aXJlKFwiN1lLSVBlXCIpKSIsIi8vIENvcHlyaWdodCBKb3llbnQsIEluYy4gYW5kIG90aGVyIE5vZGUgY29udHJpYnV0b3JzLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhXG4vLyBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlXG4vLyBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmdcbi8vIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCxcbi8vIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXRcbi8vIHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZVxuLy8gZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWRcbi8vIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1Ncbi8vIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0Zcbi8vIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU5cbi8vIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLFxuLy8gREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SXG4vLyBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFXG4vLyBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuXG4vLyBhIHRyYW5zZm9ybSBzdHJlYW0gaXMgYSByZWFkYWJsZS93cml0YWJsZSBzdHJlYW0gd2hlcmUgeW91IGRvXG4vLyBzb21ldGhpbmcgd2l0aCB0aGUgZGF0YS4gIFNvbWV0aW1lcyBpdCdzIGNhbGxlZCBhIFwiZmlsdGVyXCIsXG4vLyBidXQgdGhhdCdzIG5vdCBhIGdyZWF0IG5hbWUgZm9yIGl0LCBzaW5jZSB0aGF0IGltcGxpZXMgYSB0aGluZyB3aGVyZVxuLy8gc29tZSBiaXRzIHBhc3MgdGhyb3VnaCwgYW5kIG90aGVycyBhcmUgc2ltcGx5IGlnbm9yZWQuICAoVGhhdCB3b3VsZFxuLy8gYmUgYSB2YWxpZCBleGFtcGxlIG9mIGEgdHJhbnNmb3JtLCBvZiBjb3Vyc2UuKVxuLy9cbi8vIFdoaWxlIHRoZSBvdXRwdXQgaXMgY2F1c2FsbHkgcmVsYXRlZCB0byB0aGUgaW5wdXQsIGl0J3Mgbm90IGFcbi8vIG5lY2Vzc2FyaWx5IHN5bW1ldHJpYyBvciBzeW5jaHJvbm91cyB0cmFuc2Zvcm1hdGlvbi4gIEZvciBleGFtcGxlLFxuLy8gYSB6bGliIHN0cmVhbSBtaWdodCB0YWtlIG11bHRpcGxlIHBsYWluLXRleHQgd3JpdGVzKCksIGFuZCB0aGVuXG4vLyBlbWl0IGEgc2luZ2xlIGNvbXByZXNzZWQgY2h1bmsgc29tZSB0aW1lIGluIHRoZSBmdXR1cmUuXG4vL1xuLy8gSGVyZSdzIGhvdyB0aGlzIHdvcmtzOlxuLy9cbi8vIFRoZSBUcmFuc2Zvcm0gc3RyZWFtIGhhcyBhbGwgdGhlIGFzcGVjdHMgb2YgdGhlIHJlYWRhYmxlIGFuZCB3cml0YWJsZVxuLy8gc3RyZWFtIGNsYXNzZXMuICBXaGVuIHlvdSB3cml0ZShjaHVuayksIHRoYXQgY2FsbHMgX3dyaXRlKGNodW5rLGNiKVxuLy8gaW50ZXJuYWxseSwgYW5kIHJldHVybnMgZmFsc2UgaWYgdGhlcmUncyBhIGxvdCBvZiBwZW5kaW5nIHdyaXRlc1xuLy8gYnVmZmVyZWQgdXAuICBXaGVuIHlvdSBjYWxsIHJlYWQoKSwgdGhhdCBjYWxscyBfcmVhZChuKSB1bnRpbFxuLy8gdGhlcmUncyBlbm91Z2ggcGVuZGluZyByZWFkYWJsZSBkYXRhIGJ1ZmZlcmVkIHVwLlxuLy9cbi8vIEluIGEgdHJhbnNmb3JtIHN0cmVhbSwgdGhlIHdyaXR0ZW4gZGF0YSBpcyBwbGFjZWQgaW4gYSBidWZmZXIuICBXaGVuXG4vLyBfcmVhZChuKSBpcyBjYWxsZWQsIGl0IHRyYW5zZm9ybXMgdGhlIHF1ZXVlZCB1cCBkYXRhLCBjYWxsaW5nIHRoZVxuLy8gYnVmZmVyZWQgX3dyaXRlIGNiJ3MgYXMgaXQgY29uc3VtZXMgY2h1bmtzLiAgSWYgY29uc3VtaW5nIGEgc2luZ2xlXG4vLyB3cml0dGVuIGNodW5rIHdvdWxkIHJlc3VsdCBpbiBtdWx0aXBsZSBvdXRwdXQgY2h1bmtzLCB0aGVuIHRoZSBmaXJzdFxuLy8gb3V0cHV0dGVkIGJpdCBjYWxscyB0aGUgcmVhZGNiLCBhbmQgc3Vic2VxdWVudCBjaHVua3MganVzdCBnbyBpbnRvXG4vLyB0aGUgcmVhZCBidWZmZXIsIGFuZCB3aWxsIGNhdXNlIGl0IHRvIGVtaXQgJ3JlYWRhYmxlJyBpZiBuZWNlc3NhcnkuXG4vL1xuLy8gVGhpcyB3YXksIGJhY2stcHJlc3N1cmUgaXMgYWN0dWFsbHkgZGV0ZXJtaW5lZCBieSB0aGUgcmVhZGluZyBzaWRlLFxuLy8gc2luY2UgX3JlYWQgaGFzIHRvIGJlIGNhbGxlZCB0byBzdGFydCBwcm9jZXNzaW5nIGEgbmV3IGNodW5rLiAgSG93ZXZlcixcbi8vIGEgcGF0aG9sb2dpY2FsIGluZmxhdGUgdHlwZSBvZiB0cmFuc2Zvcm0gY2FuIGNhdXNlIGV4Y2Vzc2l2ZSBidWZmZXJpbmdcbi8vIGhlcmUuICBGb3IgZXhhbXBsZSwgaW1hZ2luZSBhIHN0cmVhbSB3aGVyZSBldmVyeSBieXRlIG9mIGlucHV0IGlzXG4vLyBpbnRlcnByZXRlZCBhcyBhbiBpbnRlZ2VyIGZyb20gMC0yNTUsIGFuZCB0aGVuIHJlc3VsdHMgaW4gdGhhdCBtYW55XG4vLyBieXRlcyBvZiBvdXRwdXQuICBXcml0aW5nIHRoZSA0IGJ5dGVzIHtmZixmZixmZixmZn0gd291bGQgcmVzdWx0IGluXG4vLyAxa2Igb2YgZGF0YSBiZWluZyBvdXRwdXQuICBJbiB0aGlzIGNhc2UsIHlvdSBjb3VsZCB3cml0ZSBhIHZlcnkgc21hbGxcbi8vIGFtb3VudCBvZiBpbnB1dCwgYW5kIGVuZCB1cCB3aXRoIGEgdmVyeSBsYXJnZSBhbW91bnQgb2Ygb3V0cHV0LiAgSW5cbi8vIHN1Y2ggYSBwYXRob2xvZ2ljYWwgaW5mbGF0aW5nIG1lY2hhbmlzbSwgdGhlcmUnZCBiZSBubyB3YXkgdG8gdGVsbFxuLy8gdGhlIHN5c3RlbSB0byBzdG9wIGRvaW5nIHRoZSB0cmFuc2Zvcm0uICBBIHNpbmdsZSA0TUIgd3JpdGUgY291bGRcbi8vIGNhdXNlIHRoZSBzeXN0ZW0gdG8gcnVuIG91dCBvZiBtZW1vcnkuXG4vL1xuLy8gSG93ZXZlciwgZXZlbiBpbiBzdWNoIGEgcGF0aG9sb2dpY2FsIGNhc2UsIG9ubHkgYSBzaW5nbGUgd3JpdHRlbiBjaHVua1xuLy8gd291bGQgYmUgY29uc3VtZWQsIGFuZCB0aGVuIHRoZSByZXN0IHdvdWxkIHdhaXQgKHVuLXRyYW5zZm9ybWVkKSB1bnRpbFxuLy8gdGhlIHJlc3VsdHMgb2YgdGhlIHByZXZpb3VzIHRyYW5zZm9ybWVkIGNodW5rIHdlcmUgY29uc3VtZWQuXG5cbm1vZHVsZS5leHBvcnRzID0gVHJhbnNmb3JtO1xuXG52YXIgRHVwbGV4ID0gcmVxdWlyZSgnLi9kdXBsZXguanMnKTtcbnZhciBpbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJyk7XG5pbmhlcml0cyhUcmFuc2Zvcm0sIER1cGxleCk7XG5cblxuZnVuY3Rpb24gVHJhbnNmb3JtU3RhdGUob3B0aW9ucywgc3RyZWFtKSB7XG4gIHRoaXMuYWZ0ZXJUcmFuc2Zvcm0gPSBmdW5jdGlvbihlciwgZGF0YSkge1xuICAgIHJldHVybiBhZnRlclRyYW5zZm9ybShzdHJlYW0sIGVyLCBkYXRhKTtcbiAgfTtcblxuICB0aGlzLm5lZWRUcmFuc2Zvcm0gPSBmYWxzZTtcbiAgdGhpcy50cmFuc2Zvcm1pbmcgPSBmYWxzZTtcbiAgdGhpcy53cml0ZWNiID0gbnVsbDtcbiAgdGhpcy53cml0ZWNodW5rID0gbnVsbDtcbn1cblxuZnVuY3Rpb24gYWZ0ZXJUcmFuc2Zvcm0oc3RyZWFtLCBlciwgZGF0YSkge1xuICB2YXIgdHMgPSBzdHJlYW0uX3RyYW5zZm9ybVN0YXRlO1xuICB0cy50cmFuc2Zvcm1pbmcgPSBmYWxzZTtcblxuICB2YXIgY2IgPSB0cy53cml0ZWNiO1xuXG4gIGlmICghY2IpXG4gICAgcmV0dXJuIHN0cmVhbS5lbWl0KCdlcnJvcicsIG5ldyBFcnJvcignbm8gd3JpdGVjYiBpbiBUcmFuc2Zvcm0gY2xhc3MnKSk7XG5cbiAgdHMud3JpdGVjaHVuayA9IG51bGw7XG4gIHRzLndyaXRlY2IgPSBudWxsO1xuXG4gIGlmIChkYXRhICE9PSBudWxsICYmIGRhdGEgIT09IHVuZGVmaW5lZClcbiAgICBzdHJlYW0ucHVzaChkYXRhKTtcblxuICBpZiAoY2IpXG4gICAgY2IoZXIpO1xuXG4gIHZhciBycyA9IHN0cmVhbS5fcmVhZGFibGVTdGF0ZTtcbiAgcnMucmVhZGluZyA9IGZhbHNlO1xuICBpZiAocnMubmVlZFJlYWRhYmxlIHx8IHJzLmxlbmd0aCA8IHJzLmhpZ2hXYXRlck1hcmspIHtcbiAgICBzdHJlYW0uX3JlYWQocnMuaGlnaFdhdGVyTWFyayk7XG4gIH1cbn1cblxuXG5mdW5jdGlvbiBUcmFuc2Zvcm0ob3B0aW9ucykge1xuICBpZiAoISh0aGlzIGluc3RhbmNlb2YgVHJhbnNmb3JtKSlcbiAgICByZXR1cm4gbmV3IFRyYW5zZm9ybShvcHRpb25zKTtcblxuICBEdXBsZXguY2FsbCh0aGlzLCBvcHRpb25zKTtcblxuICB2YXIgdHMgPSB0aGlzLl90cmFuc2Zvcm1TdGF0ZSA9IG5ldyBUcmFuc2Zvcm1TdGF0ZShvcHRpb25zLCB0aGlzKTtcblxuICAvLyB3aGVuIHRoZSB3cml0YWJsZSBzaWRlIGZpbmlzaGVzLCB0aGVuIGZsdXNoIG91dCBhbnl0aGluZyByZW1haW5pbmcuXG4gIHZhciBzdHJlYW0gPSB0aGlzO1xuXG4gIC8vIHN0YXJ0IG91dCBhc2tpbmcgZm9yIGEgcmVhZGFibGUgZXZlbnQgb25jZSBkYXRhIGlzIHRyYW5zZm9ybWVkLlxuICB0aGlzLl9yZWFkYWJsZVN0YXRlLm5lZWRSZWFkYWJsZSA9IHRydWU7XG5cbiAgLy8gd2UgaGF2ZSBpbXBsZW1lbnRlZCB0aGUgX3JlYWQgbWV0aG9kLCBhbmQgZG9uZSB0aGUgb3RoZXIgdGhpbmdzXG4gIC8vIHRoYXQgUmVhZGFibGUgd2FudHMgYmVmb3JlIHRoZSBmaXJzdCBfcmVhZCBjYWxsLCBzbyB1bnNldCB0aGVcbiAgLy8gc3luYyBndWFyZCBmbGFnLlxuICB0aGlzLl9yZWFkYWJsZVN0YXRlLnN5bmMgPSBmYWxzZTtcblxuICB0aGlzLm9uY2UoJ2ZpbmlzaCcsIGZ1bmN0aW9uKCkge1xuICAgIGlmICgnZnVuY3Rpb24nID09PSB0eXBlb2YgdGhpcy5fZmx1c2gpXG4gICAgICB0aGlzLl9mbHVzaChmdW5jdGlvbihlcikge1xuICAgICAgICBkb25lKHN0cmVhbSwgZXIpO1xuICAgICAgfSk7XG4gICAgZWxzZVxuICAgICAgZG9uZShzdHJlYW0pO1xuICB9KTtcbn1cblxuVHJhbnNmb3JtLnByb3RvdHlwZS5wdXNoID0gZnVuY3Rpb24oY2h1bmssIGVuY29kaW5nKSB7XG4gIHRoaXMuX3RyYW5zZm9ybVN0YXRlLm5lZWRUcmFuc2Zvcm0gPSBmYWxzZTtcbiAgcmV0dXJuIER1cGxleC5wcm90b3R5cGUucHVzaC5jYWxsKHRoaXMsIGNodW5rLCBlbmNvZGluZyk7XG59O1xuXG4vLyBUaGlzIGlzIHRoZSBwYXJ0IHdoZXJlIHlvdSBkbyBzdHVmZiFcbi8vIG92ZXJyaWRlIHRoaXMgZnVuY3Rpb24gaW4gaW1wbGVtZW50YXRpb24gY2xhc3Nlcy5cbi8vICdjaHVuaycgaXMgYW4gaW5wdXQgY2h1bmsuXG4vL1xuLy8gQ2FsbCBgcHVzaChuZXdDaHVuaylgIHRvIHBhc3MgYWxvbmcgdHJhbnNmb3JtZWQgb3V0cHV0XG4vLyB0byB0aGUgcmVhZGFibGUgc2lkZS4gIFlvdSBtYXkgY2FsbCAncHVzaCcgemVybyBvciBtb3JlIHRpbWVzLlxuLy9cbi8vIENhbGwgYGNiKGVycilgIHdoZW4geW91IGFyZSBkb25lIHdpdGggdGhpcyBjaHVuay4gIElmIHlvdSBwYXNzXG4vLyBhbiBlcnJvciwgdGhlbiB0aGF0J2xsIHB1dCB0aGUgaHVydCBvbiB0aGUgd2hvbGUgb3BlcmF0aW9uLiAgSWYgeW91XG4vLyBuZXZlciBjYWxsIGNiKCksIHRoZW4geW91J2xsIG5ldmVyIGdldCBhbm90aGVyIGNodW5rLlxuVHJhbnNmb3JtLnByb3RvdHlwZS5fdHJhbnNmb3JtID0gZnVuY3Rpb24oY2h1bmssIGVuY29kaW5nLCBjYikge1xuICB0aHJvdyBuZXcgRXJyb3IoJ25vdCBpbXBsZW1lbnRlZCcpO1xufTtcblxuVHJhbnNmb3JtLnByb3RvdHlwZS5fd3JpdGUgPSBmdW5jdGlvbihjaHVuaywgZW5jb2RpbmcsIGNiKSB7XG4gIHZhciB0cyA9IHRoaXMuX3RyYW5zZm9ybVN0YXRlO1xuICB0cy53cml0ZWNiID0gY2I7XG4gIHRzLndyaXRlY2h1bmsgPSBjaHVuaztcbiAgdHMud3JpdGVlbmNvZGluZyA9IGVuY29kaW5nO1xuICBpZiAoIXRzLnRyYW5zZm9ybWluZykge1xuICAgIHZhciBycyA9IHRoaXMuX3JlYWRhYmxlU3RhdGU7XG4gICAgaWYgKHRzLm5lZWRUcmFuc2Zvcm0gfHxcbiAgICAgICAgcnMubmVlZFJlYWRhYmxlIHx8XG4gICAgICAgIHJzLmxlbmd0aCA8IHJzLmhpZ2hXYXRlck1hcmspXG4gICAgICB0aGlzLl9yZWFkKHJzLmhpZ2hXYXRlck1hcmspO1xuICB9XG59O1xuXG4vLyBEb2Vzbid0IG1hdHRlciB3aGF0IHRoZSBhcmdzIGFyZSBoZXJlLlxuLy8gX3RyYW5zZm9ybSBkb2VzIGFsbCB0aGUgd29yay5cbi8vIFRoYXQgd2UgZ290IGhlcmUgbWVhbnMgdGhhdCB0aGUgcmVhZGFibGUgc2lkZSB3YW50cyBtb3JlIGRhdGEuXG5UcmFuc2Zvcm0ucHJvdG90eXBlLl9yZWFkID0gZnVuY3Rpb24obikge1xuICB2YXIgdHMgPSB0aGlzLl90cmFuc2Zvcm1TdGF0ZTtcblxuICBpZiAodHMud3JpdGVjaHVuayAmJiB0cy53cml0ZWNiICYmICF0cy50cmFuc2Zvcm1pbmcpIHtcbiAgICB0cy50cmFuc2Zvcm1pbmcgPSB0cnVlO1xuICAgIHRoaXMuX3RyYW5zZm9ybSh0cy53cml0ZWNodW5rLCB0cy53cml0ZWVuY29kaW5nLCB0cy5hZnRlclRyYW5zZm9ybSk7XG4gIH0gZWxzZSB7XG4gICAgLy8gbWFyayB0aGF0IHdlIG5lZWQgYSB0cmFuc2Zvcm0sIHNvIHRoYXQgYW55IGRhdGEgdGhhdCBjb21lcyBpblxuICAgIC8vIHdpbGwgZ2V0IHByb2Nlc3NlZCwgbm93IHRoYXQgd2UndmUgYXNrZWQgZm9yIGl0LlxuICAgIHRzLm5lZWRUcmFuc2Zvcm0gPSB0cnVlO1xuICB9XG59O1xuXG5cbmZ1bmN0aW9uIGRvbmUoc3RyZWFtLCBlcikge1xuICBpZiAoZXIpXG4gICAgcmV0dXJuIHN0cmVhbS5lbWl0KCdlcnJvcicsIGVyKTtcblxuICAvLyBpZiB0aGVyZSdzIG5vdGhpbmcgaW4gdGhlIHdyaXRlIGJ1ZmZlciwgdGhlbiB0aGF0IG1lYW5zXG4gIC8vIHRoYXQgbm90aGluZyBtb3JlIHdpbGwgZXZlciBiZSBwcm92aWRlZFxuICB2YXIgd3MgPSBzdHJlYW0uX3dyaXRhYmxlU3RhdGU7XG4gIHZhciBycyA9IHN0cmVhbS5fcmVhZGFibGVTdGF0ZTtcbiAgdmFyIHRzID0gc3RyZWFtLl90cmFuc2Zvcm1TdGF0ZTtcblxuICBpZiAod3MubGVuZ3RoKVxuICAgIHRocm93IG5ldyBFcnJvcignY2FsbGluZyB0cmFuc2Zvcm0gZG9uZSB3aGVuIHdzLmxlbmd0aCAhPSAwJyk7XG5cbiAgaWYgKHRzLnRyYW5zZm9ybWluZylcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2NhbGxpbmcgdHJhbnNmb3JtIGRvbmUgd2hlbiBzdGlsbCB0cmFuc2Zvcm1pbmcnKTtcblxuICByZXR1cm4gc3RyZWFtLnB1c2gobnVsbCk7XG59XG4iLCIvLyBDb3B5cmlnaHQgSm95ZW50LCBJbmMuIGFuZCBvdGhlciBOb2RlIGNvbnRyaWJ1dG9ycy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxuLy8gY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxuLy8gXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXG4vLyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXG4vLyBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0XG4vLyBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGVcbi8vIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkXG4vLyBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTXG4vLyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4vLyBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOXG4vLyBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSxcbi8vIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUlxuLy8gT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRVxuLy8gVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cblxuLy8gQSBiaXQgc2ltcGxlciB0aGFuIHJlYWRhYmxlIHN0cmVhbXMuXG4vLyBJbXBsZW1lbnQgYW4gYXN5bmMgLl93cml0ZShjaHVuaywgY2IpLCBhbmQgaXQnbGwgaGFuZGxlIGFsbFxuLy8gdGhlIGRyYWluIGV2ZW50IGVtaXNzaW9uIGFuZCBidWZmZXJpbmcuXG5cbm1vZHVsZS5leHBvcnRzID0gV3JpdGFibGU7XG5Xcml0YWJsZS5Xcml0YWJsZVN0YXRlID0gV3JpdGFibGVTdGF0ZTtcblxudmFyIGlzVWludDhBcnJheSA9IHR5cGVvZiBVaW50OEFycmF5ICE9PSAndW5kZWZpbmVkJ1xuICA/IGZ1bmN0aW9uICh4KSB7IHJldHVybiB4IGluc3RhbmNlb2YgVWludDhBcnJheSB9XG4gIDogZnVuY3Rpb24gKHgpIHtcbiAgICByZXR1cm4geCAmJiB4LmNvbnN0cnVjdG9yICYmIHguY29uc3RydWN0b3IubmFtZSA9PT0gJ1VpbnQ4QXJyYXknXG4gIH1cbjtcbnZhciBpc0FycmF5QnVmZmVyID0gdHlwZW9mIEFycmF5QnVmZmVyICE9PSAndW5kZWZpbmVkJ1xuICA/IGZ1bmN0aW9uICh4KSB7IHJldHVybiB4IGluc3RhbmNlb2YgQXJyYXlCdWZmZXIgfVxuICA6IGZ1bmN0aW9uICh4KSB7XG4gICAgcmV0dXJuIHggJiYgeC5jb25zdHJ1Y3RvciAmJiB4LmNvbnN0cnVjdG9yLm5hbWUgPT09ICdBcnJheUJ1ZmZlcidcbiAgfVxuO1xuXG52YXIgaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpO1xudmFyIFN0cmVhbSA9IHJlcXVpcmUoJy4vaW5kZXguanMnKTtcbnZhciBzZXRJbW1lZGlhdGUgPSByZXF1aXJlKCdwcm9jZXNzL2Jyb3dzZXIuanMnKS5uZXh0VGljaztcbnZhciBCdWZmZXIgPSByZXF1aXJlKCdidWZmZXInKS5CdWZmZXI7XG5cbmluaGVyaXRzKFdyaXRhYmxlLCBTdHJlYW0pO1xuXG5mdW5jdGlvbiBXcml0ZVJlcShjaHVuaywgZW5jb2RpbmcsIGNiKSB7XG4gIHRoaXMuY2h1bmsgPSBjaHVuaztcbiAgdGhpcy5lbmNvZGluZyA9IGVuY29kaW5nO1xuICB0aGlzLmNhbGxiYWNrID0gY2I7XG59XG5cbmZ1bmN0aW9uIFdyaXRhYmxlU3RhdGUob3B0aW9ucywgc3RyZWFtKSB7XG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG4gIC8vIHRoZSBwb2ludCBhdCB3aGljaCB3cml0ZSgpIHN0YXJ0cyByZXR1cm5pbmcgZmFsc2VcbiAgLy8gTm90ZTogMCBpcyBhIHZhbGlkIHZhbHVlLCBtZWFucyB0aGF0IHdlIGFsd2F5cyByZXR1cm4gZmFsc2UgaWZcbiAgLy8gdGhlIGVudGlyZSBidWZmZXIgaXMgbm90IGZsdXNoZWQgaW1tZWRpYXRlbHkgb24gd3JpdGUoKVxuICB2YXIgaHdtID0gb3B0aW9ucy5oaWdoV2F0ZXJNYXJrO1xuICB0aGlzLmhpZ2hXYXRlck1hcmsgPSAoaHdtIHx8IGh3bSA9PT0gMCkgPyBod20gOiAxNiAqIDEwMjQ7XG5cbiAgLy8gb2JqZWN0IHN0cmVhbSBmbGFnIHRvIGluZGljYXRlIHdoZXRoZXIgb3Igbm90IHRoaXMgc3RyZWFtXG4gIC8vIGNvbnRhaW5zIGJ1ZmZlcnMgb3Igb2JqZWN0cy5cbiAgdGhpcy5vYmplY3RNb2RlID0gISFvcHRpb25zLm9iamVjdE1vZGU7XG5cbiAgLy8gY2FzdCB0byBpbnRzLlxuICB0aGlzLmhpZ2hXYXRlck1hcmsgPSB+fnRoaXMuaGlnaFdhdGVyTWFyaztcblxuICB0aGlzLm5lZWREcmFpbiA9IGZhbHNlO1xuICAvLyBhdCB0aGUgc3RhcnQgb2YgY2FsbGluZyBlbmQoKVxuICB0aGlzLmVuZGluZyA9IGZhbHNlO1xuICAvLyB3aGVuIGVuZCgpIGhhcyBiZWVuIGNhbGxlZCwgYW5kIHJldHVybmVkXG4gIHRoaXMuZW5kZWQgPSBmYWxzZTtcbiAgLy8gd2hlbiAnZmluaXNoJyBpcyBlbWl0dGVkXG4gIHRoaXMuZmluaXNoZWQgPSBmYWxzZTtcblxuICAvLyBzaG91bGQgd2UgZGVjb2RlIHN0cmluZ3MgaW50byBidWZmZXJzIGJlZm9yZSBwYXNzaW5nIHRvIF93cml0ZT9cbiAgLy8gdGhpcyBpcyBoZXJlIHNvIHRoYXQgc29tZSBub2RlLWNvcmUgc3RyZWFtcyBjYW4gb3B0aW1pemUgc3RyaW5nXG4gIC8vIGhhbmRsaW5nIGF0IGEgbG93ZXIgbGV2ZWwuXG4gIHZhciBub0RlY29kZSA9IG9wdGlvbnMuZGVjb2RlU3RyaW5ncyA9PT0gZmFsc2U7XG4gIHRoaXMuZGVjb2RlU3RyaW5ncyA9ICFub0RlY29kZTtcblxuICAvLyBDcnlwdG8gaXMga2luZCBvZiBvbGQgYW5kIGNydXN0eS4gIEhpc3RvcmljYWxseSwgaXRzIGRlZmF1bHQgc3RyaW5nXG4gIC8vIGVuY29kaW5nIGlzICdiaW5hcnknIHNvIHdlIGhhdmUgdG8gbWFrZSB0aGlzIGNvbmZpZ3VyYWJsZS5cbiAgLy8gRXZlcnl0aGluZyBlbHNlIGluIHRoZSB1bml2ZXJzZSB1c2VzICd1dGY4JywgdGhvdWdoLlxuICB0aGlzLmRlZmF1bHRFbmNvZGluZyA9IG9wdGlvbnMuZGVmYXVsdEVuY29kaW5nIHx8ICd1dGY4JztcblxuICAvLyBub3QgYW4gYWN0dWFsIGJ1ZmZlciB3ZSBrZWVwIHRyYWNrIG9mLCBidXQgYSBtZWFzdXJlbWVudFxuICAvLyBvZiBob3cgbXVjaCB3ZSdyZSB3YWl0aW5nIHRvIGdldCBwdXNoZWQgdG8gc29tZSB1bmRlcmx5aW5nXG4gIC8vIHNvY2tldCBvciBmaWxlLlxuICB0aGlzLmxlbmd0aCA9IDA7XG5cbiAgLy8gYSBmbGFnIHRvIHNlZSB3aGVuIHdlJ3JlIGluIHRoZSBtaWRkbGUgb2YgYSB3cml0ZS5cbiAgdGhpcy53cml0aW5nID0gZmFsc2U7XG5cbiAgLy8gYSBmbGFnIHRvIGJlIGFibGUgdG8gdGVsbCBpZiB0aGUgb253cml0ZSBjYiBpcyBjYWxsZWQgaW1tZWRpYXRlbHksXG4gIC8vIG9yIG9uIGEgbGF0ZXIgdGljay4gIFdlIHNldCB0aGlzIHRvIHRydWUgYXQgZmlyc3QsIGJlY3Vhc2UgYW55XG4gIC8vIGFjdGlvbnMgdGhhdCBzaG91bGRuJ3QgaGFwcGVuIHVudGlsIFwibGF0ZXJcIiBzaG91bGQgZ2VuZXJhbGx5IGFsc29cbiAgLy8gbm90IGhhcHBlbiBiZWZvcmUgdGhlIGZpcnN0IHdyaXRlIGNhbGwuXG4gIHRoaXMuc3luYyA9IHRydWU7XG5cbiAgLy8gYSBmbGFnIHRvIGtub3cgaWYgd2UncmUgcHJvY2Vzc2luZyBwcmV2aW91c2x5IGJ1ZmZlcmVkIGl0ZW1zLCB3aGljaFxuICAvLyBtYXkgY2FsbCB0aGUgX3dyaXRlKCkgY2FsbGJhY2sgaW4gdGhlIHNhbWUgdGljaywgc28gdGhhdCB3ZSBkb24ndFxuICAvLyBlbmQgdXAgaW4gYW4gb3ZlcmxhcHBlZCBvbndyaXRlIHNpdHVhdGlvbi5cbiAgdGhpcy5idWZmZXJQcm9jZXNzaW5nID0gZmFsc2U7XG5cbiAgLy8gdGhlIGNhbGxiYWNrIHRoYXQncyBwYXNzZWQgdG8gX3dyaXRlKGNodW5rLGNiKVxuICB0aGlzLm9ud3JpdGUgPSBmdW5jdGlvbihlcikge1xuICAgIG9ud3JpdGUoc3RyZWFtLCBlcik7XG4gIH07XG5cbiAgLy8gdGhlIGNhbGxiYWNrIHRoYXQgdGhlIHVzZXIgc3VwcGxpZXMgdG8gd3JpdGUoY2h1bmssZW5jb2RpbmcsY2IpXG4gIHRoaXMud3JpdGVjYiA9IG51bGw7XG5cbiAgLy8gdGhlIGFtb3VudCB0aGF0IGlzIGJlaW5nIHdyaXR0ZW4gd2hlbiBfd3JpdGUgaXMgY2FsbGVkLlxuICB0aGlzLndyaXRlbGVuID0gMDtcblxuICB0aGlzLmJ1ZmZlciA9IFtdO1xufVxuXG5mdW5jdGlvbiBXcml0YWJsZShvcHRpb25zKSB7XG4gIC8vIFdyaXRhYmxlIGN0b3IgaXMgYXBwbGllZCB0byBEdXBsZXhlcywgdGhvdWdoIHRoZXkncmUgbm90XG4gIC8vIGluc3RhbmNlb2YgV3JpdGFibGUsIHRoZXkncmUgaW5zdGFuY2VvZiBSZWFkYWJsZS5cbiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIFdyaXRhYmxlKSAmJiAhKHRoaXMgaW5zdGFuY2VvZiBTdHJlYW0uRHVwbGV4KSlcbiAgICByZXR1cm4gbmV3IFdyaXRhYmxlKG9wdGlvbnMpO1xuXG4gIHRoaXMuX3dyaXRhYmxlU3RhdGUgPSBuZXcgV3JpdGFibGVTdGF0ZShvcHRpb25zLCB0aGlzKTtcblxuICAvLyBsZWdhY3kuXG4gIHRoaXMud3JpdGFibGUgPSB0cnVlO1xuXG4gIFN0cmVhbS5jYWxsKHRoaXMpO1xufVxuXG4vLyBPdGhlcndpc2UgcGVvcGxlIGNhbiBwaXBlIFdyaXRhYmxlIHN0cmVhbXMsIHdoaWNoIGlzIGp1c3Qgd3JvbmcuXG5Xcml0YWJsZS5wcm90b3R5cGUucGlwZSA9IGZ1bmN0aW9uKCkge1xuICB0aGlzLmVtaXQoJ2Vycm9yJywgbmV3IEVycm9yKCdDYW5ub3QgcGlwZS4gTm90IHJlYWRhYmxlLicpKTtcbn07XG5cblxuZnVuY3Rpb24gd3JpdGVBZnRlckVuZChzdHJlYW0sIHN0YXRlLCBjYikge1xuICB2YXIgZXIgPSBuZXcgRXJyb3IoJ3dyaXRlIGFmdGVyIGVuZCcpO1xuICAvLyBUT0RPOiBkZWZlciBlcnJvciBldmVudHMgY29uc2lzdGVudGx5IGV2ZXJ5d2hlcmUsIG5vdCBqdXN0IHRoZSBjYlxuICBzdHJlYW0uZW1pdCgnZXJyb3InLCBlcik7XG4gIHNldEltbWVkaWF0ZShmdW5jdGlvbigpIHtcbiAgICBjYihlcik7XG4gIH0pO1xufVxuXG4vLyBJZiB3ZSBnZXQgc29tZXRoaW5nIHRoYXQgaXMgbm90IGEgYnVmZmVyLCBzdHJpbmcsIG51bGwsIG9yIHVuZGVmaW5lZCxcbi8vIGFuZCB3ZSdyZSBub3QgaW4gb2JqZWN0TW9kZSwgdGhlbiB0aGF0J3MgYW4gZXJyb3IuXG4vLyBPdGhlcndpc2Ugc3RyZWFtIGNodW5rcyBhcmUgYWxsIGNvbnNpZGVyZWQgdG8gYmUgb2YgbGVuZ3RoPTEsIGFuZCB0aGVcbi8vIHdhdGVybWFya3MgZGV0ZXJtaW5lIGhvdyBtYW55IG9iamVjdHMgdG8ga2VlcCBpbiB0aGUgYnVmZmVyLCByYXRoZXIgdGhhblxuLy8gaG93IG1hbnkgYnl0ZXMgb3IgY2hhcmFjdGVycy5cbmZ1bmN0aW9uIHZhbGlkQ2h1bmsoc3RyZWFtLCBzdGF0ZSwgY2h1bmssIGNiKSB7XG4gIHZhciB2YWxpZCA9IHRydWU7XG4gIGlmICghQnVmZmVyLmlzQnVmZmVyKGNodW5rKSAmJlxuICAgICAgJ3N0cmluZycgIT09IHR5cGVvZiBjaHVuayAmJlxuICAgICAgY2h1bmsgIT09IG51bGwgJiZcbiAgICAgIGNodW5rICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICFzdGF0ZS5vYmplY3RNb2RlKSB7XG4gICAgdmFyIGVyID0gbmV3IFR5cGVFcnJvcignSW52YWxpZCBub24tc3RyaW5nL2J1ZmZlciBjaHVuaycpO1xuICAgIHN0cmVhbS5lbWl0KCdlcnJvcicsIGVyKTtcbiAgICBzZXRJbW1lZGlhdGUoZnVuY3Rpb24oKSB7XG4gICAgICBjYihlcik7XG4gICAgfSk7XG4gICAgdmFsaWQgPSBmYWxzZTtcbiAgfVxuICByZXR1cm4gdmFsaWQ7XG59XG5cbldyaXRhYmxlLnByb3RvdHlwZS53cml0ZSA9IGZ1bmN0aW9uKGNodW5rLCBlbmNvZGluZywgY2IpIHtcbiAgdmFyIHN0YXRlID0gdGhpcy5fd3JpdGFibGVTdGF0ZTtcbiAgdmFyIHJldCA9IGZhbHNlO1xuXG4gIGlmICh0eXBlb2YgZW5jb2RpbmcgPT09ICdmdW5jdGlvbicpIHtcbiAgICBjYiA9IGVuY29kaW5nO1xuICAgIGVuY29kaW5nID0gbnVsbDtcbiAgfVxuXG4gIGlmICghQnVmZmVyLmlzQnVmZmVyKGNodW5rKSAmJiBpc1VpbnQ4QXJyYXkoY2h1bmspKVxuICAgIGNodW5rID0gbmV3IEJ1ZmZlcihjaHVuayk7XG4gIGlmIChpc0FycmF5QnVmZmVyKGNodW5rKSAmJiB0eXBlb2YgVWludDhBcnJheSAhPT0gJ3VuZGVmaW5lZCcpXG4gICAgY2h1bmsgPSBuZXcgQnVmZmVyKG5ldyBVaW50OEFycmF5KGNodW5rKSk7XG4gIFxuICBpZiAoQnVmZmVyLmlzQnVmZmVyKGNodW5rKSlcbiAgICBlbmNvZGluZyA9ICdidWZmZXInO1xuICBlbHNlIGlmICghZW5jb2RpbmcpXG4gICAgZW5jb2RpbmcgPSBzdGF0ZS5kZWZhdWx0RW5jb2Rpbmc7XG5cbiAgaWYgKHR5cGVvZiBjYiAhPT0gJ2Z1bmN0aW9uJylcbiAgICBjYiA9IGZ1bmN0aW9uKCkge307XG5cbiAgaWYgKHN0YXRlLmVuZGVkKVxuICAgIHdyaXRlQWZ0ZXJFbmQodGhpcywgc3RhdGUsIGNiKTtcbiAgZWxzZSBpZiAodmFsaWRDaHVuayh0aGlzLCBzdGF0ZSwgY2h1bmssIGNiKSlcbiAgICByZXQgPSB3cml0ZU9yQnVmZmVyKHRoaXMsIHN0YXRlLCBjaHVuaywgZW5jb2RpbmcsIGNiKTtcblxuICByZXR1cm4gcmV0O1xufTtcblxuZnVuY3Rpb24gZGVjb2RlQ2h1bmsoc3RhdGUsIGNodW5rLCBlbmNvZGluZykge1xuICBpZiAoIXN0YXRlLm9iamVjdE1vZGUgJiZcbiAgICAgIHN0YXRlLmRlY29kZVN0cmluZ3MgIT09IGZhbHNlICYmXG4gICAgICB0eXBlb2YgY2h1bmsgPT09ICdzdHJpbmcnKSB7XG4gICAgY2h1bmsgPSBuZXcgQnVmZmVyKGNodW5rLCBlbmNvZGluZyk7XG4gIH1cbiAgcmV0dXJuIGNodW5rO1xufVxuXG4vLyBpZiB3ZSdyZSBhbHJlYWR5IHdyaXRpbmcgc29tZXRoaW5nLCB0aGVuIGp1c3QgcHV0IHRoaXNcbi8vIGluIHRoZSBxdWV1ZSwgYW5kIHdhaXQgb3VyIHR1cm4uICBPdGhlcndpc2UsIGNhbGwgX3dyaXRlXG4vLyBJZiB3ZSByZXR1cm4gZmFsc2UsIHRoZW4gd2UgbmVlZCBhIGRyYWluIGV2ZW50LCBzbyBzZXQgdGhhdCBmbGFnLlxuZnVuY3Rpb24gd3JpdGVPckJ1ZmZlcihzdHJlYW0sIHN0YXRlLCBjaHVuaywgZW5jb2RpbmcsIGNiKSB7XG4gIGNodW5rID0gZGVjb2RlQ2h1bmsoc3RhdGUsIGNodW5rLCBlbmNvZGluZyk7XG4gIHZhciBsZW4gPSBzdGF0ZS5vYmplY3RNb2RlID8gMSA6IGNodW5rLmxlbmd0aDtcblxuICBzdGF0ZS5sZW5ndGggKz0gbGVuO1xuXG4gIHZhciByZXQgPSBzdGF0ZS5sZW5ndGggPCBzdGF0ZS5oaWdoV2F0ZXJNYXJrO1xuICBzdGF0ZS5uZWVkRHJhaW4gPSAhcmV0O1xuXG4gIGlmIChzdGF0ZS53cml0aW5nKVxuICAgIHN0YXRlLmJ1ZmZlci5wdXNoKG5ldyBXcml0ZVJlcShjaHVuaywgZW5jb2RpbmcsIGNiKSk7XG4gIGVsc2VcbiAgICBkb1dyaXRlKHN0cmVhbSwgc3RhdGUsIGxlbiwgY2h1bmssIGVuY29kaW5nLCBjYik7XG5cbiAgcmV0dXJuIHJldDtcbn1cblxuZnVuY3Rpb24gZG9Xcml0ZShzdHJlYW0sIHN0YXRlLCBsZW4sIGNodW5rLCBlbmNvZGluZywgY2IpIHtcbiAgc3RhdGUud3JpdGVsZW4gPSBsZW47XG4gIHN0YXRlLndyaXRlY2IgPSBjYjtcbiAgc3RhdGUud3JpdGluZyA9IHRydWU7XG4gIHN0YXRlLnN5bmMgPSB0cnVlO1xuICBzdHJlYW0uX3dyaXRlKGNodW5rLCBlbmNvZGluZywgc3RhdGUub253cml0ZSk7XG4gIHN0YXRlLnN5bmMgPSBmYWxzZTtcbn1cblxuZnVuY3Rpb24gb253cml0ZUVycm9yKHN0cmVhbSwgc3RhdGUsIHN5bmMsIGVyLCBjYikge1xuICBpZiAoc3luYylcbiAgICBzZXRJbW1lZGlhdGUoZnVuY3Rpb24oKSB7XG4gICAgICBjYihlcik7XG4gICAgfSk7XG4gIGVsc2VcbiAgICBjYihlcik7XG5cbiAgc3RyZWFtLmVtaXQoJ2Vycm9yJywgZXIpO1xufVxuXG5mdW5jdGlvbiBvbndyaXRlU3RhdGVVcGRhdGUoc3RhdGUpIHtcbiAgc3RhdGUud3JpdGluZyA9IGZhbHNlO1xuICBzdGF0ZS53cml0ZWNiID0gbnVsbDtcbiAgc3RhdGUubGVuZ3RoIC09IHN0YXRlLndyaXRlbGVuO1xuICBzdGF0ZS53cml0ZWxlbiA9IDA7XG59XG5cbmZ1bmN0aW9uIG9ud3JpdGUoc3RyZWFtLCBlcikge1xuICB2YXIgc3RhdGUgPSBzdHJlYW0uX3dyaXRhYmxlU3RhdGU7XG4gIHZhciBzeW5jID0gc3RhdGUuc3luYztcbiAgdmFyIGNiID0gc3RhdGUud3JpdGVjYjtcblxuICBvbndyaXRlU3RhdGVVcGRhdGUoc3RhdGUpO1xuXG4gIGlmIChlcilcbiAgICBvbndyaXRlRXJyb3Ioc3RyZWFtLCBzdGF0ZSwgc3luYywgZXIsIGNiKTtcbiAgZWxzZSB7XG4gICAgLy8gQ2hlY2sgaWYgd2UncmUgYWN0dWFsbHkgcmVhZHkgdG8gZmluaXNoLCBidXQgZG9uJ3QgZW1pdCB5ZXRcbiAgICB2YXIgZmluaXNoZWQgPSBuZWVkRmluaXNoKHN0cmVhbSwgc3RhdGUpO1xuXG4gICAgaWYgKCFmaW5pc2hlZCAmJiAhc3RhdGUuYnVmZmVyUHJvY2Vzc2luZyAmJiBzdGF0ZS5idWZmZXIubGVuZ3RoKVxuICAgICAgY2xlYXJCdWZmZXIoc3RyZWFtLCBzdGF0ZSk7XG5cbiAgICBpZiAoc3luYykge1xuICAgICAgc2V0SW1tZWRpYXRlKGZ1bmN0aW9uKCkge1xuICAgICAgICBhZnRlcldyaXRlKHN0cmVhbSwgc3RhdGUsIGZpbmlzaGVkLCBjYik7XG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgYWZ0ZXJXcml0ZShzdHJlYW0sIHN0YXRlLCBmaW5pc2hlZCwgY2IpO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBhZnRlcldyaXRlKHN0cmVhbSwgc3RhdGUsIGZpbmlzaGVkLCBjYikge1xuICBpZiAoIWZpbmlzaGVkKVxuICAgIG9ud3JpdGVEcmFpbihzdHJlYW0sIHN0YXRlKTtcbiAgY2IoKTtcbiAgaWYgKGZpbmlzaGVkKVxuICAgIGZpbmlzaE1heWJlKHN0cmVhbSwgc3RhdGUpO1xufVxuXG4vLyBNdXN0IGZvcmNlIGNhbGxiYWNrIHRvIGJlIGNhbGxlZCBvbiBuZXh0VGljaywgc28gdGhhdCB3ZSBkb24ndFxuLy8gZW1pdCAnZHJhaW4nIGJlZm9yZSB0aGUgd3JpdGUoKSBjb25zdW1lciBnZXRzIHRoZSAnZmFsc2UnIHJldHVyblxuLy8gdmFsdWUsIGFuZCBoYXMgYSBjaGFuY2UgdG8gYXR0YWNoIGEgJ2RyYWluJyBsaXN0ZW5lci5cbmZ1bmN0aW9uIG9ud3JpdGVEcmFpbihzdHJlYW0sIHN0YXRlKSB7XG4gIGlmIChzdGF0ZS5sZW5ndGggPT09IDAgJiYgc3RhdGUubmVlZERyYWluKSB7XG4gICAgc3RhdGUubmVlZERyYWluID0gZmFsc2U7XG4gICAgc3RyZWFtLmVtaXQoJ2RyYWluJyk7XG4gIH1cbn1cblxuXG4vLyBpZiB0aGVyZSdzIHNvbWV0aGluZyBpbiB0aGUgYnVmZmVyIHdhaXRpbmcsIHRoZW4gcHJvY2VzcyBpdFxuZnVuY3Rpb24gY2xlYXJCdWZmZXIoc3RyZWFtLCBzdGF0ZSkge1xuICBzdGF0ZS5idWZmZXJQcm9jZXNzaW5nID0gdHJ1ZTtcblxuICBmb3IgKHZhciBjID0gMDsgYyA8IHN0YXRlLmJ1ZmZlci5sZW5ndGg7IGMrKykge1xuICAgIHZhciBlbnRyeSA9IHN0YXRlLmJ1ZmZlcltjXTtcbiAgICB2YXIgY2h1bmsgPSBlbnRyeS5jaHVuaztcbiAgICB2YXIgZW5jb2RpbmcgPSBlbnRyeS5lbmNvZGluZztcbiAgICB2YXIgY2IgPSBlbnRyeS5jYWxsYmFjaztcbiAgICB2YXIgbGVuID0gc3RhdGUub2JqZWN0TW9kZSA/IDEgOiBjaHVuay5sZW5ndGg7XG5cbiAgICBkb1dyaXRlKHN0cmVhbSwgc3RhdGUsIGxlbiwgY2h1bmssIGVuY29kaW5nLCBjYik7XG5cbiAgICAvLyBpZiB3ZSBkaWRuJ3QgY2FsbCB0aGUgb253cml0ZSBpbW1lZGlhdGVseSwgdGhlblxuICAgIC8vIGl0IG1lYW5zIHRoYXQgd2UgbmVlZCB0byB3YWl0IHVudGlsIGl0IGRvZXMuXG4gICAgLy8gYWxzbywgdGhhdCBtZWFucyB0aGF0IHRoZSBjaHVuayBhbmQgY2IgYXJlIGN1cnJlbnRseVxuICAgIC8vIGJlaW5nIHByb2Nlc3NlZCwgc28gbW92ZSB0aGUgYnVmZmVyIGNvdW50ZXIgcGFzdCB0aGVtLlxuICAgIGlmIChzdGF0ZS53cml0aW5nKSB7XG4gICAgICBjKys7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cblxuICBzdGF0ZS5idWZmZXJQcm9jZXNzaW5nID0gZmFsc2U7XG4gIGlmIChjIDwgc3RhdGUuYnVmZmVyLmxlbmd0aClcbiAgICBzdGF0ZS5idWZmZXIgPSBzdGF0ZS5idWZmZXIuc2xpY2UoYyk7XG4gIGVsc2VcbiAgICBzdGF0ZS5idWZmZXIubGVuZ3RoID0gMDtcbn1cblxuV3JpdGFibGUucHJvdG90eXBlLl93cml0ZSA9IGZ1bmN0aW9uKGNodW5rLCBlbmNvZGluZywgY2IpIHtcbiAgY2IobmV3IEVycm9yKCdub3QgaW1wbGVtZW50ZWQnKSk7XG59O1xuXG5Xcml0YWJsZS5wcm90b3R5cGUuZW5kID0gZnVuY3Rpb24oY2h1bmssIGVuY29kaW5nLCBjYikge1xuICB2YXIgc3RhdGUgPSB0aGlzLl93cml0YWJsZVN0YXRlO1xuXG4gIGlmICh0eXBlb2YgY2h1bmsgPT09ICdmdW5jdGlvbicpIHtcbiAgICBjYiA9IGNodW5rO1xuICAgIGNodW5rID0gbnVsbDtcbiAgICBlbmNvZGluZyA9IG51bGw7XG4gIH0gZWxzZSBpZiAodHlwZW9mIGVuY29kaW5nID09PSAnZnVuY3Rpb24nKSB7XG4gICAgY2IgPSBlbmNvZGluZztcbiAgICBlbmNvZGluZyA9IG51bGw7XG4gIH1cblxuICBpZiAodHlwZW9mIGNodW5rICE9PSAndW5kZWZpbmVkJyAmJiBjaHVuayAhPT0gbnVsbClcbiAgICB0aGlzLndyaXRlKGNodW5rLCBlbmNvZGluZyk7XG5cbiAgLy8gaWdub3JlIHVubmVjZXNzYXJ5IGVuZCgpIGNhbGxzLlxuICBpZiAoIXN0YXRlLmVuZGluZyAmJiAhc3RhdGUuZmluaXNoZWQpXG4gICAgZW5kV3JpdGFibGUodGhpcywgc3RhdGUsIGNiKTtcbn07XG5cblxuZnVuY3Rpb24gbmVlZEZpbmlzaChzdHJlYW0sIHN0YXRlKSB7XG4gIHJldHVybiAoc3RhdGUuZW5kaW5nICYmXG4gICAgICAgICAgc3RhdGUubGVuZ3RoID09PSAwICYmXG4gICAgICAgICAgIXN0YXRlLmZpbmlzaGVkICYmXG4gICAgICAgICAgIXN0YXRlLndyaXRpbmcpO1xufVxuXG5mdW5jdGlvbiBmaW5pc2hNYXliZShzdHJlYW0sIHN0YXRlKSB7XG4gIHZhciBuZWVkID0gbmVlZEZpbmlzaChzdHJlYW0sIHN0YXRlKTtcbiAgaWYgKG5lZWQpIHtcbiAgICBzdGF0ZS5maW5pc2hlZCA9IHRydWU7XG4gICAgc3RyZWFtLmVtaXQoJ2ZpbmlzaCcpO1xuICB9XG4gIHJldHVybiBuZWVkO1xufVxuXG5mdW5jdGlvbiBlbmRXcml0YWJsZShzdHJlYW0sIHN0YXRlLCBjYikge1xuICBzdGF0ZS5lbmRpbmcgPSB0cnVlO1xuICBmaW5pc2hNYXliZShzdHJlYW0sIHN0YXRlKTtcbiAgaWYgKGNiKSB7XG4gICAgaWYgKHN0YXRlLmZpbmlzaGVkKVxuICAgICAgc2V0SW1tZWRpYXRlKGNiKTtcbiAgICBlbHNlXG4gICAgICBzdHJlYW0ub25jZSgnZmluaXNoJywgY2IpO1xuICB9XG4gIHN0YXRlLmVuZGVkID0gdHJ1ZTtcbn1cbiIsIi8vIENvcHlyaWdodCBKb3llbnQsIEluYy4gYW5kIG90aGVyIE5vZGUgY29udHJpYnV0b3JzLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhXG4vLyBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlXG4vLyBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmdcbi8vIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCxcbi8vIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXRcbi8vIHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZVxuLy8gZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWRcbi8vIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1Ncbi8vIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0Zcbi8vIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU5cbi8vIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLFxuLy8gREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SXG4vLyBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFXG4vLyBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuXG52YXIgQnVmZmVyID0gcmVxdWlyZSgnYnVmZmVyJykuQnVmZmVyO1xuXG5mdW5jdGlvbiBhc3NlcnRFbmNvZGluZyhlbmNvZGluZykge1xuICBpZiAoZW5jb2RpbmcgJiYgIUJ1ZmZlci5pc0VuY29kaW5nKGVuY29kaW5nKSkge1xuICAgIHRocm93IG5ldyBFcnJvcignVW5rbm93biBlbmNvZGluZzogJyArIGVuY29kaW5nKTtcbiAgfVxufVxuXG52YXIgU3RyaW5nRGVjb2RlciA9IGV4cG9ydHMuU3RyaW5nRGVjb2RlciA9IGZ1bmN0aW9uKGVuY29kaW5nKSB7XG4gIHRoaXMuZW5jb2RpbmcgPSAoZW5jb2RpbmcgfHwgJ3V0ZjgnKS50b0xvd2VyQ2FzZSgpLnJlcGxhY2UoL1stX10vLCAnJyk7XG4gIGFzc2VydEVuY29kaW5nKGVuY29kaW5nKTtcbiAgc3dpdGNoICh0aGlzLmVuY29kaW5nKSB7XG4gICAgY2FzZSAndXRmOCc6XG4gICAgICAvLyBDRVNVLTggcmVwcmVzZW50cyBlYWNoIG9mIFN1cnJvZ2F0ZSBQYWlyIGJ5IDMtYnl0ZXNcbiAgICAgIHRoaXMuc3Vycm9nYXRlU2l6ZSA9IDM7XG4gICAgICBicmVhaztcbiAgICBjYXNlICd1Y3MyJzpcbiAgICBjYXNlICd1dGYxNmxlJzpcbiAgICAgIC8vIFVURi0xNiByZXByZXNlbnRzIGVhY2ggb2YgU3Vycm9nYXRlIFBhaXIgYnkgMi1ieXRlc1xuICAgICAgdGhpcy5zdXJyb2dhdGVTaXplID0gMjtcbiAgICAgIHRoaXMuZGV0ZWN0SW5jb21wbGV0ZUNoYXIgPSB1dGYxNkRldGVjdEluY29tcGxldGVDaGFyO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAnYmFzZTY0JzpcbiAgICAgIC8vIEJhc2UtNjQgc3RvcmVzIDMgYnl0ZXMgaW4gNCBjaGFycywgYW5kIHBhZHMgdGhlIHJlbWFpbmRlci5cbiAgICAgIHRoaXMuc3Vycm9nYXRlU2l6ZSA9IDM7XG4gICAgICB0aGlzLmRldGVjdEluY29tcGxldGVDaGFyID0gYmFzZTY0RGV0ZWN0SW5jb21wbGV0ZUNoYXI7XG4gICAgICBicmVhaztcbiAgICBkZWZhdWx0OlxuICAgICAgdGhpcy53cml0ZSA9IHBhc3NUaHJvdWdoV3JpdGU7XG4gICAgICByZXR1cm47XG4gIH1cblxuICB0aGlzLmNoYXJCdWZmZXIgPSBuZXcgQnVmZmVyKDYpO1xuICB0aGlzLmNoYXJSZWNlaXZlZCA9IDA7XG4gIHRoaXMuY2hhckxlbmd0aCA9IDA7XG59O1xuXG5cblN0cmluZ0RlY29kZXIucHJvdG90eXBlLndyaXRlID0gZnVuY3Rpb24oYnVmZmVyKSB7XG4gIHZhciBjaGFyU3RyID0gJyc7XG4gIHZhciBvZmZzZXQgPSAwO1xuXG4gIC8vIGlmIG91ciBsYXN0IHdyaXRlIGVuZGVkIHdpdGggYW4gaW5jb21wbGV0ZSBtdWx0aWJ5dGUgY2hhcmFjdGVyXG4gIHdoaWxlICh0aGlzLmNoYXJMZW5ndGgpIHtcbiAgICAvLyBkZXRlcm1pbmUgaG93IG1hbnkgcmVtYWluaW5nIGJ5dGVzIHRoaXMgYnVmZmVyIGhhcyB0byBvZmZlciBmb3IgdGhpcyBjaGFyXG4gICAgdmFyIGkgPSAoYnVmZmVyLmxlbmd0aCA+PSB0aGlzLmNoYXJMZW5ndGggLSB0aGlzLmNoYXJSZWNlaXZlZCkgP1xuICAgICAgICAgICAgICAgIHRoaXMuY2hhckxlbmd0aCAtIHRoaXMuY2hhclJlY2VpdmVkIDpcbiAgICAgICAgICAgICAgICBidWZmZXIubGVuZ3RoO1xuXG4gICAgLy8gYWRkIHRoZSBuZXcgYnl0ZXMgdG8gdGhlIGNoYXIgYnVmZmVyXG4gICAgYnVmZmVyLmNvcHkodGhpcy5jaGFyQnVmZmVyLCB0aGlzLmNoYXJSZWNlaXZlZCwgb2Zmc2V0LCBpKTtcbiAgICB0aGlzLmNoYXJSZWNlaXZlZCArPSAoaSAtIG9mZnNldCk7XG4gICAgb2Zmc2V0ID0gaTtcblxuICAgIGlmICh0aGlzLmNoYXJSZWNlaXZlZCA8IHRoaXMuY2hhckxlbmd0aCkge1xuICAgICAgLy8gc3RpbGwgbm90IGVub3VnaCBjaGFycyBpbiB0aGlzIGJ1ZmZlcj8gd2FpdCBmb3IgbW9yZSAuLi5cbiAgICAgIHJldHVybiAnJztcbiAgICB9XG5cbiAgICAvLyBnZXQgdGhlIGNoYXJhY3RlciB0aGF0IHdhcyBzcGxpdFxuICAgIGNoYXJTdHIgPSB0aGlzLmNoYXJCdWZmZXIuc2xpY2UoMCwgdGhpcy5jaGFyTGVuZ3RoKS50b1N0cmluZyh0aGlzLmVuY29kaW5nKTtcblxuICAgIC8vIGxlYWQgc3Vycm9nYXRlIChEODAwLURCRkYpIGlzIGFsc28gdGhlIGluY29tcGxldGUgY2hhcmFjdGVyXG4gICAgdmFyIGNoYXJDb2RlID0gY2hhclN0ci5jaGFyQ29kZUF0KGNoYXJTdHIubGVuZ3RoIC0gMSk7XG4gICAgaWYgKGNoYXJDb2RlID49IDB4RDgwMCAmJiBjaGFyQ29kZSA8PSAweERCRkYpIHtcbiAgICAgIHRoaXMuY2hhckxlbmd0aCArPSB0aGlzLnN1cnJvZ2F0ZVNpemU7XG4gICAgICBjaGFyU3RyID0gJyc7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgdGhpcy5jaGFyUmVjZWl2ZWQgPSB0aGlzLmNoYXJMZW5ndGggPSAwO1xuXG4gICAgLy8gaWYgdGhlcmUgYXJlIG5vIG1vcmUgYnl0ZXMgaW4gdGhpcyBidWZmZXIsIGp1c3QgZW1pdCBvdXIgY2hhclxuICAgIGlmIChpID09IGJ1ZmZlci5sZW5ndGgpIHJldHVybiBjaGFyU3RyO1xuXG4gICAgLy8gb3RoZXJ3aXNlIGN1dCBvZmYgdGhlIGNoYXJhY3RlcnMgZW5kIGZyb20gdGhlIGJlZ2lubmluZyBvZiB0aGlzIGJ1ZmZlclxuICAgIGJ1ZmZlciA9IGJ1ZmZlci5zbGljZShpLCBidWZmZXIubGVuZ3RoKTtcbiAgICBicmVhaztcbiAgfVxuXG4gIHZhciBsZW5JbmNvbXBsZXRlID0gdGhpcy5kZXRlY3RJbmNvbXBsZXRlQ2hhcihidWZmZXIpO1xuXG4gIHZhciBlbmQgPSBidWZmZXIubGVuZ3RoO1xuICBpZiAodGhpcy5jaGFyTGVuZ3RoKSB7XG4gICAgLy8gYnVmZmVyIHRoZSBpbmNvbXBsZXRlIGNoYXJhY3RlciBieXRlcyB3ZSBnb3RcbiAgICBidWZmZXIuY29weSh0aGlzLmNoYXJCdWZmZXIsIDAsIGJ1ZmZlci5sZW5ndGggLSBsZW5JbmNvbXBsZXRlLCBlbmQpO1xuICAgIHRoaXMuY2hhclJlY2VpdmVkID0gbGVuSW5jb21wbGV0ZTtcbiAgICBlbmQgLT0gbGVuSW5jb21wbGV0ZTtcbiAgfVxuXG4gIGNoYXJTdHIgKz0gYnVmZmVyLnRvU3RyaW5nKHRoaXMuZW5jb2RpbmcsIDAsIGVuZCk7XG5cbiAgdmFyIGVuZCA9IGNoYXJTdHIubGVuZ3RoIC0gMTtcbiAgdmFyIGNoYXJDb2RlID0gY2hhclN0ci5jaGFyQ29kZUF0KGVuZCk7XG4gIC8vIGxlYWQgc3Vycm9nYXRlIChEODAwLURCRkYpIGlzIGFsc28gdGhlIGluY29tcGxldGUgY2hhcmFjdGVyXG4gIGlmIChjaGFyQ29kZSA+PSAweEQ4MDAgJiYgY2hhckNvZGUgPD0gMHhEQkZGKSB7XG4gICAgdmFyIHNpemUgPSB0aGlzLnN1cnJvZ2F0ZVNpemU7XG4gICAgdGhpcy5jaGFyTGVuZ3RoICs9IHNpemU7XG4gICAgdGhpcy5jaGFyUmVjZWl2ZWQgKz0gc2l6ZTtcbiAgICB0aGlzLmNoYXJCdWZmZXIuY29weSh0aGlzLmNoYXJCdWZmZXIsIHNpemUsIDAsIHNpemUpO1xuICAgIHRoaXMuY2hhckJ1ZmZlci53cml0ZShjaGFyU3RyLmNoYXJBdChjaGFyU3RyLmxlbmd0aCAtIDEpLCB0aGlzLmVuY29kaW5nKTtcbiAgICByZXR1cm4gY2hhclN0ci5zdWJzdHJpbmcoMCwgZW5kKTtcbiAgfVxuXG4gIC8vIG9yIGp1c3QgZW1pdCB0aGUgY2hhclN0clxuICByZXR1cm4gY2hhclN0cjtcbn07XG5cblN0cmluZ0RlY29kZXIucHJvdG90eXBlLmRldGVjdEluY29tcGxldGVDaGFyID0gZnVuY3Rpb24oYnVmZmVyKSB7XG4gIC8vIGRldGVybWluZSBob3cgbWFueSBieXRlcyB3ZSBoYXZlIHRvIGNoZWNrIGF0IHRoZSBlbmQgb2YgdGhpcyBidWZmZXJcbiAgdmFyIGkgPSAoYnVmZmVyLmxlbmd0aCA+PSAzKSA/IDMgOiBidWZmZXIubGVuZ3RoO1xuXG4gIC8vIEZpZ3VyZSBvdXQgaWYgb25lIG9mIHRoZSBsYXN0IGkgYnl0ZXMgb2Ygb3VyIGJ1ZmZlciBhbm5vdW5jZXMgYW5cbiAgLy8gaW5jb21wbGV0ZSBjaGFyLlxuICBmb3IgKDsgaSA+IDA7IGktLSkge1xuICAgIHZhciBjID0gYnVmZmVyW2J1ZmZlci5sZW5ndGggLSBpXTtcblxuICAgIC8vIFNlZSBodHRwOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL1VURi04I0Rlc2NyaXB0aW9uXG5cbiAgICAvLyAxMTBYWFhYWFxuICAgIGlmIChpID09IDEgJiYgYyA+PiA1ID09IDB4MDYpIHtcbiAgICAgIHRoaXMuY2hhckxlbmd0aCA9IDI7XG4gICAgICBicmVhaztcbiAgICB9XG5cbiAgICAvLyAxMTEwWFhYWFxuICAgIGlmIChpIDw9IDIgJiYgYyA+PiA0ID09IDB4MEUpIHtcbiAgICAgIHRoaXMuY2hhckxlbmd0aCA9IDM7XG4gICAgICBicmVhaztcbiAgICB9XG5cbiAgICAvLyAxMTExMFhYWFxuICAgIGlmIChpIDw9IDMgJiYgYyA+PiAzID09IDB4MUUpIHtcbiAgICAgIHRoaXMuY2hhckxlbmd0aCA9IDQ7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cblxuICByZXR1cm4gaTtcbn07XG5cblN0cmluZ0RlY29kZXIucHJvdG90eXBlLmVuZCA9IGZ1bmN0aW9uKGJ1ZmZlcikge1xuICB2YXIgcmVzID0gJyc7XG4gIGlmIChidWZmZXIgJiYgYnVmZmVyLmxlbmd0aClcbiAgICByZXMgPSB0aGlzLndyaXRlKGJ1ZmZlcik7XG5cbiAgaWYgKHRoaXMuY2hhclJlY2VpdmVkKSB7XG4gICAgdmFyIGNyID0gdGhpcy5jaGFyUmVjZWl2ZWQ7XG4gICAgdmFyIGJ1ZiA9IHRoaXMuY2hhckJ1ZmZlcjtcbiAgICB2YXIgZW5jID0gdGhpcy5lbmNvZGluZztcbiAgICByZXMgKz0gYnVmLnNsaWNlKDAsIGNyKS50b1N0cmluZyhlbmMpO1xuICB9XG5cbiAgcmV0dXJuIHJlcztcbn07XG5cbmZ1bmN0aW9uIHBhc3NUaHJvdWdoV3JpdGUoYnVmZmVyKSB7XG4gIHJldHVybiBidWZmZXIudG9TdHJpbmcodGhpcy5lbmNvZGluZyk7XG59XG5cbmZ1bmN0aW9uIHV0ZjE2RGV0ZWN0SW5jb21wbGV0ZUNoYXIoYnVmZmVyKSB7XG4gIHZhciBpbmNvbXBsZXRlID0gdGhpcy5jaGFyUmVjZWl2ZWQgPSBidWZmZXIubGVuZ3RoICUgMjtcbiAgdGhpcy5jaGFyTGVuZ3RoID0gaW5jb21wbGV0ZSA/IDIgOiAwO1xuICByZXR1cm4gaW5jb21wbGV0ZTtcbn1cblxuZnVuY3Rpb24gYmFzZTY0RGV0ZWN0SW5jb21wbGV0ZUNoYXIoYnVmZmVyKSB7XG4gIHZhciBpbmNvbXBsZXRlID0gdGhpcy5jaGFyUmVjZWl2ZWQgPSBidWZmZXIubGVuZ3RoICUgMztcbiAgdGhpcy5jaGFyTGVuZ3RoID0gaW5jb21wbGV0ZSA/IDMgOiAwO1xuICByZXR1cm4gaW5jb21wbGV0ZTtcbn1cbiIsIi8vIENvcHlyaWdodCBKb3llbnQsIEluYy4gYW5kIG90aGVyIE5vZGUgY29udHJpYnV0b3JzLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhXG4vLyBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlXG4vLyBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmdcbi8vIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCxcbi8vIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXRcbi8vIHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZVxuLy8gZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWRcbi8vIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1Ncbi8vIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0Zcbi8vIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU5cbi8vIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLFxuLy8gREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SXG4vLyBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFXG4vLyBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuXG52YXIgcHVueWNvZGUgPSByZXF1aXJlKCdwdW55Y29kZScpO1xuXG5leHBvcnRzLnBhcnNlID0gdXJsUGFyc2U7XG5leHBvcnRzLnJlc29sdmUgPSB1cmxSZXNvbHZlO1xuZXhwb3J0cy5yZXNvbHZlT2JqZWN0ID0gdXJsUmVzb2x2ZU9iamVjdDtcbmV4cG9ydHMuZm9ybWF0ID0gdXJsRm9ybWF0O1xuXG5leHBvcnRzLlVybCA9IFVybDtcblxuZnVuY3Rpb24gVXJsKCkge1xuICB0aGlzLnByb3RvY29sID0gbnVsbDtcbiAgdGhpcy5zbGFzaGVzID0gbnVsbDtcbiAgdGhpcy5hdXRoID0gbnVsbDtcbiAgdGhpcy5ob3N0ID0gbnVsbDtcbiAgdGhpcy5wb3J0ID0gbnVsbDtcbiAgdGhpcy5ob3N0bmFtZSA9IG51bGw7XG4gIHRoaXMuaGFzaCA9IG51bGw7XG4gIHRoaXMuc2VhcmNoID0gbnVsbDtcbiAgdGhpcy5xdWVyeSA9IG51bGw7XG4gIHRoaXMucGF0aG5hbWUgPSBudWxsO1xuICB0aGlzLnBhdGggPSBudWxsO1xuICB0aGlzLmhyZWYgPSBudWxsO1xufVxuXG4vLyBSZWZlcmVuY2U6IFJGQyAzOTg2LCBSRkMgMTgwOCwgUkZDIDIzOTZcblxuLy8gZGVmaW5lIHRoZXNlIGhlcmUgc28gYXQgbGVhc3QgdGhleSBvbmx5IGhhdmUgdG8gYmVcbi8vIGNvbXBpbGVkIG9uY2Ugb24gdGhlIGZpcnN0IG1vZHVsZSBsb2FkLlxudmFyIHByb3RvY29sUGF0dGVybiA9IC9eKFthLXowLTkuKy1dKzopL2ksXG4gICAgcG9ydFBhdHRlcm4gPSAvOlswLTldKiQvLFxuXG4gICAgLy8gUkZDIDIzOTY6IGNoYXJhY3RlcnMgcmVzZXJ2ZWQgZm9yIGRlbGltaXRpbmcgVVJMcy5cbiAgICAvLyBXZSBhY3R1YWxseSBqdXN0IGF1dG8tZXNjYXBlIHRoZXNlLlxuICAgIGRlbGltcyA9IFsnPCcsICc+JywgJ1wiJywgJ2AnLCAnICcsICdcXHInLCAnXFxuJywgJ1xcdCddLFxuXG4gICAgLy8gUkZDIDIzOTY6IGNoYXJhY3RlcnMgbm90IGFsbG93ZWQgZm9yIHZhcmlvdXMgcmVhc29ucy5cbiAgICB1bndpc2UgPSBbJ3snLCAnfScsICd8JywgJ1xcXFwnLCAnXicsICdgJ10uY29uY2F0KGRlbGltcyksXG5cbiAgICAvLyBBbGxvd2VkIGJ5IFJGQ3MsIGJ1dCBjYXVzZSBvZiBYU1MgYXR0YWNrcy4gIEFsd2F5cyBlc2NhcGUgdGhlc2UuXG4gICAgYXV0b0VzY2FwZSA9IFsnXFwnJ10uY29uY2F0KHVud2lzZSksXG4gICAgLy8gQ2hhcmFjdGVycyB0aGF0IGFyZSBuZXZlciBldmVyIGFsbG93ZWQgaW4gYSBob3N0bmFtZS5cbiAgICAvLyBOb3RlIHRoYXQgYW55IGludmFsaWQgY2hhcnMgYXJlIGFsc28gaGFuZGxlZCwgYnV0IHRoZXNlXG4gICAgLy8gYXJlIHRoZSBvbmVzIHRoYXQgYXJlICpleHBlY3RlZCogdG8gYmUgc2Vlbiwgc28gd2UgZmFzdC1wYXRoXG4gICAgLy8gdGhlbS5cbiAgICBub25Ib3N0Q2hhcnMgPSBbJyUnLCAnLycsICc/JywgJzsnLCAnIyddLmNvbmNhdChhdXRvRXNjYXBlKSxcbiAgICBob3N0RW5kaW5nQ2hhcnMgPSBbJy8nLCAnPycsICcjJ10sXG4gICAgaG9zdG5hbWVNYXhMZW4gPSAyNTUsXG4gICAgaG9zdG5hbWVQYXJ0UGF0dGVybiA9IC9eW2EtejAtOUEtWl8tXXswLDYzfSQvLFxuICAgIGhvc3RuYW1lUGFydFN0YXJ0ID0gL14oW2EtejAtOUEtWl8tXXswLDYzfSkoLiopJC8sXG4gICAgLy8gcHJvdG9jb2xzIHRoYXQgY2FuIGFsbG93IFwidW5zYWZlXCIgYW5kIFwidW53aXNlXCIgY2hhcnMuXG4gICAgdW5zYWZlUHJvdG9jb2wgPSB7XG4gICAgICAnamF2YXNjcmlwdCc6IHRydWUsXG4gICAgICAnamF2YXNjcmlwdDonOiB0cnVlXG4gICAgfSxcbiAgICAvLyBwcm90b2NvbHMgdGhhdCBuZXZlciBoYXZlIGEgaG9zdG5hbWUuXG4gICAgaG9zdGxlc3NQcm90b2NvbCA9IHtcbiAgICAgICdqYXZhc2NyaXB0JzogdHJ1ZSxcbiAgICAgICdqYXZhc2NyaXB0Oic6IHRydWVcbiAgICB9LFxuICAgIC8vIHByb3RvY29scyB0aGF0IGFsd2F5cyBjb250YWluIGEgLy8gYml0LlxuICAgIHNsYXNoZWRQcm90b2NvbCA9IHtcbiAgICAgICdodHRwJzogdHJ1ZSxcbiAgICAgICdodHRwcyc6IHRydWUsXG4gICAgICAnZnRwJzogdHJ1ZSxcbiAgICAgICdnb3BoZXInOiB0cnVlLFxuICAgICAgJ2ZpbGUnOiB0cnVlLFxuICAgICAgJ2h0dHA6JzogdHJ1ZSxcbiAgICAgICdodHRwczonOiB0cnVlLFxuICAgICAgJ2Z0cDonOiB0cnVlLFxuICAgICAgJ2dvcGhlcjonOiB0cnVlLFxuICAgICAgJ2ZpbGU6JzogdHJ1ZVxuICAgIH0sXG4gICAgcXVlcnlzdHJpbmcgPSByZXF1aXJlKCdxdWVyeXN0cmluZycpO1xuXG5mdW5jdGlvbiB1cmxQYXJzZSh1cmwsIHBhcnNlUXVlcnlTdHJpbmcsIHNsYXNoZXNEZW5vdGVIb3N0KSB7XG4gIGlmICh1cmwgJiYgaXNPYmplY3QodXJsKSAmJiB1cmwgaW5zdGFuY2VvZiBVcmwpIHJldHVybiB1cmw7XG5cbiAgdmFyIHUgPSBuZXcgVXJsO1xuICB1LnBhcnNlKHVybCwgcGFyc2VRdWVyeVN0cmluZywgc2xhc2hlc0Rlbm90ZUhvc3QpO1xuICByZXR1cm4gdTtcbn1cblxuVXJsLnByb3RvdHlwZS5wYXJzZSA9IGZ1bmN0aW9uKHVybCwgcGFyc2VRdWVyeVN0cmluZywgc2xhc2hlc0Rlbm90ZUhvc3QpIHtcbiAgaWYgKCFpc1N0cmluZyh1cmwpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlBhcmFtZXRlciAndXJsJyBtdXN0IGJlIGEgc3RyaW5nLCBub3QgXCIgKyB0eXBlb2YgdXJsKTtcbiAgfVxuXG4gIHZhciByZXN0ID0gdXJsO1xuXG4gIC8vIHRyaW0gYmVmb3JlIHByb2NlZWRpbmcuXG4gIC8vIFRoaXMgaXMgdG8gc3VwcG9ydCBwYXJzZSBzdHVmZiBsaWtlIFwiICBodHRwOi8vZm9vLmNvbSAgXFxuXCJcbiAgcmVzdCA9IHJlc3QudHJpbSgpO1xuXG4gIHZhciBwcm90byA9IHByb3RvY29sUGF0dGVybi5leGVjKHJlc3QpO1xuICBpZiAocHJvdG8pIHtcbiAgICBwcm90byA9IHByb3RvWzBdO1xuICAgIHZhciBsb3dlclByb3RvID0gcHJvdG8udG9Mb3dlckNhc2UoKTtcbiAgICB0aGlzLnByb3RvY29sID0gbG93ZXJQcm90bztcbiAgICByZXN0ID0gcmVzdC5zdWJzdHIocHJvdG8ubGVuZ3RoKTtcbiAgfVxuXG4gIC8vIGZpZ3VyZSBvdXQgaWYgaXQncyBnb3QgYSBob3N0XG4gIC8vIHVzZXJAc2VydmVyIGlzICphbHdheXMqIGludGVycHJldGVkIGFzIGEgaG9zdG5hbWUsIGFuZCB1cmxcbiAgLy8gcmVzb2x1dGlvbiB3aWxsIHRyZWF0IC8vZm9vL2JhciBhcyBob3N0PWZvbyxwYXRoPWJhciBiZWNhdXNlIHRoYXQnc1xuICAvLyBob3cgdGhlIGJyb3dzZXIgcmVzb2x2ZXMgcmVsYXRpdmUgVVJMcy5cbiAgaWYgKHNsYXNoZXNEZW5vdGVIb3N0IHx8IHByb3RvIHx8IHJlc3QubWF0Y2goL15cXC9cXC9bXkBcXC9dK0BbXkBcXC9dKy8pKSB7XG4gICAgdmFyIHNsYXNoZXMgPSByZXN0LnN1YnN0cigwLCAyKSA9PT0gJy8vJztcbiAgICBpZiAoc2xhc2hlcyAmJiAhKHByb3RvICYmIGhvc3RsZXNzUHJvdG9jb2xbcHJvdG9dKSkge1xuICAgICAgcmVzdCA9IHJlc3Quc3Vic3RyKDIpO1xuICAgICAgdGhpcy5zbGFzaGVzID0gdHJ1ZTtcbiAgICB9XG4gIH1cblxuICBpZiAoIWhvc3RsZXNzUHJvdG9jb2xbcHJvdG9dICYmXG4gICAgICAoc2xhc2hlcyB8fCAocHJvdG8gJiYgIXNsYXNoZWRQcm90b2NvbFtwcm90b10pKSkge1xuXG4gICAgLy8gdGhlcmUncyBhIGhvc3RuYW1lLlxuICAgIC8vIHRoZSBmaXJzdCBpbnN0YW5jZSBvZiAvLCA/LCA7LCBvciAjIGVuZHMgdGhlIGhvc3QuXG4gICAgLy9cbiAgICAvLyBJZiB0aGVyZSBpcyBhbiBAIGluIHRoZSBob3N0bmFtZSwgdGhlbiBub24taG9zdCBjaGFycyAqYXJlKiBhbGxvd2VkXG4gICAgLy8gdG8gdGhlIGxlZnQgb2YgdGhlIGxhc3QgQCBzaWduLCB1bmxlc3Mgc29tZSBob3N0LWVuZGluZyBjaGFyYWN0ZXJcbiAgICAvLyBjb21lcyAqYmVmb3JlKiB0aGUgQC1zaWduLlxuICAgIC8vIFVSTHMgYXJlIG9ibm94aW91cy5cbiAgICAvL1xuICAgIC8vIGV4OlxuICAgIC8vIGh0dHA6Ly9hQGJAYy8gPT4gdXNlcjphQGIgaG9zdDpjXG4gICAgLy8gaHR0cDovL2FAYj9AYyA9PiB1c2VyOmEgaG9zdDpjIHBhdGg6Lz9AY1xuXG4gICAgLy8gdjAuMTIgVE9ETyhpc2FhY3MpOiBUaGlzIGlzIG5vdCBxdWl0ZSBob3cgQ2hyb21lIGRvZXMgdGhpbmdzLlxuICAgIC8vIFJldmlldyBvdXIgdGVzdCBjYXNlIGFnYWluc3QgYnJvd3NlcnMgbW9yZSBjb21wcmVoZW5zaXZlbHkuXG5cbiAgICAvLyBmaW5kIHRoZSBmaXJzdCBpbnN0YW5jZSBvZiBhbnkgaG9zdEVuZGluZ0NoYXJzXG4gICAgdmFyIGhvc3RFbmQgPSAtMTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGhvc3RFbmRpbmdDaGFycy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGhlYyA9IHJlc3QuaW5kZXhPZihob3N0RW5kaW5nQ2hhcnNbaV0pO1xuICAgICAgaWYgKGhlYyAhPT0gLTEgJiYgKGhvc3RFbmQgPT09IC0xIHx8IGhlYyA8IGhvc3RFbmQpKVxuICAgICAgICBob3N0RW5kID0gaGVjO1xuICAgIH1cblxuICAgIC8vIGF0IHRoaXMgcG9pbnQsIGVpdGhlciB3ZSBoYXZlIGFuIGV4cGxpY2l0IHBvaW50IHdoZXJlIHRoZVxuICAgIC8vIGF1dGggcG9ydGlvbiBjYW5ub3QgZ28gcGFzdCwgb3IgdGhlIGxhc3QgQCBjaGFyIGlzIHRoZSBkZWNpZGVyLlxuICAgIHZhciBhdXRoLCBhdFNpZ247XG4gICAgaWYgKGhvc3RFbmQgPT09IC0xKSB7XG4gICAgICAvLyBhdFNpZ24gY2FuIGJlIGFueXdoZXJlLlxuICAgICAgYXRTaWduID0gcmVzdC5sYXN0SW5kZXhPZignQCcpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBhdFNpZ24gbXVzdCBiZSBpbiBhdXRoIHBvcnRpb24uXG4gICAgICAvLyBodHRwOi8vYUBiL2NAZCA9PiBob3N0OmIgYXV0aDphIHBhdGg6L2NAZFxuICAgICAgYXRTaWduID0gcmVzdC5sYXN0SW5kZXhPZignQCcsIGhvc3RFbmQpO1xuICAgIH1cblxuICAgIC8vIE5vdyB3ZSBoYXZlIGEgcG9ydGlvbiB3aGljaCBpcyBkZWZpbml0ZWx5IHRoZSBhdXRoLlxuICAgIC8vIFB1bGwgdGhhdCBvZmYuXG4gICAgaWYgKGF0U2lnbiAhPT0gLTEpIHtcbiAgICAgIGF1dGggPSByZXN0LnNsaWNlKDAsIGF0U2lnbik7XG4gICAgICByZXN0ID0gcmVzdC5zbGljZShhdFNpZ24gKyAxKTtcbiAgICAgIHRoaXMuYXV0aCA9IGRlY29kZVVSSUNvbXBvbmVudChhdXRoKTtcbiAgICB9XG5cbiAgICAvLyB0aGUgaG9zdCBpcyB0aGUgcmVtYWluaW5nIHRvIHRoZSBsZWZ0IG9mIHRoZSBmaXJzdCBub24taG9zdCBjaGFyXG4gICAgaG9zdEVuZCA9IC0xO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbm9uSG9zdENoYXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgaGVjID0gcmVzdC5pbmRleE9mKG5vbkhvc3RDaGFyc1tpXSk7XG4gICAgICBpZiAoaGVjICE9PSAtMSAmJiAoaG9zdEVuZCA9PT0gLTEgfHwgaGVjIDwgaG9zdEVuZCkpXG4gICAgICAgIGhvc3RFbmQgPSBoZWM7XG4gICAgfVxuICAgIC8vIGlmIHdlIHN0aWxsIGhhdmUgbm90IGhpdCBpdCwgdGhlbiB0aGUgZW50aXJlIHRoaW5nIGlzIGEgaG9zdC5cbiAgICBpZiAoaG9zdEVuZCA9PT0gLTEpXG4gICAgICBob3N0RW5kID0gcmVzdC5sZW5ndGg7XG5cbiAgICB0aGlzLmhvc3QgPSByZXN0LnNsaWNlKDAsIGhvc3RFbmQpO1xuICAgIHJlc3QgPSByZXN0LnNsaWNlKGhvc3RFbmQpO1xuXG4gICAgLy8gcHVsbCBvdXQgcG9ydC5cbiAgICB0aGlzLnBhcnNlSG9zdCgpO1xuXG4gICAgLy8gd2UndmUgaW5kaWNhdGVkIHRoYXQgdGhlcmUgaXMgYSBob3N0bmFtZSxcbiAgICAvLyBzbyBldmVuIGlmIGl0J3MgZW1wdHksIGl0IGhhcyB0byBiZSBwcmVzZW50LlxuICAgIHRoaXMuaG9zdG5hbWUgPSB0aGlzLmhvc3RuYW1lIHx8ICcnO1xuXG4gICAgLy8gaWYgaG9zdG5hbWUgYmVnaW5zIHdpdGggWyBhbmQgZW5kcyB3aXRoIF1cbiAgICAvLyBhc3N1bWUgdGhhdCBpdCdzIGFuIElQdjYgYWRkcmVzcy5cbiAgICB2YXIgaXB2Nkhvc3RuYW1lID0gdGhpcy5ob3N0bmFtZVswXSA9PT0gJ1snICYmXG4gICAgICAgIHRoaXMuaG9zdG5hbWVbdGhpcy5ob3N0bmFtZS5sZW5ndGggLSAxXSA9PT0gJ10nO1xuXG4gICAgLy8gdmFsaWRhdGUgYSBsaXR0bGUuXG4gICAgaWYgKCFpcHY2SG9zdG5hbWUpIHtcbiAgICAgIHZhciBob3N0cGFydHMgPSB0aGlzLmhvc3RuYW1lLnNwbGl0KC9cXC4vKTtcbiAgICAgIGZvciAodmFyIGkgPSAwLCBsID0gaG9zdHBhcnRzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICB2YXIgcGFydCA9IGhvc3RwYXJ0c1tpXTtcbiAgICAgICAgaWYgKCFwYXJ0KSBjb250aW51ZTtcbiAgICAgICAgaWYgKCFwYXJ0Lm1hdGNoKGhvc3RuYW1lUGFydFBhdHRlcm4pKSB7XG4gICAgICAgICAgdmFyIG5ld3BhcnQgPSAnJztcbiAgICAgICAgICBmb3IgKHZhciBqID0gMCwgayA9IHBhcnQubGVuZ3RoOyBqIDwgazsgaisrKSB7XG4gICAgICAgICAgICBpZiAocGFydC5jaGFyQ29kZUF0KGopID4gMTI3KSB7XG4gICAgICAgICAgICAgIC8vIHdlIHJlcGxhY2Ugbm9uLUFTQ0lJIGNoYXIgd2l0aCBhIHRlbXBvcmFyeSBwbGFjZWhvbGRlclxuICAgICAgICAgICAgICAvLyB3ZSBuZWVkIHRoaXMgdG8gbWFrZSBzdXJlIHNpemUgb2YgaG9zdG5hbWUgaXMgbm90XG4gICAgICAgICAgICAgIC8vIGJyb2tlbiBieSByZXBsYWNpbmcgbm9uLUFTQ0lJIGJ5IG5vdGhpbmdcbiAgICAgICAgICAgICAgbmV3cGFydCArPSAneCc7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBuZXdwYXJ0ICs9IHBhcnRbal07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vIHdlIHRlc3QgYWdhaW4gd2l0aCBBU0NJSSBjaGFyIG9ubHlcbiAgICAgICAgICBpZiAoIW5ld3BhcnQubWF0Y2goaG9zdG5hbWVQYXJ0UGF0dGVybikpIHtcbiAgICAgICAgICAgIHZhciB2YWxpZFBhcnRzID0gaG9zdHBhcnRzLnNsaWNlKDAsIGkpO1xuICAgICAgICAgICAgdmFyIG5vdEhvc3QgPSBob3N0cGFydHMuc2xpY2UoaSArIDEpO1xuICAgICAgICAgICAgdmFyIGJpdCA9IHBhcnQubWF0Y2goaG9zdG5hbWVQYXJ0U3RhcnQpO1xuICAgICAgICAgICAgaWYgKGJpdCkge1xuICAgICAgICAgICAgICB2YWxpZFBhcnRzLnB1c2goYml0WzFdKTtcbiAgICAgICAgICAgICAgbm90SG9zdC51bnNoaWZ0KGJpdFsyXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobm90SG9zdC5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgcmVzdCA9ICcvJyArIG5vdEhvc3Quam9pbignLicpICsgcmVzdDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuaG9zdG5hbWUgPSB2YWxpZFBhcnRzLmpvaW4oJy4nKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmICh0aGlzLmhvc3RuYW1lLmxlbmd0aCA+IGhvc3RuYW1lTWF4TGVuKSB7XG4gICAgICB0aGlzLmhvc3RuYW1lID0gJyc7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIGhvc3RuYW1lcyBhcmUgYWx3YXlzIGxvd2VyIGNhc2UuXG4gICAgICB0aGlzLmhvc3RuYW1lID0gdGhpcy5ob3N0bmFtZS50b0xvd2VyQ2FzZSgpO1xuICAgIH1cblxuICAgIGlmICghaXB2Nkhvc3RuYW1lKSB7XG4gICAgICAvLyBJRE5BIFN1cHBvcnQ6IFJldHVybnMgYSBwdW55IGNvZGVkIHJlcHJlc2VudGF0aW9uIG9mIFwiZG9tYWluXCIuXG4gICAgICAvLyBJdCBvbmx5IGNvbnZlcnRzIHRoZSBwYXJ0IG9mIHRoZSBkb21haW4gbmFtZSB0aGF0XG4gICAgICAvLyBoYXMgbm9uIEFTQ0lJIGNoYXJhY3RlcnMuIEkuZS4gaXQgZG9zZW50IG1hdHRlciBpZlxuICAgICAgLy8geW91IGNhbGwgaXQgd2l0aCBhIGRvbWFpbiB0aGF0IGFscmVhZHkgaXMgaW4gQVNDSUkuXG4gICAgICB2YXIgZG9tYWluQXJyYXkgPSB0aGlzLmhvc3RuYW1lLnNwbGl0KCcuJyk7XG4gICAgICB2YXIgbmV3T3V0ID0gW107XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGRvbWFpbkFycmF5Lmxlbmd0aDsgKytpKSB7XG4gICAgICAgIHZhciBzID0gZG9tYWluQXJyYXlbaV07XG4gICAgICAgIG5ld091dC5wdXNoKHMubWF0Y2goL1teQS1aYS16MC05Xy1dLykgP1xuICAgICAgICAgICAgJ3huLS0nICsgcHVueWNvZGUuZW5jb2RlKHMpIDogcyk7XG4gICAgICB9XG4gICAgICB0aGlzLmhvc3RuYW1lID0gbmV3T3V0LmpvaW4oJy4nKTtcbiAgICB9XG5cbiAgICB2YXIgcCA9IHRoaXMucG9ydCA/ICc6JyArIHRoaXMucG9ydCA6ICcnO1xuICAgIHZhciBoID0gdGhpcy5ob3N0bmFtZSB8fCAnJztcbiAgICB0aGlzLmhvc3QgPSBoICsgcDtcbiAgICB0aGlzLmhyZWYgKz0gdGhpcy5ob3N0O1xuXG4gICAgLy8gc3RyaXAgWyBhbmQgXSBmcm9tIHRoZSBob3N0bmFtZVxuICAgIC8vIHRoZSBob3N0IGZpZWxkIHN0aWxsIHJldGFpbnMgdGhlbSwgdGhvdWdoXG4gICAgaWYgKGlwdjZIb3N0bmFtZSkge1xuICAgICAgdGhpcy5ob3N0bmFtZSA9IHRoaXMuaG9zdG5hbWUuc3Vic3RyKDEsIHRoaXMuaG9zdG5hbWUubGVuZ3RoIC0gMik7XG4gICAgICBpZiAocmVzdFswXSAhPT0gJy8nKSB7XG4gICAgICAgIHJlc3QgPSAnLycgKyByZXN0O1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8vIG5vdyByZXN0IGlzIHNldCB0byB0aGUgcG9zdC1ob3N0IHN0dWZmLlxuICAvLyBjaG9wIG9mZiBhbnkgZGVsaW0gY2hhcnMuXG4gIGlmICghdW5zYWZlUHJvdG9jb2xbbG93ZXJQcm90b10pIHtcblxuICAgIC8vIEZpcnN0LCBtYWtlIDEwMCUgc3VyZSB0aGF0IGFueSBcImF1dG9Fc2NhcGVcIiBjaGFycyBnZXRcbiAgICAvLyBlc2NhcGVkLCBldmVuIGlmIGVuY29kZVVSSUNvbXBvbmVudCBkb2Vzbid0IHRoaW5rIHRoZXlcbiAgICAvLyBuZWVkIHRvIGJlLlxuICAgIGZvciAodmFyIGkgPSAwLCBsID0gYXV0b0VzY2FwZS5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgIHZhciBhZSA9IGF1dG9Fc2NhcGVbaV07XG4gICAgICB2YXIgZXNjID0gZW5jb2RlVVJJQ29tcG9uZW50KGFlKTtcbiAgICAgIGlmIChlc2MgPT09IGFlKSB7XG4gICAgICAgIGVzYyA9IGVzY2FwZShhZSk7XG4gICAgICB9XG4gICAgICByZXN0ID0gcmVzdC5zcGxpdChhZSkuam9pbihlc2MpO1xuICAgIH1cbiAgfVxuXG5cbiAgLy8gY2hvcCBvZmYgZnJvbSB0aGUgdGFpbCBmaXJzdC5cbiAgdmFyIGhhc2ggPSByZXN0LmluZGV4T2YoJyMnKTtcbiAgaWYgKGhhc2ggIT09IC0xKSB7XG4gICAgLy8gZ290IGEgZnJhZ21lbnQgc3RyaW5nLlxuICAgIHRoaXMuaGFzaCA9IHJlc3Quc3Vic3RyKGhhc2gpO1xuICAgIHJlc3QgPSByZXN0LnNsaWNlKDAsIGhhc2gpO1xuICB9XG4gIHZhciBxbSA9IHJlc3QuaW5kZXhPZignPycpO1xuICBpZiAocW0gIT09IC0xKSB7XG4gICAgdGhpcy5zZWFyY2ggPSByZXN0LnN1YnN0cihxbSk7XG4gICAgdGhpcy5xdWVyeSA9IHJlc3Quc3Vic3RyKHFtICsgMSk7XG4gICAgaWYgKHBhcnNlUXVlcnlTdHJpbmcpIHtcbiAgICAgIHRoaXMucXVlcnkgPSBxdWVyeXN0cmluZy5wYXJzZSh0aGlzLnF1ZXJ5KTtcbiAgICB9XG4gICAgcmVzdCA9IHJlc3Quc2xpY2UoMCwgcW0pO1xuICB9IGVsc2UgaWYgKHBhcnNlUXVlcnlTdHJpbmcpIHtcbiAgICAvLyBubyBxdWVyeSBzdHJpbmcsIGJ1dCBwYXJzZVF1ZXJ5U3RyaW5nIHN0aWxsIHJlcXVlc3RlZFxuICAgIHRoaXMuc2VhcmNoID0gJyc7XG4gICAgdGhpcy5xdWVyeSA9IHt9O1xuICB9XG4gIGlmIChyZXN0KSB0aGlzLnBhdGhuYW1lID0gcmVzdDtcbiAgaWYgKHNsYXNoZWRQcm90b2NvbFtsb3dlclByb3RvXSAmJlxuICAgICAgdGhpcy5ob3N0bmFtZSAmJiAhdGhpcy5wYXRobmFtZSkge1xuICAgIHRoaXMucGF0aG5hbWUgPSAnLyc7XG4gIH1cblxuICAvL3RvIHN1cHBvcnQgaHR0cC5yZXF1ZXN0XG4gIGlmICh0aGlzLnBhdGhuYW1lIHx8IHRoaXMuc2VhcmNoKSB7XG4gICAgdmFyIHAgPSB0aGlzLnBhdGhuYW1lIHx8ICcnO1xuICAgIHZhciBzID0gdGhpcy5zZWFyY2ggfHwgJyc7XG4gICAgdGhpcy5wYXRoID0gcCArIHM7XG4gIH1cblxuICAvLyBmaW5hbGx5LCByZWNvbnN0cnVjdCB0aGUgaHJlZiBiYXNlZCBvbiB3aGF0IGhhcyBiZWVuIHZhbGlkYXRlZC5cbiAgdGhpcy5ocmVmID0gdGhpcy5mb3JtYXQoKTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vLyBmb3JtYXQgYSBwYXJzZWQgb2JqZWN0IGludG8gYSB1cmwgc3RyaW5nXG5mdW5jdGlvbiB1cmxGb3JtYXQob2JqKSB7XG4gIC8vIGVuc3VyZSBpdCdzIGFuIG9iamVjdCwgYW5kIG5vdCBhIHN0cmluZyB1cmwuXG4gIC8vIElmIGl0J3MgYW4gb2JqLCB0aGlzIGlzIGEgbm8tb3AuXG4gIC8vIHRoaXMgd2F5LCB5b3UgY2FuIGNhbGwgdXJsX2Zvcm1hdCgpIG9uIHN0cmluZ3NcbiAgLy8gdG8gY2xlYW4gdXAgcG90ZW50aWFsbHkgd29ua3kgdXJscy5cbiAgaWYgKGlzU3RyaW5nKG9iaikpIG9iaiA9IHVybFBhcnNlKG9iaik7XG4gIGlmICghKG9iaiBpbnN0YW5jZW9mIFVybCkpIHJldHVybiBVcmwucHJvdG90eXBlLmZvcm1hdC5jYWxsKG9iaik7XG4gIHJldHVybiBvYmouZm9ybWF0KCk7XG59XG5cblVybC5wcm90b3R5cGUuZm9ybWF0ID0gZnVuY3Rpb24oKSB7XG4gIHZhciBhdXRoID0gdGhpcy5hdXRoIHx8ICcnO1xuICBpZiAoYXV0aCkge1xuICAgIGF1dGggPSBlbmNvZGVVUklDb21wb25lbnQoYXV0aCk7XG4gICAgYXV0aCA9IGF1dGgucmVwbGFjZSgvJTNBL2ksICc6Jyk7XG4gICAgYXV0aCArPSAnQCc7XG4gIH1cblxuICB2YXIgcHJvdG9jb2wgPSB0aGlzLnByb3RvY29sIHx8ICcnLFxuICAgICAgcGF0aG5hbWUgPSB0aGlzLnBhdGhuYW1lIHx8ICcnLFxuICAgICAgaGFzaCA9IHRoaXMuaGFzaCB8fCAnJyxcbiAgICAgIGhvc3QgPSBmYWxzZSxcbiAgICAgIHF1ZXJ5ID0gJyc7XG5cbiAgaWYgKHRoaXMuaG9zdCkge1xuICAgIGhvc3QgPSBhdXRoICsgdGhpcy5ob3N0O1xuICB9IGVsc2UgaWYgKHRoaXMuaG9zdG5hbWUpIHtcbiAgICBob3N0ID0gYXV0aCArICh0aGlzLmhvc3RuYW1lLmluZGV4T2YoJzonKSA9PT0gLTEgP1xuICAgICAgICB0aGlzLmhvc3RuYW1lIDpcbiAgICAgICAgJ1snICsgdGhpcy5ob3N0bmFtZSArICddJyk7XG4gICAgaWYgKHRoaXMucG9ydCkge1xuICAgICAgaG9zdCArPSAnOicgKyB0aGlzLnBvcnQ7XG4gICAgfVxuICB9XG5cbiAgaWYgKHRoaXMucXVlcnkgJiZcbiAgICAgIGlzT2JqZWN0KHRoaXMucXVlcnkpICYmXG4gICAgICBPYmplY3Qua2V5cyh0aGlzLnF1ZXJ5KS5sZW5ndGgpIHtcbiAgICBxdWVyeSA9IHF1ZXJ5c3RyaW5nLnN0cmluZ2lmeSh0aGlzLnF1ZXJ5KTtcbiAgfVxuXG4gIHZhciBzZWFyY2ggPSB0aGlzLnNlYXJjaCB8fCAocXVlcnkgJiYgKCc/JyArIHF1ZXJ5KSkgfHwgJyc7XG5cbiAgaWYgKHByb3RvY29sICYmIHByb3RvY29sLnN1YnN0cigtMSkgIT09ICc6JykgcHJvdG9jb2wgKz0gJzonO1xuXG4gIC8vIG9ubHkgdGhlIHNsYXNoZWRQcm90b2NvbHMgZ2V0IHRoZSAvLy4gIE5vdCBtYWlsdG86LCB4bXBwOiwgZXRjLlxuICAvLyB1bmxlc3MgdGhleSBoYWQgdGhlbSB0byBiZWdpbiB3aXRoLlxuICBpZiAodGhpcy5zbGFzaGVzIHx8XG4gICAgICAoIXByb3RvY29sIHx8IHNsYXNoZWRQcm90b2NvbFtwcm90b2NvbF0pICYmIGhvc3QgIT09IGZhbHNlKSB7XG4gICAgaG9zdCA9ICcvLycgKyAoaG9zdCB8fCAnJyk7XG4gICAgaWYgKHBhdGhuYW1lICYmIHBhdGhuYW1lLmNoYXJBdCgwKSAhPT0gJy8nKSBwYXRobmFtZSA9ICcvJyArIHBhdGhuYW1lO1xuICB9IGVsc2UgaWYgKCFob3N0KSB7XG4gICAgaG9zdCA9ICcnO1xuICB9XG5cbiAgaWYgKGhhc2ggJiYgaGFzaC5jaGFyQXQoMCkgIT09ICcjJykgaGFzaCA9ICcjJyArIGhhc2g7XG4gIGlmIChzZWFyY2ggJiYgc2VhcmNoLmNoYXJBdCgwKSAhPT0gJz8nKSBzZWFyY2ggPSAnPycgKyBzZWFyY2g7XG5cbiAgcGF0aG5hbWUgPSBwYXRobmFtZS5yZXBsYWNlKC9bPyNdL2csIGZ1bmN0aW9uKG1hdGNoKSB7XG4gICAgcmV0dXJuIGVuY29kZVVSSUNvbXBvbmVudChtYXRjaCk7XG4gIH0pO1xuICBzZWFyY2ggPSBzZWFyY2gucmVwbGFjZSgnIycsICclMjMnKTtcblxuICByZXR1cm4gcHJvdG9jb2wgKyBob3N0ICsgcGF0aG5hbWUgKyBzZWFyY2ggKyBoYXNoO1xufTtcblxuZnVuY3Rpb24gdXJsUmVzb2x2ZShzb3VyY2UsIHJlbGF0aXZlKSB7XG4gIHJldHVybiB1cmxQYXJzZShzb3VyY2UsIGZhbHNlLCB0cnVlKS5yZXNvbHZlKHJlbGF0aXZlKTtcbn1cblxuVXJsLnByb3RvdHlwZS5yZXNvbHZlID0gZnVuY3Rpb24ocmVsYXRpdmUpIHtcbiAgcmV0dXJuIHRoaXMucmVzb2x2ZU9iamVjdCh1cmxQYXJzZShyZWxhdGl2ZSwgZmFsc2UsIHRydWUpKS5mb3JtYXQoKTtcbn07XG5cbmZ1bmN0aW9uIHVybFJlc29sdmVPYmplY3Qoc291cmNlLCByZWxhdGl2ZSkge1xuICBpZiAoIXNvdXJjZSkgcmV0dXJuIHJlbGF0aXZlO1xuICByZXR1cm4gdXJsUGFyc2Uoc291cmNlLCBmYWxzZSwgdHJ1ZSkucmVzb2x2ZU9iamVjdChyZWxhdGl2ZSk7XG59XG5cblVybC5wcm90b3R5cGUucmVzb2x2ZU9iamVjdCA9IGZ1bmN0aW9uKHJlbGF0aXZlKSB7XG4gIGlmIChpc1N0cmluZyhyZWxhdGl2ZSkpIHtcbiAgICB2YXIgcmVsID0gbmV3IFVybCgpO1xuICAgIHJlbC5wYXJzZShyZWxhdGl2ZSwgZmFsc2UsIHRydWUpO1xuICAgIHJlbGF0aXZlID0gcmVsO1xuICB9XG5cbiAgdmFyIHJlc3VsdCA9IG5ldyBVcmwoKTtcbiAgT2JqZWN0LmtleXModGhpcykuZm9yRWFjaChmdW5jdGlvbihrKSB7XG4gICAgcmVzdWx0W2tdID0gdGhpc1trXTtcbiAgfSwgdGhpcyk7XG5cbiAgLy8gaGFzaCBpcyBhbHdheXMgb3ZlcnJpZGRlbiwgbm8gbWF0dGVyIHdoYXQuXG4gIC8vIGV2ZW4gaHJlZj1cIlwiIHdpbGwgcmVtb3ZlIGl0LlxuICByZXN1bHQuaGFzaCA9IHJlbGF0aXZlLmhhc2g7XG5cbiAgLy8gaWYgdGhlIHJlbGF0aXZlIHVybCBpcyBlbXB0eSwgdGhlbiB0aGVyZSdzIG5vdGhpbmcgbGVmdCB0byBkbyBoZXJlLlxuICBpZiAocmVsYXRpdmUuaHJlZiA9PT0gJycpIHtcbiAgICByZXN1bHQuaHJlZiA9IHJlc3VsdC5mb3JtYXQoKTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgLy8gaHJlZnMgbGlrZSAvL2Zvby9iYXIgYWx3YXlzIGN1dCB0byB0aGUgcHJvdG9jb2wuXG4gIGlmIChyZWxhdGl2ZS5zbGFzaGVzICYmICFyZWxhdGl2ZS5wcm90b2NvbCkge1xuICAgIC8vIHRha2UgZXZlcnl0aGluZyBleGNlcHQgdGhlIHByb3RvY29sIGZyb20gcmVsYXRpdmVcbiAgICBPYmplY3Qua2V5cyhyZWxhdGl2ZSkuZm9yRWFjaChmdW5jdGlvbihrKSB7XG4gICAgICBpZiAoayAhPT0gJ3Byb3RvY29sJylcbiAgICAgICAgcmVzdWx0W2tdID0gcmVsYXRpdmVba107XG4gICAgfSk7XG5cbiAgICAvL3VybFBhcnNlIGFwcGVuZHMgdHJhaWxpbmcgLyB0byB1cmxzIGxpa2UgaHR0cDovL3d3dy5leGFtcGxlLmNvbVxuICAgIGlmIChzbGFzaGVkUHJvdG9jb2xbcmVzdWx0LnByb3RvY29sXSAmJlxuICAgICAgICByZXN1bHQuaG9zdG5hbWUgJiYgIXJlc3VsdC5wYXRobmFtZSkge1xuICAgICAgcmVzdWx0LnBhdGggPSByZXN1bHQucGF0aG5hbWUgPSAnLyc7XG4gICAgfVxuXG4gICAgcmVzdWx0LmhyZWYgPSByZXN1bHQuZm9ybWF0KCk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIGlmIChyZWxhdGl2ZS5wcm90b2NvbCAmJiByZWxhdGl2ZS5wcm90b2NvbCAhPT0gcmVzdWx0LnByb3RvY29sKSB7XG4gICAgLy8gaWYgaXQncyBhIGtub3duIHVybCBwcm90b2NvbCwgdGhlbiBjaGFuZ2luZ1xuICAgIC8vIHRoZSBwcm90b2NvbCBkb2VzIHdlaXJkIHRoaW5nc1xuICAgIC8vIGZpcnN0LCBpZiBpdCdzIG5vdCBmaWxlOiwgdGhlbiB3ZSBNVVNUIGhhdmUgYSBob3N0LFxuICAgIC8vIGFuZCBpZiB0aGVyZSB3YXMgYSBwYXRoXG4gICAgLy8gdG8gYmVnaW4gd2l0aCwgdGhlbiB3ZSBNVVNUIGhhdmUgYSBwYXRoLlxuICAgIC8vIGlmIGl0IGlzIGZpbGU6LCB0aGVuIHRoZSBob3N0IGlzIGRyb3BwZWQsXG4gICAgLy8gYmVjYXVzZSB0aGF0J3Mga25vd24gdG8gYmUgaG9zdGxlc3MuXG4gICAgLy8gYW55dGhpbmcgZWxzZSBpcyBhc3N1bWVkIHRvIGJlIGFic29sdXRlLlxuICAgIGlmICghc2xhc2hlZFByb3RvY29sW3JlbGF0aXZlLnByb3RvY29sXSkge1xuICAgICAgT2JqZWN0LmtleXMocmVsYXRpdmUpLmZvckVhY2goZnVuY3Rpb24oaykge1xuICAgICAgICByZXN1bHRba10gPSByZWxhdGl2ZVtrXTtcbiAgICAgIH0pO1xuICAgICAgcmVzdWx0LmhyZWYgPSByZXN1bHQuZm9ybWF0KCk7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIHJlc3VsdC5wcm90b2NvbCA9IHJlbGF0aXZlLnByb3RvY29sO1xuICAgIGlmICghcmVsYXRpdmUuaG9zdCAmJiAhaG9zdGxlc3NQcm90b2NvbFtyZWxhdGl2ZS5wcm90b2NvbF0pIHtcbiAgICAgIHZhciByZWxQYXRoID0gKHJlbGF0aXZlLnBhdGhuYW1lIHx8ICcnKS5zcGxpdCgnLycpO1xuICAgICAgd2hpbGUgKHJlbFBhdGgubGVuZ3RoICYmICEocmVsYXRpdmUuaG9zdCA9IHJlbFBhdGguc2hpZnQoKSkpO1xuICAgICAgaWYgKCFyZWxhdGl2ZS5ob3N0KSByZWxhdGl2ZS5ob3N0ID0gJyc7XG4gICAgICBpZiAoIXJlbGF0aXZlLmhvc3RuYW1lKSByZWxhdGl2ZS5ob3N0bmFtZSA9ICcnO1xuICAgICAgaWYgKHJlbFBhdGhbMF0gIT09ICcnKSByZWxQYXRoLnVuc2hpZnQoJycpO1xuICAgICAgaWYgKHJlbFBhdGgubGVuZ3RoIDwgMikgcmVsUGF0aC51bnNoaWZ0KCcnKTtcbiAgICAgIHJlc3VsdC5wYXRobmFtZSA9IHJlbFBhdGguam9pbignLycpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXN1bHQucGF0aG5hbWUgPSByZWxhdGl2ZS5wYXRobmFtZTtcbiAgICB9XG4gICAgcmVzdWx0LnNlYXJjaCA9IHJlbGF0aXZlLnNlYXJjaDtcbiAgICByZXN1bHQucXVlcnkgPSByZWxhdGl2ZS5xdWVyeTtcbiAgICByZXN1bHQuaG9zdCA9IHJlbGF0aXZlLmhvc3QgfHwgJyc7XG4gICAgcmVzdWx0LmF1dGggPSByZWxhdGl2ZS5hdXRoO1xuICAgIHJlc3VsdC5ob3N0bmFtZSA9IHJlbGF0aXZlLmhvc3RuYW1lIHx8IHJlbGF0aXZlLmhvc3Q7XG4gICAgcmVzdWx0LnBvcnQgPSByZWxhdGl2ZS5wb3J0O1xuICAgIC8vIHRvIHN1cHBvcnQgaHR0cC5yZXF1ZXN0XG4gICAgaWYgKHJlc3VsdC5wYXRobmFtZSB8fCByZXN1bHQuc2VhcmNoKSB7XG4gICAgICB2YXIgcCA9IHJlc3VsdC5wYXRobmFtZSB8fCAnJztcbiAgICAgIHZhciBzID0gcmVzdWx0LnNlYXJjaCB8fCAnJztcbiAgICAgIHJlc3VsdC5wYXRoID0gcCArIHM7XG4gICAgfVxuICAgIHJlc3VsdC5zbGFzaGVzID0gcmVzdWx0LnNsYXNoZXMgfHwgcmVsYXRpdmUuc2xhc2hlcztcbiAgICByZXN1bHQuaHJlZiA9IHJlc3VsdC5mb3JtYXQoKTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgdmFyIGlzU291cmNlQWJzID0gKHJlc3VsdC5wYXRobmFtZSAmJiByZXN1bHQucGF0aG5hbWUuY2hhckF0KDApID09PSAnLycpLFxuICAgICAgaXNSZWxBYnMgPSAoXG4gICAgICAgICAgcmVsYXRpdmUuaG9zdCB8fFxuICAgICAgICAgIHJlbGF0aXZlLnBhdGhuYW1lICYmIHJlbGF0aXZlLnBhdGhuYW1lLmNoYXJBdCgwKSA9PT0gJy8nXG4gICAgICApLFxuICAgICAgbXVzdEVuZEFicyA9IChpc1JlbEFicyB8fCBpc1NvdXJjZUFicyB8fFxuICAgICAgICAgICAgICAgICAgICAocmVzdWx0Lmhvc3QgJiYgcmVsYXRpdmUucGF0aG5hbWUpKSxcbiAgICAgIHJlbW92ZUFsbERvdHMgPSBtdXN0RW5kQWJzLFxuICAgICAgc3JjUGF0aCA9IHJlc3VsdC5wYXRobmFtZSAmJiByZXN1bHQucGF0aG5hbWUuc3BsaXQoJy8nKSB8fCBbXSxcbiAgICAgIHJlbFBhdGggPSByZWxhdGl2ZS5wYXRobmFtZSAmJiByZWxhdGl2ZS5wYXRobmFtZS5zcGxpdCgnLycpIHx8IFtdLFxuICAgICAgcHN5Y2hvdGljID0gcmVzdWx0LnByb3RvY29sICYmICFzbGFzaGVkUHJvdG9jb2xbcmVzdWx0LnByb3RvY29sXTtcblxuICAvLyBpZiB0aGUgdXJsIGlzIGEgbm9uLXNsYXNoZWQgdXJsLCB0aGVuIHJlbGF0aXZlXG4gIC8vIGxpbmtzIGxpa2UgLi4vLi4gc2hvdWxkIGJlIGFibGVcbiAgLy8gdG8gY3Jhd2wgdXAgdG8gdGhlIGhvc3RuYW1lLCBhcyB3ZWxsLiAgVGhpcyBpcyBzdHJhbmdlLlxuICAvLyByZXN1bHQucHJvdG9jb2wgaGFzIGFscmVhZHkgYmVlbiBzZXQgYnkgbm93LlxuICAvLyBMYXRlciBvbiwgcHV0IHRoZSBmaXJzdCBwYXRoIHBhcnQgaW50byB0aGUgaG9zdCBmaWVsZC5cbiAgaWYgKHBzeWNob3RpYykge1xuICAgIHJlc3VsdC5ob3N0bmFtZSA9ICcnO1xuICAgIHJlc3VsdC5wb3J0ID0gbnVsbDtcbiAgICBpZiAocmVzdWx0Lmhvc3QpIHtcbiAgICAgIGlmIChzcmNQYXRoWzBdID09PSAnJykgc3JjUGF0aFswXSA9IHJlc3VsdC5ob3N0O1xuICAgICAgZWxzZSBzcmNQYXRoLnVuc2hpZnQocmVzdWx0Lmhvc3QpO1xuICAgIH1cbiAgICByZXN1bHQuaG9zdCA9ICcnO1xuICAgIGlmIChyZWxhdGl2ZS5wcm90b2NvbCkge1xuICAgICAgcmVsYXRpdmUuaG9zdG5hbWUgPSBudWxsO1xuICAgICAgcmVsYXRpdmUucG9ydCA9IG51bGw7XG4gICAgICBpZiAocmVsYXRpdmUuaG9zdCkge1xuICAgICAgICBpZiAocmVsUGF0aFswXSA9PT0gJycpIHJlbFBhdGhbMF0gPSByZWxhdGl2ZS5ob3N0O1xuICAgICAgICBlbHNlIHJlbFBhdGgudW5zaGlmdChyZWxhdGl2ZS5ob3N0KTtcbiAgICAgIH1cbiAgICAgIHJlbGF0aXZlLmhvc3QgPSBudWxsO1xuICAgIH1cbiAgICBtdXN0RW5kQWJzID0gbXVzdEVuZEFicyAmJiAocmVsUGF0aFswXSA9PT0gJycgfHwgc3JjUGF0aFswXSA9PT0gJycpO1xuICB9XG5cbiAgaWYgKGlzUmVsQWJzKSB7XG4gICAgLy8gaXQncyBhYnNvbHV0ZS5cbiAgICByZXN1bHQuaG9zdCA9IChyZWxhdGl2ZS5ob3N0IHx8IHJlbGF0aXZlLmhvc3QgPT09ICcnKSA/XG4gICAgICAgICAgICAgICAgICByZWxhdGl2ZS5ob3N0IDogcmVzdWx0Lmhvc3Q7XG4gICAgcmVzdWx0Lmhvc3RuYW1lID0gKHJlbGF0aXZlLmhvc3RuYW1lIHx8IHJlbGF0aXZlLmhvc3RuYW1lID09PSAnJykgP1xuICAgICAgICAgICAgICAgICAgICAgIHJlbGF0aXZlLmhvc3RuYW1lIDogcmVzdWx0Lmhvc3RuYW1lO1xuICAgIHJlc3VsdC5zZWFyY2ggPSByZWxhdGl2ZS5zZWFyY2g7XG4gICAgcmVzdWx0LnF1ZXJ5ID0gcmVsYXRpdmUucXVlcnk7XG4gICAgc3JjUGF0aCA9IHJlbFBhdGg7XG4gICAgLy8gZmFsbCB0aHJvdWdoIHRvIHRoZSBkb3QtaGFuZGxpbmcgYmVsb3cuXG4gIH0gZWxzZSBpZiAocmVsUGF0aC5sZW5ndGgpIHtcbiAgICAvLyBpdCdzIHJlbGF0aXZlXG4gICAgLy8gdGhyb3cgYXdheSB0aGUgZXhpc3RpbmcgZmlsZSwgYW5kIHRha2UgdGhlIG5ldyBwYXRoIGluc3RlYWQuXG4gICAgaWYgKCFzcmNQYXRoKSBzcmNQYXRoID0gW107XG4gICAgc3JjUGF0aC5wb3AoKTtcbiAgICBzcmNQYXRoID0gc3JjUGF0aC5jb25jYXQocmVsUGF0aCk7XG4gICAgcmVzdWx0LnNlYXJjaCA9IHJlbGF0aXZlLnNlYXJjaDtcbiAgICByZXN1bHQucXVlcnkgPSByZWxhdGl2ZS5xdWVyeTtcbiAgfSBlbHNlIGlmICghaXNOdWxsT3JVbmRlZmluZWQocmVsYXRpdmUuc2VhcmNoKSkge1xuICAgIC8vIGp1c3QgcHVsbCBvdXQgdGhlIHNlYXJjaC5cbiAgICAvLyBsaWtlIGhyZWY9Jz9mb28nLlxuICAgIC8vIFB1dCB0aGlzIGFmdGVyIHRoZSBvdGhlciB0d28gY2FzZXMgYmVjYXVzZSBpdCBzaW1wbGlmaWVzIHRoZSBib29sZWFuc1xuICAgIGlmIChwc3ljaG90aWMpIHtcbiAgICAgIHJlc3VsdC5ob3N0bmFtZSA9IHJlc3VsdC5ob3N0ID0gc3JjUGF0aC5zaGlmdCgpO1xuICAgICAgLy9vY2NhdGlvbmFseSB0aGUgYXV0aCBjYW4gZ2V0IHN0dWNrIG9ubHkgaW4gaG9zdFxuICAgICAgLy90aGlzIGVzcGVjaWFseSBoYXBwZW5zIGluIGNhc2VzIGxpa2VcbiAgICAgIC8vdXJsLnJlc29sdmVPYmplY3QoJ21haWx0bzpsb2NhbDFAZG9tYWluMScsICdsb2NhbDJAZG9tYWluMicpXG4gICAgICB2YXIgYXV0aEluSG9zdCA9IHJlc3VsdC5ob3N0ICYmIHJlc3VsdC5ob3N0LmluZGV4T2YoJ0AnKSA+IDAgP1xuICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQuaG9zdC5zcGxpdCgnQCcpIDogZmFsc2U7XG4gICAgICBpZiAoYXV0aEluSG9zdCkge1xuICAgICAgICByZXN1bHQuYXV0aCA9IGF1dGhJbkhvc3Quc2hpZnQoKTtcbiAgICAgICAgcmVzdWx0Lmhvc3QgPSByZXN1bHQuaG9zdG5hbWUgPSBhdXRoSW5Ib3N0LnNoaWZ0KCk7XG4gICAgICB9XG4gICAgfVxuICAgIHJlc3VsdC5zZWFyY2ggPSByZWxhdGl2ZS5zZWFyY2g7XG4gICAgcmVzdWx0LnF1ZXJ5ID0gcmVsYXRpdmUucXVlcnk7XG4gICAgLy90byBzdXBwb3J0IGh0dHAucmVxdWVzdFxuICAgIGlmICghaXNOdWxsKHJlc3VsdC5wYXRobmFtZSkgfHwgIWlzTnVsbChyZXN1bHQuc2VhcmNoKSkge1xuICAgICAgcmVzdWx0LnBhdGggPSAocmVzdWx0LnBhdGhuYW1lID8gcmVzdWx0LnBhdGhuYW1lIDogJycpICtcbiAgICAgICAgICAgICAgICAgICAgKHJlc3VsdC5zZWFyY2ggPyByZXN1bHQuc2VhcmNoIDogJycpO1xuICAgIH1cbiAgICByZXN1bHQuaHJlZiA9IHJlc3VsdC5mb3JtYXQoKTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgaWYgKCFzcmNQYXRoLmxlbmd0aCkge1xuICAgIC8vIG5vIHBhdGggYXQgYWxsLiAgZWFzeS5cbiAgICAvLyB3ZSd2ZSBhbHJlYWR5IGhhbmRsZWQgdGhlIG90aGVyIHN0dWZmIGFib3ZlLlxuICAgIHJlc3VsdC5wYXRobmFtZSA9IG51bGw7XG4gICAgLy90byBzdXBwb3J0IGh0dHAucmVxdWVzdFxuICAgIGlmIChyZXN1bHQuc2VhcmNoKSB7XG4gICAgICByZXN1bHQucGF0aCA9ICcvJyArIHJlc3VsdC5zZWFyY2g7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlc3VsdC5wYXRoID0gbnVsbDtcbiAgICB9XG4gICAgcmVzdWx0LmhyZWYgPSByZXN1bHQuZm9ybWF0KCk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIC8vIGlmIGEgdXJsIEVORHMgaW4gLiBvciAuLiwgdGhlbiBpdCBtdXN0IGdldCBhIHRyYWlsaW5nIHNsYXNoLlxuICAvLyBob3dldmVyLCBpZiBpdCBlbmRzIGluIGFueXRoaW5nIGVsc2Ugbm9uLXNsYXNoeSxcbiAgLy8gdGhlbiBpdCBtdXN0IE5PVCBnZXQgYSB0cmFpbGluZyBzbGFzaC5cbiAgdmFyIGxhc3QgPSBzcmNQYXRoLnNsaWNlKC0xKVswXTtcbiAgdmFyIGhhc1RyYWlsaW5nU2xhc2ggPSAoXG4gICAgICAocmVzdWx0Lmhvc3QgfHwgcmVsYXRpdmUuaG9zdCkgJiYgKGxhc3QgPT09ICcuJyB8fCBsYXN0ID09PSAnLi4nKSB8fFxuICAgICAgbGFzdCA9PT0gJycpO1xuXG4gIC8vIHN0cmlwIHNpbmdsZSBkb3RzLCByZXNvbHZlIGRvdWJsZSBkb3RzIHRvIHBhcmVudCBkaXJcbiAgLy8gaWYgdGhlIHBhdGggdHJpZXMgdG8gZ28gYWJvdmUgdGhlIHJvb3QsIGB1cGAgZW5kcyB1cCA+IDBcbiAgdmFyIHVwID0gMDtcbiAgZm9yICh2YXIgaSA9IHNyY1BhdGgubGVuZ3RoOyBpID49IDA7IGktLSkge1xuICAgIGxhc3QgPSBzcmNQYXRoW2ldO1xuICAgIGlmIChsYXN0ID09ICcuJykge1xuICAgICAgc3JjUGF0aC5zcGxpY2UoaSwgMSk7XG4gICAgfSBlbHNlIGlmIChsYXN0ID09PSAnLi4nKSB7XG4gICAgICBzcmNQYXRoLnNwbGljZShpLCAxKTtcbiAgICAgIHVwKys7XG4gICAgfSBlbHNlIGlmICh1cCkge1xuICAgICAgc3JjUGF0aC5zcGxpY2UoaSwgMSk7XG4gICAgICB1cC0tO1xuICAgIH1cbiAgfVxuXG4gIC8vIGlmIHRoZSBwYXRoIGlzIGFsbG93ZWQgdG8gZ28gYWJvdmUgdGhlIHJvb3QsIHJlc3RvcmUgbGVhZGluZyAuLnNcbiAgaWYgKCFtdXN0RW5kQWJzICYmICFyZW1vdmVBbGxEb3RzKSB7XG4gICAgZm9yICg7IHVwLS07IHVwKSB7XG4gICAgICBzcmNQYXRoLnVuc2hpZnQoJy4uJyk7XG4gICAgfVxuICB9XG5cbiAgaWYgKG11c3RFbmRBYnMgJiYgc3JjUGF0aFswXSAhPT0gJycgJiZcbiAgICAgICghc3JjUGF0aFswXSB8fCBzcmNQYXRoWzBdLmNoYXJBdCgwKSAhPT0gJy8nKSkge1xuICAgIHNyY1BhdGgudW5zaGlmdCgnJyk7XG4gIH1cblxuICBpZiAoaGFzVHJhaWxpbmdTbGFzaCAmJiAoc3JjUGF0aC5qb2luKCcvJykuc3Vic3RyKC0xKSAhPT0gJy8nKSkge1xuICAgIHNyY1BhdGgucHVzaCgnJyk7XG4gIH1cblxuICB2YXIgaXNBYnNvbHV0ZSA9IHNyY1BhdGhbMF0gPT09ICcnIHx8XG4gICAgICAoc3JjUGF0aFswXSAmJiBzcmNQYXRoWzBdLmNoYXJBdCgwKSA9PT0gJy8nKTtcblxuICAvLyBwdXQgdGhlIGhvc3QgYmFja1xuICBpZiAocHN5Y2hvdGljKSB7XG4gICAgcmVzdWx0Lmhvc3RuYW1lID0gcmVzdWx0Lmhvc3QgPSBpc0Fic29sdXRlID8gJycgOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3JjUGF0aC5sZW5ndGggPyBzcmNQYXRoLnNoaWZ0KCkgOiAnJztcbiAgICAvL29jY2F0aW9uYWx5IHRoZSBhdXRoIGNhbiBnZXQgc3R1Y2sgb25seSBpbiBob3N0XG4gICAgLy90aGlzIGVzcGVjaWFseSBoYXBwZW5zIGluIGNhc2VzIGxpa2VcbiAgICAvL3VybC5yZXNvbHZlT2JqZWN0KCdtYWlsdG86bG9jYWwxQGRvbWFpbjEnLCAnbG9jYWwyQGRvbWFpbjInKVxuICAgIHZhciBhdXRoSW5Ib3N0ID0gcmVzdWx0Lmhvc3QgJiYgcmVzdWx0Lmhvc3QuaW5kZXhPZignQCcpID4gMCA/XG4gICAgICAgICAgICAgICAgICAgICByZXN1bHQuaG9zdC5zcGxpdCgnQCcpIDogZmFsc2U7XG4gICAgaWYgKGF1dGhJbkhvc3QpIHtcbiAgICAgIHJlc3VsdC5hdXRoID0gYXV0aEluSG9zdC5zaGlmdCgpO1xuICAgICAgcmVzdWx0Lmhvc3QgPSByZXN1bHQuaG9zdG5hbWUgPSBhdXRoSW5Ib3N0LnNoaWZ0KCk7XG4gICAgfVxuICB9XG5cbiAgbXVzdEVuZEFicyA9IG11c3RFbmRBYnMgfHwgKHJlc3VsdC5ob3N0ICYmIHNyY1BhdGgubGVuZ3RoKTtcblxuICBpZiAobXVzdEVuZEFicyAmJiAhaXNBYnNvbHV0ZSkge1xuICAgIHNyY1BhdGgudW5zaGlmdCgnJyk7XG4gIH1cblxuICBpZiAoIXNyY1BhdGgubGVuZ3RoKSB7XG4gICAgcmVzdWx0LnBhdGhuYW1lID0gbnVsbDtcbiAgICByZXN1bHQucGF0aCA9IG51bGw7XG4gIH0gZWxzZSB7XG4gICAgcmVzdWx0LnBhdGhuYW1lID0gc3JjUGF0aC5qb2luKCcvJyk7XG4gIH1cblxuICAvL3RvIHN1cHBvcnQgcmVxdWVzdC5odHRwXG4gIGlmICghaXNOdWxsKHJlc3VsdC5wYXRobmFtZSkgfHwgIWlzTnVsbChyZXN1bHQuc2VhcmNoKSkge1xuICAgIHJlc3VsdC5wYXRoID0gKHJlc3VsdC5wYXRobmFtZSA/IHJlc3VsdC5wYXRobmFtZSA6ICcnKSArXG4gICAgICAgICAgICAgICAgICAocmVzdWx0LnNlYXJjaCA/IHJlc3VsdC5zZWFyY2ggOiAnJyk7XG4gIH1cbiAgcmVzdWx0LmF1dGggPSByZWxhdGl2ZS5hdXRoIHx8IHJlc3VsdC5hdXRoO1xuICByZXN1bHQuc2xhc2hlcyA9IHJlc3VsdC5zbGFzaGVzIHx8IHJlbGF0aXZlLnNsYXNoZXM7XG4gIHJlc3VsdC5ocmVmID0gcmVzdWx0LmZvcm1hdCgpO1xuICByZXR1cm4gcmVzdWx0O1xufTtcblxuVXJsLnByb3RvdHlwZS5wYXJzZUhvc3QgPSBmdW5jdGlvbigpIHtcbiAgdmFyIGhvc3QgPSB0aGlzLmhvc3Q7XG4gIHZhciBwb3J0ID0gcG9ydFBhdHRlcm4uZXhlYyhob3N0KTtcbiAgaWYgKHBvcnQpIHtcbiAgICBwb3J0ID0gcG9ydFswXTtcbiAgICBpZiAocG9ydCAhPT0gJzonKSB7XG4gICAgICB0aGlzLnBvcnQgPSBwb3J0LnN1YnN0cigxKTtcbiAgICB9XG4gICAgaG9zdCA9IGhvc3Quc3Vic3RyKDAsIGhvc3QubGVuZ3RoIC0gcG9ydC5sZW5ndGgpO1xuICB9XG4gIGlmIChob3N0KSB0aGlzLmhvc3RuYW1lID0gaG9zdDtcbn07XG5cbmZ1bmN0aW9uIGlzU3RyaW5nKGFyZykge1xuICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gXCJzdHJpbmdcIjtcbn1cblxuZnVuY3Rpb24gaXNPYmplY3QoYXJnKSB7XG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnb2JqZWN0JyAmJiBhcmcgIT09IG51bGw7XG59XG5cbmZ1bmN0aW9uIGlzTnVsbChhcmcpIHtcbiAgcmV0dXJuIGFyZyA9PT0gbnVsbDtcbn1cbmZ1bmN0aW9uIGlzTnVsbE9yVW5kZWZpbmVkKGFyZykge1xuICByZXR1cm4gIGFyZyA9PSBudWxsO1xufVxuIiwidmFyIGh0dHAgPSBtb2R1bGUuZXhwb3J0cztcbnZhciBFdmVudEVtaXR0ZXIgPSByZXF1aXJlKCdldmVudHMnKS5FdmVudEVtaXR0ZXI7XG52YXIgUmVxdWVzdCA9IHJlcXVpcmUoJy4vbGliL3JlcXVlc3QnKTtcbnZhciB1cmwgPSByZXF1aXJlKCd1cmwnKVxuXG5odHRwLnJlcXVlc3QgPSBmdW5jdGlvbiAocGFyYW1zLCBjYikge1xuICAgIGlmICh0eXBlb2YgcGFyYW1zID09PSAnc3RyaW5nJykge1xuICAgICAgICBwYXJhbXMgPSB1cmwucGFyc2UocGFyYW1zKVxuICAgIH1cbiAgICBpZiAoIXBhcmFtcykgcGFyYW1zID0ge307XG4gICAgaWYgKCFwYXJhbXMuaG9zdCAmJiAhcGFyYW1zLnBvcnQpIHtcbiAgICAgICAgcGFyYW1zLnBvcnQgPSBwYXJzZUludCh3aW5kb3cubG9jYXRpb24ucG9ydCwgMTApO1xuICAgIH1cbiAgICBpZiAoIXBhcmFtcy5ob3N0ICYmIHBhcmFtcy5ob3N0bmFtZSkge1xuICAgICAgICBwYXJhbXMuaG9zdCA9IHBhcmFtcy5ob3N0bmFtZTtcbiAgICB9XG4gICAgXG4gICAgaWYgKCFwYXJhbXMuc2NoZW1lKSBwYXJhbXMuc2NoZW1lID0gd2luZG93LmxvY2F0aW9uLnByb3RvY29sLnNwbGl0KCc6JylbMF07XG4gICAgaWYgKCFwYXJhbXMuaG9zdCkge1xuICAgICAgICBwYXJhbXMuaG9zdCA9IHdpbmRvdy5sb2NhdGlvbi5ob3N0bmFtZSB8fCB3aW5kb3cubG9jYXRpb24uaG9zdDtcbiAgICB9XG4gICAgaWYgKC86Ly50ZXN0KHBhcmFtcy5ob3N0KSkge1xuICAgICAgICBpZiAoIXBhcmFtcy5wb3J0KSB7XG4gICAgICAgICAgICBwYXJhbXMucG9ydCA9IHBhcmFtcy5ob3N0LnNwbGl0KCc6JylbMV07XG4gICAgICAgIH1cbiAgICAgICAgcGFyYW1zLmhvc3QgPSBwYXJhbXMuaG9zdC5zcGxpdCgnOicpWzBdO1xuICAgIH1cbiAgICBpZiAoIXBhcmFtcy5wb3J0KSBwYXJhbXMucG9ydCA9IHBhcmFtcy5zY2hlbWUgPT0gJ2h0dHBzJyA/IDQ0MyA6IDgwO1xuICAgIFxuICAgIHZhciByZXEgPSBuZXcgUmVxdWVzdChuZXcgeGhySHR0cCwgcGFyYW1zKTtcbiAgICBpZiAoY2IpIHJlcS5vbigncmVzcG9uc2UnLCBjYik7XG4gICAgcmV0dXJuIHJlcTtcbn07XG5cbmh0dHAuZ2V0ID0gZnVuY3Rpb24gKHBhcmFtcywgY2IpIHtcbiAgICBwYXJhbXMubWV0aG9kID0gJ0dFVCc7XG4gICAgdmFyIHJlcSA9IGh0dHAucmVxdWVzdChwYXJhbXMsIGNiKTtcbiAgICByZXEuZW5kKCk7XG4gICAgcmV0dXJuIHJlcTtcbn07XG5cbmh0dHAuQWdlbnQgPSBmdW5jdGlvbiAoKSB7fTtcbmh0dHAuQWdlbnQuZGVmYXVsdE1heFNvY2tldHMgPSA0O1xuXG52YXIgeGhySHR0cCA9IChmdW5jdGlvbiAoKSB7XG4gICAgaWYgKHR5cGVvZiB3aW5kb3cgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignbm8gd2luZG93IG9iamVjdCBwcmVzZW50Jyk7XG4gICAgfVxuICAgIGVsc2UgaWYgKHdpbmRvdy5YTUxIdHRwUmVxdWVzdCkge1xuICAgICAgICByZXR1cm4gd2luZG93LlhNTEh0dHBSZXF1ZXN0O1xuICAgIH1cbiAgICBlbHNlIGlmICh3aW5kb3cuQWN0aXZlWE9iamVjdCkge1xuICAgICAgICB2YXIgYXhzID0gW1xuICAgICAgICAgICAgJ01zeG1sMi5YTUxIVFRQLjYuMCcsXG4gICAgICAgICAgICAnTXN4bWwyLlhNTEhUVFAuMy4wJyxcbiAgICAgICAgICAgICdNaWNyb3NvZnQuWE1MSFRUUCdcbiAgICAgICAgXTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBheHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgdmFyIGF4ID0gbmV3KHdpbmRvdy5BY3RpdmVYT2JqZWN0KShheHNbaV0pO1xuICAgICAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChheCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGF4XyA9IGF4O1xuICAgICAgICAgICAgICAgICAgICAgICAgYXggPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGF4XztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcod2luZG93LkFjdGl2ZVhPYmplY3QpKGF4c1tpXSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGUpIHt9XG4gICAgICAgIH1cbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdhamF4IG5vdCBzdXBwb3J0ZWQgaW4gdGhpcyBicm93c2VyJylcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignYWpheCBub3Qgc3VwcG9ydGVkIGluIHRoaXMgYnJvd3NlcicpO1xuICAgIH1cbn0pKCk7XG5cbmh0dHAuU1RBVFVTX0NPREVTID0ge1xuICAgIDEwMCA6ICdDb250aW51ZScsXG4gICAgMTAxIDogJ1N3aXRjaGluZyBQcm90b2NvbHMnLFxuICAgIDEwMiA6ICdQcm9jZXNzaW5nJywgICAgICAgICAgICAgICAgIC8vIFJGQyAyNTE4LCBvYnNvbGV0ZWQgYnkgUkZDIDQ5MThcbiAgICAyMDAgOiAnT0snLFxuICAgIDIwMSA6ICdDcmVhdGVkJyxcbiAgICAyMDIgOiAnQWNjZXB0ZWQnLFxuICAgIDIwMyA6ICdOb24tQXV0aG9yaXRhdGl2ZSBJbmZvcm1hdGlvbicsXG4gICAgMjA0IDogJ05vIENvbnRlbnQnLFxuICAgIDIwNSA6ICdSZXNldCBDb250ZW50JyxcbiAgICAyMDYgOiAnUGFydGlhbCBDb250ZW50JyxcbiAgICAyMDcgOiAnTXVsdGktU3RhdHVzJywgICAgICAgICAgICAgICAvLyBSRkMgNDkxOFxuICAgIDMwMCA6ICdNdWx0aXBsZSBDaG9pY2VzJyxcbiAgICAzMDEgOiAnTW92ZWQgUGVybWFuZW50bHknLFxuICAgIDMwMiA6ICdNb3ZlZCBUZW1wb3JhcmlseScsXG4gICAgMzAzIDogJ1NlZSBPdGhlcicsXG4gICAgMzA0IDogJ05vdCBNb2RpZmllZCcsXG4gICAgMzA1IDogJ1VzZSBQcm94eScsXG4gICAgMzA3IDogJ1RlbXBvcmFyeSBSZWRpcmVjdCcsXG4gICAgNDAwIDogJ0JhZCBSZXF1ZXN0JyxcbiAgICA0MDEgOiAnVW5hdXRob3JpemVkJyxcbiAgICA0MDIgOiAnUGF5bWVudCBSZXF1aXJlZCcsXG4gICAgNDAzIDogJ0ZvcmJpZGRlbicsXG4gICAgNDA0IDogJ05vdCBGb3VuZCcsXG4gICAgNDA1IDogJ01ldGhvZCBOb3QgQWxsb3dlZCcsXG4gICAgNDA2IDogJ05vdCBBY2NlcHRhYmxlJyxcbiAgICA0MDcgOiAnUHJveHkgQXV0aGVudGljYXRpb24gUmVxdWlyZWQnLFxuICAgIDQwOCA6ICdSZXF1ZXN0IFRpbWUtb3V0JyxcbiAgICA0MDkgOiAnQ29uZmxpY3QnLFxuICAgIDQxMCA6ICdHb25lJyxcbiAgICA0MTEgOiAnTGVuZ3RoIFJlcXVpcmVkJyxcbiAgICA0MTIgOiAnUHJlY29uZGl0aW9uIEZhaWxlZCcsXG4gICAgNDEzIDogJ1JlcXVlc3QgRW50aXR5IFRvbyBMYXJnZScsXG4gICAgNDE0IDogJ1JlcXVlc3QtVVJJIFRvbyBMYXJnZScsXG4gICAgNDE1IDogJ1Vuc3VwcG9ydGVkIE1lZGlhIFR5cGUnLFxuICAgIDQxNiA6ICdSZXF1ZXN0ZWQgUmFuZ2UgTm90IFNhdGlzZmlhYmxlJyxcbiAgICA0MTcgOiAnRXhwZWN0YXRpb24gRmFpbGVkJyxcbiAgICA0MTggOiAnSVxcJ20gYSB0ZWFwb3QnLCAgICAgICAgICAgICAgLy8gUkZDIDIzMjRcbiAgICA0MjIgOiAnVW5wcm9jZXNzYWJsZSBFbnRpdHknLCAgICAgICAvLyBSRkMgNDkxOFxuICAgIDQyMyA6ICdMb2NrZWQnLCAgICAgICAgICAgICAgICAgICAgIC8vIFJGQyA0OTE4XG4gICAgNDI0IDogJ0ZhaWxlZCBEZXBlbmRlbmN5JywgICAgICAgICAgLy8gUkZDIDQ5MThcbiAgICA0MjUgOiAnVW5vcmRlcmVkIENvbGxlY3Rpb24nLCAgICAgICAvLyBSRkMgNDkxOFxuICAgIDQyNiA6ICdVcGdyYWRlIFJlcXVpcmVkJywgICAgICAgICAgIC8vIFJGQyAyODE3XG4gICAgNDI4IDogJ1ByZWNvbmRpdGlvbiBSZXF1aXJlZCcsICAgICAgLy8gUkZDIDY1ODVcbiAgICA0MjkgOiAnVG9vIE1hbnkgUmVxdWVzdHMnLCAgICAgICAgICAvLyBSRkMgNjU4NVxuICAgIDQzMSA6ICdSZXF1ZXN0IEhlYWRlciBGaWVsZHMgVG9vIExhcmdlJywvLyBSRkMgNjU4NVxuICAgIDUwMCA6ICdJbnRlcm5hbCBTZXJ2ZXIgRXJyb3InLFxuICAgIDUwMSA6ICdOb3QgSW1wbGVtZW50ZWQnLFxuICAgIDUwMiA6ICdCYWQgR2F0ZXdheScsXG4gICAgNTAzIDogJ1NlcnZpY2UgVW5hdmFpbGFibGUnLFxuICAgIDUwNCA6ICdHYXRld2F5IFRpbWUtb3V0JyxcbiAgICA1MDUgOiAnSFRUUCBWZXJzaW9uIE5vdCBTdXBwb3J0ZWQnLFxuICAgIDUwNiA6ICdWYXJpYW50IEFsc28gTmVnb3RpYXRlcycsICAgIC8vIFJGQyAyMjk1XG4gICAgNTA3IDogJ0luc3VmZmljaWVudCBTdG9yYWdlJywgICAgICAgLy8gUkZDIDQ5MThcbiAgICA1MDkgOiAnQmFuZHdpZHRoIExpbWl0IEV4Y2VlZGVkJyxcbiAgICA1MTAgOiAnTm90IEV4dGVuZGVkJywgICAgICAgICAgICAgICAvLyBSRkMgMjc3NFxuICAgIDUxMSA6ICdOZXR3b3JrIEF1dGhlbnRpY2F0aW9uIFJlcXVpcmVkJyAvLyBSRkMgNjU4NVxufTsiLCJ2YXIgU3RyZWFtID0gcmVxdWlyZSgnc3RyZWFtJyk7XG52YXIgUmVzcG9uc2UgPSByZXF1aXJlKCcuL3Jlc3BvbnNlJyk7XG52YXIgQmFzZTY0ID0gcmVxdWlyZSgnQmFzZTY0Jyk7XG52YXIgaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpO1xuXG52YXIgUmVxdWVzdCA9IG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKHhociwgcGFyYW1zKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIHNlbGYud3JpdGFibGUgPSB0cnVlO1xuICAgIHNlbGYueGhyID0geGhyO1xuICAgIHNlbGYuYm9keSA9IFtdO1xuICAgIFxuICAgIHNlbGYudXJpID0gKHBhcmFtcy5zY2hlbWUgfHwgJ2h0dHAnKSArICc6Ly8nXG4gICAgICAgICsgcGFyYW1zLmhvc3RcbiAgICAgICAgKyAocGFyYW1zLnBvcnQgPyAnOicgKyBwYXJhbXMucG9ydCA6ICcnKVxuICAgICAgICArIChwYXJhbXMucGF0aCB8fCAnLycpXG4gICAgO1xuICAgIFxuICAgIGlmICh0eXBlb2YgcGFyYW1zLndpdGhDcmVkZW50aWFscyA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgcGFyYW1zLndpdGhDcmVkZW50aWFscyA9IHRydWU7XG4gICAgfVxuXG4gICAgdHJ5IHsgeGhyLndpdGhDcmVkZW50aWFscyA9IHBhcmFtcy53aXRoQ3JlZGVudGlhbHMgfVxuICAgIGNhdGNoIChlKSB7fVxuICAgIFxuICAgIHhoci5vcGVuKFxuICAgICAgICBwYXJhbXMubWV0aG9kIHx8ICdHRVQnLFxuICAgICAgICBzZWxmLnVyaSxcbiAgICAgICAgdHJ1ZVxuICAgICk7XG5cbiAgICBzZWxmLl9oZWFkZXJzID0ge307XG4gICAgXG4gICAgaWYgKHBhcmFtcy5oZWFkZXJzKSB7XG4gICAgICAgIHZhciBrZXlzID0gb2JqZWN0S2V5cyhwYXJhbXMuaGVhZGVycyk7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdmFyIGtleSA9IGtleXNbaV07XG4gICAgICAgICAgICBpZiAoIXNlbGYuaXNTYWZlUmVxdWVzdEhlYWRlcihrZXkpKSBjb250aW51ZTtcbiAgICAgICAgICAgIHZhciB2YWx1ZSA9IHBhcmFtcy5oZWFkZXJzW2tleV07XG4gICAgICAgICAgICBzZWxmLnNldEhlYWRlcihrZXksIHZhbHVlKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBcbiAgICBpZiAocGFyYW1zLmF1dGgpIHtcbiAgICAgICAgLy9iYXNpYyBhdXRoXG4gICAgICAgIHRoaXMuc2V0SGVhZGVyKCdBdXRob3JpemF0aW9uJywgJ0Jhc2ljICcgKyBCYXNlNjQuYnRvYShwYXJhbXMuYXV0aCkpO1xuICAgIH1cblxuICAgIHZhciByZXMgPSBuZXcgUmVzcG9uc2U7XG4gICAgcmVzLm9uKCdjbG9zZScsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgc2VsZi5lbWl0KCdjbG9zZScpO1xuICAgIH0pO1xuICAgIFxuICAgIHJlcy5vbigncmVhZHknLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHNlbGYuZW1pdCgncmVzcG9uc2UnLCByZXMpO1xuICAgIH0pO1xuICAgIFxuICAgIHhoci5vbnJlYWR5c3RhdGVjaGFuZ2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIC8vIEZpeCBmb3IgSUU5IGJ1Z1xuICAgICAgICAvLyBTQ1JJUFQ1NzU6IENvdWxkIG5vdCBjb21wbGV0ZSB0aGUgb3BlcmF0aW9uIGR1ZSB0byBlcnJvciBjMDBjMDIzZlxuICAgICAgICAvLyBJdCBoYXBwZW5zIHdoZW4gYSByZXF1ZXN0IGlzIGFib3J0ZWQsIGNhbGxpbmcgdGhlIHN1Y2Nlc3MgY2FsbGJhY2sgYW55d2F5IHdpdGggcmVhZHlTdGF0ZSA9PT0gNFxuICAgICAgICBpZiAoeGhyLl9fYWJvcnRlZCkgcmV0dXJuO1xuICAgICAgICByZXMuaGFuZGxlKHhocik7XG4gICAgfTtcbn07XG5cbmluaGVyaXRzKFJlcXVlc3QsIFN0cmVhbSk7XG5cblJlcXVlc3QucHJvdG90eXBlLnNldEhlYWRlciA9IGZ1bmN0aW9uIChrZXksIHZhbHVlKSB7XG4gICAgdGhpcy5faGVhZGVyc1trZXkudG9Mb3dlckNhc2UoKV0gPSB2YWx1ZVxufTtcblxuUmVxdWVzdC5wcm90b3R5cGUuZ2V0SGVhZGVyID0gZnVuY3Rpb24gKGtleSkge1xuICAgIHJldHVybiB0aGlzLl9oZWFkZXJzW2tleS50b0xvd2VyQ2FzZSgpXVxufTtcblxuUmVxdWVzdC5wcm90b3R5cGUucmVtb3ZlSGVhZGVyID0gZnVuY3Rpb24gKGtleSkge1xuICAgIGRlbGV0ZSB0aGlzLl9oZWFkZXJzW2tleS50b0xvd2VyQ2FzZSgpXVxufTtcblxuUmVxdWVzdC5wcm90b3R5cGUud3JpdGUgPSBmdW5jdGlvbiAocykge1xuICAgIHRoaXMuYm9keS5wdXNoKHMpO1xufTtcblxuUmVxdWVzdC5wcm90b3R5cGUuZGVzdHJveSA9IGZ1bmN0aW9uIChzKSB7XG4gICAgdGhpcy54aHIuX19hYm9ydGVkID0gdHJ1ZTtcbiAgICB0aGlzLnhoci5hYm9ydCgpO1xuICAgIHRoaXMuZW1pdCgnY2xvc2UnKTtcbn07XG5cblJlcXVlc3QucHJvdG90eXBlLmVuZCA9IGZ1bmN0aW9uIChzKSB7XG4gICAgaWYgKHMgIT09IHVuZGVmaW5lZCkgdGhpcy5ib2R5LnB1c2gocyk7XG5cbiAgICB2YXIga2V5cyA9IG9iamVjdEtleXModGhpcy5faGVhZGVycyk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBrZXkgPSBrZXlzW2ldO1xuICAgICAgICB2YXIgdmFsdWUgPSB0aGlzLl9oZWFkZXJzW2tleV07XG4gICAgICAgIGlmIChpc0FycmF5KHZhbHVlKSkge1xuICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCB2YWx1ZS5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgICAgIHRoaXMueGhyLnNldFJlcXVlc3RIZWFkZXIoa2V5LCB2YWx1ZVtqXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB0aGlzLnhoci5zZXRSZXF1ZXN0SGVhZGVyKGtleSwgdmFsdWUpXG4gICAgfVxuXG4gICAgaWYgKHRoaXMuYm9keS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgdGhpcy54aHIuc2VuZCgnJyk7XG4gICAgfVxuICAgIGVsc2UgaWYgKHR5cGVvZiB0aGlzLmJvZHlbMF0gPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHRoaXMueGhyLnNlbmQodGhpcy5ib2R5LmpvaW4oJycpKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoaXNBcnJheSh0aGlzLmJvZHlbMF0pKSB7XG4gICAgICAgIHZhciBib2R5ID0gW107XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5ib2R5Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBib2R5LnB1c2guYXBwbHkoYm9keSwgdGhpcy5ib2R5W2ldKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnhoci5zZW5kKGJvZHkpO1xuICAgIH1cbiAgICBlbHNlIGlmICgvQXJyYXkvLnRlc3QoT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHRoaXMuYm9keVswXSkpKSB7XG4gICAgICAgIHZhciBsZW4gPSAwO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuYm9keS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgbGVuICs9IHRoaXMuYm9keVtpXS5sZW5ndGg7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGJvZHkgPSBuZXcodGhpcy5ib2R5WzBdLmNvbnN0cnVjdG9yKShsZW4pO1xuICAgICAgICB2YXIgayA9IDA7XG4gICAgICAgIFxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuYm9keS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdmFyIGIgPSB0aGlzLmJvZHlbaV07XG4gICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IGIubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgICAgICBib2R5W2srK10gPSBiW2pdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMueGhyLnNlbmQoYm9keSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICB2YXIgYm9keSA9ICcnO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuYm9keS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgYm9keSArPSB0aGlzLmJvZHlbaV0udG9TdHJpbmcoKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnhoci5zZW5kKGJvZHkpO1xuICAgIH1cbn07XG5cbi8vIFRha2VuIGZyb20gaHR0cDovL2R4ci5tb3ppbGxhLm9yZy9tb3ppbGxhL21vemlsbGEtY2VudHJhbC9jb250ZW50L2Jhc2Uvc3JjL25zWE1MSHR0cFJlcXVlc3QuY3BwLmh0bWxcblJlcXVlc3QudW5zYWZlSGVhZGVycyA9IFtcbiAgICBcImFjY2VwdC1jaGFyc2V0XCIsXG4gICAgXCJhY2NlcHQtZW5jb2RpbmdcIixcbiAgICBcImFjY2Vzcy1jb250cm9sLXJlcXVlc3QtaGVhZGVyc1wiLFxuICAgIFwiYWNjZXNzLWNvbnRyb2wtcmVxdWVzdC1tZXRob2RcIixcbiAgICBcImNvbm5lY3Rpb25cIixcbiAgICBcImNvbnRlbnQtbGVuZ3RoXCIsXG4gICAgXCJjb29raWVcIixcbiAgICBcImNvb2tpZTJcIixcbiAgICBcImNvbnRlbnQtdHJhbnNmZXItZW5jb2RpbmdcIixcbiAgICBcImRhdGVcIixcbiAgICBcImV4cGVjdFwiLFxuICAgIFwiaG9zdFwiLFxuICAgIFwia2VlcC1hbGl2ZVwiLFxuICAgIFwib3JpZ2luXCIsXG4gICAgXCJyZWZlcmVyXCIsXG4gICAgXCJ0ZVwiLFxuICAgIFwidHJhaWxlclwiLFxuICAgIFwidHJhbnNmZXItZW5jb2RpbmdcIixcbiAgICBcInVwZ3JhZGVcIixcbiAgICBcInVzZXItYWdlbnRcIixcbiAgICBcInZpYVwiXG5dO1xuXG5SZXF1ZXN0LnByb3RvdHlwZS5pc1NhZmVSZXF1ZXN0SGVhZGVyID0gZnVuY3Rpb24gKGhlYWRlck5hbWUpIHtcbiAgICBpZiAoIWhlYWRlck5hbWUpIHJldHVybiBmYWxzZTtcbiAgICByZXR1cm4gaW5kZXhPZihSZXF1ZXN0LnVuc2FmZUhlYWRlcnMsIGhlYWRlck5hbWUudG9Mb3dlckNhc2UoKSkgPT09IC0xO1xufTtcblxudmFyIG9iamVjdEtleXMgPSBPYmplY3Qua2V5cyB8fCBmdW5jdGlvbiAob2JqKSB7XG4gICAgdmFyIGtleXMgPSBbXTtcbiAgICBmb3IgKHZhciBrZXkgaW4gb2JqKSBrZXlzLnB1c2goa2V5KTtcbiAgICByZXR1cm4ga2V5cztcbn07XG5cbnZhciBpc0FycmF5ID0gQXJyYXkuaXNBcnJheSB8fCBmdW5jdGlvbiAoeHMpIHtcbiAgICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHhzKSA9PT0gJ1tvYmplY3QgQXJyYXldJztcbn07XG5cbnZhciBpbmRleE9mID0gZnVuY3Rpb24gKHhzLCB4KSB7XG4gICAgaWYgKHhzLmluZGV4T2YpIHJldHVybiB4cy5pbmRleE9mKHgpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgeHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKHhzW2ldID09PSB4KSByZXR1cm4gaTtcbiAgICB9XG4gICAgcmV0dXJuIC0xO1xufTtcbiIsInZhciBTdHJlYW0gPSByZXF1aXJlKCdzdHJlYW0nKTtcbnZhciB1dGlsID0gcmVxdWlyZSgndXRpbCcpO1xuXG52YXIgUmVzcG9uc2UgPSBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChyZXMpIHtcbiAgICB0aGlzLm9mZnNldCA9IDA7XG4gICAgdGhpcy5yZWFkYWJsZSA9IHRydWU7XG59O1xuXG51dGlsLmluaGVyaXRzKFJlc3BvbnNlLCBTdHJlYW0pO1xuXG52YXIgY2FwYWJsZSA9IHtcbiAgICBzdHJlYW1pbmcgOiB0cnVlLFxuICAgIHN0YXR1czIgOiB0cnVlXG59O1xuXG5mdW5jdGlvbiBwYXJzZUhlYWRlcnMgKHJlcykge1xuICAgIHZhciBsaW5lcyA9IHJlcy5nZXRBbGxSZXNwb25zZUhlYWRlcnMoKS5zcGxpdCgvXFxyP1xcbi8pO1xuICAgIHZhciBoZWFkZXJzID0ge307XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsaW5lcy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgbGluZSA9IGxpbmVzW2ldO1xuICAgICAgICBpZiAobGluZSA9PT0gJycpIGNvbnRpbnVlO1xuICAgICAgICBcbiAgICAgICAgdmFyIG0gPSBsaW5lLm1hdGNoKC9eKFteOl0rKTpcXHMqKC4qKS8pO1xuICAgICAgICBpZiAobSkge1xuICAgICAgICAgICAgdmFyIGtleSA9IG1bMV0udG9Mb3dlckNhc2UoKSwgdmFsdWUgPSBtWzJdO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICBpZiAoaGVhZGVyc1trZXldICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIGlmIChpc0FycmF5KGhlYWRlcnNba2V5XSkpIHtcbiAgICAgICAgICAgICAgICAgICAgaGVhZGVyc1trZXldLnB1c2godmFsdWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgaGVhZGVyc1trZXldID0gWyBoZWFkZXJzW2tleV0sIHZhbHVlIF07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgaGVhZGVyc1trZXldID0gdmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBoZWFkZXJzW2xpbmVdID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gaGVhZGVycztcbn1cblxuUmVzcG9uc2UucHJvdG90eXBlLmdldFJlc3BvbnNlID0gZnVuY3Rpb24gKHhocikge1xuICAgIHZhciByZXNwVHlwZSA9IFN0cmluZyh4aHIucmVzcG9uc2VUeXBlKS50b0xvd2VyQ2FzZSgpO1xuICAgIGlmIChyZXNwVHlwZSA9PT0gJ2Jsb2InKSByZXR1cm4geGhyLnJlc3BvbnNlQmxvYiB8fCB4aHIucmVzcG9uc2U7XG4gICAgaWYgKHJlc3BUeXBlID09PSAnYXJyYXlidWZmZXInKSByZXR1cm4geGhyLnJlc3BvbnNlO1xuICAgIHJldHVybiB4aHIucmVzcG9uc2VUZXh0O1xufVxuXG5SZXNwb25zZS5wcm90b3R5cGUuZ2V0SGVhZGVyID0gZnVuY3Rpb24gKGtleSkge1xuICAgIHJldHVybiB0aGlzLmhlYWRlcnNba2V5LnRvTG93ZXJDYXNlKCldO1xufTtcblxuUmVzcG9uc2UucHJvdG90eXBlLmhhbmRsZSA9IGZ1bmN0aW9uIChyZXMpIHtcbiAgICBpZiAocmVzLnJlYWR5U3RhdGUgPT09IDIgJiYgY2FwYWJsZS5zdGF0dXMyKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICB0aGlzLnN0YXR1c0NvZGUgPSByZXMuc3RhdHVzO1xuICAgICAgICAgICAgdGhpcy5oZWFkZXJzID0gcGFyc2VIZWFkZXJzKHJlcyk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgY2FwYWJsZS5zdGF0dXMyID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIGlmIChjYXBhYmxlLnN0YXR1czIpIHtcbiAgICAgICAgICAgIHRoaXMuZW1pdCgncmVhZHknKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIGlmIChjYXBhYmxlLnN0cmVhbWluZyAmJiByZXMucmVhZHlTdGF0ZSA9PT0gMykge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgaWYgKCF0aGlzLnN0YXR1c0NvZGUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnN0YXR1c0NvZGUgPSByZXMuc3RhdHVzO1xuICAgICAgICAgICAgICAgIHRoaXMuaGVhZGVycyA9IHBhcnNlSGVhZGVycyhyZXMpO1xuICAgICAgICAgICAgICAgIHRoaXMuZW1pdCgncmVhZHknKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyKSB7fVxuICAgICAgICBcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHRoaXMuX2VtaXREYXRhKHJlcyk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgY2FwYWJsZS5zdHJlYW1pbmcgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIGlmIChyZXMucmVhZHlTdGF0ZSA9PT0gNCkge1xuICAgICAgICBpZiAoIXRoaXMuc3RhdHVzQ29kZSkge1xuICAgICAgICAgICAgdGhpcy5zdGF0dXNDb2RlID0gcmVzLnN0YXR1cztcbiAgICAgICAgICAgIHRoaXMuZW1pdCgncmVhZHknKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9lbWl0RGF0YShyZXMpO1xuICAgICAgICBcbiAgICAgICAgaWYgKHJlcy5lcnJvcikge1xuICAgICAgICAgICAgdGhpcy5lbWl0KCdlcnJvcicsIHRoaXMuZ2V0UmVzcG9uc2UocmVzKSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB0aGlzLmVtaXQoJ2VuZCcpO1xuICAgICAgICBcbiAgICAgICAgdGhpcy5lbWl0KCdjbG9zZScpO1xuICAgIH1cbn07XG5cblJlc3BvbnNlLnByb3RvdHlwZS5fZW1pdERhdGEgPSBmdW5jdGlvbiAocmVzKSB7XG4gICAgdmFyIHJlc3BCb2R5ID0gdGhpcy5nZXRSZXNwb25zZShyZXMpO1xuICAgIGlmIChyZXNwQm9keS50b1N0cmluZygpLm1hdGNoKC9BcnJheUJ1ZmZlci8pKSB7XG4gICAgICAgIHRoaXMuZW1pdCgnZGF0YScsIG5ldyBVaW50OEFycmF5KHJlc3BCb2R5LCB0aGlzLm9mZnNldCkpO1xuICAgICAgICB0aGlzLm9mZnNldCA9IHJlc3BCb2R5LmJ5dGVMZW5ndGg7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKHJlc3BCb2R5Lmxlbmd0aCA+IHRoaXMub2Zmc2V0KSB7XG4gICAgICAgIHRoaXMuZW1pdCgnZGF0YScsIHJlc3BCb2R5LnNsaWNlKHRoaXMub2Zmc2V0KSk7XG4gICAgICAgIHRoaXMub2Zmc2V0ID0gcmVzcEJvZHkubGVuZ3RoO1xuICAgIH1cbn07XG5cbnZhciBpc0FycmF5ID0gQXJyYXkuaXNBcnJheSB8fCBmdW5jdGlvbiAoeHMpIHtcbiAgICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHhzKSA9PT0gJ1tvYmplY3QgQXJyYXldJztcbn07XG4iLCJ2YXIgaHR0cCA9IHJlcXVpcmUoJ2h0dHAnKTtcblxudmFyIGh0dHBzID0gbW9kdWxlLmV4cG9ydHM7XG5cbmZvciAodmFyIGtleSBpbiBodHRwKSB7XG4gICAgaWYgKGh0dHAuaGFzT3duUHJvcGVydHkoa2V5KSkgaHR0cHNba2V5XSA9IGh0dHBba2V5XTtcbn07XG5cbmh0dHBzLnJlcXVlc3QgPSBmdW5jdGlvbiAocGFyYW1zLCBjYikge1xuICAgIGlmICghcGFyYW1zKSBwYXJhbXMgPSB7fTtcbiAgICBwYXJhbXMuc2NoZW1lID0gJ2h0dHBzJztcbiAgICBwYXJhbXMucHJvdG9jb2wgPSAnaHR0cHM6JztcbiAgICByZXR1cm4gaHR0cC5yZXF1ZXN0LmNhbGwodGhpcywgcGFyYW1zLCBjYik7XG59XG4iLCJleHBvcnRzLnJlYWQgPSBmdW5jdGlvbiAoYnVmZmVyLCBvZmZzZXQsIGlzTEUsIG1MZW4sIG5CeXRlcykge1xuICB2YXIgZSwgbVxuICB2YXIgZUxlbiA9IG5CeXRlcyAqIDggLSBtTGVuIC0gMVxuICB2YXIgZU1heCA9ICgxIDw8IGVMZW4pIC0gMVxuICB2YXIgZUJpYXMgPSBlTWF4ID4+IDFcbiAgdmFyIG5CaXRzID0gLTdcbiAgdmFyIGkgPSBpc0xFID8gKG5CeXRlcyAtIDEpIDogMFxuICB2YXIgZCA9IGlzTEUgPyAtMSA6IDFcbiAgdmFyIHMgPSBidWZmZXJbb2Zmc2V0ICsgaV1cblxuICBpICs9IGRcblxuICBlID0gcyAmICgoMSA8PCAoLW5CaXRzKSkgLSAxKVxuICBzID4+PSAoLW5CaXRzKVxuICBuQml0cyArPSBlTGVuXG4gIGZvciAoOyBuQml0cyA+IDA7IGUgPSBlICogMjU2ICsgYnVmZmVyW29mZnNldCArIGldLCBpICs9IGQsIG5CaXRzIC09IDgpIHt9XG5cbiAgbSA9IGUgJiAoKDEgPDwgKC1uQml0cykpIC0gMSlcbiAgZSA+Pj0gKC1uQml0cylcbiAgbkJpdHMgKz0gbUxlblxuICBmb3IgKDsgbkJpdHMgPiAwOyBtID0gbSAqIDI1NiArIGJ1ZmZlcltvZmZzZXQgKyBpXSwgaSArPSBkLCBuQml0cyAtPSA4KSB7fVxuXG4gIGlmIChlID09PSAwKSB7XG4gICAgZSA9IDEgLSBlQmlhc1xuICB9IGVsc2UgaWYgKGUgPT09IGVNYXgpIHtcbiAgICByZXR1cm4gbSA/IE5hTiA6ICgocyA/IC0xIDogMSkgKiBJbmZpbml0eSlcbiAgfSBlbHNlIHtcbiAgICBtID0gbSArIE1hdGgucG93KDIsIG1MZW4pXG4gICAgZSA9IGUgLSBlQmlhc1xuICB9XG4gIHJldHVybiAocyA/IC0xIDogMSkgKiBtICogTWF0aC5wb3coMiwgZSAtIG1MZW4pXG59XG5cbmV4cG9ydHMud3JpdGUgPSBmdW5jdGlvbiAoYnVmZmVyLCB2YWx1ZSwgb2Zmc2V0LCBpc0xFLCBtTGVuLCBuQnl0ZXMpIHtcbiAgdmFyIGUsIG0sIGNcbiAgdmFyIGVMZW4gPSBuQnl0ZXMgKiA4IC0gbUxlbiAtIDFcbiAgdmFyIGVNYXggPSAoMSA8PCBlTGVuKSAtIDFcbiAgdmFyIGVCaWFzID0gZU1heCA+PiAxXG4gIHZhciBydCA9IChtTGVuID09PSAyMyA/IE1hdGgucG93KDIsIC0yNCkgLSBNYXRoLnBvdygyLCAtNzcpIDogMClcbiAgdmFyIGkgPSBpc0xFID8gMCA6IChuQnl0ZXMgLSAxKVxuICB2YXIgZCA9IGlzTEUgPyAxIDogLTFcbiAgdmFyIHMgPSB2YWx1ZSA8IDAgfHwgKHZhbHVlID09PSAwICYmIDEgLyB2YWx1ZSA8IDApID8gMSA6IDBcblxuICB2YWx1ZSA9IE1hdGguYWJzKHZhbHVlKVxuXG4gIGlmIChpc05hTih2YWx1ZSkgfHwgdmFsdWUgPT09IEluZmluaXR5KSB7XG4gICAgbSA9IGlzTmFOKHZhbHVlKSA/IDEgOiAwXG4gICAgZSA9IGVNYXhcbiAgfSBlbHNlIHtcbiAgICBlID0gTWF0aC5mbG9vcihNYXRoLmxvZyh2YWx1ZSkgLyBNYXRoLkxOMilcbiAgICBpZiAodmFsdWUgKiAoYyA9IE1hdGgucG93KDIsIC1lKSkgPCAxKSB7XG4gICAgICBlLS1cbiAgICAgIGMgKj0gMlxuICAgIH1cbiAgICBpZiAoZSArIGVCaWFzID49IDEpIHtcbiAgICAgIHZhbHVlICs9IHJ0IC8gY1xuICAgIH0gZWxzZSB7XG4gICAgICB2YWx1ZSArPSBydCAqIE1hdGgucG93KDIsIDEgLSBlQmlhcylcbiAgICB9XG4gICAgaWYgKHZhbHVlICogYyA+PSAyKSB7XG4gICAgICBlKytcbiAgICAgIGMgLz0gMlxuICAgIH1cblxuICAgIGlmIChlICsgZUJpYXMgPj0gZU1heCkge1xuICAgICAgbSA9IDBcbiAgICAgIGUgPSBlTWF4XG4gICAgfSBlbHNlIGlmIChlICsgZUJpYXMgPj0gMSkge1xuICAgICAgbSA9ICh2YWx1ZSAqIGMgLSAxKSAqIE1hdGgucG93KDIsIG1MZW4pXG4gICAgICBlID0gZSArIGVCaWFzXG4gICAgfSBlbHNlIHtcbiAgICAgIG0gPSB2YWx1ZSAqIE1hdGgucG93KDIsIGVCaWFzIC0gMSkgKiBNYXRoLnBvdygyLCBtTGVuKVxuICAgICAgZSA9IDBcbiAgICB9XG4gIH1cblxuICBmb3IgKDsgbUxlbiA+PSA4OyBidWZmZXJbb2Zmc2V0ICsgaV0gPSBtICYgMHhmZiwgaSArPSBkLCBtIC89IDI1NiwgbUxlbiAtPSA4KSB7fVxuXG4gIGUgPSAoZSA8PCBtTGVuKSB8IG1cbiAgZUxlbiArPSBtTGVuXG4gIGZvciAoOyBlTGVuID4gMDsgYnVmZmVyW29mZnNldCArIGldID0gZSAmIDB4ZmYsIGkgKz0gZCwgZSAvPSAyNTYsIGVMZW4gLT0gOCkge31cblxuICBidWZmZXJbb2Zmc2V0ICsgaSAtIGRdIHw9IHMgKiAxMjhcbn1cbiIsImlmICh0eXBlb2YgT2JqZWN0LmNyZWF0ZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAvLyBpbXBsZW1lbnRhdGlvbiBmcm9tIHN0YW5kYXJkIG5vZGUuanMgJ3V0aWwnIG1vZHVsZVxuICBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGluaGVyaXRzKGN0b3IsIHN1cGVyQ3Rvcikge1xuICAgIGN0b3Iuc3VwZXJfID0gc3VwZXJDdG9yXG4gICAgY3Rvci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ3Rvci5wcm90b3R5cGUsIHtcbiAgICAgIGNvbnN0cnVjdG9yOiB7XG4gICAgICAgIHZhbHVlOiBjdG9yLFxuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgfVxuICAgIH0pO1xuICB9O1xufSBlbHNlIHtcbiAgLy8gb2xkIHNjaG9vbCBzaGltIGZvciBvbGQgYnJvd3NlcnNcbiAgbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBpbmhlcml0cyhjdG9yLCBzdXBlckN0b3IpIHtcbiAgICBjdG9yLnN1cGVyXyA9IHN1cGVyQ3RvclxuICAgIHZhciBUZW1wQ3RvciA9IGZ1bmN0aW9uICgpIHt9XG4gICAgVGVtcEN0b3IucHJvdG90eXBlID0gc3VwZXJDdG9yLnByb3RvdHlwZVxuICAgIGN0b3IucHJvdG90eXBlID0gbmV3IFRlbXBDdG9yKClcbiAgICBjdG9yLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IGN0b3JcbiAgfVxufVxuIiwiKGZ1bmN0aW9uIChCdWZmZXIpe1xuJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIE1pbmltYWwgSFRUUC9TIHByb3h5IGNsaWVudFxuICovXG5cbnZhciBuZXQgPSByZXF1aXJlKCduZXQnKTtcbnZhciB0bHMgPSByZXF1aXJlKCd0bHMnKTtcbnZhciB1cmxsaWIgPSByZXF1aXJlKCd1cmwnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBwcm94eUNvbm5lY3Q7XG5cbi8qKlxuICogRXN0YWJsaXNoZXMgcHJveGllZCBjb25uZWN0aW9uIHRvIGRlc3RpbmF0aW9uUG9ydFxuICpcbiAqIHByb3h5Q29ubmVjdChcImh0dHA6Ly9sb2NhbGhvc3Q6MzEyOC9cIiwgODAsIFwiZ29vZ2xlLmNvbVwiLCBmdW5jdGlvbihlcnIsIHNvY2tldCl7XG4gKiAgICAgc29ja2V0LndyaXRlKFwiR0VUIC8gSFRUUC8xLjBcXHJcXG5cXHJcXG5cIik7XG4gKiB9KTtcbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gcHJveHlVcmwgcHJveHkgY29uZmlndXJhdGlvbiwgZXRnIFwiaHR0cDovL3Byb3h5Lmhvc3Q6MzEyOC9cIlxuICogQHBhcmFtIHtOdW1iZXJ9IGRlc3RpbmF0aW9uUG9ydCBQb3J0IHRvIG9wZW4gaW4gZGVzdGluYXRpb24gaG9zdFxuICogQHBhcmFtIHtTdHJpbmd9IGRlc3RpbmF0aW9uSG9zdCBEZXN0aW5hdGlvbiBob3N0bmFtZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgQ2FsbGJhY2sgdG8gcnVuIHdpdGggdGhlIHJvY2tldCBvYmplY3Qgb25jZSBjb25uZWN0aW9uIGlzIGVzdGFibGlzaGVkXG4gKi9cbmZ1bmN0aW9uIHByb3h5Q29ubmVjdChwcm94eVVybCwgZGVzdGluYXRpb25Qb3J0LCBkZXN0aW5hdGlvbkhvc3QsIGNhbGxiYWNrKSB7XG4gICAgdmFyIHByb3h5ID0gdXJsbGliLnBhcnNlKHByb3h5VXJsKTtcblxuICAgIC8vIGNyZWF0ZSBhIHNvY2tldCBjb25uZWN0aW9uIHRvIHRoZSBwcm94eSBzZXJ2ZXJcbiAgICB2YXIgb3B0aW9ucztcbiAgICB2YXIgY29ubmVjdDtcbiAgICB2YXIgc29ja2V0O1xuXG4gICAgb3B0aW9ucyA9IHtcbiAgICAgICAgaG9zdDogcHJveHkuaG9zdG5hbWUsXG4gICAgICAgIHBvcnQ6IE51bWJlcihwcm94eS5wb3J0KSA/IE51bWJlcihwcm94eS5wb3J0KSA6IChwcm94eS5wcm90b2NvbCA9PT0gJ2h0dHBzOicgPyA0NDMgOiA4MClcbiAgICB9O1xuXG4gICAgaWYgKHByb3h5LnByb3RvY29sID09PSAnaHR0cHM6Jykge1xuICAgICAgICAvLyB3ZSBjYW4gdXNlIHVudHJ1c3RlZCBwcm94aWVzIGFzIGxvbmcgYXMgd2UgdmVyaWZ5IGFjdHVhbCBTTVRQIGNlcnRpZmljYXRlc1xuICAgICAgICBvcHRpb25zLnJlamVjdFVuYXV0aG9yaXplZCA9IGZhbHNlO1xuICAgICAgICBjb25uZWN0ID0gdGxzLmNvbm5lY3QuYmluZCh0bHMpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbm5lY3QgPSBuZXQuY29ubmVjdC5iaW5kKG5ldCk7XG4gICAgfVxuXG4gICAgLy8gRXJyb3IgaGFybmVzcyBmb3IgaW5pdGlhbCBjb25uZWN0aW9uLiBPbmNlIGNvbm5lY3Rpb24gaXMgZXN0YWJsaXNoZWQsIHRoZSByZXNwb25zaWJpbGl0eVxuICAgIC8vIHRvIGhhbmRsZSBlcnJvcnMgaXMgcGFzc2VkIHRvIHdob2V2ZXIgdXNlcyB0aGlzIHNvY2tldFxuICAgIHZhciBmaW5pc2hlZCA9IGZhbHNlO1xuICAgIHZhciB0ZW1wU29ja2V0RXJyID0gZnVuY3Rpb24gKGVycikge1xuICAgICAgICBpZiAoZmluaXNoZWQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBmaW5pc2hlZCA9IHRydWU7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBzb2NrZXQuZGVzdHJveSgpO1xuICAgICAgICB9IGNhdGNoIChFKSB7XG4gICAgICAgICAgICAvLyBpZ25vcmVcbiAgICAgICAgfVxuICAgICAgICBjYWxsYmFjayhlcnIpO1xuICAgIH07XG5cbiAgICBzb2NrZXQgPSBjb25uZWN0KG9wdGlvbnMsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKGZpbmlzaGVkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgcmVxSGVhZGVycyA9IHtcbiAgICAgICAgICAgIEhvc3Q6IGRlc3RpbmF0aW9uSG9zdCArICc6JyArIGRlc3RpbmF0aW9uUG9ydCxcbiAgICAgICAgICAgIENvbm5lY3Rpb246ICdjbG9zZSdcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKHByb3h5LmF1dGgpIHtcbiAgICAgICAgICAgIHJlcUhlYWRlcnNbJ1Byb3h5LUF1dGhvcml6YXRpb24nXSA9ICdCYXNpYyAnICsgbmV3IEJ1ZmZlcihwcm94eS5hdXRoKS50b1N0cmluZygnYmFzZTY0Jyk7XG4gICAgICAgIH1cblxuICAgICAgICBzb2NrZXQud3JpdGUoXG4gICAgICAgICAgICAvLyBIVFRQIG1ldGhvZFxuICAgICAgICAgICAgJ0NPTk5FQ1QgJyArIGRlc3RpbmF0aW9uSG9zdCArICc6JyArIGRlc3RpbmF0aW9uUG9ydCArICcgSFRUUC8xLjFcXHJcXG4nICtcblxuICAgICAgICAgICAgLy8gSFRUUCByZXF1ZXN0IGhlYWRlcnNcbiAgICAgICAgICAgIE9iamVjdC5rZXlzKHJlcUhlYWRlcnMpLm1hcChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGtleSArICc6ICcgKyByZXFIZWFkZXJzW2tleV07XG4gICAgICAgICAgICB9KS5qb2luKCdcXHJcXG4nKSArXG5cbiAgICAgICAgICAgIC8vIEVuZCByZXF1ZXN0XG4gICAgICAgICAgICAnXFxyXFxuXFxyXFxuJyk7XG5cblxuICAgICAgICB2YXIgaGVhZGVycyA9ICcnO1xuICAgICAgICB2YXIgb25Tb2NrZXREYXRhID0gZnVuY3Rpb24gKGNodW5rKSB7XG4gICAgICAgICAgICB2YXIgbWF0Y2g7XG4gICAgICAgICAgICB2YXIgcmVtYWluZGVyO1xuXG4gICAgICAgICAgICBpZiAoZmluaXNoZWQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGhlYWRlcnMgKz0gY2h1bmsudG9TdHJpbmcoJ2JpbmFyeScpO1xuICAgICAgICAgICAgaWYgKChtYXRjaCA9IGhlYWRlcnMubWF0Y2goL1xcclxcblxcclxcbi8pKSkge1xuICAgICAgICAgICAgICAgIHNvY2tldC5yZW1vdmVMaXN0ZW5lcignZGF0YScsIG9uU29ja2V0RGF0YSk7XG4gICAgICAgICAgICAgICAgcmVtYWluZGVyID0gaGVhZGVycy5zdWJzdHIobWF0Y2guaW5kZXggKyBtYXRjaFswXS5sZW5ndGgpO1xuICAgICAgICAgICAgICAgIGhlYWRlcnMgPSBoZWFkZXJzLnN1YnN0cigwLCBtYXRjaC5pbmRleCk7XG4gICAgICAgICAgICAgICAgaWYgKHJlbWFpbmRlcikge1xuICAgICAgICAgICAgICAgICAgICBzb2NrZXQudW5zaGlmdChuZXcgQnVmZmVyKHJlbWFpbmRlciwgJ2JpbmFyeScpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gcHJveHkgY29ubmVjdGlvbiBpcyBub3cgZXN0YWJsaXNoZWRcbiAgICAgICAgICAgICAgICBmaW5pc2hlZCA9IHRydWU7XG5cbiAgICAgICAgICAgICAgICBzb2NrZXQucmVtb3ZlTGlzdGVuZXIoJ2Vycm9yJywgdGVtcFNvY2tldEVycik7XG5cbiAgICAgICAgICAgICAgICAvLyBjaGVjayByZXNwb25zZSBjb2RlXG4gICAgICAgICAgICAgICAgbWF0Y2ggPSBoZWFkZXJzLm1hdGNoKC9eSFRUUFxcL1xcZCtcXC5cXGQrIChcXGQrKS9pKTtcbiAgICAgICAgICAgICAgICBpZiAoIW1hdGNoIHx8IChtYXRjaFsxXSB8fCAnJykuY2hhckF0KDApICE9PSAnMicpIHtcbiAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNvY2tldC5kZXN0cm95KCk7XG4gICAgICAgICAgICAgICAgICAgIH0gY2F0Y2ggKEUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGlnbm9yZVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjYWxsYmFjayhuZXcgRXJyb3IoJ0ludmFsaWQgcmVzcG9uc2UgZnJvbSBwcm94eScgKyAobWF0Y2ggJiYgJzogJyArIG1hdGNoWzFdIHx8ICcnKSkpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHJldHVybiBjYWxsYmFjayhudWxsLCBzb2NrZXQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBzb2NrZXQub24oJ2RhdGEnLCBvblNvY2tldERhdGEpO1xuICAgIH0pO1xuXG4gICAgc29ja2V0Lm9uY2UoJ2Vycm9yJywgdGVtcFNvY2tldEVycik7XG59XG5cbn0pLmNhbGwodGhpcyxyZXF1aXJlKFwiYnVmZmVyXCIpLkJ1ZmZlcikiLCIndXNlIHN0cmljdCc7XG5cbnZhciBtYWlsY29tcG9zZXIgPSByZXF1aXJlKCdtYWlsY29tcG9zZXInKTtcbnZhciBFdmVudEVtaXR0ZXIgPSByZXF1aXJlKCdldmVudHMnKS5FdmVudEVtaXR0ZXI7XG52YXIgdXRpbCA9IHJlcXVpcmUoJ3V0aWwnKTtcbnZhciBzaGFyZWQgPSByZXF1aXJlKCdub2RlbWFpbGVyLXNoYXJlZCcpO1xudmFyIGRpcmVjdFRyYW5zcG9ydCA9IHJlcXVpcmUoJ25vZGVtYWlsZXItZGlyZWN0LXRyYW5zcG9ydCcpO1xudmFyIHNtdHBUcmFuc3BvcnQgPSByZXF1aXJlKCdub2RlbWFpbGVyLXNtdHAtdHJhbnNwb3J0Jyk7XG52YXIgc210cFBvb2xUcmFuc3BvcnQgPSByZXF1aXJlKCdub2RlbWFpbGVyLXNtdHAtcG9vbCcpO1xudmFyIHRlbXBsYXRlU2VuZGVyID0gcmVxdWlyZSgnLi90ZW1wbGF0ZS1zZW5kZXInKTtcbnZhciBwYWNrYWdlRGF0YSA9IHJlcXVpcmUoJy4uL3BhY2thZ2UuanNvbicpO1xudmFyIGh0dHBQcm94eSA9IHJlcXVpcmUoJy4vaHR0cC1wcm94eScpO1xudmFyIFNvY2tzID0gcmVxdWlyZSgnc29ja3MnKTtcbnZhciB1cmxsaWIgPSByZXF1aXJlKCd1cmwnKTtcblxuLy8gRXhwb3J0IGNyZWF0ZVRyYW5zcG9ydCBtZXRob2Rcbm1vZHVsZS5leHBvcnRzLmNyZWF0ZVRyYW5zcG9ydCA9IGZ1bmN0aW9uICh0cmFuc3BvcnRlciwgZGVmYXVsdHMpIHtcbiAgICB2YXIgdXJsQ29uZmlnO1xuICAgIHZhciBvcHRpb25zO1xuICAgIHZhciBtYWlsZXI7XG4gICAgdmFyIHByb3h5VXJsO1xuXG4gICAgLy8gaWYgbm8gdHJhbnNwb3J0ZXIgY29uZmlndXJhdGlvbiBpcyBwcm92aWRlZCB1c2UgZGlyZWN0IGFzIGRlZmF1bHRcbiAgICB0cmFuc3BvcnRlciA9IHRyYW5zcG9ydGVyIHx8IGRpcmVjdFRyYW5zcG9ydCh7XG4gICAgICAgIGRlYnVnOiB0cnVlXG4gICAgfSk7XG5cbiAgICBpZiAoXG4gICAgICAgIC8vIHByb3ZpZGVkIHRyYW5zcG9ydGVyIGlzIGEgY29uZmlndXJhdGlvbiBvYmplY3QsIG5vdCB0cmFuc3BvcnRlciBwbHVnaW5cbiAgICAgICAgKHR5cGVvZiB0cmFuc3BvcnRlciA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIHRyYW5zcG9ydGVyLnNlbmQgIT09ICdmdW5jdGlvbicpIHx8XG4gICAgICAgIC8vIHByb3ZpZGVkIHRyYW5zcG9ydGVyIGxvb2tzIGxpa2UgYSBjb25uZWN0aW9uIHVybFxuICAgICAgICAodHlwZW9mIHRyYW5zcG9ydGVyID09PSAnc3RyaW5nJyAmJiAvXihzbXRwcz98ZGlyZWN0KTovaS50ZXN0KHRyYW5zcG9ydGVyKSlcbiAgICApIHtcblxuICAgICAgICBpZiAoKHVybENvbmZpZyA9IHR5cGVvZiB0cmFuc3BvcnRlciA9PT0gJ3N0cmluZycgPyB0cmFuc3BvcnRlciA6IHRyYW5zcG9ydGVyLnVybCkpIHtcbiAgICAgICAgICAgIC8vIHBhcnNlIGEgY29uZmlndXJhdGlvbiBVUkwgaW50byBjb25maWd1cmF0aW9uIG9wdGlvbnNcbiAgICAgICAgICAgIG9wdGlvbnMgPSBzaGFyZWQucGFyc2VDb25uZWN0aW9uVXJsKHVybENvbmZpZyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBvcHRpb25zID0gdHJhbnNwb3J0ZXI7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAob3B0aW9ucy5wcm94eSAmJiB0eXBlb2Ygb3B0aW9ucy5wcm94eSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIHByb3h5VXJsID0gb3B0aW9ucy5wcm94eTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChvcHRpb25zLnRyYW5zcG9ydCAmJiB0eXBlb2Ygb3B0aW9ucy50cmFuc3BvcnQgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHRyYW5zcG9ydGVyID0gcmVxdWlyZSgnbm9kZW1haWxlci0nICsgKG9wdGlvbnMudHJhbnNwb3J0KS50b0xvd2VyQ2FzZSgpICsgJy10cmFuc3BvcnQnKShvcHRpb25zKTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKEUpIHtcbiAgICAgICAgICAgICAgICAvLyBpZiB0cmFuc3BvcnRlciBsb2FkZXIgZmFpbHMsIHJldHVybiBhbiBlcnJvciB3aGVuIHNlbmRpbmcgbWFpbFxuICAgICAgICAgICAgICAgIHRyYW5zcG9ydGVyID0ge1xuICAgICAgICAgICAgICAgICAgICBzZW5kOiBmdW5jdGlvbiAobWFpbCwgY2FsbGJhY2spIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBlcnJtc2cgPSAnUmVxdWVzdGVkIHRyYW5zcG9ydCBwbHVnaW4gIFwibm9kZW1haWxlci0nICsgKG9wdGlvbnMudHJhbnNwb3J0KS50b0xvd2VyQ2FzZSgpICsgJy10cmFuc3BvcnRcIiBjb3VsZCBub3QgYmUgaW5pdGlhdGVkJztcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBlcnIgPSBuZXcgRXJyb3IoZXJybXNnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVyci5jb2RlID0gJ0VJTklUJztcbiAgICAgICAgICAgICAgICAgICAgICAgIHNldEltbWVkaWF0ZShmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKGVycik7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAob3B0aW9ucy5kaXJlY3QpIHtcbiAgICAgICAgICAgIHRyYW5zcG9ydGVyID0gZGlyZWN0VHJhbnNwb3J0KG9wdGlvbnMpO1xuICAgICAgICB9IGVsc2UgaWYgKG9wdGlvbnMucG9vbCkge1xuICAgICAgICAgICAgdHJhbnNwb3J0ZXIgPSBzbXRwUG9vbFRyYW5zcG9ydChvcHRpb25zKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRyYW5zcG9ydGVyID0gc210cFRyYW5zcG9ydChvcHRpb25zKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIG1haWxlciA9IG5ldyBOb2RlbWFpbGVyKHRyYW5zcG9ydGVyLCBkZWZhdWx0cyk7XG5cbiAgICBpZiAocHJveHlVcmwpIHtcbiAgICAgICAgc2V0dXBQcm94eShtYWlsZXIsIHByb3h5VXJsKTtcbiAgICB9XG5cbiAgICByZXR1cm4gbWFpbGVyO1xufTtcblxuLyoqXG4gKiBTZXRzIHVwIHByb3h5IGhhbmRsZXIgZm9yIGEgTm9kZW1haWxlciBvYmplY3RcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gbWFpbGVyIE5vZGVtYWlsZXIgaW5zdGFuY2UgdG8gbW9kaWZ5XG4gKiBAcGFyYW0ge1N0cmluZ30gcHJveHlVcmwgUHJveHkgY29uZmlndXJhdGlvbiB1cmxcbiAqL1xuZnVuY3Rpb24gc2V0dXBQcm94eShtYWlsZXIsIHByb3h5VXJsKSB7XG4gICAgdmFyIHByb3h5ID0gdXJsbGliLnBhcnNlKHByb3h5VXJsKTtcblxuICAgIC8vIHNldHVwIHNvY2tldCBoYW5kbGVyIGZvciB0aGUgbWFpbGVyIG9iamVjdFxuICAgIG1haWxlci5nZXRTb2NrZXQgPSBmdW5jdGlvbiAob3B0aW9ucywgY2FsbGJhY2spIHtcbiAgICAgICAgc3dpdGNoIChwcm94eS5wcm90b2NvbCkge1xuXG4gICAgICAgICAgICAvLyBDb25uZWN0IHVzaW5nIGEgSFRUUCBDT05ORUNUIG1ldGhvZFxuICAgICAgICAgICAgY2FzZSAnaHR0cDonOlxuICAgICAgICAgICAgY2FzZSAnaHR0cHM6JzpcbiAgICAgICAgICAgICAgICBodHRwUHJveHkocHJveHkuaHJlZiwgb3B0aW9ucy5wb3J0LCBvcHRpb25zLmhvc3QsIGZ1bmN0aW9uIChlcnIsIHNvY2tldCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gY2FsbGJhY2soZXJyKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gY2FsbGJhY2sobnVsbCwge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29ubmVjdGlvbjogc29ja2V0XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHJldHVybjtcblxuICAgICAgICAgICAgICAgIC8vIENvbm5lY3QgdXNpbmcgYSBTT0NLUzQvNSBwcm94eVxuICAgICAgICAgICAgY2FzZSAnc29ja3M6JzpcbiAgICAgICAgICAgIGNhc2UgJ3NvY2tzNTonOlxuICAgICAgICAgICAgY2FzZSAnc29ja3M0Oic6XG4gICAgICAgICAgICBjYXNlICdzb2NrczRhOic6XG4gICAgICAgICAgICAgICAgU29ja3MuY3JlYXRlQ29ubmVjdGlvbih7XG4gICAgICAgICAgICAgICAgICAgIHByb3h5OiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpcGFkZHJlc3M6IHByb3h5Lmhvc3RuYW1lLFxuICAgICAgICAgICAgICAgICAgICAgICAgcG9ydDogcHJveHkucG9ydCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IE51bWJlcihwcm94eS5wcm90b2NvbC5yZXBsYWNlKC9cXEQvZywgJycpKSB8fCA1XG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIHRhcmdldDoge1xuICAgICAgICAgICAgICAgICAgICAgICAgaG9zdDogb3B0aW9ucy5ob3N0LFxuICAgICAgICAgICAgICAgICAgICAgICAgcG9ydDogb3B0aW9ucy5wb3J0XG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIGNvbW1hbmQ6ICdjb25uZWN0JyxcbiAgICAgICAgICAgICAgICAgICAgYXV0aGVudGljYXRpb246ICFwcm94eS5hdXRoID8gZmFsc2UgOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICB1c2VybmFtZTogZGVjb2RlVVJJQ29tcG9uZW50KHByb3h5LmF1dGguc3BsaXQoJzonKS5zaGlmdCgpKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhc3N3b3JkOiBkZWNvZGVVUklDb21wb25lbnQocHJveHkuYXV0aC5zcGxpdCgnOicpLnBvcCgpKVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSwgZnVuY3Rpb24gKGVyciwgc29ja2V0KSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBjYWxsYmFjayhlcnIpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjYWxsYmFjayhudWxsLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25uZWN0aW9uOiBzb2NrZXRcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgY2FsbGJhY2sobmV3IEVycm9yKCdVbmtub3duIHByb3h5IGNvbmZpZ3VyYXRpb24nKSk7XG4gICAgfTtcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGFuIG9iamVjdCBmb3IgZXhwb3NpbmcgdGhlIE5vZGVtYWlsZXIgQVBJXG4gKlxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge09iamVjdH0gdHJhbnNwb3J0ZXIgVHJhbnNwb3J0IG9iamVjdCBpbnN0YW5jZSB0byBwYXNzIHRoZSBtYWlscyB0b1xuICovXG5mdW5jdGlvbiBOb2RlbWFpbGVyKHRyYW5zcG9ydGVyLCBkZWZhdWx0cykge1xuICAgIEV2ZW50RW1pdHRlci5jYWxsKHRoaXMpO1xuXG4gICAgdGhpcy5fZGVmYXVsdHMgPSBkZWZhdWx0cyB8fCB7fTtcblxuICAgIHRoaXMuX3BsdWdpbnMgPSB7XG4gICAgICAgIGNvbXBpbGU6IFtdLFxuICAgICAgICBzdHJlYW06IFtdXG4gICAgfTtcblxuICAgIHRoaXMudHJhbnNwb3J0ZXIgPSB0cmFuc3BvcnRlcjtcbiAgICB0aGlzLmxvZ2dlciA9IHRoaXMudHJhbnNwb3J0ZXIubG9nZ2VyIHx8IHNoYXJlZC5nZXRMb2dnZXIoe1xuICAgICAgICBsb2dnZXI6IGZhbHNlXG4gICAgfSk7XG5cbiAgICAvLyBzZXR1cCBlbWl0IGhhbmRsZXJzIGZvciB0aGUgdHJhbnNwb3J0ZXJcbiAgICBpZiAodHlwZW9mIHRyYW5zcG9ydGVyLm9uID09PSAnZnVuY3Rpb24nKSB7XG5cbiAgICAgICAgLy8gZGVwcmVjYXRlZCBsb2cgaW50ZXJmYWNlXG4gICAgICAgIHRoaXMudHJhbnNwb3J0ZXIub24oJ2xvZycsIGZ1bmN0aW9uIChsb2cpIHtcbiAgICAgICAgICAgIHRoaXMubG9nZ2VyLmRlYnVnKCclczogJXMnLCBsb2cudHlwZSwgbG9nLm1lc3NhZ2UpO1xuICAgICAgICB9LmJpbmQodGhpcykpO1xuXG4gICAgICAgIC8vIHRyYW5zcG9ydGVyIGVycm9yc1xuICAgICAgICB0aGlzLnRyYW5zcG9ydGVyLm9uKCdlcnJvcicsIGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgICAgIHRoaXMubG9nZ2VyLmVycm9yKCdUcmFuc3BvcnQgRXJyb3I6ICVzJywgZXJyLm1lc3NhZ2UpO1xuICAgICAgICAgICAgdGhpcy5lbWl0KCdlcnJvcicsIGVycik7XG4gICAgICAgIH0uYmluZCh0aGlzKSk7XG5cbiAgICAgICAgLy8gaW5kaWNhdGVzIGlmIHRoZSBzZW5kZXIgaGFzIGJlY2FtZSBpZGxlXG4gICAgICAgIHRoaXMudHJhbnNwb3J0ZXIub24oJ2lkbGUnLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgYXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cyk7XG4gICAgICAgICAgICBhcmdzLnVuc2hpZnQoJ2lkbGUnKTtcbiAgICAgICAgICAgIHRoaXMuZW1pdC5hcHBseSh0aGlzLCBhcmdzKTtcbiAgICAgICAgfS5iaW5kKHRoaXMpKTtcbiAgICB9XG59XG51dGlsLmluaGVyaXRzKE5vZGVtYWlsZXIsIEV2ZW50RW1pdHRlcik7XG5cbi8qKlxuICogQ3JlYXRlcyBhIHRlbXBsYXRlIGJhc2VkIHNlbmRlciBmdW5jdGlvblxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSB0ZW1wbGF0ZXMgT2JqZWN0IHdpdGggc3RyaW5nIHZhbHVlcyB3aGVyZSBrZXkgaXMgYSBtZXNzYWdlIGZpZWxkIGFuZCB2YWx1ZSBpcyBhIHRlbXBsYXRlXG4gKiBAcGFyYW0ge09iamVjdH0gZGVmYXVsdHMgT3B0aW9uYWwgZGVmYXVsdCBtZXNzYWdlIGZpZWxkc1xuICogQHJldHVybiB7RnVuY3Rpb259IEUtbWFpbCBzZW5kZXJcbiAqL1xuTm9kZW1haWxlci5wcm90b3R5cGUudGVtcGxhdGVTZW5kZXIgPSBmdW5jdGlvbiAodGVtcGxhdGVzLCBkZWZhdWx0cykge1xuICAgIHJldHVybiB0ZW1wbGF0ZVNlbmRlcih0aGlzLCB0ZW1wbGF0ZXMsIGRlZmF1bHRzKTtcbn07XG5cbk5vZGVtYWlsZXIucHJvdG90eXBlLnVzZSA9IGZ1bmN0aW9uIChzdGVwLCBwbHVnaW4pIHtcbiAgICBzdGVwID0gKHN0ZXAgfHwgJycpLnRvU3RyaW5nKCk7XG4gICAgaWYgKCF0aGlzLl9wbHVnaW5zLmhhc093blByb3BlcnR5KHN0ZXApKSB7XG4gICAgICAgIHRoaXMuX3BsdWdpbnNbc3RlcF0gPSBbcGx1Z2luXTtcbiAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLl9wbHVnaW5zW3N0ZXBdLnB1c2gocGx1Z2luKTtcbiAgICB9XG59O1xuXG4vKipcbiAqIE9wdGlvbmFsIG1ldGhvZHMgcGFzc2VkIHRvIHRoZSB1bmRlcmx5aW5nIHRyYW5zcG9ydCBvYmplY3RcbiAqL1xuWydjbG9zZScsICdpc0lkbGUnLCAndmVyaWZ5J10uZm9yRWFjaChmdW5jdGlvbiAobWV0aG9kKSB7XG4gICAgTm9kZW1haWxlci5wcm90b3R5cGVbbWV0aG9kXSA9IGZ1bmN0aW9uICggLyogcG9zc2libGUgYXJndW1lbnRzICovICkge1xuICAgICAgICB2YXIgYXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cyk7XG4gICAgICAgIGlmICh0eXBlb2YgdGhpcy50cmFuc3BvcnRlclttZXRob2RdID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy50cmFuc3BvcnRlclttZXRob2RdLmFwcGx5KHRoaXMudHJhbnNwb3J0ZXIsIGFyZ3MpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfTtcbn0pO1xuXG4vKipcbiAqIFNlbmRzIGFuIGVtYWlsIHVzaW5nIHRoZSBwcmVzZWxlY3RlZCB0cmFuc3BvcnQgb2JqZWN0XG4gKlxuICogQHBhcmFtIHtPYmplY3R9IGRhdGEgRS1kYXRhIGRlc2NyaXB0aW9uXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayBDYWxsYmFjayB0byBydW4gb25jZSB0aGUgc2VuZGluZyBzdWNjZWVkZWQgb3IgZmFpbGVkXG4gKi9cbk5vZGVtYWlsZXIucHJvdG90eXBlLnNlbmRNYWlsID0gZnVuY3Rpb24gKGRhdGEsIGNhbGxiYWNrKSB7XG4gICAgdmFyIHByb21pc2U7XG5cbiAgICBpZiAoIWNhbGxiYWNrICYmIHR5cGVvZiBQcm9taXNlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHByb21pc2UgPSBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgICAgICBjYWxsYmFjayA9IHNoYXJlZC5jYWxsYmFja1Byb21pc2UocmVzb2x2ZSwgcmVqZWN0KTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiB0aGlzLmdldFNvY2tldCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICB0aGlzLnRyYW5zcG9ydGVyLmdldFNvY2tldCA9IHRoaXMuZ2V0U29ja2V0LmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMuZ2V0U29ja2V0ID0gZmFsc2U7XG4gICAgfVxuXG4gICAgZGF0YSA9IGRhdGEgfHwge307XG4gICAgZGF0YS5oZWFkZXJzID0gZGF0YS5oZWFkZXJzIHx8IHt9O1xuICAgIGNhbGxiYWNrID0gY2FsbGJhY2sgfHwgZnVuY3Rpb24gKCkge307XG5cbiAgICAvLyBhcHBseSBkZWZhdWx0c1xuICAgIE9iamVjdC5rZXlzKHRoaXMuX2RlZmF1bHRzKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgaWYgKCEoa2V5IGluIGRhdGEpKSB7XG4gICAgICAgICAgICBkYXRhW2tleV0gPSB0aGlzLl9kZWZhdWx0c1trZXldO1xuICAgICAgICB9IGVsc2UgaWYgKGtleSA9PT0gJ2hlYWRlcnMnKSB7XG4gICAgICAgICAgICAvLyBoZWFkZXJzIGlzIGEgc3BlY2lhbCBjYXNlLiBBbGxvdyBzZXR0aW5nIGluZGl2aWR1YWwgZGVmYXVsdCBoZWFkZXJzXG4gICAgICAgICAgICBPYmplY3Qua2V5cyh0aGlzLl9kZWZhdWx0cy5oZWFkZXJzIHx8IHt9KS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgICAgICAgICBpZiAoIShrZXkgaW4gZGF0YS5oZWFkZXJzKSkge1xuICAgICAgICAgICAgICAgICAgICBkYXRhLmhlYWRlcnNba2V5XSA9IHRoaXMuX2RlZmF1bHRzLmhlYWRlcnNba2V5XTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LmJpbmQodGhpcykpO1xuICAgICAgICB9XG4gICAgfS5iaW5kKHRoaXMpKTtcblxuICAgIHZhciBtYWlsID0ge1xuICAgICAgICBkYXRhOiBkYXRhLFxuICAgICAgICBtZXNzYWdlOiBudWxsLFxuICAgICAgICByZXNvbHZlQ29udGVudDogc2hhcmVkLnJlc29sdmVDb250ZW50XG4gICAgfTtcblxuICAgIGlmICh0eXBlb2YgdGhpcy50cmFuc3BvcnRlciA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgY2FsbGJhY2sobmV3IEVycm9yKCdVbnN1cHBvcnRlZCBjb25maWd1cmF0aW9uLCBkb3duZ3JhZGUgTm9kZW1haWxlciB0byB2MC43LjEgdG8gdXNlIGl0JykpO1xuICAgICAgICByZXR1cm4gcHJvbWlzZTtcbiAgICB9XG5cbiAgICB0aGlzLmxvZ2dlci5pbmZvKCdTZW5kaW5nIG1haWwgdXNpbmcgJXMvJXMnLCB0aGlzLnRyYW5zcG9ydGVyLm5hbWUsIHRoaXMudHJhbnNwb3J0ZXIudmVyc2lvbik7XG5cbiAgICB0aGlzLl9wcm9jZXNzUGx1Z2lucygnY29tcGlsZScsIG1haWwsIGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgdGhpcy5sb2dnZXIuZXJyb3IoJ1BsdWdpbkNvbXBpbGUgRXJyb3I6ICVzJywgZXJyLm1lc3NhZ2UpO1xuICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKGVycik7XG4gICAgICAgIH1cblxuICAgICAgICBtYWlsLm1lc3NhZ2UgPSBtYWlsY29tcG9zZXIobWFpbC5kYXRhKTtcblxuICAgICAgICBpZiAobWFpbC5kYXRhLnhNYWlsZXIgIT09IGZhbHNlKSB7XG4gICAgICAgICAgICBtYWlsLm1lc3NhZ2Uuc2V0SGVhZGVyKCdYLU1haWxlcicsIG1haWwuZGF0YS54TWFpbGVyIHx8IHRoaXMuX2dldFZlcnNpb25TdHJpbmcoKSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAobWFpbC5kYXRhLnByaW9yaXR5KSB7XG4gICAgICAgICAgICBzd2l0Y2ggKChtYWlsLmRhdGEucHJpb3JpdHkgfHwgJycpLnRvU3RyaW5nKCkudG9Mb3dlckNhc2UoKSkge1xuICAgICAgICAgICAgICAgIGNhc2UgJ2hpZ2gnOlxuICAgICAgICAgICAgICAgICAgICBtYWlsLm1lc3NhZ2Uuc2V0SGVhZGVyKCdYLVByaW9yaXR5JywgJzEgKEhpZ2hlc3QpJyk7XG4gICAgICAgICAgICAgICAgICAgIG1haWwubWVzc2FnZS5zZXRIZWFkZXIoJ1gtTVNNYWlsLVByaW9yaXR5JywgJ0hpZ2gnKTtcbiAgICAgICAgICAgICAgICAgICAgbWFpbC5tZXNzYWdlLnNldEhlYWRlcignSW1wb3J0YW5jZScsICdIaWdoJyk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgJ2xvdyc6XG4gICAgICAgICAgICAgICAgICAgIG1haWwubWVzc2FnZS5zZXRIZWFkZXIoJ1gtUHJpb3JpdHknLCAnNSAoTG93ZXN0KScpO1xuICAgICAgICAgICAgICAgICAgICBtYWlsLm1lc3NhZ2Uuc2V0SGVhZGVyKCdYLU1TTWFpbC1Qcmlvcml0eScsICdMb3cnKTtcbiAgICAgICAgICAgICAgICAgICAgbWFpbC5tZXNzYWdlLnNldEhlYWRlcignSW1wb3J0YW5jZScsICdMb3cnKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgLy8gZG8gbm90IGFkZCBhbnl0aGluZywgc2luY2UgYWxsIG1lc3NhZ2VzIGFyZSAnTm9ybWFsJyBieSBkZWZhdWx0XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBhZGQgb3B0aW9uYWwgTGlzdC0qIGhlYWRlcnNcbiAgICAgICAgaWYgKG1haWwuZGF0YS5saXN0ICYmIHR5cGVvZiBtYWlsLmRhdGEubGlzdCA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgIHRoaXMuX2dldExpc3RIZWFkZXJzKG1haWwuZGF0YS5saXN0KS5mb3JFYWNoKGZ1bmN0aW9uIChsaXN0SGVhZGVyKSB7XG4gICAgICAgICAgICAgICAgbGlzdEhlYWRlci52YWx1ZS5mb3JFYWNoKGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICBtYWlsLm1lc3NhZ2UuYWRkSGVhZGVyKGxpc3RIZWFkZXIua2V5LCB2YWx1ZSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuX3Byb2Nlc3NQbHVnaW5zKCdzdHJlYW0nLCBtYWlsLCBmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5sb2dnZXIuZXJyb3IoJ1BsdWdpblN0cmVhbSBFcnJvcjogJXMnLCBlcnIubWVzc2FnZSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKGVycik7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRoaXMudHJhbnNwb3J0ZXIuc2VuZChtYWlsLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgdmFyIGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMpO1xuICAgICAgICAgICAgICAgIGlmIChhcmdzWzBdKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMubG9nZ2VyLmVycm9yKCdTZW5kIEVycm9yOiAlcycsIGFyZ3NbMF0ubWVzc2FnZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhbGxiYWNrLmFwcGx5KG51bGwsIGFyZ3MpO1xuICAgICAgICAgICAgfS5iaW5kKHRoaXMpKTtcbiAgICAgICAgfS5iaW5kKHRoaXMpKTtcbiAgICB9LmJpbmQodGhpcykpO1xuXG4gICAgcmV0dXJuIHByb21pc2U7XG59O1xuXG5Ob2RlbWFpbGVyLnByb3RvdHlwZS5fZ2V0VmVyc2lvblN0cmluZyA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdXRpbC5mb3JtYXQoXG4gICAgICAgICclcyAoJXM7ICslczsgJXMvJXMpJyxcbiAgICAgICAgcGFja2FnZURhdGEubmFtZSxcbiAgICAgICAgcGFja2FnZURhdGEudmVyc2lvbixcbiAgICAgICAgcGFja2FnZURhdGEuaG9tZXBhZ2UsXG4gICAgICAgIHRoaXMudHJhbnNwb3J0ZXIubmFtZSxcbiAgICAgICAgdGhpcy50cmFuc3BvcnRlci52ZXJzaW9uXG4gICAgKTtcbn07XG5cbk5vZGVtYWlsZXIucHJvdG90eXBlLl9wcm9jZXNzUGx1Z2lucyA9IGZ1bmN0aW9uIChzdGVwLCBtYWlsLCBjYWxsYmFjaykge1xuICAgIHN0ZXAgPSAoc3RlcCB8fCAnJykudG9TdHJpbmcoKTtcblxuICAgIGlmICghdGhpcy5fcGx1Z2lucy5oYXNPd25Qcm9wZXJ0eShzdGVwKSB8fCAhdGhpcy5fcGx1Z2luc1tzdGVwXS5sZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIGNhbGxiYWNrKG51bGwpO1xuICAgIH1cblxuICAgIHZhciBwbHVnaW5zID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwodGhpcy5fcGx1Z2luc1tzdGVwXSk7XG5cbiAgICB0aGlzLmxvZ2dlci5kZWJ1ZygnVXNpbmcgJXMgcGx1Z2lucyBmb3IgJXMnLCBwbHVnaW5zLmxlbmd0aCwgc3RlcCk7XG5cbiAgICB2YXIgcHJvY2Vzc1BsdWdpbnMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICghcGx1Z2lucy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHJldHVybiBjYWxsYmFjayhudWxsKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgcGx1Z2luID0gcGx1Z2lucy5zaGlmdCgpO1xuICAgICAgICBwbHVnaW4obWFpbCwgZnVuY3Rpb24gKGVycikge1xuICAgICAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgICAgIHJldHVybiBjYWxsYmFjayhlcnIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcHJvY2Vzc1BsdWdpbnMoKTtcbiAgICAgICAgfSk7XG4gICAgfS5iaW5kKHRoaXMpO1xuXG4gICAgcHJvY2Vzc1BsdWdpbnMoKTtcbn07XG5cbi8qKlxuICogVGhpcyBtZXRob2QgdGFrZXMgbGlzdCBoZWFkZXJzIHN0cnVjdHVyZSBhbmQgY29udmVydHMgaXQgaW50b1xuICogaGVhZGVyIGxpc3Qgd2l0aCBrZXktdmFsdWUgcGFpcnNcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gbGlzdERhdGEgU3RydWN0dXJlZCBMaXN0LSogaGVhZGVyc1xuICogQHJldHVybiB7QXJyYXl9IEFuIGFycmF5IG9mIGhlYWRlcnNcbiAqL1xuTm9kZW1haWxlci5wcm90b3R5cGUuX2dldExpc3RIZWFkZXJzID0gZnVuY3Rpb24gKGxpc3REYXRhKSB7XG4gICAgLy8gbWFrZSBzdXJlIGFuIHVybCBsb29rcyBsaWtlIDxwcm90b2NvbDp1cmw+XG4gICAgdmFyIGZvcm1hdExpc3RVcmwgPSBmdW5jdGlvbiAodXJsKSB7XG4gICAgICAgIHVybCA9IHVybC5yZXBsYWNlKC9bXFxzPF0rfFtcXHM+XSsvZywgJycpO1xuICAgICAgICBpZiAoL14oaHR0cHM/fG1haWx0b3xmdHApOi8udGVzdCh1cmwpKSB7XG4gICAgICAgICAgICByZXR1cm4gJzwnICsgdXJsICsgJz4nO1xuICAgICAgICB9XG4gICAgICAgIGlmICgvXlteQF0rQFteQF0rJC8udGVzdCh1cmwpKSB7XG4gICAgICAgICAgICByZXR1cm4gJzxtYWlsdG86JyArIHVybCArICc+JztcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiAnPGh0dHA6Ly8nICsgdXJsICsgJz4nO1xuICAgIH07XG5cbiAgICByZXR1cm4gT2JqZWN0LmtleXMobGlzdERhdGEpLm1hcChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBrZXk6ICdsaXN0LScgKyBrZXkudG9Mb3dlckNhc2UoKS50cmltKCksXG4gICAgICAgICAgICB2YWx1ZTogW10uY29uY2F0KGxpc3REYXRhW2tleV0gfHwgW10pLm1hcChmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZm9ybWF0TGlzdFVybCh2YWx1ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIHByZXBhcmVkOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICB2YWx1ZTogW10uY29uY2F0KHZhbHVlIHx8IFtdKS5tYXAoZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmb3JtYXRMaXN0VXJsKHZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh2YWx1ZSAmJiB2YWx1ZS51cmwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZm9ybWF0TGlzdFVybCh2YWx1ZS51cmwpICsgKHZhbHVlLmNvbW1lbnQgPyAnICgnICsgdmFsdWUuY29tbWVudCArICcpJyA6ICcnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAnJztcbiAgICAgICAgICAgICAgICAgICAgfSkuam9pbignLCAnKVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9KVxuICAgICAgICB9O1xuICAgIH0pO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIHNoYXJlZCA9IHJlcXVpcmUoJ25vZGVtYWlsZXItc2hhcmVkJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gdGVtcGxhdGVTZW5kZXI7XG5cbi8vIGV4cG9zZSBmb3IgdGVzdGluZ1xubW9kdWxlLmV4cG9ydHMucmVuZGVyID0gcmVuZGVyO1xuXG4vKipcbiAqIENyZWF0ZSB0ZW1wbGF0ZSBiYXNlZCBlLW1haWwgc2VuZGVyXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHRyYW5zcG9ydCBOb2RlbWFpbGVyIHRyYW5zcG9ydCBvYmplY3QgdG8gdXNlIGZvciBhY3R1YWwgc2VuZGluZ1xuICogQHBhcmFtIHtPYmplY3R9IHRlbXBsYXRlcyBFaXRoZXIgYW4gb2JqZWN0IHdpdGggdGVtcGxhdGUgc3RyaW5ncyBvciBhbiBleHRlcm5hbCByZW5kZXJlclxuICogQHBhcmFtIHtPYmplY3R9IFtkZWZhdWx0c10gRGVmYXVsdCBmaWVsZHMgc2V0IGZvciBldmVyeSBtYWlsIHNlbnQgdXNpbmcgdGhpcyBzZW5kZXJcbiAqIEByZXR1cm4ge0Z1bmN0aW9ufSBUZW1wbGF0ZSBiYXNlZCBzZW5kZXJcbiAqL1xuZnVuY3Rpb24gdGVtcGxhdGVTZW5kZXIodHJhbnNwb3J0LCB0ZW1wbGF0ZXMsIGRlZmF1bHRzKSB7XG4gICAgdGVtcGxhdGVzID0gdGVtcGxhdGVzIHx8IHt9O1xuICAgIGRlZmF1bHRzID0gZGVmYXVsdHMgfHwge307XG5cbiAgICAvLyBidWlsdCBpbiByZW5kZXJlclxuICAgIHZhciBkZWZhdWx0UmVuZGVyZXIgPSBmdW5jdGlvbiAoY29udGV4dCwgY2FsbGJhY2spIHtcbiAgICAgICAgdmFyIHJlbmRlcmVkID0ge307XG4gICAgICAgIE9iamVjdC5rZXlzKHRlbXBsYXRlcykuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgICAgICByZW5kZXJlZFtrZXldID0gcmVuZGVyKHRlbXBsYXRlc1trZXldLCB7XG4gICAgICAgICAgICAgICAgZXNjYXBlSHRtbDoga2V5ID09PSAnaHRtbCdcbiAgICAgICAgICAgIH0sIGNvbnRleHQpO1xuICAgICAgICB9KTtcbiAgICAgICAgY2FsbGJhY2sobnVsbCwgcmVuZGVyZWQpO1xuICAgIH07XG5cbiAgICAvLyBhY3R1YWwgcmVuZGVyZXJcbiAgICB2YXIgcmVuZGVyZXIgPSAodHlwZW9mIHRlbXBsYXRlcy5yZW5kZXIgPT09ICdmdW5jdGlvbicgPyB0ZW1wbGF0ZXMucmVuZGVyLmJpbmQodGVtcGxhdGVzKSA6IGRlZmF1bHRSZW5kZXJlcik7XG5cbiAgICByZXR1cm4gZnVuY3Rpb24gKGZpZWxkcywgY29udGV4dCwgY2FsbGJhY2spIHtcblxuICAgICAgICB2YXIgcHJvbWlzZTtcblxuICAgICAgICBpZiAoIWNhbGxiYWNrICYmIHR5cGVvZiBQcm9taXNlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBwcm9taXNlID0gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICAgICAgICAgIGNhbGxiYWNrID0gc2hhcmVkLmNhbGxiYWNrUHJvbWlzZShyZXNvbHZlLCByZWplY3QpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyByZW5kZXIgZGF0YVxuICAgICAgICByZW5kZXJlcihjb250ZXh0LCBmdW5jdGlvbiAoZXJyLCByZW5kZXJlZCkge1xuICAgICAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgICAgIHJldHVybiBjYWxsYmFjayhlcnIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIG1haWxEYXRhID0gbWl4KGRlZmF1bHRzLCBmaWVsZHMsIHJlbmRlcmVkKTtcbiAgICAgICAgICAgIHNldEltbWVkaWF0ZShmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgdHJhbnNwb3J0LnNlbmRNYWlsKG1haWxEYXRhLCBjYWxsYmFjayk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmV0dXJuIHByb21pc2U7XG4gICAgfTtcbn1cblxuLyoqXG4gKiBNZXJnZXMgbXVsdGlwbGUgb2JqZWN0cyBpbnRvIG9uZS4gQXNzdW1lcyBzaW5nbGUgbGV2ZWwsIGV4Y2VwdCAnaGVhZGVycydcbiAqL1xuZnVuY3Rpb24gbWl4KCAvKiBvYmoxLCBvYmoyLCAuLi4sIG9iak4gKi8gKSB7XG4gICAgdmFyIGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMpO1xuICAgIHZhciByZXN1bHQgPSB7fTtcblxuICAgIGFyZ3MuZm9yRWFjaChmdW5jdGlvbiAoYXJnKSB7XG4gICAgICAgIE9iamVjdC5rZXlzKGFyZyB8fCB7fSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgICAgICBpZiAoa2V5ID09PSAnaGVhZGVycycpIHtcbiAgICAgICAgICAgICAgICBpZiAoIXJlc3VsdC5oZWFkZXJzKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdC5oZWFkZXJzID0ge307XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIE9iamVjdC5rZXlzKGFyZ1trZXldKS5mb3JFYWNoKGZ1bmN0aW9uIChoS2V5KSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghKGhLZXkgaW4gcmVzdWx0LmhlYWRlcnMpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQuaGVhZGVyc1toS2V5XSA9IGFyZ1trZXldW2hLZXldO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKCEoa2V5IGluIHJlc3VsdCkpIHtcbiAgICAgICAgICAgICAgICByZXN1bHRba2V5XSA9IGFyZ1trZXldO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9KTtcblxuICAgIHJldHVybiByZXN1bHQ7XG59XG5cbi8qKlxuICogUmVuZGVycyBhIHRlbXBsYXRlIHN0cmluZyB1c2luZyBwcm92aWRlZCBjb250ZXh0LiBWYWx1ZXMgYXJlIG1hcmtlZCBhcyB7e2tleX19IGluIHRoZSB0ZW1wbGF0ZS5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gc3RyIFRlbXBsYXRlIHN0cmluZ1xuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgUmVuZGVyIG9wdGlvbnMuIG9wdGlvbnMuZXNjYXBlSHRtbD10cnVlIGVzY2FwZXMgaHRtbCBzcGVjaWZpYyBjaGFyYWN0ZXJzXG4gKiBAcGFyYW0ge09iamVjdH0gY29udGV4dCBLZXktdmFsdWUgcGFpcnMgZm9yIHRoZSB0ZW1wbGF0ZSwgZWcge25hbWU6ICdVc2VyIE5hbWUnfVxuICogQHJldHVybiB7U3RyaW5nfSBSZW5kZXJlZCB0ZW1wbGF0ZVxuICovXG5mdW5jdGlvbiByZW5kZXIoc3RyLCBvcHRpb25zLCBjb250ZXh0KSB7XG4gICAgc3RyID0gKHN0ciB8fCAnJykudG9TdHJpbmcoKTtcbiAgICBjb250ZXh0ID0gY29udGV4dCB8fCB7fTtcbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuICAgIHZhciByZSA9IC9cXHtcXHtbIF0qKFtee31cXHNdKylbIF0qXFx9XFx9L2c7XG5cbiAgICByZXR1cm4gc3RyLnJlcGxhY2UocmUsIGZ1bmN0aW9uIChtYXRjaCwga2V5KSB7XG4gICAgICAgIHZhciB2YWx1ZTtcbiAgICAgICAgaWYgKGNvbnRleHQuaGFzT3duUHJvcGVydHkoa2V5KSkge1xuICAgICAgICAgICAgdmFsdWUgPSBjb250ZXh0W2tleV0udG9TdHJpbmcoKTtcbiAgICAgICAgICAgIGlmIChvcHRpb25zLmVzY2FwZUh0bWwpIHtcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IHZhbHVlLnJlcGxhY2UoL1tcIicmPD5dL2csIGZ1bmN0aW9uIChjaGFyKSB7XG4gICAgICAgICAgICAgICAgICAgIHN3aXRjaCAoY2hhcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAnJic6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuICcmYW1wOyc7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlICc8JzpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gJyZsdDsnO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAnPic6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuICcmZ3Q7JztcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ1wiJzpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gJyZxdW90Oyc7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlICdcXCcnOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAnJiMwMzk7JztcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNoYXI7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbWF0Y2g7XG4gICAgfSk7XG59XG4iLCIndXNlIHN0cmljdCc7XG5cbi8vIGV4cG9zZSB0byB0aGUgd29ybGRcbm1vZHVsZS5leHBvcnRzID0gYWRkcmVzc3BhcnNlcjtcblxuLyoqXG4gKiBQYXJzZXMgc3RydWN0dXJlZCBlLW1haWwgYWRkcmVzc2VzIGZyb20gYW4gYWRkcmVzcyBmaWVsZFxuICpcbiAqIEV4YW1wbGU6XG4gKlxuICogICAgJ05hbWUgPGFkZHJlc3NAZG9tYWluPidcbiAqXG4gKiB3aWxsIGJlIGNvbnZlcnRlZCB0b1xuICpcbiAqICAgICBbe25hbWU6ICdOYW1lJywgYWRkcmVzczogJ2FkZHJlc3NAZG9tYWluJ31dXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHN0ciBBZGRyZXNzIGZpZWxkXG4gKiBAcmV0dXJuIHtBcnJheX0gQW4gYXJyYXkgb2YgYWRkcmVzcyBvYmplY3RzXG4gKi9cbmZ1bmN0aW9uIGFkZHJlc3NwYXJzZXIoc3RyKSB7XG4gICAgdmFyIHRva2VuaXplciA9IG5ldyBUb2tlbml6ZXIoc3RyKTtcbiAgICB2YXIgdG9rZW5zID0gdG9rZW5pemVyLnRva2VuaXplKCk7XG5cbiAgICB2YXIgYWRkcmVzc2VzID0gW107XG4gICAgdmFyIGFkZHJlc3MgPSBbXTtcbiAgICB2YXIgcGFyc2VkQWRkcmVzc2VzID0gW107XG5cbiAgICB0b2tlbnMuZm9yRWFjaChmdW5jdGlvbiAodG9rZW4pIHtcbiAgICAgICAgaWYgKHRva2VuLnR5cGUgPT09ICdvcGVyYXRvcicgJiYgKHRva2VuLnZhbHVlID09PSAnLCcgfHwgdG9rZW4udmFsdWUgPT09ICc7JykpIHtcbiAgICAgICAgICAgIGlmIChhZGRyZXNzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIGFkZHJlc3Nlcy5wdXNoKGFkZHJlc3MpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYWRkcmVzcyA9IFtdO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgYWRkcmVzcy5wdXNoKHRva2VuKTtcbiAgICAgICAgfVxuICAgIH0pO1xuXG4gICAgaWYgKGFkZHJlc3MubGVuZ3RoKSB7XG4gICAgICAgIGFkZHJlc3Nlcy5wdXNoKGFkZHJlc3MpO1xuICAgIH1cblxuICAgIGFkZHJlc3Nlcy5mb3JFYWNoKGZ1bmN0aW9uIChhZGRyZXNzKSB7XG4gICAgICAgIGFkZHJlc3MgPSBfaGFuZGxlQWRkcmVzcyhhZGRyZXNzKTtcbiAgICAgICAgaWYgKGFkZHJlc3MubGVuZ3RoKSB7XG4gICAgICAgICAgICBwYXJzZWRBZGRyZXNzZXMgPSBwYXJzZWRBZGRyZXNzZXMuY29uY2F0KGFkZHJlc3MpO1xuICAgICAgICB9XG4gICAgfSk7XG5cbiAgICByZXR1cm4gcGFyc2VkQWRkcmVzc2VzO1xufVxuXG4vKipcbiAqIENvbnZlcnRzIHRva2VucyBmb3IgYSBzaW5nbGUgYWRkcmVzcyBpbnRvIGFuIGFkZHJlc3Mgb2JqZWN0XG4gKlxuICogQHBhcmFtIHtBcnJheX0gdG9rZW5zIFRva2VucyBvYmplY3RcbiAqIEByZXR1cm4ge09iamVjdH0gQWRkcmVzcyBvYmplY3RcbiAqL1xuZnVuY3Rpb24gX2hhbmRsZUFkZHJlc3ModG9rZW5zKSB7XG4gICAgdmFyIHRva2VuO1xuICAgIHZhciBpc0dyb3VwID0gZmFsc2U7XG4gICAgdmFyIHN0YXRlID0gJ3RleHQnO1xuICAgIHZhciBhZGRyZXNzO1xuICAgIHZhciBhZGRyZXNzZXMgPSBbXTtcbiAgICB2YXIgZGF0YSA9IHtcbiAgICAgICAgYWRkcmVzczogW10sXG4gICAgICAgIGNvbW1lbnQ6IFtdLFxuICAgICAgICBncm91cDogW10sXG4gICAgICAgIHRleHQ6IFtdXG4gICAgfTtcbiAgICB2YXIgaTtcbiAgICB2YXIgbGVuO1xuXG4gICAgLy8gRmlsdGVyIG91dCA8YWRkcmVzc2VzPiwgKGNvbW1lbnRzKSBhbmQgcmVndWxhciB0ZXh0XG4gICAgZm9yIChpID0gMCwgbGVuID0gdG9rZW5zLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgIHRva2VuID0gdG9rZW5zW2ldO1xuICAgICAgICBpZiAodG9rZW4udHlwZSA9PT0gJ29wZXJhdG9yJykge1xuICAgICAgICAgICAgc3dpdGNoICh0b2tlbi52YWx1ZSkge1xuICAgICAgICAgICAgICAgIGNhc2UgJzwnOlxuICAgICAgICAgICAgICAgICAgICBzdGF0ZSA9ICdhZGRyZXNzJztcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAnKCc6XG4gICAgICAgICAgICAgICAgICAgIHN0YXRlID0gJ2NvbW1lbnQnO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlICc6JzpcbiAgICAgICAgICAgICAgICAgICAgc3RhdGUgPSAnZ3JvdXAnO1xuICAgICAgICAgICAgICAgICAgICBpc0dyb3VwID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgc3RhdGUgPSAndGV4dCc7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAodG9rZW4udmFsdWUpIHtcbiAgICAgICAgICAgIGlmIChzdGF0ZSA9PT0gJ2FkZHJlc3MnKSB7XG4gICAgICAgICAgICAgICAgLy8gaGFuZGxlIHVzZSBjYXNlIHdoZXJlIHVucXVvdGVkIG5hbWUgaW5jbHVkZXMgYSBcIjxcIlxuICAgICAgICAgICAgICAgIC8vIEFwcGxlIE1haWwgdHJ1bmNhdGVzIGV2ZXJ5dGhpbmcgYmV0d2VlbiBhbiB1bmV4cGVjdGVkIDwgYW5kIGFuIGFkZHJlc3NcbiAgICAgICAgICAgICAgICAvLyBhbmQgc28gd2lsbCB3ZVxuICAgICAgICAgICAgICAgIHRva2VuLnZhbHVlID0gdG9rZW4udmFsdWUucmVwbGFjZSgvXltePF0qPFxccyovLCAnJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBkYXRhW3N0YXRlXS5wdXNoKHRva2VuLnZhbHVlKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIElmIHRoZXJlIGlzIG5vIHRleHQgYnV0IGEgY29tbWVudCwgcmVwbGFjZSB0aGUgdHdvXG4gICAgaWYgKCFkYXRhLnRleHQubGVuZ3RoICYmIGRhdGEuY29tbWVudC5sZW5ndGgpIHtcbiAgICAgICAgZGF0YS50ZXh0ID0gZGF0YS5jb21tZW50O1xuICAgICAgICBkYXRhLmNvbW1lbnQgPSBbXTtcbiAgICB9XG5cbiAgICBpZiAoaXNHcm91cCkge1xuICAgICAgICAvLyBodHRwOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmMyODIyI2FwcGVuZGl4LUEuMS4zXG4gICAgICAgIGRhdGEudGV4dCA9IGRhdGEudGV4dC5qb2luKCcgJyk7XG4gICAgICAgIGFkZHJlc3Nlcy5wdXNoKHtcbiAgICAgICAgICAgIG5hbWU6IGRhdGEudGV4dCB8fCAoYWRkcmVzcyAmJiBhZGRyZXNzLm5hbWUpLFxuICAgICAgICAgICAgZ3JvdXA6IGRhdGEuZ3JvdXAubGVuZ3RoID8gYWRkcmVzc3BhcnNlcihkYXRhLmdyb3VwLmpvaW4oJywnKSkgOiBbXVxuICAgICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgICAvLyBJZiBubyBhZGRyZXNzIHdhcyBmb3VuZCwgdHJ5IHRvIGRldGVjdCBvbmUgZnJvbSByZWd1bGFyIHRleHRcbiAgICAgICAgaWYgKCFkYXRhLmFkZHJlc3MubGVuZ3RoICYmIGRhdGEudGV4dC5sZW5ndGgpIHtcbiAgICAgICAgICAgIGZvciAoaSA9IGRhdGEudGV4dC5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICAgICAgICAgIGlmIChkYXRhLnRleHRbaV0ubWF0Y2goL15bXkBcXHNdK0BbXkBcXHNdKyQvKSkge1xuICAgICAgICAgICAgICAgICAgICBkYXRhLmFkZHJlc3MgPSBkYXRhLnRleHQuc3BsaWNlKGksIDEpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBfcmVnZXhIYW5kbGVyID0gZnVuY3Rpb24gKGFkZHJlc3MpIHtcbiAgICAgICAgICAgICAgICBpZiAoIWRhdGEuYWRkcmVzcy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgZGF0YS5hZGRyZXNzID0gW2FkZHJlc3MudHJpbSgpXTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICcgJztcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gYWRkcmVzcztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAvLyBzdGlsbCBubyBhZGRyZXNzXG4gICAgICAgICAgICBpZiAoIWRhdGEuYWRkcmVzcy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBmb3IgKGkgPSBkYXRhLnRleHQubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gZml4ZWQgdGhlIHJlZ2V4IHRvIHBhcnNlIGVtYWlsIGFkZHJlc3MgY29ycmVjdGx5IHdoZW4gZW1haWwgYWRkcmVzcyBoYXMgbW9yZSB0aGFuIG9uZSBAXG4gICAgICAgICAgICAgICAgICAgIGRhdGEudGV4dFtpXSA9IGRhdGEudGV4dFtpXS5yZXBsYWNlKC9cXHMqXFxiW15AXFxzXStAW15cXHNdK1xcYlxccyovLCBfcmVnZXhIYW5kbGVyKS50cmltKCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChkYXRhLmFkZHJlc3MubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIElmIHRoZXJlJ3Mgc3RpbGwgaXMgbm8gdGV4dCBidXQgYSBjb21tZW50IGV4aXh0cywgcmVwbGFjZSB0aGUgdHdvXG4gICAgICAgIGlmICghZGF0YS50ZXh0Lmxlbmd0aCAmJiBkYXRhLmNvbW1lbnQubGVuZ3RoKSB7XG4gICAgICAgICAgICBkYXRhLnRleHQgPSBkYXRhLmNvbW1lbnQ7XG4gICAgICAgICAgICBkYXRhLmNvbW1lbnQgPSBbXTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEtlZXAgb25seSB0aGUgZmlyc3QgYWRkcmVzcyBvY2N1cmVuY2UsIHB1c2ggb3RoZXJzIHRvIHJlZ3VsYXIgdGV4dFxuICAgICAgICBpZiAoZGF0YS5hZGRyZXNzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgIGRhdGEudGV4dCA9IGRhdGEudGV4dC5jb25jYXQoZGF0YS5hZGRyZXNzLnNwbGljZSgxKSk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBKb2luIHZhbHVlcyB3aXRoIHNwYWNlc1xuICAgICAgICBkYXRhLnRleHQgPSBkYXRhLnRleHQuam9pbignICcpO1xuICAgICAgICBkYXRhLmFkZHJlc3MgPSBkYXRhLmFkZHJlc3Muam9pbignICcpO1xuXG4gICAgICAgIGlmICghZGF0YS5hZGRyZXNzICYmIGlzR3JvdXApIHtcbiAgICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGFkZHJlc3MgPSB7XG4gICAgICAgICAgICAgICAgYWRkcmVzczogZGF0YS5hZGRyZXNzIHx8IGRhdGEudGV4dCB8fCAnJyxcbiAgICAgICAgICAgICAgICBuYW1lOiBkYXRhLnRleHQgfHwgZGF0YS5hZGRyZXNzIHx8ICcnXG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICBpZiAoYWRkcmVzcy5hZGRyZXNzID09PSBhZGRyZXNzLm5hbWUpIHtcbiAgICAgICAgICAgICAgICBpZiAoKGFkZHJlc3MuYWRkcmVzcyB8fCAnJykubWF0Y2goL0AvKSkge1xuICAgICAgICAgICAgICAgICAgICBhZGRyZXNzLm5hbWUgPSAnJztcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBhZGRyZXNzLmFkZHJlc3MgPSAnJztcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgYWRkcmVzc2VzLnB1c2goYWRkcmVzcyk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gYWRkcmVzc2VzO1xufVxuXG4vKipcbiAqIENyZWF0ZXMgYSBUb2tlbml6ZXIgb2JqZWN0IGZvciB0b2tlbml6aW5nIGFkZHJlc3MgZmllbGQgc3RyaW5nc1xuICpcbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtTdHJpbmd9IHN0ciBBZGRyZXNzIGZpZWxkIHN0cmluZ1xuICovXG5mdW5jdGlvbiBUb2tlbml6ZXIoc3RyKSB7XG4gICAgdGhpcy5zdHIgPSAoc3RyIHx8ICcnKS50b1N0cmluZygpO1xuICAgIHRoaXMub3BlcmF0b3JDdXJyZW50ID0gJyc7XG4gICAgdGhpcy5vcGVyYXRvckV4cGVjdGluZyA9ICcnO1xuICAgIHRoaXMubm9kZSA9IG51bGw7XG4gICAgdGhpcy5lc2NhcGVkID0gZmFsc2U7XG5cbiAgICB0aGlzLmxpc3QgPSBbXTtcbn1cblxuLyoqXG4gKiBPcGVyYXRvciB0b2tlbnMgYW5kIHdoaWNoIHRva2VucyBhcmUgZXhwZWN0ZWQgdG8gZW5kIHRoZSBzZXF1ZW5jZVxuICovXG5Ub2tlbml6ZXIucHJvdG90eXBlLm9wZXJhdG9ycyA9IHtcbiAgICAnXCInOiAnXCInLFxuICAgICcoJzogJyknLFxuICAgICc8JzogJz4nLFxuICAgICcsJzogJycsXG4gICAgJzonOiAnOycsXG4gICAgLy8gU2VtaWNvbG9ucyBhcmUgbm90IGEgbGVnYWwgZGVsaW1pdGVyIHBlciB0aGUgUkZDMjgyMiBncmFtbWFyIG90aGVyXG4gICAgLy8gdGhhbiBmb3IgdGVybWluYXRpbmcgYSBncm91cCwgYnV0IHRoZXkgYXJlIGFsc28gbm90IHZhbGlkIGZvciBhbnlcbiAgICAvLyBvdGhlciB1c2UgaW4gdGhpcyBjb250ZXh0LiAgR2l2ZW4gdGhhdCBzb21lIG1haWwgY2xpZW50cyBoYXZlXG4gICAgLy8gaGlzdG9yaWNhbGx5IGFsbG93ZWQgdGhlIHNlbWljb2xvbiBhcyBhIGRlbGltaXRlciBlcXVpdmFsZW50IHRvIHRoZVxuICAgIC8vIGNvbW1hIGluIHRoZWlyIFVJLCBpdCBtYWtlcyBzZW5zZSB0byB0cmVhdCB0aGVtIHRoZSBzYW1lIGFzIGEgY29tbWFcbiAgICAvLyB3aGVuIHVzZWQgb3V0c2lkZSBvZiBhIGdyb3VwLlxuICAgICc7JzogJydcbn07XG5cbi8qKlxuICogVG9rZW5pemVzIHRoZSBvcmlnaW5hbCBpbnB1dCBzdHJpbmdcbiAqXG4gKiBAcmV0dXJuIHtBcnJheX0gQW4gYXJyYXkgb2Ygb3BlcmF0b3J8dGV4dCB0b2tlbnNcbiAqL1xuVG9rZW5pemVyLnByb3RvdHlwZS50b2tlbml6ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgY2hyLCBsaXN0ID0gW107XG4gICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IHRoaXMuc3RyLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgIGNociA9IHRoaXMuc3RyLmNoYXJBdChpKTtcbiAgICAgICAgdGhpcy5jaGVja0NoYXIoY2hyKTtcbiAgICB9XG5cbiAgICB0aGlzLmxpc3QuZm9yRWFjaChmdW5jdGlvbiAobm9kZSkge1xuICAgICAgICBub2RlLnZhbHVlID0gKG5vZGUudmFsdWUgfHwgJycpLnRvU3RyaW5nKCkudHJpbSgpO1xuICAgICAgICBpZiAobm9kZS52YWx1ZSkge1xuICAgICAgICAgICAgbGlzdC5wdXNoKG5vZGUpO1xuICAgICAgICB9XG4gICAgfSk7XG5cbiAgICByZXR1cm4gbGlzdDtcbn07XG5cbi8qKlxuICogQ2hlY2tzIGlmIGEgY2hhcmFjdGVyIGlzIGFuIG9wZXJhdG9yIG9yIHRleHQgYW5kIGFjdHMgYWNjb3JkaW5nbHlcbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gY2hyIENoYXJhY3RlciBmcm9tIHRoZSBhZGRyZXNzIGZpZWxkXG4gKi9cblRva2VuaXplci5wcm90b3R5cGUuY2hlY2tDaGFyID0gZnVuY3Rpb24gKGNocikge1xuICAgIGlmICgoY2hyIGluIHRoaXMub3BlcmF0b3JzIHx8IGNociA9PT0gJ1xcXFwnKSAmJiB0aGlzLmVzY2FwZWQpIHtcbiAgICAgICAgdGhpcy5lc2NhcGVkID0gZmFsc2U7XG4gICAgfSBlbHNlIGlmICh0aGlzLm9wZXJhdG9yRXhwZWN0aW5nICYmIGNociA9PT0gdGhpcy5vcGVyYXRvckV4cGVjdGluZykge1xuICAgICAgICB0aGlzLm5vZGUgPSB7XG4gICAgICAgICAgICB0eXBlOiAnb3BlcmF0b3InLFxuICAgICAgICAgICAgdmFsdWU6IGNoclxuICAgICAgICB9O1xuICAgICAgICB0aGlzLmxpc3QucHVzaCh0aGlzLm5vZGUpO1xuICAgICAgICB0aGlzLm5vZGUgPSBudWxsO1xuICAgICAgICB0aGlzLm9wZXJhdG9yRXhwZWN0aW5nID0gJyc7XG4gICAgICAgIHRoaXMuZXNjYXBlZCA9IGZhbHNlO1xuICAgICAgICByZXR1cm47XG4gICAgfSBlbHNlIGlmICghdGhpcy5vcGVyYXRvckV4cGVjdGluZyAmJiBjaHIgaW4gdGhpcy5vcGVyYXRvcnMpIHtcbiAgICAgICAgdGhpcy5ub2RlID0ge1xuICAgICAgICAgICAgdHlwZTogJ29wZXJhdG9yJyxcbiAgICAgICAgICAgIHZhbHVlOiBjaHJcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5saXN0LnB1c2godGhpcy5ub2RlKTtcbiAgICAgICAgdGhpcy5ub2RlID0gbnVsbDtcbiAgICAgICAgdGhpcy5vcGVyYXRvckV4cGVjdGluZyA9IHRoaXMub3BlcmF0b3JzW2Nocl07XG4gICAgICAgIHRoaXMuZXNjYXBlZCA9IGZhbHNlO1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKCF0aGlzLmVzY2FwZWQgJiYgY2hyID09PSAnXFxcXCcpIHtcbiAgICAgICAgdGhpcy5lc2NhcGVkID0gdHJ1ZTtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmICghdGhpcy5ub2RlKSB7XG4gICAgICAgIHRoaXMubm9kZSA9IHtcbiAgICAgICAgICAgIHR5cGU6ICd0ZXh0JyxcbiAgICAgICAgICAgIHZhbHVlOiAnJ1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLmxpc3QucHVzaCh0aGlzLm5vZGUpO1xuICAgIH1cblxuICAgIGlmICh0aGlzLmVzY2FwZWQgJiYgY2hyICE9PSAnXFxcXCcpIHtcbiAgICAgICAgdGhpcy5ub2RlLnZhbHVlICs9ICdcXFxcJztcbiAgICB9XG5cbiAgICB0aGlzLm5vZGUudmFsdWUgKz0gY2hyO1xuICAgIHRoaXMuZXNjYXBlZCA9IGZhbHNlO1xufTtcbiIsIihmdW5jdGlvbiAoQnVmZmVyKXtcbid1c2Ugc3RyaWN0JztcblxudmFyIGxpYm1pbWUgPSByZXF1aXJlKCdsaWJtaW1lJyk7XG52YXIgbGlicXAgPSByZXF1aXJlKCdsaWJxcCcpO1xudmFyIGxpYmJhc2U2NCA9IHJlcXVpcmUoJ2xpYmJhc2U2NCcpO1xudmFyIHB1bnljb2RlID0gcmVxdWlyZSgncHVueWNvZGUnKTtcbnZhciBhZGRyZXNzcGFyc2VyID0gcmVxdWlyZSgnYWRkcmVzc3BhcnNlcicpO1xudmFyIHN0cmVhbSA9IHJlcXVpcmUoJ3N0cmVhbScpO1xudmFyIFBhc3NUaHJvdWdoID0gc3RyZWFtLlBhc3NUaHJvdWdoO1xudmFyIGZzID0gcmVxdWlyZSgnZnMnKTtcbnZhciBmZXRjaCA9IHJlcXVpcmUoJ25vZGVtYWlsZXItZmV0Y2gnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBNaW1lTm9kZTtcblxuLyoqXG4gKiBDcmVhdGVzIGEgbmV3IG1pbWUgdHJlZSBub2RlLiBBc3N1bWVzICdtdWx0aXBhcnQvKicgYXMgdGhlIGNvbnRlbnQgdHlwZVxuICogaWYgaXQgaXMgYSBicmFuY2gsIGFueXRoaW5nIGVsc2UgY291bnRzIGFzIGxlYWYuIElmIHJvb3ROb2RlIGlzIG1pc3NpbmcgZnJvbVxuICogdGhlIG9wdGlvbnMsIGFzc3VtZXMgdGhpcyBpcyB0aGUgcm9vdC5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gY29udGVudFR5cGUgRGVmaW5lIHRoZSBjb250ZW50IHR5cGUgZm9yIHRoZSBub2RlLiBDYW4gYmUgbGVmdCBibGFuayBmb3IgYXR0YWNobWVudHMgKGRlcml2ZWQgZnJvbSBmaWxlbmFtZSlcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gb3B0aW9uYWwgb3B0aW9uc1xuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zLnJvb3ROb2RlXSByb290IG5vZGUgZm9yIHRoaXMgdHJlZVxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zLnBhcmVudE5vZGVdIGltbWVkaWF0ZSBwYXJlbnQgZm9yIHRoaXMgbm9kZVxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zLmZpbGVuYW1lXSBmaWxlbmFtZSBmb3IgYW4gYXR0YWNobWVudCBub2RlXG4gKiBAcGFyYW0ge1N0cmluZ30gW29wdGlvbnMuYmFzZUJvdW5kYXJ5XSBzaGFyZWQgcGFydCBvZiB0aGUgdW5pcXVlIG11bHRpcGFydCBib3VuZGFyeVxuICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5rZWVwQmNjXSBJZiB0cnVlLCBkbyBub3QgZXhjbHVkZSBCY2MgZnJvbSB0aGUgZ2VuZXJhdGVkIGhlYWRlcnNcbiAqIEBwYXJhbSB7U3RyaW5nfSBbb3B0aW9ucy50ZXh0RW5jb2RpbmddIGVpdGhlciAnUScgKHRoZSBkZWZhdWx0KSBvciAnQidcbiAqL1xuZnVuY3Rpb24gTWltZU5vZGUoY29udGVudFR5cGUsIG9wdGlvbnMpIHtcbiAgICB0aGlzLm5vZGVDb3VudGVyID0gMDtcblxuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG4gICAgLyoqXG4gICAgICogc2hhcmVkIHBhcnQgb2YgdGhlIHVuaXF1ZSBtdWx0aXBhcnQgYm91bmRhcnlcbiAgICAgKi9cbiAgICB0aGlzLmJhc2VCb3VuZGFyeSA9IG9wdGlvbnMuYmFzZUJvdW5kYXJ5IHx8IERhdGUubm93KCkudG9TdHJpbmcoKSArIE1hdGgucmFuZG9tKCk7XG5cbiAgICAvKipcbiAgICAgKiBJZiBkYXRlIGhlYWRlcnMgaXMgbWlzc2luZyBhbmQgY3VycmVudCBub2RlIGlzIHRoZSByb290LCB0aGlzIHZhbHVlIGlzIHVzZWQgaW5zdGVhZFxuICAgICAqL1xuICAgIHRoaXMuZGF0ZSA9IG5ldyBEYXRlKCk7XG5cbiAgICAvKipcbiAgICAgKiBSb290IG5vZGUgZm9yIGN1cnJlbnQgbWltZSB0cmVlXG4gICAgICovXG4gICAgdGhpcy5yb290Tm9kZSA9IG9wdGlvbnMucm9vdE5vZGUgfHwgdGhpcztcblxuICAgIC8qKlxuICAgICAqIElmIHRydWUgaW5jbHVkZSBCY2MgaW4gZ2VuZXJhdGVkIGhlYWRlcnMgKGlmIGF2YWlsYWJsZSlcbiAgICAgKi9cbiAgICB0aGlzLmtlZXBCY2MgPSAhIW9wdGlvbnMua2VlcEJjYztcblxuICAgIC8qKlxuICAgICAqIElmIGZpbGVuYW1lIGlzIHNwZWNpZmllZCBidXQgY29udGVudFR5cGUgaXMgbm90IChwcm9iYWJseSBhbiBhdHRhY2htZW50KVxuICAgICAqIGRldGVjdCB0aGUgY29udGVudCB0eXBlIGZyb20gZmlsZW5hbWUgZXh0ZW5zaW9uXG4gICAgICovXG4gICAgaWYgKG9wdGlvbnMuZmlsZW5hbWUpIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEZpbGVuYW1lIGZvciB0aGlzIG5vZGUuIFVzZWZ1bCB3aXRoIGF0dGFjaG1lbnRzXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmZpbGVuYW1lID0gb3B0aW9ucy5maWxlbmFtZTtcbiAgICAgICAgaWYgKCFjb250ZW50VHlwZSkge1xuICAgICAgICAgICAgY29udGVudFR5cGUgPSBsaWJtaW1lLmRldGVjdE1pbWVUeXBlKHRoaXMuZmlsZW5hbWUuc3BsaXQoJy4nKS5wb3AoKSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBJbmRpY2F0ZXMgd2hpY2ggZW5jb2Rpbmcgc2hvdWxkIGJlIHVzZWQgZm9yIGhlYWRlciBzdHJpbmdzOiBcIlFcIiBvciBcIkJcIlxuICAgICAqL1xuICAgIHRoaXMudGV4dEVuY29kaW5nID0gKG9wdGlvbnMudGV4dEVuY29kaW5nIHx8ICcnKS50b1N0cmluZygpLnRyaW0oKS5jaGFyQXQoMCkudG9VcHBlckNhc2UoKTtcblxuICAgIC8qKlxuICAgICAqIEltbWVkaWF0ZSBwYXJlbnQgZm9yIHRoaXMgbm9kZSAob3IgdW5kZWZpbmVkIGlmIG5vdCBzZXQpXG4gICAgICovXG4gICAgdGhpcy5wYXJlbnROb2RlID0gb3B0aW9ucy5wYXJlbnROb2RlO1xuXG4gICAgLyoqXG4gICAgICogQW4gYXJyYXkgZm9yIHBvc3NpYmxlIGNoaWxkIG5vZGVzXG4gICAgICovXG4gICAgdGhpcy5jaGlsZE5vZGVzID0gW107XG5cbiAgICAvKipcbiAgICAgKiBVc2VkIGZvciBnZW5lcmF0aW5nIHVuaXF1ZSBib3VuZGFyaWVzIChwcmVwZW5kZWQgdG8gdGhlIHNoYXJlZCBiYXNlKVxuICAgICAqL1xuICAgIHRoaXMuX25vZGVJZCA9ICsrdGhpcy5yb290Tm9kZS5ub2RlQ291bnRlcjtcblxuICAgIC8qKlxuICAgICAqIEEgbGlzdCBvZiBoZWFkZXIgdmFsdWVzIGZvciB0aGlzIG5vZGUgaW4gdGhlIGZvcm0gb2YgW3trZXk6JycsIHZhbHVlOicnfV1cbiAgICAgKi9cbiAgICB0aGlzLl9oZWFkZXJzID0gW107XG5cbiAgICAvKipcbiAgICAgKiBUcnVlIGlmIHRoZSBjb250ZW50IG9ubHkgdXNlcyBBU0NJSSBwcmludGFibGUgY2hhcmFjdGVyc1xuICAgICAqIEB0eXBlIHtCb29sZWFufVxuICAgICAqL1xuICAgIHRoaXMuX2lzUGxhaW5UZXh0ID0gZmFsc2U7XG5cbiAgICAvKipcbiAgICAgKiBUcnVlIGlmIHRoZSBjb250ZW50IGlzIHBsYWluIHRleHQgYnV0IGhhcyBsb25nZXIgbGluZXMgdGhhbiBhbGxvd2VkXG4gICAgICogQHR5cGUge0Jvb2xlYW59XG4gICAgICovXG4gICAgdGhpcy5faGFzTG9uZ0xpbmVzID0gZmFsc2U7XG5cbiAgICAvKipcbiAgICAgKiBJZiBzZXQsIHVzZSBpbnN0ZWFkIHRoaXMgdmFsdWUgZm9yIGVudmVsb3BlcyBpbnN0ZWFkIG9mIGdlbmVyYXRpbmcgb25lXG4gICAgICogQHR5cGUge0Jvb2xlYW59XG4gICAgICovXG4gICAgdGhpcy5fZW52ZWxvcGUgPSBmYWxzZTtcblxuICAgIC8qKlxuICAgICAqIElmIHNldCB0aGVuIHVzZSB0aGlzIHZhbHVlIGFzIHRoZSBzdHJlYW0gY29udGVudCBpbnN0ZWFkIG9mIGJ1aWxkaW5nIGl0XG4gICAgICogQHR5cGUge1N0cmluZ3xCdWZmZXJ8U3RyZWFtfVxuICAgICAqL1xuICAgIHRoaXMuX3JhdyA9IGZhbHNlO1xuXG4gICAgLyoqXG4gICAgICogQWRkaXRpb25hbCB0cmFuc2Zvcm0gc3RyZWFtcyB0aGF0IHRoZSBtZXNzYWdlIHdpbGwgYmUgcGlwZWQgYmVmb3JlXG4gICAgICogZXhwb3NpbmcgYnkgY3JlYXRlUmVhZFN0cmVhbVxuICAgICAqIEB0eXBlIHtBcnJheX1cbiAgICAgKi9cbiAgICB0aGlzLl90cmFuc2Zvcm1zID0gW107XG5cbiAgICAvKipcbiAgICAgKiBJZiBjb250ZW50IHR5cGUgaXMgc2V0IChvciBkZXJpdmVkIGZyb20gdGhlIGZpbGVuYW1lKSBhZGQgaXQgdG8gaGVhZGVyc1xuICAgICAqL1xuICAgIGlmIChjb250ZW50VHlwZSkge1xuICAgICAgICB0aGlzLnNldEhlYWRlcignY29udGVudC10eXBlJywgY29udGVudFR5cGUpO1xuICAgIH1cbn1cblxuLy8vLy8vLyBQVUJMSUMgTUVUSE9EU1xuXG4vKipcbiAqIENyZWF0ZXMgYW5kIGFwcGVuZHMgYSBjaGlsZCBub2RlLkFyZ3VtZW50cyBwcm92aWRlZCBhcmUgcGFzc2VkIHRvIE1pbWVOb2RlIGNvbnN0cnVjdG9yXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IFtjb250ZW50VHlwZV0gT3B0aW9uYWwgY29udGVudCB0eXBlXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIE9wdGlvbmFsIG9wdGlvbnMgb2JqZWN0XG4gKiBAcmV0dXJuIHtPYmplY3R9IENyZWF0ZWQgbm9kZSBvYmplY3RcbiAqL1xuTWltZU5vZGUucHJvdG90eXBlLmNyZWF0ZUNoaWxkID0gZnVuY3Rpb24gKGNvbnRlbnRUeXBlLCBvcHRpb25zKSB7XG4gICAgaWYgKCFvcHRpb25zICYmIHR5cGVvZiBjb250ZW50VHlwZSA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgb3B0aW9ucyA9IGNvbnRlbnRUeXBlO1xuICAgICAgICBjb250ZW50VHlwZSA9IHVuZGVmaW5lZDtcbiAgICB9XG4gICAgdmFyIG5vZGUgPSBuZXcgTWltZU5vZGUoY29udGVudFR5cGUsIG9wdGlvbnMpO1xuICAgIHRoaXMuYXBwZW5kQ2hpbGQobm9kZSk7XG4gICAgcmV0dXJuIG5vZGU7XG59O1xuXG4vKipcbiAqIEFwcGVuZHMgYW4gZXhpc3Rpbmcgbm9kZSB0byB0aGUgbWltZSB0cmVlLiBSZW1vdmVzIHRoZSBub2RlIGZyb20gYW4gZXhpc3RpbmdcbiAqIHRyZWUgaWYgbmVlZGVkXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IGNoaWxkTm9kZSBub2RlIHRvIGJlIGFwcGVuZGVkXG4gKiBAcmV0dXJuIHtPYmplY3R9IEFwcGVuZGVkIG5vZGUgb2JqZWN0XG4gKi9cbk1pbWVOb2RlLnByb3RvdHlwZS5hcHBlbmRDaGlsZCA9IGZ1bmN0aW9uIChjaGlsZE5vZGUpIHtcblxuICAgIGlmIChjaGlsZE5vZGUucm9vdE5vZGUgIT09IHRoaXMucm9vdE5vZGUpIHtcbiAgICAgICAgY2hpbGROb2RlLnJvb3ROb2RlID0gdGhpcy5yb290Tm9kZTtcbiAgICAgICAgY2hpbGROb2RlLl9ub2RlSWQgPSArK3RoaXMucm9vdE5vZGUubm9kZUNvdW50ZXI7XG4gICAgfVxuXG4gICAgY2hpbGROb2RlLnBhcmVudE5vZGUgPSB0aGlzO1xuXG4gICAgdGhpcy5jaGlsZE5vZGVzLnB1c2goY2hpbGROb2RlKTtcbiAgICByZXR1cm4gY2hpbGROb2RlO1xufTtcblxuLyoqXG4gKiBSZXBsYWNlcyBjdXJyZW50IG5vZGUgd2l0aCBhbm90aGVyIG5vZGVcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gbm9kZSBSZXBsYWNlbWVudCBub2RlXG4gKiBAcmV0dXJuIHtPYmplY3R9IFJlcGxhY2VtZW50IG5vZGVcbiAqL1xuTWltZU5vZGUucHJvdG90eXBlLnJlcGxhY2UgPSBmdW5jdGlvbiAobm9kZSkge1xuICAgIGlmIChub2RlID09PSB0aGlzKSB7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIHRoaXMucGFyZW50Tm9kZS5jaGlsZE5vZGVzLmZvckVhY2goZnVuY3Rpb24gKGNoaWxkTm9kZSwgaSkge1xuICAgICAgICBpZiAoY2hpbGROb2RlID09PSB0aGlzKSB7XG5cbiAgICAgICAgICAgIG5vZGUucm9vdE5vZGUgPSB0aGlzLnJvb3ROb2RlO1xuICAgICAgICAgICAgbm9kZS5wYXJlbnROb2RlID0gdGhpcy5wYXJlbnROb2RlO1xuICAgICAgICAgICAgbm9kZS5fbm9kZUlkID0gdGhpcy5fbm9kZUlkO1xuXG4gICAgICAgICAgICB0aGlzLnJvb3ROb2RlID0gdGhpcztcbiAgICAgICAgICAgIHRoaXMucGFyZW50Tm9kZSA9IHVuZGVmaW5lZDtcblxuICAgICAgICAgICAgbm9kZS5wYXJlbnROb2RlLmNoaWxkTm9kZXNbaV0gPSBub2RlO1xuICAgICAgICB9XG4gICAgfS5iaW5kKHRoaXMpKTtcblxuICAgIHJldHVybiBub2RlO1xufTtcblxuLyoqXG4gKiBSZW1vdmVzIGN1cnJlbnQgbm9kZSBmcm9tIHRoZSBtaW1lIHRyZWVcbiAqXG4gKiBAcmV0dXJuIHtPYmplY3R9IHJlbW92ZWQgbm9kZVxuICovXG5NaW1lTm9kZS5wcm90b3R5cGUucmVtb3ZlID0gZnVuY3Rpb24gKCkge1xuICAgIGlmICghdGhpcy5wYXJlbnROb2RlKSB7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIGZvciAodmFyIGkgPSB0aGlzLnBhcmVudE5vZGUuY2hpbGROb2Rlcy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICBpZiAodGhpcy5wYXJlbnROb2RlLmNoaWxkTm9kZXNbaV0gPT09IHRoaXMpIHtcbiAgICAgICAgICAgIHRoaXMucGFyZW50Tm9kZS5jaGlsZE5vZGVzLnNwbGljZShpLCAxKTtcbiAgICAgICAgICAgIHRoaXMucGFyZW50Tm9kZSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIHRoaXMucm9vdE5vZGUgPSB0aGlzO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cbiAgICB9XG59O1xuXG4vKipcbiAqIFNldHMgYSBoZWFkZXIgdmFsdWUuIElmIHRoZSB2YWx1ZSBmb3Igc2VsZWN0ZWQga2V5IGV4aXN0cywgaXQgaXMgb3ZlcndyaXR0ZW4uXG4gKiBZb3UgY2FuIHNldCBtdWx0aXBsZSB2YWx1ZXMgYXMgd2VsbCBieSB1c2luZyBbe2tleTonJywgdmFsdWU6Jyd9XSBvclxuICoge2tleTogJ3ZhbHVlJ30gYXMgdGhlIGZpcnN0IGFyZ3VtZW50LlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfEFycmF5fE9iamVjdH0ga2V5IEhlYWRlciBrZXkgb3IgYSBsaXN0IG9mIGtleSB2YWx1ZSBwYWlyc1xuICogQHBhcmFtIHtTdHJpbmd9IHZhbHVlIEhlYWRlciB2YWx1ZVxuICogQHJldHVybiB7T2JqZWN0fSBjdXJyZW50IG5vZGVcbiAqL1xuTWltZU5vZGUucHJvdG90eXBlLnNldEhlYWRlciA9IGZ1bmN0aW9uIChrZXksIHZhbHVlKSB7XG4gICAgdmFyIGFkZGVkID0gZmFsc2UsXG4gICAgICAgIGhlYWRlclZhbHVlO1xuXG4gICAgLy8gQWxsb3cgc2V0dGluZyBtdWx0aXBsZSBoZWFkZXJzIGF0IG9uY2VcbiAgICBpZiAoIXZhbHVlICYmIGtleSAmJiB0eXBlb2Yga2V5ID09PSAnb2JqZWN0Jykge1xuICAgICAgICAvLyBhbGxvdyB7a2V5Oidjb250ZW50LXR5cGUnLCB2YWx1ZTogJ3RleHQvcGxhaW4nfVxuICAgICAgICBpZiAoa2V5LmtleSAmJiAndmFsdWUnIGluIGtleSkge1xuICAgICAgICAgICAgdGhpcy5zZXRIZWFkZXIoa2V5LmtleSwga2V5LnZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBhbGxvdyBbe2tleTonY29udGVudC10eXBlJywgdmFsdWU6ICd0ZXh0L3BsYWluJ31dXG4gICAgICAgIGVsc2UgaWYgKEFycmF5LmlzQXJyYXkoa2V5KSkge1xuICAgICAgICAgICAga2V5LmZvckVhY2goZnVuY3Rpb24gKGkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnNldEhlYWRlcihpLmtleSwgaS52YWx1ZSk7XG4gICAgICAgICAgICB9LmJpbmQodGhpcykpO1xuICAgICAgICB9XG4gICAgICAgIC8vIGFsbG93IHsnY29udGVudC10eXBlJzogJ3RleHQvcGxhaW4nfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIE9iamVjdC5rZXlzKGtleSkuZm9yRWFjaChmdW5jdGlvbiAoaSkge1xuICAgICAgICAgICAgICAgIHRoaXMuc2V0SGVhZGVyKGksIGtleVtpXSk7XG4gICAgICAgICAgICB9LmJpbmQodGhpcykpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIGtleSA9IHRoaXMuX25vcm1hbGl6ZUhlYWRlcktleShrZXkpO1xuXG4gICAgaGVhZGVyVmFsdWUgPSB7XG4gICAgICAgIGtleToga2V5LFxuICAgICAgICB2YWx1ZTogdmFsdWVcbiAgICB9O1xuXG4gICAgLy8gQ2hlY2sgaWYgdGhlIHZhbHVlIGV4aXN0cyBhbmQgb3ZlcndyaXRlXG4gICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IHRoaXMuX2hlYWRlcnMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgaWYgKHRoaXMuX2hlYWRlcnNbaV0ua2V5ID09PSBrZXkpIHtcbiAgICAgICAgICAgIGlmICghYWRkZWQpIHtcbiAgICAgICAgICAgICAgICAvLyByZXBsYWNlIHRoZSBmaXJzdCBtYXRjaFxuICAgICAgICAgICAgICAgIHRoaXMuX2hlYWRlcnNbaV0gPSBoZWFkZXJWYWx1ZTtcbiAgICAgICAgICAgICAgICBhZGRlZCA9IHRydWU7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIHJlbW92ZSBmb2xsb3dpbmcgbWF0Y2hlc1xuICAgICAgICAgICAgICAgIHRoaXMuX2hlYWRlcnMuc3BsaWNlKGksIDEpO1xuICAgICAgICAgICAgICAgIGktLTtcbiAgICAgICAgICAgICAgICBsZW4tLTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIG1hdGNoIG5vdCBmb3VuZCwgYXBwZW5kIHRoZSB2YWx1ZVxuICAgIGlmICghYWRkZWQpIHtcbiAgICAgICAgdGhpcy5faGVhZGVycy5wdXNoKGhlYWRlclZhbHVlKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogQWRkcyBhIGhlYWRlciB2YWx1ZS4gSWYgdGhlIHZhbHVlIGZvciBzZWxlY3RlZCBrZXkgZXhpc3RzLCB0aGUgdmFsdWUgaXMgYXBwZW5kZWRcbiAqIGFzIGEgbmV3IGZpZWxkIGFuZCBvbGQgb25lIGlzIG5vdCB0b3VjaGVkLlxuICogWW91IGNhbiBzZXQgbXVsdGlwbGUgdmFsdWVzIGFzIHdlbGwgYnkgdXNpbmcgW3trZXk6JycsIHZhbHVlOicnfV0gb3JcbiAqIHtrZXk6ICd2YWx1ZSd9IGFzIHRoZSBmaXJzdCBhcmd1bWVudC5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ3xBcnJheXxPYmplY3R9IGtleSBIZWFkZXIga2V5IG9yIGEgbGlzdCBvZiBrZXkgdmFsdWUgcGFpcnNcbiAqIEBwYXJhbSB7U3RyaW5nfSB2YWx1ZSBIZWFkZXIgdmFsdWVcbiAqIEByZXR1cm4ge09iamVjdH0gY3VycmVudCBub2RlXG4gKi9cbk1pbWVOb2RlLnByb3RvdHlwZS5hZGRIZWFkZXIgPSBmdW5jdGlvbiAoa2V5LCB2YWx1ZSkge1xuXG4gICAgLy8gQWxsb3cgc2V0dGluZyBtdWx0aXBsZSBoZWFkZXJzIGF0IG9uY2VcbiAgICBpZiAoIXZhbHVlICYmIGtleSAmJiB0eXBlb2Yga2V5ID09PSAnb2JqZWN0Jykge1xuICAgICAgICAvLyBhbGxvdyB7a2V5Oidjb250ZW50LXR5cGUnLCB2YWx1ZTogJ3RleHQvcGxhaW4nfVxuICAgICAgICBpZiAoa2V5LmtleSAmJiBrZXkudmFsdWUpIHtcbiAgICAgICAgICAgIHRoaXMuYWRkSGVhZGVyKGtleS5rZXksIGtleS52YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gYWxsb3cgW3trZXk6J2NvbnRlbnQtdHlwZScsIHZhbHVlOiAndGV4dC9wbGFpbid9XVxuICAgICAgICBlbHNlIGlmIChBcnJheS5pc0FycmF5KGtleSkpIHtcbiAgICAgICAgICAgIGtleS5mb3JFYWNoKGZ1bmN0aW9uIChpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5hZGRIZWFkZXIoaS5rZXksIGkudmFsdWUpO1xuICAgICAgICAgICAgfS5iaW5kKHRoaXMpKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBhbGxvdyB7J2NvbnRlbnQtdHlwZSc6ICd0ZXh0L3BsYWluJ31cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBPYmplY3Qua2V5cyhrZXkpLmZvckVhY2goZnVuY3Rpb24gKGkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmFkZEhlYWRlcihpLCBrZXlbaV0pO1xuICAgICAgICAgICAgfS5iaW5kKHRoaXMpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgIHZhbHVlLmZvckVhY2goZnVuY3Rpb24gKHZhbCkge1xuICAgICAgICAgICAgdGhpcy5hZGRIZWFkZXIoa2V5LCB2YWwpO1xuICAgICAgICB9LmJpbmQodGhpcykpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICB0aGlzLl9oZWFkZXJzLnB1c2goe1xuICAgICAgICBrZXk6IHRoaXMuX25vcm1hbGl6ZUhlYWRlcktleShrZXkpLFxuICAgICAgICB2YWx1ZTogdmFsdWVcbiAgICB9KTtcblxuICAgIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBSZXRyaWV2ZXMgdGhlIGZpcnN0IG1hdGhjaW5nIHZhbHVlIG9mIGEgc2VsZWN0ZWQga2V5XG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IGtleSBLZXkgdG8gc2VhcmNoIGZvclxuICogQHJldHVuIHtTdHJpbmd9IFZhbHVlIGZvciB0aGUga2V5XG4gKi9cbk1pbWVOb2RlLnByb3RvdHlwZS5nZXRIZWFkZXIgPSBmdW5jdGlvbiAoa2V5KSB7XG4gICAga2V5ID0gdGhpcy5fbm9ybWFsaXplSGVhZGVyS2V5KGtleSk7XG4gICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IHRoaXMuX2hlYWRlcnMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgaWYgKHRoaXMuX2hlYWRlcnNbaV0ua2V5ID09PSBrZXkpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9oZWFkZXJzW2ldLnZhbHVlO1xuICAgICAgICB9XG4gICAgfVxufTtcblxuLyoqXG4gKiBTZXRzIGJvZHkgY29udGVudCBmb3IgY3VycmVudCBub2RlLiBJZiB0aGUgdmFsdWUgaXMgYSBzdHJpbmcsIGNoYXJzZXQgaXMgYWRkZWQgYXV0b21hdGljYWxseVxuICogdG8gQ29udGVudC1UeXBlIChpZiBpdCBpcyB0ZXh0LyopLiBJZiB0aGUgdmFsdWUgaXMgYSBCdWZmZXIsIHlvdSBuZWVkIHRvIHNwZWNpZnlcbiAqIHRoZSBjaGFyc2V0IHlvdXJzZWxmXG4gKlxuICogQHBhcmFtIChTdHJpbmd8QnVmZmVyKSBjb250ZW50IEJvZHkgY29udGVudFxuICogQHJldHVybiB7T2JqZWN0fSBjdXJyZW50IG5vZGVcbiAqL1xuTWltZU5vZGUucHJvdG90eXBlLnNldENvbnRlbnQgPSBmdW5jdGlvbiAoY29udGVudCkge1xuICAgIHZhciBfc2VsZiA9IHRoaXM7XG4gICAgdGhpcy5jb250ZW50ID0gY29udGVudDtcbiAgICBpZiAodHlwZW9mIHRoaXMuY29udGVudC5waXBlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIC8vIHByZS1zdHJlYW0gaGFuZGxlci4gbWlnaHQgYmUgdHJpZ2dlcmVkIGlmIGEgc3RyZWFtIGlzIHNldCBhcyBjb250ZW50XG4gICAgICAgIC8vIGFuZCAnZXJyb3InIGZpcmVzIGJlZm9yZSBhbnl0aGluZyBpcyBkb25lIHdpdGggdGhpcyBzdHJlYW1cbiAgICAgICAgdGhpcy5fY29udGVudEVycm9ySGFuZGxlciA9IGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgICAgIF9zZWxmLmNvbnRlbnQucmVtb3ZlTGlzdGVuZXIoJ2Vycm9yJywgX3NlbGYuX2NvbnRlbnRFcnJvckhhbmRsZXIpO1xuICAgICAgICAgICAgX3NlbGYuY29udGVudCA9IGVycjtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5jb250ZW50Lm9uY2UoJ2Vycm9yJywgdGhpcy5fY29udGVudEVycm9ySGFuZGxlcik7XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgdGhpcy5jb250ZW50ID09PSAnc3RyaW5nJykge1xuICAgICAgICB0aGlzLl9pc1BsYWluVGV4dCA9IGxpYm1pbWUuaXNQbGFpblRleHQodGhpcy5jb250ZW50KTtcbiAgICAgICAgaWYgKHRoaXMuX2lzUGxhaW5UZXh0ICYmIGxpYm1pbWUuaGFzTG9uZ2VyTGluZXModGhpcy5jb250ZW50LCA3NikpIHtcbiAgICAgICAgICAgIC8vIElmIHRoZXJlIGFyZSBsaW5lcyBsb25nZXIgdGhhbiA3NiBzeW1ib2xzL2J5dGVzIGRvIG5vdCB1c2UgN2JpdFxuICAgICAgICAgICAgdGhpcy5faGFzTG9uZ0xpbmVzID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbn07XG5cbk1pbWVOb2RlLnByb3RvdHlwZS5idWlsZCA9IGZ1bmN0aW9uIChjYWxsYmFjaykge1xuICAgIHZhciBzdHJlYW0gPSB0aGlzLmNyZWF0ZVJlYWRTdHJlYW0oKTtcbiAgICB2YXIgYnVmID0gW107XG4gICAgdmFyIGJ1ZmxlbiA9IDA7XG4gICAgdmFyIHJldHVybmVkID0gZmFsc2U7XG5cbiAgICBzdHJlYW0ub24oJ3JlYWRhYmxlJywgZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgY2h1bms7XG5cbiAgICAgICAgd2hpbGUgKChjaHVuayA9IHN0cmVhbS5yZWFkKCkpICE9PSBudWxsKSB7XG4gICAgICAgICAgICBidWYucHVzaChjaHVuayk7XG4gICAgICAgICAgICBidWZsZW4gKz0gY2h1bmsubGVuZ3RoO1xuICAgICAgICB9XG4gICAgfSk7XG5cbiAgICBzdHJlYW0ub25jZSgnZXJyb3InLCBmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgIGlmIChyZXR1cm5lZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybmVkID0gdHJ1ZTtcblxuICAgICAgICByZXR1cm4gY2FsbGJhY2soZXJyKTtcbiAgICB9KTtcblxuICAgIHN0cmVhbS5vbmNlKCdlbmQnLCBmdW5jdGlvbiAoY2h1bmspIHtcbiAgICAgICAgaWYgKHJldHVybmVkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuZWQgPSB0cnVlO1xuXG4gICAgICAgIGlmIChjaHVuayAmJiBjaHVuay5sZW5ndGgpIHtcbiAgICAgICAgICAgIGJ1Zi5wdXNoKGNodW5rKTtcbiAgICAgICAgICAgIGJ1ZmxlbiArPSBjaHVuay5sZW5ndGg7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNhbGxiYWNrKG51bGwsIEJ1ZmZlci5jb25jYXQoYnVmLCBidWZsZW4pKTtcbiAgICB9KTtcbn07XG5cbk1pbWVOb2RlLnByb3RvdHlwZS5nZXRUcmFuc2ZlckVuY29kaW5nID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciB0cmFuc2ZlckVuY29kaW5nID0gZmFsc2U7XG4gICAgdmFyIGNvbnRlbnRUeXBlID0gKHRoaXMuZ2V0SGVhZGVyKCdDb250ZW50LVR5cGUnKSB8fCAnJykudG9TdHJpbmcoKS50b0xvd2VyQ2FzZSgpLnRyaW0oKTtcblxuICAgIGlmICh0aGlzLmNvbnRlbnQpIHtcbiAgICAgICAgdHJhbnNmZXJFbmNvZGluZyA9ICh0aGlzLmdldEhlYWRlcignQ29udGVudC1UcmFuc2Zlci1FbmNvZGluZycpIHx8ICcnKS50b1N0cmluZygpLnRvTG93ZXJDYXNlKCkudHJpbSgpO1xuICAgICAgICBpZiAoIXRyYW5zZmVyRW5jb2RpbmcgfHwgWydiYXNlNjQnLCAncXVvdGVkLXByaW50YWJsZSddLmluZGV4T2YodHJhbnNmZXJFbmNvZGluZykgPCAwKSB7XG4gICAgICAgICAgICBpZiAoL150ZXh0XFwvL2kudGVzdChjb250ZW50VHlwZSkpIHtcbiAgICAgICAgICAgICAgICAvLyBJZiB0aGVyZSBhcmUgbm8gc3BlY2lhbCBzeW1ib2xzLCBubyBuZWVkIHRvIG1vZGlmeSB0aGUgdGV4dFxuICAgICAgICAgICAgICAgIGlmICh0aGlzLl9pc1BsYWluVGV4dCAmJiAhdGhpcy5faGFzTG9uZ0xpbmVzKSB7XG4gICAgICAgICAgICAgICAgICAgIHRyYW5zZmVyRW5jb2RpbmcgPSAnN2JpdCc7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgdGhpcy5jb250ZW50ID09PSAnc3RyaW5nJyB8fCB0aGlzLmNvbnRlbnQgaW5zdGFuY2VvZiBCdWZmZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gZGV0ZWN0IHByZWZlcnJlZCBlbmNvZGluZyBmb3Igc3RyaW5nIHZhbHVlXG4gICAgICAgICAgICAgICAgICAgIHRyYW5zZmVyRW5jb2RpbmcgPSB0aGlzLl9nZXRUZXh0RW5jb2RpbmcodGhpcy5jb250ZW50KSA9PT0gJ1EnID8gJ3F1b3RlZC1wcmludGFibGUnIDogJ2Jhc2U2NCc7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gd2UgY2FuIG5vdCBjaGVjayBjb250ZW50IGZvciBhIHN0cmVhbSwgc28gZWl0aGVyIHVzZSBwcmVmZXJyZWQgZW5jb2Rpbmcgb3IgZmFsbGJhY2sgdG8gUVBcbiAgICAgICAgICAgICAgICAgICAgdHJhbnNmZXJFbmNvZGluZyA9IHRoaXMudHJhbnNmZXJFbmNvZGluZyA9PT0gJ0InID8gJ2Jhc2U2NCcgOiAncXVvdGVkLXByaW50YWJsZSc7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIGlmICghL14obXVsdGlwYXJ0fG1lc3NhZ2UpXFwvL2kudGVzdChjb250ZW50VHlwZSkpIHtcbiAgICAgICAgICAgICAgICB0cmFuc2ZlckVuY29kaW5nID0gdHJhbnNmZXJFbmNvZGluZyB8fCAnYmFzZTY0JztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdHJhbnNmZXJFbmNvZGluZztcbn07XG5cbi8qKlxuICogQnVpbGRzIHRoZSBoZWFkZXIgYmxvY2sgZm9yIHRoZSBtaW1lIG5vZGUuIEFwcGVuZCBcXHJcXG5cXHJcXG4gYmVmb3JlIHdyaXRpbmcgdGhlIGNvbnRlbnRcbiAqXG4gKiBAcmV0dXJucyB7U3RyaW5nfSBIZWFkZXJzXG4gKi9cbk1pbWVOb2RlLnByb3RvdHlwZS5idWlsZEhlYWRlcnMgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIF9zZWxmID0gdGhpcztcbiAgICB2YXIgdHJhbnNmZXJFbmNvZGluZyA9IHRoaXMuZ2V0VHJhbnNmZXJFbmNvZGluZygpO1xuICAgIHZhciBoZWFkZXJzID0gW107XG5cbiAgICBpZiAodHJhbnNmZXJFbmNvZGluZykge1xuICAgICAgICB0aGlzLnNldEhlYWRlcignQ29udGVudC1UcmFuc2Zlci1FbmNvZGluZycsIHRyYW5zZmVyRW5jb2RpbmcpO1xuICAgIH1cblxuICAgIGlmICh0aGlzLmZpbGVuYW1lICYmICF0aGlzLmdldEhlYWRlcignQ29udGVudC1EaXNwb3NpdGlvbicpKSB7XG4gICAgICAgIHRoaXMuc2V0SGVhZGVyKCdDb250ZW50LURpc3Bvc2l0aW9uJywgJ2F0dGFjaG1lbnQnKTtcbiAgICB9XG5cbiAgICAvLyBFbnN1cmUgbWFuZGF0b3J5IGhlYWRlciBmaWVsZHNcbiAgICBpZiAodGhpcy5yb290Tm9kZSA9PT0gdGhpcykge1xuICAgICAgICBpZiAoIXRoaXMuZ2V0SGVhZGVyKCdEYXRlJykpIHtcbiAgICAgICAgICAgIHRoaXMuc2V0SGVhZGVyKCdEYXRlJywgdGhpcy5kYXRlLnRvVVRDU3RyaW5nKCkucmVwbGFjZSgvR01ULywgJyswMDAwJykpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gZW5zdXJlIHRoYXQgTWVzc2FnZS1JZCBpcyBwcmVzZW50XG4gICAgICAgIHRoaXMubWVzc2FnZUlkKCk7XG5cbiAgICAgICAgaWYgKCF0aGlzLmdldEhlYWRlcignTUlNRS1WZXJzaW9uJykpIHtcbiAgICAgICAgICAgIHRoaXMuc2V0SGVhZGVyKCdNSU1FLVZlcnNpb24nLCAnMS4wJyk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICB0aGlzLl9oZWFkZXJzLmZvckVhY2goZnVuY3Rpb24gKGhlYWRlcikge1xuICAgICAgICB2YXIga2V5ID0gaGVhZGVyLmtleTtcbiAgICAgICAgdmFyIHZhbHVlID0gaGVhZGVyLnZhbHVlO1xuICAgICAgICB2YXIgc3RydWN0dXJlZDtcbiAgICAgICAgdmFyIHBhcmFtO1xuICAgICAgICB2YXIgb3B0aW9ucyA9IHt9O1xuICAgICAgICB2YXIgZm9ybWF0dGVkSGVhZGVycyA9IFsnRnJvbScsICdTZW5kZXInLCAnVG8nLCAnQ2MnLCAnQmNjJywgJ1JlcGx5LVRvJywgJ0RhdGUnLCAnUmVmZXJlbmNlcyddO1xuXG4gICAgICAgIGlmICh2YWx1ZSAmJiBmb3JtYXR0ZWRIZWFkZXJzLmluZGV4T2Yoa2V5KSA8IDAgJiYgdHlwZW9mIHZhbHVlID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgT2JqZWN0LmtleXModmFsdWUpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgICAgICAgICAgICAgIGlmIChrZXkgIT09ICd2YWx1ZScpIHtcbiAgICAgICAgICAgICAgICAgICAgb3B0aW9uc1trZXldID0gdmFsdWVba2V5XTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHZhbHVlID0gKHZhbHVlLnZhbHVlIHx8ICcnKS50b1N0cmluZygpO1xuICAgICAgICAgICAgaWYgKCF2YWx1ZS50cmltKCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAob3B0aW9ucy5wcmVwYXJlZCkge1xuICAgICAgICAgICAgLy8gaGVhZGVyIHZhbHVlIGlzXG4gICAgICAgICAgICBoZWFkZXJzLnB1c2goa2V5ICsgJzogJyArIHZhbHVlKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHN3aXRjaCAoaGVhZGVyLmtleSkge1xuICAgICAgICAgICAgY2FzZSAnQ29udGVudC1EaXNwb3NpdGlvbic6XG4gICAgICAgICAgICAgICAgc3RydWN0dXJlZCA9IGxpYm1pbWUucGFyc2VIZWFkZXJWYWx1ZSh2YWx1ZSk7XG4gICAgICAgICAgICAgICAgaWYgKF9zZWxmLmZpbGVuYW1lKSB7XG4gICAgICAgICAgICAgICAgICAgIHN0cnVjdHVyZWQucGFyYW1zLmZpbGVuYW1lID0gX3NlbGYuZmlsZW5hbWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHZhbHVlID0gbGlibWltZS5idWlsZEhlYWRlclZhbHVlKHN0cnVjdHVyZWQpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnQ29udGVudC1UeXBlJzpcbiAgICAgICAgICAgICAgICBzdHJ1Y3R1cmVkID0gbGlibWltZS5wYXJzZUhlYWRlclZhbHVlKHZhbHVlKTtcblxuICAgICAgICAgICAgICAgIF9zZWxmLl9oYW5kbGVDb250ZW50VHlwZShzdHJ1Y3R1cmVkKTtcblxuICAgICAgICAgICAgICAgIGlmIChzdHJ1Y3R1cmVkLnZhbHVlLm1hdGNoKC9edGV4dFxcL3BsYWluXFxiLykgJiYgdHlwZW9mIF9zZWxmLmNvbnRlbnQgPT09ICdzdHJpbmcnICYmIC9bXFx1MDA4MC1cXHVGRkZGXS8udGVzdChfc2VsZi5jb250ZW50KSkge1xuICAgICAgICAgICAgICAgICAgICBzdHJ1Y3R1cmVkLnBhcmFtcy5jaGFyc2V0ID0gJ3V0Zi04JztcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB2YWx1ZSA9IGxpYm1pbWUuYnVpbGRIZWFkZXJWYWx1ZShzdHJ1Y3R1cmVkKTtcblxuICAgICAgICAgICAgICAgIGlmIChfc2VsZi5maWxlbmFtZSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBhZGQgc3VwcG9ydCBmb3Igbm9uLWNvbXBsaWFudCBjbGllbnRzIGxpa2UgUVEgd2VibWFpbFxuICAgICAgICAgICAgICAgICAgICAvLyB3ZSBjYW4ndCBidWlsZCB0aGUgdmFsdWUgd2l0aCBidWlsZEhlYWRlclZhbHVlIGFzIHRoZSB2YWx1ZSBpcyBub24gc3RhbmRhcmQgYW5kXG4gICAgICAgICAgICAgICAgICAgIC8vIHdvdWxkIGJlIGNvbnZlcnRlZCB0byBwYXJhbWV0ZXIgY29udGludWF0aW9uIGVuY29kaW5nIHRoYXQgd2UgZG8gbm90IHdhbnRcbiAgICAgICAgICAgICAgICAgICAgcGFyYW0gPSB0aGlzLl9lbmNvZGVXb3Jkcyhfc2VsZi5maWxlbmFtZSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChwYXJhbSAhPT0gX3NlbGYuZmlsZW5hbWUgfHwgL1tcXHNcIj07XS8udGVzdChwYXJhbSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGluY2x1ZGUgdmFsdWUgaW4gcXVvdGVzIGlmIG5lZWRlZFxuICAgICAgICAgICAgICAgICAgICAgICAgcGFyYW0gPSAnXCInICsgcGFyYW0gKyAnXCInO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlICs9ICc7IG5hbWU9JyArIHBhcmFtO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ0JjYyc6XG4gICAgICAgICAgICAgICAgaWYgKCFfc2VsZi5rZWVwQmNjKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIHNraXAgQkNDIHZhbHVlc1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFsdWUgPSBfc2VsZi5fZW5jb2RlSGVhZGVyVmFsdWUoa2V5LCB2YWx1ZSk7XG5cbiAgICAgICAgLy8gc2tpcCBlbXB0eSBsaW5lc1xuICAgICAgICBpZiAoISh2YWx1ZSB8fCAnJykudG9TdHJpbmcoKS50cmltKCkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGhlYWRlcnMucHVzaChsaWJtaW1lLmZvbGRMaW5lcyhrZXkgKyAnOiAnICsgdmFsdWUsIDc2KSk7XG4gICAgfS5iaW5kKHRoaXMpKTtcblxuICAgIHJldHVybiBoZWFkZXJzLmpvaW4oJ1xcclxcbicpO1xufTtcblxuLyoqXG4gKiBTdHJlYW1zIHRoZSByZmMyODIyIG1lc3NhZ2UgZnJvbSB0aGUgY3VycmVudCBub2RlLiBJZiB0aGlzIGlzIGEgcm9vdCBub2RlLFxuICogbWFuZGF0b3J5IGhlYWRlciBmaWVsZHMgYXJlIHNldCBpZiBtaXNzaW5nIChEYXRlLCBNZXNzYWdlLUlkLCBNSU1FLVZlcnNpb24pXG4gKlxuICogQHJldHVybiB7U3RyaW5nfSBDb21waWxlZCBtZXNzYWdlXG4gKi9cbk1pbWVOb2RlLnByb3RvdHlwZS5jcmVhdGVSZWFkU3RyZWFtID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuICAgIHZhciBvdXRwdXRTdHJlYW0gPSBuZXcgUGFzc1Rocm91Z2gob3B0aW9ucyk7XG4gICAgdmFyIHRyYW5zZm9ybTtcblxuICAgIHRoaXMuc3RyZWFtKG91dHB1dFN0cmVhbSwgb3B0aW9ucywgZnVuY3Rpb24gKGVycikge1xuICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICBvdXRwdXRTdHJlYW0uZW1pdCgnZXJyb3InLCBlcnIpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIG91dHB1dFN0cmVhbS5lbmQoKTtcbiAgICB9KTtcblxuICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSB0aGlzLl90cmFuc2Zvcm1zLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgIHRyYW5zZm9ybSA9IHR5cGVvZiB0aGlzLl90cmFuc2Zvcm1zW2ldID09PSAnZnVuY3Rpb24nID8gdGhpcy5fdHJhbnNmb3Jtc1tpXSgpIDogdGhpcy5fdHJhbnNmb3Jtc1tpXTtcbiAgICAgICAgb3V0cHV0U3RyZWFtLm9uY2UoJ2Vycm9yJywgZnVuY3Rpb24gKGVycikge1xuICAgICAgICAgICAgdHJhbnNmb3JtLmVtaXQoJ2Vycm9yJywgZXJyKTtcbiAgICAgICAgfSk7XG4gICAgICAgIG91dHB1dFN0cmVhbSA9IG91dHB1dFN0cmVhbS5waXBlKHRyYW5zZm9ybSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIG91dHB1dFN0cmVhbTtcbn07XG5cbi8qKlxuICogQXBwZW5kcyBhIHRyYW5zZm9ybSBzdHJlYW0gb2JqZWN0IHRvIHRoZSB0cmFuc2Zvcm1zIGxpc3QuIEZpbmFsIG91dHB1dFxuICogaXMgcGFzc2VkIHRocm91Z2ggdGhpcyBzdHJlYW0gYmVmb3JlIGV4cG9zaW5nXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHRyYW5zZm9ybSBSZWFkLVdyaXRlIHN0cmVhbVxuICovXG5NaW1lTm9kZS5wcm90b3R5cGUudHJhbnNmb3JtID0gZnVuY3Rpb24gKHRyYW5zZm9ybSkge1xuICAgIHRoaXMuX3RyYW5zZm9ybXMucHVzaCh0cmFuc2Zvcm0pO1xufTtcblxuTWltZU5vZGUucHJvdG90eXBlLnN0cmVhbSA9IGZ1bmN0aW9uIChvdXRwdXRTdHJlYW0sIG9wdGlvbnMsIGRvbmUpIHtcbiAgICB2YXIgX3NlbGYgPSB0aGlzO1xuICAgIHZhciB0cmFuc2ZlckVuY29kaW5nID0gdGhpcy5nZXRUcmFuc2ZlckVuY29kaW5nKCk7XG4gICAgdmFyIGNvbnRlbnRTdHJlYW07XG4gICAgdmFyIGxvY2FsU3RyZWFtO1xuXG4gICAgLy8gcHJvdGVjdCBhY3R1YWwgY2FsbGJhY2sgYWdhaW5zdCBtdWx0aXBsZSB0cmlnZ2VyaW5nXG4gICAgdmFyIHJldHVybmVkID0gZmFsc2U7XG4gICAgdmFyIGNhbGxiYWNrID0gZnVuY3Rpb24gKGVycikge1xuICAgICAgICBpZiAocmV0dXJuZWQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm5lZCA9IHRydWU7XG4gICAgICAgIGRvbmUoZXJyKTtcbiAgICB9O1xuXG4gICAgLy8gcHVzaGVzIG5vZGUgY29udGVudFxuICAgIGZ1bmN0aW9uIHNlbmRDb250ZW50KCkge1xuICAgICAgICBpZiAoX3NlbGYuY29udGVudCkge1xuXG4gICAgICAgICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKF9zZWxmLmNvbnRlbnQpID09PSAnW29iamVjdCBFcnJvcl0nKSB7XG4gICAgICAgICAgICAgICAgLy8gY29udGVudCBpcyBhbHJlYWR5IGVycm9yZWRcbiAgICAgICAgICAgICAgICByZXR1cm4gY2FsbGJhY2soX3NlbGYuY29udGVudCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICh0eXBlb2YgX3NlbGYuY29udGVudC5waXBlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgX3NlbGYuY29udGVudC5yZW1vdmVMaXN0ZW5lcignZXJyb3InLCBfc2VsZi5fY29udGVudEVycm9ySGFuZGxlcik7XG4gICAgICAgICAgICAgICAgX3NlbGYuX2NvbnRlbnRFcnJvckhhbmRsZXIgPSBmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjYWxsYmFjayhlcnIpO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgX3NlbGYuY29udGVudC5vbmNlKCdlcnJvcicsIF9zZWxmLl9jb250ZW50RXJyb3JIYW5kbGVyKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKFsncXVvdGVkLXByaW50YWJsZScsICdiYXNlNjQnXS5pbmRleE9mKHRyYW5zZmVyRW5jb2RpbmcpID49IDApIHtcbiAgICAgICAgICAgICAgICBjb250ZW50U3RyZWFtID0gbmV3KHRyYW5zZmVyRW5jb2RpbmcgPT09ICdiYXNlNjQnID8gbGliYmFzZTY0IDogbGlicXApLkVuY29kZXIob3B0aW9ucyk7XG5cbiAgICAgICAgICAgICAgICBjb250ZW50U3RyZWFtLnBpcGUob3V0cHV0U3RyZWFtLCB7XG4gICAgICAgICAgICAgICAgICAgIGVuZDogZmFsc2VcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBjb250ZW50U3RyZWFtLm9uY2UoJ2VuZCcsIGZpbmFsaXplKTtcbiAgICAgICAgICAgICAgICBjb250ZW50U3RyZWFtLm9uY2UoJ2Vycm9yJywgZnVuY3Rpb24gKGVycikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gY2FsbGJhY2soZXJyKTtcbiAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgIGxvY2FsU3RyZWFtID0gX3NlbGYuX2dldFN0cmVhbShfc2VsZi5jb250ZW50KTtcbiAgICAgICAgICAgICAgICBsb2NhbFN0cmVhbS5waXBlKGNvbnRlbnRTdHJlYW0pO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBhbnl0aGluZyB0aGF0IGlzIG5vdCBRUCBvciBCYXNlNTQgcGFzc2VzIGFzLWlzXG4gICAgICAgICAgICAgICAgbG9jYWxTdHJlYW0gPSBfc2VsZi5fZ2V0U3RyZWFtKF9zZWxmLmNvbnRlbnQpO1xuICAgICAgICAgICAgICAgIGxvY2FsU3RyZWFtLnBpcGUob3V0cHV0U3RyZWFtLCB7XG4gICAgICAgICAgICAgICAgICAgIGVuZDogZmFsc2VcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBsb2NhbFN0cmVhbS5vbmNlKCdlbmQnLCBmaW5hbGl6ZSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGxvY2FsU3RyZWFtLm9uY2UoJ2Vycm9yJywgZnVuY3Rpb24gKGVycikge1xuICAgICAgICAgICAgICAgIHJldHVybiBjYWxsYmFjayhlcnIpO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBzZXRJbW1lZGlhdGUoZmluYWxpemUpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gZm9yIG11bHRpcGFydCBub2RlcywgcHVzaCBjaGlsZCBub2Rlc1xuICAgIC8vIGZvciBjb250ZW50IG5vZGVzIGVuZCB0aGUgc3RyZWFtXG4gICAgZnVuY3Rpb24gZmluYWxpemUoKSB7XG4gICAgICAgIHZhciBjaGlsZElkID0gMDtcbiAgICAgICAgdmFyIHByb2Nlc3NDaGlsZE5vZGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAoY2hpbGRJZCA+PSBfc2VsZi5jaGlsZE5vZGVzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIG91dHB1dFN0cmVhbS53cml0ZSgnXFxyXFxuLS0nICsgX3NlbGYuYm91bmRhcnkgKyAnLS1cXHJcXG4nKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gY2FsbGJhY2soKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBjaGlsZCA9IF9zZWxmLmNoaWxkTm9kZXNbY2hpbGRJZCsrXTtcbiAgICAgICAgICAgIG91dHB1dFN0cmVhbS53cml0ZSgoY2hpbGRJZCA+IDEgPyAnXFxyXFxuJyA6ICcnKSArICctLScgKyBfc2VsZi5ib3VuZGFyeSArICdcXHJcXG4nKTtcbiAgICAgICAgICAgIGNoaWxkLnN0cmVhbShvdXRwdXRTdHJlYW0sIG9wdGlvbnMsIGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjYWxsYmFjayhlcnIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBzZXRJbW1lZGlhdGUocHJvY2Vzc0NoaWxkTm9kZSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfTtcblxuICAgICAgICBpZiAoX3NlbGYubXVsdGlwYXJ0KSB7XG4gICAgICAgICAgICBzZXRJbW1lZGlhdGUocHJvY2Vzc0NoaWxkTm9kZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gY2FsbGJhY2soKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGlmICh0aGlzLl9yYXcpIHtcbiAgICAgICAgc2V0SW1tZWRpYXRlKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoX3NlbGYuX3JhdykgPT09ICdbb2JqZWN0IEVycm9yXScpIHtcbiAgICAgICAgICAgICAgICAvLyBjb250ZW50IGlzIGFscmVhZHkgZXJyb3JlZFxuICAgICAgICAgICAgICAgIHJldHVybiBjYWxsYmFjayhfc2VsZi5fcmF3KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gcmVtb3ZlIGRlZmF1bHQgZXJyb3IgaGFuZGxlciAoaWYgc2V0KVxuICAgICAgICAgICAgaWYgKHR5cGVvZiBfc2VsZi5fcmF3LnBpcGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICBfc2VsZi5fcmF3LnJlbW92ZUxpc3RlbmVyKCdlcnJvcicsIF9zZWxmLl9jb250ZW50RXJyb3JIYW5kbGVyKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIHJhdyA9IF9zZWxmLl9nZXRTdHJlYW0oX3NlbGYuX3Jhdyk7XG4gICAgICAgICAgICByYXcucGlwZShvdXRwdXRTdHJlYW0sIHtcbiAgICAgICAgICAgICAgICBlbmQ6IGZhbHNlXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJhdy5vbignZXJyb3InLCBmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgb3V0cHV0U3RyZWFtLmVtaXQoJ2Vycm9yJywgZXJyKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmF3Lm9uKCdlbmQnLCBmaW5hbGl6ZSk7XG4gICAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIG91dHB1dFN0cmVhbS53cml0ZSh0aGlzLmJ1aWxkSGVhZGVycygpICsgJ1xcclxcblxcclxcbicpO1xuICAgICAgICBzZXRJbW1lZGlhdGUoc2VuZENvbnRlbnQpO1xuICAgIH1cbn07XG5cbi8qKlxuICogU2V0cyBlbnZlbG9wZSB0byBiZSB1c2VkIGluc3RlYWQgb2YgdGhlIGdlbmVyYXRlZCBvbmVcbiAqXG4gKiBAcmV0dXJuIHtPYmplY3R9IFNNVFAgZW52ZWxvcGUgaW4gdGhlIGZvcm0gb2Yge2Zyb206ICdmcm9tQGV4YW1wbGUuY29tJywgdG86IFsndG9AZXhhbXBsZS5jb20nXX1cbiAqL1xuTWltZU5vZGUucHJvdG90eXBlLnNldEVudmVsb3BlID0gZnVuY3Rpb24gKGVudmVsb3BlKSB7XG4gICAgdmFyIGxpc3Q7XG5cbiAgICB0aGlzLl9lbnZlbG9wZSA9IHtcbiAgICAgICAgZnJvbTogZmFsc2UsXG4gICAgICAgIHRvOiBbXVxuICAgIH07XG5cbiAgICBpZiAoZW52ZWxvcGUuZnJvbSkge1xuICAgICAgICBsaXN0ID0gW107XG4gICAgICAgIHRoaXMuX2NvbnZlcnRBZGRyZXNzZXModGhpcy5fcGFyc2VBZGRyZXNzZXMoZW52ZWxvcGUuZnJvbSksIGxpc3QpO1xuICAgICAgICBsaXN0ID0gbGlzdC5maWx0ZXIoZnVuY3Rpb24gKGFkZHJlc3MpIHtcbiAgICAgICAgICAgIHJldHVybiBhZGRyZXNzICYmIGFkZHJlc3MuYWRkcmVzcztcbiAgICAgICAgfSk7XG4gICAgICAgIGlmIChsaXN0Lmxlbmd0aCAmJiBsaXN0WzBdKSB7XG4gICAgICAgICAgICB0aGlzLl9lbnZlbG9wZS5mcm9tID0gbGlzdFswXS5hZGRyZXNzO1xuICAgICAgICB9XG4gICAgfVxuICAgIFsndG8nLCAnY2MnLCAnYmNjJ10uZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgIGlmIChlbnZlbG9wZVtrZXldKSB7XG4gICAgICAgICAgICB0aGlzLl9jb252ZXJ0QWRkcmVzc2VzKHRoaXMuX3BhcnNlQWRkcmVzc2VzKGVudmVsb3BlW2tleV0pLCB0aGlzLl9lbnZlbG9wZS50byk7XG4gICAgICAgIH1cbiAgICB9LmJpbmQodGhpcykpO1xuXG4gICAgdGhpcy5fZW52ZWxvcGUudG8gPSB0aGlzLl9lbnZlbG9wZS50by5tYXAoZnVuY3Rpb24gKHRvKSB7XG4gICAgICAgIHJldHVybiB0by5hZGRyZXNzO1xuICAgIH0pLmZpbHRlcihmdW5jdGlvbiAoYWRkcmVzcykge1xuICAgICAgICByZXR1cm4gYWRkcmVzcztcbiAgICB9KTtcblxuICAgIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBHZW5lcmF0ZXMgYW5kIHJldHVybnMgYW4gb2JqZWN0IHdpdGggcGFyc2VkIGFkZHJlc3MgZmllbGRzXG4gKlxuICogQHJldHVybiB7T2JqZWN0fSBBZGRyZXNzIG9iamVjdFxuICovXG5NaW1lTm9kZS5wcm90b3R5cGUuZ2V0QWRkcmVzc2VzID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBhZGRyZXNzZXMgPSB7fTtcblxuICAgIHRoaXMuX2hlYWRlcnMuZm9yRWFjaChmdW5jdGlvbiAoaGVhZGVyKSB7XG4gICAgICAgIHZhciBrZXkgPSBoZWFkZXIua2V5LnRvTG93ZXJDYXNlKCk7XG4gICAgICAgIGlmIChbJ2Zyb20nLCAnc2VuZGVyJywgJ3JlcGx5LXRvJywgJ3RvJywgJ2NjJywgJ2JjYyddLmluZGV4T2Yoa2V5KSA+PSAwKSB7XG4gICAgICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkoYWRkcmVzc2VzW2tleV0pKSB7XG4gICAgICAgICAgICAgICAgYWRkcmVzc2VzW2tleV0gPSBbXTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGhpcy5fY29udmVydEFkZHJlc3Nlcyh0aGlzLl9wYXJzZUFkZHJlc3NlcyhoZWFkZXIudmFsdWUpLCBhZGRyZXNzZXNba2V5XSk7XG4gICAgICAgIH1cbiAgICB9LmJpbmQodGhpcykpO1xuXG4gICAgcmV0dXJuIGFkZHJlc3Nlcztcbn07XG5cbi8qKlxuICogR2VuZXJhdGVzIGFuZCByZXR1cm5zIFNNVFAgZW52ZWxvcGUgd2l0aCB0aGUgc2VuZGVyIGFkZHJlc3MgYW5kIGEgbGlzdCBvZiByZWNpcGllbnRzIGFkZHJlc3Nlc1xuICpcbiAqIEByZXR1cm4ge09iamVjdH0gU01UUCBlbnZlbG9wZSBpbiB0aGUgZm9ybSBvZiB7ZnJvbTogJ2Zyb21AZXhhbXBsZS5jb20nLCB0bzogWyd0b0BleGFtcGxlLmNvbSddfVxuICovXG5NaW1lTm9kZS5wcm90b3R5cGUuZ2V0RW52ZWxvcGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKHRoaXMuX2VudmVsb3BlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9lbnZlbG9wZTtcbiAgICB9XG5cbiAgICB2YXIgZW52ZWxvcGUgPSB7XG4gICAgICAgIGZyb206IGZhbHNlLFxuICAgICAgICB0bzogW11cbiAgICB9O1xuICAgIHRoaXMuX2hlYWRlcnMuZm9yRWFjaChmdW5jdGlvbiAoaGVhZGVyKSB7XG4gICAgICAgIHZhciBsaXN0ID0gW107XG4gICAgICAgIGlmIChoZWFkZXIua2V5ID09PSAnRnJvbScgfHwgKCFlbnZlbG9wZS5mcm9tICYmIFsnUmVwbHktVG8nLCAnU2VuZGVyJ10uaW5kZXhPZihoZWFkZXIua2V5KSA+PSAwKSkge1xuICAgICAgICAgICAgdGhpcy5fY29udmVydEFkZHJlc3Nlcyh0aGlzLl9wYXJzZUFkZHJlc3NlcyhoZWFkZXIudmFsdWUpLCBsaXN0KTtcbiAgICAgICAgICAgIGlmIChsaXN0Lmxlbmd0aCAmJiBsaXN0WzBdKSB7XG4gICAgICAgICAgICAgICAgZW52ZWxvcGUuZnJvbSA9IGxpc3RbMF0uYWRkcmVzcztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmIChbJ1RvJywgJ0NjJywgJ0JjYyddLmluZGV4T2YoaGVhZGVyLmtleSkgPj0gMCkge1xuICAgICAgICAgICAgdGhpcy5fY29udmVydEFkZHJlc3Nlcyh0aGlzLl9wYXJzZUFkZHJlc3NlcyhoZWFkZXIudmFsdWUpLCBlbnZlbG9wZS50byk7XG4gICAgICAgIH1cbiAgICB9LmJpbmQodGhpcykpO1xuXG4gICAgZW52ZWxvcGUudG8gPSBlbnZlbG9wZS50by5tYXAoZnVuY3Rpb24gKHRvKSB7XG4gICAgICAgIHJldHVybiB0by5hZGRyZXNzO1xuICAgIH0pO1xuXG4gICAgcmV0dXJuIGVudmVsb3BlO1xufTtcblxuLyoqXG4gKiBSZXR1cm5zIE1lc3NhZ2UtSWQgdmFsdWUuIElmIGl0IGRvZXMgbm90IGV4aXN0LCB0aGVuIGNyZWF0ZXMgb25lXG4gKlxuICogQHJldHVybiB7U3RyaW5nfSBNZXNzYWdlLUlkIHZhbHVlXG4gKi9cbk1pbWVOb2RlLnByb3RvdHlwZS5tZXNzYWdlSWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIG1lc3NhZ2VJZCA9IHRoaXMuZ2V0SGVhZGVyKCdNZXNzYWdlLUlkJyk7XG4gICAgLy8gWW91IHJlYWxseSBzaG91bGQgZGVmaW5lIHlvdXIgb3duIE1lc3NhZ2UtSWQgZmllbGQhXG4gICAgaWYgKCFtZXNzYWdlSWQpIHtcbiAgICAgICAgbWVzc2FnZUlkID0gJzwnICtcbiAgICAgICAgICAgIC8vIGNydXggdG8gZ2VuZXJhdGUgcmFuZG9tIHN0cmluZ3MgbGlrZSB0aGlzOlxuICAgICAgICAgICAgLy8gXCIxNDAxMzkxOTA1NTkwLTU4YWE4YzMyLWQzMmEwNjVjLWMxYTJhYWQyXCJcbiAgICAgICAgICAgIFswLCAwLCAwXS5yZWR1Y2UoZnVuY3Rpb24gKHByZXYpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcHJldiArICctJyArIE1hdGguZmxvb3IoKDEgKyBNYXRoLnJhbmRvbSgpKSAqIDB4MTAwMDAwMDAwKS5cbiAgICAgICAgICAgICAgICB0b1N0cmluZygxNikuXG4gICAgICAgICAgICAgICAgc3Vic3RyaW5nKDEpO1xuICAgICAgICAgICAgfSwgRGF0ZS5ub3coKSkgK1xuICAgICAgICAgICAgJ0AnICtcbiAgICAgICAgICAgIC8vIHRyeSB0byB1c2UgdGhlIGRvbWFpbiBvZiB0aGUgRlJPTSBhZGRyZXNzIG9yIGZhbGxiYWNrIGxvY2FsaG9zdFxuICAgICAgICAgICAgKHRoaXMuZ2V0RW52ZWxvcGUoKS5mcm9tIHx8ICdsb2NhbGhvc3QnKS5zcGxpdCgnQCcpLnBvcCgpICtcbiAgICAgICAgICAgICc+JztcbiAgICAgICAgdGhpcy5zZXRIZWFkZXIoJ01lc3NhZ2UtSWQnLCBtZXNzYWdlSWQpO1xuICAgIH1cblxuICAgIHJldHVybiBtZXNzYWdlSWQ7XG59O1xuXG4vKipcbiAqIFNldHMgcHJlZ2VuZXJhdGVkIGNvbnRlbnQgdGhhdCB3aWxsIGJlIHVzZWQgYXMgdGhlIG91dHB1dCBvZiB0aGlzIG5vZGVcbiAqXG4gKiBAcGFyYW0ge1N0cmluZ3xCdWZmZXJ8U3RyZWFtfSBSYXcgTUlNRSBjb250ZW50c1xuICovXG5NaW1lTm9kZS5wcm90b3R5cGUuc2V0UmF3ID0gZnVuY3Rpb24gKHJhdykge1xuICAgIHZhciBfc2VsZiA9IHRoaXM7XG5cbiAgICB0aGlzLl9yYXcgPSByYXc7XG5cbiAgICBpZiAodGhpcy5fcmF3ICYmIHR5cGVvZiB0aGlzLl9yYXcucGlwZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAvLyBwcmUtc3RyZWFtIGhhbmRsZXIuIG1pZ2h0IGJlIHRyaWdnZXJlZCBpZiBhIHN0cmVhbSBpcyBzZXQgYXMgY29udGVudFxuICAgICAgICAvLyBhbmQgJ2Vycm9yJyBmaXJlcyBiZWZvcmUgYW55dGhpbmcgaXMgZG9uZSB3aXRoIHRoaXMgc3RyZWFtXG4gICAgICAgIHRoaXMuX2NvbnRlbnRFcnJvckhhbmRsZXIgPSBmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgICAgICBfc2VsZi5fcmF3LnJlbW92ZUxpc3RlbmVyKCdlcnJvcicsIF9zZWxmLl9jb250ZW50RXJyb3JIYW5kbGVyKTtcbiAgICAgICAgICAgIF9zZWxmLl9yYXcgPSBlcnI7XG4gICAgICAgIH07XG4gICAgICAgIF9zZWxmLl9yYXcub25jZSgnZXJyb3InLCB0aGlzLl9jb250ZW50RXJyb3JIYW5kbGVyKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcztcbn07XG5cbi8vLy8vLy8gUFJJVkFURSBNRVRIT0RTXG5cbi8qKlxuICogRGV0ZWN0cyBhbmQgcmV0dXJucyBoYW5kbGUgdG8gYSBzdHJlYW0gcmVsYXRlZCB3aXRoIHRoZSBjb250ZW50LlxuICpcbiAqIEBwYXJhbSB7TWl4ZWR9IGNvbnRlbnQgTm9kZSBjb250ZW50XG4gKiBAcmV0dXJucyB7T2JqZWN0fSBTdHJlYW0gb2JqZWN0XG4gKi9cbk1pbWVOb2RlLnByb3RvdHlwZS5fZ2V0U3RyZWFtID0gZnVuY3Rpb24gKGNvbnRlbnQpIHtcbiAgICB2YXIgY29udGVudFN0cmVhbTtcblxuICAgIGlmICh0eXBlb2YgY29udGVudC5waXBlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIC8vIGFzc3VtZSBhcyBzdHJlYW1cbiAgICAgICAgcmV0dXJuIGNvbnRlbnQ7XG4gICAgfSBlbHNlIGlmIChjb250ZW50ICYmIHR5cGVvZiBjb250ZW50LnBhdGggPT09ICdzdHJpbmcnICYmICFjb250ZW50LmhyZWYpIHtcbiAgICAgICAgLy8gcmVhZCBmaWxlXG4gICAgICAgIHJldHVybiBmcy5jcmVhdGVSZWFkU3RyZWFtKGNvbnRlbnQucGF0aCk7XG4gICAgfSBlbHNlIGlmIChjb250ZW50ICYmIHR5cGVvZiBjb250ZW50LmhyZWYgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIC8vIGZldGNoIFVSTFxuICAgICAgICByZXR1cm4gZmV0Y2goY29udGVudC5ocmVmKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICAvLyBwYXNzIHN0cmluZyBvciBidWZmZXIgY29udGVudCBhcyBhIHN0cmVhbVxuICAgICAgICBjb250ZW50U3RyZWFtID0gbmV3IFBhc3NUaHJvdWdoKCk7XG4gICAgICAgIHNldEltbWVkaWF0ZShmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBjb250ZW50U3RyZWFtLmVuZChjb250ZW50IHx8ICcnKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBjb250ZW50U3RyZWFtO1xuICAgIH1cbn07XG5cbi8qKlxuICogUGFyc2VzIGFkZHJlc3Nlcy4gVGFrZXMgaW4gYSBzaW5nbGUgYWRkcmVzcyBvciBhbiBhcnJheSBvciBhblxuICogYXJyYXkgb2YgYWRkcmVzcyBhcnJheXMgKGVnLiBUbzogW1tmaXJzdCBncm91cF0sIFtzZWNvbmQgZ3JvdXBdLC4uLl0pXG4gKlxuICogQHBhcmFtIHtNaXhlZH0gYWRkcmVzc2VzIEFkZHJlc3NlcyB0byBiZSBwYXJzZWRcbiAqIEByZXR1cm4ge0FycmF5fSBBbiBhcnJheSBvZiBhZGRyZXNzIG9iamVjdHNcbiAqL1xuTWltZU5vZGUucHJvdG90eXBlLl9wYXJzZUFkZHJlc3NlcyA9IGZ1bmN0aW9uIChhZGRyZXNzZXMpIHtcbiAgICByZXR1cm4gW10uY29uY2F0LmFwcGx5KFtdLCBbXS5jb25jYXQoYWRkcmVzc2VzKS5tYXAoZnVuY3Rpb24gKGFkZHJlc3MpIHtcbiAgICAgICAgaWYgKGFkZHJlc3MgJiYgYWRkcmVzcy5hZGRyZXNzKSB7XG4gICAgICAgICAgICBhZGRyZXNzID0gdGhpcy5fY29udmVydEFkZHJlc3NlcyhhZGRyZXNzKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYWRkcmVzc3BhcnNlcihhZGRyZXNzKTtcbiAgICB9LmJpbmQodGhpcykpKTtcbn07XG5cbi8qKlxuICogTm9ybWFsaXplcyBhIGhlYWRlciBrZXksIHVzZXMgQ2FtZWwtQ2FzZSBmb3JtLCBleGNlcHQgZm9yIHVwcGVyY2FzZSBNSU1FLVxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBrZXkgS2V5IHRvIGJlIG5vcm1hbGl6ZWRcbiAqIEByZXR1cm4ge1N0cmluZ30ga2V5IGluIENhbWVsLUNhc2UgZm9ybVxuICovXG5NaW1lTm9kZS5wcm90b3R5cGUuX25vcm1hbGl6ZUhlYWRlcktleSA9IGZ1bmN0aW9uIChrZXkpIHtcbiAgICByZXR1cm4gKGtleSB8fCAnJykudG9TdHJpbmcoKS5cbiAgICAgICAgLy8gbm8gbmV3bGluZXMgaW4ga2V5c1xuICAgIHJlcGxhY2UoL1xccj9cXG58XFxyL2csICcgJykuXG4gICAgdHJpbSgpLnRvTG93ZXJDYXNlKCkuXG4gICAgICAgIC8vIHVzZSB1cHBlcmNhc2Ugd29yZHMsIGV4Y2VwdCBNSU1FXG4gICAgcmVwbGFjZSgvXk1JTUVcXGJ8XlthLXpdfFxcLVthLXpdL2lnLCBmdW5jdGlvbiAoYykge1xuICAgICAgICByZXR1cm4gYy50b1VwcGVyQ2FzZSgpO1xuICAgIH0pO1xufTtcblxuLyoqXG4gKiBDaGVja3MgaWYgdGhlIGNvbnRlbnQgdHlwZSBpcyBtdWx0aXBhcnQgYW5kIGRlZmluZXMgYm91bmRhcnkgaWYgbmVlZGVkLlxuICogRG9lc24ndCByZXR1cm4gYW55dGhpbmcsIG1vZGlmaWVzIG9iamVjdCBhcmd1bWVudCBpbnN0ZWFkLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBzdHJ1Y3R1cmVkIFBhcnNlZCBoZWFkZXIgdmFsdWUgZm9yICdDb250ZW50LVR5cGUnIGtleVxuICovXG5NaW1lTm9kZS5wcm90b3R5cGUuX2hhbmRsZUNvbnRlbnRUeXBlID0gZnVuY3Rpb24gKHN0cnVjdHVyZWQpIHtcbiAgICB0aGlzLmNvbnRlbnRUeXBlID0gc3RydWN0dXJlZC52YWx1ZS50cmltKCkudG9Mb3dlckNhc2UoKTtcblxuICAgIHRoaXMubXVsdGlwYXJ0ID0gdGhpcy5jb250ZW50VHlwZS5zcGxpdCgnLycpLnJlZHVjZShmdW5jdGlvbiAocHJldiwgdmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHByZXYgPT09ICdtdWx0aXBhcnQnID8gdmFsdWUgOiBmYWxzZTtcbiAgICB9KTtcblxuICAgIGlmICh0aGlzLm11bHRpcGFydCkge1xuICAgICAgICB0aGlzLmJvdW5kYXJ5ID0gc3RydWN0dXJlZC5wYXJhbXMuYm91bmRhcnkgPSBzdHJ1Y3R1cmVkLnBhcmFtcy5ib3VuZGFyeSB8fCB0aGlzLmJvdW5kYXJ5IHx8IHRoaXMuX2dlbmVyYXRlQm91bmRhcnkoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmJvdW5kYXJ5ID0gZmFsc2U7XG4gICAgfVxufTtcblxuLyoqXG4gKiBHZW5lcmF0ZXMgYSBtdWx0aXBhcnQgYm91bmRhcnkgdmFsdWVcbiAqXG4gKiBAcmV0dXJuIHtTdHJpbmd9IGJvdW5kYXJ5IHZhbHVlXG4gKi9cbk1pbWVOb2RlLnByb3RvdHlwZS5fZ2VuZXJhdGVCb3VuZGFyeSA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gJy0tLS1zaW5pa2FlbC0/PV8nICsgdGhpcy5fbm9kZUlkICsgJy0nICsgdGhpcy5yb290Tm9kZS5iYXNlQm91bmRhcnk7XG59O1xuXG4vKipcbiAqIEVuY29kZXMgYSBoZWFkZXIgdmFsdWUgZm9yIHVzZSBpbiB0aGUgZ2VuZXJhdGVkIHJmYzI4MjIgZW1haWwuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IGtleSBIZWFkZXIga2V5XG4gKiBAcGFyYW0ge1N0cmluZ30gdmFsdWUgSGVhZGVyIHZhbHVlXG4gKi9cbk1pbWVOb2RlLnByb3RvdHlwZS5fZW5jb2RlSGVhZGVyVmFsdWUgPSBmdW5jdGlvbiAoa2V5LCB2YWx1ZSkge1xuICAgIGtleSA9IHRoaXMuX25vcm1hbGl6ZUhlYWRlcktleShrZXkpO1xuXG4gICAgc3dpdGNoIChrZXkpIHtcblxuICAgICAgICAvLyBTdHJ1Y3R1cmVkIGhlYWRlcnNcbiAgICAgICAgY2FzZSAnRnJvbSc6XG4gICAgICAgIGNhc2UgJ1NlbmRlcic6XG4gICAgICAgIGNhc2UgJ1RvJzpcbiAgICAgICAgY2FzZSAnQ2MnOlxuICAgICAgICBjYXNlICdCY2MnOlxuICAgICAgICBjYXNlICdSZXBseS1Ubyc6XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fY29udmVydEFkZHJlc3Nlcyh0aGlzLl9wYXJzZUFkZHJlc3Nlcyh2YWx1ZSkpO1xuXG4gICAgICAgICAgICAvLyB2YWx1ZXMgZW5jbG9zZWQgaW4gPD5cbiAgICAgICAgY2FzZSAnTWVzc2FnZS1JZCc6XG4gICAgICAgIGNhc2UgJ0luLVJlcGx5LVRvJzpcbiAgICAgICAgY2FzZSAnQ29udGVudC1JZCc6XG4gICAgICAgICAgICB2YWx1ZSA9ICh2YWx1ZSB8fCAnJykudG9TdHJpbmcoKS5yZXBsYWNlKC9cXHI/XFxufFxcci9nLCAnICcpO1xuXG4gICAgICAgICAgICBpZiAodmFsdWUuY2hhckF0KDApICE9PSAnPCcpIHtcbiAgICAgICAgICAgICAgICB2YWx1ZSA9ICc8JyArIHZhbHVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAodmFsdWUuY2hhckF0KHZhbHVlLmxlbmd0aCAtIDEpICE9PSAnPicpIHtcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IHZhbHVlICsgJz4nO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuXG4gICAgICAgICAgICAvLyBzcGFjZSBzZXBhcmF0ZWQgbGlzdCBvZiB2YWx1ZXMgZW5jbG9zZWQgaW4gPD5cbiAgICAgICAgY2FzZSAnUmVmZXJlbmNlcyc6XG4gICAgICAgICAgICB2YWx1ZSA9IFtdLmNvbmNhdC5hcHBseShbXSwgW10uY29uY2F0KHZhbHVlIHx8ICcnKS5tYXAoZnVuY3Rpb24gKGVsbSkge1xuICAgICAgICAgICAgICAgIGVsbSA9IChlbG0gfHwgJycpLnRvU3RyaW5nKCkucmVwbGFjZSgvXFxyP1xcbnxcXHIvZywgJyAnKS50cmltKCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGVsbS5yZXBsYWNlKC88W14+XSo+L2csIGZ1bmN0aW9uIChzdHIpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHN0ci5yZXBsYWNlKC9cXHMvZywgJycpO1xuICAgICAgICAgICAgICAgIH0pLnNwbGl0KC9cXHMrLyk7XG4gICAgICAgICAgICB9KSkubWFwKGZ1bmN0aW9uIChlbG0pIHtcbiAgICAgICAgICAgICAgICBpZiAoZWxtLmNoYXJBdCgwKSAhPT0gJzwnKSB7XG4gICAgICAgICAgICAgICAgICAgIGVsbSA9ICc8JyArIGVsbTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGVsbS5jaGFyQXQoZWxtLmxlbmd0aCAtIDEpICE9PSAnPicpIHtcbiAgICAgICAgICAgICAgICAgICAgZWxtID0gZWxtICsgJz4nO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gZWxtO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIHJldHVybiB2YWx1ZS5qb2luKCcgJykudHJpbSgpO1xuXG4gICAgICAgIGNhc2UgJ0RhdGUnOlxuICAgICAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh2YWx1ZSkgPT09ICdbb2JqZWN0IERhdGVdJykge1xuICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZS50b1VUQ1N0cmluZygpLnJlcGxhY2UoL0dNVC8sICcrMDAwMCcpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YWx1ZSA9ICh2YWx1ZSB8fCAnJykudG9TdHJpbmcoKS5yZXBsYWNlKC9cXHI/XFxufFxcci9nLCAnICcpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2VuY29kZVdvcmRzKHZhbHVlKTtcblxuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgdmFsdWUgPSAodmFsdWUgfHwgJycpLnRvU3RyaW5nKCkucmVwbGFjZSgvXFxyP1xcbnxcXHIvZywgJyAnKTtcbiAgICAgICAgICAgIC8vIGVuY29kZVdvcmRzIG9ubHkgZW5jb2RlcyBpZiBuZWVkZWQsIG90aGVyd2lzZSB0aGUgb3JpZ2luYWwgc3RyaW5nIGlzIHJldHVybmVkXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fZW5jb2RlV29yZHModmFsdWUpO1xuICAgIH1cbn07XG5cbi8qKlxuICogUmVidWlsZHMgYWRkcmVzcyBvYmplY3QgdXNpbmcgcHVueWNvZGUgYW5kIG90aGVyIGFkanVzdG1lbnRzXG4gKlxuICogQHBhcmFtIHtBcnJheX0gYWRkcmVzc2VzIEFuIGFycmF5IG9mIGFkZHJlc3Mgb2JqZWN0c1xuICogQHBhcmFtIHtBcnJheX0gW3VuaXF1ZUxpc3RdIEFuIGFycmF5IHRvIGJlIHBvcHVsYXRlZCB3aXRoIGFkZHJlc3Nlc1xuICogQHJldHVybiB7U3RyaW5nfSBhZGRyZXNzIHN0cmluZ1xuICovXG5NaW1lTm9kZS5wcm90b3R5cGUuX2NvbnZlcnRBZGRyZXNzZXMgPSBmdW5jdGlvbiAoYWRkcmVzc2VzLCB1bmlxdWVMaXN0KSB7XG4gICAgdmFyIHZhbHVlcyA9IFtdO1xuXG4gICAgdW5pcXVlTGlzdCA9IHVuaXF1ZUxpc3QgfHwgW107XG5cbiAgICBbXS5jb25jYXQoYWRkcmVzc2VzIHx8IFtdKS5mb3JFYWNoKGZ1bmN0aW9uIChhZGRyZXNzKSB7XG4gICAgICAgIGlmIChhZGRyZXNzLmFkZHJlc3MpIHtcbiAgICAgICAgICAgIGFkZHJlc3MuYWRkcmVzcyA9IGFkZHJlc3MuYWRkcmVzcy5yZXBsYWNlKC9ALiskLywgZnVuY3Rpb24gKGRvbWFpbikge1xuICAgICAgICAgICAgICAgIC8vIHVzZXJuYW1lcyBhcmUgbm90IHRvdWNoZWQgYW5kIGFyZSBrZXB0IGFzIGlzIGV2ZW4gaWYgdGhlc2UgaW5jbHVkZSB1bmljb2RlXG4gICAgICAgICAgICAgICAgLy8gZG9tYWlucyBhcmUgcHVueWNvZGVkIGJ5IGRlZmF1bHRcbiAgICAgICAgICAgICAgICAvLyAnasO1Z2V2YS5lZScgd2lsbCBiZSBjb252ZXJ0ZWQgdG8gJ3huLS1qZ2V2YS1kdWEuZWUnXG4gICAgICAgICAgICAgICAgLy8gbm9uLXVuaWNvZGUgZG9tYWlucyBhcmUgbGVmdCBhcyBpc1xuICAgICAgICAgICAgICAgIHJldHVybiAnQCcgKyBwdW55Y29kZS50b0FTQ0lJKGRvbWFpbi5zdWJzdHIoMSkpO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIGlmICghYWRkcmVzcy5uYW1lKSB7XG4gICAgICAgICAgICAgICAgdmFsdWVzLnB1c2goYWRkcmVzcy5hZGRyZXNzKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoYWRkcmVzcy5uYW1lKSB7XG4gICAgICAgICAgICAgICAgdmFsdWVzLnB1c2godGhpcy5fZW5jb2RlQWRkcmVzc05hbWUoYWRkcmVzcy5uYW1lKSArICcgPCcgKyBhZGRyZXNzLmFkZHJlc3MgKyAnPicpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoYWRkcmVzcy5hZGRyZXNzKSB7XG4gICAgICAgICAgICAgICAgaWYgKCF1bmlxdWVMaXN0LmZpbHRlcihcbiAgICAgICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uIChhKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGEuYWRkcmVzcyA9PT0gYWRkcmVzcy5hZGRyZXNzO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSkubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIHVuaXF1ZUxpc3QucHVzaChhZGRyZXNzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAoYWRkcmVzcy5ncm91cCkge1xuICAgICAgICAgICAgdmFsdWVzLnB1c2godGhpcy5fZW5jb2RlQWRkcmVzc05hbWUoYWRkcmVzcy5uYW1lKSArICc6JyArIChhZGRyZXNzLmdyb3VwLmxlbmd0aCA/IHRoaXMuX2NvbnZlcnRBZGRyZXNzZXMoYWRkcmVzcy5ncm91cCwgdW5pcXVlTGlzdCkgOiAnJykudHJpbSgpICsgJzsnKTtcbiAgICAgICAgfVxuICAgIH0uYmluZCh0aGlzKSk7XG5cbiAgICByZXR1cm4gdmFsdWVzLmpvaW4oJywgJyk7XG59O1xuXG4vKipcbiAqIElmIG5lZWRlZCwgbWltZSBlbmNvZGVzIHRoZSBuYW1lIHBhcnRcbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gbmFtZSBOYW1lIHBhcnQgb2YgYW4gYWRkcmVzc1xuICogQHJldHVybnMge1N0cmluZ30gTWltZSB3b3JkIGVuY29kZWQgc3RyaW5nIGlmIG5lZWRlZFxuICovXG5NaW1lTm9kZS5wcm90b3R5cGUuX2VuY29kZUFkZHJlc3NOYW1lID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgICBpZiAoIS9eW1xcdyAnXSokLy50ZXN0KG5hbWUpKSB7XG4gICAgICAgIGlmICgvXltcXHgyMC1cXHg3ZV0qJC8udGVzdChuYW1lKSkge1xuICAgICAgICAgICAgcmV0dXJuICdcIicgKyBuYW1lLnJlcGxhY2UoLyhbXFxcXFwiXSkvZywgJ1xcXFwkMScpICsgJ1wiJztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBsaWJtaW1lLmVuY29kZVdvcmQobmFtZSwgdGhpcy5fZ2V0VGV4dEVuY29kaW5nKG5hbWUpLCA1Mik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG5hbWU7XG59O1xuXG4vKipcbiAqIElmIG5lZWRlZCwgbWltZSBlbmNvZGVzIHRoZSBuYW1lIHBhcnRcbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gbmFtZSBOYW1lIHBhcnQgb2YgYW4gYWRkcmVzc1xuICogQHJldHVybnMge1N0cmluZ30gTWltZSB3b3JkIGVuY29kZWQgc3RyaW5nIGlmIG5lZWRlZFxuICovXG5NaW1lTm9kZS5wcm90b3R5cGUuX2VuY29kZVdvcmRzID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgcmV0dXJuIGxpYm1pbWUuZW5jb2RlV29yZHModmFsdWUsIHRoaXMuX2dldFRleHRFbmNvZGluZyh2YWx1ZSksIDUyKTtcbn07XG5cbi8qKlxuICogRGV0ZWN0cyBiZXN0IG1pbWUgZW5jb2RpbmcgZm9yIGEgdGV4dCB2YWx1ZVxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSB2YWx1ZSBWYWx1ZSB0byBjaGVjayBmb3JcbiAqIEByZXR1cm4ge1N0cmluZ30gZWl0aGVyICdRJyBvciAnQidcbiAqL1xuTWltZU5vZGUucHJvdG90eXBlLl9nZXRUZXh0RW5jb2RpbmcgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICB2YWx1ZSA9ICh2YWx1ZSB8fCAnJykudG9TdHJpbmcoKTtcblxuICAgIHZhciBlbmNvZGluZyA9IHRoaXMudGV4dEVuY29kaW5nO1xuICAgIHZhciBsYXRpbkxlbjtcbiAgICB2YXIgbm9uTGF0aW5MZW47XG5cbiAgICBpZiAoIWVuY29kaW5nKSB7XG4gICAgICAgIC8vIGNvdW50IGxhdGluIGFscGhhYmV0IHN5bWJvbHMgYW5kIDgtYml0IHJhbmdlIHN5bWJvbHMgKyBjb250cm9sIHN5bWJvbHNcbiAgICAgICAgLy8gaWYgdGhlcmUgYXJlIG1vcmUgbGF0aW4gY2hhcmFjdGVycywgdGhlbiB1c2UgcXVvdGVkLXByaW50YWJsZVxuICAgICAgICAvLyBlbmNvZGluZywgb3RoZXJ3aXNlIHVzZSBiYXNlNjRcbiAgICAgICAgbm9uTGF0aW5MZW4gPSAodmFsdWUubWF0Y2goL1tcXHgwMC1cXHgwOFxceDBCXFx4MENcXHgwRS1cXHgxRlxcdTAwODAtXFx1RkZGRl0vZykgfHwgW10pLmxlbmd0aDtcbiAgICAgICAgbGF0aW5MZW4gPSAodmFsdWUubWF0Y2goL1thLXpdL2dpKSB8fCBbXSkubGVuZ3RoO1xuICAgICAgICAvLyBpZiB0aGVyZSBhcmUgbW9yZSBsYXRpbiBzeW1ib2xzIHRoYW4gYmluYXJ5L3VuaWNvZGUsIHRoZW4gcHJlZmVyIFEsIG90aGVyd2lzZSBCXG4gICAgICAgIGVuY29kaW5nID0gbm9uTGF0aW5MZW4gPCBsYXRpbkxlbiA/ICdRJyA6ICdCJztcbiAgICB9XG4gICAgcmV0dXJuIGVuY29kaW5nO1xufTtcblxufSkuY2FsbCh0aGlzLHJlcXVpcmUoXCJidWZmZXJcIikuQnVmZmVyKSIsIihmdW5jdGlvbiAoQnVmZmVyKXtcbnZhciBjcnlwdG8gPSByZXF1aXJlKCdjcnlwdG8nKTtcblxudmFyIGZsYWdzID0ge1xuXHROVExNX05lZ290aWF0ZVVuaWNvZGUgICAgICAgICAgICAgICAgOiAgMHgwMDAwMDAwMSxcblx0TlRMTV9OZWdvdGlhdGVPRU0gICAgICAgICAgICAgICAgICAgIDogIDB4MDAwMDAwMDIsXG5cdE5UTE1fUmVxdWVzdFRhcmdldCAgICAgICAgICAgICAgICAgICA6ICAweDAwMDAwMDA0LFxuXHROVExNX1Vua25vd245ICAgICAgICAgICAgICAgICAgICAgICAgOiAgMHgwMDAwMDAwOCxcblx0TlRMTV9OZWdvdGlhdGVTaWduICAgICAgICAgICAgICAgICAgIDogIDB4MDAwMDAwMTAsXG5cdE5UTE1fTmVnb3RpYXRlU2VhbCAgICAgICAgICAgICAgICAgICA6ICAweDAwMDAwMDIwLFxuXHROVExNX05lZ290aWF0ZURhdGFncmFtICAgICAgICAgICAgICAgOiAgMHgwMDAwMDA0MCxcblx0TlRMTV9OZWdvdGlhdGVMYW5NYW5hZ2VyS2V5ICAgICAgICAgIDogIDB4MDAwMDAwODAsXG5cdE5UTE1fVW5rbm93bjggICAgICAgICAgICAgICAgICAgICAgICA6ICAweDAwMDAwMTAwLFxuXHROVExNX05lZ290aWF0ZU5UTE0gICAgICAgICAgICAgICAgICAgOiAgMHgwMDAwMDIwMCxcblx0TlRMTV9OZWdvdGlhdGVOVE9ubHkgICAgICAgICAgICAgICAgIDogIDB4MDAwMDA0MDAsXG5cdE5UTE1fQW5vbnltb3VzICAgICAgICAgICAgICAgICAgICAgICA6ICAweDAwMDAwODAwLFxuXHROVExNX05lZ290aWF0ZU9lbURvbWFpblN1cHBsaWVkICAgICAgOiAgMHgwMDAwMTAwMCxcblx0TlRMTV9OZWdvdGlhdGVPZW1Xb3Jrc3RhdGlvblN1cHBsaWVkIDogIDB4MDAwMDIwMDAsXG5cdE5UTE1fVW5rbm93bjYgICAgICAgICAgICAgICAgICAgICAgICA6ICAweDAwMDA0MDAwLFxuXHROVExNX05lZ290aWF0ZUFsd2F5c1NpZ24gICAgICAgICAgICAgOiAgMHgwMDAwODAwMCxcblx0TlRMTV9UYXJnZXRUeXBlRG9tYWluICAgICAgICAgICAgICAgIDogIDB4MDAwMTAwMDAsXG5cdE5UTE1fVGFyZ2V0VHlwZVNlcnZlciAgICAgICAgICAgICAgICA6ICAweDAwMDIwMDAwLFxuXHROVExNX1RhcmdldFR5cGVTaGFyZSAgICAgICAgICAgICAgICAgOiAgMHgwMDA0MDAwMCxcblx0TlRMTV9OZWdvdGlhdGVFeHRlbmRlZFNlY3VyaXR5ICAgICAgIDogIDB4MDAwODAwMDAsXG5cdE5UTE1fTmVnb3RpYXRlSWRlbnRpZnkgICAgICAgICAgICAgICA6ICAweDAwMTAwMDAwLFxuXHROVExNX1Vua25vd241ICAgICAgICAgICAgICAgICAgICAgICAgOiAgMHgwMDIwMDAwMCxcblx0TlRMTV9SZXF1ZXN0Tm9uTlRTZXNzaW9uS2V5ICAgICAgICAgIDogIDB4MDA0MDAwMDAsXG5cdE5UTE1fTmVnb3RpYXRlVGFyZ2V0SW5mbyAgICAgICAgICAgICA6ICAweDAwODAwMDAwLFxuXHROVExNX1Vua25vd240ICAgICAgICAgICAgICAgICAgICAgICAgOiAgMHgwMTAwMDAwMCxcblx0TlRMTV9OZWdvdGlhdGVWZXJzaW9uICAgICAgICAgICAgICAgIDogIDB4MDIwMDAwMDAsXG5cdE5UTE1fVW5rbm93bjMgICAgICAgICAgICAgICAgICAgICAgICA6ICAweDA0MDAwMDAwLFxuXHROVExNX1Vua25vd24yICAgICAgICAgICAgICAgICAgICAgICAgOiAgMHgwODAwMDAwMCxcblx0TlRMTV9Vbmtub3duMSAgICAgICAgICAgICAgICAgICAgICAgIDogIDB4MTAwMDAwMDAsXG5cdE5UTE1fTmVnb3RpYXRlMTI4ICAgICAgICAgICAgICAgICAgICA6ICAweDIwMDAwMDAwLFxuXHROVExNX05lZ290aWF0ZUtleUV4Y2hhbmdlICAgICAgICAgICAgOiAgMHg0MDAwMDAwMCxcblx0TlRMTV9OZWdvdGlhdGU1NiAgICAgICAgICAgICAgICAgICAgIDogIDB4ODAwMDAwMDBcbn07XG52YXIgdHlwZWZsYWdzID0ge1xuXHROVExNX1RZUEUxX0ZMQUdTIDogXHQgIGZsYWdzLk5UTE1fTmVnb3RpYXRlVW5pY29kZVxuXHRcdFx0XHRcdFx0KyBmbGFncy5OVExNX05lZ290aWF0ZU9FTVxuXHRcdFx0XHRcdFx0KyBmbGFncy5OVExNX1JlcXVlc3RUYXJnZXRcblx0XHRcdFx0XHRcdCsgZmxhZ3MuTlRMTV9OZWdvdGlhdGVOVExNXG5cdFx0XHRcdFx0XHQrIGZsYWdzLk5UTE1fTmVnb3RpYXRlT2VtRG9tYWluU3VwcGxpZWRcblx0XHRcdFx0XHRcdCsgZmxhZ3MuTlRMTV9OZWdvdGlhdGVPZW1Xb3Jrc3RhdGlvblN1cHBsaWVkXG5cdFx0XHRcdFx0XHQrIGZsYWdzLk5UTE1fTmVnb3RpYXRlQWx3YXlzU2lnblxuXHRcdFx0XHRcdFx0KyBmbGFncy5OVExNX05lZ290aWF0ZUV4dGVuZGVkU2VjdXJpdHlcblx0XHRcdFx0XHRcdCsgZmxhZ3MuTlRMTV9OZWdvdGlhdGVWZXJzaW9uXG5cdFx0XHRcdFx0XHQrIGZsYWdzLk5UTE1fTmVnb3RpYXRlMTI4XG5cdFx0XHRcdFx0XHQrIGZsYWdzLk5UTE1fTmVnb3RpYXRlNTYsXG5cblx0TlRMTV9UWVBFMl9GTEFHUyA6ICAgIGZsYWdzLk5UTE1fTmVnb3RpYXRlVW5pY29kZVxuXHRcdFx0XHRcdFx0KyBmbGFncy5OVExNX1JlcXVlc3RUYXJnZXRcblx0XHRcdFx0XHRcdCsgZmxhZ3MuTlRMTV9OZWdvdGlhdGVOVExNXG5cdFx0XHRcdFx0XHQrIGZsYWdzLk5UTE1fTmVnb3RpYXRlQWx3YXlzU2lnblxuXHRcdFx0XHRcdFx0KyBmbGFncy5OVExNX05lZ290aWF0ZUV4dGVuZGVkU2VjdXJpdHlcblx0XHRcdFx0XHRcdCsgZmxhZ3MuTlRMTV9OZWdvdGlhdGVUYXJnZXRJbmZvXG5cdFx0XHRcdFx0XHQrIGZsYWdzLk5UTE1fTmVnb3RpYXRlVmVyc2lvblxuXHRcdFx0XHRcdFx0KyBmbGFncy5OVExNX05lZ290aWF0ZTEyOFxuXHRcdFx0XHRcdFx0KyBmbGFncy5OVExNX05lZ290aWF0ZTU2XG59O1xuXG5mdW5jdGlvbiBjcmVhdGVUeXBlMU1lc3NhZ2Uob3B0aW9ucyl7XG5cdHZhciBkb21haW4gPSBlc2NhcGUob3B0aW9ucy5kb21haW4udG9VcHBlckNhc2UoKSk7XG5cdHZhciB3b3Jrc3RhdGlvbiA9IGVzY2FwZShvcHRpb25zLndvcmtzdGF0aW9uLnRvVXBwZXJDYXNlKCkpO1xuXHR2YXIgcHJvdG9jb2wgPSAnTlRMTVNTUFxcMCc7XG5cblx0dmFyIEJPRFlfTEVOR1RIID0gNDA7XG5cblx0dmFyIHR5cGUxZmxhZ3MgPSB0eXBlZmxhZ3MuTlRMTV9UWVBFMV9GTEFHUztcblx0aWYoIWRvbWFpbiB8fCBkb21haW4gPT09ICcnKVxuXHRcdHR5cGUxZmxhZ3MgPSB0eXBlMWZsYWdzIC0gZmxhZ3MuTlRMTV9OZWdvdGlhdGVPZW1Eb21haW5TdXBwbGllZDtcblxuXHR2YXIgcG9zID0gMDtcblx0dmFyIGJ1ZiA9IG5ldyBCdWZmZXIoQk9EWV9MRU5HVEggKyBkb21haW4ubGVuZ3RoICsgd29ya3N0YXRpb24ubGVuZ3RoKTtcblxuXG5cdGJ1Zi53cml0ZShwcm90b2NvbCwgcG9zLCBwcm90b2NvbC5sZW5ndGgpOyBwb3MgKz0gcHJvdG9jb2wubGVuZ3RoOyAvLyBwcm90b2NvbFxuXHRidWYud3JpdGVVSW50MzJMRSgxLCBwb3MpOyBwb3MgKz0gNDsgICAgICAgICAgLy8gdHlwZSAxXG5cdGJ1Zi53cml0ZVVJbnQzMkxFKHR5cGUxZmxhZ3MsIHBvcyk7IHBvcyArPSA0OyAvLyBUWVBFMSBmbGFnXG5cblx0YnVmLndyaXRlVUludDE2TEUoZG9tYWluLmxlbmd0aCwgcG9zKTsgcG9zICs9IDI7IC8vIGRvbWFpbiBsZW5ndGhcblx0YnVmLndyaXRlVUludDE2TEUoZG9tYWluLmxlbmd0aCwgcG9zKTsgcG9zICs9IDI7IC8vIGRvbWFpbiBtYXggbGVuZ3RoXG5cdGJ1Zi53cml0ZVVJbnQzMkxFKEJPRFlfTEVOR1RIICsgd29ya3N0YXRpb24ubGVuZ3RoLCBwb3MpOyBwb3MgKz0gNDsgLy8gZG9tYWluIGJ1ZmZlciBvZmZzZXRcblxuXHRidWYud3JpdGVVSW50MTZMRSh3b3Jrc3RhdGlvbi5sZW5ndGgsIHBvcyk7IHBvcyArPSAyOyAvLyB3b3Jrc3RhdGlvbiBsZW5ndGhcblx0YnVmLndyaXRlVUludDE2TEUod29ya3N0YXRpb24ubGVuZ3RoLCBwb3MpOyBwb3MgKz0gMjsgLy8gd29ya3N0YXRpb24gbWF4IGxlbmd0aFxuXHRidWYud3JpdGVVSW50MzJMRShCT0RZX0xFTkdUSCwgcG9zKTsgcG9zICs9IDQ7IC8vIHdvcmtzdGF0aW9uIGJ1ZmZlciBvZmZzZXRcblxuXHRidWYud3JpdGVVSW50OCg1LCBwb3MpOyBwb3MgKz0gMTsgICAgICAvL1Byb2R1Y3RNYWpvclZlcnNpb25cblx0YnVmLndyaXRlVUludDgoMSwgcG9zKTsgcG9zICs9IDE7ICAgICAgLy9Qcm9kdWN0TWlub3JWZXJzaW9uXG5cdGJ1Zi53cml0ZVVJbnQxNkxFKDI2MDAsIHBvcyk7IHBvcyArPSAyOyAvL1Byb2R1Y3RCdWlsZFxuXG5cdGJ1Zi53cml0ZVVJbnQ4KDAgLCBwb3MpOyBwb3MgKz0gMTsgLy9WZXJzaW9uUmVzZXJ2ZWQxXG5cdGJ1Zi53cml0ZVVJbnQ4KDAgLCBwb3MpOyBwb3MgKz0gMTsgLy9WZXJzaW9uUmVzZXJ2ZWQyXG5cdGJ1Zi53cml0ZVVJbnQ4KDAgLCBwb3MpOyBwb3MgKz0gMTsgLy9WZXJzaW9uUmVzZXJ2ZWQzXG5cdGJ1Zi53cml0ZVVJbnQ4KDE1LCBwb3MpOyBwb3MgKz0gMTsgLy9OVExNUmV2aXNpb25DdXJyZW50XG5cblx0YnVmLndyaXRlKHdvcmtzdGF0aW9uLCBwb3MsIHdvcmtzdGF0aW9uLmxlbmd0aCwgJ2FzY2lpJyk7IHBvcyArPSB3b3Jrc3RhdGlvbi5sZW5ndGg7IC8vIHdvcmtzdGF0aW9uIHN0cmluZ1xuXHRidWYud3JpdGUoZG9tYWluICAgICAsIHBvcywgZG9tYWluLmxlbmd0aCAgICAgLCAnYXNjaWknKTsgcG9zICs9IGRvbWFpbi5sZW5ndGg7XG5cblx0cmV0dXJuICdOVExNICcgKyBidWYudG9TdHJpbmcoJ2Jhc2U2NCcpO1xufVxuXG5mdW5jdGlvbiBwYXJzZVR5cGUyTWVzc2FnZShyYXdtc2csIGNhbGxiYWNrKXtcblx0dmFyIG1hdGNoID0gcmF3bXNnLm1hdGNoKC9OVExNICguKyk/Lyk7XG5cdGlmKCFtYXRjaCB8fCAhbWF0Y2hbMV0pXG5cdFx0cmV0dXJuIGNhbGxiYWNrKG5ldyBFcnJvcihcIkNvdWxkbid0IGZpbmQgTlRMTSBpbiB0aGUgbWVzc2FnZSB0eXBlMiBjb21taW5nIGZyb20gdGhlIHNlcnZlclwiKSk7XG5cblx0dmFyIGJ1ZiA9IG5ldyBCdWZmZXIobWF0Y2hbMV0sICdiYXNlNjQnKTtcblxuXHR2YXIgbXNnID0ge307XG5cblx0bXNnLnNpZ25hdHVyZSA9IGJ1Zi5zbGljZSgwLCA4KTtcblx0bXNnLnR5cGUgPSBidWYucmVhZEludDE2TEUoOCk7XG5cblx0aWYobXNnLnR5cGUgIT0gMilcblx0XHRyZXR1cm4gY2FsbGJhY2sobmV3IEVycm9yKFwiU2VydmVyIGRpZG4ndCByZXR1cm4gYSB0eXBlIDIgbWVzc2FnZVwiKSk7XG5cblx0bXNnLnRhcmdldE5hbWVMZW4gPSBidWYucmVhZEludDE2TEUoMTIpO1xuXHRtc2cudGFyZ2V0TmFtZU1heExlbiA9IGJ1Zi5yZWFkSW50MTZMRSgxNCk7XG5cdG1zZy50YXJnZXROYW1lT2Zmc2V0ID0gYnVmLnJlYWRJbnQzMkxFKDE2KTtcblx0bXNnLnRhcmdldE5hbWUgID0gYnVmLnNsaWNlKG1zZy50YXJnZXROYW1lT2Zmc2V0LCBtc2cudGFyZ2V0TmFtZU9mZnNldCArIG1zZy50YXJnZXROYW1lTWF4TGVuKTtcblxuICAgIG1zZy5uZWdvdGlhdGVGbGFncyA9IGJ1Zi5yZWFkSW50MzJMRSgyMCk7XG4gICAgbXNnLnNlcnZlckNoYWxsZW5nZSA9IGJ1Zi5zbGljZSgyNCwgMzIpO1xuICAgIG1zZy5yZXNlcnZlZCA9IGJ1Zi5zbGljZSgzMiwgNDApO1xuXG4gICAgaWYobXNnLm5lZ290aWF0ZUZsYWdzICYgZmxhZ3MuTlRMTV9OZWdvdGlhdGVUYXJnZXRJbmZvKXtcbiAgICBcdG1zZy50YXJnZXRJbmZvTGVuID0gYnVmLnJlYWRJbnQxNkxFKDQwKTtcbiAgICBcdG1zZy50YXJnZXRJbmZvTWF4TGVuID0gYnVmLnJlYWRJbnQxNkxFKDQyKTtcbiAgICBcdG1zZy50YXJnZXRJbmZvT2Zmc2V0ID0gYnVmLnJlYWRJbnQzMkxFKDQ0KTtcbiAgICBcdG1zZy50YXJnZXRJbmZvID0gYnVmLnNsaWNlKG1zZy50YXJnZXRJbmZvT2Zmc2V0LCBtc2cudGFyZ2V0SW5mb09mZnNldCArIG1zZy50YXJnZXRJbmZvTGVuKTtcbiAgICB9XG5cdHJldHVybiBtc2c7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZVR5cGUzTWVzc2FnZShtc2cyLCBvcHRpb25zKXtcblx0dmFyIG5vbmNlID0gbXNnMi5zZXJ2ZXJDaGFsbGVuZ2U7XG5cdHZhciB1c2VybmFtZSA9IG9wdGlvbnMudXNlcm5hbWU7XG5cdHZhciBwYXNzd29yZCA9IG9wdGlvbnMucGFzc3dvcmQ7XG5cdHZhciBuZWdvdGlhdGVGbGFncyA9IG1zZzIubmVnb3RpYXRlRmxhZ3M7XG5cblx0dmFyIGlzVW5pY29kZSA9IG5lZ290aWF0ZUZsYWdzICYgZmxhZ3MuTlRMTV9OZWdvdGlhdGVVbmljb2RlO1xuXHR2YXIgaXNOZWdvdGlhdGVFeHRlbmRlZFNlY3VyaXR5ID0gbmVnb3RpYXRlRmxhZ3MgJiBmbGFncy5OVExNX05lZ290aWF0ZUV4dGVuZGVkU2VjdXJpdHk7XG5cblx0dmFyIEJPRFlfTEVOR1RIID0gNzI7XG5cblx0dmFyIGRvbWFpbk5hbWUgPSBlc2NhcGUob3B0aW9ucy5kb21haW4udG9VcHBlckNhc2UoKSk7XG5cdHZhciB3b3Jrc3RhdGlvbiA9IGVzY2FwZShvcHRpb25zLndvcmtzdGF0aW9uLnRvVXBwZXJDYXNlKCkpO1xuXG5cdHZhciB3b3Jrc3RhdGlvbkJ5dGVzLCBkb21haW5OYW1lQnl0ZXMsIHVzZXJuYW1lQnl0ZXMsIGVuY3J5cHRlZFJhbmRvbVNlc3Npb25LZXlCeXRlcztcblxuXHR2YXIgZW5jcnlwdGVkUmFuZG9tU2Vzc2lvbktleSA9IFwiXCI7XG5cdGlmKGlzVW5pY29kZSl7XG5cdFx0d29ya3N0YXRpb25CeXRlcyA9IG5ldyBCdWZmZXIod29ya3N0YXRpb24sICd1dGYxNmxlJyk7XG5cdFx0ZG9tYWluTmFtZUJ5dGVzID0gbmV3IEJ1ZmZlcihkb21haW5OYW1lLCAndXRmMTZsZScpO1xuXHRcdHVzZXJuYW1lQnl0ZXMgPSBuZXcgQnVmZmVyKHVzZXJuYW1lLCAndXRmMTZsZScpO1xuXHRcdGVuY3J5cHRlZFJhbmRvbVNlc3Npb25LZXlCeXRlcyA9IG5ldyBCdWZmZXIoZW5jcnlwdGVkUmFuZG9tU2Vzc2lvbktleSwgJ3V0ZjE2bGUnKTtcblx0fWVsc2V7XG5cdFx0d29ya3N0YXRpb25CeXRlcyA9IG5ldyBCdWZmZXIod29ya3N0YXRpb24sICdhc2NpaScpO1xuXHRcdGRvbWFpbk5hbWVCeXRlcyA9IG5ldyBCdWZmZXIoZG9tYWluTmFtZSwgJ2FzY2lpJyk7XG5cdFx0dXNlcm5hbWVCeXRlcyA9IG5ldyBCdWZmZXIodXNlcm5hbWUsICdhc2NpaScpO1xuXHRcdGVuY3J5cHRlZFJhbmRvbVNlc3Npb25LZXlCeXRlcyA9IG5ldyBCdWZmZXIoZW5jcnlwdGVkUmFuZG9tU2Vzc2lvbktleSwgJ2FzY2lpJyk7XG5cdH1cblxuXHR2YXIgbG1DaGFsbGVuZ2VSZXNwb25zZSA9IGNhbGNfcmVzcChjcmVhdGVfTE1faGFzaGVkX3Bhc3N3b3JkX3YxKHBhc3N3b3JkKSwgbm9uY2UpO1xuXHR2YXIgbnRDaGFsbGVuZ2VSZXNwb25zZSA9IGNhbGNfcmVzcChjcmVhdGVfTlRfaGFzaGVkX3Bhc3N3b3JkX3YxKHBhc3N3b3JkKSwgbm9uY2UpO1xuXG5cdGlmKGlzTmVnb3RpYXRlRXh0ZW5kZWRTZWN1cml0eSl7XG5cdFx0dmFyIHB3aGFzaCA9IGNyZWF0ZV9OVF9oYXNoZWRfcGFzc3dvcmRfdjEocGFzc3dvcmQpO1xuXHQgXHR2YXIgY2xpZW50Q2hhbGxlbmdlID0gXCJcIjtcblx0IFx0Zm9yKHZhciBpPTA7IGkgPCA4OyBpKyspe1xuXHQgXHRcdGNsaWVudENoYWxsZW5nZSArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKCBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkqMjU2KSApO1xuXHQgICBcdH1cblx0ICAgXHR2YXIgY2xpZW50Q2hhbGxlbmdlQnl0ZXMgPSBuZXcgQnVmZmVyKGNsaWVudENoYWxsZW5nZSwgJ2FzY2lpJyk7XG5cdCAgICB2YXIgY2hhbGxlbmdlcyA9IG50bG0yc3JfY2FsY19yZXNwKHB3aGFzaCwgbm9uY2UsIGNsaWVudENoYWxsZW5nZUJ5dGVzKTtcblx0ICAgIGxtQ2hhbGxlbmdlUmVzcG9uc2UgPSBjaGFsbGVuZ2VzLmxtQ2hhbGxlbmdlUmVzcG9uc2U7XG5cdCAgICBudENoYWxsZW5nZVJlc3BvbnNlID0gY2hhbGxlbmdlcy5udENoYWxsZW5nZVJlc3BvbnNlO1xuXHR9XG5cblx0dmFyIHNpZ25hdHVyZSA9ICdOVExNU1NQXFwwJztcblxuXHR2YXIgcG9zID0gMDtcblx0dmFyIGJ1ZiA9IG5ldyBCdWZmZXIoQk9EWV9MRU5HVEggKyBkb21haW5OYW1lQnl0ZXMubGVuZ3RoICsgdXNlcm5hbWVCeXRlcy5sZW5ndGggKyB3b3Jrc3RhdGlvbkJ5dGVzLmxlbmd0aCArIGxtQ2hhbGxlbmdlUmVzcG9uc2UubGVuZ3RoICsgbnRDaGFsbGVuZ2VSZXNwb25zZS5sZW5ndGggKyBlbmNyeXB0ZWRSYW5kb21TZXNzaW9uS2V5Qnl0ZXMubGVuZ3RoKTtcblxuXHRidWYud3JpdGUoc2lnbmF0dXJlLCBwb3MsIHNpZ25hdHVyZS5sZW5ndGgpOyBwb3MgKz0gc2lnbmF0dXJlLmxlbmd0aDtcblx0YnVmLndyaXRlVUludDMyTEUoMywgcG9zKTsgcG9zICs9IDQ7ICAgICAgICAgIC8vIHR5cGUgMVxuXG5cdGJ1Zi53cml0ZVVJbnQxNkxFKGxtQ2hhbGxlbmdlUmVzcG9uc2UubGVuZ3RoLCBwb3MpOyBwb3MgKz0gMjsgLy8gTG1DaGFsbGVuZ2VSZXNwb25zZUxlblxuXHRidWYud3JpdGVVSW50MTZMRShsbUNoYWxsZW5nZVJlc3BvbnNlLmxlbmd0aCwgcG9zKTsgcG9zICs9IDI7IC8vIExtQ2hhbGxlbmdlUmVzcG9uc2VNYXhMZW5cblx0YnVmLndyaXRlVUludDMyTEUoQk9EWV9MRU5HVEggKyBkb21haW5OYW1lQnl0ZXMubGVuZ3RoICsgdXNlcm5hbWVCeXRlcy5sZW5ndGggKyB3b3Jrc3RhdGlvbkJ5dGVzLmxlbmd0aCwgcG9zKTsgcG9zICs9IDQ7IC8vIExtQ2hhbGxlbmdlUmVzcG9uc2VPZmZzZXRcblxuXHRidWYud3JpdGVVSW50MTZMRShudENoYWxsZW5nZVJlc3BvbnNlLmxlbmd0aCwgcG9zKTsgcG9zICs9IDI7IC8vIE50Q2hhbGxlbmdlUmVzcG9uc2VMZW5cblx0YnVmLndyaXRlVUludDE2TEUobnRDaGFsbGVuZ2VSZXNwb25zZS5sZW5ndGgsIHBvcyk7IHBvcyArPSAyOyAvLyBOdENoYWxsZW5nZVJlc3BvbnNlTWF4TGVuXG5cdGJ1Zi53cml0ZVVJbnQzMkxFKEJPRFlfTEVOR1RIICsgZG9tYWluTmFtZUJ5dGVzLmxlbmd0aCArIHVzZXJuYW1lQnl0ZXMubGVuZ3RoICsgd29ya3N0YXRpb25CeXRlcy5sZW5ndGggKyBsbUNoYWxsZW5nZVJlc3BvbnNlLmxlbmd0aCwgcG9zKTsgcG9zICs9IDQ7IC8vIE50Q2hhbGxlbmdlUmVzcG9uc2VPZmZzZXRcblxuXHRidWYud3JpdGVVSW50MTZMRShkb21haW5OYW1lQnl0ZXMubGVuZ3RoLCBwb3MpOyBwb3MgKz0gMjsgLy8gRG9tYWluTmFtZUxlblxuXHRidWYud3JpdGVVSW50MTZMRShkb21haW5OYW1lQnl0ZXMubGVuZ3RoLCBwb3MpOyBwb3MgKz0gMjsgLy8gRG9tYWluTmFtZU1heExlblxuXHRidWYud3JpdGVVSW50MzJMRShCT0RZX0xFTkdUSCwgcG9zKTsgcG9zICs9IDQ7IFx0XHRcdCAgLy8gRG9tYWluTmFtZU9mZnNldFxuXG5cdGJ1Zi53cml0ZVVJbnQxNkxFKHVzZXJuYW1lQnl0ZXMubGVuZ3RoLCBwb3MpOyBwb3MgKz0gMjsgLy8gVXNlck5hbWVMZW5cblx0YnVmLndyaXRlVUludDE2TEUodXNlcm5hbWVCeXRlcy5sZW5ndGgsIHBvcyk7IHBvcyArPSAyOyAvLyBVc2VyTmFtZU1heExlblxuXHRidWYud3JpdGVVSW50MzJMRShCT0RZX0xFTkdUSCArIGRvbWFpbk5hbWVCeXRlcy5sZW5ndGgsIHBvcyk7IHBvcyArPSA0OyAvLyBVc2VyTmFtZU9mZnNldFxuXG5cdGJ1Zi53cml0ZVVJbnQxNkxFKHdvcmtzdGF0aW9uQnl0ZXMubGVuZ3RoLCBwb3MpOyBwb3MgKz0gMjsgLy8gV29ya3N0YXRpb25MZW5cblx0YnVmLndyaXRlVUludDE2TEUod29ya3N0YXRpb25CeXRlcy5sZW5ndGgsIHBvcyk7IHBvcyArPSAyOyAvLyBXb3Jrc3RhdGlvbk1heExlblxuXHRidWYud3JpdGVVSW50MzJMRShCT0RZX0xFTkdUSCArIGRvbWFpbk5hbWVCeXRlcy5sZW5ndGggKyB1c2VybmFtZUJ5dGVzLmxlbmd0aCwgcG9zKTsgcG9zICs9IDQ7IC8vIFdvcmtzdGF0aW9uT2Zmc2V0XG5cblx0YnVmLndyaXRlVUludDE2TEUoZW5jcnlwdGVkUmFuZG9tU2Vzc2lvbktleUJ5dGVzLmxlbmd0aCwgcG9zKTsgcG9zICs9IDI7IC8vIEVuY3J5cHRlZFJhbmRvbVNlc3Npb25LZXlMZW5cblx0YnVmLndyaXRlVUludDE2TEUoZW5jcnlwdGVkUmFuZG9tU2Vzc2lvbktleUJ5dGVzLmxlbmd0aCwgcG9zKTsgcG9zICs9IDI7IC8vIEVuY3J5cHRlZFJhbmRvbVNlc3Npb25LZXlNYXhMZW5cblx0YnVmLndyaXRlVUludDMyTEUoQk9EWV9MRU5HVEggKyBkb21haW5OYW1lQnl0ZXMubGVuZ3RoICsgdXNlcm5hbWVCeXRlcy5sZW5ndGggKyB3b3Jrc3RhdGlvbkJ5dGVzLmxlbmd0aCArIGxtQ2hhbGxlbmdlUmVzcG9uc2UubGVuZ3RoICsgbnRDaGFsbGVuZ2VSZXNwb25zZS5sZW5ndGgsIHBvcyk7IHBvcyArPSA0OyAvLyBFbmNyeXB0ZWRSYW5kb21TZXNzaW9uS2V5T2Zmc2V0XG5cblx0YnVmLndyaXRlVUludDMyTEUodHlwZWZsYWdzLk5UTE1fVFlQRTJfRkxBR1MsIHBvcyk7IHBvcyArPSA0OyAvLyBOZWdvdGlhdGVGbGFnc1xuXG5cdGJ1Zi53cml0ZVVJbnQ4KDUsIHBvcyk7IHBvcysrOyAvLyBQcm9kdWN0TWFqb3JWZXJzaW9uXG5cdGJ1Zi53cml0ZVVJbnQ4KDEsIHBvcyk7IHBvcysrOyAvLyBQcm9kdWN0TWlub3JWZXJzaW9uXG5cdGJ1Zi53cml0ZVVJbnQxNkxFKDI2MDAsIHBvcyk7IHBvcyArPSAyOyAvLyBQcm9kdWN0QnVpbGRcblx0YnVmLndyaXRlVUludDgoMCwgcG9zKTsgcG9zKys7IC8vIFZlcnNpb25SZXNlcnZlZDFcblx0YnVmLndyaXRlVUludDgoMCwgcG9zKTsgcG9zKys7IC8vIFZlcnNpb25SZXNlcnZlZDJcblx0YnVmLndyaXRlVUludDgoMCwgcG9zKTsgcG9zKys7IC8vIFZlcnNpb25SZXNlcnZlZDNcblx0YnVmLndyaXRlVUludDgoMTUsIHBvcyk7IHBvcysrOyAvLyBOVExNUmV2aXNpb25DdXJyZW50XG5cblx0ZG9tYWluTmFtZUJ5dGVzLmNvcHkoYnVmLCBwb3MpOyBwb3MgKz0gZG9tYWluTmFtZUJ5dGVzLmxlbmd0aDtcblx0dXNlcm5hbWVCeXRlcy5jb3B5KGJ1ZiwgcG9zKTsgcG9zICs9IHVzZXJuYW1lQnl0ZXMubGVuZ3RoO1xuXHR3b3Jrc3RhdGlvbkJ5dGVzLmNvcHkoYnVmLCBwb3MpOyBwb3MgKz0gd29ya3N0YXRpb25CeXRlcy5sZW5ndGg7XG5cdGxtQ2hhbGxlbmdlUmVzcG9uc2UuY29weShidWYsIHBvcyk7IHBvcyArPSBsbUNoYWxsZW5nZVJlc3BvbnNlLmxlbmd0aDtcblx0bnRDaGFsbGVuZ2VSZXNwb25zZS5jb3B5KGJ1ZiwgcG9zKTsgcG9zICs9IG50Q2hhbGxlbmdlUmVzcG9uc2UubGVuZ3RoO1xuXHRlbmNyeXB0ZWRSYW5kb21TZXNzaW9uS2V5Qnl0ZXMuY29weShidWYsIHBvcyk7IHBvcyArPSBlbmNyeXB0ZWRSYW5kb21TZXNzaW9uS2V5Qnl0ZXMubGVuZ3RoO1xuXG5cdHJldHVybiAnTlRMTSAnICsgYnVmLnRvU3RyaW5nKCdiYXNlNjQnKTtcbn1cblxuZnVuY3Rpb24gY3JlYXRlX0xNX2hhc2hlZF9wYXNzd29yZF92MShwYXNzd29yZCl7XG5cdC8vIGZpeCB0aGUgcGFzc3dvcmQgbGVuZ3RoIHRvIDE0IGJ5dGVzXG5cdHBhc3N3b3JkID0gcGFzc3dvcmQudG9VcHBlckNhc2UoKTtcblx0dmFyIHBhc3N3b3JkQnl0ZXMgPSBuZXcgQnVmZmVyKHBhc3N3b3JkLCAnYXNjaWknKTtcblxuXHR2YXIgcGFzc3dvcmRCeXRlc1BhZGRlZCA9IG5ldyBCdWZmZXIoMTQpO1xuXHRwYXNzd29yZEJ5dGVzUGFkZGVkLmZpbGwoXCJcXDBcIik7XG5cdHZhciBzb3VyY2VFbmQgPSAxNDtcblx0aWYocGFzc3dvcmRCeXRlcy5sZW5ndGggPCAxNCkgc291cmNlRW5kID0gcGFzc3dvcmRCeXRlcy5sZW5ndGg7XG5cdHBhc3N3b3JkQnl0ZXMuY29weShwYXNzd29yZEJ5dGVzUGFkZGVkLCAwLCAwLCBzb3VyY2VFbmQpO1xuXG5cdC8vIHNwbGl0IGludG8gMiBwYXJ0cyBvZiA3IGJ5dGVzOlxuXHR2YXIgZmlyc3RQYXJ0ID0gcGFzc3dvcmRCeXRlc1BhZGRlZC5zbGljZSgwLDcpO1xuXHR2YXIgc2Vjb25kUGFydCA9IHBhc3N3b3JkQnl0ZXNQYWRkZWQuc2xpY2UoNyk7XG5cblx0ZnVuY3Rpb24gZW5jcnlwdChidWYpe1xuXHRcdHZhciBrZXkgPSBpbnNlcnRaZXJvc0V2ZXJ5N0JpdHMoYnVmKTtcblx0XHR2YXIgZGVzID0gY3J5cHRvLmNyZWF0ZUNpcGhlcml2KCdERVMtRUNCJywga2V5LCAnJyk7XG5cdFx0cmV0dXJuIGRlcy51cGRhdGUoXCJLR1MhQCMkJVwiKTsgLy8gcGFnZSA1NyBpbiBbTVMtTkxNUF0pO1xuXHR9XG5cblx0dmFyIGZpcnN0UGFydEVuY3J5cHRlZCA9IGVuY3J5cHQoZmlyc3RQYXJ0KTtcblx0dmFyIHNlY29uZFBhcnRFbmNyeXB0ZWQgPSBlbmNyeXB0KHNlY29uZFBhcnQpO1xuXG5cdHJldHVybiBCdWZmZXIuY29uY2F0KFtmaXJzdFBhcnRFbmNyeXB0ZWQsIHNlY29uZFBhcnRFbmNyeXB0ZWRdKTtcbn1cblxuZnVuY3Rpb24gaW5zZXJ0WmVyb3NFdmVyeTdCaXRzKGJ1Zil7XG5cdHZhciBiaW5hcnlBcnJheSA9IGJ5dGVzMmJpbmFyeUFycmF5KGJ1Zik7XG5cdHZhciBuZXdCaW5hcnlBcnJheSA9IFtdO1xuXHRmb3IodmFyIGk9MDsgaTxiaW5hcnlBcnJheS5sZW5ndGg7IGkrKyl7XG5cdFx0bmV3QmluYXJ5QXJyYXkucHVzaChiaW5hcnlBcnJheVtpXSk7XG5cblx0XHRpZigoaSsxKSU3ID09PSAwKXtcblx0XHRcdG5ld0JpbmFyeUFycmF5LnB1c2goMCk7XG5cdFx0fVxuXHR9XG5cdHJldHVybiBiaW5hcnlBcnJheTJieXRlcyhuZXdCaW5hcnlBcnJheSk7XG59XG5cbmZ1bmN0aW9uIGJ5dGVzMmJpbmFyeUFycmF5KGJ1Zil7XG5cdHZhciBoZXgyYmluYXJ5ID0ge1xuXHRcdDA6IFswLDAsMCwwXSxcblx0XHQxOiBbMCwwLDAsMV0sXG5cdFx0MjogWzAsMCwxLDBdLFxuXHRcdDM6IFswLDAsMSwxXSxcblx0XHQ0OiBbMCwxLDAsMF0sXG5cdFx0NTogWzAsMSwwLDFdLFxuXHRcdDY6IFswLDEsMSwwXSxcblx0XHQ3OiBbMCwxLDEsMV0sXG5cdFx0ODogWzEsMCwwLDBdLFxuXHRcdDk6IFsxLDAsMCwxXSxcblx0XHRBOiBbMSwwLDEsMF0sXG5cdFx0QjogWzEsMCwxLDFdLFxuXHRcdEM6IFsxLDEsMCwwXSxcblx0XHREOiBbMSwxLDAsMV0sXG5cdFx0RTogWzEsMSwxLDBdLFxuXHRcdEY6IFsxLDEsMSwxXVxuXHR9O1xuXG5cdHZhciBoZXhTdHJpbmcgPSBidWYudG9TdHJpbmcoJ2hleCcpLnRvVXBwZXJDYXNlKCk7XG5cdHZhciBhcnJheSA9IFtdO1xuXHRmb3IodmFyIGk9MDsgaTxoZXhTdHJpbmcubGVuZ3RoOyBpKyspe1xuICAgXHRcdHZhciBoZXhjaGFyID0gaGV4U3RyaW5nLmNoYXJBdChpKTtcbiAgIFx0XHRhcnJheSA9IGFycmF5LmNvbmNhdChoZXgyYmluYXJ5W2hleGNoYXJdKTtcbiAgIFx0fVxuICAgXHRyZXR1cm4gYXJyYXk7XG59XG5cbmZ1bmN0aW9uIGJpbmFyeUFycmF5MmJ5dGVzKGFycmF5KXtcblx0dmFyIGJpbmFyeTJoZXggPSB7XG5cdFx0JzAwMDAnOiAwLFxuXHRcdCcwMDAxJzogMSxcblx0XHQnMDAxMCc6IDIsXG5cdFx0JzAwMTEnOiAzLFxuXHRcdCcwMTAwJzogNCxcblx0XHQnMDEwMSc6IDUsXG5cdFx0JzAxMTAnOiA2LFxuXHRcdCcwMTExJzogNyxcblx0XHQnMTAwMCc6IDgsXG5cdFx0JzEwMDEnOiA5LFxuXHRcdCcxMDEwJzogJ0EnLFxuXHRcdCcxMDExJzogJ0InLFxuXHRcdCcxMTAwJzogJ0MnLFxuXHRcdCcxMTAxJzogJ0QnLFxuXHRcdCcxMTEwJzogJ0UnLFxuXHRcdCcxMTExJzogJ0YnXG5cdH07XG5cbiBcdHZhciBidWZBcnJheSA9IFtdO1xuXG5cdGZvcih2YXIgaT0wOyBpPGFycmF5Lmxlbmd0aDsgaSArPTggKXtcblx0XHRpZigoaSs3KSA+IGFycmF5Lmxlbmd0aClcblx0XHRcdGJyZWFrO1xuXG5cdFx0dmFyIGJpblN0cmluZzEgPSAnJyArIGFycmF5W2ldICsgJycgKyBhcnJheVtpKzFdICsgJycgKyBhcnJheVtpKzJdICsgJycgKyBhcnJheVtpKzNdO1xuXHRcdHZhciBiaW5TdHJpbmcyID0gJycgKyBhcnJheVtpKzRdICsgJycgKyBhcnJheVtpKzVdICsgJycgKyBhcnJheVtpKzZdICsgJycgKyBhcnJheVtpKzddO1xuICAgXHRcdHZhciBoZXhjaGFyMSA9IGJpbmFyeTJoZXhbYmluU3RyaW5nMV07XG4gICBcdFx0dmFyIGhleGNoYXIyID0gYmluYXJ5MmhleFtiaW5TdHJpbmcyXTtcblxuICAgXHRcdHZhciBidWYgPSBuZXcgQnVmZmVyKGhleGNoYXIxICsgJycgKyBoZXhjaGFyMiwgJ2hleCcpO1xuICAgXHRcdGJ1ZkFycmF5LnB1c2goYnVmKTtcbiAgIFx0fVxuXG4gICBcdHJldHVybiBCdWZmZXIuY29uY2F0KGJ1ZkFycmF5KTtcbn1cblxuZnVuY3Rpb24gY3JlYXRlX05UX2hhc2hlZF9wYXNzd29yZF92MShwYXNzd29yZCl7XG5cdHZhciBidWYgPSBuZXcgQnVmZmVyKHBhc3N3b3JkLCAndXRmMTZsZScpO1xuXHR2YXIgbWQ0ID0gY3J5cHRvLmNyZWF0ZUhhc2goJ21kNCcpO1xuXHRtZDQudXBkYXRlKGJ1Zik7XG5cdHJldHVybiBuZXcgQnVmZmVyKG1kNC5kaWdlc3QoKSk7XG59XG5cbmZ1bmN0aW9uIGNhbGNfcmVzcChwYXNzd29yZF9oYXNoLCBzZXJ2ZXJfY2hhbGxlbmdlKXtcbiAgICAvLyBwYWRkaW5nIHdpdGggemVyb3MgdG8gbWFrZSB0aGUgaGFzaCAyMSBieXRlcyBsb25nXG4gICAgdmFyIHBhc3NIYXNoUGFkZGVkID0gbmV3IEJ1ZmZlcigyMSk7XG4gICAgcGFzc0hhc2hQYWRkZWQuZmlsbChcIlxcMFwiKTtcbiAgICBwYXNzd29yZF9oYXNoLmNvcHkocGFzc0hhc2hQYWRkZWQsIDAsIDAsIHBhc3N3b3JkX2hhc2gubGVuZ3RoKTtcblxuICAgIHZhciByZXNBcnJheSA9IFtdO1xuXG4gICAgdmFyIGRlcyA9IGNyeXB0by5jcmVhdGVDaXBoZXJpdignREVTLUVDQicsIGluc2VydFplcm9zRXZlcnk3Qml0cyhwYXNzSGFzaFBhZGRlZC5zbGljZSgwLDcpKSwgJycpO1xuICAgIHJlc0FycmF5LnB1c2goIGRlcy51cGRhdGUoc2VydmVyX2NoYWxsZW5nZS5zbGljZSgwLDgpKSApO1xuXG4gICAgZGVzID0gY3J5cHRvLmNyZWF0ZUNpcGhlcml2KCdERVMtRUNCJywgaW5zZXJ0WmVyb3NFdmVyeTdCaXRzKHBhc3NIYXNoUGFkZGVkLnNsaWNlKDcsMTQpKSwgJycpO1xuICAgIHJlc0FycmF5LnB1c2goIGRlcy51cGRhdGUoc2VydmVyX2NoYWxsZW5nZS5zbGljZSgwLDgpKSApO1xuXG4gICAgZGVzID0gY3J5cHRvLmNyZWF0ZUNpcGhlcml2KCdERVMtRUNCJywgaW5zZXJ0WmVyb3NFdmVyeTdCaXRzKHBhc3NIYXNoUGFkZGVkLnNsaWNlKDE0LDIxKSksICcnKTtcbiAgICByZXNBcnJheS5wdXNoKCBkZXMudXBkYXRlKHNlcnZlcl9jaGFsbGVuZ2Uuc2xpY2UoMCw4KSkgKTtcblxuICAgXHRyZXR1cm4gQnVmZmVyLmNvbmNhdChyZXNBcnJheSk7XG59XG5cbmZ1bmN0aW9uIG50bG0yc3JfY2FsY19yZXNwKHJlc3BvbnNlS2V5TlQsIHNlcnZlckNoYWxsZW5nZSwgY2xpZW50Q2hhbGxlbmdlKXtcblx0Ly8gcGFkZGluZyB3aXRoIHplcm9zIHRvIG1ha2UgdGhlIGhhc2ggMTYgYnl0ZXMgbG9uZ2VyXG4gICAgdmFyIGxtQ2hhbGxlbmdlUmVzcG9uc2UgPSBuZXcgQnVmZmVyKGNsaWVudENoYWxsZW5nZS5sZW5ndGggKyAxNik7XG4gICAgbG1DaGFsbGVuZ2VSZXNwb25zZS5maWxsKFwiXFwwXCIpO1xuICAgIGNsaWVudENoYWxsZW5nZS5jb3B5KGxtQ2hhbGxlbmdlUmVzcG9uc2UsIDAsIDAsIGNsaWVudENoYWxsZW5nZS5sZW5ndGgpO1xuXG4gICAgdmFyIGJ1ZiA9IEJ1ZmZlci5jb25jYXQoW3NlcnZlckNoYWxsZW5nZSwgY2xpZW50Q2hhbGxlbmdlXSk7XG4gICAgdmFyIG1kNSA9IGNyeXB0by5jcmVhdGVIYXNoKCdtZDUnKTtcbiAgICBtZDUudXBkYXRlKGJ1Zik7XG4gICAgdmFyIHNlc3MgPSBtZDUuZGlnZXN0KCk7XG4gICAgdmFyIG50Q2hhbGxlbmdlUmVzcG9uc2UgPSBjYWxjX3Jlc3AocmVzcG9uc2VLZXlOVCwgc2Vzcy5zbGljZSgwLDgpKTtcblxuICAgIHJldHVybiB7XG4gICAgXHRsbUNoYWxsZW5nZVJlc3BvbnNlOiBsbUNoYWxsZW5nZVJlc3BvbnNlLFxuICAgIFx0bnRDaGFsbGVuZ2VSZXNwb25zZTogbnRDaGFsbGVuZ2VSZXNwb25zZVxuICAgIH07XG59XG5cbmV4cG9ydHMuY3JlYXRlVHlwZTFNZXNzYWdlID0gY3JlYXRlVHlwZTFNZXNzYWdlO1xuZXhwb3J0cy5wYXJzZVR5cGUyTWVzc2FnZSA9IHBhcnNlVHlwZTJNZXNzYWdlO1xuZXhwb3J0cy5jcmVhdGVUeXBlM01lc3NhZ2UgPSBjcmVhdGVUeXBlM01lc3NhZ2U7XG5cblxuXG5cblxufSkuY2FsbCh0aGlzLHJlcXVpcmUoXCJidWZmZXJcIikuQnVmZmVyKSIsIihmdW5jdGlvbiAoQnVmZmVyKXtcblwidXNlIHN0cmljdFwiXG5cbi8vIE11bHRpYnl0ZSBjb2RlYy4gSW4gdGhpcyBzY2hlbWUsIGEgY2hhcmFjdGVyIGlzIHJlcHJlc2VudGVkIGJ5IDEgb3IgbW9yZSBieXRlcy5cbi8vIE91ciBjb2RlYyBzdXBwb3J0cyBVVEYtMTYgc3Vycm9nYXRlcywgZXh0ZW5zaW9ucyBmb3IgR0IxODAzMCBhbmQgdW5pY29kZSBzZXF1ZW5jZXMuXG4vLyBUbyBzYXZlIG1lbW9yeSBhbmQgbG9hZGluZyB0aW1lLCB3ZSByZWFkIHRhYmxlIGZpbGVzIG9ubHkgd2hlbiByZXF1ZXN0ZWQuXG5cbmV4cG9ydHMuX2RiY3MgPSBEQkNTQ29kZWM7XG5cbnZhciBVTkFTU0lHTkVEID0gLTEsXG4gICAgR0IxODAzMF9DT0RFID0gLTIsXG4gICAgU0VRX1NUQVJUICA9IC0xMCxcbiAgICBOT0RFX1NUQVJUID0gLTEwMDAsXG4gICAgVU5BU1NJR05FRF9OT0RFID0gbmV3IEFycmF5KDB4MTAwKSxcbiAgICBERUZfQ0hBUiA9IC0xO1xuXG5mb3IgKHZhciBpID0gMDsgaSA8IDB4MTAwOyBpKyspXG4gICAgVU5BU1NJR05FRF9OT0RFW2ldID0gVU5BU1NJR05FRDtcblxuXG4vLyBDbGFzcyBEQkNTQ29kZWMgcmVhZHMgYW5kIGluaXRpYWxpemVzIG1hcHBpbmcgdGFibGVzLlxuZnVuY3Rpb24gREJDU0NvZGVjKGNvZGVjT3B0aW9ucywgaWNvbnYpIHtcbiAgICB0aGlzLmVuY29kaW5nTmFtZSA9IGNvZGVjT3B0aW9ucy5lbmNvZGluZ05hbWU7XG4gICAgaWYgKCFjb2RlY09wdGlvbnMpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkRCQ1MgY29kZWMgaXMgY2FsbGVkIHdpdGhvdXQgdGhlIGRhdGEuXCIpXG4gICAgaWYgKCFjb2RlY09wdGlvbnMudGFibGUpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkVuY29kaW5nICdcIiArIHRoaXMuZW5jb2RpbmdOYW1lICsgXCInIGhhcyBubyBkYXRhLlwiKTtcblxuICAgIC8vIExvYWQgdGFibGVzLlxuICAgIHZhciBtYXBwaW5nVGFibGUgPSBjb2RlY09wdGlvbnMudGFibGUoKTtcblxuXG4gICAgLy8gRGVjb2RlIHRhYmxlczogTUJDUyAtPiBVbmljb2RlLlxuXG4gICAgLy8gZGVjb2RlVGFibGVzIGlzIGEgdHJpZSwgZW5jb2RlZCBhcyBhbiBhcnJheSBvZiBhcnJheXMgb2YgaW50ZWdlcnMuIEludGVybmFsIGFycmF5cyBhcmUgdHJpZSBub2RlcyBhbmQgYWxsIGhhdmUgbGVuID0gMjU2LlxuICAgIC8vIFRyaWUgcm9vdCBpcyBkZWNvZGVUYWJsZXNbMF0uXG4gICAgLy8gVmFsdWVzOiA+PSAgMCAtPiB1bmljb2RlIGNoYXJhY3RlciBjb2RlLiBjYW4gYmUgPiAweEZGRkZcbiAgICAvLyAgICAgICAgID09IFVOQVNTSUdORUQgLT4gdW5rbm93bi91bmFzc2lnbmVkIHNlcXVlbmNlLlxuICAgIC8vICAgICAgICAgPT0gR0IxODAzMF9DT0RFIC0+IHRoaXMgaXMgdGhlIGVuZCBvZiBhIEdCMTgwMzAgNC1ieXRlIHNlcXVlbmNlLlxuICAgIC8vICAgICAgICAgPD0gTk9ERV9TVEFSVCAtPiBpbmRleCBvZiB0aGUgbmV4dCBub2RlIGluIG91ciB0cmllIHRvIHByb2Nlc3MgbmV4dCBieXRlLlxuICAgIC8vICAgICAgICAgPD0gU0VRX1NUQVJUICAtPiBpbmRleCBvZiB0aGUgc3RhcnQgb2YgYSBjaGFyYWN0ZXIgY29kZSBzZXF1ZW5jZSwgaW4gZGVjb2RlVGFibGVTZXEuXG4gICAgdGhpcy5kZWNvZGVUYWJsZXMgPSBbXTtcbiAgICB0aGlzLmRlY29kZVRhYmxlc1swXSA9IFVOQVNTSUdORURfTk9ERS5zbGljZSgwKTsgLy8gQ3JlYXRlIHJvb3Qgbm9kZS5cblxuICAgIC8vIFNvbWV0aW1lcyBhIE1CQ1MgY2hhciBjb3JyZXNwb25kcyB0byBhIHNlcXVlbmNlIG9mIHVuaWNvZGUgY2hhcnMuIFdlIHN0b3JlIHRoZW0gYXMgYXJyYXlzIG9mIGludGVnZXJzIGhlcmUuIFxuICAgIHRoaXMuZGVjb2RlVGFibGVTZXEgPSBbXTtcblxuICAgIC8vIEFjdHVhbCBtYXBwaW5nIHRhYmxlcyBjb25zaXN0IG9mIGNodW5rcy4gVXNlIHRoZW0gdG8gZmlsbCB1cCBkZWNvZGUgdGFibGVzLlxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbWFwcGluZ1RhYmxlLmxlbmd0aDsgaSsrKVxuICAgICAgICB0aGlzLl9hZGREZWNvZGVDaHVuayhtYXBwaW5nVGFibGVbaV0pO1xuXG4gICAgdGhpcy5kZWZhdWx0Q2hhclVuaWNvZGUgPSBpY29udi5kZWZhdWx0Q2hhclVuaWNvZGU7XG5cbiAgICBcbiAgICAvLyBFbmNvZGUgdGFibGVzOiBVbmljb2RlIC0+IERCQ1MuXG5cbiAgICAvLyBgZW5jb2RlVGFibGVgIGlzIGFycmF5IG1hcHBpbmcgZnJvbSB1bmljb2RlIGNoYXIgdG8gZW5jb2RlZCBjaGFyLiBBbGwgaXRzIHZhbHVlcyBhcmUgaW50ZWdlcnMgZm9yIHBlcmZvcm1hbmNlLlxuICAgIC8vIEJlY2F1c2UgaXQgY2FuIGJlIHNwYXJzZSwgaXQgaXMgcmVwcmVzZW50ZWQgYXMgYXJyYXkgb2YgYnVja2V0cyBieSAyNTYgY2hhcnMgZWFjaC4gQnVja2V0IGNhbiBiZSBudWxsLlxuICAgIC8vIFZhbHVlczogPj0gIDAgLT4gaXQgaXMgYSBub3JtYWwgY2hhci4gV3JpdGUgdGhlIHZhbHVlIChpZiA8PTI1NiB0aGVuIDEgYnl0ZSwgaWYgPD02NTUzNiB0aGVuIDIgYnl0ZXMsIGV0Yy4pLlxuICAgIC8vICAgICAgICAgPT0gVU5BU1NJR05FRCAtPiBubyBjb252ZXJzaW9uIGZvdW5kLiBPdXRwdXQgYSBkZWZhdWx0IGNoYXIuXG4gICAgLy8gICAgICAgICA8PSBTRVFfU1RBUlQgIC0+IGl0J3MgYW4gaW5kZXggaW4gZW5jb2RlVGFibGVTZXEsIHNlZSBiZWxvdy4gVGhlIGNoYXJhY3RlciBzdGFydHMgYSBzZXF1ZW5jZS5cbiAgICB0aGlzLmVuY29kZVRhYmxlID0gW107XG4gICAgXG4gICAgLy8gYGVuY29kZVRhYmxlU2VxYCBpcyB1c2VkIHdoZW4gYSBzZXF1ZW5jZSBvZiB1bmljb2RlIGNoYXJhY3RlcnMgaXMgZW5jb2RlZCBhcyBhIHNpbmdsZSBjb2RlLiBXZSB1c2UgYSB0cmVlIG9mXG4gICAgLy8gb2JqZWN0cyB3aGVyZSBrZXlzIGNvcnJlc3BvbmQgdG8gY2hhcmFjdGVycyBpbiBzZXF1ZW5jZSBhbmQgbGVhZnMgYXJlIHRoZSBlbmNvZGVkIGRiY3MgdmFsdWVzLiBBIHNwZWNpYWwgREVGX0NIQVIga2V5XG4gICAgLy8gbWVhbnMgZW5kIG9mIHNlcXVlbmNlIChuZWVkZWQgd2hlbiBvbmUgc2VxdWVuY2UgaXMgYSBzdHJpY3Qgc3Vic2VxdWVuY2Ugb2YgYW5vdGhlcikuXG4gICAgLy8gT2JqZWN0cyBhcmUga2VwdCBzZXBhcmF0ZWx5IGZyb20gZW5jb2RlVGFibGUgdG8gaW5jcmVhc2UgcGVyZm9ybWFuY2UuXG4gICAgdGhpcy5lbmNvZGVUYWJsZVNlcSA9IFtdO1xuXG4gICAgLy8gU29tZSBjaGFycyBjYW4gYmUgZGVjb2RlZCwgYnV0IG5lZWQgbm90IGJlIGVuY29kZWQuXG4gICAgdmFyIHNraXBFbmNvZGVDaGFycyA9IHt9O1xuICAgIGlmIChjb2RlY09wdGlvbnMuZW5jb2RlU2tpcFZhbHMpXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY29kZWNPcHRpb25zLmVuY29kZVNraXBWYWxzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgdmFsID0gY29kZWNPcHRpb25zLmVuY29kZVNraXBWYWxzW2ldO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiB2YWwgPT09ICdudW1iZXInKVxuICAgICAgICAgICAgICAgIHNraXBFbmNvZGVDaGFyc1t2YWxdID0gdHJ1ZTtcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBqID0gdmFsLmZyb207IGogPD0gdmFsLnRvOyBqKyspXG4gICAgICAgICAgICAgICAgICAgIHNraXBFbmNvZGVDaGFyc1tqXSA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgLy8gVXNlIGRlY29kZSB0cmllIHRvIHJlY3Vyc2l2ZWx5IGZpbGwgb3V0IGVuY29kZSB0YWJsZXMuXG4gICAgdGhpcy5fZmlsbEVuY29kZVRhYmxlKDAsIDAsIHNraXBFbmNvZGVDaGFycyk7XG5cbiAgICAvLyBBZGQgbW9yZSBlbmNvZGluZyBwYWlycyB3aGVuIG5lZWRlZC5cbiAgICBpZiAoY29kZWNPcHRpb25zLmVuY29kZUFkZCkge1xuICAgICAgICBmb3IgKHZhciB1Q2hhciBpbiBjb2RlY09wdGlvbnMuZW5jb2RlQWRkKVxuICAgICAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChjb2RlY09wdGlvbnMuZW5jb2RlQWRkLCB1Q2hhcikpXG4gICAgICAgICAgICAgICAgdGhpcy5fc2V0RW5jb2RlQ2hhcih1Q2hhci5jaGFyQ29kZUF0KDApLCBjb2RlY09wdGlvbnMuZW5jb2RlQWRkW3VDaGFyXSk7XG4gICAgfVxuXG4gICAgdGhpcy5kZWZDaGFyU0IgID0gdGhpcy5lbmNvZGVUYWJsZVswXVtpY29udi5kZWZhdWx0Q2hhclNpbmdsZUJ5dGUuY2hhckNvZGVBdCgwKV07XG4gICAgaWYgKHRoaXMuZGVmQ2hhclNCID09PSBVTkFTU0lHTkVEKSB0aGlzLmRlZkNoYXJTQiA9IHRoaXMuZW5jb2RlVGFibGVbMF1bJz8nXTtcbiAgICBpZiAodGhpcy5kZWZDaGFyU0IgPT09IFVOQVNTSUdORUQpIHRoaXMuZGVmQ2hhclNCID0gXCI/XCIuY2hhckNvZGVBdCgwKTtcblxuXG4gICAgLy8gTG9hZCAmIGNyZWF0ZSBHQjE4MDMwIHRhYmxlcyB3aGVuIG5lZWRlZC5cbiAgICBpZiAodHlwZW9mIGNvZGVjT3B0aW9ucy5nYjE4MDMwID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHRoaXMuZ2IxODAzMCA9IGNvZGVjT3B0aW9ucy5nYjE4MDMwKCk7IC8vIExvYWQgR0IxODAzMCByYW5nZXMuXG5cbiAgICAgICAgLy8gQWRkIEdCMTgwMzAgZGVjb2RlIHRhYmxlcy5cbiAgICAgICAgdmFyIHRoaXJkQnl0ZU5vZGVJZHggPSB0aGlzLmRlY29kZVRhYmxlcy5sZW5ndGg7XG4gICAgICAgIHZhciB0aGlyZEJ5dGVOb2RlID0gdGhpcy5kZWNvZGVUYWJsZXNbdGhpcmRCeXRlTm9kZUlkeF0gPSBVTkFTU0lHTkVEX05PREUuc2xpY2UoMCk7XG5cbiAgICAgICAgdmFyIGZvdXJ0aEJ5dGVOb2RlSWR4ID0gdGhpcy5kZWNvZGVUYWJsZXMubGVuZ3RoO1xuICAgICAgICB2YXIgZm91cnRoQnl0ZU5vZGUgPSB0aGlzLmRlY29kZVRhYmxlc1tmb3VydGhCeXRlTm9kZUlkeF0gPSBVTkFTU0lHTkVEX05PREUuc2xpY2UoMCk7XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IDB4ODE7IGkgPD0gMHhGRTsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgc2Vjb25kQnl0ZU5vZGVJZHggPSBOT0RFX1NUQVJUIC0gdGhpcy5kZWNvZGVUYWJsZXNbMF1baV07XG4gICAgICAgICAgICB2YXIgc2Vjb25kQnl0ZU5vZGUgPSB0aGlzLmRlY29kZVRhYmxlc1tzZWNvbmRCeXRlTm9kZUlkeF07XG4gICAgICAgICAgICBmb3IgKHZhciBqID0gMHgzMDsgaiA8PSAweDM5OyBqKyspXG4gICAgICAgICAgICAgICAgc2Vjb25kQnl0ZU5vZGVbal0gPSBOT0RFX1NUQVJUIC0gdGhpcmRCeXRlTm9kZUlkeDtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKHZhciBpID0gMHg4MTsgaSA8PSAweEZFOyBpKyspXG4gICAgICAgICAgICB0aGlyZEJ5dGVOb2RlW2ldID0gTk9ERV9TVEFSVCAtIGZvdXJ0aEJ5dGVOb2RlSWR4O1xuICAgICAgICBmb3IgKHZhciBpID0gMHgzMDsgaSA8PSAweDM5OyBpKyspXG4gICAgICAgICAgICBmb3VydGhCeXRlTm9kZVtpXSA9IEdCMTgwMzBfQ09ERVxuICAgIH0gICAgICAgIFxufVxuXG5EQkNTQ29kZWMucHJvdG90eXBlLmVuY29kZXIgPSBEQkNTRW5jb2RlcjtcbkRCQ1NDb2RlYy5wcm90b3R5cGUuZGVjb2RlciA9IERCQ1NEZWNvZGVyO1xuXG4vLyBEZWNvZGVyIGhlbHBlcnNcbkRCQ1NDb2RlYy5wcm90b3R5cGUuX2dldERlY29kZVRyaWVOb2RlID0gZnVuY3Rpb24oYWRkcikge1xuICAgIHZhciBieXRlcyA9IFtdO1xuICAgIGZvciAoOyBhZGRyID4gMDsgYWRkciA+Pj0gOClcbiAgICAgICAgYnl0ZXMucHVzaChhZGRyICYgMHhGRik7XG4gICAgaWYgKGJ5dGVzLmxlbmd0aCA9PSAwKVxuICAgICAgICBieXRlcy5wdXNoKDApO1xuXG4gICAgdmFyIG5vZGUgPSB0aGlzLmRlY29kZVRhYmxlc1swXTtcbiAgICBmb3IgKHZhciBpID0gYnl0ZXMubGVuZ3RoLTE7IGkgPiAwOyBpLS0pIHsgLy8gVHJhdmVyc2Ugbm9kZXMgZGVlcGVyIGludG8gdGhlIHRyaWUuXG4gICAgICAgIHZhciB2YWwgPSBub2RlW2J5dGVzW2ldXTtcblxuICAgICAgICBpZiAodmFsID09IFVOQVNTSUdORUQpIHsgLy8gQ3JlYXRlIG5ldyBub2RlLlxuICAgICAgICAgICAgbm9kZVtieXRlc1tpXV0gPSBOT0RFX1NUQVJUIC0gdGhpcy5kZWNvZGVUYWJsZXMubGVuZ3RoO1xuICAgICAgICAgICAgdGhpcy5kZWNvZGVUYWJsZXMucHVzaChub2RlID0gVU5BU1NJR05FRF9OT0RFLnNsaWNlKDApKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh2YWwgPD0gTk9ERV9TVEFSVCkgeyAvLyBFeGlzdGluZyBub2RlLlxuICAgICAgICAgICAgbm9kZSA9IHRoaXMuZGVjb2RlVGFibGVzW05PREVfU1RBUlQgLSB2YWxdO1xuICAgICAgICB9XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIk92ZXJ3cml0ZSBieXRlIGluIFwiICsgdGhpcy5lbmNvZGluZ05hbWUgKyBcIiwgYWRkcjogXCIgKyBhZGRyLnRvU3RyaW5nKDE2KSk7XG4gICAgfVxuICAgIHJldHVybiBub2RlO1xufVxuXG5cbkRCQ1NDb2RlYy5wcm90b3R5cGUuX2FkZERlY29kZUNodW5rID0gZnVuY3Rpb24oY2h1bmspIHtcbiAgICAvLyBGaXJzdCBlbGVtZW50IG9mIGNodW5rIGlzIHRoZSBoZXggbWJjcyBjb2RlIHdoZXJlIHdlIHN0YXJ0LlxuICAgIHZhciBjdXJBZGRyID0gcGFyc2VJbnQoY2h1bmtbMF0sIDE2KTtcblxuICAgIC8vIENob29zZSB0aGUgZGVjb2Rpbmcgbm9kZSB3aGVyZSB3ZSdsbCB3cml0ZSBvdXIgY2hhcnMuXG4gICAgdmFyIHdyaXRlVGFibGUgPSB0aGlzLl9nZXREZWNvZGVUcmllTm9kZShjdXJBZGRyKTtcbiAgICBjdXJBZGRyID0gY3VyQWRkciAmIDB4RkY7XG5cbiAgICAvLyBXcml0ZSBhbGwgb3RoZXIgZWxlbWVudHMgb2YgdGhlIGNodW5rIHRvIHRoZSB0YWJsZS5cbiAgICBmb3IgKHZhciBrID0gMTsgayA8IGNodW5rLmxlbmd0aDsgaysrKSB7XG4gICAgICAgIHZhciBwYXJ0ID0gY2h1bmtba107XG4gICAgICAgIGlmICh0eXBlb2YgcGFydCA9PT0gXCJzdHJpbmdcIikgeyAvLyBTdHJpbmcsIHdyaXRlIGFzLWlzLlxuICAgICAgICAgICAgZm9yICh2YXIgbCA9IDA7IGwgPCBwYXJ0Lmxlbmd0aDspIHtcbiAgICAgICAgICAgICAgICB2YXIgY29kZSA9IHBhcnQuY2hhckNvZGVBdChsKyspO1xuICAgICAgICAgICAgICAgIGlmICgweEQ4MDAgPD0gY29kZSAmJiBjb2RlIDwgMHhEQzAwKSB7IC8vIERlY29kZSBzdXJyb2dhdGVcbiAgICAgICAgICAgICAgICAgICAgdmFyIGNvZGVUcmFpbCA9IHBhcnQuY2hhckNvZGVBdChsKyspO1xuICAgICAgICAgICAgICAgICAgICBpZiAoMHhEQzAwIDw9IGNvZGVUcmFpbCAmJiBjb2RlVHJhaWwgPCAweEUwMDApXG4gICAgICAgICAgICAgICAgICAgICAgICB3cml0ZVRhYmxlW2N1ckFkZHIrK10gPSAweDEwMDAwICsgKGNvZGUgLSAweEQ4MDApICogMHg0MDAgKyAoY29kZVRyYWlsIC0gMHhEQzAwKTtcbiAgICAgICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW5jb3JyZWN0IHN1cnJvZ2F0ZSBwYWlyIGluIFwiICArIHRoaXMuZW5jb2RpbmdOYW1lICsgXCIgYXQgY2h1bmsgXCIgKyBjaHVua1swXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKDB4MEZGMCA8IGNvZGUgJiYgY29kZSA8PSAweDBGRkYpIHsgLy8gQ2hhcmFjdGVyIHNlcXVlbmNlIChvdXIgb3duIGVuY29kaW5nIHVzZWQpXG4gICAgICAgICAgICAgICAgICAgIHZhciBsZW4gPSAweEZGRiAtIGNvZGUgKyAyO1xuICAgICAgICAgICAgICAgICAgICB2YXIgc2VxID0gW107XG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIG0gPSAwOyBtIDwgbGVuOyBtKyspXG4gICAgICAgICAgICAgICAgICAgICAgICBzZXEucHVzaChwYXJ0LmNoYXJDb2RlQXQobCsrKSk7IC8vIFNpbXBsZSB2YXJpYXRpb246IGRvbid0IHN1cHBvcnQgc3Vycm9nYXRlcyBvciBzdWJzZXF1ZW5jZXMgaW4gc2VxLlxuXG4gICAgICAgICAgICAgICAgICAgIHdyaXRlVGFibGVbY3VyQWRkcisrXSA9IFNFUV9TVEFSVCAtIHRoaXMuZGVjb2RlVGFibGVTZXEubGVuZ3RoO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmRlY29kZVRhYmxlU2VxLnB1c2goc2VxKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICB3cml0ZVRhYmxlW2N1ckFkZHIrK10gPSBjb2RlOyAvLyBCYXNpYyBjaGFyXG4gICAgICAgICAgICB9XG4gICAgICAgIH0gXG4gICAgICAgIGVsc2UgaWYgKHR5cGVvZiBwYXJ0ID09PSBcIm51bWJlclwiKSB7IC8vIEludGVnZXIsIG1lYW5pbmcgaW5jcmVhc2luZyBzZXF1ZW5jZSBzdGFydGluZyB3aXRoIHByZXYgY2hhcmFjdGVyLlxuICAgICAgICAgICAgdmFyIGNoYXJDb2RlID0gd3JpdGVUYWJsZVtjdXJBZGRyIC0gMV0gKyAxO1xuICAgICAgICAgICAgZm9yICh2YXIgbCA9IDA7IGwgPCBwYXJ0OyBsKyspXG4gICAgICAgICAgICAgICAgd3JpdGVUYWJsZVtjdXJBZGRyKytdID0gY2hhckNvZGUrKztcbiAgICAgICAgfVxuICAgICAgICBlbHNlXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbmNvcnJlY3QgdHlwZSAnXCIgKyB0eXBlb2YgcGFydCArIFwiJyBnaXZlbiBpbiBcIiAgKyB0aGlzLmVuY29kaW5nTmFtZSArIFwiIGF0IGNodW5rIFwiICsgY2h1bmtbMF0pO1xuICAgIH1cbiAgICBpZiAoY3VyQWRkciA+IDB4RkYpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkluY29ycmVjdCBjaHVuayBpbiBcIiAgKyB0aGlzLmVuY29kaW5nTmFtZSArIFwiIGF0IGFkZHIgXCIgKyBjaHVua1swXSArIFwiOiB0b28gbG9uZ1wiICsgY3VyQWRkcik7XG59XG5cbi8vIEVuY29kZXIgaGVscGVyc1xuREJDU0NvZGVjLnByb3RvdHlwZS5fZ2V0RW5jb2RlQnVja2V0ID0gZnVuY3Rpb24odUNvZGUpIHtcbiAgICB2YXIgaGlnaCA9IHVDb2RlID4+IDg7IC8vIFRoaXMgY291bGQgYmUgPiAweEZGIGJlY2F1c2Ugb2YgYXN0cmFsIGNoYXJhY3RlcnMuXG4gICAgaWYgKHRoaXMuZW5jb2RlVGFibGVbaGlnaF0gPT09IHVuZGVmaW5lZClcbiAgICAgICAgdGhpcy5lbmNvZGVUYWJsZVtoaWdoXSA9IFVOQVNTSUdORURfTk9ERS5zbGljZSgwKTsgLy8gQ3JlYXRlIGJ1Y2tldCBvbiBkZW1hbmQuXG4gICAgcmV0dXJuIHRoaXMuZW5jb2RlVGFibGVbaGlnaF07XG59XG5cbkRCQ1NDb2RlYy5wcm90b3R5cGUuX3NldEVuY29kZUNoYXIgPSBmdW5jdGlvbih1Q29kZSwgZGJjc0NvZGUpIHtcbiAgICB2YXIgYnVja2V0ID0gdGhpcy5fZ2V0RW5jb2RlQnVja2V0KHVDb2RlKTtcbiAgICB2YXIgbG93ID0gdUNvZGUgJiAweEZGO1xuICAgIGlmIChidWNrZXRbbG93XSA8PSBTRVFfU1RBUlQpXG4gICAgICAgIHRoaXMuZW5jb2RlVGFibGVTZXFbU0VRX1NUQVJULWJ1Y2tldFtsb3ddXVtERUZfQ0hBUl0gPSBkYmNzQ29kZTsgLy8gVGhlcmUncyBhbHJlYWR5IGEgc2VxdWVuY2UsIHNldCBhIHNpbmdsZS1jaGFyIHN1YnNlcXVlbmNlIG9mIGl0LlxuICAgIGVsc2UgaWYgKGJ1Y2tldFtsb3ddID09IFVOQVNTSUdORUQpXG4gICAgICAgIGJ1Y2tldFtsb3ddID0gZGJjc0NvZGU7XG59XG5cbkRCQ1NDb2RlYy5wcm90b3R5cGUuX3NldEVuY29kZVNlcXVlbmNlID0gZnVuY3Rpb24oc2VxLCBkYmNzQ29kZSkge1xuICAgIFxuICAgIC8vIEdldCB0aGUgcm9vdCBvZiBjaGFyYWN0ZXIgdHJlZSBhY2NvcmRpbmcgdG8gZmlyc3QgY2hhcmFjdGVyIG9mIHRoZSBzZXF1ZW5jZS5cbiAgICB2YXIgdUNvZGUgPSBzZXFbMF07XG4gICAgdmFyIGJ1Y2tldCA9IHRoaXMuX2dldEVuY29kZUJ1Y2tldCh1Q29kZSk7XG4gICAgdmFyIGxvdyA9IHVDb2RlICYgMHhGRjtcblxuICAgIHZhciBub2RlO1xuICAgIGlmIChidWNrZXRbbG93XSA8PSBTRVFfU1RBUlQpIHtcbiAgICAgICAgLy8gVGhlcmUncyBhbHJlYWR5IGEgc2VxdWVuY2Ugd2l0aCAgLSB1c2UgaXQuXG4gICAgICAgIG5vZGUgPSB0aGlzLmVuY29kZVRhYmxlU2VxW1NFUV9TVEFSVC1idWNrZXRbbG93XV07XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICAvLyBUaGVyZSB3YXMgbm8gc2VxdWVuY2Ugb2JqZWN0IC0gYWxsb2NhdGUgYSBuZXcgb25lLlxuICAgICAgICBub2RlID0ge307XG4gICAgICAgIGlmIChidWNrZXRbbG93XSAhPT0gVU5BU1NJR05FRCkgbm9kZVtERUZfQ0hBUl0gPSBidWNrZXRbbG93XTsgLy8gSWYgYSBjaGFyIHdhcyBzZXQgYmVmb3JlIC0gbWFrZSBpdCBhIHNpbmdsZS1jaGFyIHN1YnNlcXVlbmNlLlxuICAgICAgICBidWNrZXRbbG93XSA9IFNFUV9TVEFSVCAtIHRoaXMuZW5jb2RlVGFibGVTZXEubGVuZ3RoO1xuICAgICAgICB0aGlzLmVuY29kZVRhYmxlU2VxLnB1c2gobm9kZSk7XG4gICAgfVxuXG4gICAgLy8gVHJhdmVyc2UgdGhlIGNoYXJhY3RlciB0cmVlLCBhbGxvY2F0aW5nIG5ldyBub2RlcyBhcyBuZWVkZWQuXG4gICAgZm9yICh2YXIgaiA9IDE7IGogPCBzZXEubGVuZ3RoLTE7IGorKykge1xuICAgICAgICB2YXIgb2xkVmFsID0gbm9kZVt1Q29kZV07XG4gICAgICAgIGlmICh0eXBlb2Ygb2xkVmFsID09PSAnb2JqZWN0JylcbiAgICAgICAgICAgIG5vZGUgPSBvbGRWYWw7XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbm9kZSA9IG5vZGVbdUNvZGVdID0ge31cbiAgICAgICAgICAgIGlmIChvbGRWYWwgIT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgICAgICBub2RlW0RFRl9DSEFSXSA9IG9sZFZhbFxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gU2V0IHRoZSBsZWFmIHRvIGdpdmVuIGRiY3NDb2RlLlxuICAgIHVDb2RlID0gc2VxW3NlcS5sZW5ndGgtMV07XG4gICAgbm9kZVt1Q29kZV0gPSBkYmNzQ29kZTtcbn1cblxuREJDU0NvZGVjLnByb3RvdHlwZS5fZmlsbEVuY29kZVRhYmxlID0gZnVuY3Rpb24obm9kZUlkeCwgcHJlZml4LCBza2lwRW5jb2RlQ2hhcnMpIHtcbiAgICB2YXIgbm9kZSA9IHRoaXMuZGVjb2RlVGFibGVzW25vZGVJZHhdO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgMHgxMDA7IGkrKykge1xuICAgICAgICB2YXIgdUNvZGUgPSBub2RlW2ldO1xuICAgICAgICB2YXIgbWJDb2RlID0gcHJlZml4ICsgaTtcbiAgICAgICAgaWYgKHNraXBFbmNvZGVDaGFyc1ttYkNvZGVdKVxuICAgICAgICAgICAgY29udGludWU7XG5cbiAgICAgICAgaWYgKHVDb2RlID49IDApXG4gICAgICAgICAgICB0aGlzLl9zZXRFbmNvZGVDaGFyKHVDb2RlLCBtYkNvZGUpO1xuICAgICAgICBlbHNlIGlmICh1Q29kZSA8PSBOT0RFX1NUQVJUKVxuICAgICAgICAgICAgdGhpcy5fZmlsbEVuY29kZVRhYmxlKE5PREVfU1RBUlQgLSB1Q29kZSwgbWJDb2RlIDw8IDgsIHNraXBFbmNvZGVDaGFycyk7XG4gICAgICAgIGVsc2UgaWYgKHVDb2RlIDw9IFNFUV9TVEFSVClcbiAgICAgICAgICAgIHRoaXMuX3NldEVuY29kZVNlcXVlbmNlKHRoaXMuZGVjb2RlVGFibGVTZXFbU0VRX1NUQVJUIC0gdUNvZGVdLCBtYkNvZGUpO1xuICAgIH1cbn1cblxuXG5cbi8vID09IEVuY29kZXIgPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG5cbmZ1bmN0aW9uIERCQ1NFbmNvZGVyKG9wdGlvbnMsIGNvZGVjKSB7XG4gICAgLy8gRW5jb2RlciBzdGF0ZVxuICAgIHRoaXMubGVhZFN1cnJvZ2F0ZSA9IC0xO1xuICAgIHRoaXMuc2VxT2JqID0gdW5kZWZpbmVkO1xuICAgIFxuICAgIC8vIFN0YXRpYyBkYXRhXG4gICAgdGhpcy5lbmNvZGVUYWJsZSA9IGNvZGVjLmVuY29kZVRhYmxlO1xuICAgIHRoaXMuZW5jb2RlVGFibGVTZXEgPSBjb2RlYy5lbmNvZGVUYWJsZVNlcTtcbiAgICB0aGlzLmRlZmF1bHRDaGFyU2luZ2xlQnl0ZSA9IGNvZGVjLmRlZkNoYXJTQjtcbiAgICB0aGlzLmdiMTgwMzAgPSBjb2RlYy5nYjE4MDMwO1xufVxuXG5EQkNTRW5jb2Rlci5wcm90b3R5cGUud3JpdGUgPSBmdW5jdGlvbihzdHIpIHtcbiAgICB2YXIgbmV3QnVmID0gbmV3IEJ1ZmZlcihzdHIubGVuZ3RoICogKHRoaXMuZ2IxODAzMCA/IDQgOiAzKSksIFxuICAgICAgICBsZWFkU3Vycm9nYXRlID0gdGhpcy5sZWFkU3Vycm9nYXRlLFxuICAgICAgICBzZXFPYmogPSB0aGlzLnNlcU9iaiwgbmV4dENoYXIgPSAtMSxcbiAgICAgICAgaSA9IDAsIGogPSAwO1xuXG4gICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgLy8gMC4gR2V0IG5leHQgY2hhcmFjdGVyLlxuICAgICAgICBpZiAobmV4dENoYXIgPT09IC0xKSB7XG4gICAgICAgICAgICBpZiAoaSA9PSBzdHIubGVuZ3RoKSBicmVhaztcbiAgICAgICAgICAgIHZhciB1Q29kZSA9IHN0ci5jaGFyQ29kZUF0KGkrKyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB2YXIgdUNvZGUgPSBuZXh0Q2hhcjtcbiAgICAgICAgICAgIG5leHRDaGFyID0gLTE7ICAgIFxuICAgICAgICB9XG5cbiAgICAgICAgLy8gMS4gSGFuZGxlIHN1cnJvZ2F0ZXMuXG4gICAgICAgIGlmICgweEQ4MDAgPD0gdUNvZGUgJiYgdUNvZGUgPCAweEUwMDApIHsgLy8gQ2hhciBpcyBvbmUgb2Ygc3Vycm9nYXRlcy5cbiAgICAgICAgICAgIGlmICh1Q29kZSA8IDB4REMwMCkgeyAvLyBXZSd2ZSBnb3QgbGVhZCBzdXJyb2dhdGUuXG4gICAgICAgICAgICAgICAgaWYgKGxlYWRTdXJyb2dhdGUgPT09IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgIGxlYWRTdXJyb2dhdGUgPSB1Q29kZTtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgbGVhZFN1cnJvZ2F0ZSA9IHVDb2RlO1xuICAgICAgICAgICAgICAgICAgICAvLyBEb3VibGUgbGVhZCBzdXJyb2dhdGUgZm91bmQuXG4gICAgICAgICAgICAgICAgICAgIHVDb2RlID0gVU5BU1NJR05FRDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2UgeyAvLyBXZSd2ZSBnb3QgdHJhaWwgc3Vycm9nYXRlLlxuICAgICAgICAgICAgICAgIGlmIChsZWFkU3Vycm9nYXRlICE9PSAtMSkge1xuICAgICAgICAgICAgICAgICAgICB1Q29kZSA9IDB4MTAwMDAgKyAobGVhZFN1cnJvZ2F0ZSAtIDB4RDgwMCkgKiAweDQwMCArICh1Q29kZSAtIDB4REMwMCk7XG4gICAgICAgICAgICAgICAgICAgIGxlYWRTdXJyb2dhdGUgPSAtMTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAvLyBJbmNvbXBsZXRlIHN1cnJvZ2F0ZSBwYWlyIC0gb25seSB0cmFpbCBzdXJyb2dhdGUgZm91bmQuXG4gICAgICAgICAgICAgICAgICAgIHVDb2RlID0gVU5BU1NJR05FRDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAobGVhZFN1cnJvZ2F0ZSAhPT0gLTEpIHtcbiAgICAgICAgICAgIC8vIEluY29tcGxldGUgc3Vycm9nYXRlIHBhaXIgLSBvbmx5IGxlYWQgc3Vycm9nYXRlIGZvdW5kLlxuICAgICAgICAgICAgbmV4dENoYXIgPSB1Q29kZTsgdUNvZGUgPSBVTkFTU0lHTkVEOyAvLyBXcml0ZSBhbiBlcnJvciwgdGhlbiBjdXJyZW50IGNoYXIuXG4gICAgICAgICAgICBsZWFkU3Vycm9nYXRlID0gLTE7XG4gICAgICAgIH1cblxuICAgICAgICAvLyAyLiBDb252ZXJ0IHVDb2RlIGNoYXJhY3Rlci5cbiAgICAgICAgdmFyIGRiY3NDb2RlID0gVU5BU1NJR05FRDtcbiAgICAgICAgaWYgKHNlcU9iaiAhPT0gdW5kZWZpbmVkICYmIHVDb2RlICE9IFVOQVNTSUdORUQpIHsgLy8gV2UgYXJlIGluIHRoZSBtaWRkbGUgb2YgdGhlIHNlcXVlbmNlXG4gICAgICAgICAgICB2YXIgcmVzQ29kZSA9IHNlcU9ialt1Q29kZV07XG4gICAgICAgICAgICBpZiAodHlwZW9mIHJlc0NvZGUgPT09ICdvYmplY3QnKSB7IC8vIFNlcXVlbmNlIGNvbnRpbnVlcy5cbiAgICAgICAgICAgICAgICBzZXFPYmogPSByZXNDb2RlO1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuXG4gICAgICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiByZXNDb2RlID09ICdudW1iZXInKSB7IC8vIFNlcXVlbmNlIGZpbmlzaGVkLiBXcml0ZSBpdC5cbiAgICAgICAgICAgICAgICBkYmNzQ29kZSA9IHJlc0NvZGU7XG5cbiAgICAgICAgICAgIH0gZWxzZSBpZiAocmVzQ29kZSA9PSB1bmRlZmluZWQpIHsgLy8gQ3VycmVudCBjaGFyYWN0ZXIgaXMgbm90IHBhcnQgb2YgdGhlIHNlcXVlbmNlLlxuXG4gICAgICAgICAgICAgICAgLy8gVHJ5IGRlZmF1bHQgY2hhcmFjdGVyIGZvciB0aGlzIHNlcXVlbmNlXG4gICAgICAgICAgICAgICAgcmVzQ29kZSA9IHNlcU9ialtERUZfQ0hBUl07XG4gICAgICAgICAgICAgICAgaWYgKHJlc0NvZGUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICBkYmNzQ29kZSA9IHJlc0NvZGU7IC8vIEZvdW5kLiBXcml0ZSBpdC5cbiAgICAgICAgICAgICAgICAgICAgbmV4dENoYXIgPSB1Q29kZTsgLy8gQ3VycmVudCBjaGFyYWN0ZXIgd2lsbCBiZSB3cml0dGVuIHRvbyBpbiB0aGUgbmV4dCBpdGVyYXRpb24uXG5cbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAvLyBUT0RPOiBXaGF0IGlmIHdlIGhhdmUgbm8gZGVmYXVsdD8gKHJlc0NvZGUgPT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgICAgICAgICAvLyBUaGVuLCB3ZSBzaG91bGQgd3JpdGUgZmlyc3QgY2hhciBvZiB0aGUgc2VxdWVuY2UgYXMtaXMgYW5kIHRyeSB0aGUgcmVzdCByZWN1cnNpdmVseS5cbiAgICAgICAgICAgICAgICAgICAgLy8gRGlkbid0IGRvIGl0IGZvciBub3cgYmVjYXVzZSBubyBlbmNvZGluZyBoYXMgdGhpcyBzaXR1YXRpb24geWV0LlxuICAgICAgICAgICAgICAgICAgICAvLyBDdXJyZW50bHksIGp1c3Qgc2tpcCB0aGUgc2VxdWVuY2UgYW5kIHdyaXRlIGN1cnJlbnQgY2hhci5cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzZXFPYmogPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodUNvZGUgPj0gMCkgeyAgLy8gUmVndWxhciBjaGFyYWN0ZXJcbiAgICAgICAgICAgIHZhciBzdWJ0YWJsZSA9IHRoaXMuZW5jb2RlVGFibGVbdUNvZGUgPj4gOF07XG4gICAgICAgICAgICBpZiAoc3VidGFibGUgIT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgICAgICBkYmNzQ29kZSA9IHN1YnRhYmxlW3VDb2RlICYgMHhGRl07XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIGlmIChkYmNzQ29kZSA8PSBTRVFfU1RBUlQpIHsgLy8gU2VxdWVuY2Ugc3RhcnRcbiAgICAgICAgICAgICAgICBzZXFPYmogPSB0aGlzLmVuY29kZVRhYmxlU2VxW1NFUV9TVEFSVC1kYmNzQ29kZV07XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChkYmNzQ29kZSA9PSBVTkFTU0lHTkVEICYmIHRoaXMuZ2IxODAzMCkge1xuICAgICAgICAgICAgICAgIC8vIFVzZSBHQjE4MDMwIGFsZ29yaXRobSB0byBmaW5kIGNoYXJhY3RlcihzKSB0byB3cml0ZS5cbiAgICAgICAgICAgICAgICB2YXIgaWR4ID0gZmluZElkeCh0aGlzLmdiMTgwMzAudUNoYXJzLCB1Q29kZSk7XG4gICAgICAgICAgICAgICAgaWYgKGlkeCAhPSAtMSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgZGJjc0NvZGUgPSB0aGlzLmdiMTgwMzAuZ2JDaGFyc1tpZHhdICsgKHVDb2RlIC0gdGhpcy5nYjE4MDMwLnVDaGFyc1tpZHhdKTtcbiAgICAgICAgICAgICAgICAgICAgbmV3QnVmW2orK10gPSAweDgxICsgTWF0aC5mbG9vcihkYmNzQ29kZSAvIDEyNjAwKTsgZGJjc0NvZGUgPSBkYmNzQ29kZSAlIDEyNjAwO1xuICAgICAgICAgICAgICAgICAgICBuZXdCdWZbaisrXSA9IDB4MzAgKyBNYXRoLmZsb29yKGRiY3NDb2RlIC8gMTI2MCk7IGRiY3NDb2RlID0gZGJjc0NvZGUgJSAxMjYwO1xuICAgICAgICAgICAgICAgICAgICBuZXdCdWZbaisrXSA9IDB4ODEgKyBNYXRoLmZsb29yKGRiY3NDb2RlIC8gMTApOyBkYmNzQ29kZSA9IGRiY3NDb2RlICUgMTA7XG4gICAgICAgICAgICAgICAgICAgIG5ld0J1ZltqKytdID0gMHgzMCArIGRiY3NDb2RlO1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyAzLiBXcml0ZSBkYmNzQ29kZSBjaGFyYWN0ZXIuXG4gICAgICAgIGlmIChkYmNzQ29kZSA9PT0gVU5BU1NJR05FRClcbiAgICAgICAgICAgIGRiY3NDb2RlID0gdGhpcy5kZWZhdWx0Q2hhclNpbmdsZUJ5dGU7XG4gICAgICAgIFxuICAgICAgICBpZiAoZGJjc0NvZGUgPCAweDEwMCkge1xuICAgICAgICAgICAgbmV3QnVmW2orK10gPSBkYmNzQ29kZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChkYmNzQ29kZSA8IDB4MTAwMDApIHtcbiAgICAgICAgICAgIG5ld0J1ZltqKytdID0gZGJjc0NvZGUgPj4gODsgICAvLyBoaWdoIGJ5dGVcbiAgICAgICAgICAgIG5ld0J1ZltqKytdID0gZGJjc0NvZGUgJiAweEZGOyAvLyBsb3cgYnl0ZVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbmV3QnVmW2orK10gPSBkYmNzQ29kZSA+PiAxNjtcbiAgICAgICAgICAgIG5ld0J1ZltqKytdID0gKGRiY3NDb2RlID4+IDgpICYgMHhGRjtcbiAgICAgICAgICAgIG5ld0J1ZltqKytdID0gZGJjc0NvZGUgJiAweEZGO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgdGhpcy5zZXFPYmogPSBzZXFPYmo7XG4gICAgdGhpcy5sZWFkU3Vycm9nYXRlID0gbGVhZFN1cnJvZ2F0ZTtcbiAgICByZXR1cm4gbmV3QnVmLnNsaWNlKDAsIGopO1xufVxuXG5EQkNTRW5jb2Rlci5wcm90b3R5cGUuZW5kID0gZnVuY3Rpb24oKSB7XG4gICAgaWYgKHRoaXMubGVhZFN1cnJvZ2F0ZSA9PT0gLTEgJiYgdGhpcy5zZXFPYmogPT09IHVuZGVmaW5lZClcbiAgICAgICAgcmV0dXJuOyAvLyBBbGwgY2xlYW4uIE1vc3Qgb2Z0ZW4gY2FzZS5cblxuICAgIHZhciBuZXdCdWYgPSBuZXcgQnVmZmVyKDEwKSwgaiA9IDA7XG5cbiAgICBpZiAodGhpcy5zZXFPYmopIHsgLy8gV2UncmUgaW4gdGhlIHNlcXVlbmNlLlxuICAgICAgICB2YXIgZGJjc0NvZGUgPSB0aGlzLnNlcU9ialtERUZfQ0hBUl07XG4gICAgICAgIGlmIChkYmNzQ29kZSAhPT0gdW5kZWZpbmVkKSB7IC8vIFdyaXRlIGJlZ2lubmluZyBvZiB0aGUgc2VxdWVuY2UuXG4gICAgICAgICAgICBpZiAoZGJjc0NvZGUgPCAweDEwMCkge1xuICAgICAgICAgICAgICAgIG5ld0J1ZltqKytdID0gZGJjc0NvZGU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBuZXdCdWZbaisrXSA9IGRiY3NDb2RlID4+IDg7ICAgLy8gaGlnaCBieXRlXG4gICAgICAgICAgICAgICAgbmV3QnVmW2orK10gPSBkYmNzQ29kZSAmIDB4RkY7IC8vIGxvdyBieXRlXG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBTZWUgdG9kbyBhYm92ZS5cbiAgICAgICAgfVxuICAgICAgICB0aGlzLnNlcU9iaiA9IHVuZGVmaW5lZDtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5sZWFkU3Vycm9nYXRlICE9PSAtMSkge1xuICAgICAgICAvLyBJbmNvbXBsZXRlIHN1cnJvZ2F0ZSBwYWlyIC0gb25seSBsZWFkIHN1cnJvZ2F0ZSBmb3VuZC5cbiAgICAgICAgbmV3QnVmW2orK10gPSB0aGlzLmRlZmF1bHRDaGFyU2luZ2xlQnl0ZTtcbiAgICAgICAgdGhpcy5sZWFkU3Vycm9nYXRlID0gLTE7XG4gICAgfVxuICAgIFxuICAgIHJldHVybiBuZXdCdWYuc2xpY2UoMCwgaik7XG59XG5cbi8vIEV4cG9ydCBmb3IgdGVzdGluZ1xuREJDU0VuY29kZXIucHJvdG90eXBlLmZpbmRJZHggPSBmaW5kSWR4O1xuXG5cbi8vID09IERlY29kZXIgPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG5cbmZ1bmN0aW9uIERCQ1NEZWNvZGVyKG9wdGlvbnMsIGNvZGVjKSB7XG4gICAgLy8gRGVjb2RlciBzdGF0ZVxuICAgIHRoaXMubm9kZUlkeCA9IDA7XG4gICAgdGhpcy5wcmV2QnVmID0gbmV3IEJ1ZmZlcigwKTtcblxuICAgIC8vIFN0YXRpYyBkYXRhXG4gICAgdGhpcy5kZWNvZGVUYWJsZXMgPSBjb2RlYy5kZWNvZGVUYWJsZXM7XG4gICAgdGhpcy5kZWNvZGVUYWJsZVNlcSA9IGNvZGVjLmRlY29kZVRhYmxlU2VxO1xuICAgIHRoaXMuZGVmYXVsdENoYXJVbmljb2RlID0gY29kZWMuZGVmYXVsdENoYXJVbmljb2RlO1xuICAgIHRoaXMuZ2IxODAzMCA9IGNvZGVjLmdiMTgwMzA7XG59XG5cbkRCQ1NEZWNvZGVyLnByb3RvdHlwZS53cml0ZSA9IGZ1bmN0aW9uKGJ1Zikge1xuICAgIHZhciBuZXdCdWYgPSBuZXcgQnVmZmVyKGJ1Zi5sZW5ndGgqMiksXG4gICAgICAgIG5vZGVJZHggPSB0aGlzLm5vZGVJZHgsIFxuICAgICAgICBwcmV2QnVmID0gdGhpcy5wcmV2QnVmLCBwcmV2QnVmT2Zmc2V0ID0gdGhpcy5wcmV2QnVmLmxlbmd0aCxcbiAgICAgICAgc2VxU3RhcnQgPSAtdGhpcy5wcmV2QnVmLmxlbmd0aCwgLy8gaWR4IG9mIHRoZSBzdGFydCBvZiBjdXJyZW50IHBhcnNlZCBzZXF1ZW5jZS5cbiAgICAgICAgdUNvZGU7XG5cbiAgICBpZiAocHJldkJ1Zk9mZnNldCA+IDApIC8vIE1ha2UgcHJldiBidWYgb3ZlcmxhcCBhIGxpdHRsZSB0byBtYWtlIGl0IGVhc2llciB0byBzbGljZSBsYXRlci5cbiAgICAgICAgcHJldkJ1ZiA9IEJ1ZmZlci5jb25jYXQoW3ByZXZCdWYsIGJ1Zi5zbGljZSgwLCAxMCldKTtcbiAgICBcbiAgICBmb3IgKHZhciBpID0gMCwgaiA9IDA7IGkgPCBidWYubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIGN1ckJ5dGUgPSAoaSA+PSAwKSA/IGJ1ZltpXSA6IHByZXZCdWZbaSArIHByZXZCdWZPZmZzZXRdO1xuXG4gICAgICAgIC8vIExvb2t1cCBpbiBjdXJyZW50IHRyaWUgbm9kZS5cbiAgICAgICAgdmFyIHVDb2RlID0gdGhpcy5kZWNvZGVUYWJsZXNbbm9kZUlkeF1bY3VyQnl0ZV07XG5cbiAgICAgICAgaWYgKHVDb2RlID49IDApIHsgXG4gICAgICAgICAgICAvLyBOb3JtYWwgY2hhcmFjdGVyLCBqdXN0IHVzZSBpdC5cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh1Q29kZSA9PT0gVU5BU1NJR05FRCkgeyAvLyBVbmtub3duIGNoYXIuXG4gICAgICAgICAgICAvLyBUT0RPOiBDYWxsYmFjayB3aXRoIHNlcS5cbiAgICAgICAgICAgIC8vdmFyIGN1clNlcSA9IChzZXFTdGFydCA+PSAwKSA/IGJ1Zi5zbGljZShzZXFTdGFydCwgaSsxKSA6IHByZXZCdWYuc2xpY2Uoc2VxU3RhcnQgKyBwcmV2QnVmT2Zmc2V0LCBpKzEgKyBwcmV2QnVmT2Zmc2V0KTtcbiAgICAgICAgICAgIGkgPSBzZXFTdGFydDsgLy8gVHJ5IHRvIHBhcnNlIGFnYWluLCBhZnRlciBza2lwcGluZyBmaXJzdCBieXRlIG9mIHRoZSBzZXF1ZW5jZSAoJ2knIHdpbGwgYmUgaW5jcmVtZW50ZWQgYnkgJ2ZvcicgY3ljbGUpLlxuICAgICAgICAgICAgdUNvZGUgPSB0aGlzLmRlZmF1bHRDaGFyVW5pY29kZS5jaGFyQ29kZUF0KDApO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHVDb2RlID09PSBHQjE4MDMwX0NPREUpIHtcbiAgICAgICAgICAgIHZhciBjdXJTZXEgPSAoc2VxU3RhcnQgPj0gMCkgPyBidWYuc2xpY2Uoc2VxU3RhcnQsIGkrMSkgOiBwcmV2QnVmLnNsaWNlKHNlcVN0YXJ0ICsgcHJldkJ1Zk9mZnNldCwgaSsxICsgcHJldkJ1Zk9mZnNldCk7XG4gICAgICAgICAgICB2YXIgcHRyID0gKGN1clNlcVswXS0weDgxKSoxMjYwMCArIChjdXJTZXFbMV0tMHgzMCkqMTI2MCArIChjdXJTZXFbMl0tMHg4MSkqMTAgKyAoY3VyU2VxWzNdLTB4MzApO1xuICAgICAgICAgICAgdmFyIGlkeCA9IGZpbmRJZHgodGhpcy5nYjE4MDMwLmdiQ2hhcnMsIHB0cik7XG4gICAgICAgICAgICB1Q29kZSA9IHRoaXMuZ2IxODAzMC51Q2hhcnNbaWR4XSArIHB0ciAtIHRoaXMuZ2IxODAzMC5nYkNoYXJzW2lkeF07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodUNvZGUgPD0gTk9ERV9TVEFSVCkgeyAvLyBHbyB0byBuZXh0IHRyaWUgbm9kZS5cbiAgICAgICAgICAgIG5vZGVJZHggPSBOT0RFX1NUQVJUIC0gdUNvZGU7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh1Q29kZSA8PSBTRVFfU1RBUlQpIHsgLy8gT3V0cHV0IGEgc2VxdWVuY2Ugb2YgY2hhcnMuXG4gICAgICAgICAgICB2YXIgc2VxID0gdGhpcy5kZWNvZGVUYWJsZVNlcVtTRVFfU1RBUlQgLSB1Q29kZV07XG4gICAgICAgICAgICBmb3IgKHZhciBrID0gMDsgayA8IHNlcS5sZW5ndGggLSAxOyBrKyspIHtcbiAgICAgICAgICAgICAgICB1Q29kZSA9IHNlcVtrXTtcbiAgICAgICAgICAgICAgICBuZXdCdWZbaisrXSA9IHVDb2RlICYgMHhGRjtcbiAgICAgICAgICAgICAgICBuZXdCdWZbaisrXSA9IHVDb2RlID4+IDg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB1Q29kZSA9IHNlcVtzZXEubGVuZ3RoLTFdO1xuICAgICAgICB9XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImljb252LWxpdGUgaW50ZXJuYWwgZXJyb3I6IGludmFsaWQgZGVjb2RpbmcgdGFibGUgdmFsdWUgXCIgKyB1Q29kZSArIFwiIGF0IFwiICsgbm9kZUlkeCArIFwiL1wiICsgY3VyQnl0ZSk7XG5cbiAgICAgICAgLy8gV3JpdGUgdGhlIGNoYXJhY3RlciB0byBidWZmZXIsIGhhbmRsaW5nIGhpZ2hlciBwbGFuZXMgdXNpbmcgc3Vycm9nYXRlIHBhaXIuXG4gICAgICAgIGlmICh1Q29kZSA+IDB4RkZGRikgeyBcbiAgICAgICAgICAgIHVDb2RlIC09IDB4MTAwMDA7XG4gICAgICAgICAgICB2YXIgdUNvZGVMZWFkID0gMHhEODAwICsgTWF0aC5mbG9vcih1Q29kZSAvIDB4NDAwKTtcbiAgICAgICAgICAgIG5ld0J1ZltqKytdID0gdUNvZGVMZWFkICYgMHhGRjtcbiAgICAgICAgICAgIG5ld0J1ZltqKytdID0gdUNvZGVMZWFkID4+IDg7XG5cbiAgICAgICAgICAgIHVDb2RlID0gMHhEQzAwICsgdUNvZGUgJSAweDQwMDtcbiAgICAgICAgfVxuICAgICAgICBuZXdCdWZbaisrXSA9IHVDb2RlICYgMHhGRjtcbiAgICAgICAgbmV3QnVmW2orK10gPSB1Q29kZSA+PiA4O1xuXG4gICAgICAgIC8vIFJlc2V0IHRyaWUgbm9kZS5cbiAgICAgICAgbm9kZUlkeCA9IDA7IHNlcVN0YXJ0ID0gaSsxO1xuICAgIH1cblxuICAgIHRoaXMubm9kZUlkeCA9IG5vZGVJZHg7XG4gICAgdGhpcy5wcmV2QnVmID0gKHNlcVN0YXJ0ID49IDApID8gYnVmLnNsaWNlKHNlcVN0YXJ0KSA6IHByZXZCdWYuc2xpY2Uoc2VxU3RhcnQgKyBwcmV2QnVmT2Zmc2V0KTtcbiAgICByZXR1cm4gbmV3QnVmLnNsaWNlKDAsIGopLnRvU3RyaW5nKCd1Y3MyJyk7XG59XG5cbkRCQ1NEZWNvZGVyLnByb3RvdHlwZS5lbmQgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgcmV0ID0gJyc7XG5cbiAgICAvLyBUcnkgdG8gcGFyc2UgYWxsIHJlbWFpbmluZyBjaGFycy5cbiAgICB3aGlsZSAodGhpcy5wcmV2QnVmLmxlbmd0aCA+IDApIHtcbiAgICAgICAgLy8gU2tpcCAxIGNoYXJhY3RlciBpbiB0aGUgYnVmZmVyLlxuICAgICAgICByZXQgKz0gdGhpcy5kZWZhdWx0Q2hhclVuaWNvZGU7XG4gICAgICAgIHZhciBidWYgPSB0aGlzLnByZXZCdWYuc2xpY2UoMSk7XG5cbiAgICAgICAgLy8gUGFyc2UgcmVtYWluaW5nIGFzIHVzdWFsLlxuICAgICAgICB0aGlzLnByZXZCdWYgPSBuZXcgQnVmZmVyKDApO1xuICAgICAgICB0aGlzLm5vZGVJZHggPSAwO1xuICAgICAgICBpZiAoYnVmLmxlbmd0aCA+IDApXG4gICAgICAgICAgICByZXQgKz0gdGhpcy53cml0ZShidWYpO1xuICAgIH1cblxuICAgIHRoaXMubm9kZUlkeCA9IDA7XG4gICAgcmV0dXJuIHJldDtcbn1cblxuLy8gQmluYXJ5IHNlYXJjaCBmb3IgR0IxODAzMC4gUmV0dXJucyBsYXJnZXN0IGkgc3VjaCB0aGF0IHRhYmxlW2ldIDw9IHZhbC5cbmZ1bmN0aW9uIGZpbmRJZHgodGFibGUsIHZhbCkge1xuICAgIGlmICh0YWJsZVswXSA+IHZhbClcbiAgICAgICAgcmV0dXJuIC0xO1xuXG4gICAgdmFyIGwgPSAwLCByID0gdGFibGUubGVuZ3RoO1xuICAgIHdoaWxlIChsIDwgci0xKSB7IC8vIGFsd2F5cyB0YWJsZVtsXSA8PSB2YWwgPCB0YWJsZVtyXVxuICAgICAgICB2YXIgbWlkID0gbCArIE1hdGguZmxvb3IoKHItbCsxKS8yKTtcbiAgICAgICAgaWYgKHRhYmxlW21pZF0gPD0gdmFsKVxuICAgICAgICAgICAgbCA9IG1pZDtcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgciA9IG1pZDtcbiAgICB9XG4gICAgcmV0dXJuIGw7XG59XG5cblxufSkuY2FsbCh0aGlzLHJlcXVpcmUoXCJidWZmZXJcIikuQnVmZmVyKSIsIlwidXNlIHN0cmljdFwiXG5cbi8vIERlc2NyaXB0aW9uIG9mIHN1cHBvcnRlZCBkb3VibGUgYnl0ZSBlbmNvZGluZ3MgYW5kIGFsaWFzZXMuXG4vLyBUYWJsZXMgYXJlIG5vdCByZXF1aXJlKCktZCB1bnRpbCB0aGV5IGFyZSBuZWVkZWQgdG8gc3BlZWQgdXAgbGlicmFyeSBsb2FkLlxuLy8gcmVxdWlyZSgpLXMgYXJlIGRpcmVjdCB0byBzdXBwb3J0IEJyb3dzZXJpZnkuXG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICAgIFxuICAgIC8vID09IEphcGFuZXNlL1NoaWZ0SklTID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAgICAvLyBBbGwgamFwYW5lc2UgZW5jb2RpbmdzIGFyZSBiYXNlZCBvbiBKSVMgWCBzZXQgb2Ygc3RhbmRhcmRzOlxuICAgIC8vIEpJUyBYIDAyMDEgLSBTaW5nbGUtYnl0ZSBlbmNvZGluZyBvZiBBU0NJSSArIMKlICsgS2FuYSBjaGFycyBhdCAweEExLTB4REYuXG4gICAgLy8gSklTIFggMDIwOCAtIE1haW4gc2V0IG9mIDY4NzkgY2hhcmFjdGVycywgcGxhY2VkIGluIDk0eDk0IHBsYW5lLCB0byBiZSBlbmNvZGVkIGJ5IDIgYnl0ZXMuIFxuICAgIC8vICAgICAgICAgICAgICBIYXMgc2V2ZXJhbCB2YXJpYXRpb25zIGluIDE5NzgsIDE5ODMsIDE5OTAgYW5kIDE5OTcuXG4gICAgLy8gSklTIFggMDIxMiAtIFN1cHBsZW1lbnRhcnkgcGxhbmUgb2YgNjA2NyBjaGFycyBpbiA5NHg5NCBwbGFuZS4gMTk5MC4gRWZmZWN0aXZlbHkgZGVhZC5cbiAgICAvLyBKSVMgWCAwMjEzIC0gRXh0ZW5zaW9uIGFuZCBtb2Rlcm4gcmVwbGFjZW1lbnQgb2YgMDIwOCBhbmQgMDIxMi4gVG90YWwgY2hhcnM6IDExMjMzLlxuICAgIC8vICAgICAgICAgICAgICAyIHBsYW5lcywgZmlyc3QgaXMgc3VwZXJzZXQgb2YgMDIwOCwgc2Vjb25kIC0gcmV2aXNlZCAwMjEyLlxuICAgIC8vICAgICAgICAgICAgICBJbnRyb2R1Y2VkIGluIDIwMDAsIHJldmlzZWQgMjAwNC4gU29tZSBjaGFyYWN0ZXJzIGFyZSBpbiBVbmljb2RlIFBsYW5lIDIgKDB4Mnh4eHgpXG5cbiAgICAvLyBCeXRlIGVuY29kaW5ncyBhcmU6XG4gICAgLy8gICogU2hpZnRfSklTOiBDb21wYXRpYmxlIHdpdGggMDIwMSwgdXNlcyBub3QgZGVmaW5lZCBjaGFycyBpbiB0b3AgaGFsZiBhcyBsZWFkIGJ5dGVzIGZvciBkb3VibGUtYnl0ZVxuICAgIC8vICAgICAgICAgICAgICAgZW5jb2Rpbmcgb2YgMDIwOC4gTGVhZCBieXRlIHJhbmdlczogMHg4MS0weDlGLCAweEUwLTB4RUY7IFRyYWlsIGJ5dGUgcmFuZ2VzOiAweDQwLTB4N0UsIDB4ODAtMHg5RSwgMHg5Ri0weEZDLlxuICAgIC8vICAgICAgICAgICAgICAgV2luZG93cyBDUDkzMiBpcyBhIHN1cGVyc2V0IG9mIFNoaWZ0X0pJUy4gU29tZSBjb21wYW5pZXMgYWRkZWQgbW9yZSBjaGFycywgbm90YWJseSBLRERJLlxuICAgIC8vICAqIEVVQy1KUDogICAgVXAgdG8gMyBieXRlcyBwZXIgY2hhcmFjdGVyLiBVc2VkIG1vc3RseSBvbiAqbml4ZXMuXG4gICAgLy8gICAgICAgICAgICAgICAweDAwLTB4N0YgICAgICAgLSBsb3dlciBwYXJ0IG9mIDAyMDFcbiAgICAvLyAgICAgICAgICAgICAgIDB4OEUsIDB4QTEtMHhERiAtIHVwcGVyIHBhcnQgb2YgMDIwMVxuICAgIC8vICAgICAgICAgICAgICAgKDB4QTEtMHhGRSl4MiAgIC0gMDIwOCBwbGFuZSAoOTR4OTQpLlxuICAgIC8vICAgICAgICAgICAgICAgMHg4RiwgKDB4QTEtMHhGRSl4MiAtIDAyMTIgcGxhbmUgKDk0eDk0KS5cbiAgICAvLyAgKiBKSVMgWCAyMDg6IDctYml0LCBkaXJlY3QgZW5jb2Rpbmcgb2YgMDIwOC4gQnl0ZSByYW5nZXM6IDB4MjEtMHg3RSAoOTQgdmFsdWVzKS4gVW5jb21tb24uXG4gICAgLy8gICAgICAgICAgICAgICBVc2VkIGFzLWlzIGluIElTTzIwMjIgZmFtaWx5LlxuICAgIC8vICAqIElTTzIwMjItSlA6IFN0YXRlZnVsIGVuY29kaW5nLCB3aXRoIGVzY2FwZSBzZXF1ZW5jZXMgdG8gc3dpdGNoIGJldHdlZW4gQVNDSUksIFxuICAgIC8vICAgICAgICAgICAgICAgIDAyMDEtMTk3NiBSb21hbiwgMDIwOC0xOTc4LCAwMjA4LTE5ODMuXG4gICAgLy8gICogSVNPMjAyMi1KUC0xOiBBZGRzIGVzYyBzZXEgZm9yIDAyMTItMTk5MC5cbiAgICAvLyAgKiBJU08yMDIyLUpQLTI6IEFkZHMgZXNjIHNlcSBmb3IgR0IyMzEzLTE5ODAsIEtTWDEwMDEtMTk5MiwgSVNPODg1OS0xLCBJU084ODU5LTcuXG4gICAgLy8gICogSVNPMjAyMi1KUC0zOiBBZGRzIGVzYyBzZXEgZm9yIDAyMDEtMTk3NiBLYW5hIHNldCwgMDIxMy0yMDAwIFBsYW5lcyAxLCAyLlxuICAgIC8vICAqIElTTzIwMjItSlAtMjAwNDogQWRkcyAwMjEzLTIwMDQgUGxhbmUgMS5cbiAgICAvL1xuICAgIC8vIEFmdGVyIEpJUyBYIDAyMTMgYXBwZWFyZWQsIFNoaWZ0X0pJUy0yMDA0LCBFVUMtSklTWDAyMTMgYW5kIElTTzIwMjItSlAtMjAwNCBmb2xsb3dlZCwgd2l0aCBqdXN0IGNoYW5naW5nIHRoZSBwbGFuZXMuXG4gICAgLy9cbiAgICAvLyBPdmVyYWxsLCBpdCBzZWVtcyB0aGF0IGl0J3MgYSBtZXNzIDooIGh0dHA6Ly93d3c4LnBsYWxhLm9yLmpwL3RrdWJvdGExL3VuaWNvZGUtc3ltYm9scy1tYXAyLmh0bWxcblxuXG4gICAgJ3NoaWZ0amlzJzoge1xuICAgICAgICB0eXBlOiAnX2RiY3MnLFxuICAgICAgICB0YWJsZTogZnVuY3Rpb24oKSB7IHJldHVybiByZXF1aXJlKCcuL3RhYmxlcy9zaGlmdGppcy5qc29uJykgfSxcbiAgICAgICAgZW5jb2RlQWRkOiB7J1xcdTAwYTUnOiAweDVDLCAnXFx1MjAzRSc6IDB4N0V9LFxuICAgICAgICBlbmNvZGVTa2lwVmFsczogW3tmcm9tOiAweEVENDAsIHRvOiAweEY5NDB9XSxcbiAgICB9LFxuICAgICdjc3NoaWZ0amlzJzogJ3NoaWZ0amlzJyxcbiAgICAnbXNrYW5qaSc6ICdzaGlmdGppcycsXG4gICAgJ3NqaXMnOiAnc2hpZnRqaXMnLFxuICAgICd3aW5kb3dzMzFqJzogJ3NoaWZ0amlzJyxcbiAgICAneHNqaXMnOiAnc2hpZnRqaXMnLFxuICAgICd3aW5kb3dzOTMyJzogJ3NoaWZ0amlzJyxcbiAgICAnOTMyJzogJ3NoaWZ0amlzJyxcbiAgICAnY3A5MzInOiAnc2hpZnRqaXMnLFxuXG4gICAgJ2V1Y2pwJzoge1xuICAgICAgICB0eXBlOiAnX2RiY3MnLFxuICAgICAgICB0YWJsZTogZnVuY3Rpb24oKSB7IHJldHVybiByZXF1aXJlKCcuL3RhYmxlcy9ldWNqcC5qc29uJykgfSxcbiAgICAgICAgZW5jb2RlQWRkOiB7J1xcdTAwYTUnOiAweDVDLCAnXFx1MjAzRSc6IDB4N0V9LFxuICAgIH0sXG5cbiAgICAvLyBUT0RPOiBLRERJIGV4dGVuc2lvbiB0byBTaGlmdF9KSVNcbiAgICAvLyBUT0RPOiBJQk0gQ0NTSUQgOTQyID0gQ1A5MzIsIGJ1dCBGMC1GOSBjdXN0b20gY2hhcnMgYW5kIG90aGVyIGNoYXIgY2hhbmdlcy5cbiAgICAvLyBUT0RPOiBJQk0gQ0NTSUQgOTQzID0gU2hpZnRfSklTID0gQ1A5MzIgd2l0aCBvcmlnaW5hbCBTaGlmdF9KSVMgbG93ZXIgMTI4IGNoYXJzLlxuXG4gICAgLy8gPT0gQ2hpbmVzZS9HQksgPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICAgIC8vIGh0dHA6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvR0JLXG5cbiAgICAvLyBPbGRlc3QgR0IyMzEyICgxOTgxLCB+NzYwMCBjaGFycykgaXMgYSBzdWJzZXQgb2YgQ1A5MzZcbiAgICAnZ2IyMzEyJzogJ2NwOTM2JyxcbiAgICAnZ2IyMzEyODAnOiAnY3A5MzYnLFxuICAgICdnYjIzMTIxOTgwJzogJ2NwOTM2JyxcbiAgICAnY3NnYjIzMTInOiAnY3A5MzYnLFxuICAgICdjc2lzbzU4Z2IyMzEyODAnOiAnY3A5MzYnLFxuICAgICdldWNjbic6ICdjcDkzNicsXG4gICAgJ2lzb2lyNTgnOiAnZ2JrJyxcblxuICAgIC8vIE1pY3Jvc29mdCdzIENQOTM2IGlzIGEgc3Vic2V0IGFuZCBhcHByb3hpbWF0aW9uIG9mIEdCSy5cbiAgICAvLyBUT0RPOiBFdXJvID0gMHg4MCBpbiBjcDkzNiwgYnV0IG5vdCBpbiBHQksgKHdoZXJlIGl0J3MgdmFsaWQgYnV0IHVuZGVmaW5lZClcbiAgICAnd2luZG93czkzNic6ICdjcDkzNicsXG4gICAgJzkzNic6ICdjcDkzNicsXG4gICAgJ2NwOTM2Jzoge1xuICAgICAgICB0eXBlOiAnX2RiY3MnLFxuICAgICAgICB0YWJsZTogZnVuY3Rpb24oKSB7IHJldHVybiByZXF1aXJlKCcuL3RhYmxlcy9jcDkzNi5qc29uJykgfSxcbiAgICB9LFxuXG4gICAgLy8gR0JLICh+MjIwMDAgY2hhcnMpIGlzIGFuIGV4dGVuc2lvbiBvZiBDUDkzNiB0aGF0IGFkZGVkIHVzZXItbWFwcGVkIGNoYXJzIGFuZCBzb21lIG90aGVyLlxuICAgICdnYmsnOiB7XG4gICAgICAgIHR5cGU6ICdfZGJjcycsXG4gICAgICAgIHRhYmxlOiBmdW5jdGlvbigpIHsgcmV0dXJuIHJlcXVpcmUoJy4vdGFibGVzL2NwOTM2Lmpzb24nKS5jb25jYXQocmVxdWlyZSgnLi90YWJsZXMvZ2JrLWFkZGVkLmpzb24nKSkgfSxcbiAgICB9LFxuICAgICd4Z2JrJzogJ2diaycsXG5cbiAgICAvLyBHQjE4MDMwIGlzIGFuIGFsZ29yaXRobWljIGV4dGVuc2lvbiBvZiBHQksuXG4gICAgJ2diMTgwMzAnOiB7XG4gICAgICAgIHR5cGU6ICdfZGJjcycsXG4gICAgICAgIHRhYmxlOiBmdW5jdGlvbigpIHsgcmV0dXJuIHJlcXVpcmUoJy4vdGFibGVzL2NwOTM2Lmpzb24nKS5jb25jYXQocmVxdWlyZSgnLi90YWJsZXMvZ2JrLWFkZGVkLmpzb24nKSkgfSxcbiAgICAgICAgZ2IxODAzMDogZnVuY3Rpb24oKSB7IHJldHVybiByZXF1aXJlKCcuL3RhYmxlcy9nYjE4MDMwLXJhbmdlcy5qc29uJykgfSxcbiAgICB9LFxuXG4gICAgJ2NoaW5lc2UnOiAnZ2IxODAzMCcsXG5cbiAgICAvLyBUT0RPOiBTdXBwb3J0IEdCMTgwMzAgKH4yNzAwMCBjaGFycyArIHdob2xlIHVuaWNvZGUgbWFwcGluZywgY3A1NDkzNilcbiAgICAvLyBodHRwOi8vaWN1LXByb2plY3Qub3JnL2RvY3MvcGFwZXJzL2diMTgwMzAuaHRtbFxuICAgIC8vIGh0dHA6Ly9zb3VyY2UuaWN1LXByb2plY3Qub3JnL3JlcG9zL2ljdS9kYXRhL3RydW5rL2NoYXJzZXQvZGF0YS94bWwvZ2ItMTgwMzAtMjAwMC54bWxcbiAgICAvLyBodHRwOi8vd3d3LmtobmdhaS5jb20vY2hpbmVzZS9jaGFybWFwL3RibGdiay5waHA/cGFnZT0wXG5cbiAgICAvLyA9PSBLb3JlYW4gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gICAgLy8gRVVDLUtSLCBLU19DXzU2MDEgYW5kIEtTIFggMTAwMSBhcmUgZXhhY3RseSB0aGUgc2FtZS5cbiAgICAnd2luZG93czk0OSc6ICdjcDk0OScsXG4gICAgJzk0OSc6ICdjcDk0OScsXG4gICAgJ2NwOTQ5Jzoge1xuICAgICAgICB0eXBlOiAnX2RiY3MnLFxuICAgICAgICB0YWJsZTogZnVuY3Rpb24oKSB7IHJldHVybiByZXF1aXJlKCcuL3RhYmxlcy9jcDk0OS5qc29uJykgfSxcbiAgICB9LFxuXG4gICAgJ2NzZXVja3InOiAnY3A5NDknLFxuICAgICdjc2tzYzU2MDExOTg3JzogJ2NwOTQ5JyxcbiAgICAnZXVja3InOiAnY3A5NDknLFxuICAgICdpc29pcjE0OSc6ICdjcDk0OScsXG4gICAgJ2tvcmVhbic6ICdjcDk0OScsXG4gICAgJ2tzYzU2MDExOTg3JzogJ2NwOTQ5JyxcbiAgICAna3NjNTYwMTE5ODknOiAnY3A5NDknLFxuICAgICdrc2M1NjAxJzogJ2NwOTQ5JyxcblxuXG4gICAgLy8gPT0gQmlnNS9UYWl3YW4vSG9uZyBLb25nID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICAgIC8vIFRoZXJlIGFyZSBsb3RzIG9mIHRhYmxlcyBmb3IgQmlnNSBhbmQgY3A5NTAuIFBsZWFzZSBzZWUgdGhlIGZvbGxvd2luZyBsaW5rcyBmb3IgaGlzdG9yeTpcbiAgICAvLyBodHRwOi8vbW96dHcub3JnL2RvY3MvYmlnNS8gIGh0dHA6Ly93d3cuaGFpYmxlLmRlL2JydW5vL2NoYXJzZXRzL2NvbnZlcnNpb24tdGFibGVzL0JpZzUuaHRtbFxuICAgIC8vIFZhcmlhdGlvbnMsIGluIHJvdWdobHkgbnVtYmVyIG9mIGRlZmluZWQgY2hhcnM6XG4gICAgLy8gICogV2luZG93cyBDUCA5NTA6IE1pY3Jvc29mdCB2YXJpYW50IG9mIEJpZzUuIENhbm9uaWNhbDogaHR0cDovL3d3dy51bmljb2RlLm9yZy9QdWJsaWMvTUFQUElOR1MvVkVORE9SUy9NSUNTRlQvV0lORE9XUy9DUDk1MC5UWFRcbiAgICAvLyAgKiBXaW5kb3dzIENQIDk1MTogTWljcm9zb2Z0IHZhcmlhbnQgb2YgQmlnNS1IS1NDUy0yMDAxLiBTZWVtcyB0byBiZSBuZXZlciBwdWJsaWMuIGh0dHA6Ly9tZS5hYmVsY2hldW5nLm9yZy9hcnRpY2xlcy9yZXNlYXJjaC93aGF0LWlzLWNwOTUxL1xuICAgIC8vICAqIEJpZzUtMjAwMyAoVGFpd2FuIHN0YW5kYXJkKSBhbG1vc3Qgc3VwZXJzZXQgb2YgY3A5NTAuXG4gICAgLy8gICogVW5pY29kZS1hdC1vbiAoVUFPKSAvIE1vemlsbGEgMS44LiBGYWxsaW5nIG91dCBvZiB1c2Ugb24gdGhlIFdlYi4gTm90IHN1cHBvcnRlZCBieSBvdGhlciBicm93c2Vycy5cbiAgICAvLyAgKiBCaWc1LUhLU0NTICgtMjAwMSwgLTIwMDQsIC0yMDA4KS4gSG9uZyBLb25nIHN0YW5kYXJkLiBcbiAgICAvLyAgICBtYW55IHVuaWNvZGUgY29kZSBwb2ludHMgbW92ZWQgZnJvbSBQVUEgdG8gU3VwcGxlbWVudGFyeSBwbGFuZSAoVSsyWFhYWCkgb3ZlciB0aGUgeWVhcnMuXG4gICAgLy8gICAgUGx1cywgaXQgaGFzIDQgY29tYmluaW5nIHNlcXVlbmNlcy5cbiAgICAvLyAgICBTZWVtcyB0aGF0IE1vemlsbGEgcmVmdXNlZCB0byBzdXBwb3J0IGl0IGZvciAxMCB5cnMuIGh0dHBzOi8vYnVnemlsbGEubW96aWxsYS5vcmcvc2hvd19idWcuY2dpP2lkPTE2MjQzMSBodHRwczovL2J1Z3ppbGxhLm1vemlsbGEub3JnL3Nob3dfYnVnLmNnaT9pZD0zMTAyOTlcbiAgICAvLyAgICBiZWNhdXNlIGJpZzUtaGtzY3MgaXMgdGhlIG9ubHkgZW5jb2RpbmcgdG8gaW5jbHVkZSBhc3RyYWwgY2hhcmFjdGVycyBpbiBub24tYWxnb3JpdGhtaWMgd2F5LlxuICAgIC8vICAgIEltcGxlbWVudGF0aW9ucyBhcmUgbm90IGNvbnNpc3RlbnQgd2l0aGluIGJyb3dzZXJzOyBzb21ldGltZXMgbGFiZWxlZCBhcyBqdXN0IGJpZzUuXG4gICAgLy8gICAgTVMgSW50ZXJuZXQgRXhwbG9yZXIgc3dpdGNoZXMgZnJvbSBiaWc1IHRvIGJpZzUtaGtzY3Mgd2hlbiBhIHBhdGNoIGFwcGxpZWQuXG4gICAgLy8gICAgR3JlYXQgZGlzY3Vzc2lvbiAmIHJlY2FwIG9mIHdoYXQncyBnb2luZyBvbiBodHRwczovL2J1Z3ppbGxhLm1vemlsbGEub3JnL3Nob3dfYnVnLmNnaT9pZD05MTI0NzAjYzMxXG4gICAgLy8gICAgSW4gdGhlIGVuY29kZXIsIGl0IG1pZ2h0IG1ha2Ugc2Vuc2UgdG8gc3VwcG9ydCBlbmNvZGluZyBvbGQgUFVBIG1hcHBpbmdzIHRvIEJpZzUgYnl0ZXMgc2VxLXMuXG4gICAgLy8gICAgT2ZmaWNpYWwgc3BlYzogaHR0cDovL3d3dy5vZ2Npby5nb3YuaGsvZW4vYnVzaW5lc3MvdGVjaF9wcm9tb3Rpb24vY2NsaS90ZXJtcy9kb2MvMjAwM2NtcF8yMDA4LnR4dFxuICAgIC8vICAgICAgICAgICAgICAgICAgIGh0dHA6Ly93d3cub2djaW8uZ292LmhrL3RjL2J1c2luZXNzL3RlY2hfcHJvbW90aW9uL2NjbGkvdGVybXMvZG9jL2hrc2NzLTIwMDgtYmlnNS1pc28udHh0XG4gICAgLy8gXG4gICAgLy8gQ3VycmVudCB1bmRlcnN0YW5kaW5nIG9mIGhvdyB0byBkZWFsIHdpdGggQmlnNSgtSEtTQ1MpIGlzIGluIHRoZSBFbmNvZGluZyBTdGFuZGFyZCwgaHR0cDovL2VuY29kaW5nLnNwZWMud2hhdHdnLm9yZy8jYmlnNS1lbmNvZGVyXG4gICAgLy8gVW5pY29kZSBtYXBwaW5nIChodHRwOi8vd3d3LnVuaWNvZGUub3JnL1B1YmxpYy9NQVBQSU5HUy9PQlNPTEVURS9FQVNUQVNJQS9PVEhFUi9CSUc1LlRYVCkgaXMgc2FpZCB0byBiZSB3cm9uZy5cblxuICAgICd3aW5kb3dzOTUwJzogJ2NwOTUwJyxcbiAgICAnOTUwJzogJ2NwOTUwJyxcbiAgICAnY3A5NTAnOiB7XG4gICAgICAgIHR5cGU6ICdfZGJjcycsXG4gICAgICAgIHRhYmxlOiBmdW5jdGlvbigpIHsgcmV0dXJuIHJlcXVpcmUoJy4vdGFibGVzL2NwOTUwLmpzb24nKSB9LFxuICAgIH0sXG5cbiAgICAvLyBCaWc1IGhhcyBtYW55IHZhcmlhdGlvbnMgYW5kIGlzIGFuIGV4dGVuc2lvbiBvZiBjcDk1MC4gV2UgdXNlIEVuY29kaW5nIFN0YW5kYXJkJ3MgYXMgYSBjb25zZW5zdXMuXG4gICAgJ2JpZzUnOiAnYmlnNWhrc2NzJyxcbiAgICAnYmlnNWhrc2NzJzoge1xuICAgICAgICB0eXBlOiAnX2RiY3MnLFxuICAgICAgICB0YWJsZTogZnVuY3Rpb24oKSB7IHJldHVybiByZXF1aXJlKCcuL3RhYmxlcy9jcDk1MC5qc29uJykuY29uY2F0KHJlcXVpcmUoJy4vdGFibGVzL2JpZzUtYWRkZWQuanNvbicpKSB9LFxuICAgICAgICBlbmNvZGVTa2lwVmFsczogWzB4YTJjY10sXG4gICAgfSxcblxuICAgICdjbmJpZzUnOiAnYmlnNWhrc2NzJyxcbiAgICAnY3NiaWc1JzogJ2JpZzVoa3NjcycsXG4gICAgJ3h4YmlnNSc6ICdiaWc1aGtzY3MnLFxuXG59O1xuIiwiXCJ1c2Ugc3RyaWN0XCJcblxuLy8gVXBkYXRlIHRoaXMgYXJyYXkgaWYgeW91IGFkZC9yZW5hbWUvcmVtb3ZlIGZpbGVzIGluIHRoaXMgZGlyZWN0b3J5LlxuLy8gV2Ugc3VwcG9ydCBCcm93c2VyaWZ5IGJ5IHNraXBwaW5nIGF1dG9tYXRpYyBtb2R1bGUgZGlzY292ZXJ5IGFuZCByZXF1aXJpbmcgbW9kdWxlcyBkaXJlY3RseS5cbnZhciBtb2R1bGVzID0gW1xuICAgIHJlcXVpcmUoXCIuL2ludGVybmFsXCIpLFxuICAgIHJlcXVpcmUoXCIuL3V0ZjE2XCIpLFxuICAgIHJlcXVpcmUoXCIuL3V0ZjdcIiksXG4gICAgcmVxdWlyZShcIi4vc2Jjcy1jb2RlY1wiKSxcbiAgICByZXF1aXJlKFwiLi9zYmNzLWRhdGFcIiksXG4gICAgcmVxdWlyZShcIi4vc2Jjcy1kYXRhLWdlbmVyYXRlZFwiKSxcbiAgICByZXF1aXJlKFwiLi9kYmNzLWNvZGVjXCIpLFxuICAgIHJlcXVpcmUoXCIuL2RiY3MtZGF0YVwiKSxcbl07XG5cbi8vIFB1dCBhbGwgZW5jb2RpbmcvYWxpYXMvY29kZWMgZGVmaW5pdGlvbnMgdG8gc2luZ2xlIG9iamVjdCBhbmQgZXhwb3J0IGl0LiBcbmZvciAodmFyIGkgPSAwOyBpIDwgbW9kdWxlcy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBtb2R1bGUgPSBtb2R1bGVzW2ldO1xuICAgIGZvciAodmFyIGVuYyBpbiBtb2R1bGUpXG4gICAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwobW9kdWxlLCBlbmMpKVxuICAgICAgICAgICAgZXhwb3J0c1tlbmNdID0gbW9kdWxlW2VuY107XG59XG4iLCIoZnVuY3Rpb24gKEJ1ZmZlcil7XG5cInVzZSBzdHJpY3RcIlxuXG4vLyBFeHBvcnQgTm9kZS5qcyBpbnRlcm5hbCBlbmNvZGluZ3MuXG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICAgIC8vIEVuY29kaW5nc1xuICAgIHV0Zjg6ICAgeyB0eXBlOiBcIl9pbnRlcm5hbFwiLCBib21Bd2FyZTogdHJ1ZX0sXG4gICAgY2VzdTg6ICB7IHR5cGU6IFwiX2ludGVybmFsXCIsIGJvbUF3YXJlOiB0cnVlfSxcbiAgICB1bmljb2RlMTF1dGY4OiBcInV0ZjhcIixcblxuICAgIHVjczI6ICAgeyB0eXBlOiBcIl9pbnRlcm5hbFwiLCBib21Bd2FyZTogdHJ1ZX0sXG4gICAgdXRmMTZsZTogXCJ1Y3MyXCIsXG5cbiAgICBiaW5hcnk6IHsgdHlwZTogXCJfaW50ZXJuYWxcIiB9LFxuICAgIGJhc2U2NDogeyB0eXBlOiBcIl9pbnRlcm5hbFwiIH0sXG4gICAgaGV4OiAgICB7IHR5cGU6IFwiX2ludGVybmFsXCIgfSxcblxuICAgIC8vIENvZGVjLlxuICAgIF9pbnRlcm5hbDogSW50ZXJuYWxDb2RlYyxcbn07XG5cbi8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbmZ1bmN0aW9uIEludGVybmFsQ29kZWMoY29kZWNPcHRpb25zLCBpY29udikge1xuICAgIHRoaXMuZW5jID0gY29kZWNPcHRpb25zLmVuY29kaW5nTmFtZTtcbiAgICB0aGlzLmJvbUF3YXJlID0gY29kZWNPcHRpb25zLmJvbUF3YXJlO1xuXG4gICAgaWYgKHRoaXMuZW5jID09PSBcImJhc2U2NFwiKVxuICAgICAgICB0aGlzLmVuY29kZXIgPSBJbnRlcm5hbEVuY29kZXJCYXNlNjQ7XG4gICAgZWxzZSBpZiAodGhpcy5lbmMgPT09IFwiY2VzdThcIikge1xuICAgICAgICB0aGlzLmVuYyA9IFwidXRmOFwiOyAvLyBVc2UgdXRmOCBmb3IgZGVjb2RpbmcuXG4gICAgICAgIHRoaXMuZW5jb2RlciA9IEludGVybmFsRW5jb2RlckNlc3U4O1xuXG4gICAgICAgIC8vIEFkZCBkZWNvZGVyIGZvciB2ZXJzaW9ucyBvZiBOb2RlIG5vdCBzdXBwb3J0aW5nIENFU1UtOFxuICAgICAgICBpZiAobmV3IEJ1ZmZlcihcImVkYTA4MFwiLCAnaGV4JykudG9TdHJpbmcoKS5sZW5ndGggPT0gMykge1xuICAgICAgICAgICAgdGhpcy5kZWNvZGVyID0gSW50ZXJuYWxEZWNvZGVyQ2VzdTg7XG4gICAgICAgICAgICB0aGlzLmRlZmF1bHRDaGFyVW5pY29kZSA9IGljb252LmRlZmF1bHRDaGFyVW5pY29kZTtcbiAgICAgICAgfVxuICAgIH1cbn1cblxuSW50ZXJuYWxDb2RlYy5wcm90b3R5cGUuZW5jb2RlciA9IEludGVybmFsRW5jb2RlcjtcbkludGVybmFsQ29kZWMucHJvdG90eXBlLmRlY29kZXIgPSBJbnRlcm5hbERlY29kZXI7XG5cbi8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbi8vIFdlIHVzZSBub2RlLmpzIGludGVybmFsIGRlY29kZXIuIEl0cyBzaWduYXR1cmUgaXMgdGhlIHNhbWUgYXMgb3Vycy5cbnZhciBTdHJpbmdEZWNvZGVyID0gcmVxdWlyZSgnc3RyaW5nX2RlY29kZXInKS5TdHJpbmdEZWNvZGVyO1xuXG5pZiAoIVN0cmluZ0RlY29kZXIucHJvdG90eXBlLmVuZCkgLy8gTm9kZSB2MC44IGRvZXNuJ3QgaGF2ZSB0aGlzIG1ldGhvZC5cbiAgICBTdHJpbmdEZWNvZGVyLnByb3RvdHlwZS5lbmQgPSBmdW5jdGlvbigpIHt9O1xuXG5cbmZ1bmN0aW9uIEludGVybmFsRGVjb2RlcihvcHRpb25zLCBjb2RlYykge1xuICAgIFN0cmluZ0RlY29kZXIuY2FsbCh0aGlzLCBjb2RlYy5lbmMpO1xufVxuXG5JbnRlcm5hbERlY29kZXIucHJvdG90eXBlID0gU3RyaW5nRGVjb2Rlci5wcm90b3R5cGU7XG5cblxuLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8vIEVuY29kZXIgaXMgbW9zdGx5IHRyaXZpYWxcblxuZnVuY3Rpb24gSW50ZXJuYWxFbmNvZGVyKG9wdGlvbnMsIGNvZGVjKSB7XG4gICAgdGhpcy5lbmMgPSBjb2RlYy5lbmM7XG59XG5cbkludGVybmFsRW5jb2Rlci5wcm90b3R5cGUud3JpdGUgPSBmdW5jdGlvbihzdHIpIHtcbiAgICByZXR1cm4gbmV3IEJ1ZmZlcihzdHIsIHRoaXMuZW5jKTtcbn1cblxuSW50ZXJuYWxFbmNvZGVyLnByb3RvdHlwZS5lbmQgPSBmdW5jdGlvbigpIHtcbn1cblxuXG4vLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8gRXhjZXB0IGJhc2U2NCBlbmNvZGVyLCB3aGljaCBtdXN0IGtlZXAgaXRzIHN0YXRlLlxuXG5mdW5jdGlvbiBJbnRlcm5hbEVuY29kZXJCYXNlNjQob3B0aW9ucywgY29kZWMpIHtcbiAgICB0aGlzLnByZXZTdHIgPSAnJztcbn1cblxuSW50ZXJuYWxFbmNvZGVyQmFzZTY0LnByb3RvdHlwZS53cml0ZSA9IGZ1bmN0aW9uKHN0cikge1xuICAgIHN0ciA9IHRoaXMucHJldlN0ciArIHN0cjtcbiAgICB2YXIgY29tcGxldGVRdWFkcyA9IHN0ci5sZW5ndGggLSAoc3RyLmxlbmd0aCAlIDQpO1xuICAgIHRoaXMucHJldlN0ciA9IHN0ci5zbGljZShjb21wbGV0ZVF1YWRzKTtcbiAgICBzdHIgPSBzdHIuc2xpY2UoMCwgY29tcGxldGVRdWFkcyk7XG5cbiAgICByZXR1cm4gbmV3IEJ1ZmZlcihzdHIsIFwiYmFzZTY0XCIpO1xufVxuXG5JbnRlcm5hbEVuY29kZXJCYXNlNjQucHJvdG90eXBlLmVuZCA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBuZXcgQnVmZmVyKHRoaXMucHJldlN0ciwgXCJiYXNlNjRcIik7XG59XG5cblxuLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8vIENFU1UtOCBlbmNvZGVyIGlzIGFsc28gc3BlY2lhbC5cblxuZnVuY3Rpb24gSW50ZXJuYWxFbmNvZGVyQ2VzdTgob3B0aW9ucywgY29kZWMpIHtcbn1cblxuSW50ZXJuYWxFbmNvZGVyQ2VzdTgucHJvdG90eXBlLndyaXRlID0gZnVuY3Rpb24oc3RyKSB7XG4gICAgdmFyIGJ1ZiA9IG5ldyBCdWZmZXIoc3RyLmxlbmd0aCAqIDMpLCBidWZJZHggPSAwO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc3RyLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBjaGFyQ29kZSA9IHN0ci5jaGFyQ29kZUF0KGkpO1xuICAgICAgICAvLyBOYWl2ZSBpbXBsZW1lbnRhdGlvbiwgYnV0IGl0IHdvcmtzIGJlY2F1c2UgQ0VTVS04IGlzIGVzcGVjaWFsbHkgZWFzeVxuICAgICAgICAvLyB0byBjb252ZXJ0IGZyb20gVVRGLTE2ICh3aGljaCBhbGwgSlMgc3RyaW5ncyBhcmUgZW5jb2RlZCBpbikuXG4gICAgICAgIGlmIChjaGFyQ29kZSA8IDB4ODApXG4gICAgICAgICAgICBidWZbYnVmSWR4KytdID0gY2hhckNvZGU7XG4gICAgICAgIGVsc2UgaWYgKGNoYXJDb2RlIDwgMHg4MDApIHtcbiAgICAgICAgICAgIGJ1ZltidWZJZHgrK10gPSAweEMwICsgKGNoYXJDb2RlID4+PiA2KTtcbiAgICAgICAgICAgIGJ1ZltidWZJZHgrK10gPSAweDgwICsgKGNoYXJDb2RlICYgMHgzZik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7IC8vIGNoYXJDb2RlIHdpbGwgYWx3YXlzIGJlIDwgMHgxMDAwMCBpbiBqYXZhc2NyaXB0LlxuICAgICAgICAgICAgYnVmW2J1ZklkeCsrXSA9IDB4RTAgKyAoY2hhckNvZGUgPj4+IDEyKTtcbiAgICAgICAgICAgIGJ1ZltidWZJZHgrK10gPSAweDgwICsgKChjaGFyQ29kZSA+Pj4gNikgJiAweDNmKTtcbiAgICAgICAgICAgIGJ1ZltidWZJZHgrK10gPSAweDgwICsgKGNoYXJDb2RlICYgMHgzZik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGJ1Zi5zbGljZSgwLCBidWZJZHgpO1xufVxuXG5JbnRlcm5hbEVuY29kZXJDZXN1OC5wcm90b3R5cGUuZW5kID0gZnVuY3Rpb24oKSB7XG59XG5cbi8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vLyBDRVNVLTggZGVjb2RlciBpcyBub3QgaW1wbGVtZW50ZWQgaW4gTm9kZSB2NC4wK1xuXG5mdW5jdGlvbiBJbnRlcm5hbERlY29kZXJDZXN1OChvcHRpb25zLCBjb2RlYykge1xuICAgIHRoaXMuYWNjID0gMDtcbiAgICB0aGlzLmNvbnRCeXRlcyA9IDA7XG4gICAgdGhpcy5hY2NCeXRlcyA9IDA7XG4gICAgdGhpcy5kZWZhdWx0Q2hhclVuaWNvZGUgPSBjb2RlYy5kZWZhdWx0Q2hhclVuaWNvZGU7XG59XG5cbkludGVybmFsRGVjb2RlckNlc3U4LnByb3RvdHlwZS53cml0ZSA9IGZ1bmN0aW9uKGJ1Zikge1xuICAgIHZhciBhY2MgPSB0aGlzLmFjYywgY29udEJ5dGVzID0gdGhpcy5jb250Qnl0ZXMsIGFjY0J5dGVzID0gdGhpcy5hY2NCeXRlcywgXG4gICAgICAgIHJlcyA9ICcnO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYnVmLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBjdXJCeXRlID0gYnVmW2ldO1xuICAgICAgICBpZiAoKGN1ckJ5dGUgJiAweEMwKSAhPT0gMHg4MCkgeyAvLyBMZWFkaW5nIGJ5dGVcbiAgICAgICAgICAgIGlmIChjb250Qnl0ZXMgPiAwKSB7IC8vIFByZXZpb3VzIGNvZGUgaXMgaW52YWxpZFxuICAgICAgICAgICAgICAgIHJlcyArPSB0aGlzLmRlZmF1bHRDaGFyVW5pY29kZTtcbiAgICAgICAgICAgICAgICBjb250Qnl0ZXMgPSAwO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoY3VyQnl0ZSA8IDB4ODApIHsgLy8gU2luZ2xlLWJ5dGUgY29kZVxuICAgICAgICAgICAgICAgIHJlcyArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGN1ckJ5dGUpO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChjdXJCeXRlIDwgMHhFMCkgeyAvLyBUd28tYnl0ZSBjb2RlXG4gICAgICAgICAgICAgICAgYWNjID0gY3VyQnl0ZSAmIDB4MUY7XG4gICAgICAgICAgICAgICAgY29udEJ5dGVzID0gMTsgYWNjQnl0ZXMgPSAxO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChjdXJCeXRlIDwgMHhGMCkgeyAvLyBUaHJlZS1ieXRlIGNvZGVcbiAgICAgICAgICAgICAgICBhY2MgPSBjdXJCeXRlICYgMHgwRjtcbiAgICAgICAgICAgICAgICBjb250Qnl0ZXMgPSAyOyBhY2NCeXRlcyA9IDE7XG4gICAgICAgICAgICB9IGVsc2UgeyAvLyBGb3VyIG9yIG1vcmUgYXJlIG5vdCBzdXBwb3J0ZWQgZm9yIENFU1UtOC5cbiAgICAgICAgICAgICAgICByZXMgKz0gdGhpcy5kZWZhdWx0Q2hhclVuaWNvZGU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7IC8vIENvbnRpbnVhdGlvbiBieXRlXG4gICAgICAgICAgICBpZiAoY29udEJ5dGVzID4gMCkgeyAvLyBXZSdyZSB3YWl0aW5nIGZvciBpdC5cbiAgICAgICAgICAgICAgICBhY2MgPSAoYWNjIDw8IDYpIHwgKGN1ckJ5dGUgJiAweDNmKTtcbiAgICAgICAgICAgICAgICBjb250Qnl0ZXMtLTsgYWNjQnl0ZXMrKztcbiAgICAgICAgICAgICAgICBpZiAoY29udEJ5dGVzID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIENoZWNrIGZvciBvdmVybG9uZyBlbmNvZGluZywgYnV0IHN1cHBvcnQgTW9kaWZpZWQgVVRGLTggKGVuY29kaW5nIE5VTEwgYXMgQzAgODApXG4gICAgICAgICAgICAgICAgICAgIGlmIChhY2NCeXRlcyA9PT0gMiAmJiBhY2MgPCAweDgwICYmIGFjYyA+IDApXG4gICAgICAgICAgICAgICAgICAgICAgICByZXMgKz0gdGhpcy5kZWZhdWx0Q2hhclVuaWNvZGU7XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKGFjY0J5dGVzID09PSAzICYmIGFjYyA8IDB4ODAwKVxuICAgICAgICAgICAgICAgICAgICAgICAgcmVzICs9IHRoaXMuZGVmYXVsdENoYXJVbmljb2RlO1xuICAgICAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBBY3R1YWxseSBhZGQgY2hhcmFjdGVyLlxuICAgICAgICAgICAgICAgICAgICAgICAgcmVzICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoYWNjKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2UgeyAvLyBVbmV4cGVjdGVkIGNvbnRpbnVhdGlvbiBieXRlXG4gICAgICAgICAgICAgICAgcmVzICs9IHRoaXMuZGVmYXVsdENoYXJVbmljb2RlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHRoaXMuYWNjID0gYWNjOyB0aGlzLmNvbnRCeXRlcyA9IGNvbnRCeXRlczsgdGhpcy5hY2NCeXRlcyA9IGFjY0J5dGVzO1xuICAgIHJldHVybiByZXM7XG59XG5cbkludGVybmFsRGVjb2RlckNlc3U4LnByb3RvdHlwZS5lbmQgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgcmVzID0gMDtcbiAgICBpZiAodGhpcy5jb250Qnl0ZXMgPiAwKVxuICAgICAgICByZXMgKz0gdGhpcy5kZWZhdWx0Q2hhclVuaWNvZGU7XG4gICAgcmV0dXJuIHJlcztcbn1cblxufSkuY2FsbCh0aGlzLHJlcXVpcmUoXCJidWZmZXJcIikuQnVmZmVyKSIsIihmdW5jdGlvbiAoQnVmZmVyKXtcblwidXNlIHN0cmljdFwiXG5cbi8vIFNpbmdsZS1ieXRlIGNvZGVjLiBOZWVkcyBhICdjaGFycycgc3RyaW5nIHBhcmFtZXRlciB0aGF0IGNvbnRhaW5zIDI1NiBvciAxMjggY2hhcnMgdGhhdFxuLy8gY29ycmVzcG9uZCB0byBlbmNvZGVkIGJ5dGVzIChpZiAxMjggLSB0aGVuIGxvd2VyIGhhbGYgaXMgQVNDSUkpLiBcblxuZXhwb3J0cy5fc2JjcyA9IFNCQ1NDb2RlYztcbmZ1bmN0aW9uIFNCQ1NDb2RlYyhjb2RlY09wdGlvbnMsIGljb252KSB7XG4gICAgaWYgKCFjb2RlY09wdGlvbnMpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIlNCQ1MgY29kZWMgaXMgY2FsbGVkIHdpdGhvdXQgdGhlIGRhdGEuXCIpXG4gICAgXG4gICAgLy8gUHJlcGFyZSBjaGFyIGJ1ZmZlciBmb3IgZGVjb2RpbmcuXG4gICAgaWYgKCFjb2RlY09wdGlvbnMuY2hhcnMgfHwgKGNvZGVjT3B0aW9ucy5jaGFycy5sZW5ndGggIT09IDEyOCAmJiBjb2RlY09wdGlvbnMuY2hhcnMubGVuZ3RoICE9PSAyNTYpKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJFbmNvZGluZyAnXCIrY29kZWNPcHRpb25zLnR5cGUrXCInIGhhcyBpbmNvcnJlY3QgJ2NoYXJzJyAobXVzdCBiZSBvZiBsZW4gMTI4IG9yIDI1NilcIik7XG4gICAgXG4gICAgaWYgKGNvZGVjT3B0aW9ucy5jaGFycy5sZW5ndGggPT09IDEyOCkge1xuICAgICAgICB2YXIgYXNjaWlTdHJpbmcgPSBcIlwiO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IDEyODsgaSsrKVxuICAgICAgICAgICAgYXNjaWlTdHJpbmcgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShpKTtcbiAgICAgICAgY29kZWNPcHRpb25zLmNoYXJzID0gYXNjaWlTdHJpbmcgKyBjb2RlY09wdGlvbnMuY2hhcnM7XG4gICAgfVxuXG4gICAgdGhpcy5kZWNvZGVCdWYgPSBuZXcgQnVmZmVyKGNvZGVjT3B0aW9ucy5jaGFycywgJ3VjczInKTtcbiAgICBcbiAgICAvLyBFbmNvZGluZyBidWZmZXIuXG4gICAgdmFyIGVuY29kZUJ1ZiA9IG5ldyBCdWZmZXIoNjU1MzYpO1xuICAgIGVuY29kZUJ1Zi5maWxsKGljb252LmRlZmF1bHRDaGFyU2luZ2xlQnl0ZS5jaGFyQ29kZUF0KDApKTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY29kZWNPcHRpb25zLmNoYXJzLmxlbmd0aDsgaSsrKVxuICAgICAgICBlbmNvZGVCdWZbY29kZWNPcHRpb25zLmNoYXJzLmNoYXJDb2RlQXQoaSldID0gaTtcblxuICAgIHRoaXMuZW5jb2RlQnVmID0gZW5jb2RlQnVmO1xufVxuXG5TQkNTQ29kZWMucHJvdG90eXBlLmVuY29kZXIgPSBTQkNTRW5jb2RlcjtcblNCQ1NDb2RlYy5wcm90b3R5cGUuZGVjb2RlciA9IFNCQ1NEZWNvZGVyO1xuXG5cbmZ1bmN0aW9uIFNCQ1NFbmNvZGVyKG9wdGlvbnMsIGNvZGVjKSB7XG4gICAgdGhpcy5lbmNvZGVCdWYgPSBjb2RlYy5lbmNvZGVCdWY7XG59XG5cblNCQ1NFbmNvZGVyLnByb3RvdHlwZS53cml0ZSA9IGZ1bmN0aW9uKHN0cikge1xuICAgIHZhciBidWYgPSBuZXcgQnVmZmVyKHN0ci5sZW5ndGgpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc3RyLmxlbmd0aDsgaSsrKVxuICAgICAgICBidWZbaV0gPSB0aGlzLmVuY29kZUJ1ZltzdHIuY2hhckNvZGVBdChpKV07XG4gICAgXG4gICAgcmV0dXJuIGJ1Zjtcbn1cblxuU0JDU0VuY29kZXIucHJvdG90eXBlLmVuZCA9IGZ1bmN0aW9uKCkge1xufVxuXG5cbmZ1bmN0aW9uIFNCQ1NEZWNvZGVyKG9wdGlvbnMsIGNvZGVjKSB7XG4gICAgdGhpcy5kZWNvZGVCdWYgPSBjb2RlYy5kZWNvZGVCdWY7XG59XG5cblNCQ1NEZWNvZGVyLnByb3RvdHlwZS53cml0ZSA9IGZ1bmN0aW9uKGJ1Zikge1xuICAgIC8vIFN0cmluZ3MgYXJlIGltbXV0YWJsZSBpbiBKUyAtPiB3ZSB1c2UgdWNzMiBidWZmZXIgdG8gc3BlZWQgdXAgY29tcHV0YXRpb25zLlxuICAgIHZhciBkZWNvZGVCdWYgPSB0aGlzLmRlY29kZUJ1ZjtcbiAgICB2YXIgbmV3QnVmID0gbmV3IEJ1ZmZlcihidWYubGVuZ3RoKjIpO1xuICAgIHZhciBpZHgxID0gMCwgaWR4MiA9IDA7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBidWYubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWR4MSA9IGJ1ZltpXSoyOyBpZHgyID0gaSoyO1xuICAgICAgICBuZXdCdWZbaWR4Ml0gPSBkZWNvZGVCdWZbaWR4MV07XG4gICAgICAgIG5ld0J1ZltpZHgyKzFdID0gZGVjb2RlQnVmW2lkeDErMV07XG4gICAgfVxuICAgIHJldHVybiBuZXdCdWYudG9TdHJpbmcoJ3VjczInKTtcbn1cblxuU0JDU0RlY29kZXIucHJvdG90eXBlLmVuZCA9IGZ1bmN0aW9uKCkge1xufVxuXG59KS5jYWxsKHRoaXMscmVxdWlyZShcImJ1ZmZlclwiKS5CdWZmZXIpIiwiXCJ1c2Ugc3RyaWN0XCJcblxuLy8gR2VuZXJhdGVkIGRhdGEgZm9yIHNiY3MgY29kZWMuIERvbid0IGVkaXQgbWFudWFsbHkuIFJlZ2VuZXJhdGUgdXNpbmcgZ2VuZXJhdGlvbi9nZW4tc2Jjcy5qcyBzY3JpcHQuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgXCI0MzdcIjogXCJjcDQzN1wiLFxuICBcIjczN1wiOiBcImNwNzM3XCIsXG4gIFwiNzc1XCI6IFwiY3A3NzVcIixcbiAgXCI4NTBcIjogXCJjcDg1MFwiLFxuICBcIjg1MlwiOiBcImNwODUyXCIsXG4gIFwiODU1XCI6IFwiY3A4NTVcIixcbiAgXCI4NTZcIjogXCJjcDg1NlwiLFxuICBcIjg1N1wiOiBcImNwODU3XCIsXG4gIFwiODU4XCI6IFwiY3A4NThcIixcbiAgXCI4NjBcIjogXCJjcDg2MFwiLFxuICBcIjg2MVwiOiBcImNwODYxXCIsXG4gIFwiODYyXCI6IFwiY3A4NjJcIixcbiAgXCI4NjNcIjogXCJjcDg2M1wiLFxuICBcIjg2NFwiOiBcImNwODY0XCIsXG4gIFwiODY1XCI6IFwiY3A4NjVcIixcbiAgXCI4NjZcIjogXCJjcDg2NlwiLFxuICBcIjg2OVwiOiBcImNwODY5XCIsXG4gIFwiODc0XCI6IFwid2luZG93czg3NFwiLFxuICBcIjkyMlwiOiBcImNwOTIyXCIsXG4gIFwiMTA0NlwiOiBcImNwMTA0NlwiLFxuICBcIjExMjRcIjogXCJjcDExMjRcIixcbiAgXCIxMTI1XCI6IFwiY3AxMTI1XCIsXG4gIFwiMTEyOVwiOiBcImNwMTEyOVwiLFxuICBcIjExMzNcIjogXCJjcDExMzNcIixcbiAgXCIxMTYxXCI6IFwiY3AxMTYxXCIsXG4gIFwiMTE2MlwiOiBcImNwMTE2MlwiLFxuICBcIjExNjNcIjogXCJjcDExNjNcIixcbiAgXCIxMjUwXCI6IFwid2luZG93czEyNTBcIixcbiAgXCIxMjUxXCI6IFwid2luZG93czEyNTFcIixcbiAgXCIxMjUyXCI6IFwid2luZG93czEyNTJcIixcbiAgXCIxMjUzXCI6IFwid2luZG93czEyNTNcIixcbiAgXCIxMjU0XCI6IFwid2luZG93czEyNTRcIixcbiAgXCIxMjU1XCI6IFwid2luZG93czEyNTVcIixcbiAgXCIxMjU2XCI6IFwid2luZG93czEyNTZcIixcbiAgXCIxMjU3XCI6IFwid2luZG93czEyNTdcIixcbiAgXCIxMjU4XCI6IFwid2luZG93czEyNThcIixcbiAgXCIyODU5MVwiOiBcImlzbzg4NTkxXCIsXG4gIFwiMjg1OTJcIjogXCJpc284ODU5MlwiLFxuICBcIjI4NTkzXCI6IFwiaXNvODg1OTNcIixcbiAgXCIyODU5NFwiOiBcImlzbzg4NTk0XCIsXG4gIFwiMjg1OTVcIjogXCJpc284ODU5NVwiLFxuICBcIjI4NTk2XCI6IFwiaXNvODg1OTZcIixcbiAgXCIyODU5N1wiOiBcImlzbzg4NTk3XCIsXG4gIFwiMjg1OThcIjogXCJpc284ODU5OFwiLFxuICBcIjI4NTk5XCI6IFwiaXNvODg1OTlcIixcbiAgXCIyODYwMFwiOiBcImlzbzg4NTkxMFwiLFxuICBcIjI4NjAxXCI6IFwiaXNvODg1OTExXCIsXG4gIFwiMjg2MDNcIjogXCJpc284ODU5MTNcIixcbiAgXCIyODYwNFwiOiBcImlzbzg4NTkxNFwiLFxuICBcIjI4NjA1XCI6IFwiaXNvODg1OTE1XCIsXG4gIFwiMjg2MDZcIjogXCJpc284ODU5MTZcIixcbiAgXCJ3aW5kb3dzODc0XCI6IHtcbiAgICBcInR5cGVcIjogXCJfc2Jjc1wiLFxuICAgIFwiY2hhcnNcIjogXCLigqzvv73vv73vv73vv73igKbvv73vv73vv73vv73vv73vv73vv73vv73vv73vv73vv73igJjigJnigJzigJ3igKLigJPigJTvv73vv73vv73vv73vv73vv73vv73vv73CoOC4geC4guC4g+C4hOC4heC4huC4h+C4iOC4ieC4iuC4i+C4jOC4jeC4juC4j+C4kOC4keC4kuC4k+C4lOC4leC4luC4l+C4mOC4meC4muC4m+C4nOC4neC4nuC4n+C4oOC4oeC4ouC4o+C4pOC4peC4puC4p+C4qOC4qeC4quC4q+C4rOC4reC4ruC4r+C4sOC4seC4suC4s+C4tOC4teC4tuC4t+C4uOC4ueC4uu+/ve+/ve+/ve+/veC4v+C5gOC5geC5guC5g+C5hOC5heC5huC5h+C5iOC5ieC5iuC5i+C5jOC5jeC5juC5j+C5kOC5keC5kuC5k+C5lOC5leC5luC5l+C5mOC5meC5muC5m++/ve+/ve+/ve+/vVwiXG4gIH0sXG4gIFwid2luODc0XCI6IFwid2luZG93czg3NFwiLFxuICBcImNwODc0XCI6IFwid2luZG93czg3NFwiLFxuICBcIndpbmRvd3MxMjUwXCI6IHtcbiAgICBcInR5cGVcIjogXCJfc2Jjc1wiLFxuICAgIFwiY2hhcnNcIjogXCLigqzvv73igJrvv73igJ7igKbigKDigKHvv73igLDFoOKAucWaxaTFvcW577+94oCY4oCZ4oCc4oCd4oCi4oCT4oCU77+94oSixaHigLrFm8Wlxb7FusKgy4fLmMWBwqTEhMKmwqfCqMKpxZ7Cq8Kswq3CrsW7wrDCscubxYLCtMK1wrbCt8K4xIXFn8K7xL3LncS+xbzFlMOBw4LEgsOExLnEhsOHxIzDicSYw4vEmsONw47EjsSQxYPFh8OTw5TFkMOWw5fFmMWuw5rFsMOcw53FosOfxZXDocOixIPDpMS6xIfDp8SNw6nEmcOrxJvDrcOuxI/EkcWExYjDs8O0xZHDtsO3xZnFr8O6xbHDvMO9xaPLmVwiXG4gIH0sXG4gIFwid2luMTI1MFwiOiBcIndpbmRvd3MxMjUwXCIsXG4gIFwiY3AxMjUwXCI6IFwid2luZG93czEyNTBcIixcbiAgXCJ3aW5kb3dzMTI1MVwiOiB7XG4gICAgXCJ0eXBlXCI6IFwiX3NiY3NcIixcbiAgICBcImNoYXJzXCI6IFwi0ILQg+KAmtGT4oCe4oCm4oCg4oCh4oKs4oCw0InigLnQitCM0IvQj9GS4oCY4oCZ4oCc4oCd4oCi4oCT4oCU77+94oSi0ZnigLrRmtGc0ZvRn8Kg0I7RntCIwqTSkMKmwqfQgcKp0ITCq8Kswq3CrtCHwrDCsdCG0ZbSkcK1wrbCt9GR4oSW0ZTCu9GY0IXRldGX0JDQkdCS0JPQlNCV0JbQl9CY0JnQmtCb0JzQndCe0J/QoNCh0KLQo9Ck0KXQptCn0KjQqdCq0KvQrNCt0K7Qr9Cw0LHQstCz0LTQtdC20LfQuNC50LrQu9C80L3QvtC/0YDRgdGC0YPRhNGF0YbRh9GI0YnRitGL0YzRjdGO0Y9cIlxuICB9LFxuICBcIndpbjEyNTFcIjogXCJ3aW5kb3dzMTI1MVwiLFxuICBcImNwMTI1MVwiOiBcIndpbmRvd3MxMjUxXCIsXG4gIFwid2luZG93czEyNTJcIjoge1xuICAgIFwidHlwZVwiOiBcIl9zYmNzXCIsXG4gICAgXCJjaGFyc1wiOiBcIuKCrO+/veKAmsaS4oCe4oCm4oCg4oChy4bigLDFoOKAucWS77+9xb3vv73vv73igJjigJnigJzigJ3igKLigJPigJTLnOKEosWh4oC6xZPvv73FvsW4wqDCocKiwqPCpMKlwqbCp8KowqnCqsKrwqzCrcKuwq/CsMKxwrLCs8K0wrXCtsK3wrjCucK6wrvCvMK9wr7Cv8OAw4HDgsODw4TDhcOGw4fDiMOJw4rDi8OMw43DjsOPw5DDkcOSw5PDlMOVw5bDl8OYw5nDmsObw5zDncOew5/DoMOhw6LDo8Okw6XDpsOnw6jDqcOqw6vDrMOtw67Dr8Oww7HDssOzw7TDtcO2w7fDuMO5w7rDu8O8w73DvsO/XCJcbiAgfSxcbiAgXCJ3aW4xMjUyXCI6IFwid2luZG93czEyNTJcIixcbiAgXCJjcDEyNTJcIjogXCJ3aW5kb3dzMTI1MlwiLFxuICBcIndpbmRvd3MxMjUzXCI6IHtcbiAgICBcInR5cGVcIjogXCJfc2Jjc1wiLFxuICAgIFwiY2hhcnNcIjogXCLigqzvv73igJrGkuKAnuKApuKAoOKAoe+/veKAsO+/veKAue+/ve+/ve+/ve+/ve+/veKAmOKAmeKAnOKAneKAouKAk+KAlO+/veKEou+/veKAuu+/ve+/ve+/ve+/vcKgzoXOhsKjwqTCpcKmwqfCqMKp77+9wqvCrMKtwq7igJXCsMKxwrLCs86EwrXCtsK3zojOic6KwrvOjMK9zo7Oj86QzpHOks6TzpTOlc6WzpfOmM6ZzprOm86czp3Ons6fzqDOoe+/vc6jzqTOpc6mzqfOqM6pzqrOq86szq3Ors6vzrDOsc6yzrPOtM61zrbOt864zrnOus67zrzOvc6+zr/PgM+Bz4LPg8+Ez4XPhs+Hz4jPic+Kz4vPjM+Nz47vv71cIlxuICB9LFxuICBcIndpbjEyNTNcIjogXCJ3aW5kb3dzMTI1M1wiLFxuICBcImNwMTI1M1wiOiBcIndpbmRvd3MxMjUzXCIsXG4gIFwid2luZG93czEyNTRcIjoge1xuICAgIFwidHlwZVwiOiBcIl9zYmNzXCIsXG4gICAgXCJjaGFyc1wiOiBcIuKCrO+/veKAmsaS4oCe4oCm4oCg4oChy4bigLDFoOKAucWS77+977+977+977+94oCY4oCZ4oCc4oCd4oCi4oCT4oCUy5zihKLFoeKAusWT77+977+9xbjCoMKhwqLCo8KkwqXCpsKnwqjCqcKqwqvCrMKtwq7Cr8KwwrHCssKzwrTCtcK2wrfCuMK5wrrCu8K8wr3CvsK/w4DDgcOCw4PDhMOFw4bDh8OIw4nDisOLw4zDjcOOw4/EnsORw5LDk8OUw5XDlsOXw5jDmcOaw5vDnMSwxZ7Dn8Ogw6HDosOjw6TDpcOmw6fDqMOpw6rDq8Osw63DrsOvxJ/DscOyw7PDtMO1w7bDt8O4w7nDusO7w7zEscWfw79cIlxuICB9LFxuICBcIndpbjEyNTRcIjogXCJ3aW5kb3dzMTI1NFwiLFxuICBcImNwMTI1NFwiOiBcIndpbmRvd3MxMjU0XCIsXG4gIFwid2luZG93czEyNTVcIjoge1xuICAgIFwidHlwZVwiOiBcIl9zYmNzXCIsXG4gICAgXCJjaGFyc1wiOiBcIuKCrO+/veKAmsaS4oCe4oCm4oCg4oChy4bigLDvv73igLnvv73vv73vv73vv73vv73igJjigJnigJzigJ3igKLigJPigJTLnOKEou+/veKAuu+/ve+/ve+/ve+/vcKgwqHCosKj4oKqwqXCpsKnwqjCqcOXwqvCrMKtwq7Cr8KwwrHCssKzwrTCtcK2wrfCuMK5w7fCu8K8wr3CvsK/1rDWsday1rPWtNa11rbWt9a41rnvv73Wu9a81r3Wvta/14DXgdeC14PXsNex17LXs9e077+977+977+977+977+977+977+915DXkdeS15PXlNeV15bXl9eY15nXmteb15zXndee15/XoNeh16LXo9ek16XXpten16jXqdeq77+977+94oCO4oCP77+9XCJcbiAgfSxcbiAgXCJ3aW4xMjU1XCI6IFwid2luZG93czEyNTVcIixcbiAgXCJjcDEyNTVcIjogXCJ3aW5kb3dzMTI1NVwiLFxuICBcIndpbmRvd3MxMjU2XCI6IHtcbiAgICBcInR5cGVcIjogXCJfc2Jjc1wiLFxuICAgIFwiY2hhcnNcIjogXCLigqzZvuKAmsaS4oCe4oCm4oCg4oChy4bigLDZueKAucWS2obamNqI2q/igJjigJnigJzigJ3igKLigJPigJTaqeKEotqR4oC6xZPigIzigI3ausKg2IzCosKjwqTCpcKmwqfCqMKp2r7Cq8Kswq3CrsKvwrDCscKywrPCtMK1wrbCt8K4wrnYm8K7wrzCvcK+2J/bgdih2KLYo9ik2KXYptin2KjYqdiq2KvYrNit2K7Yr9iw2LHYstiz2LTYtdi2w5fYt9i42LnYutmA2YHZgtmDw6DZhMOi2YXZhtmH2YjDp8Oow6nDqsOr2YnZisOuw6/Zi9mM2Y3ZjsO02Y/ZkMO32ZHDudmSw7vDvOKAjuKAj9uSXCJcbiAgfSxcbiAgXCJ3aW4xMjU2XCI6IFwid2luZG93czEyNTZcIixcbiAgXCJjcDEyNTZcIjogXCJ3aW5kb3dzMTI1NlwiLFxuICBcIndpbmRvd3MxMjU3XCI6IHtcbiAgICBcInR5cGVcIjogXCJfc2Jjc1wiLFxuICAgIFwiY2hhcnNcIjogXCLigqzvv73igJrvv73igJ7igKbigKDigKHvv73igLDvv73igLnvv73CqMuHwrjvv73igJjigJnigJzigJ3igKLigJPigJTvv73ihKLvv73igLrvv73Cr8ub77+9wqDvv73CosKjwqTvv73CpsKnw5jCqcWWwqvCrMKtwq7DhsKwwrHCssKzwrTCtcK2wrfDuMK5xZfCu8K8wr3CvsOmxITErsSAxIbDhMOFxJjEksSMw4nFucSWxKLEtsSqxLvFoMWDxYXDk8WMw5XDlsOXxbLFgcWaxarDnMW7xb3Dn8SFxK/EgcSHw6TDpcSZxJPEjcOpxbrEl8SjxLfEq8S8xaHFhMWGw7PFjcO1w7bDt8WzxYLFm8Wrw7zFvMW+y5lcIlxuICB9LFxuICBcIndpbjEyNTdcIjogXCJ3aW5kb3dzMTI1N1wiLFxuICBcImNwMTI1N1wiOiBcIndpbmRvd3MxMjU3XCIsXG4gIFwid2luZG93czEyNThcIjoge1xuICAgIFwidHlwZVwiOiBcIl9zYmNzXCIsXG4gICAgXCJjaGFyc1wiOiBcIuKCrO+/veKAmsaS4oCe4oCm4oCg4oChy4bigLDvv73igLnFku+/ve+/ve+/ve+/veKAmOKAmeKAnOKAneKAouKAk+KAlMuc4oSi77+94oC6xZPvv73vv73FuMKgwqHCosKjwqTCpcKmwqfCqMKpwqrCq8Kswq3CrsKvwrDCscKywrPCtMK1wrbCt8K4wrnCusK7wrzCvcK+wr/DgMOBw4LEgsOEw4XDhsOHw4jDicOKw4vMgMONw47Dj8SQw5HMicOTw5TGoMOWw5fDmMOZw5rDm8Ocxq/Mg8Ofw6DDocOixIPDpMOlw6bDp8Oow6nDqsOrzIHDrcOuw6/EkcOxzKPDs8O0xqHDtsO3w7jDucO6w7vDvMaw4oKrw79cIlxuICB9LFxuICBcIndpbjEyNThcIjogXCJ3aW5kb3dzMTI1OFwiLFxuICBcImNwMTI1OFwiOiBcIndpbmRvd3MxMjU4XCIsXG4gIFwiaXNvODg1OTFcIjoge1xuICAgIFwidHlwZVwiOiBcIl9zYmNzXCIsXG4gICAgXCJjaGFyc1wiOiBcIsKAwoHCgsKDwoTChcKGwofCiMKJworCi8KMwo3CjsKPwpDCkcKSwpPClMKVwpbCl8KYwpnCmsKbwpzCncKewp/CoMKhwqLCo8KkwqXCpsKnwqjCqcKqwqvCrMKtwq7Cr8KwwrHCssKzwrTCtcK2wrfCuMK5wrrCu8K8wr3CvsK/w4DDgcOCw4PDhMOFw4bDh8OIw4nDisOLw4zDjcOOw4/DkMORw5LDk8OUw5XDlsOXw5jDmcOaw5vDnMOdw57Dn8Ogw6HDosOjw6TDpcOmw6fDqMOpw6rDq8Osw63DrsOvw7DDscOyw7PDtMO1w7bDt8O4w7nDusO7w7zDvcO+w79cIlxuICB9LFxuICBcImNwMjg1OTFcIjogXCJpc284ODU5MVwiLFxuICBcImlzbzg4NTkyXCI6IHtcbiAgICBcInR5cGVcIjogXCJfc2Jjc1wiLFxuICAgIFwiY2hhcnNcIjogXCLCgMKBwoLCg8KEwoXChsKHwojCicKKwovCjMKNwo7Cj8KQwpHCksKTwpTClcKWwpfCmMKZwprCm8Kcwp3CnsKfwqDEhMuYxYHCpMS9xZrCp8KoxaDFnsWkxbnCrcW9xbvCsMSFy5vFgsK0xL7Fm8uHwrjFocWfxaXFusudxb7FvMWUw4HDgsSCw4TEucSGw4fEjMOJxJjDi8Saw43DjsSOxJDFg8WHw5PDlMWQw5bDl8WYxa7DmsWww5zDncWiw5/FlcOhw6LEg8OkxLrEh8OnxI3DqcSZw6vEm8Otw67Ej8SRxYTFiMOzw7TFkcO2w7fFmcWvw7rFscO8w73Fo8uZXCJcbiAgfSxcbiAgXCJjcDI4NTkyXCI6IFwiaXNvODg1OTJcIixcbiAgXCJpc284ODU5M1wiOiB7XG4gICAgXCJ0eXBlXCI6IFwiX3NiY3NcIixcbiAgICBcImNoYXJzXCI6IFwiwoDCgcKCwoPChMKFwobCh8KIwonCisKLwozCjcKOwo/CkMKRwpLCk8KUwpXClsKXwpjCmcKawpvCnMKdwp7Cn8KgxKbLmMKjwqTvv73EpMKnwqjEsMWexJ7EtMKt77+9xbvCsMSnwrLCs8K0wrXEpcK3wrjEscWfxJ/EtcK977+9xbzDgMOBw4Lvv73DhMSKxIjDh8OIw4nDisOLw4zDjcOOw4/vv73DkcOSw5PDlMSgw5bDl8Scw5nDmsObw5zFrMWcw5/DoMOhw6Lvv73DpMSLxInDp8Oow6nDqsOrw6zDrcOuw6/vv73DscOyw7PDtMShw7bDt8Sdw7nDusO7w7zFrcWdy5lcIlxuICB9LFxuICBcImNwMjg1OTNcIjogXCJpc284ODU5M1wiLFxuICBcImlzbzg4NTk0XCI6IHtcbiAgICBcInR5cGVcIjogXCJfc2Jjc1wiLFxuICAgIFwiY2hhcnNcIjogXCLCgMKBwoLCg8KEwoXChsKHwojCicKKwovCjMKNwo7Cj8KQwpHCksKTwpTClcKWwpfCmMKZwprCm8Kcwp3CnsKfwqDEhMS4xZbCpMSoxLvCp8KoxaDEksSixabCrcW9wq/CsMSFy5vFl8K0xKnEvMuHwrjFocSTxKPFp8WKxb7Fi8SAw4HDgsODw4TDhcOGxK7EjMOJxJjDi8SWw43DjsSqxJDFhcWMxLbDlMOVw5bDl8OYxbLDmsObw5zFqMWqw5/EgcOhw6LDo8Okw6XDpsSvxI3DqcSZw6vEl8Otw67Eq8SRxYbFjcS3w7TDtcO2w7fDuMWzw7rDu8O8xanFq8uZXCJcbiAgfSxcbiAgXCJjcDI4NTk0XCI6IFwiaXNvODg1OTRcIixcbiAgXCJpc284ODU5NVwiOiB7XG4gICAgXCJ0eXBlXCI6IFwiX3NiY3NcIixcbiAgICBcImNoYXJzXCI6IFwiwoDCgcKCwoPChMKFwobCh8KIwonCisKLwozCjcKOwo/CkMKRwpLCk8KUwpXClsKXwpjCmcKawpvCnMKdwp7Cn8Kg0IHQgtCD0ITQhdCG0IfQiNCJ0IrQi9CMwq3QjtCP0JDQkdCS0JPQlNCV0JbQl9CY0JnQmtCb0JzQndCe0J/QoNCh0KLQo9Ck0KXQptCn0KjQqdCq0KvQrNCt0K7Qr9Cw0LHQstCz0LTQtdC20LfQuNC50LrQu9C80L3QvtC/0YDRgdGC0YPRhNGF0YbRh9GI0YnRitGL0YzRjdGO0Y/ihJbRkdGS0ZPRlNGV0ZbRl9GY0ZnRmtGb0ZzCp9Ge0Z9cIlxuICB9LFxuICBcImNwMjg1OTVcIjogXCJpc284ODU5NVwiLFxuICBcImlzbzg4NTk2XCI6IHtcbiAgICBcInR5cGVcIjogXCJfc2Jjc1wiLFxuICAgIFwiY2hhcnNcIjogXCLCgMKBwoLCg8KEwoXChsKHwojCicKKwovCjMKNwo7Cj8KQwpHCksKTwpTClcKWwpfCmMKZwprCm8Kcwp3CnsKfwqDvv73vv73vv73CpO+/ve+/ve+/ve+/ve+/ve+/ve+/vdiMwq3vv73vv73vv73vv73vv73vv73vv73vv73vv73vv73vv73vv73vv73Ym++/ve+/ve+/vdif77+92KHYotij2KTYpdim2KfYqNip2KrYq9is2K3Yrtiv2LDYsdiy2LPYtNi12LbYt9i42LnYuu+/ve+/ve+/ve+/ve+/vdmA2YHZgtmD2YTZhdmG2YfZiNmJ2YrZi9mM2Y3ZjtmP2ZDZkdmS77+977+977+977+977+977+977+977+977+977+977+977+977+9XCJcbiAgfSxcbiAgXCJjcDI4NTk2XCI6IFwiaXNvODg1OTZcIixcbiAgXCJpc284ODU5N1wiOiB7XG4gICAgXCJ0eXBlXCI6IFwiX3NiY3NcIixcbiAgICBcImNoYXJzXCI6IFwiwoDCgcKCwoPChMKFwobCh8KIwonCisKLwozCjcKOwo/CkMKRwpLCk8KUwpXClsKXwpjCmcKawpvCnMKdwp7Cn8Kg4oCY4oCZwqPigqzigq/CpsKnwqjCqc26wqvCrMKt77+94oCVwrDCscKywrPOhM6FzobCt86IzonOisK7zozCvc6Ozo/OkM6RzpLOk86UzpXOls6XzpjOmc6azpvOnM6dzp7On86gzqHvv73Oo86kzqXOps6nzqjOqc6qzqvOrM6tzq7Or86wzrHOss6zzrTOtc62zrfOuM65zrrOu868zr3Ovs6/z4DPgc+Cz4PPhM+Fz4bPh8+Iz4nPis+Lz4zPjc+O77+9XCJcbiAgfSxcbiAgXCJjcDI4NTk3XCI6IFwiaXNvODg1OTdcIixcbiAgXCJpc284ODU5OFwiOiB7XG4gICAgXCJ0eXBlXCI6IFwiX3NiY3NcIixcbiAgICBcImNoYXJzXCI6IFwiwoDCgcKCwoPChMKFwobCh8KIwonCisKLwozCjcKOwo/CkMKRwpLCk8KUwpXClsKXwpjCmcKawpvCnMKdwp7Cn8Kg77+9wqLCo8KkwqXCpsKnwqjCqcOXwqvCrMKtwq7Cr8KwwrHCssKzwrTCtcK2wrfCuMK5w7fCu8K8wr3Cvu+/ve+/ve+/ve+/ve+/ve+/ve+/ve+/ve+/ve+/ve+/ve+/ve+/ve+/ve+/ve+/ve+/ve+/ve+/ve+/ve+/ve+/ve+/ve+/ve+/ve+/ve+/ve+/ve+/ve+/ve+/ve+/veKAl9eQ15HXkteT15TXldeW15fXmNeZ15rXm9ec153Xntef16DXodei16PXpNel16bXp9eo16nXqu+/ve+/veKAjuKAj++/vVwiXG4gIH0sXG4gIFwiY3AyODU5OFwiOiBcImlzbzg4NTk4XCIsXG4gIFwiaXNvODg1OTlcIjoge1xuICAgIFwidHlwZVwiOiBcIl9zYmNzXCIsXG4gICAgXCJjaGFyc1wiOiBcIsKAwoHCgsKDwoTChcKGwofCiMKJworCi8KMwo3CjsKPwpDCkcKSwpPClMKVwpbCl8KYwpnCmsKbwpzCncKewp/CoMKhwqLCo8KkwqXCpsKnwqjCqcKqwqvCrMKtwq7Cr8KwwrHCssKzwrTCtcK2wrfCuMK5wrrCu8K8wr3CvsK/w4DDgcOCw4PDhMOFw4bDh8OIw4nDisOLw4zDjcOOw4/EnsORw5LDk8OUw5XDlsOXw5jDmcOaw5vDnMSwxZ7Dn8Ogw6HDosOjw6TDpcOmw6fDqMOpw6rDq8Osw63DrsOvxJ/DscOyw7PDtMO1w7bDt8O4w7nDusO7w7zEscWfw79cIlxuICB9LFxuICBcImNwMjg1OTlcIjogXCJpc284ODU5OVwiLFxuICBcImlzbzg4NTkxMFwiOiB7XG4gICAgXCJ0eXBlXCI6IFwiX3NiY3NcIixcbiAgICBcImNoYXJzXCI6IFwiwoDCgcKCwoPChMKFwobCh8KIwonCisKLwozCjcKOwo/CkMKRwpLCk8KUwpXClsKXwpjCmcKawpvCnMKdwp7Cn8KgxITEksSixKrEqMS2wqfEu8SQxaDFpsW9wq3FqsWKwrDEhcSTxKPEq8SpxLfCt8S8xJHFocWnxb7igJXFq8WLxIDDgcOCw4PDhMOFw4bErsSMw4nEmMOLxJbDjcOOw4/DkMWFxYzDk8OUw5XDlsWow5jFssOaw5vDnMOdw57Dn8SBw6HDosOjw6TDpcOmxK/EjcOpxJnDq8SXw63DrsOvw7DFhsWNw7PDtMO1w7bFqcO4xbPDusO7w7zDvcO+xLhcIlxuICB9LFxuICBcImNwMjg2MDBcIjogXCJpc284ODU5MTBcIixcbiAgXCJpc284ODU5MTFcIjoge1xuICAgIFwidHlwZVwiOiBcIl9zYmNzXCIsXG4gICAgXCJjaGFyc1wiOiBcIsKAwoHCgsKDwoTChcKGwofCiMKJworCi8KMwo3CjsKPwpDCkcKSwpPClMKVwpbCl8KYwpnCmsKbwpzCncKewp/CoOC4geC4guC4g+C4hOC4heC4huC4h+C4iOC4ieC4iuC4i+C4jOC4jeC4juC4j+C4kOC4keC4kuC4k+C4lOC4leC4luC4l+C4mOC4meC4muC4m+C4nOC4neC4nuC4n+C4oOC4oeC4ouC4o+C4pOC4peC4puC4p+C4qOC4qeC4quC4q+C4rOC4reC4ruC4r+C4sOC4seC4suC4s+C4tOC4teC4tuC4t+C4uOC4ueC4uu+/ve+/ve+/ve+/veC4v+C5gOC5geC5guC5g+C5hOC5heC5huC5h+C5iOC5ieC5iuC5i+C5jOC5jeC5juC5j+C5kOC5keC5kuC5k+C5lOC5leC5luC5l+C5mOC5meC5muC5m++/ve+/ve+/ve+/vVwiXG4gIH0sXG4gIFwiY3AyODYwMVwiOiBcImlzbzg4NTkxMVwiLFxuICBcImlzbzg4NTkxM1wiOiB7XG4gICAgXCJ0eXBlXCI6IFwiX3NiY3NcIixcbiAgICBcImNoYXJzXCI6IFwiwoDCgcKCwoPChMKFwobCh8KIwonCisKLwozCjcKOwo/CkMKRwpLCk8KUwpXClsKXwpjCmcKawpvCnMKdwp7Cn8Kg4oCdwqLCo8Kk4oCewqbCp8OYwqnFlsKrwqzCrcKuw4bCsMKxwrLCs+KAnMK1wrbCt8O4wrnFl8K7wrzCvcK+w6bEhMSuxIDEhsOEw4XEmMSSxIzDicW5xJbEosS2xKrEu8WgxYPFhcOTxYzDlcOWw5fFssWBxZrFqsOcxbvFvcOfxIXEr8SBxIfDpMOlxJnEk8SNw6nFusSXxKPEt8SrxLzFocWExYbDs8WNw7XDtsO3xbPFgsWbxavDvMW8xb7igJlcIlxuICB9LFxuICBcImNwMjg2MDNcIjogXCJpc284ODU5MTNcIixcbiAgXCJpc284ODU5MTRcIjoge1xuICAgIFwidHlwZVwiOiBcIl9zYmNzXCIsXG4gICAgXCJjaGFyc1wiOiBcIsKAwoHCgsKDwoTChcKGwofCiMKJworCi8KMwo3CjsKPwpDCkcKSwpPClMKVwpbCl8KYwpnCmsKbwpzCncKewp/CoOG4guG4g8KjxIrEi+G4isKn4bqAwqnhuoLhuIvhu7LCrcKuxbjhuJ7huJ/EoMSh4bmA4bmBwrbhuZbhuoHhuZfhuoPhuaDhu7PhuoThuoXhuaHDgMOBw4LDg8OEw4XDhsOHw4jDicOKw4vDjMONw47Dj8W0w5HDksOTw5TDlcOW4bmqw5jDmcOaw5vDnMOdxbbDn8Ogw6HDosOjw6TDpcOmw6fDqMOpw6rDq8Osw63DrsOvxbXDscOyw7PDtMO1w7bhuavDuMO5w7rDu8O8w73Ft8O/XCJcbiAgfSxcbiAgXCJjcDI4NjA0XCI6IFwiaXNvODg1OTE0XCIsXG4gIFwiaXNvODg1OTE1XCI6IHtcbiAgICBcInR5cGVcIjogXCJfc2Jjc1wiLFxuICAgIFwiY2hhcnNcIjogXCLCgMKBwoLCg8KEwoXChsKHwojCicKKwovCjMKNwo7Cj8KQwpHCksKTwpTClcKWwpfCmMKZwprCm8Kcwp3CnsKfwqDCocKiwqPigqzCpcWgwqfFocKpwqrCq8Kswq3CrsKvwrDCscKywrPFvcK1wrbCt8W+wrnCusK7xZLFk8W4wr/DgMOBw4LDg8OEw4XDhsOHw4jDicOKw4vDjMONw47Dj8OQw5HDksOTw5TDlcOWw5fDmMOZw5rDm8Ocw53DnsOfw6DDocOiw6PDpMOlw6bDp8Oow6nDqsOrw6zDrcOuw6/DsMOxw7LDs8O0w7XDtsO3w7jDucO6w7vDvMO9w77Dv1wiXG4gIH0sXG4gIFwiY3AyODYwNVwiOiBcImlzbzg4NTkxNVwiLFxuICBcImlzbzg4NTkxNlwiOiB7XG4gICAgXCJ0eXBlXCI6IFwiX3NiY3NcIixcbiAgICBcImNoYXJzXCI6IFwiwoDCgcKCwoPChMKFwobCh8KIwonCisKLwozCjcKOwo/CkMKRwpLCk8KUwpXClsKXwpjCmcKawpvCnMKdwp7Cn8KgxITEhcWB4oKs4oCexaDCp8WhwqnImMKrxbnCrcW6xbvCsMKxxIzFgsW94oCdwrbCt8W+xI3ImcK7xZLFk8W4xbzDgMOBw4LEgsOExIbDhsOHw4jDicOKw4vDjMONw47Dj8SQxYPDksOTw5TFkMOWxZrFsMOZw5rDm8OcxJjImsOfw6DDocOixIPDpMSHw6bDp8Oow6nDqsOrw6zDrcOuw6/EkcWEw7LDs8O0xZHDtsWbxbHDucO6w7vDvMSZyJvDv1wiXG4gIH0sXG4gIFwiY3AyODYwNlwiOiBcImlzbzg4NTkxNlwiLFxuICBcImNwNDM3XCI6IHtcbiAgICBcInR5cGVcIjogXCJfc2Jjc1wiLFxuICAgIFwiY2hhcnNcIjogXCLDh8O8w6nDosOkw6DDpcOnw6rDq8Oow6/DrsOsw4TDhcOJw6bDhsO0w7bDssO7w7nDv8OWw5zCosKjwqXigqfGksOhw63Ds8O6w7HDkcKqwrrCv+KMkMKswr3CvMKhwqvCu+KWkeKWkuKWk+KUguKUpOKVoeKVouKVluKVleKVo+KVkeKVl+KVneKVnOKVm+KUkOKUlOKUtOKUrOKUnOKUgOKUvOKVnuKVn+KVmuKVlOKVqeKVpuKVoOKVkOKVrOKVp+KVqOKVpOKVpeKVmeKVmOKVkuKVk+KVq+KVquKUmOKUjOKWiOKWhOKWjOKWkOKWgM6xw5/Ok8+AzqPPg8K1z4TOps6YzqnOtOKIns+GzrXiiKniiaHCseKJpeKJpOKMoOKMocO34omIwrDiiJnCt+KImuKBv8Ky4pagwqBcIlxuICB9LFxuICBcImlibTQzN1wiOiBcImNwNDM3XCIsXG4gIFwiY3NpYm00MzdcIjogXCJjcDQzN1wiLFxuICBcImNwNzM3XCI6IHtcbiAgICBcInR5cGVcIjogXCJfc2Jjc1wiLFxuICAgIFwiY2hhcnNcIjogXCLOkc6SzpPOlM6VzpbOl86YzpnOms6bzpzOnc6ezp/OoM6hzqPOpM6lzqbOp86ozqnOsc6yzrPOtM61zrbOt864zrnOus67zrzOvc6+zr/PgM+Bz4PPgs+Ez4XPhs+Hz4jilpHilpLilpPilILilKTilaHilaLilZbilZXilaPilZHilZfilZ3ilZzilZvilJDilJTilLTilKzilJzilIDilLzilZ7ilZ/ilZrilZTilanilabilaDilZDilazilafilajilaTilaXilZnilZjilZLilZPilavilarilJjilIzilojiloTilozilpDiloDPic6szq3Ors+Kzq/PjM+Nz4vPjs6GzojOic6KzozOjs6PwrHiiaXiiaTOqs6rw7fiiYjCsOKImcK34oia4oG/wrLilqDCoFwiXG4gIH0sXG4gIFwiaWJtNzM3XCI6IFwiY3A3MzdcIixcbiAgXCJjc2libTczN1wiOiBcImNwNzM3XCIsXG4gIFwiY3A3NzVcIjoge1xuICAgIFwidHlwZVwiOiBcIl9zYmNzXCIsXG4gICAgXCJjaGFyc1wiOiBcIsSGw7zDqcSBw6TEo8OlxIfFgsSTxZbFl8SrxbnDhMOFw4nDpsOGxY3DtsSiwqLFmsWbw5bDnMO4wqPDmMOXwqTEgMSqw7PFu8W8xbrigJ3CpsKpwq7CrMK9wrzFgcKrwrvilpHilpLilpPilILilKTEhMSMxJjEluKVo+KVkeKVl+KVncSuxaDilJDilJTilLTilKzilJzilIDilLzFssWq4pWa4pWU4pWp4pWm4pWg4pWQ4pWsxb3EhcSNxJnEl8SvxaHFs8Wrxb7ilJjilIzilojiloTilozilpDiloDDk8OfxYzFg8O1w5XCtcWExLbEt8S7xLzFhsSSxYXigJnCrcKx4oCcwr7CtsKnw7figJ7CsOKImcK3wrnCs8Ky4pagwqBcIlxuICB9LFxuICBcImlibTc3NVwiOiBcImNwNzc1XCIsXG4gIFwiY3NpYm03NzVcIjogXCJjcDc3NVwiLFxuICBcImNwODUwXCI6IHtcbiAgICBcInR5cGVcIjogXCJfc2Jjc1wiLFxuICAgIFwiY2hhcnNcIjogXCLDh8O8w6nDosOkw6DDpcOnw6rDq8Oow6/DrsOsw4TDhcOJw6bDhsO0w7bDssO7w7nDv8OWw5zDuMKjw5jDl8aSw6HDrcOzw7rDscORwqrCusK/wq7CrMK9wrzCocKrwrvilpHilpLilpPilILilKTDgcOCw4DCqeKVo+KVkeKVl+KVncKiwqXilJDilJTilLTilKzilJzilIDilLzDo8OD4pWa4pWU4pWp4pWm4pWg4pWQ4pWswqTDsMOQw4rDi8OIxLHDjcOOw4/ilJjilIzilojiloTCpsOM4paAw5PDn8OUw5LDtcOVwrXDvsOew5rDm8OZw73DncKvwrTCrcKx4oCXwr7CtsKnw7fCuMKwwqjCt8K5wrPCsuKWoMKgXCJcbiAgfSxcbiAgXCJpYm04NTBcIjogXCJjcDg1MFwiLFxuICBcImNzaWJtODUwXCI6IFwiY3A4NTBcIixcbiAgXCJjcDg1MlwiOiB7XG4gICAgXCJ0eXBlXCI6IFwiX3NiY3NcIixcbiAgICBcImNoYXJzXCI6IFwiw4fDvMOpw6LDpMWvxIfDp8WCw6vFkMWRw67FucOExIbDicS5xLrDtMO2xL3EvsWaxZvDlsOcxaTFpcWBw5fEjcOhw63Ds8O6xITEhcW9xb7EmMSZwqzFusSMxZ/Cq8K74paR4paS4paT4pSC4pSkw4HDgsSaxZ7ilaPilZHilZfilZ3Fu8W84pSQ4pSU4pS04pSs4pSc4pSA4pS8xILEg+KVmuKVlOKVqeKVpuKVoOKVkOKVrMKkxJHEkMSOw4vEj8WHw43DjsSb4pSY4pSM4paI4paExaLFruKWgMOTw5/DlMWDxYTFiMWgxaHFlMOaxZXFsMO9w53Fo8K0wq3Lncuby4fLmMKnw7fCuMKwwqjLmcWxxZjFmeKWoMKgXCJcbiAgfSxcbiAgXCJpYm04NTJcIjogXCJjcDg1MlwiLFxuICBcImNzaWJtODUyXCI6IFwiY3A4NTJcIixcbiAgXCJjcDg1NVwiOiB7XG4gICAgXCJ0eXBlXCI6IFwiX3NiY3NcIixcbiAgICBcImNoYXJzXCI6IFwi0ZLQgtGT0IPRkdCB0ZTQhNGV0IXRltCG0ZfQh9GY0IjRmdCJ0ZrQitGb0IvRnNCM0Z7QjtGf0I/RjtCu0YrQqtCw0JDQsdCR0YbQptC00JTQtdCV0YTQpNCz0JPCq8K74paR4paS4paT4pSC4pSk0YXQpdC40JjilaPilZHilZfilZ3QudCZ4pSQ4pSU4pS04pSs4pSc4pSA4pS80LrQmuKVmuKVlOKVqeKVpuKVoOKVkOKVrMKk0LvQm9C80JzQvdCd0L7QntC/4pSY4pSM4paI4paE0J/Rj+KWgNCv0YDQoNGB0KHRgtCi0YPQo9C20JbQstCS0YzQrOKElsKt0YvQq9C30JfRiNCo0Y3QrdGJ0KnRh9CnwqfilqDCoFwiXG4gIH0sXG4gIFwiaWJtODU1XCI6IFwiY3A4NTVcIixcbiAgXCJjc2libTg1NVwiOiBcImNwODU1XCIsXG4gIFwiY3A4NTZcIjoge1xuICAgIFwidHlwZVwiOiBcIl9zYmNzXCIsXG4gICAgXCJjaGFyc1wiOiBcIteQ15HXkteT15TXldeW15fXmNeZ15rXm9ec153Xntef16DXodei16PXpNel16bXp9eo16nXqu+/vcKj77+9w5fvv73vv73vv73vv73vv73vv73vv73vv73vv73vv73CrsKswr3CvO+/vcKrwrvilpHilpLilpPilILilKTvv73vv73vv73CqeKVo+KVkeKVl+KVncKiwqXilJDilJTilLTilKzilJzilIDilLzvv73vv73ilZrilZTilanilabilaDilZDilazCpO+/ve+/ve+/ve+/ve+/ve+/ve+/ve+/ve+/veKUmOKUjOKWiOKWhMKm77+94paA77+977+977+977+977+977+9wrXvv73vv73vv73vv73vv73vv73vv73Cr8K0wq3CseKAl8K+wrbCp8O3wrjCsMKowrfCucKzwrLilqDCoFwiXG4gIH0sXG4gIFwiaWJtODU2XCI6IFwiY3A4NTZcIixcbiAgXCJjc2libTg1NlwiOiBcImNwODU2XCIsXG4gIFwiY3A4NTdcIjoge1xuICAgIFwidHlwZVwiOiBcIl9zYmNzXCIsXG4gICAgXCJjaGFyc1wiOiBcIsOHw7zDqcOiw6TDoMOlw6fDqsOrw6jDr8OuxLHDhMOFw4nDpsOGw7TDtsOyw7vDucSww5bDnMO4wqPDmMWexZ/DocOtw7PDusOxw5HEnsSfwr/CrsKswr3CvMKhwqvCu+KWkeKWkuKWk+KUguKUpMOBw4LDgMKp4pWj4pWR4pWX4pWdwqLCpeKUkOKUlOKUtOKUrOKUnOKUgOKUvMOjw4PilZrilZTilanilabilaDilZDilazCpMK6wqrDisOLw4jvv73DjcOOw4/ilJjilIzilojiloTCpsOM4paAw5PDn8OUw5LDtcOVwrXvv73Dl8Oaw5vDmcOsw7/Cr8K0wq3Cse+/vcK+wrbCp8O3wrjCsMKowrfCucKzwrLilqDCoFwiXG4gIH0sXG4gIFwiaWJtODU3XCI6IFwiY3A4NTdcIixcbiAgXCJjc2libTg1N1wiOiBcImNwODU3XCIsXG4gIFwiY3A4NThcIjoge1xuICAgIFwidHlwZVwiOiBcIl9zYmNzXCIsXG4gICAgXCJjaGFyc1wiOiBcIsOHw7zDqcOiw6TDoMOlw6fDqsOrw6jDr8Ouw6zDhMOFw4nDpsOGw7TDtsOyw7vDucO/w5bDnMO4wqPDmMOXxpLDocOtw7PDusOxw5HCqsK6wr/CrsKswr3CvMKhwqvCu+KWkeKWkuKWk+KUguKUpMOBw4LDgMKp4pWj4pWR4pWX4pWdwqLCpeKUkOKUlOKUtOKUrOKUnOKUgOKUvMOjw4PilZrilZTilanilabilaDilZDilazCpMOww5DDisOLw4jigqzDjcOOw4/ilJjilIzilojiloTCpsOM4paAw5PDn8OUw5LDtcOVwrXDvsOew5rDm8OZw73DncKvwrTCrcKx4oCXwr7CtsKnw7fCuMKwwqjCt8K5wrPCsuKWoMKgXCJcbiAgfSxcbiAgXCJpYm04NThcIjogXCJjcDg1OFwiLFxuICBcImNzaWJtODU4XCI6IFwiY3A4NThcIixcbiAgXCJjcDg2MFwiOiB7XG4gICAgXCJ0eXBlXCI6IFwiX3NiY3NcIixcbiAgICBcImNoYXJzXCI6IFwiw4fDvMOpw6LDo8Ogw4HDp8Oqw4rDqMONw5TDrMODw4LDicOAw4jDtMO1w7LDmsO5w4zDlcOcwqLCo8OZ4oKnw5PDocOtw7PDusOxw5HCqsK6wr/DksKswr3CvMKhwqvCu+KWkeKWkuKWk+KUguKUpOKVoeKVouKVluKVleKVo+KVkeKVl+KVneKVnOKVm+KUkOKUlOKUtOKUrOKUnOKUgOKUvOKVnuKVn+KVmuKVlOKVqeKVpuKVoOKVkOKVrOKVp+KVqOKVpOKVpeKVmeKVmOKVkuKVk+KVq+KVquKUmOKUjOKWiOKWhOKWjOKWkOKWgM6xw5/Ok8+AzqPPg8K1z4TOps6YzqnOtOKIns+GzrXiiKniiaHCseKJpeKJpOKMoOKMocO34omIwrDiiJnCt+KImuKBv8Ky4pagwqBcIlxuICB9LFxuICBcImlibTg2MFwiOiBcImNwODYwXCIsXG4gIFwiY3NpYm04NjBcIjogXCJjcDg2MFwiLFxuICBcImNwODYxXCI6IHtcbiAgICBcInR5cGVcIjogXCJfc2Jjc1wiLFxuICAgIFwiY2hhcnNcIjogXCLDh8O8w6nDosOkw6DDpcOnw6rDq8Oow5DDsMOew4TDhcOJw6bDhsO0w7bDvsO7w53DvcOWw5zDuMKjw5jigqfGksOhw63Ds8O6w4HDjcOTw5rCv+KMkMKswr3CvMKhwqvCu+KWkeKWkuKWk+KUguKUpOKVoeKVouKVluKVleKVo+KVkeKVl+KVneKVnOKVm+KUkOKUlOKUtOKUrOKUnOKUgOKUvOKVnuKVn+KVmuKVlOKVqeKVpuKVoOKVkOKVrOKVp+KVqOKVpOKVpeKVmeKVmOKVkuKVk+KVq+KVquKUmOKUjOKWiOKWhOKWjOKWkOKWgM6xw5/Ok8+AzqPPg8K1z4TOps6YzqnOtOKIns+GzrXiiKniiaHCseKJpeKJpOKMoOKMocO34omIwrDiiJnCt+KImuKBv8Ky4pagwqBcIlxuICB9LFxuICBcImlibTg2MVwiOiBcImNwODYxXCIsXG4gIFwiY3NpYm04NjFcIjogXCJjcDg2MVwiLFxuICBcImNwODYyXCI6IHtcbiAgICBcInR5cGVcIjogXCJfc2Jjc1wiLFxuICAgIFwiY2hhcnNcIjogXCLXkNeR15LXk9eU15XXlteX15jXmdea15vXnNed157Xn9eg16HXotej16TXpdem16fXqNep16rCosKjwqXigqfGksOhw63Ds8O6w7HDkcKqwrrCv+KMkMKswr3CvMKhwqvCu+KWkeKWkuKWk+KUguKUpOKVoeKVouKVluKVleKVo+KVkeKVl+KVneKVnOKVm+KUkOKUlOKUtOKUrOKUnOKUgOKUvOKVnuKVn+KVmuKVlOKVqeKVpuKVoOKVkOKVrOKVp+KVqOKVpOKVpeKVmeKVmOKVkuKVk+KVq+KVquKUmOKUjOKWiOKWhOKWjOKWkOKWgM6xw5/Ok8+AzqPPg8K1z4TOps6YzqnOtOKIns+GzrXiiKniiaHCseKJpeKJpOKMoOKMocO34omIwrDiiJnCt+KImuKBv8Ky4pagwqBcIlxuICB9LFxuICBcImlibTg2MlwiOiBcImNwODYyXCIsXG4gIFwiY3NpYm04NjJcIjogXCJjcDg2MlwiLFxuICBcImNwODYzXCI6IHtcbiAgICBcInR5cGVcIjogXCJfc2Jjc1wiLFxuICAgIFwiY2hhcnNcIjogXCLDh8O8w6nDosOCw6DCtsOnw6rDq8Oow6/DruKAl8OAwqfDicOIw4rDtMOLw4/Du8O5wqTDlMOcwqLCo8OZw5vGksKmwrTDs8O6wqjCuMKzwq/DjuKMkMKswr3CvMK+wqvCu+KWkeKWkuKWk+KUguKUpOKVoeKVouKVluKVleKVo+KVkeKVl+KVneKVnOKVm+KUkOKUlOKUtOKUrOKUnOKUgOKUvOKVnuKVn+KVmuKVlOKVqeKVpuKVoOKVkOKVrOKVp+KVqOKVpOKVpeKVmeKVmOKVkuKVk+KVq+KVquKUmOKUjOKWiOKWhOKWjOKWkOKWgM6xw5/Ok8+AzqPPg8K1z4TOps6YzqnOtOKIns+GzrXiiKniiaHCseKJpeKJpOKMoOKMocO34omIwrDiiJnCt+KImuKBv8Ky4pagwqBcIlxuICB9LFxuICBcImlibTg2M1wiOiBcImNwODYzXCIsXG4gIFwiY3NpYm04NjNcIjogXCJjcDg2M1wiLFxuICBcImNwODY0XCI6IHtcbiAgICBcInR5cGVcIjogXCJfc2Jjc1wiLFxuICAgIFwiY2hhcnNcIjogXCJcXHUwMDAwXFx1MDAwMVxcdTAwMDJcXHUwMDAzXFx1MDAwNFxcdTAwMDVcXHUwMDA2XFx1MDAwN1xcYlxcdFxcblxcdTAwMGJcXGZcXHJcXHUwMDBlXFx1MDAwZlxcdTAwMTBcXHUwMDExXFx1MDAxMlxcdTAwMTNcXHUwMDE0XFx1MDAxNVxcdTAwMTZcXHUwMDE3XFx1MDAxOFxcdTAwMTlcXHUwMDFhXFx1MDAxYlxcdTAwMWNcXHUwMDFkXFx1MDAxZVxcdTAwMWYgIVxcXCIjJNmqJicoKSorLC0uLzAxMjM0NTY3ODk6Ozw9Pj9AQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVpbXFxcXF1eX2BhYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ent8fX5/wrDCt+KImeKImuKWkuKUgOKUguKUvOKUpOKUrOKUnOKUtOKUkOKUjOKUlOKUmM6y4oiez4bCscK9wrziiYjCq8K777u377u477+977+977u777u877+9wqDCre+6gsKjwqTvuoTvv73vv73vuo7vuo/vupXvupnYjO+6ne+6oe+6pdmg2aHZotmj2aTZpdmm2afZqNmp77uR2JvvurHvurXvurnYn8Ki77qA77qB77qD77qF77uK77qL77qN77qR77qT77qX77qb77qf77qj77qn77qp77qr77qt77qv77qz77q377q777q/77uB77uF77uL77uPwqbCrMO3w5fvu4nZgO+7k++7l++7m++7n++7o++7p++7q++7re+7r++7s++6ve+7jO+7ju+7je+7oe+5vdmR77ul77up77us77uw77uy77uQ77uV77u177u277ud77uZ77ux4pag77+9XCJcbiAgfSxcbiAgXCJpYm04NjRcIjogXCJjcDg2NFwiLFxuICBcImNzaWJtODY0XCI6IFwiY3A4NjRcIixcbiAgXCJjcDg2NVwiOiB7XG4gICAgXCJ0eXBlXCI6IFwiX3NiY3NcIixcbiAgICBcImNoYXJzXCI6IFwiw4fDvMOpw6LDpMOgw6XDp8Oqw6vDqMOvw67DrMOEw4XDicOmw4bDtMO2w7LDu8O5w7/DlsOcw7jCo8OY4oKnxpLDocOtw7PDusOxw5HCqsK6wr/ijJDCrMK9wrzCocKrwqTilpHilpLilpPilILilKTilaHilaLilZbilZXilaPilZHilZfilZ3ilZzilZvilJDilJTilLTilKzilJzilIDilLzilZ7ilZ/ilZrilZTilanilabilaDilZDilazilafilajilaTilaXilZnilZjilZLilZPilavilarilJjilIzilojiloTilozilpDiloDOscOfzpPPgM6jz4PCtc+EzqbOmM6pzrTiiJ7Phs614oip4omhwrHiiaXiiaTijKDijKHDt+KJiMKw4oiZwrfiiJrigb/CsuKWoMKgXCJcbiAgfSxcbiAgXCJpYm04NjVcIjogXCJjcDg2NVwiLFxuICBcImNzaWJtODY1XCI6IFwiY3A4NjVcIixcbiAgXCJjcDg2NlwiOiB7XG4gICAgXCJ0eXBlXCI6IFwiX3NiY3NcIixcbiAgICBcImNoYXJzXCI6IFwi0JDQkdCS0JPQlNCV0JbQl9CY0JnQmtCb0JzQndCe0J/QoNCh0KLQo9Ck0KXQptCn0KjQqdCq0KvQrNCt0K7Qr9Cw0LHQstCz0LTQtdC20LfQuNC50LrQu9C80L3QvtC/4paR4paS4paT4pSC4pSk4pWh4pWi4pWW4pWV4pWj4pWR4pWX4pWd4pWc4pWb4pSQ4pSU4pS04pSs4pSc4pSA4pS84pWe4pWf4pWa4pWU4pWp4pWm4pWg4pWQ4pWs4pWn4pWo4pWk4pWl4pWZ4pWY4pWS4pWT4pWr4pWq4pSY4pSM4paI4paE4paM4paQ4paA0YDRgdGC0YPRhNGF0YbRh9GI0YnRitGL0YzRjdGO0Y/QgdGR0ITRlNCH0ZfQjtGewrDiiJnCt+KImuKElsKk4pagwqBcIlxuICB9LFxuICBcImlibTg2NlwiOiBcImNwODY2XCIsXG4gIFwiY3NpYm04NjZcIjogXCJjcDg2NlwiLFxuICBcImNwODY5XCI6IHtcbiAgICBcInR5cGVcIjogXCJfc2Jjc1wiLFxuICAgIFwiY2hhcnNcIjogXCLvv73vv73vv73vv73vv73vv73Ohu+/vcK3wqzCpuKAmOKAmc6I4oCVzonOis6qzozvv73vv73Ojs6rwqnOj8KywrPOrMKjzq3Ors6vz4rOkM+Mz43Okc6SzpPOlM6VzpbOl8K9zpjOmcKrwrvilpHilpLilpPilILilKTOms6bzpzOneKVo+KVkeKVl+KVnc6ezp/ilJDilJTilLTilKzilJzilIDilLzOoM6h4pWa4pWU4pWp4pWm4pWg4pWQ4pWszqPOpM6lzqbOp86ozqnOsc6yzrPilJjilIzilojiloTOtM614paAzrbOt864zrnOus67zrzOvc6+zr/PgM+Bz4PPgs+EzoTCrcKxz4XPhs+HwqfPiM6FwrDCqM+Jz4vOsM+O4pagwqBcIlxuICB9LFxuICBcImlibTg2OVwiOiBcImNwODY5XCIsXG4gIFwiY3NpYm04NjlcIjogXCJjcDg2OVwiLFxuICBcImNwOTIyXCI6IHtcbiAgICBcInR5cGVcIjogXCJfc2Jjc1wiLFxuICAgIFwiY2hhcnNcIjogXCLCgMKBwoLCg8KEwoXChsKHwojCicKKwovCjMKNwo7Cj8KQwpHCksKTwpTClcKWwpfCmMKZwprCm8Kcwp3CnsKfwqDCocKiwqPCpMKlwqbCp8KowqnCqsKrwqzCrcKu4oC+wrDCscKywrPCtMK1wrbCt8K4wrnCusK7wrzCvcK+wr/DgMOBw4LDg8OEw4XDhsOHw4jDicOKw4vDjMONw47Dj8Wgw5HDksOTw5TDlcOWw5fDmMOZw5rDm8Ocw53FvcOfw6DDocOiw6PDpMOlw6bDp8Oow6nDqsOrw6zDrcOuw6/FocOxw7LDs8O0w7XDtsO3w7jDucO6w7vDvMO9xb7Dv1wiXG4gIH0sXG4gIFwiaWJtOTIyXCI6IFwiY3A5MjJcIixcbiAgXCJjc2libTkyMlwiOiBcImNwOTIyXCIsXG4gIFwiY3AxMDQ2XCI6IHtcbiAgICBcInR5cGVcIjogXCJfc2Jjc1wiLFxuICAgIFwiY2hhcnNcIjogXCLvuojDl8O376O276O176O076O377mxwojilqDilILilIDilJDilIzilJTilJjvubnvubvvub3vub/vubfvuorvu7Dvu7Pvu7Lvu47vu4/vu5Dvu7bvu7jvu7rvu7zCoO+juu+jue+juMKk76O777qL77qR77qX77qb77qf77qj2IzCre+6p++6s9mg2aHZotmj2aTZpdmm2afZqNmp77q32Jvvurvvur/vu4rYn++7i9ih2KLYo9ik2KXYptin2KjYqdiq2KvYrNit2K7Yr9iw2LHYstiz2LTYtdi22Lfvu4fYudi677uM77qC77qE77qO77uT2YDZgdmC2YPZhNmF2YbZh9mI2YnZitmL2YzZjdmO2Y/ZkNmR2ZLvu5fvu5vvu5/vo7zvu7Xvu7fvu7nvu7vvu6Pvu6fvu6zvu6nvv71cIlxuICB9LFxuICBcImlibTEwNDZcIjogXCJjcDEwNDZcIixcbiAgXCJjc2libTEwNDZcIjogXCJjcDEwNDZcIixcbiAgXCJjcDExMjRcIjoge1xuICAgIFwidHlwZVwiOiBcIl9zYmNzXCIsXG4gICAgXCJjaGFyc1wiOiBcIsKAwoHCgsKDwoTChcKGwofCiMKJworCi8KMwo3CjsKPwpDCkcKSwpPClMKVwpbCl8KYwpnCmsKbwpzCncKewp/CoNCB0ILSkNCE0IXQhtCH0IjQidCK0IvQjMKt0I7Qj9CQ0JHQktCT0JTQldCW0JfQmNCZ0JrQm9Cc0J3QntCf0KDQodCi0KPQpNCl0KbQp9Co0KnQqtCr0KzQrdCu0K/QsNCx0LLQs9C00LXQttC30LjQudC60LvQvNC90L7Qv9GA0YHRgtGD0YTRhdGG0YfRiNGJ0YrRi9GM0Y3RjtGP4oSW0ZHRktKR0ZTRldGW0ZfRmNGZ0ZrRm9GcwqfRntGfXCJcbiAgfSxcbiAgXCJpYm0xMTI0XCI6IFwiY3AxMTI0XCIsXG4gIFwiY3NpYm0xMTI0XCI6IFwiY3AxMTI0XCIsXG4gIFwiY3AxMTI1XCI6IHtcbiAgICBcInR5cGVcIjogXCJfc2Jjc1wiLFxuICAgIFwiY2hhcnNcIjogXCLQkNCR0JLQk9CU0JXQltCX0JjQmdCa0JvQnNCd0J7Qn9Cg0KHQotCj0KTQpdCm0KfQqNCp0KrQq9Cs0K3QrtCv0LDQsdCy0LPQtNC10LbQt9C40LnQutC70LzQvdC+0L/ilpHilpLilpPilILilKTilaHilaLilZbilZXilaPilZHilZfilZ3ilZzilZvilJDilJTilLTilKzilJzilIDilLzilZ7ilZ/ilZrilZTilanilabilaDilZDilazilafilajilaTilaXilZnilZjilZLilZPilavilarilJjilIzilojiloTilozilpDiloDRgNGB0YLRg9GE0YXRhtGH0YjRidGK0YvRjNGN0Y7Rj9CB0ZHSkNKR0ITRlNCG0ZbQh9GXwrfiiJrihJbCpOKWoMKgXCJcbiAgfSxcbiAgXCJpYm0xMTI1XCI6IFwiY3AxMTI1XCIsXG4gIFwiY3NpYm0xMTI1XCI6IFwiY3AxMTI1XCIsXG4gIFwiY3AxMTI5XCI6IHtcbiAgICBcInR5cGVcIjogXCJfc2Jjc1wiLFxuICAgIFwiY2hhcnNcIjogXCLCgMKBwoLCg8KEwoXChsKHwojCicKKwovCjMKNwo7Cj8KQwpHCksKTwpTClcKWwpfCmMKZwprCm8Kcwp3CnsKfwqDCocKiwqPCpMKlwqbCp8WTwqnCqsKrwqzCrcKuwq/CsMKxwrLCs8W4wrXCtsK3xZLCucK6wrvCvMK9wr7Cv8OAw4HDgsSCw4TDhcOGw4fDiMOJw4rDi8yAw43DjsOPxJDDkcyJw5PDlMagw5bDl8OYw5nDmsObw5zGr8yDw5/DoMOhw6LEg8Okw6XDpsOnw6jDqcOqw6vMgcOtw67Dr8SRw7HMo8Ozw7TGocO2w7fDuMO5w7rDu8O8xrDigqvDv1wiXG4gIH0sXG4gIFwiaWJtMTEyOVwiOiBcImNwMTEyOVwiLFxuICBcImNzaWJtMTEyOVwiOiBcImNwMTEyOVwiLFxuICBcImNwMTEzM1wiOiB7XG4gICAgXCJ0eXBlXCI6IFwiX3NiY3NcIixcbiAgICBcImNoYXJzXCI6IFwiwoDCgcKCwoPChMKFwobCh8KIwonCisKLwozCjcKOwo/CkMKRwpLCk8KUwpXClsKXwpjCmcKawpvCnMKdwp7Cn8Kg4LqB4LqC4LqE4LqH4LqI4Lqq4LqK4LqN4LqU4LqV4LqW4LqX4LqZ4Lqa4Lqb4Lqc4Lqd4Lqe4Lqf4Lqh4Lqi4Lqj4Lql4Lqn4Lqr4Lqt4Lqu77+977+977+94Lqv4Lqw4Lqy4Lqz4Lq04Lq14Lq24Lq34Lq44Lq54Lq84Lqx4Lq74Lq977+977+977+94LuA4LuB4LuC4LuD4LuE4LuI4LuJ4LuK4LuL4LuM4LuN4LuG77+94Luc4Lud4oKt77+977+977+977+977+977+977+977+977+977+977+977+977+977+977+977+94LuQ4LuR4LuS4LuT4LuU4LuV4LuW4LuX4LuY4LuZ77+977+9wqLCrMKm77+9XCJcbiAgfSxcbiAgXCJpYm0xMTMzXCI6IFwiY3AxMTMzXCIsXG4gIFwiY3NpYm0xMTMzXCI6IFwiY3AxMTMzXCIsXG4gIFwiY3AxMTYxXCI6IHtcbiAgICBcInR5cGVcIjogXCJfc2Jjc1wiLFxuICAgIFwiY2hhcnNcIjogXCLvv73vv73vv73vv73vv73vv73vv73vv73vv73vv73vv73vv73vv73vv73vv73vv73vv73vv73vv73vv73vv73vv73vv73vv73vv73vv73vv73vv73vv73vv73vv73vv73guYjguIHguILguIPguITguIXguIbguIfguIjguInguIrguIvguIzguI3guI7guI/guJDguJHguJLguJPguJTguJXguJbguJfguJjguJnguJrguJvguJzguJ3guJ7guJ/guKDguKHguKLguKPguKTguKXguKbguKfguKjguKnguKrguKvguKzguK3guK7guK/guLDguLHguLLguLPguLTguLXguLbguLfguLjguLnguLrguYnguYrguYvigqzguL/guYDguYHguYLguYPguYTguYXguYbguYfguYjguYnguYrguYvguYzguY3guY7guY/guZDguZHguZLguZPguZTguZXguZbguZfguZjguZnguZrguZvCosKswqbCoFwiXG4gIH0sXG4gIFwiaWJtMTE2MVwiOiBcImNwMTE2MVwiLFxuICBcImNzaWJtMTE2MVwiOiBcImNwMTE2MVwiLFxuICBcImNwMTE2MlwiOiB7XG4gICAgXCJ0eXBlXCI6IFwiX3NiY3NcIixcbiAgICBcImNoYXJzXCI6IFwi4oKswoHCgsKDwoTigKbChsKHwojCicKKwovCjMKNwo7Cj8KQ4oCY4oCZ4oCc4oCd4oCi4oCT4oCUwpjCmcKawpvCnMKdwp7Cn8Kg4LiB4LiC4LiD4LiE4LiF4LiG4LiH4LiI4LiJ4LiK4LiL4LiM4LiN4LiO4LiP4LiQ4LiR4LiS4LiT4LiU4LiV4LiW4LiX4LiY4LiZ4Lia4Lib4Lic4Lid4Lie4Lif4Lig4Lih4Lii4Lij4Lik4Lil4Lim4Lin4Lio4Lip4Liq4Lir4Lis4Lit4Liu4Liv4Liw4Lix4Liy4Liz4Li04Li14Li24Li34Li44Li54Li677+977+977+977+94Li/4LmA4LmB4LmC4LmD4LmE4LmF4LmG4LmH4LmI4LmJ4LmK4LmL4LmM4LmN4LmO4LmP4LmQ4LmR4LmS4LmT4LmU4LmV4LmW4LmX4LmY4LmZ4Lma4Lmb77+977+977+977+9XCJcbiAgfSxcbiAgXCJpYm0xMTYyXCI6IFwiY3AxMTYyXCIsXG4gIFwiY3NpYm0xMTYyXCI6IFwiY3AxMTYyXCIsXG4gIFwiY3AxMTYzXCI6IHtcbiAgICBcInR5cGVcIjogXCJfc2Jjc1wiLFxuICAgIFwiY2hhcnNcIjogXCLCgMKBwoLCg8KEwoXChsKHwojCicKKwovCjMKNwo7Cj8KQwpHCksKTwpTClcKWwpfCmMKZwprCm8Kcwp3CnsKfwqDCocKiwqPigqzCpcKmwqfFk8KpwqrCq8Kswq3CrsKvwrDCscKywrPFuMK1wrbCt8WSwrnCusK7wrzCvcK+wr/DgMOBw4LEgsOEw4XDhsOHw4jDicOKw4vMgMONw47Dj8SQw5HMicOTw5TGoMOWw5fDmMOZw5rDm8Ocxq/Mg8Ofw6DDocOixIPDpMOlw6bDp8Oow6nDqsOrzIHDrcOuw6/EkcOxzKPDs8O0xqHDtsO3w7jDucO6w7vDvMaw4oKrw79cIlxuICB9LFxuICBcImlibTExNjNcIjogXCJjcDExNjNcIixcbiAgXCJjc2libTExNjNcIjogXCJjcDExNjNcIixcbiAgXCJtYWNjcm9hdGlhblwiOiB7XG4gICAgXCJ0eXBlXCI6IFwiX3NiY3NcIixcbiAgICBcImNoYXJzXCI6IFwiw4TDhcOHw4nDkcOWw5zDocOgw6LDpMOjw6XDp8Opw6jDqsOrw63DrMOuw6/DscOzw7LDtMO2w7XDusO5w7vDvOKAoMKwwqLCo8Kn4oCiwrbDn8KuxaDihKLCtMKo4omgxb3DmOKInsKx4omk4oml4oiGwrXiiILiiJHiiI/FoeKIq8KqwrrihKbFvsO4wr/CocKs4oiaxpLiiYjEhsKrxIzigKbCoMOAw4PDlcWSxZPEkOKAlOKAnOKAneKAmOKAmcO34peK77+9wqnigYTCpOKAueKAusOGwrvigJPCt+KAmuKAnuKAsMOCxIfDgcSNw4jDjcOOw4/DjMOTw5TEkcOSw5rDm8OZxLHLhsucwq/PgMOLy5rCuMOKw6bLh1wiXG4gIH0sXG4gIFwibWFjY3lyaWxsaWNcIjoge1xuICAgIFwidHlwZVwiOiBcIl9zYmNzXCIsXG4gICAgXCJjaGFyc1wiOiBcItCQ0JHQktCT0JTQldCW0JfQmNCZ0JrQm9Cc0J3QntCf0KDQodCi0KPQpNCl0KbQp9Co0KnQqtCr0KzQrdCu0K/igKDCsMKiwqPCp+KAosK20IbCrsKp4oSi0ILRkuKJoNCD0ZPiiJ7CseKJpOKJpdGWwrXiiILQiNCE0ZTQh9GX0InRmdCK0ZrRmNCFwqziiJrGkuKJiOKIhsKrwrvigKbCoNCL0ZvQjNGc0ZXigJPigJTigJzigJ3igJjigJnDt+KAntCO0Z7Qj9Gf4oSW0IHRkdGP0LDQsdCy0LPQtNC10LbQt9C40LnQutC70LzQvdC+0L/RgNGB0YLRg9GE0YXRhtGH0YjRidGK0YvRjNGN0Y7CpFwiXG4gIH0sXG4gIFwibWFjZ3JlZWtcIjoge1xuICAgIFwidHlwZVwiOiBcIl9zYmNzXCIsXG4gICAgXCJjaGFyc1wiOiBcIsOEwrnCssOJwrPDlsOczoXDoMOiw6TOhMKow6fDqcOow6rDq8Kj4oSiw67Dr+KAosK94oCww7TDtsKmwq3DucO7w7zigKDOk86UzpjOm86ezqDDn8KuwqnOo86qwqfiiaDCsM6HzpHCseKJpOKJpcKlzpLOlc6WzpfOmc6azpzOps6rzqjOqc6szp3CrM6fzqHiiYjOpMKrwrvigKbCoM6lzqfOhs6IxZPigJPigJXigJzigJ3igJjigJnDt86JzorOjM6Ozq3Ors6vz4zOj8+NzrHOss+IzrTOtc+GzrPOt865zr7Ous67zrzOvc6/z4DPjs+Bz4PPhM64z4nPgs+Hz4XOts+Kz4vOkM6w77+9XCJcbiAgfSxcbiAgXCJtYWNpY2VsYW5kXCI6IHtcbiAgICBcInR5cGVcIjogXCJfc2Jjc1wiLFxuICAgIFwiY2hhcnNcIjogXCLDhMOFw4fDicORw5bDnMOhw6DDosOkw6PDpcOnw6nDqMOqw6vDrcOsw67Dr8Oxw7PDssO0w7bDtcO6w7nDu8O8w53CsMKiwqPCp+KAosK2w5/CrsKp4oSiwrTCqOKJoMOGw5jiiJ7CseKJpOKJpcKlwrXiiILiiJHiiI/PgOKIq8KqwrrihKbDpsO4wr/CocKs4oiaxpLiiYjiiIbCq8K74oCmwqDDgMODw5XFksWT4oCT4oCU4oCc4oCd4oCY4oCZw7fil4rDv8W44oGEwqTDkMOww57DvsO9wrfigJrigJ7igLDDgsOKw4HDi8OIw43DjsOPw4zDk8OU77+9w5LDmsObw5nEscuGy5zCr8uYy5nLmsK4y53Lm8uHXCJcbiAgfSxcbiAgXCJtYWNyb21hblwiOiB7XG4gICAgXCJ0eXBlXCI6IFwiX3NiY3NcIixcbiAgICBcImNoYXJzXCI6IFwiw4TDhcOHw4nDkcOWw5zDocOgw6LDpMOjw6XDp8Opw6jDqsOrw63DrMOuw6/DscOzw7LDtMO2w7XDusO5w7vDvOKAoMKwwqLCo8Kn4oCiwrbDn8KuwqnihKLCtMKo4omgw4bDmOKInsKx4omk4omlwqXCteKIguKIkeKIj8+A4oirwqrCuuKEpsOmw7jCv8KhwqziiJrGkuKJiOKIhsKrwrvigKbCoMOAw4PDlcWSxZPigJPigJTigJzigJ3igJjigJnDt+KXisO/xbjigYTCpOKAueKAuu+sge+sguKAocK34oCa4oCe4oCww4LDisOBw4vDiMONw47Dj8OMw5PDlO+/vcOSw5rDm8OZxLHLhsucwq/LmMuZy5rCuMudy5vLh1wiXG4gIH0sXG4gIFwibWFjcm9tYW5pYVwiOiB7XG4gICAgXCJ0eXBlXCI6IFwiX3NiY3NcIixcbiAgICBcImNoYXJzXCI6IFwiw4TDhcOHw4nDkcOWw5zDocOgw6LDpMOjw6XDp8Opw6jDqsOrw63DrMOuw6/DscOzw7LDtMO2w7XDusO5w7vDvOKAoMKwwqLCo8Kn4oCiwrbDn8KuwqnihKLCtMKo4omgxILFnuKInsKx4omk4omlwqXCteKIguKIkeKIj8+A4oirwqrCuuKEpsSDxZ/Cv8KhwqziiJrGkuKJiOKIhsKrwrvigKbCoMOAw4PDlcWSxZPigJPigJTigJzigJ3igJjigJnDt+KXisO/xbjigYTCpOKAueKAusWixaPigKHCt+KAmuKAnuKAsMOCw4rDgcOLw4jDjcOOw4/DjMOTw5Tvv73DksOaw5vDmcSxy4bLnMKvy5jLmcuawrjLncuby4dcIlxuICB9LFxuICBcIm1hY3RoYWlcIjoge1xuICAgIFwidHlwZVwiOiBcIl9zYmNzXCIsXG4gICAgXCJjaGFyc1wiOiBcIsKrwrvigKbvoozvoo/vopLvopXvopjvoovvoo7vopHvopTvopfigJzigJ3vopnvv73igKLvooTvoonvooXvoobvoofvoojvoorvoo3vopDvopPvopbigJjigJnvv73CoOC4geC4guC4g+C4hOC4heC4huC4h+C4iOC4ieC4iuC4i+C4jOC4jeC4juC4j+C4kOC4keC4kuC4k+C4lOC4leC4luC4l+C4mOC4meC4muC4m+C4nOC4neC4nuC4n+C4oOC4oeC4ouC4o+C4pOC4peC4puC4p+C4qOC4qeC4quC4q+C4rOC4reC4ruC4r+C4sOC4seC4suC4s+C4tOC4teC4tuC4t+C4uOC4ueC4uu+7v+KAi+KAk+KAlOC4v+C5gOC5geC5guC5g+C5hOC5heC5huC5h+C5iOC5ieC5iuC5i+C5jOC5jeKEouC5j+C5kOC5keC5kuC5k+C5lOC5leC5luC5l+C5mOC5mcKuwqnvv73vv73vv73vv71cIlxuICB9LFxuICBcIm1hY3R1cmtpc2hcIjoge1xuICAgIFwidHlwZVwiOiBcIl9zYmNzXCIsXG4gICAgXCJjaGFyc1wiOiBcIsOEw4XDh8OJw5HDlsOcw6HDoMOiw6TDo8Olw6fDqcOow6rDq8Otw6zDrsOvw7HDs8Oyw7TDtsO1w7rDucO7w7zigKDCsMKiwqPCp+KAosK2w5/CrsKp4oSiwrTCqOKJoMOGw5jiiJ7CseKJpOKJpcKlwrXiiILiiJHiiI/PgOKIq8KqwrrihKbDpsO4wr/CocKs4oiaxpLiiYjiiIbCq8K74oCmwqDDgMODw5XFksWT4oCT4oCU4oCc4oCd4oCY4oCZw7fil4rDv8W4xJ7En8SwxLHFnsWf4oChwrfigJrigJ7igLDDgsOKw4HDi8OIw43DjsOPw4zDk8OU77+9w5LDmsObw5nvv73Lhsucwq/LmMuZy5rCuMudy5vLh1wiXG4gIH0sXG4gIFwibWFjdWtyYWluZVwiOiB7XG4gICAgXCJ0eXBlXCI6IFwiX3NiY3NcIixcbiAgICBcImNoYXJzXCI6IFwi0JDQkdCS0JPQlNCV0JbQl9CY0JnQmtCb0JzQndCe0J/QoNCh0KLQo9Ck0KXQptCn0KjQqdCq0KvQrNCt0K7Qr+KAoMKw0pDCo8Kn4oCiwrbQhsKuwqnihKLQgtGS4omg0IPRk+KInsKx4omk4oml0ZbCtdKR0IjQhNGU0IfRl9CJ0ZnQitGa0ZjQhcKs4oiaxpLiiYjiiIbCq8K74oCmwqDQi9Gb0IzRnNGV4oCT4oCU4oCc4oCd4oCY4oCZw7figJ7QjtGe0I/Rn+KEltCB0ZHRj9Cw0LHQstCz0LTQtdC20LfQuNC50LrQu9C80L3QvtC/0YDRgdGC0YPRhNGF0YbRh9GI0YnRitGL0YzRjdGOwqRcIlxuICB9LFxuICBcImtvaThyXCI6IHtcbiAgICBcInR5cGVcIjogXCJfc2Jjc1wiLFxuICAgIFwiY2hhcnNcIjogXCLilIDilILilIzilJDilJTilJjilJzilKTilKzilLTilLziloDiloTilojilozilpDilpHilpLilpPijKDilqDiiJniiJriiYjiiaTiiaXCoOKMocKwwrLCt8O34pWQ4pWR4pWS0ZHilZPilZTilZXilZbilZfilZjilZnilZrilZvilZzilZ3ilZ7ilZ/ilaDilaHQgeKVouKVo+KVpOKVpeKVpuKVp+KVqOKVqeKVquKVq+KVrMKp0Y7QsNCx0YbQtNC10YTQs9GF0LjQudC60LvQvNC90L7Qv9GP0YDRgdGC0YPQttCy0YzRi9C30YjRjdGJ0YfRitCu0JDQkdCm0JTQldCk0JPQpdCY0JnQmtCb0JzQndCe0J/Qr9Cg0KHQotCj0JbQktCs0KvQl9Co0K3QqdCn0KpcIlxuICB9LFxuICBcImtvaTh1XCI6IHtcbiAgICBcInR5cGVcIjogXCJfc2Jjc1wiLFxuICAgIFwiY2hhcnNcIjogXCLilIDilILilIzilJDilJTilJjilJzilKTilKzilLTilLziloDiloTilojilozilpDilpHilpLilpPijKDilqDiiJniiJriiYjiiaTiiaXCoOKMocKwwrLCt8O34pWQ4pWR4pWS0ZHRlOKVlNGW0ZfilZfilZjilZnilZrilZvSkeKVneKVnuKVn+KVoOKVodCB0ITilaPQhtCH4pWm4pWn4pWo4pWp4pWq0pDilazCqdGO0LDQsdGG0LTQtdGE0LPRhdC40LnQutC70LzQvdC+0L/Rj9GA0YHRgtGD0LbQstGM0YvQt9GI0Y3RidGH0YrQrtCQ0JHQptCU0JXQpNCT0KXQmNCZ0JrQm9Cc0J3QntCf0K/QoNCh0KLQo9CW0JLQrNCr0JfQqNCt0KnQp9CqXCJcbiAgfSxcbiAgXCJrb2k4cnVcIjoge1xuICAgIFwidHlwZVwiOiBcIl9zYmNzXCIsXG4gICAgXCJjaGFyc1wiOiBcIuKUgOKUguKUjOKUkOKUlOKUmOKUnOKUpOKUrOKUtOKUvOKWgOKWhOKWiOKWjOKWkOKWkeKWkuKWk+KMoOKWoOKImeKImuKJiOKJpOKJpcKg4oyhwrDCssK3w7filZDilZHilZLRkdGU4pWU0ZbRl+KVl+KVmOKVmeKVmuKVm9KR0Z7ilZ7ilZ/ilaDilaHQgdCE4pWj0IbQh+KVpuKVp+KVqOKVqeKVqtKQ0I7CqdGO0LDQsdGG0LTQtdGE0LPRhdC40LnQutC70LzQvdC+0L/Rj9GA0YHRgtGD0LbQstGM0YvQt9GI0Y3RidGH0YrQrtCQ0JHQptCU0JXQpNCT0KXQmNCZ0JrQm9Cc0J3QntCf0K/QoNCh0KLQo9CW0JLQrNCr0JfQqNCt0KnQp9CqXCJcbiAgfSxcbiAgXCJrb2k4dFwiOiB7XG4gICAgXCJ0eXBlXCI6IFwiX3NiY3NcIixcbiAgICBcImNoYXJzXCI6IFwi0pvSk+KAmtKS4oCe4oCm4oCg4oCh77+94oCw0rPigLnSstK30rbvv73SmuKAmOKAmeKAnOKAneKAouKAk+KAlO+/veKEou+/veKAuu+/ve+/ve+/ve+/ve+/vdOv067RkcKk06PCpsKn77+977+977+9wqvCrMKtwq7vv73CsMKxwrLQge+/vdOiwrbCt++/veKElu+/vcK777+977+977+9wqnRjtCw0LHRhtC00LXRhNCz0YXQuNC50LrQu9C80L3QvtC/0Y/RgNGB0YLRg9C20LLRjNGL0LfRiNGN0YnRh9GK0K7QkNCR0KbQlNCV0KTQk9Cl0JjQmdCa0JvQnNCd0J7Qn9Cv0KDQodCi0KPQltCS0KzQq9CX0KjQrdCp0KfQqlwiXG4gIH0sXG4gIFwiYXJtc2NpaThcIjoge1xuICAgIFwidHlwZVwiOiBcIl9zYmNzXCIsXG4gICAgXCJjaGFyc1wiOiBcIsKAwoHCgsKDwoTChcKGwofCiMKJworCi8KMwo3CjsKPwpDCkcKSwpPClMKVwpbCl8KYwpnCmsKbwpzCncKewp/CoO+/vdaH1okpKMK7wqvigJQu1Z0sLdaK4oCm1ZzVm9We1LHVodSy1aLUs9Wj1LTVpNS11aXUttWm1LfVp9S41ajUudWp1LrVqtS71avUvNWs1L3VrdS+1a7Uv9Wv1YDVsNWB1bHVgtWy1YPVs9WE1bTVhdW11YbVttWH1bfViNW41YnVudWK1brVi9W71YzVvNWN1b3VjtW+1Y/Vv9WQ1oDVkdaB1ZLWgtWT1oPVlNaE1ZXWhdWW1obVmu+/vVwiXG4gIH0sXG4gIFwicmsxMDQ4XCI6IHtcbiAgICBcInR5cGVcIjogXCJfc2Jjc1wiLFxuICAgIFwiY2hhcnNcIjogXCLQgtCD4oCa0ZPigJ7igKbigKDigKHigqzigLDQieKAudCK0prSutCP0ZLigJjigJnigJzigJ3igKLigJPigJTvv73ihKLRmeKAutGa0pvSu9GfwqDSsNKx05jCpNOowqbCp9CBwqnSksKrwqzCrcKu0q7CsMKx0IbRltOpwrXCtsK30ZHihJbSk8K705nSotKj0q/QkNCR0JLQk9CU0JXQltCX0JjQmdCa0JvQnNCd0J7Qn9Cg0KHQotCj0KTQpdCm0KfQqNCp0KrQq9Cs0K3QrtCv0LDQsdCy0LPQtNC10LbQt9C40LnQutC70LzQvdC+0L/RgNGB0YLRg9GE0YXRhtGH0YjRidGK0YvRjNGN0Y7Rj1wiXG4gIH0sXG4gIFwidGN2blwiOiB7XG4gICAgXCJ0eXBlXCI6IFwiX3NiY3NcIixcbiAgICBcImNoYXJzXCI6IFwiXFx1MDAwMMOa4bukXFx1MDAwM+G7quG7rOG7rlxcdTAwMDdcXGJcXHRcXG5cXHUwMDBiXFxmXFxyXFx1MDAwZVxcdTAwMGZcXHUwMDEw4buo4buw4buy4bu24bu4w53hu7RcXHUwMDE4XFx1MDAxOVxcdTAwMWFcXHUwMDFiXFx1MDAxY1xcdTAwMWRcXHUwMDFlXFx1MDAxZiAhXFxcIiMkJSYnKCkqKywtLi8wMTIzNDU2Nzg5Ojs8PT4/QEFCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaW1xcXFxdXl9gYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXp7fH1+f8OA4bqiw4PDgeG6oOG6tuG6rMOI4bq64bq8w4nhurjhu4bDjOG7iMSow43hu4rDkuG7jsOVw5Phu4zhu5jhu5zhu57hu6Dhu5rhu6LDmeG7psWowqDEgsOCw4rDlMagxq/EkMSDw6LDqsO0xqHGsMSR4bqwzIDMicyDzIHMo8Og4bqjw6PDoeG6oeG6suG6seG6s+G6teG6r+G6tOG6ruG6puG6qOG6quG6pOG7gOG6t+G6p+G6qeG6q+G6peG6rcOo4buC4bq74bq9w6nhurnhu4Hhu4Phu4Xhur/hu4fDrOG7ieG7hOG6vuG7ksSpw63hu4vDsuG7lOG7j8O1w7Phu43hu5Phu5Xhu5fhu5Hhu5nhu53hu5/hu6Hhu5vhu6PDueG7luG7p8Wpw7rhu6Xhu6vhu63hu6/hu6nhu7Hhu7Phu7fhu7nDveG7teG7kFwiXG4gIH0sXG4gIFwiZ2VvcmdpYW5hY2FkZW15XCI6IHtcbiAgICBcInR5cGVcIjogXCJfc2Jjc1wiLFxuICAgIFwiY2hhcnNcIjogXCLCgMKB4oCaxpLigJ7igKbigKDigKHLhuKAsMWg4oC5xZLCjcKOwo/CkOKAmOKAmeKAnOKAneKAouKAk+KAlMuc4oSixaHigLrFk8Kdwp7FuMKgwqHCosKjwqTCpcKmwqfCqMKpwqrCq8Kswq3CrsKvwrDCscKywrPCtMK1wrbCt8K4wrnCusK7wrzCvcK+wr/hg5Dhg5Hhg5Lhg5Phg5Thg5Xhg5bhg5fhg5jhg5nhg5rhg5vhg5zhg53hg57hg5/hg6Dhg6Hhg6Lhg6Phg6Thg6Xhg6bhg6fhg6jhg6nhg6rhg6vhg6zhg63hg67hg6/hg7Dhg7Hhg7Lhg7Phg7Thg7Xhg7bDp8Oow6nDqsOrw6zDrcOuw6/DsMOxw7LDs8O0w7XDtsO3w7jDucO6w7vDvMO9w77Dv1wiXG4gIH0sXG4gIFwiZ2VvcmdpYW5wc1wiOiB7XG4gICAgXCJ0eXBlXCI6IFwiX3NiY3NcIixcbiAgICBcImNoYXJzXCI6IFwiwoDCgeKAmsaS4oCe4oCm4oCg4oChy4bigLDFoOKAucWSwo3CjsKPwpDigJjigJnigJzigJ3igKLigJPigJTLnOKEosWh4oC6xZPCncKexbjCoMKhwqLCo8KkwqXCpsKnwqjCqcKqwqvCrMKtwq7Cr8KwwrHCssKzwrTCtcK2wrfCuMK5wrrCu8K8wr3CvsK/4YOQ4YOR4YOS4YOT4YOU4YOV4YOW4YOx4YOX4YOY4YOZ4YOa4YOb4YOc4YOy4YOd4YOe4YOf4YOg4YOh4YOi4YOz4YOj4YOk4YOl4YOm4YOn4YOo4YOp4YOq4YOr4YOs4YOt4YOu4YO04YOv4YOw4YO1w6bDp8Oow6nDqsOrw6zDrcOuw6/DsMOxw7LDs8O0w7XDtsO3w7jDucO6w7vDvMO9w77Dv1wiXG4gIH0sXG4gIFwicHQxNTRcIjoge1xuICAgIFwidHlwZVwiOiBcIl9zYmNzXCIsXG4gICAgXCJjaGFyc1wiOiBcItKW0pLTrtKT4oCe4oCm0rbSrtKy0q/SoNOi0qLSmtK60rjSl+KAmOKAmeKAnOKAneKAouKAk+KAlNKz0rfSodOj0qPSm9K70rnCoNCO0Z7QiNOo0pjSsMKn0IHCqdOYwqvCrNOvwq7SnMKw0rHQhtGW0pnTqcK2wrfRkeKEltOZwrvRmNKq0qvSndCQ0JHQktCT0JTQldCW0JfQmNCZ0JrQm9Cc0J3QntCf0KDQodCi0KPQpNCl0KbQp9Co0KnQqtCr0KzQrdCu0K/QsNCx0LLQs9C00LXQttC30LjQudC60LvQvNC90L7Qv9GA0YHRgtGD0YTRhdGG0YfRiNGJ0YrRi9GM0Y3RjtGPXCJcbiAgfSxcbiAgXCJ2aXNjaWlcIjoge1xuICAgIFwidHlwZVwiOiBcIl9zYmNzXCIsXG4gICAgXCJjaGFyc1wiOiBcIlxcdTAwMDBcXHUwMDAx4bqyXFx1MDAwM1xcdTAwMDThurThuqpcXHUwMDA3XFxiXFx0XFxuXFx1MDAwYlxcZlxcclxcdTAwMGVcXHUwMDBmXFx1MDAxMFxcdTAwMTFcXHUwMDEyXFx1MDAxM+G7tlxcdTAwMTVcXHUwMDE2XFx1MDAxN1xcdTAwMTjhu7hcXHUwMDFhXFx1MDAxYlxcdTAwMWNcXHUwMDFk4bu0XFx1MDAxZiAhXFxcIiMkJSYnKCkqKywtLi8wMTIzNDU2Nzg5Ojs8PT4/QEFCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaW1xcXFxdXl9gYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXp7fH1+f+G6oOG6ruG6sOG6tuG6pOG6puG6qOG6rOG6vOG6uOG6vuG7gOG7guG7hOG7huG7kOG7kuG7lOG7luG7mOG7ouG7muG7nOG7nuG7iuG7juG7jOG7iOG7psWo4buk4buyw5Xhuq/hurHhurfhuqXhuqfhuqnhuq3hur3hurnhur/hu4Hhu4Phu4Xhu4fhu5Hhu5Phu5Xhu5fhu6DGoOG7meG7neG7n+G7i+G7sOG7qOG7quG7rMah4bubxq/DgMOBw4LDg+G6osSC4bqz4bq1w4jDicOK4bq6w4zDjcSo4buzxJDhu6nDksOTw5ThuqHhu7fhu6vhu63DmcOa4bu54bu1w53hu6HGsMOgw6HDosOj4bqjxIPhu6/huqvDqMOpw6rhurvDrMOtxKnhu4nEkeG7scOyw7PDtMO14buP4buN4bulw7nDusWp4bunw73hu6Phu65cIlxuICB9LFxuICBcImlzbzY0NmNuXCI6IHtcbiAgICBcInR5cGVcIjogXCJfc2Jjc1wiLFxuICAgIFwiY2hhcnNcIjogXCJcXHUwMDAwXFx1MDAwMVxcdTAwMDJcXHUwMDAzXFx1MDAwNFxcdTAwMDVcXHUwMDA2XFx1MDAwN1xcYlxcdFxcblxcdTAwMGJcXGZcXHJcXHUwMDBlXFx1MDAwZlxcdTAwMTBcXHUwMDExXFx1MDAxMlxcdTAwMTNcXHUwMDE0XFx1MDAxNVxcdTAwMTZcXHUwMDE3XFx1MDAxOFxcdTAwMTlcXHUwMDFhXFx1MDAxYlxcdTAwMWNcXHUwMDFkXFx1MDAxZVxcdTAwMWYgIVxcXCIjwqUlJicoKSorLC0uLzAxMjM0NTY3ODk6Ozw9Pj9AQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVpbXFxcXF1eX2BhYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ent8feKAvn/vv73vv73vv73vv73vv73vv73vv73vv73vv73vv73vv73vv73vv73vv73vv73vv73vv73vv73vv73vv73vv73vv73vv73vv73vv73vv73vv73vv73vv73vv73vv73vv73vv73vv73vv73vv73vv73vv73vv73vv73vv73vv73vv73vv73vv73vv73vv73vv73vv73vv73vv73vv73vv73vv73vv73vv73vv73vv73vv73vv73vv73vv73vv73vv73vv73vv73vv73vv73vv73vv73vv73vv73vv73vv73vv73vv73vv73vv73vv73vv73vv73vv73vv73vv73vv73vv73vv73vv73vv73vv73vv73vv73vv73vv73vv73vv73vv73vv73vv73vv73vv73vv73vv73vv73vv73vv73vv73vv73vv73vv73vv73vv73vv73vv73vv73vv73vv73vv73vv73vv73vv73vv73vv73vv73vv73vv73vv73vv71cIlxuICB9LFxuICBcImlzbzY0NmpwXCI6IHtcbiAgICBcInR5cGVcIjogXCJfc2Jjc1wiLFxuICAgIFwiY2hhcnNcIjogXCJcXHUwMDAwXFx1MDAwMVxcdTAwMDJcXHUwMDAzXFx1MDAwNFxcdTAwMDVcXHUwMDA2XFx1MDAwN1xcYlxcdFxcblxcdTAwMGJcXGZcXHJcXHUwMDBlXFx1MDAwZlxcdTAwMTBcXHUwMDExXFx1MDAxMlxcdTAwMTNcXHUwMDE0XFx1MDAxNVxcdTAwMTZcXHUwMDE3XFx1MDAxOFxcdTAwMTlcXHUwMDFhXFx1MDAxYlxcdTAwMWNcXHUwMDFkXFx1MDAxZVxcdTAwMWYgIVxcXCIjJCUmJygpKissLS4vMDEyMzQ1Njc4OTo7PD0+P0BBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWlvCpV1eX2BhYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ent8feKAvn/vv73vv73vv73vv73vv73vv73vv73vv73vv73vv73vv73vv73vv73vv73vv73vv73vv73vv73vv73vv73vv73vv73vv73vv73vv73vv73vv73vv73vv73vv73vv73vv73vv73vv73vv73vv73vv73vv73vv73vv73vv73vv73vv73vv73vv73vv73vv73vv73vv73vv73vv73vv73vv73vv73vv73vv73vv73vv73vv73vv73vv73vv73vv73vv73vv73vv73vv73vv73vv73vv73vv73vv73vv73vv73vv73vv73vv73vv73vv73vv73vv73vv73vv73vv73vv73vv73vv73vv73vv73vv73vv73vv73vv73vv73vv73vv73vv73vv73vv73vv73vv73vv73vv73vv73vv73vv73vv73vv73vv73vv73vv73vv73vv73vv73vv73vv73vv73vv73vv73vv73vv73vv73vv73vv73vv73vv73vv73vv71cIlxuICB9LFxuICBcImhwcm9tYW44XCI6IHtcbiAgICBcInR5cGVcIjogXCJfc2Jjc1wiLFxuICAgIFwiY2hhcnNcIjogXCLCgMKBwoLCg8KEwoXChsKHwojCicKKwovCjMKNwo7Cj8KQwpHCksKTwpTClcKWwpfCmMKZwprCm8Kcwp3CnsKfwqDDgMOCw4jDisOLw47Dj8K0y4vLhsKoy5zDmcOb4oKkwq/DncO9wrDDh8Onw5HDscKhwr/CpMKjwqXCp8aSwqLDosOqw7TDu8Ohw6nDs8O6w6DDqMOyw7nDpMOrw7bDvMOFw67DmMOGw6XDrcO4w6bDhMOsw5bDnMOJw6/Dn8OUw4HDg8Ojw5DDsMONw4zDk8OSw5XDtcWgxaHDmsW4w7/DnsO+wrfCtcK2wr7igJTCvMK9wqrCusKr4pagwrvCse+/vVwiXG4gIH0sXG4gIFwibWFjaW50b3NoXCI6IHtcbiAgICBcInR5cGVcIjogXCJfc2Jjc1wiLFxuICAgIFwiY2hhcnNcIjogXCLDhMOFw4fDicORw5bDnMOhw6DDosOkw6PDpcOnw6nDqMOqw6vDrcOsw67Dr8Oxw7PDssO0w7bDtcO6w7nDu8O84oCgwrDCosKjwqfigKLCtsOfwq7CqeKEosK0wqjiiaDDhsOY4oiewrHiiaTiiaXCpcK14oiC4oiR4oiPz4DiiKvCqsK64oSmw6bDuMK/wqHCrOKImsaS4omI4oiGwqvCu+KApsKgw4DDg8OVxZLFk+KAk+KAlOKAnOKAneKAmOKAmcO34peKw7/FuOKBhMKk4oC54oC676yB76yC4oChwrfigJrigJ7igLDDgsOKw4HDi8OIw43DjsOPw4zDk8OU77+9w5LDmsObw5nEscuGy5zCr8uYy5nLmsK4y53Lm8uHXCJcbiAgfSxcbiAgXCJhc2NpaVwiOiB7XG4gICAgXCJ0eXBlXCI6IFwiX3NiY3NcIixcbiAgICBcImNoYXJzXCI6IFwi77+977+977+977+977+977+977+977+977+977+977+977+977+977+977+977+977+977+977+977+977+977+977+977+977+977+977+977+977+977+977+977+977+977+977+977+977+977+977+977+977+977+977+977+977+977+977+977+977+977+977+977+977+977+977+977+977+977+977+977+977+977+977+977+977+977+977+977+977+977+977+977+977+977+977+977+977+977+977+977+977+977+977+977+977+977+977+977+977+977+977+977+977+977+977+977+977+977+977+977+977+977+977+977+977+977+977+977+977+977+977+977+977+977+977+977+977+977+977+977+977+977+977+977+977+977+977+977+9XCJcbiAgfSxcbiAgXCJ0aXM2MjBcIjoge1xuICAgIFwidHlwZVwiOiBcIl9zYmNzXCIsXG4gICAgXCJjaGFyc1wiOiBcIu+/ve+/ve+/ve+/ve+/ve+/ve+/ve+/ve+/ve+/ve+/ve+/ve+/ve+/ve+/ve+/ve+/ve+/ve+/ve+/ve+/ve+/ve+/ve+/ve+/ve+/ve+/ve+/ve+/ve+/ve+/ve+/ve+/veC4geC4guC4g+C4hOC4heC4huC4h+C4iOC4ieC4iuC4i+C4jOC4jeC4juC4j+C4kOC4keC4kuC4k+C4lOC4leC4luC4l+C4mOC4meC4muC4m+C4nOC4neC4nuC4n+C4oOC4oeC4ouC4o+C4pOC4peC4puC4p+C4qOC4qeC4quC4q+C4rOC4reC4ruC4r+C4sOC4seC4suC4s+C4tOC4teC4tuC4t+C4uOC4ueC4uu+/ve+/ve+/ve+/veC4v+C5gOC5geC5guC5g+C5hOC5heC5huC5h+C5iOC5ieC5iuC5i+C5jOC5jeC5juC5j+C5kOC5keC5kuC5k+C5lOC5leC5luC5l+C5mOC5meC5muC5m++/ve+/ve+/ve+/vVwiXG4gIH1cbn0iLCJcInVzZSBzdHJpY3RcIlxuXG4vLyBNYW51YWxseSBhZGRlZCBkYXRhIHRvIGJlIHVzZWQgYnkgc2JjcyBjb2RlYyBpbiBhZGRpdGlvbiB0byBnZW5lcmF0ZWQgb25lLlxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgICAvLyBOb3Qgc3VwcG9ydGVkIGJ5IGljb252LCBub3Qgc3VyZSB3aHkuXG4gICAgXCIxMDAyOVwiOiBcIm1hY2NlbnRldXJvXCIsXG4gICAgXCJtYWNjZW50ZXVyb1wiOiB7XG4gICAgICAgIFwidHlwZVwiOiBcIl9zYmNzXCIsXG4gICAgICAgIFwiY2hhcnNcIjogXCLDhMSAxIHDicSEw5bDnMOhxIXEjMOkxI3EhsSHw6nFucW6xI7DrcSPxJLEk8SWw7PEl8O0w7bDtcO6xJrEm8O84oCgwrDEmMKjwqfigKLCtsOfwq7CqeKEosSZwqjiiaDEo8SuxK/EquKJpOKJpcSrxLbiiILiiJHFgsS7xLzEvcS+xLnEusWFxYbFg8Ks4oiaxYTFh+KIhsKrwrvigKbCoMWIxZDDlcWRxYzigJPigJTigJzigJ3igJjigJnDt+KXisWNxZTFlcWY4oC54oC6xZnFlsWXxaDigJrigJ7FocWaxZvDgcWkxaXDjcW9xb7FqsOTw5TFq8Wuw5rFr8WwxbHFssWzw53DvcS3xbvFgcW8xKLLh1wiXG4gICAgfSxcblxuICAgIFwiODA4XCI6IFwiY3A4MDhcIixcbiAgICBcImlibTgwOFwiOiBcImNwODA4XCIsXG4gICAgXCJjcDgwOFwiOiB7XG4gICAgICAgIFwidHlwZVwiOiBcIl9zYmNzXCIsXG4gICAgICAgIFwiY2hhcnNcIjogXCLQkNCR0JLQk9CU0JXQltCX0JjQmdCa0JvQnNCd0J7Qn9Cg0KHQotCj0KTQpdCm0KfQqNCp0KrQq9Cs0K3QrtCv0LDQsdCy0LPQtNC10LbQt9C40LnQutC70LzQvdC+0L/ilpHilpLilpPilILilKTilaHilaLilZbilZXilaPilZHilZfilZ3ilZzilZvilJDilJTilLTilKzilJzilIDilLzilZ7ilZ/ilZrilZTilanilabilaDilZDilazilafilajilaTilaXilZnilZjilZLilZPilavilarilJjilIzilojiloTilozilpDiloDRgNGB0YLRg9GE0YXRhtGH0YjRidGK0YvRjNGN0Y7Rj9CB0ZHQhNGU0IfRl9CO0Z7CsOKImcK34oia4oSW4oKs4pagwqBcIlxuICAgIH0sXG5cbiAgICAvLyBBbGlhc2VzIG9mIGdlbmVyYXRlZCBlbmNvZGluZ3MuXG4gICAgXCJhc2NpaThiaXRcIjogXCJhc2NpaVwiLFxuICAgIFwidXNhc2NpaVwiOiBcImFzY2lpXCIsXG4gICAgXCJhbnNpeDM0XCI6IFwiYXNjaWlcIixcbiAgICBcImFuc2l4MzQxOTY4XCI6IFwiYXNjaWlcIixcbiAgICBcImFuc2l4MzQxOTg2XCI6IFwiYXNjaWlcIixcbiAgICBcImNzYXNjaWlcIjogXCJhc2NpaVwiLFxuICAgIFwiY3AzNjdcIjogXCJhc2NpaVwiLFxuICAgIFwiaWJtMzY3XCI6IFwiYXNjaWlcIixcbiAgICBcImlzb2lyNlwiOiBcImFzY2lpXCIsXG4gICAgXCJpc282NDZ1c1wiOiBcImFzY2lpXCIsXG4gICAgXCJpc282NDZpcnZcIjogXCJhc2NpaVwiLFxuICAgIFwidXNcIjogXCJhc2NpaVwiLFxuXG4gICAgXCJsYXRpbjFcIjogXCJpc284ODU5MVwiLFxuICAgIFwibGF0aW4yXCI6IFwiaXNvODg1OTJcIixcbiAgICBcImxhdGluM1wiOiBcImlzbzg4NTkzXCIsXG4gICAgXCJsYXRpbjRcIjogXCJpc284ODU5NFwiLFxuICAgIFwibGF0aW41XCI6IFwiaXNvODg1OTlcIixcbiAgICBcImxhdGluNlwiOiBcImlzbzg4NTkxMFwiLFxuICAgIFwibGF0aW43XCI6IFwiaXNvODg1OTEzXCIsXG4gICAgXCJsYXRpbjhcIjogXCJpc284ODU5MTRcIixcbiAgICBcImxhdGluOVwiOiBcImlzbzg4NTkxNVwiLFxuICAgIFwibGF0aW4xMFwiOiBcImlzbzg4NTkxNlwiLFxuXG4gICAgXCJjc2lzb2xhdGluMVwiOiBcImlzbzg4NTkxXCIsXG4gICAgXCJjc2lzb2xhdGluMlwiOiBcImlzbzg4NTkyXCIsXG4gICAgXCJjc2lzb2xhdGluM1wiOiBcImlzbzg4NTkzXCIsXG4gICAgXCJjc2lzb2xhdGluNFwiOiBcImlzbzg4NTk0XCIsXG4gICAgXCJjc2lzb2xhdGluY3lyaWxsaWNcIjogXCJpc284ODU5NVwiLFxuICAgIFwiY3Npc29sYXRpbmFyYWJpY1wiOiBcImlzbzg4NTk2XCIsXG4gICAgXCJjc2lzb2xhdGluZ3JlZWtcIiA6IFwiaXNvODg1OTdcIixcbiAgICBcImNzaXNvbGF0aW5oZWJyZXdcIjogXCJpc284ODU5OFwiLFxuICAgIFwiY3Npc29sYXRpbjVcIjogXCJpc284ODU5OVwiLFxuICAgIFwiY3Npc29sYXRpbjZcIjogXCJpc284ODU5MTBcIixcblxuICAgIFwibDFcIjogXCJpc284ODU5MVwiLFxuICAgIFwibDJcIjogXCJpc284ODU5MlwiLFxuICAgIFwibDNcIjogXCJpc284ODU5M1wiLFxuICAgIFwibDRcIjogXCJpc284ODU5NFwiLFxuICAgIFwibDVcIjogXCJpc284ODU5OVwiLFxuICAgIFwibDZcIjogXCJpc284ODU5MTBcIixcbiAgICBcImw3XCI6IFwiaXNvODg1OTEzXCIsXG4gICAgXCJsOFwiOiBcImlzbzg4NTkxNFwiLFxuICAgIFwibDlcIjogXCJpc284ODU5MTVcIixcbiAgICBcImwxMFwiOiBcImlzbzg4NTkxNlwiLFxuXG4gICAgXCJpc29pcjE0XCI6IFwiaXNvNjQ2anBcIixcbiAgICBcImlzb2lyNTdcIjogXCJpc282NDZjblwiLFxuICAgIFwiaXNvaXIxMDBcIjogXCJpc284ODU5MVwiLFxuICAgIFwiaXNvaXIxMDFcIjogXCJpc284ODU5MlwiLFxuICAgIFwiaXNvaXIxMDlcIjogXCJpc284ODU5M1wiLFxuICAgIFwiaXNvaXIxMTBcIjogXCJpc284ODU5NFwiLFxuICAgIFwiaXNvaXIxNDRcIjogXCJpc284ODU5NVwiLFxuICAgIFwiaXNvaXIxMjdcIjogXCJpc284ODU5NlwiLFxuICAgIFwiaXNvaXIxMjZcIjogXCJpc284ODU5N1wiLFxuICAgIFwiaXNvaXIxMzhcIjogXCJpc284ODU5OFwiLFxuICAgIFwiaXNvaXIxNDhcIjogXCJpc284ODU5OVwiLFxuICAgIFwiaXNvaXIxNTdcIjogXCJpc284ODU5MTBcIixcbiAgICBcImlzb2lyMTY2XCI6IFwidGlzNjIwXCIsXG4gICAgXCJpc29pcjE3OVwiOiBcImlzbzg4NTkxM1wiLFxuICAgIFwiaXNvaXIxOTlcIjogXCJpc284ODU5MTRcIixcbiAgICBcImlzb2lyMjAzXCI6IFwiaXNvODg1OTE1XCIsXG4gICAgXCJpc29pcjIyNlwiOiBcImlzbzg4NTkxNlwiLFxuXG4gICAgXCJjcDgxOVwiOiBcImlzbzg4NTkxXCIsXG4gICAgXCJpYm04MTlcIjogXCJpc284ODU5MVwiLFxuXG4gICAgXCJjeXJpbGxpY1wiOiBcImlzbzg4NTk1XCIsXG5cbiAgICBcImFyYWJpY1wiOiBcImlzbzg4NTk2XCIsXG4gICAgXCJhcmFiaWM4XCI6IFwiaXNvODg1OTZcIixcbiAgICBcImVjbWExMTRcIjogXCJpc284ODU5NlwiLFxuICAgIFwiYXNtbzcwOFwiOiBcImlzbzg4NTk2XCIsXG5cbiAgICBcImdyZWVrXCIgOiBcImlzbzg4NTk3XCIsXG4gICAgXCJncmVlazhcIiA6IFwiaXNvODg1OTdcIixcbiAgICBcImVjbWExMThcIiA6IFwiaXNvODg1OTdcIixcbiAgICBcImVsb3Q5MjhcIiA6IFwiaXNvODg1OTdcIixcblxuICAgIFwiaGVicmV3XCI6IFwiaXNvODg1OThcIixcbiAgICBcImhlYnJldzhcIjogXCJpc284ODU5OFwiLFxuXG4gICAgXCJ0dXJraXNoXCI6IFwiaXNvODg1OTlcIixcbiAgICBcInR1cmtpc2g4XCI6IFwiaXNvODg1OTlcIixcblxuICAgIFwidGhhaVwiOiBcImlzbzg4NTkxMVwiLFxuICAgIFwidGhhaThcIjogXCJpc284ODU5MTFcIixcblxuICAgIFwiY2VsdGljXCI6IFwiaXNvODg1OTE0XCIsXG4gICAgXCJjZWx0aWM4XCI6IFwiaXNvODg1OTE0XCIsXG4gICAgXCJpc29jZWx0aWNcIjogXCJpc284ODU5MTRcIixcblxuICAgIFwidGlzNjIwMFwiOiBcInRpczYyMFwiLFxuICAgIFwidGlzNjIwMjUyOTFcIjogXCJ0aXM2MjBcIixcbiAgICBcInRpczYyMDI1MzMwXCI6IFwidGlzNjIwXCIsXG5cbiAgICBcIjEwMDAwXCI6IFwibWFjcm9tYW5cIixcbiAgICBcIjEwMDA2XCI6IFwibWFjZ3JlZWtcIixcbiAgICBcIjEwMDA3XCI6IFwibWFjY3lyaWxsaWNcIixcbiAgICBcIjEwMDc5XCI6IFwibWFjaWNlbGFuZFwiLFxuICAgIFwiMTAwODFcIjogXCJtYWN0dXJraXNoXCIsXG5cbiAgICBcImNzcGM4Y29kZXBhZ2U0MzdcIjogXCJjcDQzN1wiLFxuICAgIFwiY3NwYzc3NWJhbHRpY1wiOiBcImNwNzc1XCIsXG4gICAgXCJjc3BjODUwbXVsdGlsaW5ndWFsXCI6IFwiY3A4NTBcIixcbiAgICBcImNzcGNwODUyXCI6IFwiY3A4NTJcIixcbiAgICBcImNzcGM4NjJsYXRpbmhlYnJld1wiOiBcImNwODYyXCIsXG4gICAgXCJjcGdyXCI6IFwiY3A4NjlcIixcblxuICAgIFwibXNlZVwiOiBcImNwMTI1MFwiLFxuICAgIFwibXNjeXJsXCI6IFwiY3AxMjUxXCIsXG4gICAgXCJtc2Fuc2lcIjogXCJjcDEyNTJcIixcbiAgICBcIm1zZ3JlZWtcIjogXCJjcDEyNTNcIixcbiAgICBcIm1zdHVya1wiOiBcImNwMTI1NFwiLFxuICAgIFwibXNoZWJyXCI6IFwiY3AxMjU1XCIsXG4gICAgXCJtc2FyYWJcIjogXCJjcDEyNTZcIixcbiAgICBcIndpbmJhbHRyaW1cIjogXCJjcDEyNTdcIixcblxuICAgIFwiY3AyMDg2NlwiOiBcImtvaThyXCIsXG4gICAgXCIyMDg2NlwiOiBcImtvaThyXCIsXG4gICAgXCJpYm04NzhcIjogXCJrb2k4clwiLFxuICAgIFwiY3Nrb2k4clwiOiBcImtvaThyXCIsXG5cbiAgICBcImNwMjE4NjZcIjogXCJrb2k4dVwiLFxuICAgIFwiMjE4NjZcIjogXCJrb2k4dVwiLFxuICAgIFwiaWJtMTE2OFwiOiBcImtvaTh1XCIsXG5cbiAgICBcInN0cmsxMDQ4MjAwMlwiOiBcInJrMTA0OFwiLFxuXG4gICAgXCJ0Y3ZuNTcxMlwiOiBcInRjdm5cIixcbiAgICBcInRjdm41NzEyMVwiOiBcInRjdm5cIixcblxuICAgIFwiZ2IxOTg4ODBcIjogXCJpc282NDZjblwiLFxuICAgIFwiY25cIjogXCJpc282NDZjblwiLFxuXG4gICAgXCJjc2lzbzE0amlzYzYyMjByb1wiOiBcImlzbzY0NmpwXCIsXG4gICAgXCJqaXNjNjIyMDE5Njlyb1wiOiBcImlzbzY0NmpwXCIsXG4gICAgXCJqcFwiOiBcImlzbzY0NmpwXCIsXG5cbiAgICBcImNzaHByb21hbjhcIjogXCJocHJvbWFuOFwiLFxuICAgIFwicjhcIjogXCJocHJvbWFuOFwiLFxuICAgIFwicm9tYW44XCI6IFwiaHByb21hbjhcIixcbiAgICBcInhyb21hbjhcIjogXCJocHJvbWFuOFwiLFxuICAgIFwiaWJtMTA1MVwiOiBcImhwcm9tYW44XCIsXG5cbiAgICBcIm1hY1wiOiBcIm1hY2ludG9zaFwiLFxuICAgIFwiY3NtYWNpbnRvc2hcIjogXCJtYWNpbnRvc2hcIixcbn07XG5cbiIsIm1vZHVsZS5leHBvcnRzPVtcbltcIjg3NDBcIixcIuSPsOSwsuSYg+SWpuSVuPCniafktbfklrPwp7Kx5LOi8KezheOuleSctuSdhOSxh+SxgPCkir/wo5iX8KeNkvCmuovwp4OS5LGX8KqNkeSdj+SXmuSyhfCnsazktIfkqqTkmqHwpqyj54il8KWplPChqaPwo7iG8KO9oeaZjeWbu1wiXSxcbltcIjg3NjdcIixcIue2leWknfCorrnjt7TpnLTwp6+v5a+b8KG1nuWqpOOYpfCpurDlq5Hlrrfls7zmna7olpPwqaWF55Gh55Kd46G18KG1k/Cjmp7wpoCh47usXCJdLFxuW1wiODdhMVwiLFwi8KWjnuOrteervOm+l/CkhaHwqKSN8KOHqvCgqorwo4me5IyK6JKE6b6W6ZCv5KSw6JiT5aKW6Z2K6YiY56eQ56iy5pmg5qip6KKd55GM56+F5p6C56is5YmP6YGG45Om54+E8KW2ueeThum/h+Wes+Skr+WRjOSEsfCjmo7loJjnqbLwp62l6K6P5Jqu8Ka6iOSGgfCltpnnrq7wopK86b+I8KKTgfCik4nwopOM6b+J6JSE8KOWu+SCtOm/iuSTofCqt7/mi4Hnga7pv4tcIl0sXG5bXCI4ODQwXCIsXCLjh4BcIiw0LFwi8KCEjOOHhfCgg5HwoION44eG44eH8KCDi/Chv6jjh4jwoIOK44eJ44eK44eL44eM8KCEjuOHjeOHjsSAw4HHjcOAxJLDicSaw4jFjMOTx5HDkuC/v8OKzIThur7gv7/DisyM4buAw4rEgcOhx47DoMmRxJPDqcSbw6jEq8Otx5DDrMWNw7PHksOyxavDuseUw7nHlseYx5pcIl0sXG5bXCI4OGExXCIsXCLHnMO84L+/w6rMhOG6v+C/v8OqzIzhu4HDqsmh4o+a4o+bXCJdLFxuW1wiODk0MFwiLFwi8KqOqfChhYVcIl0sXG5bXCI4OTQzXCIsXCLmlIpcIl0sXG5bXCI4OTQ2XCIsXCLkuL3mu53ptY7ph59cIl0sXG5bXCI4OTRjXCIsXCLwp5y15pKR5Lya5Lyo5L6o5YWW5YW05Yac5Yek5Yqh5Yqo5Yy75Y2O5Y+R5Y+Y5Zui5aOw5aSE5aSH5aSy5aS05a2m5a6e5a6f5bKa5bqG5oC75paJ5p++5qCE5qGl5rWO54K855S157qk57qs57q657uH57uP57uf57yG57y36Im66IuP6I2v6KeG6K6+6K+i6L2m6L2n6L2uXCJdLFxuW1wiODlhMVwiLFwi55CR57O857eN5qWG56uJ5YinXCJdLFxuW1wiODlhYlwiLFwi6YaM56K46YWe6IK8XCJdLFxuW1wiODliMFwiLFwi6LSL6IO28KCnp1wiXSxcbltcIjg5YjVcIixcIuiCn+m7h+Szjem3iem4jOSwvvCpt7bwp4CO6biK8KqEs+OXgVwiXSxcbltcIjg5YzFcIixcIua6muiIvueUmVwiXSxcbltcIjg5YzVcIixcIuSkkemprOmqj+m+meemh/CokazwobeK8KCXkPCiq6bkuKTkuoHkuoDkuofkur/ku6vkvLfjkYzkvr3juYjlgIPlgojjkb3jkpPjkqXlhoblpIXlh5vlh7zliIXkuonlibnlipDljKfjl4fljqnjlZHljrDjlZPlj4LlkKPjla3jlbLjmoHlkpPlkqPlkrTlkrnlk5Dlk6/llJjllKPllKjjlpjllL/jlqXjlr/ll5fjl4VcIl0sXG5bXCI4YTQwXCIsXCLwp7aE5ZSlXCJdLFxuW1wiOGE0M1wiLFwi8KCxgvCgtJXwpYSr5ZaQ8KKzhuOnrPCgjYHouYbwpLa48KmTpeSBk/Cogr7nnbrworC446i05J+V8KiFnfCmp7LwpLeq5pOd8KC1vPCgvrTwoLOV8KGDtOaSjei5vvCgupbwoLCL8KC9pPCisqnwqImW8KSTk1wiXSxcbltcIjhhNjRcIixcIvCgtYbwqamN8KiDqeSftPCkuqfworOC6aqy46mn8KmXtOO/reOUhvCli4fwqZ+U8KejiPCitYTpta7poJVcIl0sXG5bXCI4YTc2XCIsXCLkj5nwpoKl5pK05ZOj8KK1jPCir4rwoYG346e78KGBr1wiXSxcbltcIjhhYTFcIixcIvCmm5rwppyW8KemoOaTqvClgZLwoLGD6Lmo8KKGofCorYzwoJyxXCJdLFxuW1wiOGFhY1wiLFwi5KCL8KCGqeO/uuWhs/Cito1cIl0sXG5bXCI4YWIyXCIsXCLwpJeI8KCTvPCmgpfwoL2M8KC2luWVueSCu+SOulwiXSxcbltcIjhhYmJcIixcIuSqtPCiqabwoYKd6Iaq6aO18KC2nOaNueOnvvCinbXot4DlmqHmkbzjuYNcIl0sXG5bXCI4YWM5XCIsXCLwqpiB8KC4ifCiq4/worOJXCJdLFxuW1wiOGFjZVwiLFwi8KGDiPCjp4LjppLjqIbwqIqb45W48KW5ifCig4flmZLwoLyx8KKysvCpnKDjkrzmsL3wpLi7XCJdLFxuW1wiOGFkZlwiLFwi8KeVtPCiuovwooiI8KqZm/Cos43woLm68KCwtPCmoJznvpPwoYOP8KKgg/CipLnjl7vwpYej8KC6jPCgvo3woLqq476T8KC8sPCgtYfwoYWP8KC5jFwiXSxcbltcIjhhZjZcIixcIvCguqvwoK6p8KC1iPChg4DwoYS947+58KKaluaQsvCgvq1cIl0sXG5bXCI4YjQwXCIsXCLwo4+08KeYufCir47woLW+8KC1v/CisZHworGV46iY8KC6mPChg4fwoLyu8KqYsvCmrZDwqLOS8Ki2mfCos4rplqrlk4zoi4TllrlcIl0sXG5bXCI4YjU1XCIsXCLwqbuD6bCm6aq28KednvCit67nhYDoha3og6zlsJzwppWy6IS0456X5Y2f8KiCvemGtvCgu7rwoLiP8KC5t/Cgu7vjl53wpLer45iJ8KCzluWar/CinrXwoYOJ8KC4kPCgubjwoYG48KGFiPCoiIfwoZGV8KC5ufCkuZDworak5amU8KGAnfChgJ7woYO18KGDtuWenPCguJFcIl0sXG5bXCI4YmExXCIsXCLwp5qU8KiLjfCgvrXwoLm78KWFvuOcg/CgvrbwoYaA8KWLmPCqir3wpKea8KGguvCkhbfwqIm85aKZ5Ymo45ia8KWcveeusuWtqOSggOSsrOm8p+Snp+mwn+mujfClrbTwo4S95Ze745ey5ZqJ5Lio5aSC8KGvgfCvobjpnZHwoIKG5Lmb5Lq745S+5bCj5b2R5b+E46O65omM5pS15q265rC15rC654Gs54ir5Lis54qt8KSjqee9kueku+ezuee9k/Cmiarjk4FcIl0sXG5bXCI4YmRlXCIsXCLwpo2L6ICC6IKA8KaYkvCmpZHljZ3ooaTop4Hwp6Ky6K6g6LSd6ZKF6ZW46ZW/6Zeo8Ki4j+mfpumhtemjjumjnumlo/CpoJDpsbzpuJ/pu4Tmra/vpIfkuLfwoIKH6Zid5oi36ZKiXCJdLFxuW1wiOGM0MFwiLFwi5YC75re+8Kmxs+m+puO3ieiij/CkhY7ngbfls7XkrKDwpYeN45WZ8KW0sOaEovCoqLLovqfph7bnhpHmnJnnjrrwo4qB8KqEh+Oyi/ChpoDkrJDno6TnkILlhq7wqJyP5ICJ5qmj8KqKuuSIo+iYj/Cgqa/nqKrwqaWH8KirqumdleeBjeWMpPCigb7pj7Tnm5nwqKej6b6n55+d5Lqj5L+w5YK85Liv5LyX6b6o5ZC057aL5aKS5aOQ8KG2tuW6kuW6meW/gvCinJLmlotcIl0sXG5bXCI4Y2ExXCIsXCLwo4+55qSZ5qmD8KOxo+azv1wiXSxcbltcIjhjYTdcIixcIueIgPCklIXnjozju5vwpKiT5ayV55K56K6D8KWypPClmpXnqpPnr6zns4Pnuazoi7jolpfpvqnoopDpvqrournpvqvov4/olZ/pp6DpiKHpvqzwqLa58KGQv+SBseSKouWomlwiXSxcbltcIjhjYzlcIixcIumhqOadq+SJtuWcvVwiXSxcbltcIjhjY2VcIixcIuiXlvCkpbvoir/wp4SN5LKB8Ka1tOW1u/CmrJXwpr6+6b6t6b6u5a6W6b6v5pun57mb5rmX56eK47aI5JOD8KOJlvCinpbkjprklLZcIl0sXG5bXCI4Y2U2XCIsXCLls5Xwo6ya6Ku55bG447SS8KOVkeW1uOm+sueFl+SVmPCkg6zwobij5LG346W445GK8KCGpPCmsYHoq4zkvrTwoIi55aa/6IWs6aGW8KmjuuW8u1wiXSxcbltcIjhkNDBcIixcIvCgrp9cIl0sXG5bXCI4ZDQyXCIsXCLwooeB8KilreSEguSau/CpgbnjvIfpvrPwqoa15IO445+W5Ju38KaxhuSFvPComrLwp4+/5JWt46OU8KWSmuSVoeSUm+S2ieSxu+S1tuSXquO/iPCkrI/jmaHkk57kkr3kh63ltL7ltYjltZbjt7zjoI/ltqTltrnjoKDjoLjluYLlur3lvKXlvoPjpIjjpJTjpL/jpY3mg5fmhL3ls6Xjponmhrfmhrnmh4/jprjmiKzmipDmi6XmjJjjp7jlmrFcIl0sXG5bXCI4ZGExXCIsXCLjqIPmj6Lmj7vmkIfmkZrjqYvmk4DltJXlmKHpvp/jqpfmlobjqr3ml7/mmZPjq7LmmpLjrKLmnJbjrYLmnqTmoIDjrZjmoYrmooTjrbLjrbHjrbvmpInmpYPniZzmpaTmpp/mpoXjrrzmp5bjr53mqaXmqbTmqbHmqoLjr6zmqpnjr7LmqqvmqrXmq5Tmq7bmroHmr4Hmr6rmsbXmsqrjs4vmtILmtIbmtKbmtoHjs6/mtqTmtrHmuJXmuJjmuKnmuobwqKeA5rq75rui5rua6b2/5ruo5rup5ryk5ry047WG8KO9gea+gea+vuO1quO1teeGt+WymeO2iueArOO2keeBkOeBlOeBr+eBv+eCifCgjKXkj4Hjl7HwoLuYXCJdLFxuW1wiOGU0MFwiLFwi8KO7l+WevvCmu5PnhL7wpZ+g45mO5qai8KivqeWttOepifClo6HwqZOZ56ml56m98KWmrOequ+eqsOerguerg+eHkfCmko3kh4rnq5rnq53nq6rkh6/lkrLwpbCB56yL562V56yp8KWMjvCls77nrqLnra/ojpzwpa608Kaxv+evkOiQoeeukueuuPCltKDjtq3wpbGl6JKS56+657CG57C18KWzgeexhOeyg/CkooLnsqbmmb3wpJW457OJ57OH57Om57G057Oz57O157OOXCJdLFxuW1wiOGVhMVwiLFwi57mn5JSd8Ka5hOe1nfCmu5bnko3ntonntqvnhLXntrPnt5LwpIGX8KaAqee3pOO0k+e3tfChn7nnt6XwqI2t57id8KaEofCmhZrnua7nupLkjKvpkaznuKfnvYDnvYHnvYfnpLbwpouQ6aeh576X8KaNkee+o/ChmaHwoIGo5JWc8KOdpuSUg/CojLrnv7rwppKJ6ICF6ICI6ICd6ICo6ICv8KqCh/Cms4PogLvogLzogaHwopyU5KaJ8KaYpvCjt6Pwppuo5pyl6IKn8KipiOiEh+iEmuWisPCim7bmsb/wppKY8KS+uOaTp/ChkoroiJjwoaGe5qmT8KSppfCkqpXkkbroiKnwoKyN8KapkvCjtb7kv7nwoZO96JOi6I2i8KasivCkpqfwo5Sw8KGds/Cjt7joiqrmpJvwr6aU5IebXCJdLFxuW1wiOGY0MFwiLFwi6JWL6IuQ6Iya8KC4lvChnrTjm4Hwo4W98KOVmuiJu+iLouiMmPCjuovwpraj8KashfCmrpfwo5eO47a/6Iyd5Zes6I6F5JSL8Ka2peiOrOiPgeiPk+ORvvCmu5TmqZfolZrjkpbwprmC8KK7r+iRmPClr6TokbHjt5Pkk6TmqqfokYrwo7K156WY6JKo8KaulvCmubfwprmD6JOe6JCP6I6R5JKg6JKT6JOk8KWykeSJgPCls4DklYPolLTlq7LwprqZ5JSn6JWz5JSW5p6/6JiWXCJdLFxuW1wiOGZhMVwiLFwi8KiYpfComLvol4Hwp4KI6JiC8KGWgvCng43wr6ay5JWq6Jio45mI8KGiouWPt/Cnjpromb7onbHwqoO46J+u8KKwp+ieseifmuigj+WZoeiZrOahluSYj+ihheihhvCnl6Dwo7a58KeXpOihnuiinOSZm+iitOiiteaPgeijheedt/CnnI/opofoporopqbopqnopqfoprzwqKil6Ken8KekpPCnqr3oqpznnpPph77oqpDwp6mZ56up8KesuvCjvo/knJPwp6y454W86KyM6Kyf8KWQsPCllaXorL/orYzorY3oqqnwpKm66K6Q6K6b6Kqv8KGbn+SYleihj+iym/CntZTwp7aP8K+nlOOcpfCntZPos5bwp7aY8Ke2vei0kui0g/ChpJDos5vngZzotJHwpLOJ47uQ6LW3XCJdLFxuW1wiOTA0MFwiLFwi6Lap8KiAgvChgJTwpKaK46288KiGvPCnhIznq6fouq3ourbou4Ppi5TovJnovK3wqI2l8KiQkui+pemMg/Cqip/woKmQ6L6z5KSq8KinnvColL3wo7a75bu48KOJoui/ufCqgJTwqJq88KiUgfCijKXjpoDwpruX6YC38KiUvPCnqr7pgaHwqJWs8KiYi+mCqPConJPpg4TwqJum6YKu6YO96YWn46uw6Yap6YeE57Ks8Kiks/ChuonpiI7msp/piYHpiaLwpZa56Yq58KirhvCjspvwqKyM8KWXm1wiXSxcbltcIjkwYTFcIixcIvCgtLHpjKzpjavwqKuh8Kivq+eCj+Wrg/Coq6LwqKul5KWl6YmE8KivrPCosLnwqK+/6Y2z6ZGb6Lq86ZaF6Zam6ZCm6Zag5r+25Iq58KKZuvCom5jwoYm88KO4ruSnn+awnOmZu+maluSFrOmao/Cmu5Xmh5rpmrbno7XwqKug6Zq95Y+M5Kah8KayuPCgibTwppCQ8KmCr/Cpg6XwpKuR8KGklfCjjIrpnLHomYLpnLbkqI/klL3kloXwpKup54G15a2B6Zyb6Z2c8KmHlemdl+WtivCph6vpnZ/pkKXlg5Dwo4K38KOCvOmeiemen+mesemevumfgOmfkumfoPClkazpn67nkJzwqZCz6Z+/6Z+18KmQnfCnpbrkq5HpoLTpoLPpoYvpoabjrI7wp4W147WR8KCYsPCkhZxcIl0sXG5bXCI5MTQwXCIsXCLwpZyG6aOK6aK36aOI6aOH5Ku/8Ka0p/Chm5PllrDpo6Hpo6bpo6zpjbjppLnwpKip5K2y8Kmhl/CppIXpp7XpqIzpqLvpqJDpqZjwpZyl45uE8KmCsfCpr5Xpq6Dpq6LwqayF6au05LCO6ayU6ayt8KiYgOWAtOmstPCmpqjjo4Pwo4G96a2Q6a2A8Km0vuWphfChoaPpro7wpImL6bCC6a+/6bCM8Km5qOm3lPCpvrfwqoaS8KqGq/Cqg6HwqoSj8KqHn+m1vum2g/CqhLTpuI7moohcIl0sXG5bXCI5MWExXCIsXCLpt4TwooWb8KqGk/CqiKDwoaS78KqIs+m0ufCqgrnwqoq06bqQ6bqV6bqe6bqi5LS06bqq6bqv8KSNpOm7geOtoOOnpeO0neS8suOevvCosKvpvILpvIjkrpbpkKTwprai6byX6byW6by55Zqf5ZqK6b2F6aa48KmCi+mfsuiRv+m9oum9qeernOm+jueIluSuvvCkpbXwpKa754W38KSnuPCkjYjwpKmR546e8KivmvCho7rnpp/wqKW+8Ki4tumNqemPs/CoqYTpi6zpjoHpj4vwqKWs8KSSueeIl+O7q+edsuepg+eDkPCkkbPwpI+454W+8KGfr+eCo/Chor7wo5aZ47uH8KGihfClkK/woZ+445yi8KGbu/ChoLnjm6HwoZ208KGjkfClvYvjnKPwoZuA5Z2b8KSopfChj77woYqoXCJdLFxuW1wiOTI0MFwiLFwi8KGPhvChkrbolIPwo5qm6JSD6JGV8KSmlPCnhaXwo7ix8KWVnPCju7vwp4GS5JO08KObrvCppp3wprym5p+545yz47CV47en5aGs8KGkouagkOSBl/CjnL/wpIOh8KSCi/CkhI/wprCh5ZOL5Zqe8KaaseWakvCgv5/woK6o8KC4jemPhvCorJPpjpzku7jlhKvjoJnwpJC25Lq88KCRpfCgjb/kvYvkvorwpZmR5amo8KCGq/Cgj4vjppnwoIyK8KCQlOOQteS8qfCgi4DwqLqz8KCJteirmvCgiIzkuphcIl0sXG5bXCI5MmExXCIsXCLlg43lhI3kvqLkvIPwpKiO8KO6iuS9guWAruWBrOWCgeS/jOS/peWBmOWDvOWFmeWFm+WFneWFnua5tvCjlpXwo7i58KO6v+a1svChooTwo7qJ5Yao5YeD8KCXoOSTnfCgkqPwoJKS8KCSkei1uvCoqpzwoJyO5YmZ5Yqk8KChs+WLoemNruSZuueGjPCkjozwoLCg8KSmrPChg6Tmp5HwoLid55G547ue55KZ55CU55GW546Y5K6O8KSqvPCkgo3lj5DjloTniI/wpIOJ5Za08KCNheWTjfCgr4blnJ3piZ3pm7Tpjabln53lno3lnb/jmL7lo4vlqpnwqKmG8KGbuvChna/woZyQ5ais5aa46YqP5am+5auP5aiS8KWlhvChp7PwoaGh8KSKleObtea0heeRg+WoofCluoNcIl0sXG5bXCI5MzQwXCIsXCLlqoHwqK+X8KCQk+mPoOeSjPChjIPnhIXkpbLpkIjwqKe76Y69456g5bCe5bKe5bme5bmI8KGmlvChpbzwo6uu5buN5a2P8KGkg/ChpITjnIHwoaKg45ud8KGbvuObk+iEqvCoqYfwoba68KORsvCopqjlvIzlvI7woaSn8KGeq+Wpq/ChnLvlrYTomJTwp5e96KGg5oG+8KKhoPCimKvlv5vjurjwopav8KKWvvCpgojwpr2z5oeA8KCAvvCggYbwopib5oaZ5oaY5oG18KKym/CitIfwpJuU8KmFjVwiXSxcbltcIjkzYTFcIixcIuaRsfCkmaXwoq2q46ip8KKsovCjkZDwqaOq8KK5uOaMt/CqkZvmkrbmjLHmj5HwpKej8KK1p+aKpPCisqHmkLvmlavmpbLjr7Two4KO8KOKrfCkponwo4qr5ZSN8KOLoPCho5nwqZC/5puO8KOKifCjhrPjq6DkhpDwpZaE8KisovCllo/woZu88KWVm/ClkKXno67wo4SD8KGgqvCjiLTjkaTwo4iP8KOGgvCki4nmmo7wprSk5pmr5K6T5piw8KehsPCht6vmmaPwo4uS8KOLoeaYnvClobLjo5Hwo6C68KOevOOumfCjnqLwo4++55OQ466W5p6P8KSYquaituagnuOvhOaqvuOho/Cjn5XwpJKH5qiz5qmS5quJ5qyF8KGkkuaUkeaimOapjOOvl+apuuatl/Cjv4Dwo7Ka6Y6g6Yuy8KivqvCoq4tcIl0sXG5bXCI5NDQwXCIsXCLpionwqICe8KinnOmRp+a2pea8i/Ckp6zmtafwo72/47aP5riE8KSAvOWovea4iuWhh+a0pOehgueEu/CkjJrwpIm254Ox54mQ54qH54qU8KSej/CknKXlhbnwpKqk8KCXq+eRuvCju7jwo5mf8KSpivCkpJfwpb+h47yG47qx8KSrn/CosKPwo7y15oKn47uz55OM55C86Y6H55C35JKf8Ka3quSVkeeWg+O9o/Cks5nwpLSG472Y55WV55mz8KqXhuOsmeeRqPCoq4zwpKar8KSmjuOru1wiXSxcbltcIjk0YTFcIixcIuO3jfCkqY7ju7/wpKeF8KSjs+mHuuWcsumNgvCoq6PwoaGk5YOf8KWIofClh6fnnbjwo4iy55yO55yP55278KSal/CjnoHjqZ7wpKOw55C455Kb47q/8KSquvCkq4fkg4jwpKqW8KaGrumMh/ClloHnoJ7noo3noojno5Lnj5DnpZnwp52B8KWbo+SEjuemm+iSluempeaorfCju7rnqLrnp7Tkha7woZum5ISy6Yi156ex8KC1jPCkpozwoIqZ8KO2uvChna7jlpfllavjlbDjmqrwoIeU8KCwjeerouWpmfCim7Xwpaqv8KWqnOWojfCgiZvno7DlqKrwpa+G56u+5Ie557Gd57Gt5IiR8KWus/Clurzwpbqm57ON8KSnufChnrDnso7nsbznsq7mqrLnt5znuIfnt5PnvY7wpomhXCJdLFxuW1wiOTU0MFwiLFwi8KaFnPCnrYjntpfwpbqC5Imq8KattfCgpJbmn5bwoIGO8KOXj+WfhPCmkJLwpo+48KSloue/neesp/CgoKzwpaup8KW1g+esjPCluI7pp6bomYXpqaPmqJzwo5C/46ei8KSnt/Cmlq3pqJ/wppag6JKA8KeEp/Cms5Hkk6rohLfkkILog4bohInohYLwpp606aOD8KapguiJouiJpfCmqZHokZPwpran6JiQ8KeIm+WqhuSFv/ChoYDlrKvwoaKh5auk8KGjmOiaoPCvprzwo7aP6KCt8KeQouWoglwiXSxcbltcIjk1YTFcIixcIuihruS9heiih+iiv+ijpuilpeiljfClmoPopZTwp56F8KeehPCor7XwqK+Z8KiunPCop7njuq3okqPkm7Xkm4/jn7LoqL3oqJzwqZGI5b2N6Yir8KSKhOaXlOeEqeeDhPChoYXpta3osp/os6nwp7ec5aaa55+D5aew5I2u45uU6Liq6Lqn8KSwiei8sOi9iuSLtOaxmOa+u/CijKHkopvmvbnmuovwoZ+a6a+p45q18KSkr+mCu+mCl+WVseSkhumGu+mQhPCoqYvkgaLwqKu86ZCn8KiwnfCosLvok6XoqKvplpnplqfplpfplpbwqLS055GF47uC8KSjv/CkqYLwpI+q47un8KOIpemaj/Cou6fwqLmm8Ki5peO7jPCkp63wpKm48KO/rueQkueRq+O7vOmdgfCpgrBcIl0sXG5bXCI5NjQwXCIsXCLmoYfkqJ3wqYKT8KWfn+mdnemNqPCoponwqLCm8Kisr/Cmjr7pirrlrJHorankpLznj7nwpIib6Z6b6Z2x6aS48KC8puW3gfCor4XwpKqy6aCf8KmTmumLtvCpl5fph6Xkk4DwqK2Q8KSpp/CoraTpo5zwqKmF47yA6Yiq5KSl6JCU6aS76aWN8KeshuO3vemmm+Str+mmqumpnPCoraXwpaOI5qqP6aih5au+6aiv8KmjseSukPCppYjpprzkrr3krpfpjb3lobLwoYyC5aCi8KSmuFwiXSxcbltcIjk2YTFcIixcIvChk6jnoYTwopyf8KO2uOajheO1vemRmOOkp+aFkPCinoHwoqWr5oSH6bGP6bGT6bG76bC16bCQ6a2/6a+P8Km4remun/Cqh7XwqoO+6bSh5LKu8KSEhOm4mOSysOm0jPCqhrTwqoOt8KqDs/CppK/ptqXokr3wpriS8Ka/n/CmroLol7zklLPwprak8Ka6hPCmt7DokKDol67wpriA8KOfl/CmgaTnp6Lwo5ac8KOZgOSkrfCkp57jtaLpj5vpir7pjYjwoIq/56K56Ym36ZGN5L+k45GA6YGk8KWVneegveehlOeituehi/ChnZfwo4eJ8KSlgeOamuS9sua/mua/meeAnueAnuWQlPCkhrXlnrvlo7PlnorptJbln5fnhLTjkq/wpIas54er8KaxgPCkvpflrKjwoZ618KipiVwiXSxcbltcIjk3NDBcIixcIuaEjOWrjuWoi+SKvPCkkojjnKzkrbvwqKe86Y676Y648KGjlvCgvJ3okbLwprOA8KGQk/Cki7rworCm8KSPgeWmlPCjtrfwpp2B57ao8KaFm/CmgqTwpKa58KSmi/Cop7rpi6Xnj6Lju6nnkrTwqK2j8KGin+O7ofCkqrPmq5jnj7Pnj7vju5bwpKi+8KSqlPChn5nwpKmm8KCOp/ChkKTwpKel55GI8KSklueCpfCkpbbpioTnj6bpjZ/woJO+6Yyx8KirjvCoqJbpjobwqK+n8KWXleSktfCoqoLnhatcIl0sXG5bXCI5N2ExXCIsXCLwpKWD8KCzv+WapPCgmJrwoK+r8KCyuOWUguenhPChn7rnt77woZuC8KSpkPChoZLklK7pkIHjnIrwqKuA8KSmreWmsPChor/woaKD8KeShOWqoeObovCjtZvjmrDpiZ/lqbnwqKqB8KGhoumNtOOzjfCgqrTkqpbjporlg7TjtanjtYzwoY6c54W15Iu78KiImOa4j/Cpg6Tkk6vmtZfwp7mP54Gn5rKv47OW8KO/rfCjuK3muILmvIzjta/woI+155WR45q845OI5JqA47ua5KGx5aeE6Ymu5KS+6L2B8KiwnPCmr4DloJLln4jjm5bwoZGS54O+8KSNovCkqbHwor+j8KGKsPCijr3mornmpafwoY6Y8KOTpfCnr7Two5uf8Kiqg/Cjn5bwo4+68KSyn+aomvCjmq3wprK36JC+5JOf5JOOXCJdLFxuW1wiOTg0MFwiLFwi8Ka0pvCmtZHwprKC8Ka/nua8l/CnhInojL3woZy66I+t8KaygPCngZPwoZ+b5aaJ5aqC8KGes+WpoeWpsfChpIXwpIe845yt5aev8KGcvOObh+eGjumOkOaamvCkiqXlqa7lqKvwpIqT5qir8KO7ufCnnLbwpJGb8KSLiueEnfCkiZnwqKeh5L6w8Ka0qOWzgvCkk47wp7mN8KSOveaojPCkiZbwoYyE54Km54Sz8KSPqeO2peazn/CvoKXwpKmP57ml5aer5bSv47ez5b2c8KSpnfChn5/ntqTokKZcIl0sXG5bXCI5OGExXCIsXCLlkoXwo6u68KOMgPCgiJTlnb7woKOV8KCYmeO/pfChvp7wqoq254CD8KmFm+W1sOeOj+ezk/CoqZnwqZCg5L+I57+n54uN54yQ8KertOeMuOeMufClm7bnjYHnjYjjuqnwp6yY6YGs54e18KSjsuePoeiHtuO7iuecjOO7keayouWbveeQmeeQnueQn+O7ouO7sOO7tOO7uueTk+O8juO9k+eVgueVreeVsueWjeO9vOeXiOeXnOO/gOeZjeO/l+eZtOO/nOeZuvCkvZznhojlmKPopoDloankgJ3nnYPkgLnmnaHkgYXjl5vnnpjkgarkga/lsZ7nnr7nn4vlo7LnoJjngrnnoJzkgqjnoLnnoYfnoZHnoabokYjwpZS156Sz5qCD56Sy5ISDXCJdLFxuW1wiOTk0MFwiLFwi5ISJ56aR56aZ6L6756iG6L685IWn56qR5Iay56q86Im55IeE56uP56ub5IeP5Lih562i562s562757CS57Cb5Img5Im657G757Kc5IqM57K45IqU57Ot6L6T54OA8KCzj+e3j+e3lOe3kOe3vee+rue+tOeKn+SOl+iAoOiApeesueiAruiAseiBlOO3jOWetOeCoOiCt+iDqeSPreiEjOeMquiEjuiEkueVoOiElOSQgeOsueiFluiFmeiFmlwiXSxcbltcIjk5YTFcIixcIuSQk+WguuiFvOiGhOSQpeiGk+SQreiGpeWfr+iHgeiHpOiJlOSSj+iKpuiJtuiLiuiLmOiLv+SSsOiNl+mZqeamiuiQheeDteiRpOaDo+iSiOSUhOiSvuiToeiTuOiUkOiUuOiVkuSUu+iVr+iVsOiXoOSVt+iZsuiakuiasuibr+mZheiei+SYhuSYl+iiruijv+ikpOilh+imkfCnpafoqKnoqLjoqpToqrTosZHos5Tos7LotJzknpjloZ/ot4Pkn63ku67ouLrll5jlnZToubHll7XourDkoLfou47ou6Lou6Tou63ou7Lovrfov4Hov4rov4zpgLPpp4Tkoq3po6DpiJPkpJ7piKjpiZjpiavpirHpiq7pir9cIl0sXG5bXCI5YTQwXCIsXCLpi6Ppi6vpi7Ppi7Tpi73pjYPpjoTpjq3kpYXkpZHpur/pkJfljIHpkJ3pkK3pkL7kparpkZTpkbnplK3plqLkpqfpl7TpmLPkp6XmnqDkqKTpnYDkqLXpnrLpn4LlmZTkq6Tmg6jpornkrJnpo7HloYTppI7ppJnlhrTppJzppLfppYLppZ3ppaLkrbDpp4Xkrp3pqLzprI/nqoPpranproHpr53pr7Hpr7Tksa3psKDjna/woa+C6bWJ6bC6XCJdLFxuW1wiOWFhMVwiLFwi6bu+5ZmQ6baT6ba96beA6be86ZO26L626bm76bqs6bqx6bq96buG6ZOc6bui6bux6bu456uI6b2E8KCClPCgirfwoI6g5qSa6ZOD5aas8KCTl+WhgOmTgeOeufCgl5XwoJiV8KCZtvChmrrlnZfnhbPwoKuC8KCrjfCgrr/lkarwr6C78KCvi+WSnvCgr7vwoLC78KCxk/CgsaXwoLG85oOn8KCyjeWZuvCgsrXwoLOd8KCzrfCgta/woLay8KC3iOallemwr+iepfCguITwoLiO8KC7l/CgvpDwoLyt8KC5s+WwoPCgvrzluIvwoYGc8KGBj/ChgbbmnJ7woYG78KGCiPChgpbjmYfwoYK/8KGDk/ChhK/woYS75Y2k6JKt8KGLo/ChjbXwoYy26K6B8KGVt/ChmJnwoZ+D8KGfh+S5uOeCu/ChoK3woaWqXCJdLFxuW1wiOWI0MFwiLFwi8KGorfChqYXwobCq8KGxsPChsqzwobuI5ouD8KG7lfChvJXnhpjmoZXwooGF5qep45uI8KKJvPCij5fwoo+68KKcqvCiobHwoqWP6Iu98KKlp/CippPwoquV6Kal8KKrqOi+oPCirI7pnrjwoqy/6aGH6aq98KKxjFwiXSxcbltcIjliNjJcIixcIvCisojworK38KWvqPCitIjworSS8KK2t/CitpXwormC8KK9tPCiv4zwo4Cz8KOBpvCjjJ/wo4+e5b6x5pmI5pq/8KepufCjlafwo5ez54iB8KSmuuefl/CjmJrwo5yW57qH8KCNhuWiteacjlwiXSxcbltcIjliYTFcIixcIuakmPCjqqfwp5mX8KW/ovCjuJHwo7q58KeXvvCigprko5DkqrjwpISZ8KiqmvCki67wpIyN8KSAu/CkjLTwpI6W8KSphfCgl4rlh5LwoJiR5aaf8KG6qOOuvvCjs7/wpJCE8KSTluWeiPCkmbTjppvwpJyv8KiXqPCpp4njnaLwooeD6K2e8KitjumnlvCkoJLwpKO78KSoleeIifCkq4DwoLG45aWl8KS6pfCkvobwoJ256Lua8KWArOWKj+Wcv+eFsfClipnwpZCZ8KO9ivCkqqfllrzwpZGG8KWRrvCmrZLph5TjkbPwpZS/8KeYsvCllZ7knJjwpZWi8KWVpvCln4fwpKS/8KWhneWBpuOTu/Cjj4zmg57wpaSD5J288KiliPClqq7wpa6J8KWwhvChtpDlnqHnhZHmvrbwpoSC8KewkumBlvCmhrLwpL6a6K2i8KaQgvCmkYpcIl0sXG5bXCI5YzQwXCIsXCLltZvwpq+36Ly28KaShPChpJzoq6rwpKe28KaSiPCjv6/wppSS5K+A8KaWv/CmmrXwopyb6ZGl8KWfoeaGleWop/Cvo43kvrvlmrnwpJSh8KabvOS5qvCkpLTpmZbmto/wprK945iY6KW38KaemfCmoa7wppCR8KahnueHn/Cmo4fnrYLwqYOA8KCokfCmpKbphITwpqS556mF6bew8KanuumopvCmqK3jmZ/wppGp8KCAoeemg/CmqLTwpq2b5bSs8KOUmeiPj/Cmrp3km5DwprKk55S76KGl8Ka2ruWitlwiXSxcbltcIjljYTFcIixcIuOcnPCilo3wp4GL8KeHjeOxlPCnioDwp4qF6YqB8KKFuvCniovpjLDwp4um8KSnkOawuemSn/CnkZDwoLu46KCn6KO18KKkpvCokbPwoZ6x5rq48KSoqvChoKDjpqTjmrnlsJDnp6PklL/mmrbwqbKt8KmipOilg/Cnn4zwp6GY5ZuW5IOf8KGYiuOmofCjnK/wqIOo8KGPheeGreiNpvCnp53wqYao5amn5LK38KeCr/Copqvwp6e98KeoivCnrIvwp7Wm8KSFuuetg+elvvCogInmvrXwqouf5qiD8KiMmOWOovCmuIfpjr/moLbpnZ3wqIWv8KiAo/CmprXwoY+t8KOIr/CogYjltoXwqLCw8KiCg+Wclemgo/CopYnltqvwpKaI5pa+5qeV5Y+S8KSqpfCjvoHjsJHmnLbwqIKQ8KiDtPCohK7wob6h8KiFj1wiXSxcbltcIjlkNDBcIixcIvCohonwqIav8KiImvCojIbwqIyv8KiOiuOXivCokajwqJqq5KO65o+m8KilluegiOmJlfCoprjkj7LwqKen5I+f8KinqPCorYbwqK+U5ae48Kiwiei8i/Cov4XwqYOs562R8KmEkPCphLzjt7fwqYWe8KSriui/kOeKj+Wai/Cpk6fwqZep8KmWsPCplrjwqZyy8KmjkfCppYnwqaWq8Kmng/CpqKjwqayO8Km1mvCptpvnup/wqbu48Km8o+SypOmVh/CqipPnhqLwqou/5LaR6YCS8KqXi+S2nPCgspzovr7ll4FcIl0sXG5bXCI5ZGExXCIsXCLovrrwopKw6L658KSqk+SUiee5v+a9luaqseS7quOTpPCorKzwp6Kd45y66LqA8KGftfCogKTwqK2s8KiumfCnqL7wppqv47er8KeZlfCjsrfwpZi18KWlluS6mvCluoHwpomY5Zq/8KC5rei4juWtrfCjuojwpLKe5o+e5ouQ8KGftvChobvmlLDlmK3wpbGK5ZCa8KWMkeO3hvCptpjksb3lmKLlmJ7nvYnwpbuY5aW18KO1gOidsOS4nPCgv6rwoLWJ8KOauuiEl+m1nui0mOeYu+mxheeZjueeuemNheWQsuiFiOiLt+WYpeiEsuiQmOiCveWXquelouWZg+WQlvCgup3jl47lmIXll7Hmm7HwqIui45it55S05Zew5Za65ZKX5ZWy8KCxgfCgspblu5DwpYWI8KC5tvCisaJcIl0sXG5bXCI5ZTQwXCIsXCLwoLqi6bqr57Wa5Zee8KGBteaKnemdreWSlOizjeeHtumFtuaPvOaOueaPvuWVqfCirYPpsbLworqz5Yaa45Of8KC2p+WGp+WRjeWUnuWUk+eZpui4rfCmoornlrHogrbooITonoboo4fohrbokJzwoYOB5JOs54yE8KSchuWukOiMi/CmopPlmbvwopu08Ke0r/CkhqPwp7Wz8Ka7kPCnirbphbDwoYeZ6YiI8KOzvPCqmqnwoLqs8KC7ueeJpvChsqLknY7wpL+C8Ke/ufCgv6vkg7pcIl0sXG5bXCI5ZWExXCIsXCLpsZ3mlJ/worag5KOz8KSfoPCptbzwoL+s8KC4iuaBovCnlqPwoL+tXCJdLFxuW1wiOWVhZFwiLFwi8KaBiPChhofnhqPnuo7ptZDkuJrkuITjlbflrI3msrLljafjmqzjp5zljb3jmqXwpJiY5aKa8KStruiIreWRi+WeqvClqpXwoKW5XCJdLFxuW1wiOWVjNVwiLFwi46mS8KKRpeeNtPCpuqzktInpr63wo7O+8Km8sOSxm/CkvqnwqZae8Km/nuiRnPCjtrbwp4qy8Kaes/CjnKDmjK7ntKXwo7u38KO4rOOoqumAiOWLjOO5tOOZuuSXqfCgko7nmYDlq7DwoLq256G68Ke8ruWip+SCv+WZvOmui+W1tOeZlPCqkLTpuoXks6Hnl7njn7vmhJnwo4Oa8KSPslwiXSxcbltcIjllZjVcIixcIuWZnfChiqnlnqfwpKWj8Km4huWItPCngq7jlq3msYrptbxcIl0sXG5bXCI5ZjQwXCIsXCLnsZbprLnln57woZ2s5bGT5pOT8KmTkPCmjLXwp4Wk6Jqt8KC0qPCmtKLwpKui8KC1sVwiXSxcbltcIjlmNGZcIixcIuWHvvChvI/lto7pnIPwobeR6bqB6YGM56yf6ayC5bOR566j5omo5oy16au/56+P6ayq57G+6ayu57GC57KG6bCV56+86ayJ6byX6bCb8KSkvum9muWVs+Wvg+S/vem6mOS/suWJoOO4huWLkeWdp+WBluWmt+W4kumfiOm2q+i9nOWRqemetOmlgOmeuuWMrOaEsFwiXSxcbltcIjlmYTFcIixcIuakrOWPmumwium0guSwu+mZgeamgOWCpueVhvChna3pp5rlibNcIl0sXG5bXCI5ZmFlXCIsXCLphZnpmoHphZxcIl0sXG5bXCI5ZmIyXCIsXCLphZHwqLqX5o2/8Ka0o+ariuWYkemGjueVuuaKhfCgj7znjY/nsbDwpbCh8KOzvVwiXSxcbltcIjlmYzFcIixcIvCkpJnnm5bprp3kuKrwoLOU6I6+6KGCXCJdLFxuW1wiOWZjOVwiLFwi5bGK5qeA5YOt5Z265Yif5be15LuO5rCx8KCHsuS8ueWSnOWTmuWKmui2guOXvuW8jOOXs1wiXSxcbltcIjlmZGJcIixcIuatkumFvOm+pemul+mgrumitOmquum6qOm6hOeFuueslFwiXSxcbltcIjlmZTdcIixcIuavuuigmOe9uFwiXSxcbltcIjlmZWJcIixcIuWYoPCqmYroubfpvZNcIl0sXG5bXCI5ZmYwXCIsXCLot5TouY/puJzouIHmioLwqI296Lio6Lm156uT8KSpt+eovuejmOazquipp+eYh1wiXSxcbltcImEwNDBcIixcIvCoqZrpvKbms47on5bnl4Pwqoqy56GT8K+hgOi0jOeLoueNseisreeMgueTseizq/CkqrvomK/lvrrooqDkkrdcIl0sXG5bXCJhMDU1XCIsXCLwoaC78Ka4hVwiXSxcbltcImEwNThcIixcIuipvvCilJtcIl0sXG5bXCJhMDViXCIsXCLmg73nmafpq5fptYTpja7pro/on7VcIl0sXG5bXCJhMDYzXCIsXCLooI/os7fnjKzpnKHprrDjl5bnirLksIfnsZHppYrwpoWZ5oWZ5LCE6bqW5oW9XCJdLFxuW1wiYTA3M1wiLFwi5Z2f5oWv5oqm5oi55ouO46mc5oei5Y6q8KOPteaNpOagguOXklwiXSxcbltcImEwYTFcIixcIuW1l/Cor4Lov5rwqLi5XCJdLFxuW1wiYTBhNlwiLFwi5YOZ8KG1huekhuWMsumYuPCgvLvkgaVcIl0sXG5bXCJhMGFlXCIsXCLnn75cIl0sXG5bXCJhMGIwXCIsXCLns4Lwpbya57Oa56it6IGm6IGj57WN55SF55Oy6KaU6Iia5pyM6IGi8KeShuiBm+eTsOiEg+ecpOimifCmn4znlZPwpruR6J6p6J+O6IeI6J6M6KmJ6LKt6K2D55yr55O46JOa45i15qay6LamXCJdLFxuW1wiYTBkNFwiLFwi6Kap55Go5ra56J+B8KSAkeeTp+O3m+eFtuaCpOaGnOOzkeeFouaBt1wiXSxcbltcImEwZTJcIixcIue9sfCorK3niZDmg6nkrb7liKDjsJjwo7OH8KW7l/CnmZbwpZSx8KGlhPChi77wqaSD8Ka3nPCngq3ls4Hwpoat8Kioj/CjmbfwoIOu8KahhvCkvI7klaLlrJ/wpo2M6b2Q6bqm8KaJq1wiXSxcbltcImEzYzBcIixcIuKQgFwiLDMxLFwi4pChXCJdLFxuW1wiYzZhMVwiLFwi4pGgXCIsOSxcIuKRtFwiLDksXCLihbBcIiw5LFwi5Li25Li/5LqF5Lqg5YaC5YaW5Yar5Yu55Yy45Y2p5Y625aSK5a6A5beb4ryz5bm/5bu05b2Q5b2h5pS05peg55aS55m26L616Zq2wqjLhuODveODvuOCneOCnuOAg+S7neOAheOAhuOAh+ODvO+8u++8veKcveOBgVwiLDIzXSxcbltcImM3NDBcIixcIuOBmVwiLDU4LFwi44Kh44Ki44Kj44KkXCJdLFxuW1wiYzdhMVwiLFwi44KlXCIsODEsXCLQkFwiLDUsXCLQgdCWXCIsNF0sXG5bXCJjODQwXCIsXCLQm1wiLDI2LFwi0ZHQtlwiLDI1LFwi4oen4oa44oa544eP8KCDjOS5mvCggorliILkkpFcIl0sXG5bXCJjOGExXCIsXCLpvrDlhojpvrHwp5iHXCJdLFxuW1wiYzhjZFwiLFwi77+i77+k77yH77yC44ix4oSW4oSh44Kb44Kc4rqA4rqE4rqG4rqH4rqI4rqK4rqM4rqN4rqV4rqc4rqd4rql4rqn4rqq4rqs4rqu4rq24rq84rq+4ruG4ruK4ruM4ruN4ruP4ruW4ruX4rue4rujXCJdLFxuW1wiYzhmNVwiLFwiyoPJkMmbyZTJtcWTw7jFi8qKyapcIl0sXG5bXCJmOWZlXCIsXCLvv61cIl0sXG5bXCJmYTQwXCIsXCLwoJWH6Yub8KCXn/Cjv4XolYzkirXnj6/lhrXjmYnwpKWC8KinpOmNhPChp5voi67wo7OI56C85p2E5ouf8KSks/CopqrwoIqg8Kaus/ChjIXkvqvwopOt5YCI8Ka0qfCnqoTwo5iA8KSqsfCilJPlgKnwoI2+5b6k8KCOgPCgjYfmu5vwoJCf5YG95YSB45G65YSO6aGs452D6JCW8KSmpPCgkoflhaDwo4605YWq8KCvv/Cig7zwoIul8KKUsPCglo7wo4iz8KGmg+WuguidvfCglrPwo7KZ5Yay5Ya4XCJdLFxuW1wiZmFhMVwiLFwi6bS05YeJ5YeP5YeR47Oc5YeT8KSqpuWGs+WHouWNguWHreiPjeakvvCjnK3lvbvliIvliKbliLzlirXliZflipTlirnli4XnsJXolYLli6DomI3wpqyT5YyF8KirnuWViea7mfCjvoDwoKWU8KO/rOWMs+WNhPCgr6Lms4vwoZym5qCb54+V5oGK47qq46OM8KGbqOeHneSSouWNreWNtPComqvljb7ljb/woZaW8KGYk+efpuWOk/CoqpvljqDljqvljq7njqfwpZ2y472Z546c5Y+B5Y+F5rGJ5LmJ5Z++5Y+Z46qr8KCuj+WPoPCjv6vworaj5Y+28KCxt+WQk+eBueWUq+aZl+a1m+WRrfCmrZPwoLW05ZWd5ZKP5ZKk5J6m8KGcjfCgu53jtrTwoLWNXCJdLFxuW1wiZmI0MFwiLFwi8KimvPCimpjllYfks63lkK/nkJfllobllqnlmIXwoaOX8KSAuuSVkvCkkLXmmrPwoYK05Zi35puN8KOKiuaapOaareWZjeWZj+ejseWbsemeh+WPvuWcgOWbr+WbrfCorabjmKPwoYmP5Z2G8KSGpeaxrueCi+WdguOasfCmsb7ln6bwoZCW5aCD8KGRlPCkjaPloKbwpK+15aGc5aKq45Wh5aOg5aOc8KGIvOWju+Wvv+Wdg/CqhZDwpIm46Y+T45ah5aSf5qKm45uD5rmZXCJdLFxuW1wiZmJhMVwiLFwi8KGYvuWopOWVk/ChmpLolIXlp4nwoLWO8KaygfCmtKrwoZ+c5aeZ8KGfu/ChnrLwpram5rWx8KGgqPChm5Xlp7nwprmF5aqr5amj45um8KSmqeWpt+OciOWqlueRpeWrk/CmvqHwopWU47aF8KGkkeOcsvChmrjluoPli5Dlrbbmlojlrbzwp6iO5ICE5KGd8KCIhOWvleaFoPChqLTwpaeM8KCWpeWvs+WuneS0kOWwhfChrYTlsJPnj47lsJTwobKl8KasqOWxieSjneWyheWzqeWzr+W2i/Cht7nwobi35bSQ5bSY5bWG8KG6pOWyuuW3l+iLvOOgrfCkpIHwooGJ8KKFs+iKh+OgtuOvguW4ruaqiuW5teW5uvCkkrzwoLOT5Y6m5Lq35buQ5Y6o8KGdseW4ieW7tPCokoJcIl0sXG5bXCJmYzQwXCIsXCLlu7nlu7vjoqDlu7zmoL7pkJvlvI3woIeB8K+ilOOrnuSirvChjLrlvLrwpqKI8KKPkOW9mPCikbHlvaPpnr3wprmu5b2y6Y2A8KiotuW+p+W2tuO1n/CliZDwob2q8KeDuPCimajph5bwoIqe8KioqeaAseaahfChobfjpaPjt4fjmLnlnpDwop6056Wx47mA5oKe5oKk5oKz8KSmgvCkpo/wp6mT55Kk5YOh5aqg5oWk6JCk5oWC8K+ipvCmu5LmhoHlh7TwoJmW5oaH5a6q8KO+t1wiXSxcbltcImZjYTFcIixcIvCioZ/mh5PwqK6d8KmlneaHkOOksvCipoDwoqOB5oCj5oWc5pSe5o6L8KCEmOaLhfChnbDmi5XworiN5o2s8KSnn+Ool+aQuOaPuPChjo7woZ+85pKQ5r6K8KK4tumglPCkgozwpZyd5pOh5pOl6ZG746mm5pC646mX5pWN5ryW8KSoqPCkqKPmloXmla3mlZ/wo4G+5pa18KSlgOSst+aXkeSDmPChoKnml6Dml6Plv5/wo5CA5piY8KOHt/Cjh7jmmYTwo4ak8KOGpeaZi/CgubXmmafwpYem5pmz5pm08KG4vfCjiLHwqJe08KOHiPCljJPnn4XwoqO36aak5pyC8KSOnPCkqKHjrKvmp7rwo5+C5p2e5p2n5p2i8KSHjfCpg63mn5fkk6nmoKLmuZDpiLzmoIHwo4+m8Ka2oOahnVwiXSxcbltcImZkNDBcIixcIvCjka/mp6HmqIvwqKuf5qWz5qOD8KOXjeakgeakgOO0suOogfCjmLzjroDmnqzmpaHwqKmK5Iu85qS25qaY466h8KCPieiNo+WCkOanufCjmZnwooSq5qmF8KOcg+aqneOvs+aeseariPCphpzjsI3mrJ3woKSj5oOe5qy15q208KKfjea6tfCjq5vwoI618KGlmOOdgOWQofCjrZrmr6Hwo7u85q+c5rC38KKSi/Cko7Hwpq2R5rGa6Iim5rG58KO2vOSThfCjtr3wpIak8KSkjPCkpIBcIl0sXG5bXCJmZGExXCIsXCLwo7OJ45ul47Or8KC0sumug/Cjh7nwopKR576P5qC38Ka0pfCmtqHwprer5raW5rWc5rm85ryE8KSlv/CkgoXwprmy6JSz8Ka9tOWHh+aynOa4neiQrvCorKHmuK/wo7iv55GT8KO+guenjOa5j+WqkfCjgYvmv7jjnI3mvp3wo7iw5ru68KGSl/CkgL3klZXpj7DmvYTmvZzjtY7mvbTwqYWw47S75r6f8KSFhOa/k/CkgpHwpIWV8KSAufCjv7Dwo7608KSEv+WHn/CkhZbwpIWX8KSFgPCmh53ngYvngb7ngqfngoHng4zng5Xng5bng5/khITjt6jnhrTnhpbwpIm354Sr54WF5aqI54WK54Wu5bKc8KSNpeeFj+mNovCki4HnhKzwpJGa8KSop/CkqKLnhrrwqK+o54K954iOXCJdLFxuW1wiZmU0MFwiLFwi6ZGC54iV5aSR6ZGD54ik6Y2B8KWYheeIrueJgPCkpbTmor3niZXniZfjuZXwo4GE5qCN5ry954qC54yq54yr8KSgo/CooKvko63wqKCE54yo54yu54+P546q8KCwuvCmqK7nj4nnkYnwpIei8KGbp/CkqKTmmKPjm4XwpKa38KSmjfCkp7vnj7fnkJXmpIPwpKim55C58KCXg+O7l+eRnPCioq3nkaDwqLqy55GH54+k55G26I6555Gs45yw55G06Y+x5qis55KC5KWT8KSqjFwiXSxcbltcImZlYTFcIixcIvCkhZ/wpKm58Kiuj+WthvCosIPwoaKe55OI8KGmiOeUjueTqeeUnvCou5nwoamL5a+X8Ki6rOmOheeVjeeViueVp+eVrvCkvoLjvITwpLST55aO55Gd55ae55a055iC55is55mR55mP55mv55m28KaPteeakOiHr+OfuPCmpJHwpqSO55qh55ql55q355uM8Ka+n+iRovClgp3wpYW98KG4nOecnuecpuedgOaSr/CliKDnnZjwo4qs556v8KilpPCopajwoZuB55+056CJ8KGNtvCkqJLmo4rnoq/no4fno5PpmqXnpK7wpZeg56OX56S056Kx8KeYjOi+uOiihPCorKvwpoKD8KKYnOemhuikgOakguemgPCloZfnpp3wp6y556S856ap5riq8KeEpuO6qOenhvCphI3np5RcIl1cbl1cbiIsIm1vZHVsZS5leHBvcnRzPVtcbltcIjBcIixcIlxcdTAwMDBcIiwxMjcsXCLigqxcIl0sXG5bXCI4MTQwXCIsXCLkuILkuITkuIXkuIbkuI/kuJLkuJfkuJ/kuKDkuKHkuKPkuKbkuKnkuK7kuK/kuLHkuLPkuLXkuLfkuLzkuYDkuYHkuYLkuYTkuYbkuYrkuZHkuZXkuZfkuZrkuZvkuaLkuaPkuaTkuaXkuafkuajkuapcIiw1LFwi5Lmy5Lm0XCIsOSxcIuS5v1wiLDYsXCLkuofkuopcIl0sXG5bXCI4MTgwXCIsXCLkupDkupbkupfkupnkupzkup3kup7kuqPkuqrkuq/kurDkurHkurTkurbkurfkurjkurnkurzkur3kur7ku4jku4zku4/ku5Dku5Lku5rku5vku5zku6Dku6Lku6bku6fku6nku63ku67ku6/ku7Hku7Tku7jku7nku7rku7zku77kvIDkvIJcIiw2LFwi5LyL5LyM5LySXCIsNCxcIuS8nOS8neS8oeS8o+S8qOS8qeS8rOS8reS8ruS8seS8s+S8teS8t+S8ueS8u+S8vlwiLDQsXCLkvYTkvYXkvYdcIiw1LFwi5L2S5L2U5L2W5L2h5L2i5L2m5L2o5L2q5L2r5L2t5L2u5L2x5L2y5L215L235L245L255L265L295L6A5L6B5L6C5L6F5L6G5L6H5L6K5L6M5L6O5L6Q5L6S5L6T5L6V5L6W5L6Y5L6Z5L6a5L6c5L6e5L6f5L6h5L6iXCJdLFxuW1wiODI0MFwiLFwi5L6k5L6r5L6t5L6wXCIsNCxcIuS+tlwiLDgsXCLkv4Dkv4Hkv4Lkv4bkv4fkv4jkv4nkv4vkv4zkv43kv5JcIiw0LFwi5L+Z5L+b5L+g5L+i5L+k5L+l5L+n5L+r5L+s5L+w5L+y5L+05L+15L+25L+35L+55L+75L+85L+95L+/XCIsMTFdLFxuW1wiODI4MFwiLFwi5YCL5YCO5YCQ5YCR5YCT5YCV5YCW5YCX5YCb5YCd5YCe5YCg5YCi5YCj5YCk5YCn5YCr5YCvXCIsMTAsXCLlgLvlgL3lgL/lgYDlgYHlgYLlgYTlgYXlgYblgYnlgYrlgYvlgY3lgZBcIiw0LFwi5YGW5YGX5YGY5YGZ5YGb5YGdXCIsNyxcIuWBplwiLDUsXCLlga1cIiw4LFwi5YG45YG55YG65YG85YG95YKB5YKC5YKD5YKE5YKG5YKH5YKJ5YKK5YKL5YKM5YKOXCIsMjAsXCLlgqTlgqblgqrlgqvlgq1cIiw0LFwi5YKzXCIsNixcIuWCvFwiXSxcbltcIjgzNDBcIixcIuWCvVwiLDE3LFwi5YOQXCIsNSxcIuWDl+WDmOWDmeWDm1wiLDEwLFwi5YOo5YOp5YOq5YOr5YOv5YOw5YOx5YOy5YO05YO2XCIsNCxcIuWDvFwiLDksXCLlhIhcIl0sXG5bXCI4MzgwXCIsXCLlhInlhIrlhIxcIiw1LFwi5YSTXCIsMTMsXCLlhKJcIiwyOCxcIuWFguWFh+WFiuWFjOWFjuWFj+WFkOWFkuWFk+WFl+WFmOWFmeWFm+WFnVwiLDQsXCLlhaPlhaTlhablhaflhanlharlha/lhbLlhbrlhb7lhb/lhoPlhoTlhoblhoflhorlhovlho7lho/lhpDlhpHlhpPlhpTlhpjlhprlhp3lhp7lhp/lhqHlhqPlhqZcIiw0LFwi5Yat5Yau5Ya05Ya45Ya55Ya65Ya+5Ya/5YeB5YeC5YeD5YeF5YeI5YeK5YeN5YeO5YeQ5YeSXCIsNV0sXG5bXCI4NDQwXCIsXCLlh5jlh5nlh5rlh5zlh57lh5/lh6Llh6Plh6VcIiw1LFwi5Yes5Yeu5Yex5Yey5Ye05Ye35Ye+5YiE5YiF5YiJ5YiL5YiM5YiP5YiQ5YiT5YiU5YiV5Yic5Yie5Yif5Yih5Yii5Yij5Yil5Yim5Yin5Yiq5Yis5Yiv5Yix5Yiy5Yi05Yi15Yi85Yi+5YmEXCIsNSxcIuWJi+WJjuWJj+WJkuWJk+WJleWJl+WJmFwiXSxcbltcIjg0ODBcIixcIuWJmeWJmuWJm+WJneWJn+WJoOWJouWJo+WJpOWJpuWJqOWJq+WJrOWJreWJruWJsOWJseWJs1wiLDksXCLlib7lioDlioNcIiw0LFwi5YqJXCIsNixcIuWKkeWKkuWKlFwiLDYsXCLlipzliqTliqXliqbliqfliq7liq/lirDlirRcIiw5LFwi5YuA5YuB5YuC5YuE5YuF5YuG5YuI5YuK5YuM5YuN5YuO5YuP5YuR5YuT5YuU5YuV5YuX5YuZXCIsNSxcIuWLoOWLoeWLouWLo+WLpVwiLDEwLFwi5YuxXCIsNyxcIuWLu+WLvOWLveWMgeWMguWMg+WMhOWMh+WMieWMiuWMi+WMjOWMjlwiXSxcbltcIjg1NDBcIixcIuWMkeWMkuWMk+WMlOWMmOWMm+WMnOWMnuWMn+WMouWMpOWMpeWMp+WMqOWMqeWMq+WMrOWMreWMr1wiLDksXCLljLzljL3ljYDljYLljYTljYbljYvljYzljY3ljZDljZTljZjljZnljZvljZ3ljaXljajljarljazlja3ljbLljbbljbnljbvljbzljb3ljb7ljoDljoHljoPljofljojljorljo7ljo9cIl0sXG5bXCI4NTgwXCIsXCLljpBcIiw0LFwi5Y6W5Y6X5Y6Z5Y6b5Y6c5Y6e5Y6g5Y6h5Y6k5Y6n5Y6q5Y6r5Y6s5Y6t5Y6vXCIsNixcIuWOt+WOuOWOueWOuuWOvOWOveWOvuWPgOWPg1wiLDQsXCLlj47lj4/lj5Dlj5Llj5Plj5Xlj5rlj5zlj53lj57lj6Hlj6Llj6flj7Tlj7rlj77lj7/lkIDlkILlkIXlkIflkIvlkJTlkJjlkJnlkJrlkJzlkKLlkKTlkKXlkKrlkLDlkLPlkLblkLflkLrlkL3lkL/lkYHlkYLlkYTlkYXlkYflkYnlkYzlkY3lkY7lkY/lkZHlkZrlkZ1cIiw0LFwi5ZGj5ZGl5ZGn5ZGpXCIsNyxcIuWRtOWRueWRuuWRvuWRv+WSgeWSg+WSheWSh+WSiOWSieWSiuWSjeWSkeWSk+WSl+WSmOWSnOWSnuWSn+WSoOWSoVwiXSxcbltcIjg2NDBcIixcIuWSouWSpeWSruWSsOWSsuWSteWStuWSt+WSueWSuuWSvOWSvuWTg+WTheWTiuWTi+WTluWTmOWTm+WToFwiLDQsXCLlk6vlk6zlk6/lk7Dlk7Hlk7RcIiw1LFwi5ZO75ZO+5ZSA5ZSC5ZSD5ZSE5ZSF5ZSI5ZSKXCIsNCxcIuWUkuWUk+WUlVwiLDUsXCLllJzllJ3llJ7llJ/llKHllKXllKZcIl0sXG5bXCI4NjgwXCIsXCLllKjllKnllKvllK3llLLllLTllLXllLbllLjllLnllLrllLvllL3llYDllYLllYXllYfllYjllYtcIiw0LFwi5ZWR5ZWS5ZWT5ZWU5ZWXXCIsNCxcIuWVneWVnuWVn+WVoOWVouWVo+WVqOWVqeWVq+WVr1wiLDUsXCLllbnllbrllb3llb/lloXllobllozllo3llo7llpDllpLllpPllpXllpbllpfllprllpvllp7llqBcIiw2LFwi5ZaoXCIsOCxcIuWWsuWWtOWWtuWWuOWWuuWWvOWWv1wiLDQsXCLll4bll4fll4jll4rll4vll47ll4/ll5Dll5Xll5dcIiw0LFwi5Zee5Zeg5Zei5Zen5Zep5Zet5Zeu5Zew5Zex5Ze05Ze25Ze4XCIsNCxcIuWXv+WYguWYg+WYhOWYhVwiXSxcbltcIjg3NDBcIixcIuWYhuWYh+WYiuWYi+WYjeWYkFwiLDcsXCLlmJnlmJrlmJzlmJ3lmKDlmKHlmKLlmKXlmKblmKjlmKnlmKrlmKvlmK7lmK/lmLDlmLPlmLXlmLflmLjlmLrlmLzlmL3lmL7lmYBcIiwxMSxcIuWZj1wiLDQsXCLlmZXlmZblmZrlmZvlmZ1cIiw0XSxcbltcIjg3ODBcIixcIuWZo+WZpeWZpuWZp+WZreWZruWZr+WZsOWZsuWZs+WZtOWZteWZt+WZuOWZueWZuuWZvVwiLDcsXCLlmodcIiw2LFwi5ZqQ5ZqR5ZqS5ZqUXCIsMTQsXCLlmqRcIiwxMCxcIuWasFwiLDYsXCLlmrjlmrnlmrrlmrvlmr1cIiwxMixcIuWbi1wiLDgsXCLlm5Xlm5blm5jlm5nlm5zlm6Plm6VcIiw1LFwi5Zus5Zuu5Zuv5Zuy5Zuz5Zu25Zu35Zu45Zu75Zu85ZyA5ZyB5ZyC5ZyF5ZyH5ZyLXCIsNl0sXG5bXCI4ODQwXCIsXCLlnJJcIiw5LFwi5Zyd5Zye5Zyg5Zyh5Zyi5Zyk5Zyl5Zym5Zyn5Zyr5Zyx5Zyy5Zy0XCIsNCxcIuWcvOWcveWcv+WdgeWdg+WdhOWdheWdhuWdiOWdieWdi+WdklwiLDQsXCLlnZjlnZnlnaLlnaPlnaXlnaflnazlna7lnbDlnbHlnbLlnbTlnbXlnbjlnbnlnbrlnb3lnb7lnb/lnoBcIl0sXG5bXCI4ODgwXCIsXCLlnoHlnoflnojlnonlnorlno1cIiw0LFwi5Z6UXCIsNixcIuWenOWeneWenuWen+WepeWeqOWequWerOWer+WesOWeseWes+WeteWetuWet+WeuVwiLDgsXCLln4RcIiw2LFwi5Z+M5Z+N5Z+Q5Z+R5Z+T5Z+W5Z+X5Z+b5Z+c5Z+e5Z+h5Z+i5Z+j5Z+lXCIsNyxcIuWfruWfsOWfseWfsuWfs+WfteWftuWft+Wfu+WfvOWfvuWfv+WggeWgg+WghOWgheWgiOWgieWgiuWgjOWgjuWgj+WgkOWgkuWgk+WglOWgluWgl+WgmOWgmuWgm+WgnOWgneWgn+WgouWgo+WgpVwiLDQsXCLloKtcIiw0LFwi5aCx5aCy5aCz5aC05aC2XCIsN10sXG5bXCI4OTQwXCIsXCLloL5cIiw1LFwi5aGFXCIsNixcIuWhjuWhj+WhkOWhkuWhk+WhleWhluWhl+WhmVwiLDQsXCLloZ9cIiw1LFwi5aGmXCIsNCxcIuWhrVwiLDE2LFwi5aG/5aKC5aKE5aKG5aKH5aKI5aKK5aKL5aKMXCJdLFxuW1wiODk4MFwiLFwi5aKNXCIsNCxcIuWilFwiLDQsXCLlopvlopzlop3loqBcIiw3LFwi5aKqXCIsMTcsXCLlor3lor7lor/lo4Dlo4Llo4Plo4Tlo4ZcIiwxMCxcIuWjkuWjk+WjlOWjllwiLDEzLFwi5aOlXCIsNSxcIuWjreWjr+WjseWjsuWjtOWjteWjt+WjuOWjulwiLDcsXCLlpIPlpIXlpIblpIhcIiw0LFwi5aSO5aSQ5aSR5aSS5aST5aSX5aSY5aSb5aSd5aSe5aSg5aSh5aSi5aSj5aSm5aSo5aSs5aSw5aSy5aSz5aS15aS25aS7XCJdLFxuW1wiOGE0MFwiLFwi5aS95aS+5aS/5aWA5aWD5aWF5aWG5aWK5aWM5aWN5aWQ5aWS5aWT5aWZ5aWbXCIsNCxcIuWloeWlo+WlpOWlplwiLDEyLFwi5aW15aW35aW65aW75aW85aW+5aW/5aaA5aaF5aaJ5aaL5aaM5aaO5aaP5aaQ5aaR5aaU5aaV5aaY5aaa5aab5aac5aad5aaf5aag5aah5aai5aamXCJdLFxuW1wiOGE4MFwiLFwi5aan5aas5aat5aaw5aax5aazXCIsNSxcIuWmuuWmvOWmveWmv1wiLDYsXCLlp4flp4jlp4nlp4zlp43lp47lp4/lp5Xlp5blp5nlp5vlp55cIiw0LFwi5aek5aem5aen5aep5aeq5aer5aetXCIsMTEsXCLlp7rlp7zlp73lp77lqIDlqILlqIrlqIvlqI3lqI7lqI/lqJDlqJLlqJTlqJXlqJblqJflqJnlqJrlqJvlqJ3lqJ7lqKHlqKLlqKTlqKblqKflqKjlqKpcIiw2LFwi5aiz5ai15ai3XCIsNCxcIuWoveWovuWov+WpgVwiLDQsXCLlqYflqYjlqYtcIiw5LFwi5amW5amX5amY5amZ5ambXCIsNV0sXG5bXCI4YjQwXCIsXCLlqaHlqaPlqaTlqaXlqablqajlqanlqatcIiw4LFwi5am45am55am75am85am95am+5aqAXCIsMTcsXCLlqpNcIiw2LFwi5aqcXCIsMTMsXCLlqqvlqqxcIl0sXG5bXCI4YjgwXCIsXCLlqq1cIiw0LFwi5aq05aq25aq35aq5XCIsNCxcIuWqv+WrgOWrg1wiLDUsXCLlq4rlq4vlq41cIiw0LFwi5auT5auV5auX5auZ5aua5aub5aud5aue5auf5aui5auk5aul5aun5auo5auq5ausXCIsNCxcIuWrslwiLDIyLFwi5ayKXCIsMTEsXCLlrJhcIiwyNSxcIuWss+WsteWstuWsuFwiLDcsXCLlrYFcIiw2XSxcbltcIjhjNDBcIixcIuWtiFwiLDcsXCLlrZLlrZblrZ7lraDlraHlraflrajlravlra3lra7lra/lrbLlrbTlrbblrbflrbjlrbnlrbvlrbzlrb7lrb/lroLlroblrorlro3lro7lrpDlrpHlrpLlrpTlrpblrp/lrqflrqjlrqnlrqzlrq3lrq7lrq/lrrHlrrLlrrflrrrlrrvlrrzlr4Dlr4Hlr4Plr4jlr4nlr4rlr4vlr43lr47lr49cIl0sXG5bXCI4YzgwXCIsXCLlr5Hlr5RcIiw4LFwi5a+g5a+i5a+j5a+m5a+n5a+pXCIsNCxcIuWvr+WvsVwiLDYsXCLlr73lr77lsIDlsILlsIPlsIXlsIflsIjlsIvlsIzlsI3lsI7lsJDlsJLlsJPlsJflsJnlsJvlsJ7lsJ/lsKDlsKHlsKPlsKblsKjlsKnlsKrlsKvlsK3lsK7lsK/lsLDlsLLlsLPlsLXlsLblsLflsYPlsYTlsYblsYflsYzlsY3lsZLlsZPlsZTlsZblsZflsZjlsZrlsZvlsZzlsZ3lsZ/lsaLlsaTlsadcIiw2LFwi5bGw5bGyXCIsNixcIuWxu+WxvOWxveWxvuWygOWyg1wiLDQsXCLlsonlsorlsovlso7lso/lspLlspPlspXlsp1cIiw0LFwi5bKkXCIsNF0sXG5bXCI4ZDQwXCIsXCLlsqrlsq7lsq/lsrDlsrLlsrTlsrblsrnlsrrlsrvlsrzlsr7ls4Dls4Lls4Pls4VcIiw1LFwi5bOMXCIsNSxcIuWzk1wiLDUsXCLls5pcIiw2LFwi5bOi5bOj5bOn5bOp5bOr5bOs5bOu5bOv5bOxXCIsOSxcIuWzvFwiLDRdLFxuW1wiOGQ4MFwiLFwi5bSB5bSE5bSF5bSIXCIsNSxcIuW0j1wiLDQsXCLltJXltJfltJjltJnltJrltJzltJ3ltJ9cIiw0LFwi5bSl5bSo5bSq5bSr5bSs5bSvXCIsNCxcIuW0tVwiLDcsXCLltL9cIiw3LFwi5bWI5bWJ5bWNXCIsMTAsXCLltZnltZrltZzltZ5cIiwxMCxcIuW1quW1reW1ruW1sOW1seW1suW1s+W1tVwiLDEyLFwi5baDXCIsMjEsXCLltprltpvltpzltp7ltp/ltqBcIl0sXG5bXCI4ZTQwXCIsXCLltqFcIiwyMSxcIuW2uFwiLDEyLFwi5beGXCIsNixcIuW3jlwiLDEyLFwi5bec5bef5beg5bej5bek5beq5bes5betXCJdLFxuW1wiOGU4MFwiLFwi5bew5be15be25be4XCIsNCxcIuW3v+W4gOW4hOW4h+W4ieW4iuW4i+W4jeW4juW4kuW4k+W4l+W4nlwiLDcsXCLluKhcIiw0LFwi5biv5biw5biyXCIsNCxcIuW4ueW4uuW4vuW4v+W5gOW5geW5g+W5hlwiLDUsXCLluY1cIiw2LFwi5bmWXCIsNCxcIuW5nOW5neW5n+W5oOW5o1wiLDE0LFwi5bm15bm35bm55bm+5bqB5bqC5bqD5bqF5bqI5bqJ5bqM5bqN5bqO5bqS5bqY5bqb5bqd5bqh5bqi5bqj5bqk5bqoXCIsNCxcIuW6rlwiLDQsXCLlurTlurrlurvlurzlur3lur9cIiw2XSxcbltcIjhmNDBcIixcIuW7huW7h+W7iOW7i1wiLDUsXCLlu5Tlu5Xlu5flu5jlu5nlu5rlu5xcIiwxMSxcIuW7qeW7q1wiLDgsXCLlu7Xlu7jlu7nlu7vlu7zlu73lvIXlvIblvIflvInlvIzlvI3lvI7lvJDlvJLlvJTlvJblvJnlvJrlvJzlvJ3lvJ7lvKHlvKLlvKPlvKRcIl0sXG5bXCI4ZjgwXCIsXCLlvKjlvKvlvKzlvK7lvLDlvLJcIiw2LFwi5by75by95by+5by/5b2BXCIsMTQsXCLlvZHlvZTlvZnlvZrlvZvlvZzlvZ7lvZ/lvaDlvaPlvaXlvaflvajlvavlva7lva/lvbLlvbTlvbXlvbblvbjlvbrlvb3lvb7lvb/lvoPlvoblvo3lvo7lvo/lvpHlvpPlvpTlvpblvprlvpvlvp3lvp7lvp/lvqDlvqJcIiw1LFwi5b6p5b6r5b6s5b6vXCIsNSxcIuW+tuW+uOW+ueW+uuW+u+W+vlwiLDQsXCLlv4flv4jlv4rlv4vlv47lv5Plv5Tlv5Xlv5rlv5vlv5zlv57lv5/lv6Llv6Plv6Xlv6blv6jlv6nlv6zlv6/lv7Dlv7Llv7Plv7Tlv7blv7flv7nlv7rlv7zmgIdcIl0sXG5bXCI5MDQwXCIsXCLmgIjmgInmgIvmgIzmgJDmgJHmgJPmgJfmgJjmgJrmgJ7mgJ/mgKLmgKPmgKTmgKzmgK3mgK7mgLBcIiw0LFwi5oC2XCIsNCxcIuaAveaAvuaBgOaBhFwiLDYsXCLmgYzmgY7mgY/mgZHmgZPmgZTmgZbmgZfmgZjmgZvmgZzmgZ7mgZ/mgaDmgaHmgaXmgabmga7mgbHmgbLmgbTmgbXmgbfmgb7mgoBcIl0sXG5bXCI5MDgwXCIsXCLmgoHmgoLmgoXmgobmgofmgojmgormgovmgo7mgo/mgpDmgpHmgpPmgpXmgpfmgpjmgpnmgpzmgp7mgqHmgqLmgqTmgqXmgqfmgqnmgqrmgq7mgrDmgrPmgrXmgrbmgrfmgrnmgrrmgr1cIiw3LFwi5oOH5oOI5oOJ5oOMXCIsNCxcIuaDkuaDk+aDlOaDluaDl+aDmeaDm+aDnuaDoVwiLDQsXCLmg6rmg7Hmg7Lmg7Xmg7fmg7jmg7tcIiw0LFwi5oSC5oSD5oSE5oSF5oSH5oSK5oSL5oSM5oSQXCIsNCxcIuaEluaEl+aEmOaEmeaEm+aEnOaEneaEnuaEoeaEouaEpeaEqOaEqeaEquaErFwiLDE4LFwi5oWAXCIsNl0sXG5bXCI5MTQwXCIsXCLmhYfmhYnmhYvmhY3mhY/mhZDmhZLmhZPmhZTmhZZcIiw2LFwi5oWe5oWf5oWg5oWh5oWj5oWk5oWl5oWm5oWpXCIsNixcIuaFseaFsuaFs+aFtOaFtuaFuFwiLDE4LFwi5oaM5oaN5oaPXCIsNCxcIuaGlVwiXSxcbltcIjkxODBcIixcIuaGllwiLDYsXCLmhp5cIiw4LFwi5oaq5oar5oatXCIsOSxcIuaGuFwiLDUsXCLmhr/mh4Dmh4Hmh4NcIiw0LFwi5oeJ5oeMXCIsNCxcIuaHk+aHlVwiLDE2LFwi5oenXCIsMTMsXCLmh7ZcIiw4LFwi5oiAXCIsNSxcIuaIh+aIieaIk+aIlOaImeaInOaIneaInuaIoOaIo+aIpuaIp+aIqOaIqeaIq+aIreaIr+aIsOaIseaIsuaIteaItuaIuFwiLDQsXCLmiYLmiYTmiYXmiYbmiYpcIl0sXG5bXCI5MjQwXCIsXCLmiY/miZDmiZXmiZbmiZfmiZnmiZrmiZxcIiw2LFwi5omk5oml5omo5omx5omy5om05om15om35om45om65om75om95oqB5oqC5oqD5oqF5oqG5oqH5oqI5oqLXCIsNSxcIuaKlOaKmeaKnOaKneaKnuaKo+aKpuaKp+aKqeaKquaKreaKruaKr+aKsOaKsuaKs+aKtOaKtuaKt+aKuOaKuuaKvuaLgOaLgVwiXSxcbltcIjkyODBcIixcIuaLg+aLi+aLj+aLkeaLleaLneaLnuaLoOaLoeaLpOaLquaLq+aLsOaLsuaLteaLuOaLueaLuuaLu+aMgOaMg+aMhOaMheaMhuaMiuaMi+aMjOaMjeaMj+aMkOaMkuaMk+aMlOaMleaMl+aMmOaMmeaMnOaMpuaMp+aMqeaMrOaMreaMruaMsOaMseaMs1wiLDUsXCLmjLvmjLzmjL7mjL/mjYDmjYHmjYTmjYfmjYjmjYrmjZHmjZLmjZPmjZTmjZZcIiw3LFwi5o2g5o2k5o2l5o2m5o2o5o2q5o2r5o2s5o2v5o2w5o2y5o2z5o205o215o245o255o285o295o2+5o2/5o6B5o6D5o6E5o6F5o6G5o6L5o6N5o6R5o6T5o6U5o6V5o6X5o6ZXCIsNixcIuaOoeaOpOaOpuaOq+aOr+aOseaOsuaOteaOtuaOueaOu+aOveaOv+aPgFwiXSxcbltcIjkzNDBcIixcIuaPgeaPguaPg+aPheaPh+aPiOaPiuaPi+aPjOaPkeaPk+aPlOaPleaPl1wiLDYsXCLmj5/mj6Lmj6RcIiw0LFwi5o+r5o+s5o+u5o+v5o+w5o+x5o+z5o+15o+35o+55o+65o+75o+85o++5pCD5pCE5pCGXCIsNCxcIuaQjeaQjuaQkeaQkuaQlVwiLDUsXCLmkJ3mkJ/mkKLmkKPmkKRcIl0sXG5bXCI5MzgwXCIsXCLmkKXmkKfmkKjmkKnmkKvmkK5cIiw1LFwi5pC1XCIsNCxcIuaQu+aQvOaQvuaRgOaRguaRg+aRieaRi1wiLDYsXCLmkZPmkZXmkZbmkZfmkZlcIiw0LFwi5pGfXCIsNyxcIuaRqOaRquaRq+aRrOaRrlwiLDksXCLmkbtcIiw2LFwi5pKD5pKG5pKIXCIsOCxcIuaSk+aSlOaSl+aSmOaSmuaSm+aSnOaSneaSn1wiLDQsXCLmkqXmkqbmkqfmkqjmkqrmkqvmkq/mkrHmkrLmkrPmkrTmkrbmkrnmkrvmkr3mkr7mkr/mk4Hmk4Pmk4Tmk4ZcIiw2LFwi5pOP5pOR5pOT5pOU5pOV5pOW5pOZ5pOaXCJdLFxuW1wiOTQ0MFwiLFwi5pOb5pOc5pOd5pOf5pOg5pOh5pOj5pOl5pOnXCIsMjQsXCLmlIFcIiw3LFwi5pSKXCIsNyxcIuaUk1wiLDQsXCLmlJlcIiw4XSxcbltcIjk0ODBcIixcIuaUouaUo+aUpOaUplwiLDQsXCLmlKzmlK3mlLDmlLHmlLLmlLPmlLfmlLrmlLzmlL3mlYBcIiw0LFwi5pWG5pWH5pWK5pWL5pWN5pWO5pWQ5pWS5pWT5pWU5pWX5pWY5pWa5pWc5pWf5pWg5pWh5pWk5pWl5pWn5pWo5pWp5pWq5pWt5pWu5pWv5pWx5pWz5pW15pW25pW4XCIsMTQsXCLmlojmlonmlormlo3mlo7mlo/mlpLmlpTmlpXmlpbmlpjmlprmlp3mlp7mlqDmlqLmlqPmlqbmlqjmlqrmlqzmlq7mlrFcIiw3LFwi5pa65pa75pa+5pa/5peA5peC5peH5peI5peJ5peK5peN5peQ5peR5peT5peU5peV5peYXCIsNyxcIuaXoeaXo+aXpOaXquaXq1wiXSxcbltcIjk1NDBcIixcIuaXsuaXs+aXtOaXteaXuOaXueaXu1wiLDQsXCLmmIHmmITmmIXmmIfmmIjmmInmmIvmmI3mmJDmmJHmmJLmmJbmmJfmmJjmmJrmmJvmmJzmmJ7mmKHmmKLmmKPmmKTmmKbmmKnmmKrmmKvmmKzmmK7mmLDmmLLmmLPmmLdcIiw0LFwi5pi95pi/5pmA5pmC5pmEXCIsNixcIuaZjeaZjuaZkOaZkeaZmFwiXSxcbltcIjk1ODBcIixcIuaZmeaZm+aZnOaZneaZnuaZoOaZouaZo+aZpeaZp+aZqVwiLDQsXCLmmbHmmbLmmbPmmbXmmbjmmbnmmbvmmbzmmb3mmb/mmoDmmoHmmoPmmoXmmobmmojmmonmmormmovmmo3mmo7mmo/mmpDmmpLmmpPmmpTmmpXmmphcIiw0LFwi5pqeXCIsOCxcIuaaqVwiLDQsXCLmmq9cIiw0LFwi5pq15pq25pq35pq45pq65pq75pq85pq95pq/XCIsMjUsXCLmm5rmm55cIiw3LFwi5pun5puo5puqXCIsNSxcIuabseabteabtuabuOabuuabu+abveacgeacguacg1wiXSxcbltcIjk2NDBcIixcIuachOacheachuach+acjOacjuacj+ackeackuack+acluacmOacmeacmuacnOacnuacoFwiLDUsXCLmnKfmnKnmnK7mnLDmnLLmnLPmnLbmnLfmnLjmnLnmnLvmnLzmnL7mnL/mnYHmnYTmnYXmnYfmnYrmnYvmnY3mnZLmnZTmnZXmnZdcIiw0LFwi5p2d5p2i5p2j5p2k5p2m5p2n5p2r5p2s5p2u5p2x5p205p22XCJdLFxuW1wiOTY4MFwiLFwi5p245p255p265p275p295p6A5p6C5p6D5p6F5p6G5p6I5p6K5p6M5p6N5p6O5p6P5p6R5p6S5p6T5p6U5p6W5p6Z5p6b5p6f5p6g5p6h5p6k5p6m5p6p5p6s5p6u5p6x5p6y5p605p65XCIsNyxcIuafguafhVwiLDksXCLmn5Xmn5bmn5fmn5vmn5/mn6Hmn6Pmn6Tmn6bmn6fmn6jmn6rmn6vmn63mn67mn7Lmn7VcIiw3LFwi5p++5qCB5qCC5qCD5qCE5qCG5qCN5qCQ5qCS5qCU5qCV5qCYXCIsNCxcIuagnuagn+agoOagolwiLDYsXCLmoKtcIiw2LFwi5qC05qC15qC25qC65qC75qC/5qGH5qGL5qGN5qGP5qGS5qGWXCIsNV0sXG5bXCI5NzQwXCIsXCLmoZzmoZ3moZ7moZ/moarmoaxcIiw3LFwi5qG15qG4XCIsOCxcIuaiguaihOaih1wiLDcsXCLmopDmopHmopLmopTmopXmopbmophcIiw5LFwi5qKj5qKk5qKl5qKp5qKq5qKr5qKs5qKu5qKx5qKy5qK05qK25qK35qK4XCJdLFxuW1wiOTc4MFwiLFwi5qK5XCIsNixcIuajgeajg1wiLDUsXCLmo4rmo4zmo47mo4/mo5Dmo5Hmo5Pmo5Tmo5bmo5fmo5nmo5tcIiw0LFwi5qOh5qOi5qOkXCIsOSxcIuajr+ajsuajs+ajtOajtuajt+ajuOaju+ajveajvuajv+akgOakguakg+akhOakhlwiLDQsXCLmpIzmpI/mpJHmpJNcIiwxMSxcIuakoeakouako+akpVwiLDcsXCLmpK7mpK/mpLHmpLLmpLPmpLXmpLbmpLfmpLjmpLrmpLvmpLzmpL7mpYDmpYHmpYNcIiwxNixcIualleallualmOalmealm+alnOaln1wiXSxcbltcIjk4NDBcIixcIualoealoualpOalpealp+alqOalqealqualrOalrealr+alsOalslwiLDQsXCLmpbrmpbvmpb3mpb7mpb/mpoHmpoPmpoXmpormpovmpozmpo5cIiw1LFwi5qaW5qaX5qaZ5qaa5qadXCIsOSxcIuamqeamquamrOamruamr+amsOamsuams+amteamtuamuOamueamuuamvOamvVwiXSxcbltcIjk4ODBcIixcIuamvuamv+angOanglwiLDcsXCLmp4vmp43mp4/mp5Hmp5Lmp5Pmp5VcIiw1LFwi5qec5qed5qee5qehXCIsMTEsXCLmp67mp6/mp7Dmp7Hmp7NcIiw5LFwi5qe+5qiAXCIsOSxcIuaoi1wiLDExLFwi5qiZXCIsNSxcIuaooOaoolwiLDUsXCLmqKnmqKvmqKzmqK3mqK7mqLDmqLLmqLPmqLTmqLZcIiw2LFwi5qi/XCIsNCxcIuapheaphuapiFwiLDcsXCLmqZFcIiw2LFwi5qmaXCJdLFxuW1wiOTk0MFwiLFwi5qmcXCIsNCxcIuapouapo+appOapplwiLDEwLFwi5qmyXCIsNixcIuapuuapu+apveapvuapv+aqgeaqguaqg+aqhVwiLDgsXCLmqo/mqpJcIiw0LFwi5qqYXCIsNyxcIuaqoVwiLDVdLFxuW1wiOTk4MFwiLFwi5qqn5qqo5qqq5qqtXCIsMTE0LFwi5qyl5qym5qyoXCIsNl0sXG5bXCI5YTQwXCIsXCLmrK/mrLDmrLHmrLPmrLTmrLXmrLbmrLjmrLvmrLzmrL3mrL/mrYDmrYHmrYLmrYTmrYXmrYjmrYrmrYvmrY1cIiwxMSxcIuatmlwiLDcsXCLmrajmranmratcIiwxMyxcIuatuuatveatvuatv+augOauheauiFwiXSxcbltcIjlhODBcIixcIuaujOaujuauj+aukOaukeaulOauleaul+aumOaumeaunFwiLDQsXCLmrqJcIiw3LFwi5q6rXCIsNyxcIuautuauuFwiLDYsXCLmr4Dmr4Pmr4Tmr4ZcIiw0LFwi5q+M5q+O5q+Q5q+R5q+Y5q+a5q+cXCIsNCxcIuavolwiLDcsXCLmr6zmr63mr67mr7Dmr7Hmr7Lmr7Tmr7bmr7fmr7jmr7rmr7vmr7zmr75cIiw2LFwi5rCIXCIsNCxcIuawjuawkuawl+awnOawneawnuawoOawo+awpeawq+awrOawreawseaws+awtuawt+awueawuuawu+awvOawvuawv+axg+axhOaxheaxiOaxi1wiLDQsXCLmsZHmsZLmsZPmsZbmsZhcIl0sXG5bXCI5YjQwXCIsXCLmsZnmsZrmsaLmsaPmsaXmsabmsafmsatcIiw0LFwi5rGx5rGz5rG15rG35rG45rG65rG75rG85rG/5rKA5rKE5rKH5rKK5rKL5rKN5rKO5rKR5rKS5rKV5rKW5rKX5rKY5rKa5rKc5rKd5rKe5rKg5rKi5rKo5rKs5rKv5rKw5rK05rK15rK25rK35rK65rOA5rOB5rOC5rOD5rOG5rOH5rOI5rOL5rON5rOO5rOP5rOR5rOS5rOYXCJdLFxuW1wiOWI4MFwiLFwi5rOZ5rOa5rOc5rOd5rOf5rOk5rOm5rOn5rOp5rOs5rOt5rOy5rO05rO55rO/5rSA5rSC5rSD5rSF5rSG5rSI5rSJ5rSK5rSN5rSP5rSQ5rSR5rST5rSU5rSV5rSW5rSY5rSc5rSd5rSfXCIsNSxcIua0pua0qOa0qea0rOa0rea0r+a0sOa0tOa0tua0t+a0uOa0uua0v+a1gOa1gua1hOa1iea1jOa1kOa1lea1lua1l+a1mOa1m+a1nea1n+a1oea1oua1pOa1pea1p+a1qOa1q+a1rOa1rea1sOa1sea1sua1s+a1tea1tua1uea1uua1u+a1vVwiLDQsXCLmtoPmtoTmtobmtofmtormtovmto3mto/mtpDmtpLmtpZcIiw0LFwi5rac5rai5ral5ras5rat5raw5rax5raz5ra05ra25ra35ra5XCIsNSxcIua3gea3gua3g+a3iOa3iea3ilwiXSxcbltcIjljNDBcIixcIua3jea3jua3j+a3kOa3kua3k+a3lOa3lea3l+a3mua3m+a3nOa3n+a3oua3o+a3pea3p+a3qOa3qea3qua3rea3r+a3sOa3sua3tOa3tea3tua3uOa3uua3vVwiLDcsXCLmuIbmuIfmuIjmuInmuIvmuI/muJLmuJPmuJXmuJjmuJnmuJvmuJzmuJ7muJ/muKLmuKbmuKfmuKjmuKrmuKzmuK7muLDmuLHmuLPmuLVcIl0sXG5bXCI5YzgwXCIsXCLmuLbmuLfmuLnmuLtcIiw3LFwi5rmFXCIsNyxcIua5j+a5kOa5kea5kua5lea5l+a5mea5mua5nOa5nea5nua5oFwiLDEwLFwi5rms5rmt5rmvXCIsMTQsXCLmuoDmuoHmuoLmuoTmuofmuojmuopcIiw0LFwi5rqRXCIsNixcIua6mea6mua6m+a6nea6nua6oOa6oea6o+a6pOa6pua6qOa6qea6q+a6rOa6rea6rua6sOa6s+a6tea6uOa6uea6vOa6vua6v+a7gOa7g+a7hOa7hea7hua7iOa7iea7iua7jOa7jea7jua7kOa7kua7lua7mOa7mea7m+a7nOa7nea7o+a7p+a7qlwiLDVdLFxuW1wiOWQ0MFwiLFwi5ruw5rux5ruy5ruz5ru15ru25ru35ru45ru6XCIsNyxcIua8g+a8hOa8hea8h+a8iOa8ilwiLDQsXCLmvJDmvJHmvJLmvJZcIiw5LFwi5ryh5ryi5ryj5ryl5rym5ryn5ryo5rys5ryu5ryw5ryy5ry05ry15ry3XCIsNixcIua8v+a9gOa9gea9glwiXSxcbltcIjlkODBcIixcIua9g+a9hOa9hea9iOa9iea9iua9jOa9jlwiLDksXCLmvZnmvZrmvZvmvZ3mvZ/mvaDmvaHmvaPmvaTmvaXmvadcIiw1LFwi5r2v5r2w5r2x5r2z5r215r225r235r255r275r29XCIsNixcIua+hea+hua+h+a+iua+i+a+j1wiLDEyLFwi5r6d5r6e5r6f5r6g5r6iXCIsNCxcIua+qFwiLDEwLFwi5r605r615r635r645r66XCIsNSxcIua/gea/g1wiLDUsXCLmv4pcIiw2LFwi5r+TXCIsMTAsXCLmv5/mv6Lmv6Pmv6Tmv6VcIl0sXG5bXCI5ZTQwXCIsXCLmv6ZcIiw3LFwi5r+wXCIsMzIsXCLngJJcIiw3LFwi54CcXCIsNixcIueApFwiLDZdLFxuW1wiOWU4MFwiLFwi54CrXCIsOSxcIueAtueAt+eAuOeAulwiLDE3LFwi54GN54GO54GQXCIsMTMsXCLngZ9cIiwxMSxcIueBrueBseeBsueBs+eBtOeBt+eBueeBuueBu+eBveeCgeeCgueCg+eChOeChueCh+eCiOeCi+eCjOeCjeeCj+eCkOeCkeeCk+eCl+eCmOeCmueCm+eCnlwiLDEyLFwi54Kw54Ky54K054K154K254K654K+54K/54OE54OF54OG54OH54OJ54OLXCIsMTIsXCLng5pcIl0sXG5bXCI5ZjQwXCIsXCLng5zng53ng57ng6Dng6Hng6Lng6Png6Xng6rng67ng7BcIiw2LFwi54O454O654O754O854O+XCIsMTAsXCLnhItcIiw0LFwi54SR54SS54SU54SX54SbXCIsMTAsXCLnhKdcIiw3LFwi54Sy54Sz54S0XCJdLFxuW1wiOWY4MFwiLFwi54S154S3XCIsMTMsXCLnhYbnhYfnhYjnhYnnhYvnhY3nhY9cIiwxMixcIueFneeFn1wiLDQsXCLnhaXnhalcIiw0LFwi54Wv54Ww54Wx54W054W154W254W354W554W754W854W+XCIsNSxcIueGhVwiLDQsXCLnhovnhoznho3nho7nhpDnhpHnhpLnhpPnhpXnhpbnhpfnhppcIiw0LFwi54ahXCIsNixcIueGqeeGqueGq+eGrVwiLDUsXCLnhrTnhrbnhrfnhrjnhrpcIiw4LFwi54eEXCIsOSxcIueHj1wiLDRdLFxuW1wiYTA0MFwiLFwi54eWXCIsOSxcIueHoeeHoueHo+eHpOeHpueHqFwiLDUsXCLnh69cIiw5LFwi54e6XCIsMTEsXCLniIdcIiwxOV0sXG5bXCJhMDgwXCIsXCLniJvniJzniJ5cIiw5LFwi54ip54ir54it54iu54iv54iy54iz54i054i654i854i+54mAXCIsNixcIueJieeJiueJi+eJjueJj+eJkOeJkeeJk+eJlOeJleeJl+eJmOeJmueJnOeJnueJoOeJo+eJpOeJpeeJqOeJqueJq+eJrOeJreeJsOeJseeJs+eJtOeJtueJt+eJuOeJu+eJvOeJveeKgueKg+eKhVwiLDQsXCLnioznio7nipDnipHnipNcIiwxMSxcIueKoFwiLDExLFwi54qu54qx54qy54qz54q154q6XCIsNixcIueLheeLhueLh+eLieeLiueLi+eLjOeLj+eLkeeLk+eLlOeLleeLlueLmOeLmueLm1wiXSxcbltcImExYTFcIixcIuOAgOOAgeOAgsK3y4nLh8Ko44CD44CF4oCU772e4oCW4oCm4oCY4oCZ4oCc4oCd44CU44CV44CIXCIsNyxcIuOAluOAl+OAkOOAkcKxw5fDt+KItuKIp+KIqOKIkeKIj+KIquKIqeKIiOKIt+KImuKKpeKIpeKIoOKMkuKKmeKIq+KIruKJoeKJjOKJiOKIveKIneKJoOKJruKJr+KJpOKJpeKInuKIteKItOKZguKZgMKw4oCy4oCz4oSD77yEwqTvv6Dvv6HigLDCp+KEluKYhuKYheKXi+KXj+KXjuKXh+KXhuKWoeKWoOKWs+KWsuKAu+KGkuKGkOKGkeKGk+OAk1wiXSxcbltcImEyYTFcIixcIuKFsFwiLDldLFxuW1wiYTJiMVwiLFwi4pKIXCIsMTksXCLikbRcIiwxOSxcIuKRoFwiLDldLFxuW1wiYTJlNVwiLFwi44igXCIsOV0sXG5bXCJhMmYxXCIsXCLihaBcIiwxMV0sXG5bXCJhM2ExXCIsXCLvvIHvvILvvIPvv6XvvIVcIiw4OCxcIu+/o1wiXSxcbltcImE0YTFcIixcIuOBgVwiLDgyXSxcbltcImE1YTFcIixcIuOCoVwiLDg1XSxcbltcImE2YTFcIixcIs6RXCIsMTYsXCLOo1wiLDZdLFxuW1wiYTZjMVwiLFwizrFcIiwxNixcIs+DXCIsNl0sXG5bXCJhNmUwXCIsXCLvuLXvuLbvuLnvuLrvuL/vuYDvuL3vuL7vuYHvuYLvuYPvuYRcIl0sXG5bXCJhNmVlXCIsXCLvuLvvuLzvuLfvuLjvuLFcIl0sXG5bXCJhNmY0XCIsXCLvuLPvuLRcIl0sXG5bXCJhN2ExXCIsXCLQkFwiLDUsXCLQgdCWXCIsMjVdLFxuW1wiYTdkMVwiLFwi0LBcIiw1LFwi0ZHQtlwiLDI1XSxcbltcImE4NDBcIixcIsuKy4vLmeKAk+KAleKApeKAteKEheKEieKGluKGl+KGmOKGmeKIleKIn+KIo+KJkuKJpuKJp+KKv+KVkFwiLDM1LFwi4paBXCIsNl0sXG5bXCJhODgwXCIsXCLilohcIiw3LFwi4paT4paU4paV4pa84pa94pei4pej4pek4pel4piJ4oqV44CS44Cd44CeXCJdLFxuW1wiYThhMVwiLFwixIHDoceOw6DEk8OpxJvDqMSrw63HkMOsxY3Ds8eSw7LFq8O6x5TDuceWx5jHmsecw7zDqsmRXCJdLFxuW1wiYThiZFwiLFwixYTFiFwiXSxcbltcImE4YzBcIixcIsmhXCJdLFxuW1wiYThjNVwiLFwi44SFXCIsMzZdLFxuW1wiYTk0MFwiLFwi44ChXCIsOCxcIuOKo+OOjuOOj+OOnOOOneOOnuOOoeOPhOOPjuOPkeOPkuOPle+4sO+/ou+/pFwiXSxcbltcImE5NTlcIixcIuKEoeOIsVwiXSxcbltcImE5NWNcIixcIuKAkFwiXSxcbltcImE5NjBcIixcIuODvOOCm+OCnOODveODvuOAhuOCneOCnu+5iVwiLDksXCLvuZTvuZXvuZbvuZfvuZlcIiw4XSxcbltcImE5ODBcIixcIu+5olwiLDQsXCLvuajvuanvuarvuatcIl0sXG5bXCJhOTk2XCIsXCLjgIdcIl0sXG5bXCJhOWE0XCIsXCLilIBcIiw3NV0sXG5bXCJhYTQwXCIsXCLni5zni53ni5/ni6JcIiw1LFwi54uq54ur54u154u254u554u954u+54u/54yA54yC54yEXCIsNSxcIueMi+eMjOeMjeeMj+eMkOeMkeeMkueMlOeMmOeMmeeMmueMn+eMoOeMo+eMpOeMpueMp+eMqOeMreeMr+eMsOeMsueMs+eMteeMtueMuueMu+eMvOeMveeNgFwiLDhdLFxuW1wiYWE4MFwiLFwi542J542K542L542M542O542P542R542T542U542V542W542YXCIsNyxcIueNoVwiLDEwLFwi542u542w542xXCJdLFxuW1wiYWI0MFwiLFwi542yXCIsMTEsXCLnjb9cIiw0LFwi546F546G546I546K546M546N546P546Q546S546T546U546V546X546Y546Z546a546c546d546e546g546h546jXCIsNSxcIueOqueOrOeOreeOseeOtOeOteeOtueOuOeOueeOvOeOveeOvueOv+ePgeePg1wiLDRdLFxuW1wiYWI4MFwiLFwi54+L54+M54+O54+SXCIsNixcIuePmuePm+ePnOePneePn+ePoeePouePo+ePpOePpuePqOePquePq+ePrOePruePr+ePsOePseePs1wiLDRdLFxuW1wiYWM0MFwiLFwi54+4XCIsMTAsXCLnkITnkIfnkIjnkIvnkIznkI3nkI7nkJFcIiw4LFwi55CcXCIsNSxcIueQo+eQpOeQp+eQqeeQq+eQreeQr+eQseeQsueQt1wiLDQsXCLnkL3nkL7nkL/nkYDnkYJcIiwxMV0sXG5bXCJhYzgwXCIsXCLnkY5cIiw2LFwi55GW55GY55Gd55GgXCIsMTIsXCLnka7nka/nkbFcIiw0LFwi55G455G555G6XCJdLFxuW1wiYWQ0MFwiLFwi55G755G855G955G/55KC55KE55KF55KG55KI55KJ55KK55KM55KN55KP55KRXCIsMTAsXCLnkp3nkp9cIiw3LFwi55KqXCIsMTUsXCLnkrtcIiwxMl0sXG5bXCJhZDgwXCIsXCLnk4hcIiw5LFwi55OTXCIsOCxcIueTneeTn+eToeeTpeeTp1wiLDYsXCLnk7Dnk7Hnk7JcIl0sXG5bXCJhZTQwXCIsXCLnk7Pnk7Xnk7hcIiw2LFwi55SA55SB55SC55SD55SFXCIsNyxcIueUjueUkOeUkueUlOeUleeUlueUl+eUm+eUneeUnueUoFwiLDQsXCLnlKbnlKfnlKrnlK7nlLTnlLbnlLnnlLznlL3nlL/nlYHnlYLnlYPnlYTnlYbnlYfnlYnnlYrnlY3nlZDnlZHnlZLnlZPnlZXnlZbnlZfnlZhcIl0sXG5bXCJhZTgwXCIsXCLnlZ1cIiw3LFwi55Wn55Wo55Wp55WrXCIsNixcIueVs+eVteeVtueVt+eVulwiLDQsXCLnloDnloHnloLnloTnloXnlodcIl0sXG5bXCJhZjQwXCIsXCLnlojnlonnlornloznlo3nlo7nlpDnlpPnlpXnlpjnlpvnlpznlp7nlqLnlqZcIiw0LFwi55at55a255a355a655a755a/55eA55eB55eG55eL55eM55eO55eP55eQ55eR55eT55eX55eZ55ea55ec55ed55ef55eg55eh55el55ep55es55et55eu55ev55ey55ez55e155e255e355e455e655e755e955e+55iC55iE55iG55iHXCJdLFxuW1wiYWY4MFwiLFwi55iI55iJ55iL55iN55iO55iP55iR55iS55iT55iU55iW55ia55ic55id55ie55ih55ij55in55io55is55iu55iv55ix55iy55i255i355i555i655i755i955mB55mC55mEXCJdLFxuW1wiYjA0MFwiLFwi55mFXCIsNixcIueZjlwiLDUsXCLnmZXnmZdcIiw0LFwi55md55mf55mg55mh55mi55mkXCIsNixcIueZrOeZreeZrueZsFwiLDcsXCLnmbnnmbrnmbznmb/nmoDnmoHnmoPnmoXnmonnmornmoznmo3nmo/nmpDnmpLnmpTnmpXnmpfnmpjnmprnmptcIl0sXG5bXCJiMDgwXCIsXCLnmpxcIiw3LFwi55qlXCIsOCxcIuear+easOeas+eatVwiLDksXCLnm4Dnm4Hnm4PllYrpmL/ln4PmjKjlk47llInlk4DnmpHnmYzolLznn67oib7noo3niLHpmpjpno3msKjlronkv7rmjInmmpflsrjog7rmoYjogq7mmILnm47lh7nmlZbnhqznv7HoooTlgrLlpaXmh4rmvrPoiq3mjYzmiZLlj63lkKfnrIblhavnlqTlt7Tmi5Tot4vpnbbmiorogJnlnZ3pnLjnvaLniLjnmb3mn4/nmb7mkYbkvbDotKXmi5znqJfmlpHnj63mkKzmibPoiKzpooHmnb/niYjmia7mi4zkvLTnk6PljYrlip7nu4rpgqbluK7moobmppzohoDnu5Hmo5Lno4XomozplZHlgo3osKToi57og57ljIXopJLliaVcIl0sXG5bXCJiMTQwXCIsXCLnm4Tnm4fnm4nnm4vnm4znm5Pnm5Xnm5nnm5rnm5znm53nm57nm6BcIiw0LFwi55umXCIsNyxcIuebsOebs+ebteebtuebt+ebuuebu+ebveebv+ecgOecguecg+echeechueciuecjOecjlwiLDEwLFwi55yb55yc55yd55ye55yh55yj55yk55yl55yn55yq55yrXCJdLFxuW1wiYjE4MFwiLFwi55ys55yu55ywXCIsNCxcIuecueecu+ecveecvuecv+edguedhOedheedhuediFwiLDcsXCLnnZJcIiw3LFwi552c6JaE6Zu55L+d5aCh6aWx5a6d5oqx5oql5pq06LG56bKN54iG5p2v56KR5oKy5Y2R5YyX6L6I6IOM6LSd6ZKh5YCN54uI5aSH5oOr54SZ6KKr5aWU6Iuv5pys56yo5bSp57u355St5rO16Lmm6L+46YC86by75q+U6YSZ56yU5b2856Kn6JOW6JS95q+V5q+Z5q+W5biB5bqH55e56Zet5pWd5byK5b+F6L6f5aOB6IeC6YG/6Zmb6Z6t6L6557yW6LSs5omB5L6/5Y+Y5Y2e6L6o6L6p6L6r6YGN5qCH5b2q6IaY6KGo6bOW5oaL5Yir55iq5b2s5paM5r+S5ruo5a6+5pGI5YW15Yaw5p+E5LiZ56eJ6aW854KzXCJdLFxuW1wiYjI0MFwiLFwi552d552e552f552g552k552n552p552q552tXCIsMTEsXCLnnbrnnbvnnbznnoHnnoLnnoPnnoZcIiw1LFwi556P556Q556TXCIsMTEsXCLnnqHnnqPnnqTnnqbnnqjnnqvnnq3nnq7nnq/nnrHnnrLnnrTnnrZcIiw0XSxcbltcImIyODBcIixcIueevOeevuefgFwiLDEyLFwi55+OXCIsOCxcIuefmOefmeefmuefnVwiLDQsXCLnn6Tnl4Xlubbnjrvoj6Dmkq3mi6jpkrXms6LljZrli4PmkI/pk4LnrpTkvK/luJvoiLbohJbohormuKTms4rpqbPmjZXljZzlk7rooaXln6DkuI3luIPmraXnsL/pg6jmgJbmk6bnjJzoo4HmnZDmiY3otKLnnazouKnph4flvanoj5zolKHppJDlj4LompXmrovmg63mg6jngb/oi43oiLHku5Pmsqfol4/mk43ns5nmp73mm7nojYnljpXnrZbkvqflhozmtYvlsYLoua3mj5Llj4nojKzojLbmn6XnorTmkL3lr5/lspTlt67or6fmi4bmn7TosbrmkIDmjrronYnppovosJfnvKDpk7LkuqfpmJDpoqTmmIznjJZcIl0sXG5bXCJiMzQwXCIsXCLnn6bnn6jnn6rnn6/nn7Dnn7Hnn7Lnn7Tnn7Xnn7fnn7nnn7rnn7vnn7znoINcIiw1LFwi56CK56CL56CO56CP56CQ56CT56CV56CZ56Cb56Ce56Cg56Ch56Ci56Ck56Co56Cq56Cr56Cu56Cv56Cx56Cy56Cz56C156C256C956C/56GB56GC56GD56GE56GG56GI56GJ56GK56GL56GN56GP56GR56GT56GU56GY56GZ56GaXCJdLFxuW1wiYjM4MFwiLFwi56Gb56Gc56GeXCIsMTEsXCLnoa9cIiw3LFwi56G456G556G656G756G9XCIsNixcIuWcuuWwneW4uOmVv+WBv+iCoOWOguaVnueVheWUseWAoei2heaKhOmSnuacneWYsua9ruW3ouWQteeCkui9puaJr+aSpOaOo+W9u+a+iOmDtOiHo+i+sOWwmOaZqOW/seayiemZiOi2geihrOaSkeensOWfjuapmeaIkOWRiOS5mOeoi+aDqea+hOivmuaJv+mAnumqi+enpOWQg+eXtOaMgeWMmeaxoOi/n+W8m+mpsOiAu+m9v+S+iOWwuui1pOe/heaWpeeCveWFheWGsuiZq+W0h+WuoOaKvemFrOeVtOi4jOeooOaEgeetueS7h+e7uOeeheS4keiHreWIneWHuuapseWOqOi6h+mUhOmbj+a7gemZpOalmlwiXSxcbltcImI0NDBcIixcIueihOeiheeihueiiOeiiueii+eij+eikOeikueilOeileeilueimeeineeinueioOeioueipOeipueiqFwiLDcsXCLnorXnorbnorfnorjnorrnorvnorznor3nor/no4Dno4Lno4Pno4Tno4bno4fno4jno4zno43no47no4/no5Hno5Lno5Pno5bno5fno5jno5pcIiw5XSxcbltcImI0ODBcIixcIuejpOejpeejpuejp+ejqeejquejq+ejrVwiLDQsXCLno7Pno7Xno7bno7jno7nno7tcIiw1LFwi56SC56SD56SE56SGXCIsNixcIuehgOWCqOefl+aQkOinpuWkhOaPo+W3neepv+akveS8oOiIueWWmOS4sueWrueql+W5ouW6iumXr+WIm+WQueeCiuaNtumUpOWeguaYpeakv+mGh+WUh+a3s+e6r+igouaIs+e7sOeWteiMqOejgembjOi+nuaFiOeTt+ivjeatpOWIuui1kOasoeiBquiRseWbseWMhuS7juS4m+WHkeeyl+mGi+ewh+S/g+i5v+evoeeqnOaRp+W0lOWCrOiEhueYgeeyuea3rOe/oOadkeWtmOWvuOeji+aSruaQk+aOquaMq+mUmeaQrei+vuetlOeYqeaJk+Wkp+WRhuatueWCo+aItOW4puauhuS7o+i0t+iii+W+hemArlwiXSxcbltcImI1NDBcIixcIuekjVwiLDUsXCLnpJRcIiw5LFwi56SfXCIsNCxcIuekpVwiLDE0LFwi56S1XCIsNCxcIuekveekv+elguelg+elhOelheelh+elilwiLDgsXCLnpZTnpZXnpZjnpZnnpaHnpaNcIl0sXG5bXCJiNTgwXCIsXCLnpaTnpabnpannparnpavnpaznpa7npbBcIiw2LFwi56W556W7XCIsNCxcIuemguemg+emhuemh+emiOemieemi+emjOemjeemjuemkOemkeemkuaAoOiAveaLheS4ueWNlemDuOaOuOiDhuaXpuawruS9huaDrua3oeivnuW8ueibi+W9k+aMoeWFmuiNoeaho+WIgOaNo+i5iOWAkuWym+elt+WvvOWIsOeou+aCvOmBk+ebl+W+t+W+l+eahOi5rOeBr+eZu+etieeequWHs+mCk+WgpOS9jua7tOi/quaVjOesm+eLhOa2pOe/n+WroeaKteW6leWcsOiSguesrOW4neW8n+mAkue8lOmioOaOgua7h+eimOeCueWFuOmdm+Weq+eUteS9g+eUuOW6l+aDpuWloOa3gOauv+eiieWPvOmbleWHi+WIgeaOieWQiumSk+iwg+i3jOeIueein+idtui/reiwjeWPoFwiXSxcbltcImI2NDBcIixcIuemk1wiLDYsXCLnpptcIiwxMSxcIuemqFwiLDEwLFwi56a0XCIsNCxcIuemvOemv+enguenhOenheenh+eniOeniuenjOenjuenj+enkOenk+enlOenluenl+enmVwiLDUsXCLnp6Dnp6Hnp6Lnp6Xnp6jnp6pcIl0sXG5bXCJiNjgwXCIsXCLnp6znp67np7FcIiw2LFwi56e556e656e856e+56e/56iB56iE56iF56iH56iI56iJ56iK56iM56iPXCIsNCxcIueoleeolueomOeomeeom+eonOS4geebr+WPrumSiemhtum8jumUreWumuiuouS4ouS4nOWGrOiRo+aHguWKqOagi+S+l+aBq+WGu+a0nuWFnOaKluaWl+mZoeixhumAl+eXmOmDveedo+avkueKiueLrOivu+Wgteeduei1jOadnOmVgOiCmuW6pua4oeWmkuerr+efremUu+auteaWree8juWghuWFkemYn+WvueWiqeWQqOi5suaVpumhv+WbpOmSneebvumBgeaOh+WThuWkmuWkuuWem+i6suactei3uuiIteWJgeaDsOWgleibvuWzqOm5heS/hOmineiuueWopeaBtuWOhOaJvOmBj+mEgumlv+aBqeiAjOWEv+iAs+WwlOmltea0seS6jFwiXSxcbltcImI3NDBcIixcIueoneeon+eooeeooueopFwiLDE0LFwi56i056i156i256i456i656i+56mAXCIsNSxcIueph1wiLDksXCLnqZJcIiw0LFwi56mYXCIsMTZdLFxuW1wiYjc4MFwiLFwi56mpXCIsNixcIuepseepsueps+epteepu+epvOepveepvueqgueqheeqh+eqieeqiueqi+eqjOeqjueqj+eqkOeqk+eqlOeqmeeqmueqm+eqnueqoeeqoui0sOWPkee9muetj+S8kOS5j+mYgOazleePkOiXqeW4hueVque/u+aoiuefvumSkue5geWHoeeDpuWPjei/lOiMg+i0qeeKr+mlreazm+WdiuiKs+aWueiCquaIv+mYsuWmqOS7v+iuv+e6uuaUvuiPsumdnuWVoemjnuiCpeWMquivveWQoOiCuuW6n+ayuOi0ueiKrOmFmuWQqeawm+WIhue6t+Wdn+eEmuaxvueyieWli+S7veW/v+aEpOeyquS4sOWwgeaeq+icguWzsOmUi+mjjueWr+eDvemAouWGr+e8neiuveWlieWHpOS9m+WQpuWkq+aVt+iCpOWtteaJtuaLgui+kOW5heawn+espuS8j+S/mOacjVwiXSxcbltcImI4NDBcIixcIueqo+eqpOeqp+eqqeeqqueqq+eqrlwiLDQsXCLnqrRcIiwxMCxcIuergFwiLDEwLFwi56uMXCIsOSxcIuerl+ermOermuerm+ernOerneeroeerouerpOerp1wiLDUsXCLnq67nq7Dnq7Hnq7Lnq7NcIl0sXG5bXCJiODgwXCIsXCLnq7RcIiw0LFwi56u756u856u+56yA56yB56yC56yF56yH56yJ56yM56yN56yO56yQ56yS56yT56yW56yX56yY56ya56yc56yd56yf56yh56yi56yj56yn56yp56yt5rWu5raq56aP6KKx5byX55Sr5oqa6L6F5L+v6Yec5pan6ISv6IWR5bqc6IWQ6LW05Ymv6KaG6LWL5aSN5YKF5LuY6Zic54i26IW56LSf5a+M6K6j6ZmE5aaH57ya5ZKQ5Zm25ZiO6K+l5pS55qaC6ZKZ55uW5rqJ5bmy55SY5p2G5p+R56u/6IKd6LW25oSf56eG5pWi6LWj5YaI5Yia6ZKi57y46IKb57qy5bKX5riv5p2g56+Z55qL6auY6IaP576U57OV5pCe6ZWQ56i/5ZGK5ZOl5q2M5pCB5oiI6bi96IOz55aZ5Ymy6Z2p6JGb5qC86Juk6ZiB6ZqU6ZOs5Liq5ZCE57uZ5qC56Lef6ICV5pu05bqa5765XCJdLFxuW1wiYjk0MFwiLFwi56yv56yw56yy56y056y156y256y356y556y756y956y/XCIsNSxcIuethuetiOetiuetjeetjuetk+etleetl+etmeetnOetnuetn+etoeeto1wiLDEwLFwi562v562w562z562056225624562656285629562/566B566C566D566E566GXCIsNixcIueujueuj1wiXSxcbltcImI5ODBcIixcIueukeeukueuk+eulueumOeumeeumueum+eunueun+euoOeuo+eupOeupeeurueur+eusOeusueus+euteeutueut+euuVwiLDcsXCLnr4Lnr4Pnr4Tln4LogL/mopflt6XmlLvlip/mga3pvprkvpvouqzlhazlrqvlvJPlt6nmsZ7mi7HotKHlhbHpkqnli77msp/oi5/ni5flnqLmnoTotK3lpJ/ovpzoj4flkpXnro3kvLDmsr3lraTlp5HpvJPlj6Tom4rpqqjosLfogqHmlYXpob7lm7rpm4fliK7nk5zliZDlr6HmjILopILkuZbmi5DmgKrmo7rlhbPlrpjlhqDop4LnrqHppobnvZDmg6/ngYzotK/lhYnlub/pgJvnkbDop4TlnK3noYXlvZLpvp/pl7rovajprLzor6HnmbjmoYLmn5zot6rotLXliL3ovormu5rmo43plIXpg63lm73mnpzoo7nov4flk4hcIl0sXG5bXCJiYTQwXCIsXCLnr4Xnr4jnr4nnr4rnr4vnr43nr47nr4/nr5Dnr5Lnr5RcIiw0LFwi56+b56+c56+e56+f56+g56+i56+j56+k56+n56+o56+p56+r56+s56+t56+v56+w56+yXCIsNCxcIuevuOevueevuuevu+evveevv1wiLDcsXCLnsIjnsInnsIrnsI3nsI7nsJBcIiw1LFwi57CX57CY57CZXCJdLFxuW1wiYmE4MFwiLFwi57CaXCIsNCxcIuewoFwiLDUsXCLnsKjnsKnnsKtcIiwxMixcIuewuVwiLDUsXCLnsYLpqrjlranmtbfmsKbkuqXlrrPpqofphaPmhqjpgq/pn6nlkKvmtrXlr5Llh73llornvZXnv7DmkrzmjY3ml7Hmhr7mgo3nhIrmsZfmsYnlpK/mna3oiKrlo5Xlmo7osarmr6vpg53lpb3ogJflj7fmtanlkbXllp3ojbfoj4/moLjnpr7lkozkvZXlkIjnm5LosonpmILmsrPmtrjotavopJDpuaTotLrlmL/pu5Hnl5Xlvojni6Dmgajlk7zkuqjmqKrooaHmgZLovbDlk4Tng5jombnpuL/mtKrlro/lvJjnuqLllonkvq/njLTlkLzljprlgJnlkI7lkbzkuY7lv73nkZrlo7bokavog6HonbTni5Dns4rmuZZcIl0sXG5bXCJiYjQwXCIsXCLnsYNcIiw5LFwi57GOXCIsMzYsXCLnsbVcIiw1LFwi57G+XCIsOV0sXG5bXCJiYjgwXCIsXCLnsojnsopcIiw2LFwi57KT57KU57KW57KZ57Ka57Kb57Kg57Kh57Kj57Km57Kn57Ko57Kp57Kr57Ks57Kt57Kv57Kw57K0XCIsNCxcIueyuueyu+W8p+iZjuWUrOaKpOS6kuayquaIt+iKseWTl+WNjueMvua7keeUu+WIkuWMluivneankOW+iuaAgOa3ruWdj+asoueOr+ahk+i/mOe8k+aNouaCo+WUpOeXquixoueElea2o+WupuW5u+iNkuaFjOm7hOejuuidl+ewp+eah+WHsOaDtueFjOaZg+W5jOaBjeiwjueBsOaMpei+ieW+veaBouiblOWbnuavgeaClOaFp+WNieaDoOaZpui0v+enveS8mueDqeaxh+ius+ivsue7mOiNpOaYj+Wpmumtgua1kea3t+ixgea0u+S8meeBq+iOt+aIluaDkemcjei0p+eluOWHu+WcvuWfuuacuueVuOeoveenr+eulVwiXSxcbltcImJjNDBcIixcIueyv+ezgOezguezg+ezhOezhuezieezi+ezjlwiLDYsXCLns5jns5rns5vns53ns57ns6FcIiw2LFwi57OpXCIsNSxcIuezsFwiLDcsXCLns7nns7rns7xcIiwxMyxcIue0i1wiLDVdLFxuW1wiYmM4MFwiLFwi57SRXCIsMTQsXCLntKHntKPntKTntKXntKbntKjntKnntKrntKzntK3ntK7ntLBcIiw2LFwi6IKM6aWl6L+55r+A6K6l6bih5aes57up57yJ5ZCJ5p6B5qOY6L6R57GN6ZuG5Y+K5oCl55a+5rGy5Y2z5auJ57qn5oyk5Yeg6ISK5bex6JOf5oqA5YaA5a2j5LyO56Wt5YmC5oK45rWO5a+E5a+C6K6h6K6w5pei5b+M6ZmF5aaT57un57qq5ZiJ5p635aS55L2z5a625Yqg6I2a6aKK6LS+55Sy6ZK+5YGH56i85Lu35p626am+5auB5q2855uR5Z2a5bCW56y66Ze054WO5YW86IKp6Imw5aW457yE6Iyn5qOA5p+s56Kx56G35ouj5o2h566A5L+t5Ymq5YeP6I2Q5qeb6Ym06Le16LSx6KeB6ZSu566t5Lu2XCJdLFxuW1wiYmQ0MFwiLFwi57S3XCIsNTQsXCLnta9cIiw3XSxcbltcImJkODBcIixcIue1uFwiLDMyLFwi5YGl6Iiw5YmR6aWv5riQ5rqF5ran5bu65YO15aec5bCG5rWG5rGf55aG6JKL5qGo5aWW6K6y5Yyg6YWx6ZmN6JWJ5qSS56SB54Sm6IO25Lqk6YOK5rWH6aqE5aiH5Zq85pCF6ZOw55+r5L6l6ISa54uh6KeS6aW657y057ue5Ym/5pWZ6YW16L2/6L6D5Y+r56qW5o+t5o6l55qG56e46KGX6Zi25oiq5Yqr6IqC5qGU5p2w5o23552r56ut5rSB57uT6Kej5aeQ5oiS6JeJ6Iql55WM5YCf5LuL55al6K+r5bGK5be+562L5pak6YeR5LuK5rSl6KWf57Sn6ZSm5LuF6LCo6L+b6Z2z5pmL56aB6L+R54Os5rW4XCJdLFxuW1wiYmU0MFwiLFwi57aZXCIsMTIsXCLntqdcIiw2LFwi57avXCIsNDJdLFxuW1wiYmU4MFwiLFwi57eaXCIsMzIsXCLlsL3lirLojYblhaLojI7nnZvmmbbpsrjkuqzmg4rnsr7nsrPnu4/kupXorabmma/poojpnZnlooPmlazplZzlvoTnl4npnZbnq5/nq57lh4Dngq/nqpjmj6rnqbbnuqDnjpbpn63kuYXngbjkuZ3phZLljqnmlZHml6foh7zoiIXlko7lsLHnlprpnqDmi5jni5nnlr3lsYXpqbnoj4rlsYDlkoDnn6nkuL7msq7ogZrmi5Lmja7lt6jlhbfot53ouJ7plK/kv7Hlj6Xmg6fngqzliafmjZDpuYPlqJ/lgKbnnLfljbfnu6LmkoXmlKvmionmjpjlgJTniLXop4nlhrPor4Dnu53lnYfoj4zpkqflhpvlkJvls7tcIl0sXG5bXCJiZjQwXCIsXCLnt7tcIiw2Ml0sXG5bXCJiZjgwXCIsXCLnuLrnuLxcIiw0LFwi57mCXCIsNCxcIue5iFwiLDIxLFwi5L+K56uj5rWa6YOh6aqP5ZaA5ZKW5Y2h5ZKv5byA5o+p5qW35Yev5oWo5YiK5aCq5YuY5Z2O56CN55yL5bq35oW357Og5omb5oqX5Lqi54KV6ICD5ou354Ok6Z2g5Z236Iub5p+v5qO156OV6aKX56eR5aOz5ZKz5Y+v5ri05YWL5Yi75a6i6K++6IKv5ZWD5Z6m5oGz5Z2R5ZCt56m65oGQ5a2U5o6n5oqg5Y+j5omj5a+H5p6v5ZOt56qf6Ium6YW35bqT6KOk5aS45Z6u5oyO6Leo6IOv5Z2X56235L6p5b+r5a695qy+5Yyh562Q54uC5qGG55+/55y25pe35Ya15LqP55uU5bK/56ql6JG15aWO6a2B5YKAXCJdLFxuW1wiYzA0MFwiLFwi57meXCIsMzUsXCLnuoNcIiwyMyxcIue6nOe6nee6nlwiXSxcbltcImMwODBcIixcIue6rue6tOe6u+e6vOe7lue7pOe7rOe7uee8iue8kOe8nue8t+e8uee8u1wiLDYsXCLnvYPnvYZcIiw5LFwi572S572T6aaI5oSn5rqD5Z2k5piG5o2G5Zuw5ous5omp5buT6ZiU5Z6D5ouJ5ZaH6Jyh6IWK6L6j5ZWm6I6x5p2l6LWW6JOd5amq5qCP5oum56+u6ZiR5YWw5r6c6LCw5o+96KeI5oeS57yG54OC5rul55CF5qaU54u85buK6YOO5pyX5rWq5o2e5Yqz54mi6ICB5L2s5ael6YWq54OZ5rad5YuS5LmQ6Zu36ZWt6JW+56OK57Sv5YSh5Z6S5pOC6IKL57G75rOq5qOx5qWe5Ya35Y6Y5qKo54qB6buO56+x54u456a75ryT55CG5p2O6YeM6bKk56S86I6J6I2U5ZCP5qCX5Li95Y6J5Yqx56C+5Y6G5Yip5YKI5L6L5L+QXCJdLFxuW1wiYzE0MFwiLFwi572W572Z572b572c572d572e572g572jXCIsNCxcIue9q+e9rOe9ree9r+e9sOe9s+e9tee9tue9t+e9uOe9uue9u+e9vOe9vee9v+e+gOe+glwiLDcsXCLnvovnvo3nvo9cIiw0LFwi576VXCIsNCxcIue+m+e+nOe+oOe+oue+o+e+pee+pue+qFwiLDYsXCLnvrFcIl0sXG5bXCJjMTgwXCIsXCLnvrNcIiw0LFwi57665767576+57+A57+C57+D57+E57+G57+H57+I57+J57+L57+N57+PXCIsNCxcIue/lue/l+e/mVwiLDUsXCLnv6Lnv6Pnl6Lnq4vnspLmsqXpmrblipvnkoPlk6nkv6nogZTojrLov57plbDlu4nmgJzmtp/luJjmlZvohLjpk77mgYvngrznu4Pnsq7lh4nmooHnsrHoia/kuKTovobph4/mmb7kuq7osIXmkqnogYrlg5rnlpfnh47lr6Xovr3mvabkuobmkoLplaPlu5bmlpnliJfoo4Lng4jliqPnjI7nkLPmnpfno7fpnJbkuLTpgrvps57mt4vlh5votYHlkJ3mi47njrLoj7Hpm7bpvoTpk4PkvLbnvprlh4zngbXpmbXlsq3pooblj6bku6TmupznkInmprTnoavppo/nlZnliJjnmKTmtYHmn7Plha3pvpnogYvlkpnnrLznqr9cIl0sXG5bXCJjMjQwXCIsXCLnv6Tnv6fnv6jnv6rnv6vnv6znv63nv6/nv7Lnv7RcIiw2LFwi57+957++57+/6ICC6ICH6ICI6ICJ6ICK6ICO6ICP6ICR6ICT6ICa6ICb6ICd6ICe6ICf6ICh6ICj6ICk6ICrXCIsNSxcIuiAsuiAtOiAueiAuuiAvOiAvuiBgOiBgeiBhOiBheiBh+iBiOiBieiBjuiBj+iBkOiBkeiBk+iBleiBluiBl1wiXSxcbltcImMyODBcIixcIuiBmeiBm1wiLDEzLFwi6IGrXCIsNSxcIuiBslwiLDExLFwi6ZqG5Z6E5oui6ZmH5qW85aiE5pCC56+T5ryP6ZmL6Iqm5Y2i6aKF5bqQ54KJ5o6z5Y2k6JmP6bKB6bqT56KM6Zyy6Lev6LWC6bm/5r2e56aE5b2V6ZmG5oiu6am05ZCV6ZOd5L6j5peF5bGl5bGh57yV6JmR5rCv5b6L546H5ruk57u/5bOm5oyb5a2q5rum5Y215Lmx5o6g55Wl5oqh6L2u5Lym5LuR5rKm57q26K666JCd6J66572X6YC76ZSj566p6aqh6KO46JC95rSb6aqG57uc5aaI6bq7546b56CB6JqC6ams6aqC5Zib5ZCX5Z+L5Lmw6bqm5Y2W6L+I6ISJ556S6aaS6Juu5ruh6JST5pu85oWi5ryrXCJdLFxuW1wiYzM0MFwiLFwi6IG+6IKB6IKC6IKF6IKI6IKK6IKNXCIsNSxcIuiClOiCleiCl+iCmeiCnuiCo+iCpuiCp+iCqOiCrOiCsOiCs+iCteiCtuiCuOiCueiCu+iDheiDh1wiLDQsXCLog49cIiw2LFwi6IOY6IOf6IOg6IOi6IOj6IOm6IOu6IO16IO36IO56IO76IO+6IO/6ISA6ISB6ISD6ISE6ISF6ISH6ISI6ISLXCJdLFxuW1wiYzM4MFwiLFwi6ISM6ISV6ISX6ISZ6ISb6ISc6ISd6ISfXCIsMTIsXCLohK3ohK7ohLDohLPohLTohLXohLfohLlcIiw0LFwi6IS/6LCp6IqS6Iyr55uy5rCT5b+Z6I6954yr6IyF6ZSa5q+b55+b6ZOG5Y2v6IyC5YaS5bi96LKM6LS45LmI546r5p6a5qKF6YW26ZyJ54Wk5rKh55yJ5aqS6ZWB5q+P576O5pin5a+Q5aa55aqa6Zeo6Ze35Lus6JCM6JKZ5qqs55uf6ZSw54yb5qKm5a2f55yv6Yaa6Z2h57Oc6L+36LCc5byl57Gz56eY6KeF5rOM6Jyc5a+G5bmC5qOJ55yg57u15YaV5YWN5YuJ5aip57yF6Z2i6IuX5o+P556E6JeQ56eS5ri65bqZ5aaZ6JSR54Gt5rCR5oq/55q/5pWP5oKv6Ze95piO6J6f6bij6ZOt5ZCN5ZG96LCs5pG4XCJdLFxuW1wiYzQ0MFwiLFwi6IWAXCIsNSxcIuiFh+iFieiFjeiFjuiFj+iFkuiFluiFl+iFmOiFm1wiLDQsXCLohaHohaLohaPohaTohabohajoharohavohazoha/ohbLohbPohbXohbbohbfohbjohoHohoNcIiw0LFwi6IaJ6IaL6IaM6IaN6IaO6IaQ6IaSXCIsNSxcIuiGmeiGmuiGnlwiLDQsXCLohqTohqVcIl0sXG5bXCJjNDgwXCIsXCLohqfohqnohqtcIiw3LFwi6Ia0XCIsNSxcIuiGvOiGveiGvuiGv+iHhOiHheiHh+iHiOiHieiHi+iHjVwiLDYsXCLmkbnomJHmqKHohpzno6jmkanprZTmirnmnKvojqvloqjpu5jmsqvmvKDlr57pmYzosIvniZ/mn5Dmi4fniaHkuqnlp4bmr43lopPmmq7luZXli5/mhZXmnKjnm67nnabniafnqYbmi7/lk6rlkZDpkqDpgqPlqJznurPmsJbkuYPlpbbogJDlpYjljZfnlLfpmr7lm4rmjKDohJHmgbzpl7nmt5blkaLppoHlhoXlq6nog73lpq7pnJPlgKrms6XlsLzmi5/kvaDljL/ohbvpgIbmurrolKvmi4jlubTnor7mkrXmjbvlv7XlqJjphb/puJ/lsL/mjY/ogYLlrb3lla7plYrplY3mtoXmgqjmn6Dni57lh53lroFcIl0sXG5bXCJjNTQwXCIsXCLoh5RcIiwxNCxcIuiHpOiHpeiHpuiHqOiHqeiHq+iHrlwiLDQsXCLoh7VcIiw1LFwi6Ie96Ie/6IiD6IiHXCIsNCxcIuiIjuiIj+iIkeiIk+iIlVwiLDUsXCLoiJ3oiKDoiKToiKXoiKboiKfoiKnoiK7oiLLoiLroiLzoiL3oiL9cIl0sXG5bXCJjNTgwXCIsXCLoiYDoiYHoiYLoiYPoiYXoiYboiYjoiYroiYzoiY3oiY7oiZBcIiw3LFwi6ImZ6Imb6Imc6Imd6Ime6ImgXCIsNyxcIuiJqeaLp+aznueJm+aJremSrue6veiEk+a1k+WGnOW8hOWltOWKquaAkuWls+aaluiZkOeWn+aMquaHpuezr+ivuuWTpuasp+m4peautOiXleWRleWBtuaypOWVqui2tOeIrOW4leaAleeQtuaLjeaOkueJjOW+mOa5g+a0vuaUgOa9mOebmOejkOebvOeVlOWIpOWPm+S5k+W6nuaXgeiAquiDluaKm+WShuWIqOeCruiijei3keazoeWRuOiDmuWfueijtOi1lOmZqumFjeS9qeaym+WWt+ebhuegsOaKqOeDuea+juW9reiTrOajmuehvOevt+iGqOaci+m5j+aNp+eisOWdr+egkumcueaJueaKq+WKiOeQteavl1wiXSxcbltcImM2NDBcIixcIuiJquiJq+iJrOiJreiJseiJteiJtuiJt+iJuOiJu+iJvOiKgOiKgeiKg+iKheiKhuiKh+iKieiKjOiKkOiKk+iKlOiKleiKluiKmuiKm+iKnuiKoOiKouiKo+iKp+iKsuiKteiKtuiKuuiKu+iKvOiKv+iLgOiLguiLg+iLheiLhuiLieiLkOiLluiLmeiLmuiLneiLouiLp+iLqOiLqeiLquiLrOiLreiLruiLsOiLsuiLs+iLteiLtuiLuFwiXSxcbltcImM2ODBcIixcIuiLuuiLvFwiLDQsXCLojIrojIvojI3ojJDojJLojJPojJbojJjojJnojJ1cIiw5LFwi6Iyp6Iyq6Iyu6Iyw6Iyy6Iy36Iy76Iy95ZWk6IS+55ay55qu5Yy555ee5YO75bGB6K2s56+H5YGP54mH6aqX6aOY5ryC55Oi56Wo5pKH556l5ou86aKR6LSr5ZOB6IGY5LmS5Z2q6Iu56JCN5bmz5Yet55O26K+E5bGP5Z2h5rO86aKH5amG56C06a2E6L+r57KV5YmW5omR6ZO65LuG6I6G6JGh6I+p6JKy5Z+U5py05ZyD5pmu5rWm6LCx5pud54CR5pyf5qy65qCW5oia5aa75LiD5YeE5ryG5p+S5rKP5YW25qOL5aWH5q2n55Wm5bSO6ISQ6b2Q5peX56WI56WB6aqR6LW35bKC5Lme5LyB5ZCv5aWR56CM5Zmo5rCU6L+E5byD5rG95rOj6K6r5o6QXCJdLFxuW1wiYzc0MFwiLFwi6Iy+6Iy/6I2B6I2C6I2E6I2F6I2I6I2KXCIsNCxcIuiNk+iNlVwiLDQsXCLojZ3ojaLojbBcIiw2LFwi6I256I266I2+XCIsNixcIuiOh+iOiOiOiuiOi+iOjOiOjeiOj+iOkOiOkeiOlOiOleiOluiOl+iOmeiOmuiOneiOn+iOoVwiLDYsXCLojqzojq3ojq5cIl0sXG5bXCJjNzgwXCIsXCLojq/ojrXojrvojr7ojr/oj4Loj4Poj4Toj4boj4joj4noj4voj43oj47oj5Doj5Hoj5Loj5Poj5Xoj5foj5noj5roj5voj57oj6Loj6Poj6Toj6boj6foj6joj6voj6zoj63mgbDmtL3nibXmiabpko7pk4XljYPov4Hnrb7ku5/osKbkub7pu5TpkrHpkrPliY3mvZzpgaPmtYXosLTloJHltYzmrKDmrYnmnqrlkZvohZTnvozlopnolLflvLrmiqLmqYfplLnmlbLmgoTmoaXnnqfkuZTkvqjlt6fpnpjmkqznv5jls63kv4/nqo3liIfojITkuJTmgK/nqoPpkqbkvrXkurLnp6bnkLTli6Toirnmk5Lnpr3lr53msoHpnZLovbvmsKLlgL7ljb/muIXmk47mmbTmsLDmg4Xpobfor7fluobnkLznqbfnp4vkuJjpgrHnkIPmsYLlm5rphYvms4XotovljLrom4bmm7Louq/lsYjpqbHmuKBcIl0sXG5bXCJjODQwXCIsXCLoj67oj6/oj7NcIiw0LFwi6I+66I+76I+86I++6I+/6JCA6JCC6JCF6JCH6JCI6JCJ6JCK6JCQ6JCSXCIsNSxcIuiQmeiQmuiQm+iQnlwiLDUsXCLokKlcIiw3LFwi6JCyXCIsNSxcIuiQueiQuuiQu+iQvlwiLDcsXCLokYfokYjokYlcIl0sXG5bXCJjODgwXCIsXCLokYpcIiw2LFwi6JGSXCIsNCxcIuiRmOiRneiRnuiRn+iRoOiRouiRpFwiLDQsXCLokaroka7oka/okbDokbLokbTokbfokbnokbvokbzlj5blqLbpvovotqPljrvlnIjpoqfmnYPphpvms4nlhajnl4rmi7PniqzliLjlip3nvLrngpTnmLjljbTpuYrmprfnoa7pm4Doo5nnvqTnhLbnh4Plhonmn5Pnk6Tlo6TmlJjlmrforqnppbbmibDnu5Xmg7nng63lo6zku4Hkurrlv43pn6fku7vorqTliIPlpornuqvmiZTku43ml6XmiI7ojLjok4nojaPono3nhpTmurblrrnnu5Llhpfmj4nmn5TogonojLnooJXlhJLlrbrlpoLovrHkubPmsZ3lhaXopKXova/pmK7olYrnkZ7plJDpl7Dmtqboi6XlvLHmkpLmtJLokKjoha7ps4PloZ7otZvkuInlj4FcIl0sXG5bXCJjOTQwXCIsXCLokb1cIiw0LFwi6JKD6JKE6JKF6JKG6JKK6JKN6JKPXCIsNyxcIuiSmOiSmuiSm+iSneiSnuiSn+iSoOiSolwiLDEyLFwi6JKw6JKx6JKz6JK16JK26JK36JK76JK86JK+6JOA6JOC6JOD6JOF6JOG6JOH6JOI6JOL6JOM6JOO6JOP6JOS6JOU6JOV6JOXXCJdLFxuW1wiYzk4MFwiLFwi6JOYXCIsNCxcIuiTnuiToeiTouiTpOiTp1wiLDQsXCLok63ok67ok6/ok7FcIiwxMCxcIuiTveiTvuiUgOiUgeiUguS8nuaVo+ahkeWXk+S4p+aQlOmqmuaJq+WrgueRn+iJsua2qeajruWDp+iOjuegguadgOWIueaymee6seWCu+WVpeeFnuetm+aZkuePiuiLq+adieWxseWIoOeFveihq+mXqumZleaThei1oeiGs+WWhOaxleaJh+e8ruWikuS8pOWVhui1j+aZjOS4iuWwmuijs+aiouaNjueojeeDp+iKjeWLuumftuWwkeWTqOmCtee7jeWloui1iuibh+iIjOiIjei1puaRhOWwhOaFkea2ieekvuiuvuegt+eUs+WRu+S8uOi6q+a3seWooOe7heelnuayiOWuoeWptueUmuiCvuaFjua4l+WjsOeUn+eUpeeJsuWNh+e7s1wiXSxcbltcImNhNDBcIixcIuiUg1wiLDgsXCLolI3olI7olI/olJDolJLolJTolJXolJbolJjolJnolJvolJzolJ3olJ7olKDolKJcIiw4LFwi6JStXCIsOSxcIuiUvlwiLDQsXCLolYTolYXolYbolYfolYtcIiwxMF0sXG5bXCJjYTgwXCIsXCLolZfolZjolZrolZvolZzolZ3olZ9cIiw0LFwi6JWl6JWm6JWn6JWpXCIsOCxcIuiVs+iVteiVtuiVt+iVuOiVvOiVveiVv+iWgOiWgeecgeebm+WJqeiDnOWco+W4iOWkseeLruaWvea5v+ivl+WwuOiZseWNgeefs+aLvuaXtuS7gOmjn+iagOWunuivhuWPsuefouS9v+WxjumptuWni+W8j+ekuuWjq+S4luafv+S6i+aLreiqk+mAneWKv+aYr+WXnOWZrOmAguS7leS+jemHiumlsOawj+W4guaBg+WupOinhuivleaUtuaJi+mmluWuiOWvv+aOiOWUruWPl+eYpuWFveiUrOaeouais+auiuaKkui+k+WPlOiIkua3keeWj+S5pui1juWtsOeGn+iWr+aakeabmee9suicgOm7jem8oOWxnuacr+i/sOagkeadn+aIjeerluWiheW6tuaVsOa8sVwiXSxcbltcImNiNDBcIixcIuiWguiWg+iWhuiWiFwiLDYsXCLolpBcIiwxMCxcIuiWnVwiLDYsXCLolqXolqbolqfolqnolqvolqzolq3olrFcIiw1LFwi6Ja46Ja6XCIsNixcIuiXglwiLDYsXCLol4pcIiw0LFwi6JeR6JeSXCJdLFxuW1wiY2I4MFwiLFwi6JeU6JeWXCIsNSxcIuiXnVwiLDYsXCLol6Xol6bol6fol6jol6pcIiwxNCxcIuaBleWIt+iAjeaRlOihsOeUqeW4heagk+aLtOmcnOWPjOeIveiwgeawtOedoeeojuWQrueerOmhuuiInOivtOehleaclOeDgeaWr+aSleWYtuaAneengeWPuOS4neatu+iChuWvuuWXo+Wbm+S8uuS8vOmlsuW3s+advuiAuOaAgumigumAgeWui+iuvOivteaQnOiJmOaTnuWXveiLj+mFpeS/l+e0oOmAn+eyn+WDs+Whkea6r+Wuv+ivieiCg+mFuOiSnOeul+iZvemai+maj+e7pemrk+eijuWygeepl+mBgumap+eln+WtmeaNn+esi+iTkeaireWUhue8qeeQkOe0oumUgeaJgOWhjOS7luWug+WlueWhlFwiXSxcbltcImNjNDBcIixcIuiXueiXuuiXvOiXveiXvuiYgFwiLDQsXCLomIZcIiwxMCxcIuiYkuiYk+iYlOiYleiYl1wiLDE1LFwi6Jio6JiqXCIsMTMsXCLomLnomLromLvomL3omL7omL/omYBcIl0sXG5bXCJjYzgwXCIsXCLomYFcIiwxMSxcIuiZkuiZk+iZlVwiLDQsXCLomZvomZzomZ3omZ/omaDomaHomaNcIiw3LFwi542t5oye6LmL6LiP6IOO6IuU5oqs5Y+w5rOw6YWe5aSq5oCB5rGw5Z2N5pGK6LSq55ir5rup5Z2b5qqA55ew5r2t6LCt6LCI5Z2m5q+v6KKS56Kz5o6i5Y+554Kt5rGk5aGY5pCq5aCC5qOg6Iab5ZSQ57OW5YCY6Lq65reM6Laf54Or5o6P5rab5ruU57um6JCE5qGD6YCD5reY6Zm26K6o5aWX54m56Jek6IW+55a86KqK5qKv5YmU6Lii6ZSR5o+Q6aKY6LmE5ZW85L2T5pu/5ZqP5oOV5raV5YmD5bGJ5aSp5re75aGr55Sw55Sc5oGs6IiU6IWG5oyR5p2h6L+i55y66Lez6LS06ZOB5biW5Y6F5ZCs54ODXCJdLFxuW1wiY2Q0MFwiLFwi6Jmt6Jmv6Jmw6JmyXCIsNixcIuiag1wiLDYsXCLomo5cIiw0LFwi6JqU6JqWXCIsNSxcIuianlwiLDQsXCLomqXomqbomqvomq3omq7omrLomrPomrfomrjomrnomrtcIiw0LFwi6JuB6JuC6JuD6JuF6JuI6JuM6JuN6JuS6JuT6JuV6JuW6JuX6Jua6JucXCJdLFxuW1wiY2Q4MFwiLFwi6Jud6Jug6Juh6Jui6Juj6Jul6Jum6Jun6Juo6Juq6Jur6Jus6Juv6Ju16Ju26Ju36Ju66Ju76Ju86Ju96Ju/6JyB6JyE6JyF6JyG6JyL6JyM6JyO6JyP6JyQ6JyR6JyU6JyW5rGA5bu35YGc5Lqt5bqt5oy66ImH6YCa5qGQ6YWu556z5ZCM6ZOc5b2k56ul5qG25o2F562S57uf55eb5YG35oqV5aS06YCP5Ye456eD56qB5Zu+5b6S6YCU5raC5bGg5Zyf5ZCQ5YWU5rmN5Zui5o6o6aKT6IW/6JyV6KSq6YCA5ZCe5bGv6IeA5ouW5omY6ISx6bi16ZmA6amu6am85qSt5aal5ouT5ZS+5oyW5ZOH6JuZ5rS85aiD55Om6KKc5q2q5aSW6LGM5byv5rm+546p6aG95Li454O35a6M56KX5oy95pma55qW5oOL5a6b5amJ5LiH6IWV5rGq546L5Lqh5p6J572R5b6A5pe65pyb5b+Y5aaE5aiBXCJdLFxuW1wiY2U0MFwiLFwi6JyZ6Jyb6Jyd6Jyf6Jyg6Jyk6Jym6Jyn6Jyo6Jyq6Jyr6Jys6Jyt6Jyv6Jyw6Jyy6Jyz6Jy16Jy26Jy46Jy56Jy66Jy86Jy96J2AXCIsNixcIuidiuidi+idjeidj+idkOidkeidkuidlOidleidluidmOidmlwiLDUsXCLonaHonaLonaZcIiw3LFwi6J2v6J2x6J2y6J2z6J21XCJdLFxuW1wiY2U4MFwiLFwi6J236J246J256J266J2/6J6A6J6B6J6E6J6G6J6H6J6J6J6K6J6M6J6OXCIsNCxcIuielOieleieluiemFwiLDYsXCLonqBcIiw0LFwi5beN5b6u5Y2x6Z+m6L+d5qGF5Zu05ZSv5oOf5Li65r2N57u06IuH6JCO5aeU5Lyf5Lyq5bC+57qs5pyq6JSa5ZGz55WP6IOD5ZaC6a2P5L2N5rit6LCT5bCJ5oWw5Y2r55if5rip6JqK5paH6Ze757q55ZC756iz57SK6Zeu5Zeh57+B55Ou5oyd6JyX5rah56qd5oiR5pah5Y2n5o+h5rKD5ber5ZGc6ZKo5LmM5rGh6K+s5bGL5peg6Iqc5qKn5ZC+5ZC05q+L5q2m5LqU5o2C5Y2I6Iie5LyN5L6u5Z2e5oiK6Zu+5pmk54mp5Yu/5Yqh5oKf6K+v5piU54aZ5p6Q6KW/56GS55+95pmw5Zi75ZC46ZSh54m6XCJdLFxuW1wiY2Y0MFwiLFwi6J6l6J6m6J6n6J6p6J6q6J6u6J6w6J6x6J6y6J606J626J636J646J656J676J686J6+6J6/6J+BXCIsNCxcIuifh+ifiOifieifjFwiLDQsXCLon5RcIiw2LFwi6J+c6J+d6J+e6J+f6J+h6J+i6J+j6J+k6J+m6J+n6J+o6J+p6J+r6J+s6J+t6J+vXCIsOV0sXG5bXCJjZjgwXCIsXCLon7ron7von7zon73on7/ooIDooIHooILooIRcIiw1LFwi6KCLXCIsNyxcIuiglOigl+igmOigmeigmuignFwiLDQsXCLooKPnqIDmga/luIzmgonohp3lpJXmg5znhoTng6/muqrmsZDnioDmqoTooq3luK3kuaDlqrPllpzpk6PmtJfns7vpmpnmiI/nu4bnno7omb7ljKPpnJ7ovpbmmofls6HkvqDni63kuIvljqblpI/lkJPmjoDplKjlhYjku5npspznuqTlkrjotKTooZToiLfpl7Lmto7lvKblq4zmmL7pmannjrDnjK7ljr/ohbrppoXnvqHlrqrpmbfpmZDnur/nm7jljqLplbbpppnnrrHopYTmuZjkuaHnv5TnpaXor6bmg7Plk43kuqvpobnlt7fmqaHlg4/lkJHosaHokKfnoZ3pnITliYrlk67lmqPplIDmtojlrrXmt4bmmZNcIl0sXG5bXCJkMDQwXCIsXCLooKRcIiwxMyxcIuigs1wiLDUsXCLooLrooLvooL3ooL7ooL/ooYHooYLooYPooYZcIiw1LFwi6KGOXCIsNSxcIuihleihluihmOihmlwiLDYsXCLooabooafooarooa3ooa/oobHoobPoobToobXoobboobjoobnoobpcIl0sXG5bXCJkMDgwXCIsXCLoobvoobzoooDoooPooobooofooonooorooozooo7ooo/oopDoopHoopPoopToopXoopdcIiw0LFwi6KKdXCIsNCxcIuiio+iipVwiLDUsXCLlsI/lrZ3moKHogpbllbjnrJHmlYjmpZTkupvmrYfonY7pnovljY/mjJ/mkLrpgqrmlpzog4HosJDlhpnmorDljbjon7nmh4jms4Tms7vosKLlsZHolqroiq/plIzmrKPovpvmlrDlv7vlv4Pkv6HooYXmmJ/ohaXnjKnmg7rlhbTliJHlnovlvaLpgqLooYzphpLlubjmnY/mgKflp5PlhYTlh7bog7jljIjmsbnpm4TnhorkvJHkv67nvp7mnL3ll4XplIjnp4Doopbnu6Plop/miIzpnIDomZrlmJjpobvlvpDorrjok4TphZflj5nml63luo/nlZzmgaTnta7lqb/nu6rnu63ovanllqflrqPmgqzml4vnjoRcIl0sXG5bXCJkMTQwXCIsXCLooqzooq7ooq/oorDoorJcIiw0LFwi6KK46KK56KK66KK76KK96KK+6KK/6KOA6KOD6KOE6KOH6KOI6KOK6KOL6KOM6KON6KOP6KOQ6KOR6KOT6KOW6KOX6KOaXCIsNCxcIuijoOijoeijpuijp+ijqVwiLDYsXCLoo7Loo7Xoo7boo7foo7roo7voo73oo7/opIDopIHopINcIiw1XSxcbltcImQxODBcIixcIuikieiki1wiLDQsXCLopJHopJRcIiw0LFwi6KScXCIsNCxcIuikouiko+ikpOikpuikp+ikqOikqeikrOikreikruikr+ikseiksuiks+ikteikt+mAieeZo+ecqee7mumdtOiWm+WtpueptOmbquihgOWLi+eGj+W+quaXrOivouWvu+mpr+W3oeauieaxm+iureiur+mAiui/heWOi+aKvOm4pum4reWRgOS4q+iKveeJmeianOW0luihmea2r+mbheWTkeS6muiutueEieWSvemYieeDn+a3ueebkOS4peeglOickuWyqeW7tuiogOminOmYjueCjuayv+WlhOaOqeecvOihjea8lOiJs+WgsOeHleWOjOegmumbgeWUgeW9pueEsOWutOiwmumqjOaug+Wkrum4r+enp+adqOaJrOS9r+eWoee+iua0i+mYs+awp+S7sOeXkuWFu+agt+a8vumCgOiFsOWmlueRtlwiXSxcbltcImQyNDBcIixcIuikuFwiLDgsXCLopYLopYPopYVcIiwyNCxcIuiloFwiLDUsXCLopadcIiwxOSxcIuilvFwiXSxcbltcImQyODBcIixcIuilveilvuimgOimguimhOimheimh1wiLDI2LFwi5pGH5bCn6YGl56qR6LCj5aea5ZKs6IiA6I2v6KaB6ICA5qSw5ZmO6IC254i36YeO5Ya25Lmf6aG15o6W5Lia5Y+25puz6IWL5aSc5ray5LiA5aO55Yy75o+W6ZOx5L6d5LyK6KGj6aKQ5aS36YGX56e75Luq6IOw55aR5rKC5a6c5aeo5b2d5qSF6JqB5YCa5bey5LmZ55+j5Lul6Im65oqR5piT6YKR5bG55Lq/5b256IeG6YC46IKE55ar5Lqm6KOU5oSP5q+F5b+G5LmJ55uK5rqi6K+j6K6u6LCK6K+R5byC57+857+M57uO6Iy16I2r5Zug5q636Z+z6Zi05ae75ZCf6ZO25rer5a+F6aWu5bC55byV6ZqQXCJdLFxuW1wiZDM0MFwiLFwi6KaiXCIsMzAsXCLop4Pop43op5Pop5Top5Xop5fop5jop5nop5vop53op5/op6Dop6Hop6Lop6Top6fop6jop6nop6rop6zop63op67op7Dop7Hop7Lop7RcIiw2XSxcbltcImQzODBcIixcIuinu1wiLDQsXCLoqIFcIiw1LFwi6KiIXCIsMjEsXCLljbDoi7HmqLHlqbTpubDlupTnvKjojrnokKTokKXojafonYfov47otaLnm4jlvbHpopbnoazmmKDlk5/mi6XkvaPoh4Pnl4jlurjpm43ouIrom7nlko/ms7PmtozmsLjmgb/li4fnlKjlub3kvJjmgqDlv6flsKTnlLHpgq7pk4DnirnmsrnmuLjphYnmnInlj4vlj7PkvZHph4nor7Hlj4jlubzov4Lmt6Tkuo7nm4LmpobomZ7mhJroiIbkvZnkv57pgL7psbzmhInmuJ3muJTpmoXkuojlqLHpm6jkuI7lsb/nprnlrofor63nvr3njonln5/oiovpg4HlkIHpgYfllrvls6rlvqHmhIjmrLLni7HogrLoqolcIl0sXG5bXCJkNDQwXCIsXCLoqJ5cIiwzMSxcIuiov1wiLDgsXCLoqYlcIiwyMV0sXG5bXCJkNDgwXCIsXCLoqZ9cIiwyNSxcIuipulwiLDYsXCLmtbTlr5Poo5XpooTosavpqa3puLPmuIrlhqTlhYPlnqPoooHljp/mj7TovpXlm63lkZjlnIbnjL/mupDnvJjov5zoi5HmhL/mgKjpmaLmm7Dnuqbotorot4PpkqXlsrPnsqTmnIjmgqbpmIXogJjkupHpg6fljIDpmajlhYHov5DolbTphZ3mmZXpn7XlrZXljJ3noLjmnYLmoL3lk4nngb7lrrDovb3lho3lnKjlkrHmlJLmmoLotZ7otYPohI/okazpga3ns5/lh7/ol7vmnqPml6nmvqHomqTouoHlmarpgKDnmoLngbbnh6XotKPmi6nliJnms73otLzmgI7lop7mho7mm77otaDmiY7llrPmuKPmnK3ovadcIl0sXG5bXCJkNTQwXCIsXCLoqoFcIiw3LFwi6KqLXCIsNyxcIuiqlFwiLDQ2XSxcbltcImQ1ODBcIixcIuirg1wiLDMyLFwi6ZOh6Ze455yo5qCF5qao5ZKL5LmN54K46K+I5pGY5paL5a6F56qE5YC65a+o55675q+h6Km557KY5rK+55uP5pap6L6X5bSt5bGV6Ji45qCI5Y2g5oiY56uZ5rmb57u95qif56ug5b2w5ryz5byg5o6M5rao5p2W5LiI5biQ6LSm5LuX6IOA55i06Zqc5oub5pit5om+5rK86LW154Wn572p5YWG6IKH5Y+s6YGu5oqY5ZOy6Juw6L6Z6ICF6ZSX6JSX6L+Z5rWZ54+N5paf55yf55SE56Cn6Ie76LSe6ZKI5L6m5p6V55a56K+K6ZyH5oyv6ZWH6Zi16JK45oyj552B5b6B54uw5LqJ5oCU5pW05ouv5q2j5pS/XCJdLFxuW1wiZDY0MFwiLFwi6KukXCIsMzQsXCLorIhcIiwyN10sXG5bXCJkNjgwXCIsXCLorKTorKXorKdcIiwzMCxcIuW4p+eXh+mDkeivgeiKneaeneaUr+WQseicmOefpeiCouiEguaxgeS5i+e7h+iBjOebtOakjeauluaJp+WAvOS+hOWdgOaMh+atoui2vuWPquaXqOe6uOW/l+aMmuaOt+iHs+iHtOe9ruW4nOWzmeWItuaZuuenqeeomui0qOeCmeeXlOa7nuayu+eqkuS4reebheW/oOmSn+iht+e7iOenjeiCv+mHjeS7suS8l+iIn+WRqOW3nua0suivjOeypei9tOiCmOW4muWSkueaseWumeaYvOmqpOePoOagquibm+acseeMquivuOivm+mAkOerueeDm+eFruaLhOeeqeWYseS4u+iRl+afseWKqeibgOi0rumTuOetkVwiXSxcbltcImQ3NDBcIixcIuithlwiLDMxLFwi6K2nXCIsNCxcIuitrVwiLDI1XSxcbltcImQ3ODBcIixcIuiuh1wiLDI0LFwi6K6s6K6x6K676K+H6K+Q6K+q6LCJ6LCe5L2P5rOo56Wd6am75oqT54iq5ou95LiT56CW6L2s5pKw6LWa56+G5qGp5bqE6KOF5aaG5pKe5aOu54q25qSO6ZSl6L+96LWY5Z2g57yA6LCG5YeG5o2J5ouZ5Y2T5qGM55Ci6IyB6YWM5ZWE552A54G85rWK5YW55ZKo6LWE5ae/5ruL5reE5a2c57Sr5LuU57G95ruT5a2Q6Ieq5riN5a2X6ayD5qOV6Liq5a6X57u85oC757q16YK56LWw5aWP5o+N56ef6Laz5Y2S5peP56WW6K+F6Zi757uE6ZK757qC5Zi06YaJ5pyA572q5bCK6YG15pio5bem5L2Q5p+e5YGa5L2c5Z2Q5bqnXCJdLFxuW1wiZDg0MFwiLFwi6LC4XCIsOCxcIuixguixg+ixhOixheixiOixiuixi+ixjVwiLDcsXCLosZbosZfosZjosZnosZtcIiw1LFwi6LGjXCIsNixcIuixrFwiLDYsXCLosbTosbXosbbosbfosbtcIiw2LFwi6LKD6LKE6LKG6LKHXCJdLFxuW1wiZDg4MFwiLFwi6LKI6LKL6LKNXCIsNixcIuiyleiyluiyl+iymVwiLDIwLFwi5LqN5LiM5YWA5LiQ5bu/5Y2F5LiV5LqY5Lie6ayy5a2s5Zmp5Lio56a65Li/5YyV5LmH5aSt54i75Y2u5rCQ5Zuf6IOk6aaX5q+T552+6byX5Li25Lqf6byQ5Lmc5Lmp5LqT6IqI5a2b5ZWs5ZiP5LuE5Y6N5Y6d5Y6j5Y6l5Y6u6Z2l6LWd5Yya5Y+15Yym5Yyu5Yy+6LWc5Y2m5Y2j5YiC5YiI5YiO5Yit5Yiz5Yi/5YmA5YmM5Yme5Ymh5Ymc6JKv5Ym95YqC5YqB5YqQ5YqT5YaC572U5Lq75LuD5LuJ5LuC5Luo5Luh5Lur5Lue5Lyb5Luz5Lyi5L2k5Lu15Lyl5Lyn5LyJ5Lyr5L2e5L2n5pS45L2a5L2dXCJdLFxuW1wiZDk0MFwiLFwi6LKuXCIsNjJdLFxuW1wiZDk4MFwiLFwi6LOtXCIsMzIsXCLkvZ/kvZfkvLLkvL3kvbbkvbTkvpHkvonkvoPkvo/kvb7kvbvkvqrkvbzkvqzkvpTkv6bkv6jkv6rkv4Xkv5rkv6Pkv5zkv5Hkv5/kv7jlgKnlgYzkv7PlgKzlgI/lgK7lgK3kv77lgJzlgIzlgKXlgKjlgb7lgYPlgZXlgYjlgY7lgazlgbvlgqXlgqflgqnlgrrlg5blhIblg63lg6zlg6blg67lhIflhIvku53msL3kvZjkvaXkv47pvqDmsYbnsbTlha7lt73pu4npppjlhoHlpJTli7nljI3oqIfljJDlh6vlpJnlhZXkuqDlhZbkurPooa7ooqTkurXohJToo5LnpoDlrLTooIPnvrjlhqvlhrHlhr3lhrxcIl0sXG5bXCJkYTQwXCIsXCLotI5cIiwxNCxcIui0oOi1kei1kui1l+i1n+i1pei1qOi1qei1qui1rOi1rui1r+i1sei1sui1uFwiLDgsXCLotoLotoPotobotofotojotonotoxcIiw0LFwi6LaS6LaT6LaVXCIsOSxcIui2oOi2oVwiXSxcbltcImRhODBcIixcIui2oui2pFwiLDEyLFwi6Lay6La26La36La56La76La96LeA6LeB6LeC6LeF6LeH6LeI6LeJ6LeK6LeN6LeQ6LeS6LeT6LeU5YeH5YaW5Yai5Yal6K6g6K6m6K6n6K6q6K606K616K636K+C6K+D6K+L6K+P6K+O6K+S6K+T6K+U6K+W6K+Y6K+Z6K+c6K+f6K+g6K+k6K+o6K+p6K+u6K+w6K+z6K+26K+56K+86K+/6LCA6LCC6LCE6LCH6LCM6LCP6LCR6LCS6LCU6LCV6LCW6LCZ6LCb6LCY6LCd6LCf6LCg6LCh6LCl6LCn6LCq6LCr6LCu6LCv6LCy6LCz6LC16LC25Y2p5Y266Zid6Zii6Zih6Zix6Ziq6Zi96Zi86ZmC6ZmJ6ZmU6Zmf6Zmn6Zms6Zmy6Zm06ZqI6ZqN6ZqX6Zqw6YKX6YKb6YKd6YKZ6YKs6YKh6YK06YKz6YK26YK6XCJdLFxuW1wiZGI0MFwiLFwi6LeV6LeY6LeZ6Lec6Leg6Leh6Lei6Lel6Lem6Len6Lep6Let6Leu6Lew6Lex6Ley6Le06Le26Le86Le+XCIsNixcIui4hui4h+i4iOi4i+i4jei4jui4kOi4kei4kui4k+i4lVwiLDcsXCLouKDouKHouKRcIiw0LFwi6Lir6Lit6Liw6Liy6Liz6Li06Li26Li36Li46Li76Li86Li+XCJdLFxuW1wiZGI4MFwiLFwi6Li/6LmD6LmF6LmG6LmMXCIsNCxcIui5k1wiLDUsXCLouZpcIiwxMSxcIui5p+i5qOi5qui5q+i5rui5semCuOmCsOmDj+mDhemCvumDkOmDhOmDh+mDk+mDpumDoumDnOmDl+mDm+mDq+mDr+mDvumEhOmEoumEnumEo+mEsemEr+mEuemFg+mFhuWIjeWlguWKouWKrOWKreWKvuWTv+WLkOWLluWLsOWPn+eHruefjeW7tOWHteWHvOmsr+WOtuW8geeVmuW3r+WdjOWeqeWeoeWhvuWivOWjheWjkeWcqeWcrOWcquWcs+WcueWcruWcr+WdnOWcu+WdguWdqeWeheWdq+WehuWdvOWdu+WdqOWdreWdtuWds+WereWepOWejOWesuWfj+Wep+WetOWek+WeoOWfleWfmOWfmuWfmeWfkuWeuOWftOWfr+WfuOWfpOWfnVwiXSxcbltcImRjNDBcIixcIui5s+i5tei5t1wiLDQsXCLoub3oub7ouoDouoLouoPouoTouobouohcIiw2LFwi6LqR6LqS6LqT6LqVXCIsNixcIui6nei6n1wiLDExLFwi6Lqt6Lqu6Lqw6Lqx6LqzXCIsNixcIui6u1wiLDddLFxuW1wiZGM4MFwiLFwi6LuDXCIsMTAsXCLou49cIiwyMSxcIuWgi+WgjeWfveWfreWggOWgnuWgmeWhhOWgoOWhpeWhrOWigeWiieWimuWigOmmqOm8meaHv+iJueiJveiJv+iKj+iKiuiKqOiKhOiKjuiKkeiKl+iKmeiKq+iKuOiKvuiKsOiLiOiLiuiLo+iKmOiKt+iKruiLi+iLjOiLgeiKqeiKtOiKoeiKquiKn+iLhOiLjuiKpOiLoeiMieiLt+iLpOiMj+iMh+iLnOiLtOiLkuiLmOiMjOiLu+iLk+iMkeiMmuiMhuiMlOiMleiLoOiLleiMnOiNkeiNm+iNnOiMiOiOkuiMvOiMtOiMseiOm+iNnuiMr+iNj+iNh+iNg+iNn+iNgOiMl+iNoOiMreiMuuiMs+iNpuiNpVwiXSxcbltcImRkNDBcIixcIui7pVwiLDYyXSxcbltcImRkODBcIixcIui8pFwiLDMyLFwi6I2o6Iyb6I2p6I2s6I2q6I2t6I2u6I6w6I246I6z6I606I6g6I6q6I6T6I6c6I6F6I286I626I6p6I296I646I276I6Y6I6e6I6o6I666I686I+B6JCB6I+l6I+Y5aCH6JCY6JCL6I+d6I+96I+W6JCc6JC46JCR6JCG6I+U6I+f6JCP6JCD6I+46I+56I+q6I+F6I+A6JCm6I+w6I+h6JGc6JGR6JGa6JGZ6JGz6JKH6JKI6JG66JKJ6JG46JC86JGG6JGp6JG26JKM6JKO6JCx6JGt6JOB6JON6JOQ6JOm6JK96JOT6JOK6JK/6JK66JOg6JKh6JK56JK06JKX6JOl6JOj6JSM55SN6JS46JOw6JS56JSf6JS6XCJdLFxuW1wiZGU0MFwiLFwi6L2FXCIsMzIsXCLovarovoDovozovpLovp3ovqDovqHovqLovqTovqXovqbovqfovqrovqzovq3ovq7ovq/ovrLovrPovrTovrXovrfovrjovrrovrvovrzovr/ov4Dov4Pov4ZcIl0sXG5bXCJkZTgwXCIsXCLov4lcIiw0LFwi6L+P6L+S6L+W6L+X6L+a6L+g6L+h6L+j6L+n6L+s6L+v6L+x6L+y6L+06L+16L+26L+66L+76L+86L++6L+/6YCH6YCI6YCM6YCO6YCT6YCV6YCY6JWW6JS76JO/6JO86JWZ6JWI6JWo6JWk6JWe6JW6556i6JWD6JWy6JW76Jak6Jao6JaH6JaP6JW56Jau6Jac6JaF6Ja56Ja36Jaw6JeT6JeB6Jec6Je/6Jin6JiF6Jip6JiW6Ji85bu+5byI5aS85aWB6IC35aWV5aWa5aWY5YyP5bCi5bCl5bCs5bC05omM5omq5oqf5oq75ouK5oua5ouX5ouu5oyi5ou25oy55o2L5o2D5o6t5o+25o2x5o265o6O5o605o2t5o6s5o6K5o2p5o6u5o685o+y5o+45o+g5o+/5o+E5o+e5o+O5pGS5o+G5o6+5pGF5pGB5pCL5pCb5pCg5pCM5pCm5pCh5pGe5pKE5pGt5pKWXCJdLFxuW1wiZGY0MFwiLFwi6YCZ6YCc6YCj6YCk6YCl6YCnXCIsNSxcIumAsFwiLDQsXCLpgLfpgLnpgLrpgL3pgL/pgYDpgYPpgYXpgYbpgYhcIiw0LFwi6YGO6YGU6YGV6YGW6YGZ6YGa6YGcXCIsNSxcIumBpOmBpumBp+mBqemBqumBq+mBrOmBr1wiLDQsXCLpgbZcIiw2LFwi6YG+6YKBXCJdLFxuW1wiZGY4MFwiLFwi6YKE6YKF6YKG6YKH6YKJ6YKK6YKMXCIsNCxcIumCkumClOmClumCmOmCmumCnOmCnumCn+mCoOmCpOmCpemCp+mCqOmCqemCq+mCremCsumCt+mCvOmCvemCv+mDgOaRuuaSt+aSuOaSmeaSuuaTgOaTkOaTl+aTpOaTouaUieaUpeaUruW8i+W/kueUmeW8keWNn+WPseWPveWPqeWPqOWPu+WQkuWQluWQhuWRi+WRkuWRk+WRlOWRluWRg+WQoeWRl+WRmeWQo+WQsuWSguWSlOWRt+WRseWRpOWSmuWSm+WShOWRtuWRpuWSneWTkOWSreWTguWStOWTkuWSp+WSpuWTk+WTlOWRsuWSo+WTleWSu+WSv+WTjOWTmeWTmuWTnOWSqeWSquWSpOWTneWTj+WTnuWUm+WTp+WUoOWTveWUlOWTs+WUouWUo+WUj+WUkeWUp+WUquWVp+WWj+WWteWVieWVreWVgeWVleWUv+WVkOWUvFwiXSxcbltcImUwNDBcIixcIumDgumDg+mDhumDiOmDiemDi+mDjOmDjemDkumDlOmDlemDlumDmOmDmemDmumDnumDn+mDoOmDo+mDpOmDpemDqemDqumDrOmDrumDsOmDsemDsumDs+mDtemDtumDt+mDuemDuumDu+mDvOmDv+mEgOmEgemEg+mEhVwiLDE5LFwi6YSa6YSb6YScXCJdLFxuW1wiZTA4MFwiLFwi6YSd6YSf6YSg6YSh6YSkXCIsMTAsXCLphLDphLJcIiw2LFwi6YS6XCIsOCxcIumFhOWUt+WVluWVteWVtuWVt+WUs+WUsOWVnOWWi+WXkuWWg+WWseWWueWWiOWWgeWWn+WVvuWXluWWkeWVu+WXn+WWveWWvuWWlOWWmeWXquWXt+WXieWYn+WXkeWXq+WXrOWXlOWXpuWXneWXhOWXr+WXpeWXsuWXs+WXjOWXjeWXqOWXteWXpOi+lOWYnuWYiOWYjOWYgeWYpOWYo+WXvuWYgOWYp+WYreWZmOWYueWZl+WYrOWZjeWZouWZmeWZnOWZjOWZlOWahuWZpOWZseWZq+WZu+WZvOWaheWak+War+WblOWbl+WbneWboeWbteWbq+WbueWbv+WchOWciuWcieWcnOW4j+W4meW4lOW4keW4seW4u+W4vFwiXSxcbltcImUxNDBcIixcIumFhemFh+mFiOmFkemFk+mFlOmFlemFlumFmOmFmemFm+mFnOmFn+mFoOmFpumFp+mFqOmFq+mFremFs+mFuumFu+mFvOmGgFwiLDQsXCLphobphojphorpho7pho/phpNcIiw2LFwi6YacXCIsNSxcIumGpFwiLDUsXCLphqvphqzphrDphrHphrLphrPphrbphrfphrjphrnphrtcIl0sXG5bXCJlMTgwXCIsXCLphrxcIiwxMCxcIumHiOmHi+mHkOmHklwiLDksXCLph51cIiw4LFwi5bi35bmE5bmU5bmb5bme5bmh5bKM5bG65bKN5bKQ5bKW5bKI5bKY5bKZ5bKR5bKa5bKc5bK15bKi5bK95bKs5bKr5bKx5bKj5bOB5bK35bOE5bOS5bOk5bOL5bOl5bSC5bSD5bSn5bSm5bSu5bSk5bSe5bSG5bSb5bWY5bS+5bS05bS95bWs5bWb5bWv5bWd5bWr5bWL5bWK5bWp5bW05baC5baZ5bad6LGz5ba35beF5b2z5b235b6C5b6H5b6J5b6M5b6V5b6Z5b6c5b6o5b6t5b615b686KGi5b2h54qt54qw54q054q354q454uD54uB54uO54uN54uS54uo54uv54up54uy54u054u354yB54uz54yD54u6XCJdLFxuW1wiZTI0MFwiLFwi6YemXCIsNjJdLFxuW1wiZTI4MFwiLFwi6YilXCIsMzIsXCLni7vnjJfnjJPnjKHnjIrnjJ7njJ3njJXnjKLnjLnnjKXnjKznjLjnjLHnjZDnjY3njZfnjaDnjaznja/njb7oiJvlpKXpo6flpKTlpILppaPppadcIiw1LFwi6aW06aW36aW96aaA6aaE6aaH6aaK6aaN6aaQ6aaR6aaT6aaU6aaV5bqA5bqR5bqL5bqW5bql5bqg5bq55bq15bq+5bqz6LWT5buS5buR5bub5buo5buq6Ia65b+E5b+J5b+W5b+P5oCD5b+u5oCE5b+h5b+k5b++5oCF5oCG5b+q5b+t5b+45oCZ5oC15oCm5oCb5oCP5oCN5oCp5oCr5oCK5oC/5oCh5oG45oG55oG75oG65oGCXCJdLFxuW1wiZTM0MFwiLFwi6YmGXCIsNDUsXCLpibVcIiwxNl0sXG5bXCJlMzgwXCIsXCLpioZcIiw3LFwi6YqPXCIsMjQsXCLmgarmgb3mgpbmgprmgq3mgp3mgoPmgpLmgozmgpvmg6zmgrvmgrHmg53mg5jmg4bmg5rmgrTmhKDmhKbmhJXmhKPmg7TmhIDmhI7mhKvmhYrmhbXmhqzmhpTmhqfmhrfmh5Tmh7Xlv53pmrPpl6npl6vpl7Hpl7Ppl7Xpl7bpl7zpl77pmIPpmITpmIbpmIjpmIrpmIvpmIzpmI3pmI/pmJLpmJXpmJbpmJfpmJnpmJrkuKzniL/miJXmsLXmsZTmsZzmsYrmsqPmsoXmspDmspTmsozmsajmsanmsbTmsbbmsobmsqnms5Dms5Tmsq3ms7fms7jms7Hms5fmsrLms6Dms5bms7rms6vms67msrHms5Pms6/ms75cIl0sXG5bXCJlNDQwXCIsXCLpiqhcIiw1LFwi6YqvXCIsMjQsXCLpi4lcIiwzMV0sXG5bXCJlNDgwXCIsXCLpi6lcIiwzMixcIua0uea0p+a0jOa1g+a1iOa0h+a0hOa0mea0jua0q+a1jea0rua0tea0mua1j+a1kua1lOa0s+a2kea1r+a2nua2oOa1nua2k+a2lOa1nOa1oOa1vOa1o+a4mua3h+a3hea3nua4jua2v+a3oOa4kea3pua3nea3mea4lua2q+a4jOa2rua4q+a5rua5jua5q+a6sua5n+a6hua5k+a5lOa4sua4pea5hOa7n+a6sea6mOa7oOa8rea7oua6pea6p+a6vea6u+a6t+a7l+a6tOa7j+a6j+a7gua6n+a9oua9hua9h+a8pOa8lea7uea8r+a8tua9i+a9tOa8qua8iea8qea+iea+jea+jOa9uOa9sua9vOa9uua/kVwiXSxcbltcImU1NDBcIixcIumMilwiLDUxLFwi6Yy/XCIsMTBdLFxuW1wiZTU4MFwiLFwi6Y2KXCIsMzEsXCLpjavmv4nmvqfmvrnmvrbmv4Lmv6Hmv67mv57mv6Dmv6/ngJrngKPngJvngLnngLXngY/ngZ7lroDlroTlrpXlrpPlrqXlrrjnlK/pqp7mkLTlr6Tlr67opLDlr7DouYforIfovrbov5Pov5Xov6Xov67ov6Tov6nov6bov7Pov6jpgIXpgITpgIvpgKbpgJHpgI3pgJbpgKHpgLXpgLbpgK3pgK/pgYTpgZHpgZLpgZDpgajpgZjpgaLpgZvmmrnpgbTpgb3pgoLpgojpgoPpgovlvZDlvZflvZblvZjlsLvlkqvlsZDlsZnlrbHlsaPlsabnvrzlvKrlvKnlvK3oibTlvLzprLvlsa7lpoHlpoPlpo3lpqnlpqrlpqNcIl0sXG5bXCJlNjQwXCIsXCLpjaxcIiwzNCxcIumOkFwiLDI3XSxcbltcImU2ODBcIixcIumOrFwiLDI5LFwi6Y+L6Y+M6Y+N5aaX5aeK5aar5aae5aak5aeS5aay5aav5aeX5aa+5aiF5aiG5aed5aiI5aej5aeY5ae55aiM5aiJ5aiy5ai05aiR5aij5aiT5amA5amn5amK5amV5ai85ami5am16IOs5aqq5aqb5am35am65aq+5aur5aqy5auS5auU5aq45aug5auj5aux5auW5aum5auY5auc5ayJ5ayX5ayW5ayy5ay35a2A5bCV5bCc5a2a5a2l5a2z5a2R5a2T5a2i6am16am36am46am66am/6am96aqA6aqB6aqF6aqI6aqK6aqQ6aqS6aqT6aqW6aqY6aqb6aqc6aqd6aqf6aqg6aqi6aqj6aql6aqn57qf57qh57qj57ql57qo57qpXCJdLFxuW1wiZTc0MFwiLFwi6Y+OXCIsNyxcIumPl1wiLDU0XSxcbltcImU3ODBcIixcIumQjlwiLDMyLFwi57qt57qw57q+57uA57uB57uC57uJ57uL57uM57uQ57uU57uX57ub57ug57uh57uo57ur57uu57uv57ux57uy57yN57u257u657u757u+57yB57yC57yD57yH57yI57yL57yM57yP57yR57yS57yX57yZ57yc57yb57yf57yhXCIsNixcIue8que8q+e8rOe8ree8r1wiLDQsXCLnvLXlubrnlb/lt5vnlL7pgpXnjo7njpHnjq7njqLnjp/nj4/nj4Lnj5HnjrfnjrPnj4Dnj4nnj4jnj6Xnj5npobznkIrnj6nnj6fnj57njrrnj7LnkI/nkKrnkZvnkKbnkKXnkKjnkLDnkK7nkKxcIl0sXG5bXCJlODQwXCIsXCLpkK9cIiwxNCxcIumQv1wiLDQzLFwi6ZGs6ZGt6ZGu6ZGvXCJdLFxuW1wiZTg4MFwiLFwi6ZGwXCIsMjAsXCLpkpHpkpbpkpjpk4fpk4/pk5Ppk5Tpk5rpk6bpk7vplJzplKDnkJvnkJrnkYHnkZznkZfnkZXnkZnnkbfnka3nkb7nkpznko7nkoDnkoHnkofnkovnkp7nkqjnkqnnkpDnkqfnk5Lnkrrpn6rpn6vpn6zmnYzmnZPmnZ7mnYjmnanmnqXmnofmnarmnbPmnpjmnqfmnbXmnqjmnp7mnq3mnovmnbfmnbzmn7DmoInmn5jmoIrmn6nmnrDmoIzmn5nmnrXmn5rmnrPmn53moIDmn4Pmnrjmn6LmoI7mn4Hmn73moLLmoLPmoaDmoaHmoY7moaLmoYTmoaTmooPmoJ3moZXmoabmoYHmoafmoYDmoL7moYrmoYnmoKnmorXmoo/mobTmobfmopPmoavmo4Lmpa7mo7zmpJ/mpKDmo7lcIl0sXG5bXCJlOTQwXCIsXCLplKfplLPplL3plYPplYjplYvplZXplZrplaDpla7plbTplbXplbdcIiw3LFwi6ZaAXCIsNDJdLFxuW1wiZTk4MFwiLFwi6ZarXCIsMzIsXCLmpKTmo7DmpIvmpIHmpZfmo6PmpJDmpbHmpLnmpaDmpYLmpZ3mpoTmpavmpoDmppjmpbjmpLTmp4zmpofmpojmp47mponmpabmpaPmpbnmppvmpqfmprvmpqvmpq3mp5TmprHmp4Hmp4rmp5/mppXmp6Dmpo3mp7/mqK/mp63mqJfmqJjmqaXmp7LmqYTmqL7mqqDmqZDmqZvmqLXmqo7mqbnmqL3mqKjmqZjmqbzmqpHmqpDmqqnmqpfmqqvnjLfnjZLmroHmroLmrofmroTmrpLmrpPmro3mrprmrpvmrqHmrqrovavova3ovbHovbLovbPovbXovbbovbjovbfovbnovbrovbzovb7ovoHovoLovoTovofovotcIl0sXG5bXCJlYTQwXCIsXCLpl4xcIiwyNyxcIumXrOmXv+mYh+mYk+mYmOmYm+mYnumYoOmYo1wiLDYsXCLpmKvpmKzpmK3pmK/pmLDpmLfpmLjpmLnpmLrpmL7pmYHpmYPpmYrpmY7pmY/pmZHpmZLpmZPpmZbpmZdcIl0sXG5bXCJlYTgwXCIsXCLpmZjpmZnpmZrpmZzpmZ3pmZ7pmaDpmaPpmaXpmabpmavpma1cIiw0LFwi6Zmz6Zm4XCIsMTIsXCLpmofpmonpmorovo3ovo7ovo/ovpjovprou47miIvmiJfmiJvmiJ/miKLmiKHmiKXmiKTmiKzoh6fnk6/nk7Tnk7/nlI/nlJHnlJPmlLTml67ml6/ml7DmmIrmmJnmnbLmmIPmmJXmmIDngoXmm7fmmJ3mmLTmmLHmmLbmmLXogIbmmZ/mmZTmmYHmmY/mmZbmmaHmmZfmmbfmmoTmmozmmqfmmp3mmr7mm5vmm5zmm6bmm6notLLotLPotLbotLvotL3otYDotYXotYbotYjotYnotYfotY3otZXotZnop4fop4rop4vop4zop47op4/op5Dop5Hnia7nip/niZ3niabnia/nib7nib/nioTniovnio3nio/nipLmjIjmjLLmjrBcIl0sXG5bXCJlYjQwXCIsXCLpmozpmo7pmpHpmpLpmpPpmpXpmpbpmprpmpvpmp1cIiw5LFwi6ZqoXCIsNyxcIumasemasumatOmatemat+mauOmauumau+mav+mbgumbg+mbiOmbiumbi+mbkOmbkembk+mblOmbllwiLDksXCLpm6FcIiw2LFwi6ZurXCJdLFxuW1wiZWI4MFwiLFwi6Zus6Zut6Zuu6Zuw6Zux6Zuy6Zu06Zu16Zu46Zu66Zu76Zu86Zu96Zu/6ZyC6ZyD6ZyF6ZyK6ZyL6ZyM6ZyQ6ZyR6ZyS6ZyU6ZyV6ZyXXCIsNCxcIumcnemcn+mcoOaQv+aTmOiAhOavquavs+avveavteavueawheawh+awhuawjeawleawmOawmeawmuawoeawqeawpOawquawsuaUteaVleaVq+eJjeeJkueJlueIsOiZouWIluiCn+iCnOiCk+iCvOaciuiCveiCseiCq+iCreiCtOiCt+iDp+iDqOiDqeiDquiDm+iDguiDhOiDmeiDjeiDl+ackOiDneiDq+iDseiDtOiDreiEjeiEjuiDsuiDvOacleiEkuixmuiEtuiEnuiErOiEmOiEsuiFiOiFjOiFk+iFtOiFmeiFmuiFseiFoOiFqeiFvOiFveiFreiFp+WhjeWqteiGiOiGguiGkea7leiGo+iGquiHjOacpuiHiuiGu1wiXSxcbltcImVjNDBcIixcIumcoVwiLDgsXCLpnKvpnKzpnK7pnK/pnLHpnLNcIiw0LFwi6Zy66Zy76Zy86Zy96Zy/XCIsMTgsXCLpnZTpnZXpnZfpnZjpnZrpnZzpnZ3pnZ/pnaPpnaTpnabpnafpnajpnapcIiw3XSxcbltcImVjODBcIixcIumdsumdtemdt1wiLDQsXCLpnb1cIiw3LFwi6Z6GXCIsNCxcIumejOmejumej+mekOmek+melemelumel+memVwiLDQsXCLoh4HohqbmrKTmrLfmrLnmrYPmrYbmrZnpo5Hpo5Lpo5Ppo5Xpo5npo5rmrrPlvYDmr4Lop7PmlpDpvZHmlpPmlrzml4bml4Tml4Pml4zml47ml5Lml5bngoDngpzngpbngp3ngrvng4DngrfngqvngrHng6jng4rnhJDnhJPnhJbnhK/nhLHnhbPnhZznhajnhYXnhbLnhYrnhbjnhbrnhpjnhrPnhrXnhqjnhqDnh6Dnh5Tnh6fnh7nniJ3niKjngaznhJjnhabnhrnmiL7miL3miYPmiYjmiYnnpLvnpYDnpYbnpYnnpZvnpZznpZPnpZrnpaLnpZfnpaDnpa/npafnpbrnpoXnpornpprnpqfnprPlv5Hlv5BcIl0sXG5bXCJlZDQwXCIsXCLpnp7pnp/pnqHpnqLpnqRcIiw2LFwi6Z6s6Z6u6Z6w6Z6x6Z6z6Z61XCIsNDZdLFxuW1wiZWQ4MFwiLFwi6Z+k6Z+l6Z+o6Z+uXCIsNCxcIumftOmft1wiLDIzLFwi5oC85oGd5oGa5oGn5oGB5oGZ5oGj5oKr5oSG5oSN5oWd5oap5oad5oeL5oeR5oiG6IKA6IG/5rKT5rO25re855+255+456CA56CJ56CX56CY56CR5par56Ct56Cc56Cd56C556C656C756Cf56C856Cl56Cs56Cj56Cp56GO56Gt56GW56GX56Cm56GQ56GH56GM56Gq56Kb56KT56Ka56KH56Kc56Kh56Kj56Ky56K556Kl56OU56OZ56OJ56Os56Oy56SF56O056ST56Sk56Se56S06b6b6bu56bu76bu855ux55yE55yN55u555yH55yI55ya55yi55yZ55yt55ym55y155y4552Q552R552H552D552a552oXCJdLFxuW1wiZWU0MFwiLFwi6aCPXCIsNjJdLFxuW1wiZWU4MFwiLFwi6aGOXCIsMzIsXCLnnaLnnaXnnb/nno3nnb3nnoDnnoznnpHnnp/nnqDnnrDnnrXnnr3nlLrnlYDnlY7nlYvnlYjnlZvnlbLnlbnnloPnvZjnvaHnvZ/oqYjnvajnvbTnvbHnvbnnvoHnvb7nm43nm6XooLLpkoXpkobpkofpkovpkorpkozpko3pko/pkpDpkpTpkpfpkpXpkprpkpvpkpzpkqPpkqTpkqvpkqrpkq3pkqzpkq/pkrDpkrLpkrTpkrZcIiw0LFwi6ZK86ZK96ZK/6ZOE6ZOIXCIsNixcIumTkOmTkemTkumTlemTlumTl+mTmemTmOmTm+mTnumTn+mToOmToumTpOmTpemTp+mTqOmTqlwiXSxcbltcImVmNDBcIixcIumhr1wiLDUsXCLpoovpoo7popLpopXpopnpoqPpoqhcIiwzNyxcIumjj+mjkOmjlOmjlumjl+mjm+mjnOmjnemjoFwiLDRdLFxuW1wiZWY4MFwiLFwi6aOl6aOm6aOpXCIsMzAsXCLpk6npk6vpk67pk6/pk7Ppk7Tpk7Xpk7fpk7npk7zpk73pk7/plIPplILplIbplIfplInplIrplI3plI7plI/plJJcIiw0LFwi6ZSY6ZSb6ZSd6ZSe6ZSf6ZSi6ZSq6ZSr6ZSp6ZSs6ZSx6ZSy6ZS06ZS26ZS36ZS46ZS86ZS+6ZS/6ZWC6ZS16ZWE6ZWF6ZWG6ZWJ6ZWM6ZWO6ZWP6ZWS6ZWT6ZWU6ZWW6ZWX6ZWY6ZWZ6ZWb6ZWe6ZWf6ZWd6ZWh6ZWi6ZWkXCIsOCxcIumVr+mVsemVsumVs+mUuuefp+efrOmbieenleenreeno+enq+eohuW1h+eog+eogueonueolFwiXSxcbltcImYwNDBcIixcIumkiFwiLDQsXCLppI7ppI/ppJFcIiwyOCxcIumkr1wiLDI2XSxcbltcImYwODBcIixcIumlilwiLDksXCLppZZcIiwxMixcIumlpOmlpumls+mluOmluemlu+mlvummgummg+mmieeoueeot+epkem7j+mmpeepsOeaiOeajueak+eameeapOeTnueToOeUrOm4oOm4oum4qFwiLDQsXCLpuLLpuLHpuLbpuLjpuLfpuLnpuLrpuL7puYHpuYLpuYTpuYbpuYfpuYjpuYnpuYvpuYzpuY7puZHpuZXpuZfpuZrpuZvpuZzpuZ7puaPpuaZcIiw2LFwi6bmx6bmt6bmz55aS55aU55aW55ag55ad55as55aj55az55a055a455eE55ax55aw55eD55eC55eW55eN55ej55eo55em55ek55er55en55iD55ex55e855e/55iQ55iA55iF55iM55iX55iK55il55iY55iV55iZXCJdLFxuW1wiZjE0MFwiLFwi6aaM6aaO6aaaXCIsMTAsXCLppqbppqfppqlcIiw0N10sXG5bXCJmMTgwXCIsXCLpp5lcIiwzMixcIueYm+eYvOeYoueYoOeZgOeYreeYsOeYv+eYteeZg+eYvueYs+eZjeeZnueZlOeZnOeZlueZq+eZr+e/iuerpuepuOepueeqgOeqhueqiOeqleeqpueqoOeqrOeqqOeqreeqs+ihpOihqeihsuihveihv+iiguiiouijhuiit+iivOijieijouijjuijo+ijpeijseikmuijvOijqOijvuijsOikoeikmeikk+ikm+ikiuiktOikq+iktuilgeilpuilu+eWi+iDpeeasueatOefnOiAkuiAlOiAluiAnOiAoOiAouiApeiApuiAp+iAqeiAqOiAseiAi+iAteiBg+iBhuiBjeiBkuiBqeiBseimg+mhuOmigOmig1wiXSxcbltcImYyNDBcIixcIumnulwiLDYyXSxcbltcImYyODBcIixcIumouVwiLDMyLFwi6aKJ6aKM6aKN6aKP6aKU6aKa6aKb6aKe6aKf6aKh6aKi6aKl6aKm6JmN6JmU6Jms6Jmu6Jm/6Jm66Jm86Jm76Jqo6JqN6JqL6Jqs6Jqd6Jqn6Jqj6Jqq6JqT6Jqp6Jq26JuE6Jq16JuO6Jqw6Jq66Jqx6Jqv6JuJ6JuP6Jq06Jup6Jux6Juy6Jut6Juz6JuQ6JyT6Jue6Ju06Juf6JuY6JuR6JyD6JyH6Ju46JyI6JyK6JyN6JyJ6Jyj6Jy76Jye6Jyl6Jyu6Jya6Jy+6J2I6Jy06Jyx6Jyp6Jy36Jy/6J6C6Jyi6J296J2+6J276J2g6J2w6J2M6J2u6J6L6J2T6J2j6J286J2k6J2Z6J2l6J6T6J6v6J6o6J+SXCJdLFxuW1wiZjM0MFwiLFwi6amaXCIsMTcsXCLpqbLpqoPpqonpqo3pqo7pqpTpqpXpqpnpqqbpqqlcIiw2LFwi6aqy6aqz6aq06aq16aq56aq76aq96aq+6aq/6auD6auE6auGXCIsNCxcIumrjemrjumrj+mrkOmrkumrlOmrlemrlumrl+mrmemrmumrm+mrnFwiXSxcbltcImYzODBcIixcIumrnemrnumroOmroumro+mrpOmrpemrp+mrqOmrqemrqumrrOmrrumrsFwiLDgsXCLpq7rpq7xcIiw2LFwi6ayE6ayF6ayG6J+G6J6I6J6F6J6t6J6X6J6D6J6r6J+l6J6s6J616J6z6J+L6J+T6J696J+R6J+A6J+K6J+b6J+q6J+g6J+u6KCW6KCT6J++6KCK6KCb6KCh6KC56KC857y2572C572E572F6IiQ56u656u956yI56yD56yE56yV56yK56yr56yP562H56y456yq56yZ56yu56yx56yg56yl56yk56yz56y+56ye562Y562a562F5621562M562d562g562u5627562i562y562x566Q566m566n5664566s566d566o566F566q566c566i566r566056+R56+B56+M56+d56+a56+l56+m56+q57CM56++56+857CP57CW57CLXCJdLFxuW1wiZjQ0MFwiLFwi6ayH6ayJXCIsNSxcIumskOmskemskumslFwiLDEwLFwi6ayg6ayh6ayi6aykXCIsMTAsXCLprLDprLHprLNcIiw3LFwi6ay96ay+6ay/6a2A6a2G6a2K6a2L6a2M6a2O6a2Q6a2S6a2T6a2VXCIsNV0sXG5bXCJmNDgwXCIsXCLprZtcIiwzMixcIuewn+ewquewpuewuOexgeexgOiHvuiIgeiIguiIhOiHrOihhOiIoeiIouiIo+iIreiIr+iIqOiIq+iIuOiIu+iIs+iItOiIvuiJhOiJieiJi+iJj+iJmuiJn+iJqOihvuiiheiiiOijmOijn+ilnue+nee+n+e+p+e+r+e+sOe+suexvOaVieeykeeyneeynOeynueyoueysueyvOeyveezgeezh+ezjOezjeeziOezheezl+ezqOiJruaaqOe+v+e/jue/lee/pee/oee/pue/qee/rue/s+ezuOe1t+e2pue2rue5h+e6m+m6uOm6tOi1s+i2hOi2lOi2kei2sei1p+i1reixh+ixiemFiumFkOmFjumFj+mFpFwiXSxcbltcImY1NDBcIixcIumtvFwiLDYyXSxcbltcImY1ODBcIixcIumuu1wiLDMyLFwi6YWi6YWh6YWw6YWp6YWv6YW96YW+6YWy6YW06YW56YaM6YaF6YaQ6YaN6YaR6Yai6Yaj6Yaq6Yat6Yau6Yav6Ya16Ya06Ya66LGV6bm+6La46Ler6LiF6LmZ6Lmp6La16La/6La86La66LeE6LeW6LeX6Lea6Lee6LeO6LeP6Leb6LeG6Les6Le36Le46Lej6Le56Le76Lek6LiJ6Le96LiU6Lid6Lif6Lis6Liu6Lij6Liv6Li66LmA6Li56Li16Li96Lix6LmJ6LmB6LmC6LmR6LmS6LmK6Lmw6Lm26Lm86Lmv6Lm06LqF6LqP6LqU6LqQ6Lqc6Lqe6LG46LKC6LKK6LKF6LKY6LKU5pab6KeW6Kee6Kea6KecXCJdLFxuW1wiZjY0MFwiLFwi6a+cXCIsNjJdLFxuW1wiZjY4MFwiLFwi6bCbXCIsMzIsXCLop6Xop6vop6/oqL7orKbpnZPpm6npm7Ppm6/pnIbpnIHpnIjpnI/pnI7pnKrpnK3pnLDpnL7pvoDpvoPpvoVcIiw1LFwi6b6M6bu+6byL6byN6Zq56Zq86Zq96ZuO6ZuS556/6Zug6YqO6Yqu6YuI6Yy+6Y2q6Y+K6Y6P6ZC+6ZGr6bG/6bKC6bKF6bKG6bKH6bKI56ij6bKL6bKO6bKQ6bKR6bKS6bKU6bKV6bKa6bKb6bKeXCIsNSxcIumypVwiLDQsXCLpsqvpsq3psq7psrBcIiw3LFwi6bK66bK76bK86bK96bOE6bOF6bOG6bOH6bOK6bOLXCJdLFxuW1wiZjc0MFwiLFwi6bC8XCIsNjJdLFxuW1wiZjc4MFwiLFwi6bG76bG96bG+6bKA6bKD6bKE6bKJ6bKK6bKM6bKP6bKT6bKW6bKX6bKY6bKZ6bKd6bKq6bKs6bKv6bK56bK+XCIsNCxcIumziOmziemzkemzkumzmumzm+mzoOmzoemzjFwiLDQsXCLps5Pps5Tps5Xps5fps5jps5nps5zps53ps5/ps6LpnbzpnoXpnpHpnpLpnpTpnq/pnqvpnqPpnrLpnrTpqrHpqrDpqrfpuZjpqrbpqrrpqrzpq4Hpq4Dpq4Xpq4Lpq4vpq4zpq5HprYXprYPprYfprYnprYjprY3prZHpo6jppI3ppK7ppZXppZTpq5/pq6Hpq6bpq6/pq6vpq7vpq63pq7nprIjprI/prJPprJ/prKPpur3pur7nuLvpuoLpuofpuojpuovpupLpj5bpup3pup/pu5vpu5zpu53pu6Dpu5/pu6Lpu6npu6fpu6Xpu6rpu6/pvKLpvKzpvK/pvLnpvLfpvL3pvL7pvYRcIl0sXG5bXCJmODQwXCIsXCLps6NcIiw2Ml0sXG5bXCJmODgwXCIsXCLptKJcIiwzMl0sXG5bXCJmOTQwXCIsXCLptYNcIiw2Ml0sXG5bXCJmOTgwXCIsXCLptoJcIiwzMl0sXG5bXCJmYTQwXCIsXCLptqNcIiw2Ml0sXG5bXCJmYTgwXCIsXCLpt6JcIiwzMl0sXG5bXCJmYjQwXCIsXCLpuINcIiwyNyxcIum4pOm4p+m4rum4sOm4tOm4u+m4vOm5gOm5jem5kOm5kum5k+m5lOm5lum5mem5nem5n+m5oOm5oem5oum5pem5rum5r+m5sum5tFwiLDksXCLpuoBcIl0sXG5bXCJmYjgwXCIsXCLpuoHpuoPpuoTpuoXpuobpuonpuorpuoxcIiw1LFwi6bqUXCIsOCxcIum6num6oFwiLDUsXCLpuqfpuqjpuqnpuqpcIl0sXG5bXCJmYzQwXCIsXCLpuqtcIiw4LFwi6bq16bq26bq36bq56bq66bq86bq/XCIsNCxcIum7hem7hum7h+m7iOm7ium7i+m7jOm7kOm7kum7k+m7lem7lum7l+m7mem7mum7num7oem7o+m7pOm7pum7qOm7q+m7rOm7rem7rum7sFwiLDgsXCLpu7rpu73pu79cIiw2XSxcbltcImZjODBcIixcIum8hlwiLDQsXCLpvIzpvI/pvJHpvJLpvJTpvJXpvJbpvJjpvJpcIiw1LFwi6byh6byjXCIsOCxcIum8rem8rum8sOm8sVwiXSxcbltcImZkNDBcIixcIum8slwiLDQsXCLpvLjpvLrpvLzpvL9cIiw0LFwi6b2FXCIsMTAsXCLpvZJcIiwzOF0sXG5bXCJmZDgwXCIsXCLpvblcIiw1LFwi6b6B6b6C6b6NXCIsMTEsXCLpvpzpvp3pvp7pvqFcIiw0LFwi76Ss76W576aV76en76exXCJdLFxuW1wiZmU0MFwiLFwi76iM76iN76iO76iP76iR76iT76iU76iY76if76ig76ih76ij76ik76in76io76ipXCJdXG5dXG4iLCJtb2R1bGUuZXhwb3J0cz1bXG5bXCIwXCIsXCJcXHUwMDAwXCIsMTI3XSxcbltcIjgxNDFcIixcIuqwguqwg+qwheqwhuqwi1wiLDQsXCLqsJjqsJ7qsJ/qsKHqsKLqsKPqsKVcIiw2LFwi6rCu6rCy6rCz6rC0XCJdLFxuW1wiODE2MVwiLFwi6rC16rC26rC36rC66rC76rC96rC+6rC/6rGBXCIsOSxcIuqxjOqxjlwiLDUsXCLqsZVcIl0sXG5bXCI4MTgxXCIsXCLqsZbqsZfqsZnqsZrqsZvqsZ1cIiwxOCxcIuqxsuqxs+qxteqxtuqxueqxu1wiLDQsXCLqsoLqsofqsojqso3qso7qso/qspHqspLqspPqspVcIiw2LFwi6rKe6rKiXCIsNSxcIuqyq+qyreqyruqysVwiLDYsXCLqsrrqsr7qsr/qs4Dqs4Lqs4Pqs4Xqs4bqs4fqs4nqs4rqs4vqs41cIiw3LFwi6rOW6rOYXCIsNyxcIuqzouqzo+qzpeqzpuqzqeqzq+qzreqzruqzsuqztOqzt1wiLDQsXCLqs77qs7/qtIHqtILqtIPqtIXqtIdcIiw0LFwi6rSO6rSQ6rSS6rSTXCJdLFxuW1wiODI0MVwiLFwi6rSU6rSV6rSW6rSX6rSZ6rSa6rSb6rSd6rSe6rSf6rShXCIsNyxcIuq0quq0q+q0rlwiLDVdLFxuW1wiODI2MVwiLFwi6rS26rS36rS56rS66rS76rS9XCIsNixcIuq1huq1iOq1ilwiLDUsXCLqtZHqtZLqtZPqtZXqtZbqtZdcIl0sXG5bXCI4MjgxXCIsXCLqtZlcIiw3LFwi6rWi6rWkXCIsNyxcIuq1ruq1r+q1seq1suq1t+q1uOq1ueq1uuq1vuq2gOq2g1wiLDQsXCLqtorqtovqto3qto7qto/qtpFcIiwxMCxcIuq2nlwiLDUsXCLqtqVcIiwxNyxcIuq2uFwiLDcsXCLqt4Lqt4Pqt4Xqt4bqt4fqt4lcIiw2LFwi6reS6reUXCIsNyxcIuq3neq3nuq3n+q3oeq3ouq3o+q3pVwiLDE4XSxcbltcIjgzNDFcIixcIuq3uuq3u+q3veq3vuq4glwiLDUsXCLquIrquIzquI5cIiw1LFwi6riVXCIsN10sXG5bXCI4MzYxXCIsXCLquJ1cIiwxOCxcIuq4suq4s+q4teq4tuq4ueq4u+q4vFwiXSxcbltcIjgzODFcIixcIuq4veq4vuq4v+q5guq5hOq5h+q5iOq5ieq5i+q5j+q5keq5kuq5k+q5leq5l1wiLDQsXCLquZ7quaLquaPquaTquabquafquarquavqua3qua7qua/qubFcIiw2LFwi6rm66rm+XCIsNSxcIuq6hlwiLDUsXCLquo1cIiw0NixcIuq6v+q7geq7guq7g+q7hVwiLDYsXCLqu47qu5JcIiw1LFwi6rua6rub6rudXCIsOF0sXG5bXCI4NDQxXCIsXCLqu6bqu6fqu6nqu6rqu6zqu65cIiw1LFwi6ru16ru26ru36ru56ru66ru76ru9XCIsOF0sXG5bXCI4NDYxXCIsXCLqvIbqvInqvIrqvIvqvIzqvI7qvI/qvJFcIiwxOF0sXG5bXCI4NDgxXCIsXCLqvKRcIiw3LFwi6ryu6ryv6ryx6ryz6ry1XCIsNixcIuq8vuq9gOq9hOq9heq9huq9h+q9ilwiLDUsXCLqvZFcIiwxMCxcIuq9nlwiLDUsXCLqvaZcIiwxOCxcIuq9ulwiLDUsXCLqvoHqvoLqvoPqvoXqvobqvofqvolcIiw2LFwi6r6S6r6T6r6U6r6WXCIsNSxcIuq+nVwiLDI2LFwi6r666r676r696r6+XCJdLFxuW1wiODU0MVwiLFwi6r6/6r+BXCIsNSxcIuq/iuq/jOq/j1wiLDQsXCLqv5VcIiw2LFwi6r+dXCIsNF0sXG5bXCI4NTYxXCIsXCLqv6JcIiw1LFwi6r+qXCIsNSxcIuq/suq/s+q/teq/tuq/t+q/uVwiLDYsXCLrgILrgINcIl0sXG5bXCI4NTgxXCIsXCLrgIVcIiw2LFwi64CN64CO64CP64CR64CS64CT64CVXCIsNixcIuuAnlwiLDksXCLrgKlcIiwyNixcIuuBhuuBh+uBieuBi+uBjeuBj+uBkOuBkeuBkuuBluuBmOuBmuuBm+uBnOuBnlwiLDI5LFwi64G+64G/64KB64KC64KD64KFXCIsNixcIuuCjuuCkOuCklwiLDUsXCLrgpvrgp3rgp7rgqPrgqRcIl0sXG5bXCI4NjQxXCIsXCLrgqXrgqbrgqfrgqrrgrDrgrLrgrbrgrfrgrnrgrrrgrvrgr1cIiw2LFwi64OG64OKXCIsNSxcIuuDklwiXSxcbltcIjg2NjFcIixcIuuDk+uDleuDluuDl+uDmVwiLDYsXCLrg6Hrg6Lrg6Prg6Trg6ZcIiwxMF0sXG5bXCI4NjgxXCIsXCLrg7FcIiwyMixcIuuEiuuEjeuEjuuEj+uEkeuElOuEleuEluuEl+uEmuuEnlwiLDQsXCLrhKbrhKfrhKnrhKrrhKvrhK1cIiw2LFwi64S264S6XCIsNSxcIuuFguuFg+uFheuFhuuFh+uFiVwiLDYsXCLrhZLrhZPrhZbrhZfrhZnrhZrrhZvrhZ3rhZ7rhZ/rhaFcIiwyMixcIuuFuuuFu+uFveuFvuuFv+uGgeuGg1wiLDQsXCLrhorrhozrho7rho/rhpDrhpHrhpXrhpbrhpfrhpnrhprrhpvrhp1cIl0sXG5bXCI4NzQxXCIsXCLrhp5cIiw5LFwi64apXCIsMTVdLFxuW1wiODc2MVwiLFwi64a5XCIsMTgsXCLrh43rh47rh4/rh5Hrh5Lrh5Prh5VcIl0sXG5bXCI4NzgxXCIsXCLrh5ZcIiw1LFwi64ee64egXCIsNyxcIuuHquuHq+uHreuHruuHr+uHsVwiLDcsXCLrh7rrh7zrh75cIiw1LFwi64iG64iH64iJ64iK64iNXCIsNixcIuuIluuImOuImlwiLDUsXCLriKFcIiwxOCxcIuuItVwiLDYsXCLriL1cIiwyNixcIuuJmeuJmuuJm+uJneuJnuuJn+uJoVwiLDYsXCLriapcIiw0XSxcbltcIjg4NDFcIixcIuuJr1wiLDQsXCLribZcIiw1LFwi64m9XCIsNixcIuuKhuuKh+uKiOuKilwiLDRdLFxuW1wiODg2MVwiLFwi64qP64qS64qT64qV64qW64qX64qbXCIsNCxcIuuKouuKpOuKp+uKqOuKqeuKq+uKreuKruuKr+uKseuKsuuKs+uKteuKtuuKt1wiXSxcbltcIjg4ODFcIixcIuuKuFwiLDE1LFwi64uK64uL64uN64uO64uP64uR64uTXCIsNCxcIuuLmuuLnOuLnuuLn+uLoOuLoeuLo+uLp+uLqeuLquuLsOuLseuLsuuLtuuLvOuLveuLvuuMguuMg+uMheuMhuuMh+uMiVwiLDYsXCLrjJLrjJZcIiw1LFwi64ydXCIsNTQsXCLrjZfrjZnrjZrrjZ3rjaDrjaHrjaLrjaNcIl0sXG5bXCI4OTQxXCIsXCLrjabrjajrjarrjazrja3rja/rjbLrjbPrjbXrjbbrjbfrjblcIiw2LFwi646C646GXCIsNSxcIuuOjVwiXSxcbltcIjg5NjFcIixcIuuOjuuOj+uOkeuOkuuOk+uOlVwiLDEwLFwi646iXCIsNSxcIuuOqeuOquuOq+uOrVwiXSxcbltcIjg5ODFcIixcIuuOrlwiLDIxLFwi64+G64+H64+J64+K64+N64+P64+R64+S64+T64+W64+Y64+a64+c64+e64+f64+h64+i64+j64+l64+m64+n64+pXCIsMTgsXCLrj71cIiwxOCxcIuuQkVwiLDYsXCLrkJnrkJrrkJvrkJ3rkJ7rkJ/rkKFcIiw2LFwi65Cq65CsXCIsNyxcIuuQtVwiLDE1XSxcbltcIjhhNDFcIixcIuuRhVwiLDEwLFwi65GS65GT65GV65GW65GX65GZXCIsNixcIuuRouuRpOuRplwiXSxcbltcIjhhNjFcIixcIuuRp1wiLDQsXCLrka1cIiwxOCxcIuuSgeuSglwiXSxcbltcIjhhODFcIixcIuuSg1wiLDQsXCLrkolcIiwxOSxcIuuSnlwiLDUsXCLrkqXrkqbrkqfrkqnrkqrrkqvrkq1cIiw3LFwi65K265K465K6XCIsNSxcIuuTgeuTguuTg+uTheuThuuTh+uTiVwiLDYsXCLrk5Hrk5Lrk5Prk5Trk5ZcIiw1LFwi65Oe65Of65Oh65Oi65Ol65OnXCIsNCxcIuuTruuTsOuTslwiLDUsXCLrk7lcIiwyNixcIuuUluuUl+uUmeuUmuuUnVwiXSxcbltcIjhiNDFcIixcIuuUnlwiLDUsXCLrlKbrlKtcIiw0LFwi65Sy65Sz65S165S265S365S5XCIsNixcIuuVguuVhlwiXSxcbltcIjhiNjFcIixcIuuVh+uViOuVieuViuuVjuuVj+uVkeuVkuuVk+uVlVwiLDYsXCLrlZ7rlaJcIiw4XSxcbltcIjhiODFcIixcIuuVq1wiLDUyLFwi65ai65aj65al65am65an65ap65as65at65au65av65ay65a2XCIsNCxcIuuWvuuWv+uXgeuXguuXg+uXhVwiLDYsXCLrl47rl5JcIiw1LFwi65eZXCIsMTgsXCLrl61cIiwxOF0sXG5bXCI4YzQxXCIsXCLrmIBcIiwxNSxcIuuYkuuYk+uYleuYluuYl+uYmVwiLDRdLFxuW1wiOGM2MVwiLFwi65ieXCIsNixcIuuYplwiLDUsXCLrmK1cIiw2LFwi65i1XCIsNV0sXG5bXCI4YzgxXCIsXCLrmLtcIiwxMixcIuuZiVwiLDI2LFwi65ml65mm65mn65mpXCIsNTAsXCLrmp7rmp/rmqHrmqLrmqPrmqVcIiw1LFwi65qt65qu65qv65qw65qyXCIsMTZdLFxuW1wiOGQ0MVwiLFwi65uDXCIsMTYsXCLrm5VcIiw4XSxcbltcIjhkNjFcIixcIuubnlwiLDE3LFwi65ux65uy65uz65u165u265u365u565u6XCJdLFxuW1wiOGQ4MVwiLFwi65u7XCIsNCxcIuucguucg+uchOuchlwiLDMzLFwi65yq65yr65yt65yu65yxXCIsNixcIuucuuucvFwiLDcsXCLrnYXrnYbrnYfrnYnrnYrrnYvrnY1cIiw2LFwi652WXCIsOSxcIuudoeudouudo+udpeudpuudp+udqVwiLDYsXCLrnbLrnbTrnbZcIiw1LFwi652+652/656B656C656D656FXCIsNixcIuuejuuek+uelOueleuemuuem+ueneuenlwiXSxcbltcIjhlNDFcIixcIuuen+ueoVwiLDYsXCLrnqrrnq5cIiw1LFwi656265636565XCIsOF0sXG5bXCI4ZTYxXCIsXCLrn4JcIiw0LFwi65+I65+KXCIsMTldLFxuW1wiOGU4MVwiLFwi65+eXCIsMTMsXCLrn67rn6/rn7Hrn7Lrn7Prn7VcIiw2LFwi65++66CCXCIsNCxcIuugiuugi+ugjeugjuugj+ugkVwiLDYsXCLroJrroJzroJ5cIiw1LFwi66Cm66Cn66Cp66Cq66Cr66CtXCIsNixcIuugtuugulwiLDUsXCLroYHroYLroYProYVcIiwxMSxcIuuhkuuhlFwiLDcsXCLroZ7roZ/roaHroaLroaProaVcIiw2LFwi66Gu66Gw66GyXCIsNSxcIuuhueuhuuuhu+uhvVwiLDddLFxuW1wiOGY0MVwiLFwi66KFXCIsNyxcIuuijlwiLDE3XSxcbltcIjhmNjFcIixcIuuioFwiLDcsXCLroqlcIiw2LFwi66Kx66Ky66Kz66K166K266K366K5XCIsNF0sXG5bXCI4ZjgxXCIsXCLror7ror/ro4Lro4Tro4ZcIiw1LFwi66ON66OO66OP66OR66OS66OT66OVXCIsNyxcIuujnuujoOujolwiLDUsXCLro6rro6vro63ro67ro6/ro7FcIiw2LFwi66O666O866O+XCIsNSxcIuukhVwiLDE4LFwi66SZXCIsNixcIuukoVwiLDI2LFwi66S+66S/66WB66WC66WD66WFXCIsNixcIuuljeuljuulkOulklwiLDVdLFxuW1wiOTA0MVwiLFwi66Wa66Wb66Wd66We66Wf66WhXCIsNixcIuulquulrOulrlwiLDUsXCLrpbbrpbfrpbnrpbrrpbvrpb1cIl0sXG5bXCI5MDYxXCIsXCLrpb5cIiw1LFwi66aG66aI66aL66aM66aPXCIsMTVdLFxuW1wiOTA4MVwiLFwi66afXCIsMTIsXCLrpq7rpq/rprHrprLrprPrprVcIiw2LFwi66a+66eA66eCXCIsNSxcIuuniuuni+unjeunk1wiLDQsXCLrp5rrp5zrp5/rp6Drp6Lrp6brp6frp6nrp6rrp6vrp61cIiw2LFwi66e266e7XCIsNCxcIuuoglwiLDUsXCLrqIlcIiwxMSxcIuuollwiLDMzLFwi66i666i766i966i+66i/66mB66mD66mE66mF66mGXCJdLFxuW1wiOTE0MVwiLFwi66mH66mK66mM66mP66mQ66mR66mS66mW66mX66mZ66ma66mb66mdXCIsNixcIuuppuupqlwiLDVdLFxuW1wiOTE2MVwiLFwi66my66mz66m166m266m366m5XCIsOSxcIuuqhuuqiOuqieuqiuuqi+uqjVwiLDVdLFxuW1wiOTE4MVwiLFwi66qTXCIsMjAsXCLrqqrrqq3rqq7rqq/rqrHrqrNcIiw0LFwi66q666q866q+XCIsNSxcIuurheurhuurh+uriVwiLDE0LFwi66uaXCIsMzMsXCLrq73rq77rq7/rrIHrrILrrIPrrIVcIiw3LFwi66yO66yQ66ySXCIsNSxcIuusmeusmuusm+usneusnuusn+usoVwiLDZdLFxuW1wiOTI0MVwiLFwi66yo66yq66ysXCIsNyxcIuust+usueusuuusv1wiLDQsXCLrrYbrrYjrrYrrrYvrrYzrrY7rrZHrrZJcIl0sXG5bXCI5MjYxXCIsXCLrrZPrrZXrrZbrrZfrrZlcIiw3LFwi662i662kXCIsNyxcIuutrVwiLDRdLFxuW1wiOTI4MVwiLFwi662yXCIsMjEsXCLrronrrorrrovrro3rro7rro/rrpFcIiwxOCxcIuuupeuupuuup+uuqeuuquuuq+uurVwiLDYsXCLrrrXrrrbrrrhcIiw3LFwi66+B66+C66+D66+F66+G66+H66+JXCIsNixcIuuvkeuvkuuvlFwiLDM1LFwi66+666+766+966++67CBXCJdLFxuW1wiOTM0MVwiLFwi67CDXCIsNCxcIuuwiuuwjuuwkOuwkuuwk+uwmeuwmuuwoOuwoeuwouuwo+uwpuuwqOuwquuwq+uwrOuwruuwr+uwsuuws+uwtVwiXSxcbltcIjkzNjFcIixcIuuwtuuwt+uwuVwiLDYsXCLrsYLrsYbrsYfrsYjrsYrrsYvrsY7rsY/rsZFcIiw4XSxcbltcIjkzODFcIixcIuuxmuuxm+uxnOuxnlwiLDM3LFwi67KG67KH67KJ67KK67KN67KPXCIsNCxcIuuyluuymOuym1wiLDQsXCLrsqLrsqPrsqXrsqbrsqlcIiw2LFwi67Ky67K2XCIsNSxcIuuyvuuyv+uzgeuzguuzg+uzhVwiLDcsXCLrs47rs5Lrs5Prs5Trs5brs5frs5nrs5rrs5vrs51cIiwyMixcIuuzt+uzueuzuuuzu+uzvVwiXSxcbltcIjk0NDFcIixcIuuzvlwiLDUsXCLrtIbrtIjrtIpcIiw1LFwi67SR67SS67ST67SVXCIsOF0sXG5bXCI5NDYxXCIsXCLrtJ5cIiw1LFwi67SlXCIsNixcIuu0rVwiLDEyXSxcbltcIjk0ODFcIixcIuu0ulwiLDUsXCLrtYFcIiw2LFwi67WK67WL67WN67WO67WP67WRXCIsNixcIuu1mlwiLDksXCLrtaXrtabrtafrtalcIiwyMixcIuu2guu2g+u2heu2huu2i1wiLDQsXCLrtpLrtpTrtpbrtpfrtpjrtpvrtp1cIiw2LFwi67alXCIsMTAsXCLrtrFcIiw2LFwi67a5XCIsMjRdLFxuW1wiOTU0MVwiLFwi67eS67eT67eW67eX67eZ67ea67eb67edXCIsMTEsXCLrt6pcIiw1LFwi67exXCJdLFxuW1wiOTU2MVwiLFwi67ey67ez67e167e267e367e5XCIsNixcIuu4geu4guu4hOu4hlwiLDUsXCLruI7ruI/ruJHruJLruJNcIl0sXG5bXCI5NTgxXCIsXCLruJVcIiw2LFwi67ie67igXCIsMzUsXCLruYbruYfruYnruYrruYvruY3ruY9cIiw0LFwi67mW67mY67mc67md67me67mf67mi67mj67ml67mm67mn67mp67mrXCIsNCxcIuu5suu5tlwiLDQsXCLrub7rub/ruoHruoLruoPruoVcIiw2LFwi67qO67qSXCIsNSxcIuu6mlwiLDEzLFwi67qpXCIsMTRdLFxuW1wiOTY0MVwiLFwi67q4XCIsMjMsXCLru5Lru5NcIl0sXG5bXCI5NjYxXCIsXCLru5Xru5bru5lcIiw2LFwi67uh67ui67umXCIsNSxcIuu7rVwiLDhdLFxuW1wiOTY4MVwiLFwi67u2XCIsMTAsXCLrvIJcIiw1LFwi67yKXCIsMTMsXCLrvJrrvJ5cIiwzMyxcIuu9guu9g+u9heu9huu9h+u9iVwiLDYsXCLrvZLrvZPrvZTrvZZcIiw0NF0sXG5bXCI5NzQxXCIsXCLrvoNcIiwxNixcIuu+lVwiLDhdLFxuW1wiOTc2MVwiLFwi676eXCIsMTcsXCLrvrFcIiw3XSxcbltcIjk3ODFcIixcIuu+uVwiLDExLFwi67+GXCIsNSxcIuu/juu/j+u/keu/kuu/k+u/lVwiLDYsXCLrv53rv57rv6Drv6JcIiw4OSxcIuyAveyAvuyAv1wiXSxcbltcIjk4NDFcIixcIuyBgFwiLDE2LFwi7IGSXCIsNSxcIuyBmeyBmuyBm1wiXSxcbltcIjk4NjFcIixcIuyBneyBnuyBn+yBoVwiLDYsXCLsgapcIiwxNV0sXG5bXCI5ODgxXCIsXCLsgbpcIiwyMSxcIuyCkuyCk+yCleyCluyCl+yCmVwiLDYsXCLsgqLsgqTsgqZcIiw1LFwi7IKu7IKx7IKy7IK3XCIsNCxcIuyCvuyDguyDg+yDhOyDhuyDh+yDiuyDi+yDjeyDjuyDj+yDkVwiLDYsXCLsg5rsg55cIiw1LFwi7IOm7IOn7IOp7IOq7IOr7IOtXCIsNixcIuyDtuyDuOyDulwiLDUsXCLshIHshILshIPshIXshIbshIfshIlcIiw2LFwi7ISR7ISS7IST7ISU7ISWXCIsNSxcIuyEoeyEouyEpeyEqOyEqeyEquyEq+yErlwiXSxcbltcIjk5NDFcIixcIuyEsuyEs+yEtOyEteyEt+yEuuyEu+yEveyEvuyEv+yFgVwiLDYsXCLshYrshY5cIiw1LFwi7IWW7IWXXCJdLFxuW1wiOTk2MVwiLFwi7IWZ7IWa7IWb7IWdXCIsNixcIuyFpuyFqlwiLDUsXCLshbHshbLshbPshbXshbbshbfshbnshbrshbtcIl0sXG5bXCI5OTgxXCIsXCLshbxcIiw4LFwi7IaGXCIsNSxcIuyGj+yGkeyGkuyGk+yGleyGl1wiLDQsXCLshp7shqDshqLshqPshqTshqbshqfshqrshqvshq3shq7shq/shrFcIiwxMSxcIuyGvlwiLDUsXCLsh4Xsh4bsh4fsh4nsh4rsh4vsh41cIiw2LFwi7IeV7IeW7IeZXCIsNixcIuyHoeyHouyHo+yHpeyHpuyHp+yHqVwiLDYsXCLsh7Lsh7RcIiw3LFwi7Ie+7Ie/7IiB7IiC7IiD7IiFXCIsNixcIuyIjuyIkOyIklwiLDUsXCLsiJrsiJvsiJ3siJ7siKHsiKLsiKNcIl0sXG5bXCI5YTQxXCIsXCLsiKTsiKXsiKbsiKfsiKrsiKzsiK7siLDsiLPsiLVcIiwxNl0sXG5bXCI5YTYxXCIsXCLsiYbsiYfsiYlcIiw2LFwi7ImS7ImT7ImV7ImW7ImX7ImZXCIsNixcIuyJoeyJouyJo+yJpOyJplwiXSxcbltcIjlhODFcIixcIuyJp1wiLDQsXCLsia7sia/sibHsibLsibPsibVcIiw2LFwi7Im+7IqA7IqCXCIsNSxcIuyKilwiLDUsXCLsipFcIiw2LFwi7IqZ7Iqa7Iqc7IqeXCIsNSxcIuyKpuyKp+yKqeyKquyKq+yKrlwiLDUsXCLsirbsirjsirpcIiwzMyxcIuyLnuyLn+yLoeyLouyLpVwiLDUsXCLsi67si7Dsi7Lsi7Psi7Tsi7Xsi7fsi7rsi73si77si7/sjIFcIiw2LFwi7IyK7IyL7IyO7IyPXCJdLFxuW1wiOWI0MVwiLFwi7IyQ7IyR7IyS7IyW7IyX7IyZ7Iya7Iyb7IydXCIsNixcIuyMpuyMp+yMqlwiLDhdLFxuW1wiOWI2MVwiLFwi7IyzXCIsMTcsXCLsjYZcIiw3XSxcbltcIjliODFcIixcIuyNjlwiLDI1LFwi7I2q7I2r7I2t7I2u7I2v7I2x7I2zXCIsNCxcIuyNuuyNu+yNvlwiLDUsXCLsjoXsjobsjofsjonsjorsjovsjo1cIiw1MCxcIuyPgVwiLDIyLFwi7I+aXCJdLFxuW1wiOWM0MVwiLFwi7I+b7I+d7I+e7I+h7I+jXCIsNCxcIuyPquyPq+yPrOyPrlwiLDUsXCLsj7bsj7fsj7lcIiw1XSxcbltcIjljNjFcIixcIuyPv1wiLDgsXCLskIlcIiw2LFwi7JCRXCIsOV0sXG5bXCI5YzgxXCIsXCLskJtcIiw4LFwi7JClXCIsNixcIuyQreyQruyQr+yQseyQsuyQs+yQtVwiLDYsXCLskL5cIiw5LFwi7JGJXCIsMjYsXCLskabskafskanskarskavska1cIiw2LFwi7JG27JG37JG47JG6XCIsNSxcIuySgVwiLDE4LFwi7JKVXCIsNixcIuySnVwiLDEyXSxcbltcIjlkNDFcIixcIuySqlwiLDEzLFwi7JK57JK67JK77JK9XCIsOF0sXG5bXCI5ZDYxXCIsXCLsk4ZcIiwyNV0sXG5bXCI5ZDgxXCIsXCLsk6BcIiw4LFwi7JOqXCIsNSxcIuyTsuyTs+yTteyTtuyTt+yTueyTu+yTvOyTveyTvuyUglwiLDksXCLslI3slI7slI/slJHslJLslJPslJVcIiw2LFwi7JSdXCIsMTAsXCLslKrslKvslK3slK7slK/slLFcIiw2LFwi7JS67JS87JS+XCIsNSxcIuyVhuyVh+yVi+yVj+yVkOyVkeyVkuyVluyVmuyVm+yVnOyVn+yVouyVo+yVpeyVpuyVp+yVqVwiLDYsXCLslbLslbZcIiw1LFwi7JW+7JW/7JaB7JaC7JaD7JaF7JaG7JaI7JaJ7JaK7JaL7JaO7JaQ7JaS7JaT7JaUXCJdLFxuW1wiOWU0MVwiLFwi7JaW7JaZ7Jaa7Jab7Jad7Jae7Jaf7JahXCIsNyxcIuyWqlwiLDksXCLslrZcIl0sXG5bXCI5ZTYxXCIsXCLslrfslrrslr9cIiw0LFwi7JeL7JeN7JeP7JeS7JeT7JeV7JeW7JeX7JeZXCIsNixcIuyXouyXpOyXpuyXp1wiXSxcbltcIjllODFcIixcIuyXqOyXqeyXquyXq+yXr+yXseyXsuyXs+yXteyXuOyXueyXuuyXu+yYguyYg+yYhOyYieyYiuyYi+yYjeyYjuyYj+yYkVwiLDYsXCLsmJrsmJ1cIiw2LFwi7Jim7Jin7Jip7Jiq7Jir7Jiv7Jix7Jiy7Ji27Ji47Ji67Ji87Ji97Ji+7Ji/7JmC7JmD7JmF7JmG7JmH7JmJXCIsNixcIuyZkuyZllwiLDUsXCLsmZ7smZ/smaFcIiwxMCxcIuyZreyZruyZsOyZslwiLDUsXCLsmbrsmbvsmb3smb7smb/smoFcIiw2LFwi7JqK7JqM7JqOXCIsNSxcIuyaluyal+yameyamuyam+yanVwiLDYsXCLsmqZcIl0sXG5bXCI5ZjQxXCIsXCLsmqjsmqpcIiw1LFwi7Jqy7Jqz7Jq17Jq27Jq37Jq7XCIsNCxcIuybguybhOybhlwiLDUsXCLsm45cIl0sXG5bXCI5ZjYxXCIsXCLsm4/sm5Hsm5Lsm5Psm5VcIiw2LFwi7Jue7Juf7JuiXCIsNSxcIuybquybq+ybreybruybr+ybseybslwiXSxcbltcIjlmODFcIixcIuybs1wiLDQsXCLsm7rsm7vsm7zsm75cIiw1LFwi7JyG7JyH7JyJ7JyK7JyL7JyNXCIsNixcIuycluycmOycmlwiLDUsXCLsnKLsnKPsnKXsnKbsnKfsnKlcIiw2LFwi7Jyy7Jy07Jy27Jy47Jy57Jy67Jy77Jy+7Jy/7J2B7J2C7J2D7J2FXCIsNCxcIuydi+ydjuydkOydmeydmuydm+ydneydnuydn+ydoVwiLDYsXCLsnansnarsnaxcIiw3LFwi7J227J237J257J267J277J2/7J6A7J6B7J6C7J6G7J6L7J6M7J6N7J6P7J6S7J6T7J6V7J6Z7J6bXCIsNCxcIuyeouyep1wiLDQsXCLsnq7snq/snrHsnrLsnrPsnrXsnrbsnrdcIl0sXG5bXCJhMDQxXCIsXCLsnrjsnrnsnrrsnrvsnr7sn4JcIiw1LFwi7J+K7J+L7J+N7J+P7J+RXCIsNixcIuyfmeyfmuyfm+yfnFwiXSxcbltcImEwNjFcIixcIuyfnlwiLDUsXCLsn6Xsn6bsn6fsn6nsn6rsn6vsn61cIiwxM10sXG5bXCJhMDgxXCIsXCLsn7tcIiw0LFwi7KCC7KCD7KCF7KCG7KCH7KCJ7KCLXCIsNCxcIuygkuyglOygl1wiLDQsXCLsoJ7soJ/soKHsoKLsoKPsoKVcIiw2LFwi7KCu7KCw7KCyXCIsNSxcIuygueyguuygu+ygveygvuygv+yhgVwiLDYsXCLsoYrsoYvsoY5cIiw1LFwi7KGVXCIsMjYsXCLsobLsobPsobXsobbsobfsobnsobtcIiw0LFwi7KKC7KKE7KKI7KKJ7KKK7KKOXCIsNSxcIuyilVwiLDcsXCLsop7soqDsoqLsoqPsoqRcIl0sXG5bXCJhMTQxXCIsXCLsoqXsoqbsoqfsoqlcIiwxOCxcIuyivuyiv+yjgOyjgVwiXSxcbltcImExNjFcIixcIuyjguyjg+yjheyjhuyjh+yjieyjiuyji+yjjVwiLDYsXCLso5bso5jso5pcIiw1LFwi7KOi7KOj7KOlXCJdLFxuW1wiYTE4MVwiLFwi7KOmXCIsMTQsXCLso7ZcIiw1LFwi7KO+7KO/7KSB7KSC7KSD7KSHXCIsNCxcIuykjuOAgOOAgeOAgsK34oCl4oCmwqjjgIPCreKAleKIpe+8vOKIvOKAmOKAmeKAnOKAneOAlOOAleOAiFwiLDksXCLCscOXw7fiiaDiiaTiiaXiiJ7iiLTCsOKAsuKAs+KEg+KEq++/oO+/oe+/peKZguKZgOKIoOKKpeKMkuKIguKIh+KJoeKJksKn4oC74piG4piF4peL4peP4peO4peH4peG4pah4pag4paz4pay4pa94pa84oaS4oaQ4oaR4oaT4oaU44CT4omq4omr4oia4oi94oid4oi14oir4ois4oiI4oiL4oqG4oqH4oqC4oqD4oiq4oip4oin4oio77+iXCJdLFxuW1wiYTI0MVwiLFwi7KSQ7KSSXCIsNSxcIuykmVwiLDE4XSxcbltcImEyNjFcIixcIuykrVwiLDYsXCLspLVcIiwxOF0sXG5bXCJhMjgxXCIsXCLspYhcIiw3LFwi7KWS7KWT7KWV7KWW7KWX7KWZXCIsNixcIuylouylpFwiLDcsXCLspa3spa7spa/ih5Lih5TiiIDiiIPCtO+9nsuHy5jLncuay5nCuMubwqHCv8uQ4oiu4oiR4oiPwqTihInigLDil4Hil4DilrfilrbimaTimaDimaHimaXimafimaPiipnil4jilqPil5Dil5HilpLilqTilqXilqjilqfilqbilqnimajimI/imI7imJzimJ7CtuKAoOKAoeKGleKGl+KGmeKGluKGmOKZreKZqeKZquKZrOOJv+OInOKEluOPh+KEouOPguOPmOKEoeKCrMKuXCJdLFxuW1wiYTM0MVwiLFwi7KWx7KWy7KWz7KW1XCIsNixcIuylvVwiLDEwLFwi7KaK7KaL7KaN7KaO7KaPXCJdLFxuW1wiYTM2MVwiLFwi7KaRXCIsNixcIuymmuymnOymnlwiLDE2XSxcbltcImEzODFcIixcIuymr1wiLDE2LFwi7KeC7KeD7KeF7KeG7KeJ7KeLXCIsNCxcIuynkuynlOynl+ynmOynm++8gVwiLDU4LFwi77+m77y9XCIsMzIsXCLvv6NcIl0sXG5bXCJhNDQxXCIsXCLsp57sp5/sp6Hsp6Psp6Xsp6bsp6jsp6nsp6rsp6vsp67sp7JcIiw1LFwi7Ke67Ke77Ke97Ke+7Ke/7KiB7KiC7KiD7KiEXCJdLFxuW1wiYTQ2MVwiLFwi7KiF7KiG7KiH7KiK7KiOXCIsNSxcIuyoleyoluyol+yomVwiLDEyXSxcbltcImE0ODFcIixcIuyopuyop+yoqOyoqlwiLDI4LFwi44SxXCIsOTNdLFxuW1wiYTU0MVwiLFwi7KmHXCIsNCxcIuypjuypj+ypkeypkuypk+yplVwiLDYsXCLsqZ7sqaJcIiw1LFwi7Kmp7KmqXCJdLFxuW1wiYTU2MVwiLFwi7KmrXCIsMTcsXCLsqb5cIiw1LFwi7KqF7KqGXCJdLFxuW1wiYTU4MVwiLFwi7KqHXCIsMTYsXCLsqplcIiwxNCxcIuKFsFwiLDldLFxuW1wiYTViMFwiLFwi4oWgXCIsOV0sXG5bXCJhNWMxXCIsXCLOkVwiLDE2LFwizqNcIiw2XSxcbltcImE1ZTFcIixcIs6xXCIsMTYsXCLPg1wiLDZdLFxuW1wiYTY0MVwiLFwi7KqoXCIsMTksXCLsqr7sqr/sq4Hsq4Lsq4Psq4VcIl0sXG5bXCJhNjYxXCIsXCLsq4ZcIiw1LFwi7KuO7KuQ7KuS7KuU7KuV7KuW7KuX7KuaXCIsNSxcIuyroVwiLDZdLFxuW1wiYTY4MVwiLFwi7Kuo7Kup7Kuq7Kur7KutXCIsNixcIuyrtVwiLDE4LFwi7KyJ7KyK4pSA4pSC4pSM4pSQ4pSY4pSU4pSc4pSs4pSk4pS04pS84pSB4pSD4pSP4pST4pSb4pSX4pSj4pSz4pSr4pS74pWL4pSg4pSv4pSo4pS34pS/4pSd4pSw4pSl4pS44pWC4pSS4pSR4pSa4pSZ4pSW4pSV4pSO4pSN4pSe4pSf4pSh4pSi4pSm4pSn4pSp4pSq4pSt4pSu4pSx4pSy4pS14pS24pS54pS64pS94pS+4pWA4pWB4pWDXCIsN10sXG5bXCJhNzQxXCIsXCLsrItcIiw0LFwi7KyR7KyS7KyT7KyV7KyW7KyX7KyZXCIsNixcIuysolwiLDddLFxuW1wiYTc2MVwiLFwi7KyqXCIsMjIsXCLsrYLsrYPsrYRcIl0sXG5bXCJhNzgxXCIsXCLsrYXsrYbsrYfsrYrsrYvsrY3srY7srY/srZFcIiw2LFwi7K2a7K2b7K2c7K2eXCIsNSxcIuytpVwiLDcsXCLjjpXjjpbjjpfihJPjjpjjj4TjjqPjjqTjjqXjjqbjjplcIiw5LFwi44+K446N446O446P44+P446I446J44+I446n446o446wXCIsOSxcIuOOgFwiLDQsXCLjjrpcIiw1LFwi446QXCIsNCxcIuKEpuOPgOOPgeOOiuOOi+OOjOOPluOPheOOreOOruOOr+OPm+OOqeOOquOOq+OOrOOPneOPkOOPk+OPg+OPieOPnOOPhlwiXSxcbltcImE4NDFcIixcIuytrVwiLDEwLFwi7K26XCIsMTRdLFxuW1wiYTg2MVwiLFwi7K6JXCIsMTgsXCLsrp1cIiw2XSxcbltcImE4ODFcIixcIuyupFwiLDE5LFwi7K65XCIsMTEsXCLDhsOQwqrEplwiXSxcbltcImE4YTZcIixcIsSyXCJdLFxuW1wiYThhOFwiLFwixL/FgcOYxZLCusOexabFilwiXSxcbltcImE4YjFcIixcIuOJoFwiLDI3LFwi4pOQXCIsMjUsXCLikaBcIiwxNCxcIsK94oWT4oWUwrzCvuKFm+KFnOKFneKFnlwiXSxcbltcImE5NDFcIixcIuyvhVwiLDE0LFwi7K+VXCIsMTBdLFxuW1wiYTk2MVwiLFwi7K+g7K+h7K+i7K+j7K+l7K+m7K+o7K+qXCIsMThdLFxuW1wiYTk4MVwiLFwi7K+9XCIsMTQsXCLssI7ssI/ssJHssJLssJPssJVcIiw2LFwi7LCe7LCf7LCg7LCj7LCkw6bEkcOwxKfEscSzxLjFgMWCw7jFk8Ofw77Fp8WLxYnjiIBcIiwyNyxcIuKSnFwiLDI1LFwi4pG0XCIsMTQsXCLCucKywrPigbTigb/igoHigoLigoPigoRcIl0sXG5bXCJhYTQxXCIsXCLssKXssKbssKrssKvssK3ssK/ssLFcIiw2LFwi7LC67LC/XCIsNCxcIuyxhuyxh+yxieyxiuyxi+yxjeyxjlwiXSxcbltcImFhNjFcIixcIuyxj1wiLDQsXCLssZbssZpcIiw1LFwi7LGh7LGi7LGj7LGl7LGn7LGpXCIsNixcIuyxseyxslwiXSxcbltcImFhODFcIixcIuyxs+yxtOyxtlwiLDI5LFwi44GBXCIsODJdLFxuW1wiYWI0MVwiLFwi7LKU7LKV7LKW7LKX7LKa7LKb7LKd7LKe7LKf7LKhXCIsNixcIuyyquyyrlwiLDUsXCLssrbssrfssrlcIl0sXG5bXCJhYjYxXCIsXCLssrrssrvssr1cIiw2LFwi7LOG7LOI7LOKXCIsNSxcIuyzkeyzkuyzk+yzlVwiLDVdLFxuW1wiYWI4MVwiLFwi7LObXCIsOCxcIuyzpVwiLDYsXCLss63ss67ss6/ss7FcIiwxMixcIuOCoVwiLDg1XSxcbltcImFjNDFcIixcIuyzvuyzv+y0gOy0glwiLDUsXCLstIrstIvstI3stI7stI/stJFcIiw2LFwi7LSa7LSc7LSe7LSf7LSgXCJdLFxuW1wiYWM2MVwiLFwi7LSh7LSi7LSj7LSl7LSm7LSn7LSp7LSq7LSr7LStXCIsMTEsXCLstLpcIiw0XSxcbltcImFjODFcIixcIuy0v1wiLDI4LFwi7LWd7LWe7LWf0JBcIiw1LFwi0IHQllwiLDI1XSxcbltcImFjZDFcIixcItCwXCIsNSxcItGR0LZcIiwyNV0sXG5bXCJhZDQxXCIsXCLstaHstaLstaPstaVcIiw2LFwi7LWu7LWw7LWyXCIsNSxcIuy1uVwiLDddLFxuW1wiYWQ2MVwiLFwi7LaBXCIsNixcIuy2iVwiLDEwLFwi7LaW7LaX7LaZ7Laa7Lab7Lad7Lae7LafXCJdLFxuW1wiYWQ4MVwiLFwi7Lag7Lah7Lai7Laj7Lam7Lao7LaqXCIsNSxcIuy2sVwiLDE4LFwi7LeFXCJdLFxuW1wiYWU0MVwiLFwi7LeGXCIsNSxcIuy3jey3juy3j+y3kVwiLDE2XSxcbltcImFlNjFcIixcIuy3olwiLDUsXCLst6nst6rst6vst63st67st6/st7FcIiw2LFwi7Le67Le87Le+XCIsNF0sXG5bXCJhZTgxXCIsXCLsuIPsuIXsuIbsuIfsuInsuIrsuIvsuI1cIiw2LFwi7LiV7LiW7LiX7LiY7LiaXCIsNSxcIuy4ouy4o+y4pey4puy4p+y4qey4quy4q1wiXSxcbltcImFmNDFcIixcIuy4rOy4rey4ruy4r+y4suy4tOy4tlwiLDE5XSxcbltcImFmNjFcIixcIuy5ilwiLDEzLFwi7Lma7Lmb7Lmd7Lme7LmiXCIsNSxcIuy5quy5rFwiXSxcbltcImFmODFcIixcIuy5rlwiLDUsXCLsubbsubfsubnsubrsubvsub1cIiw2LFwi7LqG7LqI7LqKXCIsNSxcIuy6kuy6k+y6ley6luy6l+y6mVwiXSxcbltcImIwNDFcIixcIuy6mlwiLDUsXCLsuqLsuqZcIiw1LFwi7LquXCIsMTJdLFxuW1wiYjA2MVwiLFwi7Lq7XCIsNSxcIuy7glwiLDE5XSxcbltcImIwODFcIixcIuy7llwiLDEzLFwi7Lum7Lun7Lup7Luq7LutXCIsNixcIuy7tuy7ulwiLDUsXCLqsIDqsIHqsITqsIfqsIjqsInqsIrqsJBcIiw3LFwi6rCZXCIsNCxcIuqwoOqwpOqwrOqwreqwr+qwsOqwseqwuOqwueqwvOqxgOqxi+qxjeqxlOqxmOqxnOqxsOqxseqxtOqxt+qxuOqxuuqygOqygeqyg+qyhOqyheqyhuqyieqyiuqyi+qyjOqykOqylOqynOqyneqyn+qyoOqyoeqyqOqyqeqyquqyrOqyr+qysOqyuOqyueqyu+qyvOqyveqzgeqzhOqziOqzjOqzleqzl+qzoOqzoeqzpOqzp+qzqOqzquqzrOqzr+qzsOqzseqzs+qzteqztuqzvOqzveq0gOq0hOq0hlwiXSxcbltcImIxNDFcIixcIuy8guy8g+y8hey8huy8h+y8iVwiLDYsXCLsvJLsvJTsvJZcIiw1LFwi7Lyd7Lye7Lyf7Lyh7Lyi7LyjXCJdLFxuW1wiYjE2MVwiLFwi7LylXCIsNixcIuy8ruy8slwiLDUsXCLsvLlcIiwxMV0sXG5bXCJiMTgxXCIsXCLsvYVcIiwxNCxcIuy9luy9l+y9mey9muy9m+y9nVwiLDYsXCLsvabsvajsvarsvavsvazqtIzqtI3qtI/qtJHqtJjqtJzqtKDqtKnqtKzqtK3qtLTqtLXqtLjqtLzqtYTqtYXqtYfqtYnqtZDqtZTqtZjqtaHqtaPqtazqta3qtbDqtbPqtbTqtbXqtbbqtbvqtbzqtb3qtb/qtoHqtoLqtojqtonqtozqtpDqtpzqtp3qtqTqtrfqt4Dqt4Hqt4Tqt4jqt5Dqt5Hqt5Pqt5zqt6Dqt6Tqt7jqt7nqt7zqt7/quIDquIHquIjquInquIvquI3quJTquLDquLHquLTquLfquLjquLrquYDquYHquYPquYXquYbquYrquYzquY3quY7quZDquZTquZbquZzquZ3quZ/quaDquaHquaXquajquanquazqubDqubhcIl0sXG5bXCJiMjQxXCIsXCLsva3sva7sva/svbLsvbPsvbXsvbbsvbfsvblcIiw2LFwi7L6B7L6C7L6D7L6E7L6GXCIsNSxcIuy+jVwiXSxcbltcImIyNjFcIixcIuy+jlwiLDE4LFwi7L6iXCIsNSxcIuy+qVwiXSxcbltcImIyODFcIixcIuy+qlwiLDUsXCLsvrFcIiwxOCxcIuy/hVwiLDYsXCLqubnqubvqubzqub3quoTquoXquozqurzqur3qur7qu4Dqu4Tqu4zqu43qu4/qu5Dqu5Hqu5jqu5nqu5zqu6jqu6vqu63qu7Tqu7jqu7zqvIfqvIjqvI3qvJDqvKzqvK3qvLDqvLLqvLTqvLzqvL3qvL/qvYHqvYLqvYPqvYjqvYnqvZDqvZzqvZ3qvaTqvaXqvbnqvoDqvoTqvojqvpDqvpHqvpXqvpzqvrjqvrnqvrzqv4Dqv4fqv4jqv4nqv4vqv43qv47qv5Tqv5zqv6jqv6nqv7Dqv7Hqv7Tqv7jrgIDrgIHrgITrgIzrgJDrgJTrgJzrgJ3rgKjrgYTrgYXrgYjrgYrrgYzrgY7rgZPrgZTrgZXrgZfrgZlcIl0sXG5bXCJiMzQxXCIsXCLsv4xcIiwxOSxcIuy/ouy/o+y/pey/puy/p+y/qVwiXSxcbltcImIzNjFcIixcIuy/qlwiLDUsXCLsv7Lsv7Tsv7ZcIiw1LFwi7L+97L++7L+/7YCB7YCC7YCD7YCFXCIsNV0sXG5bXCJiMzgxXCIsXCLtgItcIiw1LFwi7YCSXCIsNSxcIu2AmVwiLDE5LFwi64Gd64G864G964KA64KE64KM64KN64KP64KR64KY64KZ64Ka64Kc64Kf64Kg64Kh64Ki64Ko64Kp64KrXCIsNCxcIuuCseuCs+uCtOuCteuCuOuCvOuDhOuDheuDh+uDiOuDieuDkOuDkeuDlOuDmOuDoOuDpeuEiOuEieuEi+uEjOuEkOuEkuuEk+uEmOuEmeuEm+uEnOuEneuEo+uEpOuEpeuEqOuErOuEtOuEteuEt+uEuOuEueuFgOuFgeuFhOuFiOuFkOuFkeuFlOuFleuFmOuFnOuFoOuFuOuFueuFvOuGgOuGguuGiOuGieuGi+uGjeuGkuuGk+uGlOuGmOuGnOuGqOuHjOuHkOuHlOuHnOuHnVwiXSxcbltcImI0NDFcIixcIu2ArlwiLDUsXCLtgLbtgLftgLntgLrtgLvtgL1cIiw2LFwi7YGG7YGI7YGKXCIsNV0sXG5bXCJiNDYxXCIsXCLtgZHtgZLtgZPtgZXtgZbtgZftgZlcIiw2LFwi7YGhXCIsMTAsXCLtga7tga9cIl0sXG5bXCJiNDgxXCIsXCLtgbHtgbLtgbPtgbVcIiw2LFwi7YG+7YG/7YKA7YKCXCIsMTgsXCLrh5/rh6jrh6nrh6zrh7Drh7nrh7vrh73riITriIXriIjriIvriIzriJTriJXriJfriJnriKDriLTriLzriZjriZzriaDriajrianribTribXribzrioTrioXrionripDripHripTripjripnriprriqDriqHriqPriqXriqbriqrriqzrirDrirTri4jri4nri4zri5Dri5Lri5jri5nri5vri53ri6Lri6Tri6Xri6bri6jri6tcIiw0LFwi64uz64u064u164u3XCIsNCxcIuuLv+uMgOuMgeuMhOuMiOuMkOuMkeuMk+uMlOuMleuMnOuNlOuNleuNluuNmOuNm+uNnOuNnuuNn+uNpOuNpVwiXSxcbltcImI1NDFcIixcIu2ClVwiLDE0LFwi7YKm7YKn7YKp7YKq7YKr7YKtXCIsNV0sXG5bXCJiNTYxXCIsXCLtgrPtgrbtgrjtgrpcIiw1LFwi7YOC7YOD7YOF7YOG7YOH7YOKXCIsNSxcIu2Dku2DllwiLDRdLFxuW1wiYjU4MVwiLFwi7YOb7YOe7YOf7YOh7YOi7YOj7YOlXCIsNixcIu2Dru2DslwiLDUsXCLtg7lcIiwxMSxcIuuNp+uNqeuNq+uNruuNsOuNseuNtOuNuOuOgOuOgeuOg+uOhOuOheuOjOuOkOuOlOuOoOuOoeuOqOuOrOuPhOuPheuPiOuPi+uPjOuPjuuPkOuPlOuPleuPl+uPmeuPm+uPneuPoOuPpOuPqOuPvOuQkOuQmOuQnOuQoOuQqOuQqeuQq+uQtOuRkOuRkeuRlOuRmOuRoOuRoeuRo+uRpeuRrOuSgOuSiOuSneuSpOuSqOuSrOuSteuSt+uSueuTgOuThOuTiOuTkOuTleuTnOuTneuToOuTo+uTpOuTpuuTrOuTreuTr+uTseuTuOuUlOuUleuUmOuUm+uUnOuUpOuUpeuUp+uUqOuUqeuUquuUsOuUseuUtOuUuFwiXSxcbltcImI2NDFcIixcIu2EhVwiLDcsXCLthI5cIiwxN10sXG5bXCJiNjYxXCIsXCLthKBcIiwxNSxcIu2Esu2Es+2Ete2Etu2Et+2Eue2Eu+2EvO2Eve2EvlwiXSxcbltcImI2ODFcIixcIu2Ev+2Fgu2FhlwiLDUsXCLthY7thY/thZHthZLthZPthZVcIiw2LFwi7YWe7YWg7YWiXCIsNSxcIu2Fqe2Fqu2Fq+2FreuVgOuVgeuVg+uVhOuVheuVi+uVjOuVjeuVkOuVlOuVnOuVneuVn+uVoOuVoeuWoOuWoeuWpOuWqOuWquuWq+uWsOuWseuWs+uWtOuWteuWu+uWvOuWveuXgOuXhOuXjOuXjeuXj+uXkOuXkeuXmOuXrOuYkOuYkeuYlOuYmOuYpeuYrOuYtOuZiOuZpOuZqOuanOuaneuaoOuapOuaq+uarOuaseublOubsOubtOubuOucgOucgeucheucqOucqeucrOucr+ucsOucuOucueucu+udhOudiOudjOudlOudleudoOudpOudqOudsOudseuds+udteudvOudveuegOuehOuejOuejeuej+uekOuekeuekuueluuel1wiXSxcbltcImI3NDFcIixcIu2FrlwiLDEzLFwi7YW9XCIsNixcIu2Ghe2Ghu2Gh+2Gie2GilwiXSxcbltcImI3NjFcIixcIu2Gi1wiLDIwLFwi7Yai7Yaj7Yal7Yam7YanXCJdLFxuW1wiYjc4MVwiLFwi7YapXCIsNixcIu2Gsu2GtO2Gtu2Gt+2GuO2Gue2Gu+2Gve2Gvu2Gv+2HgVwiLDE0LFwi656Y656Z656c656g656o656p656r656s656t65606561656465+H65+J65+s65+t65+w65+065+865+965+/66CA66CB66CH66CI66CJ66CM66CQ66CY66CZ66Cb66Cd66Ck66Cl66Co66Cs66C066C166C366C466C566GA66GE66GR66GT66Gc66Gd66Gg66Gk66Gs66Gt66Gv66Gx66G466G866KN66Ko66Kw66K066K466OA66OB66OD66OF66OM66OQ66OU66Od66Of66Oh66Oo66Op66Os66Ow66O466O566O766O966SE66SY66Sg66S866S966WA66WE66WM66WP66WR66WY66WZ66Wc66Wg66Wo66WpXCJdLFxuW1wiYjg0MVwiLFwi7YeQXCIsNyxcIu2HmVwiLDE3XSxcbltcImI4NjFcIixcIu2Hq1wiLDgsXCLth7Xth7bth7fth7lcIiwxM10sXG5bXCJiODgxXCIsXCLtiIjtiIpcIiw1LFwi7YiRXCIsMjQsXCLrpavrpa3rpbTrpbXrpbjrpbzrpoTrpoXrpofrponrporrpo3rpo7rpqzrpq3rprDrprTrprzrpr3rpr/rp4Hrp4jrp4nrp4zrp45cIiw0LFwi66eY66eZ66eb66ed66ee66eh66ej66ek66el66eo66es66e066e166e366e466e566e666iA66iB66iI66iV66i466i566i866mA66mC66mI66mJ66mL66mN66mO66mT66mU66mV66mY66mc66mk66ml66mn66mo66mp66mw66mx66m066m466qD66qE66qF66qH66qM66qo66qp66qr66qs66qw66qy66q466q566q766q966uE66uI66uY66uZ66u8XCJdLFxuW1wiYjk0MVwiLFwi7Yiq7Yir7Yiu7Yiv7Yix7Yiy7Yiz7Yi1XCIsNixcIu2Ivu2JgO2JglwiLDUsXCLtiYntiYrtiYvtiYxcIl0sXG5bXCJiOTYxXCIsXCLtiY1cIiwxNCxcIu2JnVwiLDYsXCLtiaXtiabtiaftiahcIl0sXG5bXCJiOTgxXCIsXCLtialcIiwyMixcIu2Kgu2Kg+2Khe2Khu2Kh+2Kie2Kiu2Ki+2KjOusgOushOusjeusj+uskeusmOusnOusoOusqeusq+ustOusteustuusuOusu+usvOusveusvuuthOutheuth+utieutjeutj+utkOutlOutmOutoeuto+utrOuuiOuujOuukOuupOuuqOuurOuutOuut+uvgOuvhOuviOuvkOuvk+uvuOuvueuvvOuvv+uwgOuwguuwiOuwieuwi+uwjOuwjeuwj+uwkeuwlFwiLDQsXCLrsJtcIiw0LFwi67Ck67Cl67Cn67Cp67Ct67Cw67Cx67C067C467GA67GB67GD67GE67GF67GJ67GM67GN67GQ67Gd67KE67KF67KI67KL67KM67KO67KU67KV67KXXCJdLFxuW1wiYmE0MVwiLFwi7YqN7YqO7YqP7YqS7YqT7YqU7YqWXCIsNSxcIu2Kne2Knu2Kn+2Koe2Kou2Ko+2KpVwiLDYsXCLtiq1cIl0sXG5bXCJiYTYxXCIsXCLtiq7tiq/tirDtirJcIiw1LFwi7Yq67Yq77Yq97Yq+7YuB7YuDXCIsNCxcIu2Liu2LjFwiLDVdLFxuW1wiYmE4MVwiLFwi7YuS7YuT7YuV7YuW7YuX7YuZ7Yua7Yub7YudXCIsNixcIu2LplwiLDksXCLti7Lti7Pti7Xti7bti7fti7nti7rrspnrsprrsqDrsqHrsqTrsqfrsqjrsrDrsrHrsrPrsrTrsrXrsrzrsr3rs4Drs4Trs43rs4/rs5Drs5Hrs5Xrs5jrs5zrs7Trs7Xrs7brs7jrs7zrtITrtIXrtIfrtInrtJDrtJTrtKTrtKzrtYDrtYjrtYnrtYzrtZDrtZjrtZnrtaTrtajrtoDrtoHrtoTrtofrtojrtonrtorrtpDrtpHrtpPrtpXrtpnrtprrtpzrtqTrtrDrtrjrt5Trt5Xrt5jrt5zrt6nrt7Drt7Trt7jruIDruIPruIXruIzruI3ruJDruJTruJzruJ3ruJ/ruYTruYXruYjruYzruY7ruZTruZXruZfruZnruZrruZvruaDruaHruaRcIl0sXG5bXCJiYjQxXCIsXCLti7tcIiw0LFwi7YyC7YyE7YyGXCIsNSxcIu2Mj+2Mke2Mku2Mk+2Mle2Ml1wiLDQsXCLtjJ7tjKLtjKNcIl0sXG5bXCJiYjYxXCIsXCLtjKTtjKbtjKftjKrtjKvtjK3tjK7tjK/tjLFcIiw2LFwi7Yy67Yy+XCIsNSxcIu2Nhu2Nh+2NiO2NiVwiXSxcbltcImJiODFcIixcIu2NilwiLDMxLFwi67mo67mq67mw67mx67mz67m067m167m767m867m967qA67qE67qM67qN67qP67qQ67qR67qY67qZ67qo67uQ67uR67uU67uX67uY67ug67uj67uk67ul67us67yB67yI67yJ67yY67yZ67yb67yc67yd672A672B672E672I672Q672R672V676U676w67+F67+M67+N67+Q67+U67+c67+f67+h7IC87IGR7IGY7IGc7IGg7IGo7IGp7IKQ7IKR7IKU7IKY7IKg7IKh7IKj7IKl7IKs7IKt7IKv7IKw7IKz7IK07IK17IK27IK87IK97IK/7IOA7IOB7IOF7IOI7IOJ7IOM7IOQ7IOY7IOZ7IOb7IOc7IOd7IOkXCJdLFxuW1wiYmM0MVwiLFwi7Y2qXCIsMTcsXCLtjb7tjb/tjoHtjoLtjoPtjoXtjobtjodcIl0sXG5bXCJiYzYxXCIsXCLtjojtjontjortjovtjo7tjpJcIiw1LFwi7Y6a7Y6b7Y6d7Y6e7Y6f7Y6hXCIsNixcIu2Oqu2OrO2OrlwiXSxcbltcImJjODFcIixcIu2Or1wiLDQsXCLtjrXtjrbtjrftjrntjrrtjrvtjr1cIiw2LFwi7Y+G7Y+H7Y+KXCIsNSxcIu2PkVwiLDUsXCLsg6Xsg6jsg6zsg7Tsg7Xsg7fsg7nshIDshITshIjshJDshJXshJxcIiw0LFwi7ISj7ISk7ISm7ISn7ISs7ISt7ISv7ISw7ISx7IS27IS47IS57IS87IWA7IWI7IWJ7IWL7IWM7IWN7IWU7IWV7IWY7IWc7IWk7IWl7IWn7IWo7IWp7IWw7IW07IW47IaF7IaM7IaN7IaO7IaQ7IaU7IaW7Iac7Iad7Iaf7Iah7Ial7Iao7Iap7Ias7Iaw7Ia97IeE7IeI7IeM7IeU7IeX7IeY7Ieg7Iek7Ieo7Iew7Iex7Iez7Ie87Ie97IiA7IiE7IiM7IiN7IiP7IiR7IiY7IiZ7Iic7Iif7Iig7Iio7Iip7Iir7IitXCJdLFxuW1wiYmQ0MVwiLFwi7Y+X7Y+ZXCIsNyxcIu2Pou2PpFwiLDcsXCLtj67tj6/tj7Htj7Ltj7Ptj7Xtj7btj7dcIl0sXG5bXCJiZDYxXCIsXCLtj7jtj7ntj7rtj7vtj77tkIDtkIJcIiw1LFwi7ZCJXCIsMTNdLFxuW1wiYmQ4MVwiLFwi7ZCXXCIsNSxcIu2QnlwiLDI1LFwi7Iiv7Iix7Iiy7Ii07ImI7ImQ7ImR7ImU7ImY7Img7Iml7Ims7Imt7Imw7Im07Im87Im97Im/7IqB7IqI7IqJ7IqQ7IqY7Iqb7Iqd7Iqk7Iql7Iqo7Iqs7Iqt7Iq07Iq17Iq37Iq57Iuc7Iud7Iug7Iuj7Iuk7Iur7Ius7Iut7Iuv7Iux7Iu27Iu47Iu57Iu77Iu87IyA7IyI7IyJ7IyM7IyN7IyT7IyU7IyV7IyY7Iyc7Iyk7Iyl7Iyo7Iyp7I2F7I2o7I2p7I2s7I2w7I2y7I247I257I287I297I6E7I6I7I6M7I+A7I+Y7I+Z7I+c7I+f7I+g7I+i7I+o7I+p7I+t7I+07I+17I+47JCI7JCQ7JCk7JCs7JCwXCJdLFxuW1wiYmU0MVwiLFwi7ZC4XCIsNyxcIu2Rge2Rgu2Rg+2RhVwiLDE0XSxcbltcImJlNjFcIixcIu2RlFwiLDcsXCLtkZ3tkZ7tkZ/tkaHtkaLtkaPtkaVcIiw3LFwi7ZGu7ZGw7ZGx7ZGyXCJdLFxuW1wiYmU4MVwiLFwi7ZGzXCIsNCxcIu2Ruu2Ru+2Rve2Rvu2Sge2Sg1wiLDQsXCLtkortkoztko5cIiw1LFwi7ZKVXCIsOCxcIuyQtOyQvOyQveyRiOyRpOyRpeyRqOyRrOyRtOyRteyRueySgOySlOySnOySuOySvOyTqeyTsOyTseyTtOyTuOyTuuyTv+yUgOyUgeyUjOyUkOyUlOyUnOyUqOyUqeyUrOyUsOyUuOyUueyUu+yUveyVhOyVheyViOyVieyViuyVjOyVjeyVjuyVk+yVlOyVleyVl+yVmOyVmeyVneyVnuyVoOyVoeyVpOyVqOyVsOyVseyVs+yVtOyVteyVvOyVveyWgOyWhOyWh+yWjOyWjeyWj+yWkeyWleyWl+yWmOyWnOyWoOyWqeyWtOyWteyWuOyWueyWu+yWvOyWveyWvuyXhFwiLDYsXCLsl4zsl45cIl0sXG5bXCJiZjQxXCIsXCLtkp5cIiwxMCxcIu2SqlwiLDE0XSxcbltcImJmNjFcIixcIu2SuVwiLDE4LFwi7ZON7ZOO7ZOP7ZOR7ZOS7ZOT7ZOVXCJdLFxuW1wiYmY4MVwiLFwi7ZOWXCIsNSxcIu2Tne2Tnu2ToFwiLDcsXCLtk6ntk6rtk6vtk63tk67tk6/tk7FcIiw2LFwi7ZO57ZO67ZO87JeQ7JeR7JeU7JeY7Jeg7Jeh7Jej7Jel7Jes7Jet7Jeu7Jew7Je07Je27Je37Je8XCIsNSxcIuyYheyYhuyYh+yYiOyYjOyYkOyYmOyYmeyYm+yYnOyYpOyYpeyYqOyYrOyYreyYruyYsOyYs+yYtOyYteyYt+yYueyYu+yZgOyZgeyZhOyZiOyZkOyZkeyZk+yZlOyZleyZnOyZneyZoOyZrOyZr+yZseyZuOyZueyZvOyagOyaiOyaieyai+yajeyalOyaleyamOyanOyapOyapeyap+yaqeyasOyaseyatOyauOyaueyauuybgOybgeybg+ybheybjOybjeybkOyblOybnOybneyboOyboeybqFwiXSxcbltcImMwNDFcIixcIu2TvlwiLDUsXCLtlIXtlIbtlIftlIntlIrtlIvtlI1cIiw2LFwi7ZSW7ZSYXCIsNV0sXG5bXCJjMDYxXCIsXCLtlJ5cIiwyNV0sXG5bXCJjMDgxXCIsXCLtlLjtlLntlLrtlLvtlL7tlL/tlYHtlYLtlYPtlYVcIiw2LFwi7ZWO7ZWQ7ZWSXCIsNSxcIu2Vmu2Vm+2Vne2Vnu2Vn+2Voe2Vou2Vo+ybqeybrOybsOybuOybueybveychOycheyciOycjOyclOycleycl+ycmeycoOycoeycpOycqOycsOycseycs+ycteyct+ycvOycveydgOydhOydiuydjOydjeydj+ydkVwiLDcsXCLsnZzsnaDsnajsnavsnbTsnbXsnbjsnbzsnb3snb7snoPsnoTsnoXsnofsnojsnonsnorsno7snpDsnpHsnpTsnpbsnpfsnpjsnprsnqDsnqHsnqPsnqTsnqXsnqbsnqzsnq3snrDsnrTsnrzsnr3snr/sn4Dsn4Hsn4jsn4nsn4zsn47sn5Dsn5jsn53sn6Tsn6jsn6zsoIDsoIHsoITsoIjsoIpcIl0sXG5bXCJjMTQxXCIsXCLtlaTtlabtlaftlartlaztla5cIiw1LFwi7ZW27ZW37ZW57ZW67ZW77ZW9XCIsNixcIu2Whu2Wiu2Wi1wiXSxcbltcImMxNjFcIixcIu2WjO2Wje2Wju2Wj+2WkVwiLDE5LFwi7Zam7ZanXCJdLFxuW1wiYzE4MVwiLFwi7ZaoXCIsMzEsXCLsoJDsoJHsoJPsoJXsoJbsoJzsoJ3soKDsoKTsoKzsoK3soK/soLHsoLjsoLzsoYDsoYjsoYnsoYzsoY3soZTsobDsobHsobTsobjsobrsooDsooHsooPsooXsoobsoofsoovsoozsoo3sopTsop3sop/soqHsoqjsorzsor3so4Tso4jso4zso5Tso5Xso5fso5nso6Dso6Hso6Tso7Xso7zso73spIDspITspIXspIbspIzspI3spI/spJHspJjspKzspLTspZDspZHspZTspZjspaDspaHspaPspazspbDspbTspbzspojsponspozsppDsppjsppnsppvspp3sp4Dsp4Hsp4Tsp4fsp4jsp4rsp5Dsp5Hsp5NcIl0sXG5bXCJjMjQxXCIsXCLtl4rtl4vtl43tl47tl4/tl5Htl5NcIiw0LFwi7Zea7Zec7ZeeXCIsNSxcIu2Xpu2Xp+2Xqe2Xqu2Xq+2Xre2XrlwiXSxcbltcImMyNjFcIixcIu2Xr1wiLDQsXCLtl7btl7jtl7pcIiw1LFwi7ZiC7ZiD7ZiF7ZiG7ZiH7ZiJXCIsNixcIu2YklwiXSxcbltcImMyODFcIixcIu2YllwiLDUsXCLtmJ3tmJ7tmJ/tmKHtmKLtmKPtmKVcIiw3LFwi7ZiuXCIsOSxcIu2Yuu2Yu+ynleynluynmeynmuynnOynneynoOynouynpOynp+ynrOynreynr+ynsOynseynuOynueynvOyogOyoiOyoieyoi+yojOyojeyolOyomOyoqeypjOypjeypkOyplOypnOypneypn+ypoOypoeypqOypveyqhOyqmOyqvOyqveyrgOyrhOyrjOyrjeyrj+yrkeyrk+yrmOyrmeyroOyrrOyrtOysiOyskOyslOysmOysoOysoeytgeytiOytieytjOytkOytmOytmeytneytpOytuOytueyunOyuuOyvlOyvpOyvp+yvqeywjOywjeywkOywlOywnOywneywoeywouywp+ywqOywqeywrOywruywsOywuOywueywu1wiXSxcbltcImMzNDFcIixcIu2Yve2Yvu2Yv+2Zge2Zgu2Zg+2ZhO2Zhu2Zh+2Ziu2ZjO2Zju2Zj+2ZkO2Zku2Zk+2Zlu2Zl+2Zme2Zmu2Zm+2ZnVwiLDRdLFxuW1wiYzM2MVwiLFwi7ZmiXCIsNCxcIu2ZqO2ZqlwiLDUsXCLtmbLtmbPtmbVcIiwxMV0sXG5bXCJjMzgxXCIsXCLtmoHtmoLtmoTtmoZcIiw1LFwi7ZqO7ZqP7ZqR7ZqS7ZqT7ZqVXCIsNyxcIu2anu2aoO2aolwiLDUsXCLtmqntmqrssLzssL3ssL7ssYTssYXssYjssYzssZTssZXssZfssZjssZnssaDssaTssabssajssbDssbXsspjsspnsspzssqDssqjssqnssqvssqzssq3ssrTssrXssrjssrzss4Tss4Xss4fss4nss5Dss5Tss6Tss6zss7DstIHstIjstInstIzstJDstJjstJnstJvstJ3stKTstKjstKzstLnstZzstaDstaTstazsta3sta/stbHstbjstojstpTstpXstpjstpzstqTstqXstqfstqnstrDst4Tst4zst5Dst6jst6zst7Dst7jst7nst7vst73suITsuIjsuIzsuJTsuJnsuKDsuKHsuKTsuKjsuLDsuLHsuLPsuLVcIl0sXG5bXCJjNDQxXCIsXCLtmqvtmq3tmq7tmq/tmrFcIiw3LFwi7Zq67Zq8XCIsNyxcIu2bhu2bh+2bie2biu2bi1wiXSxcbltcImM0NjFcIixcIu2bje2bju2bj+2bkO2bku2bk+2ble2blu2bmO2bmlwiLDUsXCLtm6Htm6Ltm6Ptm6Xtm6btm6ftm6lcIiw0XSxcbltcImM0ODFcIixcIu2bru2br+2bse2bsu2bs+2btO2btlwiLDUsXCLtm77tm7/tnIHtnILtnIPtnIVcIiwxMSxcIu2cku2ck+2clOy5mOy5mey5nOy5n+y5oOy5oey5qOy5qey5q+y5rey5tOy5tey5uOy5vOy6hOy6hey6h+y6iey6kOy6key6lOy6mOy6oOy6oey6o+y6pOy6pey6rOy6rey7gey7pOy7pey7qOy7q+y7rOy7tOy7tey7t+y7uOy7uey8gOy8gey8hOy8iOy8kOy8key8k+y8ley8nOy8oOy8pOy8rOy8rey8r+y8sOy8sey8uOy9lOy9ley9mOy9nOy9pOy9pey9p+y9qey9sOy9sey9tOy9uOy+gOy+hey+jOy+oey+qOy+sOy/hOy/oOy/oey/pOy/qOy/sOy/sey/s+y/tey/vO2AgO2AhO2Ake2AmO2Are2AtO2Ate2AuO2AvFwiXSxcbltcImM1NDFcIixcIu2cle2clu2cl+2cmu2cm+2cne2cnu2cn+2coVwiLDYsXCLtnKrtnKztnK5cIiw1LFwi7Zy27Zy37Zy5XCJdLFxuW1wiYzU2MVwiLFwi7Zy67Zy77Zy9XCIsNixcIu2dhe2dhu2diO2dilwiLDUsXCLtnZLtnZPtnZXtnZpcIiw0XSxcbltcImM1ODFcIixcIu2dn+2dou2dpO2dpu2dp+2dqO2dqu2dq+2dre2dru2dr+2dse2dsu2ds+2dtVwiLDYsXCLtnb7tnb/tnoDtnoJcIiw1LFwi7Z6K7Z6L7YGE7YGF7YGH7YGJ7YGQ7YGU7YGY7YGg7YGs7YGt7YGw7YG07YG87YG97YKB7YKk7YKl7YKo7YKs7YK07YK17YK37YK57YOA7YOB7YOE7YOI7YOJ7YOQ7YOR7YOT7YOU7YOV7YOc7YOd7YOg7YOk7YOs7YOt7YOv7YOw7YOx7YO47YSN7YSw7YSx7YS07YS47YS67YWA7YWB7YWD7YWE7YWF7YWM7YWN7YWQ7YWU7YWc7YWd7YWf7YWh7YWo7YWs7YW87YaE7YaI7Yag7Yah7Yak7Yao7Yaw7Yax7Yaz7Ya17Ya67Ya87YeA7YeY7Ye07Ye47YiH7YiJ7YiQ7Yis7Yit7Yiw7Yi07Yi87Yi97Yi/7YmB7YmI7YmcXCJdLFxuW1wiYzY0MVwiLFwi7Z6N7Z6O7Z6P7Z6RXCIsNixcIu2emu2enO2enlwiLDVdLFxuW1wiYzZhMVwiLFwi7Ymk7YqA7YqB7YqE7YqI7YqQ7YqR7YqV7Yqc7Yqg7Yqk7Yqs7Yqx7Yq47Yq57Yq87Yq/7YuA7YuC7YuI7YuJ7YuL7YuU7YuY7Yuc7Yuk7Yul7Yuw7Yux7Yu07Yu47YyA7YyB7YyD7YyF7YyM7YyN7YyO7YyQ7YyU7YyW7Yyc7Yyd7Yyf7Yyg7Yyh7Yyl7Yyo7Yyp7Yys7Yyw7Yy47Yy57Yy77Yy87Yy97Y2E7Y2F7Y287Y297Y6A7Y6E7Y6M7Y6N7Y6P7Y6Q7Y6R7Y6Y7Y6Z7Y6c7Y6g7Y6o7Y6p7Y6r7Y6t7Y607Y647Y687Y+E7Y+F7Y+I7Y+J7Y+Q7Y+Y7Y+h7Y+j7Y+s7Y+t7Y+w7Y+07Y+87Y+97Y+/7ZCBXCJdLFxuW1wiYzdhMVwiLFwi7ZCI7ZCd7ZGA7ZGE7ZGc7ZGg7ZGk7ZGt7ZGv7ZG47ZG57ZG87ZG/7ZKA7ZKC7ZKI7ZKJ7ZKL7ZKN7ZKU7ZKp7ZOM7ZOQ7ZOU7ZOc7ZOf7ZOo7ZOs7ZOw7ZO47ZO77ZO97ZSE7ZSI7ZSM7ZSU7ZSV7ZSX7ZS87ZS97ZWA7ZWE7ZWM7ZWN7ZWP7ZWR7ZWY7ZWZ7ZWc7ZWg7ZWl7ZWo7ZWp7ZWr7ZWt7ZW07ZW17ZW47ZW87ZaE7ZaF7ZaH7ZaI7ZaJ7ZaQ7Zal7ZeI7ZeJ7ZeM7ZeQ7ZeS7ZeY7ZeZ7Zeb7Zed7Zek7Zel7Zeo7Zes7Ze07Ze17Ze37Ze57ZiA7ZiB7ZiE7ZiI7ZiQ7ZiR7ZiT7ZiU7ZiV7Zic7ZigXCJdLFxuW1wiYzhhMVwiLFwi7Zik7Zit7Zi47Zi57Zi87ZmA7ZmF7ZmI7ZmJ7ZmL7ZmN7ZmR7ZmU7ZmV7ZmY7Zmc7Zmn7Zmp7Zmw7Zmx7Zm07ZqD7ZqF7ZqM7ZqN7ZqQ7ZqU7Zqd7Zqf7Zqh7Zqo7Zqs7Zqw7Zq57Zq77ZuE7ZuF7ZuI7ZuM7ZuR7ZuU7ZuX7ZuZ7Zug7Zuk7Zuo7Zuw7Zu17Zu87Zu97ZyA7ZyE7ZyR7ZyY7ZyZ7Zyc7Zyg7Zyo7Zyp7Zyr7Zyt7Zy07Zy17Zy47Zy87Z2E7Z2H7Z2J7Z2Q7Z2R7Z2U7Z2W7Z2X7Z2Y7Z2Z7Z2g7Z2h7Z2j7Z2l7Z2p7Z2s7Z2w7Z207Z287Z297Z6B7Z6I7Z6J7Z6M7Z6Q7Z6Y7Z6Z7Z6b7Z6dXCJdLFxuW1wiY2FhMVwiLFwi5Ly95L2z5YGH5YO55Yqg5Y+v5ZG15ZOl5ZiJ5auB5a625pqH5p625p635p+v5q2M54+C55eC56i86Iub6IyE6KGX6KKI6Ki26LOI6LeP6Lu76L+m6aeV5Yi75Y205ZCE5oGq5oWk5q6854+P6ISa6Ka66KeS6Zaj5L6D5YiK5aK+5aW45aem5bmy5bm55oeH5o+A5p2G5p+s5qG/5r6X55mO55yL56O156iI56u/57Ch6IKd6Imu6Imx6Kur6ZaT5Lmr5Zad5pu35ri056Kj56ut6JGb6KSQ6J2O6Z6o5YuY5Z2O5aCq5bWM5oSf5oa+5oih5pWi5p+R5qmE5rib55SY55az55uj556w57S66YKv6ZGR6ZGS6b6VXCJdLFxuW1wiY2JhMVwiLFwi5Yyj5bKs55Sy6IOb6YmA6ZaY5Ymb5aCI5aec5bKh5bSX5bq35by65b2K5oW35rGf55W655aG57Og57Wz57ax576M6IWU6Iih6JaR6KWB6Kyb6Yu86ZmN6bGH5LuL5Lu35YCL5Yex5aGP5oS35oS+5oWo5pS55qeq5ryR55al55qG55uW566H6Iql6JOL76SA6Y6n6ZaL5ZaA5a6i5Z2R76SB57Kz57656Ya15YCo5Y675bGF5beo5ouS5o2u5pOa5pOn5rig54Ks56Wb6Led6Lie76SC6YG96YmF6Yu45Lm+5Lu25YGl5be+5bu65oSG5qWX6IWx6JmU6LmH6Y216air5Lme5YKR5p2w5qGA5YSJ5YqN5YqS5qqiXCJdLFxuW1wiY2NhMVwiLFwi55686YiQ6buU5Yqr5oCv6L+y5YGI5oap5o+t5pOK5qC85qqE5r+A6IaI6Kah6ZqU5aCF54m954qs55SE57W557mt6IKp6KaL6K206YGj6bWR5oqJ5rG65r2U57WQ57y66Kij5YW85oWK566d6KyZ6YmX6Y6M5Lqs5L+T5YCe5YK+5YSG5YuB5YuN5Y2/5Z2w5aKD5bqa5b6R5oW25oas5pOO5pWs5pmv5pq75pu05qKX5raH54KF54Ox55Kf55Kl55OK55eZ56Gs56Os56uf56u257WF57aT6ICV6IC/6ISb6I6W6K2m6LyV6YCV6Y+h6aCD6aC46ama6a+o5L+C5ZWT5aC65aWR5a2j5bGG5oK45oiS5qGC5qKwXCJdLFxuW1wiY2RhMVwiLFwi5qOo5rqq55WM55m456OO56i957O757mr57m86KiI6Kqh6LC/6ZqO6beE5Y+k5Y+p5ZGK5ZGx5Zu65aeR5a2k5bC75bqr5ou35pS35pWF5pWy5pqg5p6v5qeB5rK955e855qQ552+56i/576U6ICD6IKh6IaP6Ium6Iu96I+w6JeB6KCx6KK06Kql76SD6L6c6Yyu6ZuH6aGn6auY6byT5ZOt5pab5puy5qKP56mA6LC36bWg5Zuw5Z2k5bSR5piG5qKx5qON5ru+55Co6KKe6a+k5rGo76SE6aqo5L6b5YWs5YWx5Yqf5a2U5bel5oGQ5oGt5oux5o6n5pS754+Z56m66Jqj6LKi6Z6P5Liy5a+h5oiI5p6c55OcXCJdLFxuW1wiY2VhMVwiLFwi56eR6I+T6KqH6Kqy6Leo6YGO6Y2L6aGG5buT5qeo6Je/6YOt76SF5Yag5a6Y5a+s5oWj5qO65qy+54GM55Cv55OY566h572Q6I+F6KeA6LKr6Zec6aSo5Yiu5oGd5ous6YCC5L6K5YWJ5Yyh5aOZ5buj5pug5rS454Ka54uC54+W562Q6IOx6ZGb5Y2m5o6b572r5LmW5YKA5aGK5aOe5oCq5oSn5ouQ5qeQ6a2B5a6P57SY6IKx6L2f5Lqk5YOR5ZKs5Zas5ayM5bag5ben5pSq5pWO5qCh5qmL54uh55qO55+v57We57+56Iag6JWO6Juf6LyD6L2O6YOK6aSD6amV6a6r5LiY5LmF5Lmd5LuH5L+x5YW35Yu+XCJdLFxuW1wiY2ZhMVwiLFwi5Y2A5Y+j5Y+l5ZKO5ZiU5Z215Z6i5a+H5baH5buQ5oe85ouY5pWR5p645p+p5qeL5q2Q5q+G5q+s5rGC5rqd54G454uX546W55CD556/55+p56m257W/6ICJ6Ie86IiF6IiK6Iuf6KGi6Kyz6LO86LuA6YCR6YKx6Ymk6Yq26aeS6amF6bOp6beX6b6c5ZyL5bGA6I+K6Z6g6Z6r6bq05ZCb56qY576k6KOZ6LuN6YOh5aCA5bGI5o6Y56qf5a6u5byT56m556qu6IqO6Lqs5YCm5Yi45Yu45Y235ZyI5ouz5o2y5qyK5reD55y35Y6l542X6JWo6Lm26ZeV5py65quD5r2w6Kmt6LuM6aWL76SG5pm35q246LK0XCJdLFxuW1wiZDBhMVwiLFwi6ay876SH5Y+r5Zyt5aWO5o+G5qe754+q56GF56q656uF57O+6JG16KaP6LWz6YC16Zao5Yu75Z2H55WH562g6I+M6Yie76SI5qmY5YWL5YmL5YqH5oif5qOY5qW16ZqZ5YOF5Yqk5Yuk5oeD5pak5qC55qe/55G+562L6Iq56I+r6Kay6Ky56L+R6aWJ76SJ5LuK5aaX5pOS5piR5qqO55C056aB56a96Iqp6KG+6KG/6KWf76SK6Yym5LyL5Y+K5oCl5omx5rGy57Sa57Wm5LqY5YWi55+c6IKv5LyB5LyO5YW25YaA5Zec5Zmo5Zy75Z+65Z+85aSU5aWH5aaT5a+E5bKQ5bSO5bex5bm+5b+M5oqA5peX5pejXCJdLFxuW1wiZDFhMVwiLFwi5pye5pyf5p2e5qOL5qOE5qmf5qy65rCj5rG95rKC5reH546Y55Cm55Cq55KC55Kj55W455W/56KB56Ov56WB56WH56WI56W6566V57SA57a6576I6ICG6ICt6IKM6KiY6K2P6LGI6LW36Yyh6Yyk6aOi6aWR6aiO6aiP6aml6bqS57eK5L225ZCJ5ouu5qGU6YeR5Zar5YS676SL76SM5aic5oem76SN5ouP5ou/76SOXCIsNSxcIumCo++klFwiLDQsXCLoq77vpJnvpJrvpJvvpJzmmpbvpJ3nhZbvpJ7vpJ/pm6PvpKDmjY/mjbrljZfvpKHmno/mpaDmubPvpKLnlLfvpKPvpKTvpKVcIl0sXG5bXCJkMmExXCIsXCLntI3vpKbvpKfoobLlm4rlqJjvpKhcIiw0LFwi5LmD76St5YWn5aWI5p+w6ICQ76Su5aWz5bm05pKa56eK5b+15oGs5ouI5o275a+n5a+X5Yqq76Sv5aW05byp5oCS76Sw76Sx76Sy55GZ76SzXCIsNSxcIumnke+kuVwiLDEwLFwi5r+D76WE76WF6Ia/6L6y5oOx76WG76WH6IWm76WI76WJ5bC/76WKXCIsNyxcIuWrqeiopeadu+e0kO+lklwiLDUsXCLog73vpZjvpZnlsLzms6XljL/murrlpJrojLZcIl0sXG5bXCJkM2ExXCIsXCLkuLnkurbkvYbllq7lnJjlo4flvZbmlrfml6bmqoDmrrXmuY3nn63nq6/nsJ7nt57om4voopLphLLpjZvmkrvmvr7njbrnlrjpgZTllZblnY3mhrrmk5Tmm4fmt6HmuZvmva3mvrnnl7DogYPohr3olYHopoPoq4forZrpjJ/mspPnlZPnrZTouI/pgZ3llJDloILloZjluaLmiIfmkp7mo6Dnlbbns5bonrPpu6jku6Plnojlna7lpKflsI3lsrHluLblvoXmiLTmk6HnjrPoh7rooovosrjpmorpu5vlroXlvrfmgrPlgJLliIDliLDlnJbloLXloZflsI7lsaDls7bltovluqblvpLmgrzmjJHmjonmkJfmoYNcIl0sXG5bXCJkNGExXCIsXCLmo7nmq4Lmt5jmuKHmu5Tmv6Tnh77nm5znnbnnprHnqLvokITopqnos63ot7PouYjpgIPpgJTpgZPpg73pjY3pmbbpn5zmr5LngIbniZjniqLnjajnnaPnpr/nr6TnupvoroDloqnmg4fmlabml73mmr7msoznhJ7nh4nosZrpoJPkua3nqoHku53lhqzlh43li5XlkIzmhqfmnbHmoZDmo5/mtJ7mvbznlrznnrPnq6Xog7TokaPpioXlhZzmlpfmnZzmnpPnl5jnq4fojbPvpZrosYbpgJfpoK3lsa/oh4DoiprpgYHpga/piI3lvpfltp3mqZnnh4jnmbvnrYnol6TorITphKfpqLDllofmh7bvpZvnmannvoVcIl0sXG5bXCJkNWExXCIsXCLomL/onrroo7jpgo/vpZzmtJvng5nnj57ntaHokL3vpZ3pharpp7HvpZ7kuoLljbXmrITmrJLngL7niJvomK3puJ7liYzovqPltZDmk6XmlKzmrJbmv6vnsYPnupzol43opaTopr3mi4noh5jooJ/lu4rmnJfmtarni7znkIXnka/onoLpg57kvobltI3lvqDokIrlhrfmjqDnlaXkuq7lgIblhanlh4nmooHmqJHnsq7nsrHns6foia/oq5LovJvph4/kvrblhLfli7XlkYLlu6zmha7miL7ml4Xmq5rmv77npKrol5zooKPplq3pqaLpqarpupfpu47lipvmm4bmrbfngJ3npKvovaLpnYLmhpDmiIDmlKPmvKNcIl0sXG5bXCJkNmExXCIsXCLnhYnnkonnt7Toga/ok67ovKbpgKPpjYrlhr3liJfliqPmtIzng4joo4Llu4nmloLmrq7mv4LnsL7njbXku6TkvLblm7nvpZ/lsrrltrrmgJznjrLnrK3nvprnv47ogYbpgJ7piLTpm7bpnYjpoJjpvaHkvovmvqfnpq7phrTpmrfli57vpaDmkojmk4Tmq5PmvZ7ngJjniJDnm6fogIHomIbomZzot6/ovIXpnLLpra/pt7rpubXnooznpb/ntqDoj4npjITpub/pupPoq5blo5/lvITmnKfngKfnk4/nsaDogb7lhKHngKjniaLno4ros4Los5ros7Tpm7fkuoblg5rlr67lu5bmlpnnh47nmYLnnq3ogYrok7xcIl0sXG5bXCJkN2ExXCIsXCLpgbzprKfpvo3lo5jlqYHlsaLmqJPmt5rmvI/nmLvntK/nuLfolJ7opLjpj6TpmYvlionml5Lmn7PmprTmtYHmupzngI/nkInnkaDnlZnnmKTnoavorKzpoZ7lha3miK7pmbjkvpblgKvltJnmt6rntrjovKrlvovmhYTmoJfvpaHpmobli5Logovlh5zlh4zmpZ7nqJzntr7oj7HpmbXkv5rliKnljpjlkI/llI7lsaXmgqfmnY7moqjmtaznioHni7jnkIbnkoPvpaLnl6Lnsaznvbnnvrjojonoo4/oo6Hph4zph5Dpm6Lpr4nlkJ3mvb7nh5Dnkpjol7rouqrpmqPpsZfpup/mnpfmt4vnkLPoh6jpnJbnoKxcIl0sXG5bXCJkOGExXCIsXCLnq4vnrKDnspLmkannkarnl7Lnorzno6jppqzprZTpurvlr57luZXmvKDohpzojqvpgojkuIfljY3lqKnlt5LlvY7mhaLmjL3mmanmm7zmu7/mvKvngaPnnp7okKzolJPooLvovJPppYXpsLvllJzmirnmnKvmsqvojInoparpnbrkuqHlpoTlv5jlv5nmnJvntrLnvZToipLojKvojr3ovJ7pgpnln4vlprnlqpLlr5DmmKfmnprmooXmr4/nhaTnvbXosrfos6PpgoHprYXohIjosorpmYzpqYDpuqXlrZ/msJPnjJvnm7Lnm5/okIzlhqroppPlhY3lhpXli4nmo4nmspTnnITnnKDntr/nt6zpnaLpurXmu4VcIl0sXG5bXCJkOWExXCIsXCLolJHlhqXlkI3lkb3mmI7mmp3mpKfmup/nmr/nnpHojJfok4Lonp/phanpipjps7ToooLkvq7lhpLli5/lp4bluL3mhZXmkbjmkbnmmq7mn5DmqKHmr43mr5vniZ/niaHnkYHnnLjnn5vogJfoirzojIXorIDorKjosozmnKjmspDniafnm67nnabnqYbptqnmrb/mspLlpKLmnKbokpnlja/lopPlppnlu5/mj4/mmLTmnbPmuLrnjKvnq5foi5fpjKjli5nlt6vmhq7mh4vmiIrmi4fmkqvml6DmpZnmrabmr4vnhKHnj7fnlZ3nuYboiJ7ojILolaroqqPosr/pnKfptaHloqjpu5jlgJHliI7lkLvllY/mlodcIl0sXG5bXCJkYWExXCIsXCLmsbbntIrntIvogZ7omorploDpm6/li7/mspXnianlkbPlqprlsL7ltYvlvYzlvq7mnKrmorbmpaPmuLzmuYTnnInnsbPnvo7oloforI7ov7fpnaHpu7TlsrfmgrbmhI3mhqvmlY/ml7vml7zmsJHms6/njp/nj4nnt6HplpTlr4bonJzorJDliZ3ljZrmi43mkI/mkrLmnLTmqLjms4rnj4Dnkp7nrpTnspXnuJvohoroiLboloTov6vpm7npp4HkvLTljYrlj43lj5vmi4zmkKzmlIDmlpHmp4Pms67mvZjnj63nlZTnmKLnm6Tnm7zno5Dno7vnpKzntYboiKzon6Dov5TpoJLpo6/li4Pmi5TmkqXmuKTmvZFcIl0sXG5bXCJkYmExXCIsXCLnmbzot4vphrHpiaLpq67prYPlgKPlgo3lnYrlpqjlsKjluYflvbfmiL/mlL7mlrnml4HmmInmnovmppzmu4Lno4XntKHogqrohoDoiKvoirPokqHomozoqKrorJfpgqbpmLLpvpDlgI3kv7PvpaPln7nlvpjmi5zmjpLmna/muYPnhJnnm4Pog4zog5roo7Too7XopJnos6DovKnphY3pmarkvK/kvbDluJvmn4/moKLnmb3nmb7prYTluaHmqIrnhannh5TnlarvpaTnuYHolYPol6npo5zkvJDnrY/nvbDplqXlh6HluIbmorXmsL7msY7ms5vniq/nr4TojIPms5XnkLrlg7vliojlo4Hmk5jmqpfnkqfnmZZcIl0sXG5bXCJkY2ExXCIsXCLnoqfomJfpl6LpnLnvpaXljZ7lvIHororovqjovq/pgorliKXnnqXpsYnpvIjkuJnlgILlhbXlsZvlubfmmJ7mmLrmn4Tmo4XngrPnlIHnl4Xnp4nnq53ovKfppKDpqIjkv53loKHloLHlr7bmma7mraXmtJHmubrmvb3nj6TnlKvoj6noo5zopJPorZzovJTkvI/lg5XljJDljZzlrpPlvqnmnI3npo/ohbnojK/olJTopIfopobovLnovLvppqXpsJLmnKzkubbkv7jlpYnlsIHls6/ls7Dmjafmo5Lng73nhqLnkKvnuKvok6zonILpgKLpi5Lps7PkuI3ku5jkv6/lgoXliZblia/lkKblkpDln6DlpKvlqaZcIl0sXG5bXCJkZGExXCIsXCLlrZrlrbXlr4zlupzvpabmibbmlbfmlqfmta7muqXniLbnrKbnsL/nvLbohZDohZHohproiYDoipnojqnoqIPosqDos6bos7votbTotrrpg6jph5zpmJzpmYTpp5nps6fljJfliIblkKnlmbTlorPlpZTlpa7lv7/mhqTmia7mmJDmsb7nhJrnm4bnsonns57ntJvoiqzos4Hpm7DvpafkvZvlvJflvb/mi4LltKnmnIvmo5rnobznuYPptazkuJXlgpnljJXljKrljZHlpoPlqaLluofmgrLmhormiYnmibnmlpDmnofmpqfmr5Tmr5bmr5fmr5jmsrjvpajnkLXnl7rnoJLnopHnp5Xnp5jnsoPnt4vnv6HogqVcIl0sXG5bXCJkZWExXCIsXCLohL7oh4Loj7LonJroo6joqrnorazosrvphJnpnZ7po5vpvLvlmqzlrKrlvazmlozmqrPmrq/mtZzmv7HngJXniZ3njq3osqfos5PpoLvmhpHmsLfogZjpqIHkuY3kuovkupvku5XkvLrkvLzkvb/kv5/lg7/lj7Llj7jllIbll6Plm5vlo6vlpaLlqJHlr6vlr7rlsITlt7PluKvlvpnmgJ3mjajmlpzmlq/mn7bmn7vmoq3mrbvmspnms5fmuKPngInnjYXnoILnpL7npYDnpaDnp4Hnr6nntJfntbLogoboiI3ojo7ok5Hom4foo5/oqZDoqZ7orJ3os5zotabovq3pgqrpo7zpp5/pup3liYrvpanmnJTvpapcIl0sXG5bXCJkZmExXCIsXCLlgpjliKrlsbHmlaPmsZXnj4rnlKPnlp3nrpfokpzphbjpnLDkubfmkpLmrrrnhZ7olqnkuInvpavmnYnmo67muJfoip/olJjooavmj7fmvoHpiJLpoq/kuIrlgrflg4/lhJ/llYbllqrlmJflrYDlsJnls6DluLjluorluqDlu4Lmg7PmoZHmqaHmuZjniL3niYDni4Dnm7jnpaXnrrHnv5Too7Pop7ToqbPosaHos57pnJzloZ7nkr3os73ll4fvpaznqaHntKLoibLnibLnlJ/nlKXvpa3nrJnlooXlo7vltrzluo/lurblvpDmgZXmipLmjb/mlY3mmpHmm5nmm7jmoJbmo7LnioDnkZ7nra7nta7nt5bnvbJcIl0sXG5bXCJlMGExXCIsXCLog6XoiJLolq/opb/oqpPpgJ3pi6Tpu43pvKDlpJXlpa3luK3mg5zmmJTmmbPmnpDmsZDmt4XmvZ/nn7Pnoqnok4bph4vpjKvku5nlg4rlhYjlloTlrIvlrqPmiYfmlb7ml4vmuLLnhb3nkIHnkYTnkofnkr/nmaznpqrnt5rnuZXnvqjohbrohrPoiLnomJron6zoqbXot6PpgbjpipHpkKXppY3prq7ljajlsZHmpZTms4TmtKnmuKvoiIzolpvopLvoqK3oqqrpm6rpvafliaHmmrnmrrLnupbon77otI3ploPpmZ3mlJ3mtonnh67vpa7ln47lp5PlrqzmgKfmg7rmiJDmmJ/mmZ/njKnnj7nnm5vnnIHnraxcIl0sXG5bXCJlMWExXCIsXCLogZbogbLohaXoqqDphpLkuJbli6LmrbLmtJfnqIXnrLnntLDvpa/osrDlj6zlmK/loZHlrrXlsI/lsJHlt6LmiYDmjoPmkJTmmK3morPmsrzmtojmuq/ngJ/ngqTnh5LnlKbnlo/nlo7nmJnnrJHnr6DnsKvntKDntLnolKzola3omIfoqLTpgI3pgaHpgrXpirfpn7bpqLfkv5flsazmnZ/mtpHnsp/nuozorJbotJbpgJ/lravlt73mkI3ok4DpgZzpo6Hnjoflrovmgprmnb7mt57oqJ/oqqbpgIHpoIzliLfvpbDngZHnoo7pjpboobDph5fkv67lj5fll73lm5rlnoLlo73lq4Llrojlsqvls4DluKXmhIFcIl0sXG5bXCJlMmExXCIsXCLmiI3miYvmjojmkJzmlLbmlbjmqLnmrormsLTmtJnmvLHnh6fni6nnjbjnkIfnkrLnmKbnnaHnp4DnqZfnq6rnsrnnto/ntqznuaHnvp7ohKnojLHokpDok5rol6roopboqrDorpDovLjpgYLpgoPphazpipbpirnpmovpmqfpmqjpm5bpnIDpoIjpppbpq5PprJrlj5Tlob7lpJnlrbDlrr/mt5HmvZrnhp/nkKHnkrnogoXoj73lt6HlvoflvqrmgYLml6zmoJLmpa/mqZPmronmtLXmt7Pnj6Pnm77nnqznrY3ntJTohKPoiJzojYDok7TolaPoqaLoq4TphofpjJ7poIbpprTmiIzooZPov7DpiaXltIfltKdcIl0sXG5bXCJlM2ExXCIsXCLltannkZ/ohp3onajmv5Xmi77nv5LopLbopbLkuJ7kuZjlg6fli53ljYfmib/mmIfnuanooIXpmZ7kvo3ljJnlmLblp4vlqqTlsLjlsY7lsY3luILlvJHmgYPmlr3mmK/mmYLmnr7mn7TnjJznn6LnpLrnv4XokpTok43oppboqaboqanoq6HosZXosbrln7Tlr5TlvI/mga/mi63mpI3mrpbmuZznhoTnr5LonZXorZjou77po5/po77kvLjkvoHkv6HlkbvlqKDlrrjmhLzmlrDmmajnh7znlLPnpZ7ntLPohY7oh6Pojpjolqrol47onIPoqIrouqvovpvvpbHov4XlpLHlrqTlr6bmgonlr6nlsIvlv4PmsoFcIl0sXG5bXCJlNGExXCIsXCLvpbLmt7HngIvnlJroiq/oq7bku4DljYHvpbPpm5nmsI/kup7kv4TlhZLllZ7lqKXls6jmiJHniZnoir3ojqrom77ooZnoqJ3pmL/pm4XppJPptInptZ3loIrlsrPltr3luYTmg6HmhJXmj6HmqILmuKXphILpjZTpoY7psJDpvbflronlsrjmjInmmY/moYjnnLzpm4Hpno3poZTprp/mlqHorIHou4vplrzllLXlsqnlt5blurXmmpfnmYzoj7Tpl4flo5Pmirzni47ptKjku7DlpK7mgI/mmLvmroPnp6fptKbljpPlk4Dln4PltJbmhJvmm5bmtq/noo3oib7pmpjpnYTljoTmibzmjpbmtrLnuIrohYvpoY1cIl0sXG5bXCJlNWExXCIsXCLmq7vnvYzptq/puJrkuZ/lgLvlhrblpJzmg7nmj7bmpLDniLrogLbvpbTph47lvLHvpbXvpbbntIToi6Xoka/okrvol6Xouo3vpbfkva/vpbjvpbnlo6TlrYPmgZnmj5rmlJjmla3mmpjvpbrmpYrmqKPmtIvngIHnhaznl5LnmI3nprPnqbDvpbvnvorvpbzopYTvpb3orpPph4Dpmb3vpb7ppIrlnITlvqHmlrzmvIHnmIDnpqboqp7ppq3prZrpvazlhITmhrbmipHmqo3oh4blgYPloLDlvabnhInoqIDoq7rlrbzomJbkv7rlhLzlmrTlpYTmjqnmt7nltqrmpa3lhobkuojkvZnvpb/vpoDvpoHlpoLvpoJcIl0sXG5bXCJlNmExXCIsXCLvpoPmrZ/msZ3vpoTnkrXnpJbvpoXoiIfoiYXojLnovL/ovZ3vpobppJjvpofvpojvponkuqbvporln5/lvbnmmJPvpovvpoznlqvnubnora/vpo3pgIbpqZvlmqXloKflp7jlqJ/lrrTvpo7lu7bvpo/vppDmjZDmjLvvppHmpL3msofmsr/mto7mtpPmt7XmvJTvppLng5/nhLbnhZnvppPnh4Pnh5XvppTnoY/noa/vppXnrbXnt6PvppbnuK/vppfooY3ou5/vppjvppnvpprpiZvvppvps7bvppzvpp3vpp7mgoXmtoXvpp/nhrHvpqDvpqHplrHljq3vpqLvpqPvpqTmn5PvpqXngo7nhLDnkLDoibboi5JcIl0sXG5bXCJlN2ExXCIsXCLvpqbplrvpq6Xpub3mm4Tvpqfnh4HokYnvpqjvpqnloYvvpqrvpqvltrjlvbHvpqzmmKDmmo7mpbnmpq7msLjms7PmuLbmvYHmv5rngJvngK/nhZDnh5/njbDvpq3nkZvvpq7nk5Tnm4jnqY7nupPvpq/vprDoi7HoqaDov47vprHpjYjvprLpnJnvprPvprTkuYLlgKrvprXliIjlj6Hmm7Pmsa3mv4rnjIrnnb/nqaLoiq7ol53omILvprboo5ToqaPorb3osavvprfpirPvprjpnJPpoJDkupTkvI3kv4nlgrLljYjlkL7lkLPll5rloaLlorrlpaflqJvlr6Tmgp/vprnmh4rmlZbml7/mmaTmoqfmsZrmvrNcIl0sXG5bXCJlOGExXCIsXCLng4/nhqznjZLnrb3onIjoqqTpsLLpvIflsYvmsoPnjYTnjonpiLrmuqvnkaXnmJ/nqannuJXomIrlhYDlo4Xmk4Hnk67nlJXnmbDnv4HpgpXpm43ppZTmuKbnk6bnqqnnqqroh6Xom5nonbjoqJvlqYnlrozlrpvmoqHmpIDmtaPnjqnnkJPnkKznopfnt6nnv6vohJjohZXojp7osYzpmK7poJHmm7DlvoDml7rmnonmsarnjovlgK3lqIPmrarnn67lpJbltazlt43njKXnlY/vprrvprvlg6Xlh7nloK/lpK3lppblp5rlr6Xvprzvpr3ltqLmi5fmkJbmkpPmk77vpr7mm5zvpr/mqYjvp4Dnh7/nkaTvp4FcIl0sXG5bXCJlOWExXCIsXCLnqojnqq/nuYfnuZ7ogIDohbDvp4Lon6/opoHorKDpgZnvp4PpgoDppZLmhb7mrLLmtbTnuJ/opKXovrHkv5Hlgq3lhpfli4fln4floonlrrnlurjmhYLmppXmtozmuafmurbnhpTnkaLnlKjnlKzogbPojLjok4nouIrpjpTpj57vp4Tkuo7kvZHlgbblhKrlj4jlj4vlj7Plroflr5PlsKTmhJrmhoLml7TniZvnjpfnkYDnm4LnpZDnppHnprnntIbnvr3oiovol5XomZ7ov4LpgYfpg7Xph6rpmoXpm6jpm6nli5blvafml63mmLHmoK/nhZznqLbpg4HpoIrkupHvp4XmqZLmrp7mvpDnhonogJjoirjolZNcIl0sXG5bXCJlYWExXCIsXCLpgYvpmpXpm7Lpn7volJrprLHkupDnhorpm4TlhYPljp/lk6HlnJPlnJLlnqPlqpvlq4Tlr4PmgKjmhL/mj7TmsoXmtLnmubLmupDniLDnjL/nkZfoi5HoooHovYXpgaDvp4bpmaLpoZjptJvmnIjotorpiZ7kvY3lgYnlg57ljbHlnI3lp5TlqIHlsInmhbDmmpDmuK3niLLnkYvnt6/og4PokI7okabolL/onZ/ooZvopJjorILpgZXpn4vprY/kubPkvpHlhJLlharvp4fllK/llqnlrbrlrqXlubzlub3lur7mgqDmg5/mhIjmhInmj4TmlLjmnInvp4jmn5Tmn5rvp4nmpaHmpaLmsrnmtKfvp4rmuLjvp4tcIl0sXG5bXCJlYmExXCIsXCLmv6HnjLbnjLfvp4znkZznlLHvp43nmZLvp47vp4/ntq3oh77okLjoo5Xoqpjoq5voq63ouLDouYLpgYrpgL7pgbrphYnph4npja7vp5Dvp5HloInvp5Lmr5PogonogrLvp5Pvp5TlhYHlpavlsLnvp5Xvp5bmvaTnjqfog6TotIfvp5fpiJfplo/vp5jvp5nvp5rvp5vogb/miI7ngJzntajono3vp5zlnqDmganmhYfmrrfoqr7pioDpmrHkuZnlkJ/mt6volK3pmbDpn7Ppo67mj5bms6PpgpHlh53mh4nohrrpt7nkvp3lgJrlhIDlrpzmhI/mh7/mk6zmpIXmr4XnlpHnn6PnvqnoiaTolo/on7vooaPoqrxcIl0sXG5bXCJlY2ExXCIsXCLorbDphqvkuozku6XkvIrvp53vp57lpLflp6jvp5/lt7LlvJvlvZvmgKHvp6Dvp6Hvp6Lvp6PniL7nj6Xvp6TnlbDnl43vp6Xnp7vvp6bogIzogLPogoToi6HojZHvp6fvp6josr3osrPpgofvp6nvp6rpo7TppIzvp6vvp6zngLfnm4rnv4rnv4znv7zorJrkurrku4HliIPljbDvp63lkr3lm6Dlp7vlr4XlvJXlv43mua7vp67vp6/ntarojLXvp7DompPoqo3vp7Hpna3pnbfvp7Lvp7PkuIDkvZrkvb7lo7nml6XmuqLpgLjpjrDpprnku7vlo6zlporlp5nmgYHvp7Tvp7XnqJTvp7bojY/os4PlhaXljYRcIl0sXG5bXCJlZGExXCIsXCLvp7fvp7jvp7nku43lianlrZXoir/ku5TliLrlkqjlp4nlp7/lrZDlrZflrZzmgaPmhYjmu4vngpnnha7njobnk7fnlrXno4HntKvogIXoh6rojKjolJfol4noq67os4fpm4zkvZzli7rlmrzmlqvmmKjngbzngrjniLXntr3oio3phYzpm4DptbLlrbHmo6fmrpjmvbrnm57lspHmmqvmvZvnrrTnsKrooLbpm5zkuIjku5fljKDloLTlorvlo6/lpazlsIfluLPluoTlvLXmjozmmrLmnZbmqJ/mqqPmrIzmvL/niYbvp7rnjZDnkovnq6Dnsqfohbjoh5/oh6fojorokazolKPolpTol4/oo53otJPphqzplbdcIl0sXG5bXCJlZWExXCIsXCLpmpzlho3lk4nlnKjlrrDmiY3mnZDmoL3mopPmuL3mu5Pngb3nuKHoo4HosqHovInpvYvpvY7niK3nro/oq43pjJrkvYfkvY7lhLLlkoDlp5DlupXmirXmnbXmpa7mqJfmsq7muJrni5nnjKrnlr3nrrjntLXoi6foj7nokZfol7foqZvosq/ouofpgJnpgrjpm47pvZ/li6PlkIrlq6Hlr4LmkZjmlbXmu7Tni4Tvp7vnmoTnqY3nrJvnsY3nuL7nv5/ojbvorKvos4rotaTot6HouZ/ov6rov7npganpj5HkvYPkvbrlgrPlhajlhbjliY3liarloaHlobzlpaDlsIjlsZXlu5vmgpvmiLDmoJPmrr/msIjmvrFcIl0sXG5bXCJlZmExXCIsXCLnhY7nkKDnlLDnlLjnlZHnmbLnrYznrovnrq3nr4bnuo/oqa7ovL7ovYnpiL/pipPpjKLpkKvpm7vpoZrpoavppJ7liIfmiKrmipjmtZnnmaTnq4rnr4DntbbljaDlsr7lupfmvLjngrnnspjpnJHpro7pu57mjqXmkbronbbkuIHkupXkuq3lgZzlgbXlkYjlp4PlrprluYDluq3lu7flvoHmg4XmjLrmlL/mlbTml4zmmbbmmbjmn77mpajmqonmraPmsYDmt4Dmt6jmuJ/muZ7ngJ7ngqHnjo7nj73nlLrnnZvnoofnpo7nqIvnqb3nsr7nto7oiYfoqILoq6rosp7phK3phYrph5jpiabpi4zpjKDpnIbpnZZcIl0sXG5bXCJmMGExXCIsXCLpnZzpoILpvI7liLblipHllbzloKTluJ3lvJ/mgozmj5Dmoq/mv5/npa3nrKzoh43olrroo73oq7jouYTpho3pmaTpmpvpnL3poYzpvYrkv47lhYblh4vliqnlmLLlvJTlvavmjqrmk43ml6nmmYHmm7rmm7nmnJ3mop3mo5fmp73mvJXmva7nhafnh6XniKrnkqrnnLrnpZbnpZrnp5/nqKDnqpXnspfns5/ntYTnubDogofol7vomqToqZToqr/otpnouoHpgKDpga3ph6PpmLvpm5Xps6Xml4/nsIfotrPpj4PlrZjlsIrljZLmi5nnjJ3lgKflrpflvp7mgrDmhavmo5Xmt5nnkK7nqK7ntYLntpznuLHohatcIl0sXG5bXCJmMWExXCIsXCLouKrouLXpjb7pkJjkvZDlnZDlt6bluqfmjKvnvarkuLvkvY/kvo/lgZrlp53og4Tlkarlkajll77lpY/lrpnlt57lu5rmmZ3mnLHmn7HmoKrms6jmtLLmuYrmvo3ngrfnj6DnlofnsYzntILntKzntqLoiJ/om5voqLvoqoXotbDouorovLPpgLHphY7phZLpkYTpp5Dnq7nnsqXkv4rlhIHlh4bln4jlr6/ls7vmmZnmqL3mtZrmupbmv6znhIznla/nq6PooKLpgKHpgbXpm4vpp7/ojIHkuK3ku7LooYbph43ljb3mq5vmpavmsYHokbrlop7mho7mm77mi6/ng53nlJHnl4fnuZLokrjorYnotIjkuYvlj6pcIl0sXG5bXCJmMmExXCIsXCLlkqvlnLDlnYDlv5fmjIHmjIfmka/mlK/ml6jmmbrmnp3mnrPmraLmsaDmsprmvKznn6XnoKXnpYnnpZfntJnogqLohILoh7Poip3oirfonJjoqozvp7zotITotr7pgbLnm7TnqJnnqLfnuZTogbfllIfll5TlobXmjK/mkKLmmYnmmYvmoa3mppvmroTmtKXmurHnj43nkajnkqHnlZvnlrnnm6HnnJ7nnovnp6bnuInnuJ3oh7volK/oopfoqLros5Hou6vovrDpgLLpjq3pmaPpmbPpnIfkvoTlj7Hlp6rlq4nluJnmoY7nk4bnlr7np6nnqpLohqPom63os6rot4zov63mlp/mnJXvp73ln7fmvZfnt53ovK9cIl0sXG5bXCJmM2ExXCIsXCLpj7bpm4blvrXmh7LmvoTkuJTkvpjlgJ/lj4nll5/lta/lt67mrKHmraTno4vnrprvp77ouYnou4rpga7mjYnmkL7nnYDnqoTpjK/pkb/pvarmkrDmvq/nh6bnkqjnk5rnq4TnsJLnuoLnsrLnupjorprotIrpkb3ppJDppYzliLnlr5/mk6bmnK3ntK7lg63lj4PlobnmhZjmhZnmh7rmlqznq5norpLorpblgInlgKHlibXllLHlqLzlu6DlvbDmhLTmlZ7mmIzmmLbmmqLmp43mu4TmvLLnjJbnmKHnqpPohLnoiZnoj5bokrzlgrXln7Dlr4Dlr6jlvanmjqHnoKbntrXoj5zolKHph4fph7Xlhormn7XnrZZcIl0sXG5bXCJmNGExXCIsXCLosqzlh4Tlprvmgr3omZXlgJzvp7/liZTlsLrmhb3miJrmi5Pmk7LmlqXmu4znmKDohIrouaDpmZ/pmrvku5/ljYPllpjlpKnlt53mk4Xms4nmt7rnjpTnqb/oiJvolqbos6TouJDpgbfph6fpl6HpmKHpn4blh7jlk7LlloblvrnmkqTmvojntrTovJ/ovY3pkLXlg4nlsJbmsr7mt7vnlJvnnrvnsL3nsaToqbnoq4LloJ7lpr7luJbmjbfniZLnlornnavoq5zosrzovJLlu7PmmbTmt7jogb3oj4Hoq4vpnZHpr5bvqIDliYPmm7/mtpXmu6/nt6Doq6bpgK7pgZ7pq5TliJ3lib/lk6jmhpTmioTmi5vmoqJcIl0sXG5bXCJmNWExXCIsXCLmpJLmpZrmqLXngpLnhKbnoZ3npIHnpI7np5LnqI3ogpboibjoi5XojYnolYnosoLotoXphaLphovphq7kv4Plm5Hnh63nn5fonIDop7jlr7jlv5bmnZHpgqjlj6LloZrlr7XmgqTmhoHmkaDnuL3ogbDolKXpioPmkq7lgqzltJTmnIDlopzmir3mjqjmpI7mpbjmqJ7muavnmrrnp4voirvokKnoq4/otqjov73phJLphYvphpzpjJDpjJjpjprpm5vpqLbpsI3kuJHnlZznpZ3nq7rnrZHnr4nnuK7ok4TouZnoubTou7jpgJDmmKXmpL/nkYPlh7rmnK7pu5zlhYXlv6Dmspbon7LooZ3oobfmgrTohrXokINcIl0sXG5bXCJmNmExXCIsXCLotIXlj5blkLnlmLTlqLblsLHngornv6DogZrohIboh63otqPphonpqZ/pt7LlgbTku4TljqDmg7vmuKzlsaTkvojlgKTll6Tls5nluZ/mgaXmopTmsrvmt4Tnhr7nl5Tnl7TnmaHnqJrnqYnnt4fnt7vnva7oh7TomqnovJzpm4npprPpvZLliYfli4Xpo63opqrkuIPmn5LmvIbkvrXlr6LmnpXmsojmtbjnkJvnoKfph53pjbzon4Tnp6TnqLHlv6vku5blkqTllL7loq7lpqXmg7DmiZPmi5bmnLbmpZXoiLXpmYDpprHpp53lgKzljZPllYTlnbzvqIHmiZjvqILmk6Lmmavmn53mv4Hmv6/nkKLnkLjoqJdcIl0sXG5bXCJmN2ExXCIsXCLpkLjlkZHlmIblnablvYjmhprmrY7ngZjngq3ntrvoqpXlparohKvmjqLnnIjogL3osqrloZTmkK3mprvlrpXluJHmua/vqIPolanlhYzlj7DlpKrmgKDmhYvmrobmsbDms7DnrJ7og47oi5Tot4bpgrDporHvqITmk4fmvqTmkpHmlITlhY7lkJDlnJ/oqI7mhZ/mobbvqIXnl5vnrZLntbHpgJrloIbmp4zohb/opKrpgIDpoLnlgbjlpZflpqzmipXpgI/prKrmhZ3nibnpl5blnaHlqYblt7Tmiormkq3mk7rmnbfms6LmtL7niKznkLbnoLTnvbfoiq3ot5vpoJfliKTlnYLmnb/niYjnk6PosqnovqbpiJFcIl0sXG5bXCJmOGExXCIsXCLpmKrlhavlj63mjYzkvanllITmgpbmlZfmspvmtb/niYzni73nqJfopofosp3lva3mvo7ng7nohqjmhI7kvr/lgY/miYHniYfnr4fnt6jnv6npgY3pnq3pqJnosrblnarlubPmnrDokI3oqZXlkKDlrJbluaPlu6LlvIrmloPogrrolL3plonpmZvkvYjljIXljI3ljI/lkoblk7rlnIPluIPmgJbmipvmirHmjZXvqIbms6HmtabnlrHnoLLog57ohK/oi57okaHokrLooo3opJLpgIvpi6rpo73prpHluYXmmrTmm53ngJHniIbvqIfkv7Xlib3lvarmhZPmnZPmqJnmvILnk6Lnpajooajosbnpo4fpo4TpqYNcIl0sXG5bXCJmOWExXCIsXCLlk4HnqJ/mpZPoq7fosYrpoqjppq7lvbzmiqvnlrLnmq7ooqvpgb/pmYLljLnlvLzlv4Xms4znj4znlaLnlovnrYboi77ppp3kuY/pgLzkuIvkvZXljqblpI/lu4jmmLDmsrPnkZXojbfonabos4DpgZDpnJ7psJXlo5HlrbjomZDorJTptrTlr5Lmgajmgo3ml7HmsZfmvKLmvqPngJrnvZXnv7DplpHplpLpmZDpn5PlibLovYTlh73lkKvlkrjllaPllormqrvmtrXnt5joiabpipzpmbfpubnlkIjlk4jnm5Lom6TplqTpl5TpmZzkuqLkvInlp67lq6blt7fmgZLmipfmna3moYHmsobmuK/nvLjogpvoiKpcIl0sXG5bXCJmYWExXCIsXCLvqIjvqInpoIXkuqXlgZXlkrPlnpPlpZrlranlrrPmh4jmpbfmtbfngKPon7nop6PoqbLoq6fpgoLpp63pqrjlir7moLjlgJblubjmnY/ojYfooYzkuqvlkJHlmq7nj6bphJXpn7/ppInppZfpppnlmZPlop/omZvoqLHmhrLmq7bnjbvou5LmrYfpmqrpqZflpZXniIDotavpnankv5Tls7TlvKbmh7jmmZvms6vngqvnjoTnjrnnj77nnKnnnY3ntYPntaLnuKPoiLfooZLvqIros6LpiYnpoa/lrZHnqbTooYDpoIHlq4zkv6DljZTlpL7ls73mjL7mtbnni7nohIXohIfojqLpi4/poLDkuqjlhYTliJHlnotcIl0sXG5bXCJmYmExXCIsXCLlvaLms4Lmu47ngIXngZDngq/nhpLnj6nnkanojYronqLooaHpgIjpgqLpjqPppqjlha7lvZfmg6DmhafmmrPolZnouYrphq/pnovkuY7kupLlkbzlo5Xlo7rlpb3lsrXlvKfmiLbmiYjmmIrmmafmr6vmtanmt4/muZbmu7jmvpTmv6Dmv6nngZ3ni5DnkKXnkZrnk6DnmpPnpZzns4rnuJ7og6Hoiqbokavokr/omY7omZ/onbTorbfosarpjqzpoIDpoaXmg5HmiJbphbflqZrmmI/mt7fmuL7nkL/prYLlv73mg5rnrI/lk4TlvJjmsZ7ms5PmtKrng5jntIXombnoqIzptLvljJblkozlrIXmqLrngavnlbVcIl0sXG5bXCJmY2ExXCIsXCLnpo3npr7oirHoj6/oqbHorYHosqjpnbTvqIvmk7TmlKvnorrnorvnqavkuLjllprlpZDlrqblubvmgqPmj5vmraHmmaXmoZPmuJnnhaXnkrDntIjpgoTpqanpsKXmtLvmu5HnjL7osYHpl4rlh7DluYzlvqjmgY3mg7bmhLDmhYzmmYPmmYTmpqXms4HmuZ/mu4nmvaLnhYznkpznmofnr4HnsKfojZLonZfpgZHpmo3pu4PljK/lm57lu7vlvormgaLmgpTmh7fmmabmnIPmqpzmt67mvq7ngbDnjarnuarohr7ojLTom5Toqqjos4TlioPnjbLlrpbmqavpkITlk67lmoblrZ3mlYjmloXmm4nmop/mto3mt4ZcIl0sXG5bXCJmZGExXCIsXCLniLvogrTphbXpqY3kvq/lgJnljprlkI7lkLzllonll4XluL/lvozmnL3nhabnj53pgIXli5vli7PloaTlo47nhITnho/nh7volrDoqJPmmojolqjllqfmmoTnhYrokLHljYnllpnmr4HlvZnlvr3mj67mmonnhYfoq7HovJ3pur7kvJHmkLrng4vnlabomafmgaTorY7pt7jlhYflh7bljIjmtLbog7jpu5HmmJXmrKPngpjnl5XlkIPlsbnntIfoqJbmrKDmrL3mrYblkLjmgbDmtL3nv5XoiIjlg5blh57llpzlmavlm43lp6zlrInluIzmhpnmhpjmiLHmmZ7mm6bnhpnnhrnnhrrniqfnpqfnqIDnvrLoqbBcIl1cbl1cbiIsIm1vZHVsZS5leHBvcnRzPVtcbltcIjBcIixcIlxcdTAwMDBcIiwxMjddLFxuW1wiYTE0MFwiLFwi44CA77yM44CB44CC77yO4oCn77yb77ya77yf77yB77iw4oCm4oCl77mQ77mR77mSwrfvuZTvuZXvuZbvuZfvvZzigJPvuLHigJTvuLPilbTvuLTvuY/vvIjvvInvuLXvuLbvvZvvvZ3vuLfvuLjjgJTjgJXvuLnvuLrjgJDjgJHvuLvvuLzjgIrjgIvvuL3vuL7jgIjjgInvuL/vuYDjgIzjgI3vuYHvuYLjgI7jgI/vuYPvuYTvuZnvuZpcIl0sXG5bXCJhMWExXCIsXCLvuZvvuZzvuZ3vuZ7igJjigJnigJzigJ3jgJ3jgJ7igLXigLLvvIPvvIbvvIrigLvCp+OAg+KXi+KXj+KWs+KWsuKXjuKYhuKYheKXh+KXhuKWoeKWoOKWveKWvOOKo+KEhcKv77+j77y/y43vuYnvuYrvuY3vuY7vuYvvuYzvuZ/vuaDvuaHvvIvvvI3Dl8O3wrHiiJrvvJzvvJ7vvJ3iiabiiafiiaDiiJ7iiZLiiaHvuaJcIiw0LFwi772e4oip4oiq4oql4oig4oif4oq/44+S44+R4oir4oiu4oi14oi04pmA4pmC4oqV4oqZ4oaR4oaT4oaQ4oaS4oaW4oaX4oaZ4oaY4oil4oij77yPXCJdLFxuW1wiYTI0MFwiLFwi77y84oiV77mo77yE77+l44CS77+g77+h77yF77yg4oSD4oSJ77mp77mq77mr44+V446c446d446e44+O446h446O446P44+EwrDlhZnlhZvlhZ7lhZ3lhaHlhaPll6fnk6nns47iloFcIiw3LFwi4paP4paO4paN4paM4paL4paK4paJ4pS84pS04pSs4pSk4pSc4paU4pSA4pSC4paV4pSM4pSQ4pSU4pSY4pWtXCJdLFxuW1wiYTJhMVwiLFwi4pWu4pWw4pWv4pWQ4pWe4pWq4pWh4pei4pej4pel4pek4pWx4pWy4pWz77yQXCIsOSxcIuKFoFwiLDksXCLjgKFcIiw4LFwi5Y2B5Y2E5Y2F77yhXCIsMjUsXCLvvYFcIiwyMV0sXG5bXCJhMzQwXCIsXCLvvZfvvZjvvZnvvZrOkVwiLDE2LFwizqNcIiw2LFwizrFcIiwxNixcIs+DXCIsNixcIuOEhVwiLDEwXSxcbltcImEzYTFcIixcIuOEkFwiLDI1LFwiy5nLicuKy4fLi1wiXSxcbltcImEzZTFcIixcIuKCrFwiXSxcbltcImE0NDBcIixcIuS4gOS5meS4geS4g+S5g+S5neS6huS6jOS6uuWEv+WFpeWFq+WHoOWIgOWIgeWKm+WMleWNgeWNnOWPiOS4ieS4i+S4iOS4iuS4q+S4uOWHoeS5heS5iOS5n+S5nuS6juS6oeWFgOWIg+WLuuWNg+WPieWPo+Wcn+Wjq+WkleWkp+Wls+WtkOWtkeWtk+WvuOWwj+WwouWwuOWxseW3neW3peW3seW3suW3s+W3vuW5suW7vuW8i+W8k+aJjVwiXSxcbltcImE0YTFcIixcIuS4keS4kOS4jeS4reS4sOS4ueS5i+WwueS6iOS6keS6leS6kuS6lOS6ouS7geS7gOS7g+S7huS7h+S7jeS7iuS7i+S7hOWFg+WFgeWFp+WFreWFruWFrOWGl+WHtuWIhuWIh+WIiOWLu+WLvuWLv+WMluWMueWNiOWNh+WNheWNnuWOhOWPi+WPiuWPjeWjrOWkqeWkq+WkquWkreWtlOWwkeWwpOWwuuWxr+W3tOW5u+W7v+W8lOW8leW/g+aIiOaItuaJi+aJjuaUr+aWh+aWl+aWpOaWueaXpeabsOaciOacqOasoOatouatueavi+avlOavm+awj+awtOeBq+eIqueItueIu+eJh+eJmeeJm+eKrOeOi+S4mVwiXSxcbltcImE1NDBcIixcIuS4luS4leS4lOS4mOS4u+S5jeS5j+S5juS7peS7mOS7lOS7leS7luS7l+S7o+S7pOS7meS7nuWFheWFhOWGieWGiuWGrOWHueWHuuWHuOWIiuWKoOWKn+WMheWMhuWMl+WMneS7n+WNiuWNieWNoeWNoOWNr+WNruWOu+WPr+WPpOWPs+WPrOWPruWPqeWPqOWPvOWPuOWPteWPq+WPpuWPquWPsuWPseWPsOWPpeWPreWPu+Wbm+WbmuWkllwiXSxcbltcImE1YTFcIixcIuWkruWkseWltOWltuWtleWug+WwvOW3qOW3p+W3puW4guW4g+W5s+W5vOW8geW8mOW8l+W/heaIiuaJk+aJlOaJkuaJkeaWpeaXpuacruacrOacquacq+acreato+avjeawkeawkOawuOaxgeaxgOawvueKr+eOhOeOieeTnOeTpueUmOeUn+eUqOeUqeeUsOeUseeUsueUs+eWi+eZveearueav+ebruefm+efouefs+ekuuemvueptOeri+S4nuS4n+S5kuS5k+S5qeS6meS6pOS6puS6peS7v+S8ieS8meS8iuS8leS8jeS8kOS8keS8j+S7suS7tuS7u+S7sOS7s+S7veS8geS8i+WFieWFh+WFhuWFiOWFqFwiXSxcbltcImE2NDBcIixcIuWFseWGjeWGsOWIl+WIkeWIkuWIjuWIluWKo+WMiOWMoeWMoOWNsOWNseWQieWQj+WQjOWQiuWQkOWQgeWQi+WQhOWQkeWQjeWQiOWQg+WQjuWQhuWQkuWboOWbnuWbneWcs+WcsOWcqOWcreWcrOWcr+WcqeWkmeWkmuWkt+WkuOWmhOWluOWmg+WlveWlueWmguWmgeWtl+WtmOWuh+WuiOWuheWuieWvuuWwluWxueW3nuW4huW5tuW5tFwiXSxcbltcImE2YTFcIixcIuW8j+W8m+W/meW/luaIjuaIjOaIjeaIkOaJo+aJm+aJmOaUtuaXqeaXqOaXrOaXreabsuabs+acieacveactOacseacteasoeatpOatu+awluaxneaxl+axmeaxn+axoOaxkOaxleaxoeaxm+axjeaxjueBsOeJn+eJneeZvuerueexs+ezuOe8tue+iue+veiAgeiAg+iAjOiAkuiAs+iBv+iCieiCi+iCjOiHo+iHquiHs+iHvOiIjOiIm+iIn+iJruiJsuiJvuiZq+ihgOihjOiho+ilv+mYoeS4suS6qOS9jeS9j+S9h+S9l+S9nuS8tOS9m+S9leS8sOS9kOS9keS8veS8uuS8uOS9g+S9lOS8vOS9huS9o1wiXSxcbltcImE3NDBcIixcIuS9nOS9oOS8r+S9juS8tuS9meS9neS9iOS9muWFjOWFi+WFjeWFteWGtuWGt+WIpeWIpOWIqeWIquWIqOWKq+WKqeWKquWKrOWMo+WNs+WNteWQneWQreWQnuWQvuWQpuWRjuWQp+WRhuWRg+WQs+WRiOWRguWQm+WQqeWRiuWQueWQu+WQuOWQruWQteWQtuWQoOWQvOWRgOWQseWQq+WQn+WQrOWbquWbsOWbpOWbq+WdiuWdkeWdgOWdjVwiXSxcbltcImE3YTFcIixcIuWdh+WdjuWcvuWdkOWdj+Wcu+Wjr+WkvuWmneWmkuWmqOWmnuWmo+WmmeWmluWmjeWmpOWmk+WmiuWmpeWtneWtnOWtmuWtm+WujOWui+Wuj+WwrOWxgOWxgeWwv+WwvuWykOWykeWylOWyjOW3q+W4jOW6j+W6h+W6iuW7t+W8hOW8n+W9pOW9ouW9t+W9ueW/mOW/jOW/l+W/jeW/seW/q+W/uOW/quaIkuaIkeaKhOaKl+aKluaKgOaJtuaKieaJreaKiuaJvOaJvuaJueaJs+aKkuaJr+aKmOaJruaKleaKk+aKkeaKhuaUueaUu+aUuOaXseabtOadn+adjuadj+adkOadkeadnOadluadnuadieadhuadoFwiXSxcbltcImE4NDBcIixcIuadk+adl+atpeavj+axguaxnuaymeaygeayiOayieayheaym+axquaxuuaykOaxsOayjOaxqOayluaykuaxveayg+axsuaxvuaxtOayhuaxtuayjeaylOaymOaygueBtueBvOeBveeBuOeJoueJoeeJoOeLhOeLgueOlueUrOeUq+eUt+eUuOeaguebr+efo+engeengOemv+eptuezu+e9leiCluiCk+iCneiCmOiCm+iCmuiCsuiJr+iKklwiXSxcbltcImE4YTFcIixcIuiKi+iKjeimi+inkuiogOiwt+ixhuixleiynei1pOi1sOi2s+i6q+i7iui+m+i+sOi/gui/hui/hei/hOW3oemCkemCoumCqumCpumCo+mFiemHhumHjOmYsumYrumYsemYqumYrOS4puS5luS5s+S6i+S6m+S6nuS6q+S6rOS9r+S+neS+jeS9s+S9v+S9rOS+m+S+i+S+huS+g+S9sOS9teS+iOS9qeS9u+S+luS9vuS+j+S+keS9uuWFlOWFkuWFleWFqeWFt+WFtuWFuOWGveWHveWIu+WIuOWIt+WIuuWIsOWIruWItuWJgeWKvuWKu+WNkuWNlOWNk+WNkeWNpuWNt+WNuOWNueWPluWPlOWPl+WRs+WRtVwiXSxcbltcImE5NDBcIixcIuWSluWRuOWSleWSgOWRu+WRt+WShOWSkuWShuWRvOWSkOWRseWRtuWSjOWSmuWRouWRqOWSi+WRveWSjuWbuuWeg+Wdt+WdquWdqeWdoeWdpuWdpOWdvOWknOWlieWlh+WliOWlhOWllOWmvuWmu+WnlOWmueWmruWnkeWnhuWnkOWnjeWni+Wnk+WniuWmr+Wms+WnkuWnheWtn+WtpOWto+Wul+WumuWumOWunOWumeWum+WwmuWxiOWxhVwiXSxcbltcImE5YTFcIixcIuWxhuWyt+WyoeWyuOWyqeWyq+WyseWys+W4mOW4muW4luW4leW4m+W4keW5uOW6muW6l+W6nOW6leW6luW7tuW8puW8p+W8qeW+gOW+geW9v+W9vOW/neW/oOW/veW/teW/v+aAj+aAlOaAr+aAteaAluaAquaAleaAoeaAp+aAqeaAq+aAm+aIluaIleaIv+aIvuaJgOaJv+aLieaLjOaLhOaKv+aLguaKueaLkuaLm+aKq+aLk+aLlOaLi+aLiOaKqOaKveaKvOaLkOaLmeaLh+aLjeaKteaLmuaKseaLmOaLluaLl+aLhuaKrOaLjuaUvuaWp+aWvOaXuuaYlOaYk+aYjOaYhuaYguaYjuaYgOaYj+aYleaYilwiXSxcbltcImFhNDBcIixcIuaYh+acjeaci+adreaei+aeleadseaenOads+adt+aeh+aeneael+adr+adsOadv+aeieadvuaekOadteaemuaek+advOadquadsuaso+atpuatp+atv+awk+awm+azo+azqOazs+ayseazjOazpeays+ayveayvuayvOazouayq+azleazk+ayuOazhOayueazgeayruazl+azheazseayv+ayu+azoeazm+aziuayrOazr+aznOazluazoFwiXSxcbltcImFhYTFcIixcIueCleeCjueCkueCiueCmeeIrOeIreeIuOeJiOeJp+eJqeeLgOeLjueLmeeLl+eLkOeOqeeOqOeOn+eOq+eOpeeUveeWneeWmeeWmueahOebguebsuebtOefpeefveekvuelgOelgeenieeniOepuuepueeruuezvue9lOe+jOe+i+iAheiCuuiCpeiCouiCseiCoeiCq+iCqeiCtOiCquiCr+iHpeiHvuiIjeiKs+iKneiKmeiKreiKveiKn+iKueiKseiKrOiKpeiKr+iKuOiKo+iKsOiKvuiKt+iZjuiZseWIneihqOi7i+i/jui/lOi/kemCtemCuOmCsemCtumHh+mHkemVt+mWgOmYnOmZgOmYv+mYu+mZhFwiXSxcbltcImFiNDBcIixcIumZgumauembqOmdkumdnuS6n+S6reS6ruS/oeS+teS+r+S+v+S/oOS/keS/j+S/neS/g+S+tuS/mOS/n+S/iuS/l+S+ruS/kOS/hOS/guS/muS/juS/nuS+t+WFl+WGkuWGkeWGoOWJjuWJg+WJiuWJjeWJjOWJi+WJh+WLh+WLieWLg+WLgeWMjeWNl+WNu+WOmuWPm+WSrOWTgOWSqOWTjuWTieWSuOWSpuWSs+WTh+WTguWSveWSquWTgVwiXSxcbltcImFiYTFcIixcIuWThOWTiOWSr+WSq+WSseWSu+WSqeWSp+WSv+Wbv+WeguWei+WeoOWeo+WeouWfjuWeruWek+WlleWlkeWlj+WljuWlkOWnnOWnmOWnv+Wno+WnqOWog+WnpeWnquWnmuWnpuWogeWnu+WtqeWuo+WupuWupOWuouWupeWwgeWxjuWxj+WxjeWxi+WzmeWzkuW3t+W4neW4peW4n+W5veW6oOW6puW7uuW8iOW8reW9peW+iOW+heW+iuW+i+W+h+W+jOW+ieaAkuaAneaAoOaApeaAjuaAqOaBjeaBsOaBqOaBouaBhuaBg+aBrOaBq+aBquaBpOaJgeaLnOaMluaMieaLvOaLreaMgeaLruaLveaMh+aLseaLt1wiXSxcbltcImFjNDBcIixcIuaLr+aLrOaLvuaLtOaMkeaMguaUv+aVheaWq+aWveaXouaYpeaYreaYoOaYp+aYr+aYn+aYqOaYseaYpOabt+afv+afk+afseaflOafkOafrOaetuaer+afteafqeafr+afhOafkeaetOafmuafpeaeuOafj+afnuafs+aesOafmeafouafneafkuatquaug+auhuauteavkuavl+awn+aziea0i+a0sua0qua1gea0pea0jOa0sea0nua0l1wiXSxcbltcImFjYTFcIixcIua0u+a0vea0vua0tua0m+aztea0uea0p+a0uOa0qea0rua0tea0jua0q+eCq+eCuueCs+eCrOeCr+eCreeCuOeCrueCpOeIsOeJsueJr+eJtOeLqeeLoOeLoeeOt+ePiueOu+eOsuePjeePgOeOs+eUmueUreeVj+eVjOeVjueVi+eWq+eWpOeWpeeWoueWo+eZuOeahueah+eaiOebiOebhuebg+ebheecgeebueebuOecieeci+ebvuebvOech+efnOeggueglOegjOegjeelhuelieeliOelh+emueemuuenkeenkueni+epv+eqgeerv+erveexvee0gue0hee0gOe0iee0h+e0hOe0hue8uOe+jue+v+iAhFwiXSxcbltcImFkNDBcIixcIuiAkOiAjeiAkeiAtuiDluiDpeiDmuiDg+iDhOiDjOiDoeiDm+iDjuiDnuiDpOiDneiHtOiIouiLp+iMg+iMheiLo+iLm+iLpuiMhOiLpeiMguiMieiLkuiLl+iLseiMgeiLnOiLlOiLkeiLnuiLk+iLn+iLr+iMhuiZkOiZueiZu+iZuuihjeihq+imgeinlOioiOioguiog+iynuiyoOi1tOi1s+i2tOi7jei7jOi/sOi/pui/oui/qui/pVwiXSxcbltcImFkYTFcIixcIui/rei/q+i/pOi/qOmDiumDjumDgemDg+mFi+mFiumHjemWgumZkOmZi+mZjOmZjemdoumdqemfi+mfremfs+mggemiqOmjm+mjn+mmlummmeS5mOS6s+WAjOWAjeWAo+S/r+WApuWApeS/uOWAqeWAluWAhuWAvOWAn+WAmuWAkuWAkeS/uuWAgOWAlOWAqOS/seWAoeWAi+WAmeWAmOS/s+S/ruWAreWAquS/vuWAq+WAieWFvOWGpOWGpeWGouWHjeWHjOWHhuWHi+WJluWJnOWJlOWJm+WJneWMquWNv+WOn+WOneWPn+WTqOWUkOWUgeWUt+WTvOWTpeWTsuWUhuWTuuWUlOWTqeWTreWToeWUieWTruWTqlwiXSxcbltcImFlNDBcIixcIuWTpuWUp+WUh+WTveWUj+Wcg+WchOWfguWflOWfi+Wfg+WgieWkj+Wll+WlmOWlmuWokeWomOWonOWon+Wom+Wok+WnrOWooOWoo+WoqeWopeWojOWoieWtq+WxmOWusOWus+WutuWutOWuruWuteWuueWuuOWwhOWxkeWxleWxkOWzreWzveWzu+WzquWzqOWzsOWztuW0geWztOW3ruW4reW4q+W6q+W6reW6p+W8seW+kuW+keW+kOaBmVwiXSxcbltcImFlYTFcIixcIuaBo+aBpeaBkOaBleaBreaBqeaBr+aChOaCn+aCmuaCjeaClOaCjOaCheaCluaJh+aLs+aMiOaLv+aNjuaMvuaMr+aNleaNguaNhuaNj+aNieaMuuaNkOaMveaMquaMq+aMqOaNjeaNjOaViOaVieaWmeaXgeaXheaZguaZieaZj+aZg+aZkuaZjOaZheaZgeabuOaclOacleacl+agoeaguOahiOahhuahk+agueahguahlOagqeais+agl+ahjOahkeagveaftOahkOahgOagvOahg+agquahheagk+agmOahgeauiuauieaut+awo+awp+awqOawpuawpOazsOa1qua2lea2iOa2h+a1pua1uOa1t+a1mea2k1wiXSxcbltcImFmNDBcIixcIua1rOa2iea1rua1mua1tOa1qea2jOa2iua1uea2hea1pea2lOeDiueDmOeDpOeDmeeDiOeDj+eIueeJueeLvOeLueeLveeLuOeLt+eOhuePreeQieePruePoOePquePnueVlOeVneeVnOeVmueVmeeWvueXheeXh+eWsueWs+eWveeWvOeWueeXgueWuOeai+easOebiuebjeebjuecqeecn+ecoOecqOefqeegsOegp+eguOegneegtOegt1wiXSxcbltcImFmYTFcIixcIuegpeegreegoOegn+egsuelleelkOeloOeln+elluelnuelneell+elmuenpOeno+enp+enn+enpuenqeenmOeqhOeqiOermeeshueskeeyiee0oee0l+e0i+e0iue0oOe0oue0lOe0kOe0lee0mue0nOe0jee0mee0m+e8uue9n+e+lOe/hee/geiAhuiAmOiAleiAmeiAl+iAveiAv+iDseiEguiDsOiEheiDreiDtOiEhuiDuOiDs+iEiOiDveiEiuiDvOiDr+iHreiHrOiIgOiIkOiIquiIq+iIqOiIrOiKu+iMq+iNkuiNlOiNiuiMuOiNkOiNieiMteiMtOiNj+iMsuiMueiMtuiMl+iNgOiMseiMqOiNg1wiXSxcbltcImIwNDBcIixcIuiZlOiaiuiaquiak+iapOiaqeiajOiao+ianOihsOiht+iigeiiguihveihueiomOiokOiojuiojOioleioiuiol+iok+ioluioj+iokeixiOixuuixueiyoeiyoui1t+i6rOi7kui7lOi7j+i+semAgemAhui/t+mAgOi/uui/tOmAg+i/vemAhei/uOmClemDoemDnemDoumFkumFjemFjOmHmOmHnemHl+mHnOmHmemWg+mZoumZo+mZoVwiXSxcbltcImIwYTFcIixcIumZm+mZnemZpOmZmOmZnumau+mjoummrOmqqOmrmOmspemssumsvOS5vuWBuuWBveWBnOWBh+WBg+WBjOWBmuWBieWBpeWBtuWBjuWBleWBteWBtOWBt+WBj+WAj+WBr+WBreWFnOWGleWHsOWJquWJr+WLkuWLmeWLmOWLleWMkOWMj+WMmeWMv+WNgOWMvuWPg+abvOWVhuWVquWVpuWVhOWVnuWVoeWVg+WViuWUseWVluWVj+WVleWUr+WVpOWUuOWUruWVnOWUrOWVo+WUs+WVgeWVl+WciOWci+WcieWfn+WgheWgiuWghuWfoOWfpOWfuuWgguWgteWft+WfueWkoOWlouWotuWpgeWpieWppuWpquWpgFwiXSxcbltcImIxNDBcIixcIuWovOWpouWpmuWphuWpiuWtsOWvh+WvheWvhOWvguWuv+WvhuWwieWwiOWwh+WxoOWxnOWxneW0h+W0huW0juW0m+W0luW0ouW0keW0qeW0lOW0meW0pOW0p+W0l+W3ouW4uOW4tuW4s+W4t+W6t+W6uOW6tuW6teW6vuW8teW8t+W9l+W9rOW9qeW9q+W+l+W+meW+nuW+mOW+oeW+oOW+nOaBv+aCo+aCieaCoOaCqOaDi+aCtOaDpuaCvVwiXSxcbltcImIxYTFcIixcIuaDheaCu+aCteaDnOaCvOaDmOaDleaDhuaDn+aCuOaDmuaDh+aImuaIm+aJiOaOoOaOp+aNsuaOluaOouaOpeaNt+aNp+aOmOaOquaNseaOqeaOieaOg+aOm+aNq+aOqOaOhOaOiOaOmeaOoeaOrOaOkuaOj+aOgOaNu+aNqeaNqOaNuuaVneaVluaVkeaVmeaVl+WVn+aVj+aVmOaVleaVlOaWnOaWm+aWrOaXj+aXi+aXjOaXjuaZneaZmuaZpOaZqOaZpuaZnuabueWLl+acm+aigeair+aiouaik+aiteahv+ahtuaiseaip+ail+aisOaig+ajhOaireaihuaiheailOaineaiqOain+aioeaiguassuauulwiXSxcbltcImIyNDBcIixcIuavq+avrOawq+a2jua2vOa3s+a3mea2sua3oea3jOa3pOa3u+a3uua4hea3h+a3i+a2r+a3kea2rua3nua3uea2uOa3t+a3tea3hea3kua4mua2tea3mua3q+a3mOa3qua3sea3rua3qOa3hua3hOa2qua3rOa2v+a3pueDueeEieeEiueDveeDr+eIveeJveeKgeeMnOeMm+eMlueMk+eMmeeOh+eQheeQiueQg+eQhuePvueQjeeToOeTtlwiXSxcbltcImIyYTFcIixcIueTt+eUnOeUoueVpeeVpueVoueVsOeWj+eXlOeXleeWteeXiueXjeeajueblOebkuebm+ect+ecvuecvOectuecuOecuuehq+ehg+ehjuelpeelqOelreenu+eqkueqleesoOesqOesm+esrOespuesmeesnuesrueykueyl+eylee1hue1g+e1see0rue0uee0vOe1gOe0sOe0s+e1hOe0r+e1gue0sue0see8vee+nue+mue/jOe/jue/kuiAnOiBiuiBhuiEr+iEluiEo+iEq+iEqeiEsOiEpOiIguiIteiIt+iItuiIueiOjuiOnuiOmOiNuOiOouiOluiOveiOq+iOkuiOiuiOk+iOieiOoOiNt+iNu+iNvFwiXSxcbltcImIzNDBcIixcIuiOhuiOp+iZleW9quibh+ibgOiatuibhOiateibhuibi+iaseiar+ibieihk+iinuiiiOiiq+iikuiiluiijeiii+imk+imj+ioquioneioo+iopeioseioreion+iom+ioouixieixmuiyqeiyrOiyq+iyqOiyquiyp+i1p+i1pui2vui2uui7m+i7n+mAmemAjemAmumAl+mAo+mAn+mAnemAkOmAlemAnumAoOmAj+mAoumAlumAm+mAlFwiXSxcbltcImIzYTFcIixcIumDqOmDremDvemFl+mHjumHtemHpumHo+mHp+mHremHqemWiemZqumZtemZs+mZuOmZsOmZtOmZtumZt+mZrOmbgOmbqumbqeeroOern+mggumgg+mtmumzpem5tem5v+m6pem6u+WCouWCjeWCheWCmeWCkeWCgOWCluWCmOWCmuacgOWHseWJsuWJtOWJteWJqeWLnuWLneWLm+WNmuWOpeWVu+WWgOWWp+WVvOWWiuWWneWWmOWWguWWnOWWquWWlOWWh+WWi+WWg+WWs+WWruWWn+WUvuWWsuWWmuWWu+WWrOWWseWVvuWWieWWq+WWmeWcjeWgr+WgquWgtOWgpOWgsOWgseWgoeWgneWgoOWjueWjuuWloFwiXSxcbltcImI0NDBcIixcIuWpt+WqmuWpv+WqkuWqm+Wqp+Wts+WtseWvkuWvjOWvk+WvkOWwiuWwi+WwseW1jOW1kOW0tOW1h+W3veW5heW4veW5gOW5g+W5vuW7iuW7geW7guW7hOW8vOW9reW+qeW+quW+qOaDkeaDoeaCsuaCtuaDoOaEnOaEo+aDuuaEleaDsOaDu+aDtOaFqOaDseaEjuaDtuaEieaEgOaEkuaIn+aJieaOo+aOjOaPj+aPgOaPqeaPieaPhuaPjVwiXSxcbltcImI0YTFcIixcIuaPkuaPo+aPkOaPoeaPluaPreaPruaNtuaPtOaPquaPm+aRkuaPmuaPueaVnuaVpuaVouaVo+aWkeaWkOaWr+aZruaZsOaZtOaZtuaZr+aakeaZuuaZvuaZt+abvuabv+acn+acneajuuajleajoOajmOajl+akheajn+ajteajruajp+ajueajkuajsuajo+aji+ajjeakjeakkuakjuajieajmualruaju+asvuasuuasveaumOauluauvOavr+awruawr+awrOa4r+a4uOa5lOa4oea4sua5p+a5iua4oOa4pea4o+a4m+a5m+a5mOa4pOa5lua5rua4rea4pua5r+a4tOa5jea4uua4rOa5g+a4nea4vua7i1wiXSxcbltcImI1NDBcIixcIua6iea4mea5jua5o+a5hOa5sua5qea5n+eEmeeEmueEpueEsOeEoeeEtueFrueEnOeJjOeKhOeKgOeMtueMpeeMtOeMqeeQuueQqueQs+eQoueQpeeQteeQtueQtOeQr+eQm+eQpueQqOeUpeeUpueVq+eVqueXoueXm+eXo+eXmeeXmOeXnueXoOeZu+eZvOealueak+eatOebnOedj+efreehneehrOehr+eojeeoiOeoi+eoheeogOeqmFwiXSxcbltcImI1YTFcIixcIueql+eqluerpeero+etieetluethuetkOetkuetlOetjeeti+etj+etkeeyn+eypee1nue1kOe1qOe1lee0q+e1rue1sue1oee1pue1oue1sOe1s+WWhOe/lOe/leiAi+iBkuiCheiFleiFlOiFi+iFkeiFjuiEueiFhuiEvuiFjOiFk+iFtOiIkuiInOiPqeiQg+iPuOiQjeiPoOiPheiQi+iPgeiPr+iPseiPtOiRl+iQiuiPsOiQjOiPjOiPveiPsuiPiuiQuOiQjuiQhOiPnOiQh+iPlOiPn+iZm+ibn+ibmeibreiblOibm+ibpOibkOibnuihl+ijgeijguiiseimg+imluiou+ipoOipleipnuiovOipgVwiXSxcbltcImI2NDBcIixcIuiplOipm+ipkOiphuiotOiouuiotuipluixoeiyguiyr+iyvOiys+iyveizgeiyu+izgOiytOiyt+iytuiyv+iyuOi2iui2hei2gei3jui3nei3i+i3mui3kei3jOi3m+i3hui7u+i7uOi7vOi+nOmArumAtemAsemAuOmAsumAtumEgumDtemEiemDvumFo+mFpemHj+mIlOmIlemIo+mIiemInumIjemIkOmIh+mIkemWlOmWj+mWi+mWkVwiXSxcbltcImI2YTFcIixcIumWk+mWkumWjumaiumajumai+mZvemahemahumajemZsumahOmbgembhembhOmbhumbh+mbr+mbsumfjOmghemghumgiOmjp+mjqumjr+mjqemjsumjremmrummrem7g+m7jem7keS6guWCreWCteWCsuWCs+WDheWCvuWCrOWCt+WCu+WCr+WDh+WJv+WJt+WJveWLn+WLpuWLpOWLouWLo+WMr+WXn+WXqOWXk+WXpuWXjuWXnOWXh+WXkeWXo+WXpOWXr+WXmuWXoeWXheWXhuWXpeWXieWckuWck+WhnuWhkeWhmOWhl+WhmuWhlOWhq+WhjOWhreWhiuWhouWhkuWhi+Wlp+WrgeWrieWrjOWqvuWqveWqvFwiXSxcbltcImI3NDBcIixcIuWqs+WrguWqsuW1qeW1r+W5jOW5ueW7ieW7iOW8kuW9meW+rOW+ruaEmuaEj+aFiOaEn+aDs+aEm+aDueaEgeaEiOaFjuaFjOaFhOaFjeaEvuaEtOaEp+aEjeaEhuaEt+aIoeaIouaQk+aQvuaQnuaQquaQreaQveaQrOaQj+aQnOaQlOaQjeaQtuaQluaQl+aQhuaVrOaWn+aWsOaal+aaieaah+aaiOaaluaahOaamOaajeacg+amlOalrVwiXSxcbltcImI3YTFcIixcIualmualt+aloOallOalteaksOamgualiualqOalq+alnualk+alueamhualnealo+alm+ath+atsuavgOauv+avk+avvea6oua6r+a7k+a6tua7gua6kOa6nea7h+a7hea6pea6mOa6vOa6uua6q+a7kea6lua6nOa7hOa7lOa6qua6p+a6tOeFjueFmeeFqeeFpOeFieeFp+eFnOeFrOeFpueFjOeFpeeFnueFhueFqOeFlueIuueJkueMt+eNheeMv+eMvueRr+eRmueRleeRn+eRnueRgeeQv+eRmeeRm+eRnOeVtueVuOeYgOeXsOeYgeeXsueXseeXuueXv+eXtOeXs+ebnuebn+edm+edq+edpuednuedo1wiXSxcbltcImI4NDBcIixcIuedueedquedrOednOedpeedqOedouefrueijueisOeil+eimOeijOeiieehvOeikeeik+ehv+eluuelv+emgeiQrOemveeonOeomueooOeolOeon+eonueqn+eqoOett+evgOetoOetruetp+eyseeys+eytee2k+e1uee2kee2gee2j+e1m+e9rue9qee9que9sue+qee+qOe+pOiBluiBmOiChuiChOiFseiFsOiFuOiFpeiFruiFs+iFq1wiXSxcbltcImI4YTFcIixcIuiFueiFuuiFpuiIheiJh+iSguiRt+iQveiQseiRteiRpuiRq+iRieiRrOiRm+iQvOiQteiRoeiRo+iRqeiRreiRhuiZnuiZnOiZn+ibueick+iciOich+icgOibvuibu+icguicg+ichuiciuihmeijn+ijlOijmeijnOijmOijneijoeijiuijleijkuimnOino+ipq+ipsuips+ippuipqeipsOiqh+ipvOipo+iqoOipseiqheipreipouipruiprOipueipu+iovuipqOixouiyiuiyieiziuizh+iziOizhOiysuizg+izguizhei3oei3n+i3qOi3r+i3s+i3uui3qui3pOi3pui6sui8g+i8iei7vui8ilwiXSxcbltcImI5NDBcIixcIui+n+i+sumBi+mBiumBk+mBgumBlOmAvOmBlemBkOmBh+mBj+mBjumBjemBkemAvumBgemEkumEl+mFrOmFqumFqemHiemIt+mJl+mIuOmIvemJgOmIvumJm+mJi+mJpOmJkemItOmJiemJjemJhemIuemIv+mJmumWmOmamOmalOmalembjembi+mbiembiumbt+mbu+mbuembtumdlumdtOmdtumgkOmgkemgk+mgiumgkumgjOmjvOmjtFwiXSxcbltcImI5YTFcIixcIumjvemjvumms+mmsemmtOmroemzqem6gum8jum8k+m8oOWDp+WDruWDpeWDluWDreWDmuWDleWDj+WDkeWDseWDjuWDqeWFouWHs+WKg+WKguWMseWOreWXvuWYgOWYm+WYl+WXveWYlOWYhuWYieWYjeWYjuWXt+WYluWYn+WYiOWYkOWXtuWcmOWcluWhteWhvuWig+Wik+WiiuWhueWiheWhveWjveWkpeWkouWkpOWlquWlqeWroeWrpuWrqeWrl+WrluWrmOWro+WtteWvnuWvp+WvoeWvpeWvpuWvqOWvouWvpOWvn+WwjeWxouW2hOW2h+W5m+W5o+W5leW5l+W5lOW7k+W7luW8iuW9huW9sOW+ueaFh1wiXSxcbltcImJhNDBcIixcIuaEv+aFi+aFt+aFouaFo+aFn+aFmuaFmOaFteaIquaSh+aRmOaRlOaSpOaRuOaRn+aRuuaRkeaRp+aQtOaRreaRu+aVsuaWoeaXl+aXluaaouaaqOaaneamnOamqOamleangeamruank+ani+amm+amt+amu+amq+amtOankOanjeamreanjOampuang+amo+atieatjOaws+a8s+a8lOa7vua8k+a7tOa8qea8vua8oOa8rOa8j+a8gua8olwiXSxcbltcImJhYTFcIixcIua7v+a7r+a8hua8sea8uOa8sua8o+a8lea8q+a8r+a+iOa8qua7rOa8gea7sua7jOa7t+eGlOeGmeeFveeGiueGhOeGkueIvueKkueKlueNhOeNkOeRpOeRo+eRqueRsOeRreeUhOeWkeeYp+eYjeeYi+eYieeYk+eboeebo+eehOedveedv+edoeejgeein+eip+eis+eiqeeio+emjuemj+emjeeorueoseeqqueqqeerreerr+euoeeuleeui+etteeul+euneeulOeuj+euuOeuh+euhOeyueeyveeyvue2u+e2sOe2nOe2vee2vue2oOe3iue2tOe2sue2see2uue2oue2v+e2tee2uOe2ree3kue3h+e2rFwiXSxcbltcImJiNDBcIixcIue9sOe/oOe/oee/n+iBnuiBmuiCh+iFkOiGgOiGj+iGiOiGiuiFv+iGguiHp+iHuuiIh+iIlOiInuiJi+iTieiSv+iThuiThOiSmeiSnuiSsuiSnOiTi+iSuOiTgOiTk+iSkOiSvOiTkeiTiuicv+icnOicu+icouicpeictOicmOidleict+icqeijs+ikguijtOijueijuOijveijqOikmuijr+iqpuiqjOiqnuiqo+iqjeiqoeiqk+iqpFwiXSxcbltcImJiYTFcIixcIuiqquiqpeiqqOiqmOiqkeiqmuiqp+ixquiyjeiyjOizk+izkeizkui1q+i2mei2lei3vOi8lOi8kui8lei8k+i+o+mBoOmBmOmBnOmBo+mBmemBnumBoumBnemBm+mEmemEmOmEnumFtemFuOmFt+mFtOmJuOmKgOmKhemKmOmKlumJu+mKk+mKnOmKqOmJvOmKkemWoemWqOmWqemWo+mWpemWpOmamemanOmam+mbjOmbkumcgOmdvOmehemftumgl+mgmOmir+misemkg+mkhemkjOmkiemngemqr+mqsOmrpumtgemtgumztOmztumzs+m6vOm8u+m9iuWEhOWEgOWDu+WDteWDueWEguWEiOWEieWEheWHnFwiXSxcbltcImJjNDBcIixcIuWKh+WKiOWKieWKjeWKiuWLsOWOsuWYruWYu+WYueWYsuWYv+WYtOWYqeWZk+WZjuWZl+WZtOWYtuWYr+WYsOWigOWin+WinuWis+WinOWiruWiqeWipuWlreWsieWru+Wsi+WrteWsjOWsiOWvruWvrOWvqeWvq+WxpOWxpeW2neW2lOW5ouW5n+W5oeW7ouW7muW7n+W7neW7o+W7oOW9iOW9seW+t+W+teaFtuaFp+aFruaFneaFleaGglwiXSxcbltcImJjYTFcIixcIuaFvOaFsOaFq+aFvuaGp+aGkOaGq+aGjuaGrOaGmuaGpOaGlOaGruaIruaRqeaRr+aRueaSnuaSsuaSiOaSkOaSsOaSpeaSk+aSleaSqeaSkuaSruaSreaSq+aSmuaSrOaSmeaSouaSs+aVteaVt+aVuOaaruaaq+aatOaaseaoo+aon+anqOaogeaonuaomeanveaooeaok+aoiuans+aoguaoheanreaokeatkOatjuaupOavheavhua8v+a9vOa+hOa9kea9pua9lOa+hua9rea9m+a9uOa9rua+jua9uua9sOa9pOa+l+a9mOa7lea9r+a9oOa9n+eGn+eGrOeGseeGqOeJlueKm+eNjueNl+eRqeeSi+eSg1wiXSxcbltcImJkNDBcIixcIueRvueSgOeVv+eYoOeYqeeYn+eYpOeYpueYoeeYoueamueauuebpOeejueeh+eejOeekeeei+eji+ejheeiuuejiueivuejleeivOejkOeov+eovOepgOeoveeot+eou+eqr+eqrueureeuseevhOeutOevhuevh+evgeeuoOevjOeziue3oOe3tOe3r+e3u+e3mOe3rOe3nee3qOe3o+e3mue3nue3qee2nue3mee3sue3uee9tee9t+e+r1wiXSxcbltcImJkYTFcIixcIue/qeiApuiGm+iGnOiGneiGoOiGmuiGmOiUl+iUveiUmuiTruiUrOiUreiUk+iUkeiUo+iUoeiUlOiTrOiUpeiTv+iUhuieguidtOidtuidoOidpuiduOidqOidmeidl+idjOidk+ihm+ihneikkOikh+ikkuikk+ikleikiuiqvOirkuirh+irhOiqleiri+iruOiqsuirieirguiqv+iqsOirluirjeiqtuiqueirm+ixjOixjuixrOizoOiznuizpuizpOizrOizreizouizo+iznOizquizoei1rei2n+i2o+i4q+i4kOi4nei4oui4j+i4qei4n+i4oei4nui6uui8nei8m+i8n+i8qei8pui8qui8nOi8nlwiXSxcbltcImJlNDBcIixcIui8pemBqemBrumBqOmBremBt+mEsOmEremEp+mEsemGh+mGiemGi+mGg+mLhemKu+mKt+mLqumKrOmLpOmLgemKs+mKvOmLkumLh+mLsOmKsumWremWsemchOmchumch+mciemdoOmejemei+mej+mgoemgq+mgnOmis+mkiumkk+mkkumkmOmnnemnkOmnn+mnm+mnkemnlemnkumnmemqt+mrrumrr+msp+mthemthOmtt+mtr+m0hum0iVwiXSxcbltcImJlYTFcIixcIum0g+m6qem6vum7juWiqOm9kuWEkuWEmOWElOWEkOWEleWGgOWGquWHneWKkeWKk+WLs+WZmeWZq+WZueWZqeWZpOWZuOWZquWZqOWZpeWZseWZr+WZrOWZouWZtuWjgeWivuWjh+WjheWlruWsneWstOWtuOWvsOWwjuW9iuaGsuaGkeaGqeaGiuaHjeaGtuaGvuaHiuaHiOaIsOaTheaTgeaTi+aSu+aSvOaTmuaThOaTh+aTguaTjeaSv+aTkuaTlOaSvuaVtOabhuabieaaueabhOabh+aauOaoveaouOaouuapmeapq+apmOaoueaphOapouapoeapi+aph+aoteapn+apiOatmeatt+awhea/gua+sea+oVwiXSxcbltcImJmNDBcIixcIua/g+a+pOa/gea+p+a+s+a/gOa+uea+tua+pua+oOa+tOeGvueHieeHkOeHkueHiOeHleeGueeHjueHmeeHnOeHg+eHhOeNqOeSnOeSo+eSmOeSn+eSnueToueUjOeUjeeYtOeYuOeYuuebp+ebpeeeoOeenueen+eepeejqOejmuejrOejp+empuepjeepjuephuepjOepi+equuevmeewkeevieevpOevm+evoeevqeevpuezleezlue4ilwiXSxcbltcImJmYTFcIixcIue4kee4iOe4m+e4o+e4nue4nee4iee4kOe9uee+sue/sOe/see/ruiAqOiGs+iGqeiGqOiHu+iIiOiJmOiJmeiViuiVmeiViOiVqOiVqeiVg+iVieiVreiVquiVnuieg+ien+ienuieouiejeihoeikquiksuikpeikq+ikoeimquimpuirpuiruuirq+irseisgOirnOirp+irruirvuisgeisguirt+irreirs+irtuirvOixq+ixreiyk+iztOi5hOi4sei4tOi5gui4uei4tei8u+i8r+i8uOi8s+i+qOi+pumBtemBtOmBuOmBsumBvOmBuumEtOmGkumMoOmMtumLuOmMs+mMr+mMoumLvOmMq+mMhOmMmlwiXSxcbltcImMwNDBcIixcIumMkOmMpumMoemMlemMrumMmemWu+map+maqOmaqumblemcjumckemclumcjemck+mcj+mdm+mdnOmdpumemOmgsOmguOmgu+mgt+mgremguemgpOmkkOmkqOmknumkm+mkoemkmumnremnoumnsemquOmqvOmru+mrremsqOmukem0lem0o+m0pum0qOm0kum0m+m7mOm7lOm+jem+nOWEquWEn+WEoeWEsuWLteWajuWagOWakOWaheWah1wiXSxcbltcImMwYTFcIixcIuWaj+WjleWjk+WjkeWjjuWssOWsquWspOWtuuWwt+WxqOW2vOW2uuW2veW2uOW5q+W9jOW+veaHieaHguaHh+aHpuaHi+aIsuaItOaTjuaTiuaTmOaToOaTsOaTpuaTrOaTseaTouaTreaWguaWg+abmeabluaqgOaqlOaqhOaqouaqnOarm+aqo+apvuaql+aqkOaqoOatnOauruavmuawiOa/mOa/sea/n+a/oOa/m+a/pOa/q+a/r+a+gOa/rOa/oea/qea/lea/rua/sOeHp+eHn+eHrueHpueHpeeHreeHrOeHtOeHoOeIteeJhueNsOeNsueSqeeSsOeSpueSqOeZhueZgueZjOebquees+eequeesOeerFwiXSxcbltcImMxNDBcIixcIueep+eereefr+ejt+ejuuejtOejr+ekgeemp+emquepl+eqv+ewh+ewjeevvuevt+ewjOevoOezoOeznOeznuezouezn+ezmeeznee4rue4vue5hue4t+e4sue5g+e4q+e4vee4see5hee5gee4tOe4uee5iOe4tee4v+e4r+e9hOe/s+e/vOiBseiBsuiBsOiBr+iBs+iHhuiHg+iGuuiHguiHgOiGv+iGveiHieiGvuiHqOiIieiJseiWqlwiXSxcbltcImMxYTFcIixcIuiWhOiVvuiWnOiWkeiWlOiWr+iWm+iWh+iWqOiWiuiZp+ifgOifkeies+ifkuifhuieq+ieu+ieuuifiOifi+iku+iktuilhOikuOikveimrOisjuisl+ismeism+isiuisoOisneishOiskOixgeiwv+ixs+izuuizveizvOizuOizu+i2qOi5iei5i+i5iOi5iui9hOi8vui9gui9hei8v+mBv+mBvemChOmCgemCgumCgOmEuemGo+mGnumGnOmNjemOgumMqOmNtemNiumNpemNi+mMmOmNvumNrOmNm+mNsOmNmumNlOmXiumXi+mXjOmXiOmXhumasemauOmblumcnOmcnumeoOmfk+mhhumitumktemogVwiXSxcbltcImMyNDBcIixcIumnv+murumuq+muqumurem0u+m0v+m6i+m7j+m7num7nOm7nem7m+m8vum9i+WPouWaleWaruWjmeWjmOWsuOW9neaHo+aIs+aTtOaTsuaTvuaUhuaTuuaTu+aTt+aWt+abnOacpuaqs+aqrOarg+aqu+aquOarguaqruaqr+atn+atuOaur+eAieeAi+a/vueAhua/uueAkeeAj+eHu+eHvOeHvueHuOeNt+eNteeSp+eSv+eUleeZlueZmFwiXSxcbltcImMyYTFcIixcIueZkueeveeev+eeu+eevOekjuemruepoeepouepoOerhOerheewq+ewp+ewquewnuewo+ewoeezp+e5lOe5lee5nue5mue5oee5kue5mee9iOe/uee/u+iBt+iBtuiHjeiHj+iIiuiXj+iWqeiXjeiXkOiXieiWsOiWuuiWueiWpuifr+ifrOifsuifoOimhuimsuintOisqOisueisrOisq+ixkOi0hei5mei5o+i5pui5pOi5n+i5lei7gOi9iei9jemCh+mCg+mCiOmGq+mGrOmHkOmOlOmOiumOlumOoumOs+mOrumOrOmOsOmOmOmOmumOl+mXlOmXlumXkOmXlemboumbnOmbmembm+mbnumcpOmeo+meplwiXSxcbltcImMzNDBcIixcIumeremfuemhjemhj+mhjOmhjumhk+miuumkvumkv+mkvemkrummpemojumrgemsg+mshumtj+mtjumtjemviumviemvvemviOmvgOm1kem1nem1oOm7oOm8lem8rOWEs+WapeWjnuWjn+WjouWvtem+kOW7rOaHsuaHt+aHtuaHteaUgOaUj+aboOabnearpearnearmuark+eAm+eAn+eAqOeAmueAneeAleeAmOeIhueIjeeJmOeKoueNuFwiXSxcbltcImMzYTFcIixcIueNuueSveeTiueTo+eWh+eWhueZn+eZoeefh+ekmeemseepq+epqeewvuewv+ewuOewveewt+exgOe5q+e5ree5uee5qee5que+hee5s+e+tue+uee+uOiHmOiXqeiXneiXquiXleiXpOiXpeiXt+ifu+igheigjeifueifvuiloOiln+illuilnuitgeitnOitmOitieitmuitjuitj+ithuitmei0iOi0iui5vOi5sui6h+i5tui5rOi5uui5tOi9lOi9jui+remCiumCi+mGsemGrumPoemPkemPn+mPg+mPiOmPnOmPnemPlumPoumPjemPmOmPpOmPl+mPqOmXnOmatOmbo+mcqumcp+mdoemfnOmfu+mhnlwiXSxcbltcImM0NDBcIixcIumhmOmhm+mivOmlhemliemolumomemsjemvqOmvp+mvlumvm+m2iem1oem1sum1qum1rOm6kum6l+m6k+m6tOWLuOWaqOWat+WatuWatOWavOWjpOWtgOWtg+WtveWvtuW3ieaHuOaHuuaUmOaUlOaUmeabpuacp+arrOeAvueAsOeAsueIkOeNu+eTj+eZoueZpeekpuekquekrOekq+erh+ertuexjOexg+exjeezr+ezsOi+rue5vee5vFwiXSxcbltcImM0YTFcIixcIue6gue9jOiAgOiHmuiJpuiXu+iXueiYkeiXuuiYhuiYi+iYh+iYiuiglOigleilpOimuuinuOitsOitrOitpuitr+itn+itq+i0j+i0jei6iei6gei6hei6gumGtOmHi+mQmOmQg+mPvemXoemcsOmjhOmlkumlkemmqOmoq+mosOmot+motemwk+mwjem5uem6tem7qOm8r+m9n+m9o+m9oeWEt+WEuOWbgeWbgOWbguWklOWxrOW3jeaHvOaHvuaUneaUnOaWleabqearu+ashOaruuausueBjOeIm+eKp+eTlueTlOeZqeefk+exkOe6j+e6jOe+vOiYl+iYreiYmuigo+igouigoeign+ilquilrOimveittFwiXSxcbltcImM1NDBcIixcIuitt+itvei0k+i6iui6jei6i+i9n+i+r+mGuumQrumQs+mQtemQuumQuOmQsumQq+mXoumcuOmcuemcsumfv+mhp+mhpemll+mphempg+mpgOmovumrj+mtlOmtkemwremwpem2r+m2tOm3gum2uOm6nem7r+m8mem9nOm9pum9p+WEvOWEu+WbiOWbiuWbieWtv+W3lOW3kuW9juaHv+aUpOasiuatoeeBkeeBmOeOgOeTpOeWiueZrueZrFwiXSxcbltcImM1YTFcIixcIuems+exoOexn+iBvuiBveiHn+ilsuilr+invOiugOi0lui0l+i6kei6k+i9oemFiOmRhOmRkemRkumcvemcvumfg+mfgemhq+mllemplempjemrkumsmumxiemwsemwvumwu+m3k+m3l+m8tOm9rOm9qum+lOWbjOW3luaIgOaUo+aUq+aUquabrOaskOeTmueriuexpOexo+expee6k+e6lue6lOiHouiYuOiYv+igseiuiumCkOmCj+mRo+mRoOmRpOmdqOmhr+mlnOmpmumpm+mpl+mrk+mrlOmrkemxlOmxl+mxlum3pem6n+m7tOWbkeWjqeaUrOeBnueZseeZsuefl+e9kOe+iOigtuigueihouiuk+iuklwiXSxcbltcImM2NDBcIixcIuiuluiJt+i0m+mHgOmRqumdgumdiOmdhOmfhumhsOmpn+msoumtmOmxn+m3uem3uum5vOm5vem8h+m9t+m9suW7s+aslueBo+exrOexruigu+ingOi6oemHgemRsumRsOmhsemlnumrlumso+m7jOeBpOefmuiumumRt+mfiempoumppee6nOiunOi6qumHhemRvemRvumRvOmxt+mxuOm7t+ixlOmRv+m4mueIqOmpqumssem4m+m4nuexslwiXSxcbltcImM5NDBcIixcIuS5guS5nOWHteWMmuWOguS4h+S4jOS5h+S6jeWbl++ojOWxruW9s+S4j+WGh+S4juS4ruS6k+S7guS7ieS7iOWGmOWLvOWNrOWOueWcoOWkg+WkrOWwkOW3v+aXoeaus+avjOawlOeIv+S4seS4vOS7qOS7nOS7qeS7oeS7neS7muWIjOWMnOWNjOWcouWco+Wkl+Wkr+WugeWuhOWwkuWwu+WxtOWxs+W4hOW6gOW6guW/ieaIieaJkOawlVwiXSxcbltcImM5YTFcIixcIuawtuaxg+awv+awu+eKrueKsOeOiuemuOiCiumYnuS8juS8mOS8rOS7teS8lOS7seS8gOS7t+S8iOS8neS8guS8heS8ouS8k+S8hOS7tOS8kuWGseWIk+WIieWIkOWKpuWMouWMn+WNjeWOiuWQh+WboeWbn+WcruWcquWctOWkvOWmgOWlvOWmheWlu+WlvuWlt+Wlv+WtluWwleWwpeWxvOWxuuWxu+WxvuW3n+W5teW6hOW8guW8muW9tOW/leW/lOW/j+aJnOaJnuaJpOaJoeaJpuaJouaJmeaJoOaJmuaJpeaXr+aXruacvuacueacuOacu+acuuacv+acvOacs+awmOaxhuaxkuaxnOaxj+axiuaxlOaxi1wiXSxcbltcImNhNDBcIixcIuaxjOeBseeJnueKtOeKteeOjueUqueZv+eptee9keiJuOiJvOiKgOiJveiJv+iZjeilvumCmemCl+mCmOmCm+mClOmYoumYpOmYoOmYo+S9luS8u+S9ouS9ieS9k+S9pOS8vuS9p+S9kuS9n+S9geS9mOS8reS8s+S8v+S9oeWGj+WGueWInOWInuWIoeWKreWKruWMieWNo+WNsuWOjuWOj+WQsOWQt+WQquWRlOWRheWQmeWQnOWQpeWQmFwiXSxcbltcImNhYTFcIixcIuWQveWRj+WRgeWQqOWQpOWRh+WbruWbp+WbpeWdgeWdheWdjOWdieWdi+WdkuWkhuWlgOWmpuWmmOWmoOWml+WmjuWmouWmkOWmj+Wmp+WmoeWujuWukuWwqOWwquWyjeWyj+WyiOWyi+WyieWykuWyiuWyhuWyk+WyleW3oOW4iuW4juW6i+W6ieW6jOW6iOW6jeW8heW8neW9uOW9tuW/kuW/keW/kOW/reW/qOW/ruW/s+W/oeW/pOW/o+W/uuW/r+W/t+W/u+aAgOW/tOaIuuaKg+aKjOaKjuaKj+aKlOaKh+aJseaJu+aJuuaJsOaKgeaKiOaJt+aJveaJsuaJtOaUt+aXsOaXtOaXs+aXsuaXteadheadh1wiXSxcbltcImNiNDBcIixcIuadmeadleadjOadiOadneadjeadmuadi+avkOawmeawmuaxuOaxp+axq+ayhOayi+ayj+axseaxr+axqeaymuaxreayh+ayleaynOaxpuaxs+axpeaxu+ayjueBtOeBuueJo+eKv+eKveeLg+eLhueLgeeKuueLheeOleeOl+eOk+eOlOeOkueUuueUueeWlOeWleeageekveiAtOiCleiCmeiCkOiCkuiCnOiKkOiKj+iKheiKjuiKkeiKk1wiXSxcbltcImNiYTFcIixcIuiKiuiKg+iKhOixuOi/iei+v+mCn+mCoemCpemCnumCp+mCoOmYsOmYqOmYr+mYreS4s+S+mOS9vOS+heS9veS+gOS+h+S9tuS9tOS+ieS+hOS9t+S9jOS+l+S9quS+muS9ueS+geS9uOS+kOS+nOS+lOS+nuS+kuS+guS+leS9q+S9ruWGnuWGvOWGvuWIteWIsuWIs+WJhuWIseWKvOWMiuWMi+WMvOWOkuWOlOWSh+WRv+WSgeWSkeWSguWSiOWRq+WRuuWRvuWRpeWRrOWRtOWRpuWSjeWRr+WRoeWRoOWSmOWRo+WRp+WRpOWbt+WbueWdr+WdsuWdreWdq+WdseWdsOWdtuWegOWdteWdu+Wds+WdtOWdolwiXSxcbltcImNjNDBcIixcIuWdqOWdveWkjOWlheWmteWmuuWnj+WnjuWmsuWnjOWngeWmtuWmvOWng+WnluWmseWmveWngOWniOWmtOWnh+WtouWtpeWuk+WuleWxhOWxh+WyruWypOWyoOWyteWyr+WyqOWyrOWyn+Wyo+WyreWyouWyquWyp+WyneWypeWytuWysOWypuW4l+W4lOW4meW8qOW8ouW8o+W8pOW9lOW+guW9vuW9veW/nuW/peaAreaApuaAmeaAsuaAi1wiXSxcbltcImNjYTFcIixcIuaAtOaAiuaAl+aAs+aAmuaAnuaArOaAouaAjeaAkOaAruaAk+aAkeaAjOaAieaAnOaIlOaIveaKreaKtOaLkeaKvuaKquaKtuaLiuaKruaKs+aKr+aKu+aKqeaKsOaKuOaUveaWqOaWu+aYieaXvOaYhOaYkuaYiOaXu+aYg+aYi+aYjeaYheaXveaYkeaYkOabtuaciuaeheadrOaejuaekuadtuadu+aemOaehuaehOadtOaejeaejOaduuaen+aekeaemeaeg+adveaegeaduOadueaelOaspeaugOatvuavnuawneayk+azrOazq+azruazmeaytuazlOayreazp+ayt+azkOazguayuuazg+azhuazreazslwiXSxcbltcImNkNDBcIixcIuazkuazneaytOayiuayneaygOaznuazgOa0sOazjeazh+aysOazueazj+azqeazkeeClOeCmOeCheeCk+eChueChOeCkeeClueCgueCmueCg+eJqueLlueLi+eLmOeLieeLnOeLkueLlOeLmueLjOeLkeeOpOeOoeeOreeOpueOoueOoOeOrOeOneeTneeTqOeUv+eVgOeUvueWjOeWmOear+ebs+ebseebsOebteefuOefvOefueefu+efulwiXSxcbltcImNkYTFcIixcIueft+elguekv+enheepuOepu+eru+exteezveiAteiCj+iCruiCo+iCuOiCteiCreiIoOiKoOiLgOiKq+iKmuiKmOiKm+iKteiKp+iKruiKvOiKnuiKuuiKtOiKqOiKoeiKqeiLguiKpOiLg+iKtuiKouiZsOiZr+iZreiZruixlui/kui/i+i/k+i/jei/lui/lei/l+mCsumCtOmCr+mCs+mCsOmYuemYvemYvOmYuumZg+S/jeS/heS/k+S+suS/ieS/i+S/geS/lOS/nOS/meS+u+S+s+S/m+S/h+S/luS+uuS/gOS+ueS/rOWJhOWJieWLgOWLguWMveWNvOWOl+WOluWOmeWOmOWSuuWSoeWSreWSpeWTj1wiXSxcbltcImNlNDBcIixcIuWTg+iMjeWSt+WSruWTluWStuWTheWThuWSoOWRsOWSvOWSouWSvuWRsuWTnuWSsOWeteWenuWen+WepOWejOWel+WeneWem+WelOWemOWej+WemeWepeWemuWeleWjtOWkjeWlk+WnoeWnnuWnruWogOWnseWnneWnuuWnveWnvOWntuWnpOWnsuWnt+Wnm+WnqeWns+WnteWnoOWnvuWntOWnreWuqOWxjOWzkOWzmOWzjOWzl+Wzi+Wzm1wiXSxcbltcImNlYTFcIixcIuWznuWzmuWzieWzh+WziuWzluWzk+WzlOWzj+WziOWzhuWzjuWzn+WzuOW3ueW4oeW4ouW4o+W4oOW4pOW6sOW6pOW6ouW6m+W6o+W6peW8h+W8ruW9luW+huaAt+aAueaBlOaBsuaBnuaBheaBk+aBh+aBieaBm+aBjOaBgOaBguaBn+aApOaBhOaBmOaBpuaBruaJguaJg+aLj+aMjeaMi+aLteaMjuaMg+aLq+aLueaMj+aMjOaLuOaLtuaMgOaMk+aMlOaLuuaMleaLu+aLsOaVgeaVg+aWquaWv+aYtuaYoeaYsuaYteaYnOaYpuaYouaYs+aYq+aYuuaYneaYtOaYueaYruacj+ackOafgeafsuafiOaeulwiXSxcbltcImNmNDBcIixcIuafnOaeu+afuOafmOafgOaet+afheafq+afpOafn+aeteafjeaes+aft+aftuafruafo+afguaeueafjuafp+afsOaesuafvOafhuafreafjOaeruafpuafm+afuuafieafiuafg+afquafi+asqOauguauhOautuavluavmOavoOawoOawoea0qOa0tOa0rea0n+a0vOa0v+a0kua0iuazmua0s+a0hOa0mea0uua0mua0kea0gOa0nea1glwiXSxcbltcImNmYTFcIixcIua0gea0mOa0t+a0g+a0j+a1gOa0h+a0oOa0rOa0iOa0oua0iea0kOeCt+eCn+eCvueCseeCsOeCoeeCtOeCteeCqeeJgeeJieeJiueJrOeJsOeJs+eJrueLiueLpOeLqOeLq+eLn+eLqueLpueLo+eOheePjOePguePiOePheeOueeOtueOteeOtOePq+eOv+ePh+eOvuePg+ePhueOuOePi+eTrOeTrueUrueVh+eViOeWp+eWqueZueebhOeciOecg+echOecheeciuebt+ebu+ebuuefp+efqOeghuegkeegkuegheegkOegj+egjuegieegg+egk+eliueljOeli+elheelhOenleenjeenj+enluenjueqgFwiXSxcbltcImQwNDBcIixcIuepvuerkeesgOesgeexuuexuOexueexv+eygOeygee0g+e0iOe0gee9mOe+kee+jee+vuiAh+iAjuiAj+iAlOiAt+iDmOiDh+iDoOiDkeiDiOiDguiDkOiDheiDo+iDmeiDnOiDiuiDleiDieiDj+iDl+iDpuiDjeiHv+iIoeiKlOiLmeiLvuiLueiMh+iLqOiMgOiLleiMuuiLq+iLluiLtOiLrOiLoeiLsuiLteiMjOiLu+iLtuiLsOiLqlwiXSxcbltcImQwYTFcIixcIuiLpOiLoOiLuuiLs+iLreiZt+iZtOiZvOiZs+ihgeihjuihp+ihquihqeink+iohOioh+i1sui/o+i/oei/rui/oOmDsemCvemCv+mDlemDhemCvumDh+mDi+mDiOmHlOmHk+mZlOmZj+mZkemZk+mZiumZjuWAnuWAheWAh+WAk+WAouWAsOWAm+S/teS/tOWAs+WAt+WArOS/tuS/t+WAl+WAnOWAoOWAp+WAteWAr+WAseWAjuWFmuWGlOWGk+WHiuWHhOWHheWHiOWHjuWJoeWJmuWJkuWJnuWJn+WJleWJouWLjeWMjuWOnuWUpuWTouWUl+WUkuWTp+WTs+WTpOWUmuWTv+WUhOWUiOWTq+WUkeWUheWTsVwiXSxcbltcImQxNDBcIixcIuWUiuWTu+WTt+WTuOWToOWUjuWUg+WUi+WcgeWcguWfjOWgsuWfleWfkuWeuuWfhuWeveWevOWeuOWetuWev+Wfh+WfkOWeueWfgeWkjuWliuWomeWoluWoreWoruWoleWoj+Wol+WoiuWonuWos+WtrOWup+WureWurOWwg+WxluWxlOWzrOWzv+WzruWzseWzt+W0gOWzueW4qeW4qOW6qOW6ruW6quW6rOW8s+W8sOW9p+aBneaBmuaBp1wiXSxcbltcImQxYTFcIixcIuaBgeaCouaCiOaCgOaCkuaCgeaCneaCg+aCleaCm+aCl+aCh+aCnOaCjuaImeaJhuaLsuaMkOaNluaMrOaNhOaNheaMtuaNg+aPpOaMueaNi+aNiuaMvOaMqeaNgeaMtOaNmOaNlOaNmeaMreaNh+aMs+aNmuaNkeaMuOaNl+aNgOaNiOaViuaVhuaXhuaXg+aXhOaXguaZiuaZn+aZh+aZkeackuack+agn+agmuahieagsuags+agu+ahi+ahj+agluagseagnOagteagq+agreagr+ahjuahhOagtOagneagkuaglOagpuagqOagruahjeaguuagpeagoOasrOasr+asreasseastOatreiCguauiOavpuavpFwiXSxcbltcImQyNDBcIixcIuavqOavo+avouavp+awpea1uua1o+a1pOa1tua0jea1oea2kua1mOa1oua1rea1r+a2kea2jea3r+a1v+a2hua1nua1p+a1oOa2l+a1sOa1vOa1n+a2gua2mOa0r+a1qOa2i+a1vua2gOa2hOa0lua2g+a1u+a1vea1tea2kOeDnOeDk+eDkeeDneeDi+e8ueeDoueDl+eDkueDnueDoOeDlOeDjeeDheeDhueDh+eDmueDjueDoeeJgueJuFwiXSxcbltcImQyYTFcIixcIueJt+eJtueMgOeLuueLtOeLvueLtueLs+eLu+eMgeePk+ePmeePpeePlueOvOePp+ePo+ePqeePnOePkuePm+ePlOePneePmuePl+ePmOePqOeTnueTn+eTtOeTteeUoeeVm+eVn+eWsOeXgeeWu+eXhOeXgOeWv+eWtueWuueaiuebieecneecm+eckOeck+eckueco+eckeecleecmeecmuecouecp+ego+egrOegouegteegr+egqOegruegq+egoeegqeegs+egquegseellOelm+elj+elnOelk+elkuelkeenq+enrOenoOenruenreenquennOennuenneeqhueqieeqheeqi+eqjOeqiueqh+ermOeskFwiXSxcbltcImQzNDBcIixcIueshOesk+esheesj+esiOesiuesjuesieeskueyhOeykeeyiueyjOeyiOeyjeeyhee0nue0nee0kee0jue0mOe0lue0k+e0n+e0kue0j+e0jOe9nOe9oee9nue9oOe9nee9m+e+lue+kue/g+e/gue/gOiAluiAvuiAueiDuuiDsuiDueiDteiEgeiDu+iEgOiIgeiIr+iIpeiMs+iMreiNhOiMmeiNkeiMpeiNluiMv+iNgeiMpuiMnOiMolwiXSxcbltcImQzYTFcIixcIuiNguiNjuiMm+iMquiMiOiMvOiNjeiMluiMpOiMoOiMt+iMr+iMqeiNh+iNheiNjOiNk+iMnuiMrOiNi+iMp+iNiOiZk+iZkuiaouiaqOialuiajeiakeianuiah+ial+iahuiai+iamuiaheiapeiameiaoeiap+ialeiamOiajuianeiakOialOihg+ihhOihreihteihtuihsuiigOihseihv+ihr+iig+ihvuihtOihvOiokuixh+ixl+ixu+iypOiyo+i1tui1uOi2tei2t+i2tui7kei7k+i/vui/temAgui/v+i/u+mAhOi/vOi/tumDlumDoOmDmemDmumDo+mDn+mDpemDmOmDm+mDl+mDnOmDpOmFkFwiXSxcbltcImQ0NDBcIixcIumFjumFj+mHlemHoumHmumZnOmZn+mavOmjo+mrn+msr+S5v+WBsOWBquWBoeWBnuWBoOWBk+WBi+WBneWBsuWBiOWBjeWBgeWBm+WBiuWBouWAleWBheWBn+WBqeWBq+WBo+WBpOWBhuWBgOWBruWBs+WBl+WBkeWHkOWJq+WJreWJrOWJruWLluWLk+WMreWOnOWVteWVtuWUvOWVjeWVkOWUtOWUquWVkeWVouWUtuWUteWUsOWVkuWVhVwiXSxcbltcImQ0YTFcIixcIuWUjOWUsuWVpeWVjuWUueWViOWUreWUu+WVgOWVi+WciuWch+Wfu+WglOWfouWftuWfnOWftOWggOWfreWfveWgiOWfuOWgi+Wfs+Wfj+Wgh+WfruWfo+WfsuWfpeWfrOWfoeWgjuWfvOWgkOWfp+WggeWgjOWfseWfqeWfsOWgjeWghOWlnOWpoOWpmOWpleWpp+WpnuWouOWoteWpreWpkOWpn+WppeWprOWpk+WppOWpl+Wpg+WpneWpkuWphOWpm+WpiOWqjuWovuWpjeWoueWpjOWpsOWpqeWph+WpkeWpluWpguWpnOWtsuWtruWvgeWvgOWxmeW0nuW0i+W0neW0muW0oOW0jOW0qOW0jeW0puW0peW0j1wiXSxcbltcImQ1NDBcIixcIuW0sOW0kuW0o+W0n+W0ruW4vuW4tOW6seW6tOW6ueW6suW6s+W8tuW8uOW+m+W+luW+n+aCiuaCkOaChuaCvuaCsOaCuuaDk+aDlOaDj+aDpOaDmeaDneaDiOaCseaDm+aCt+aDiuaCv+aDg+aDjeaDgOaMsuaNpeaOiuaOguaNveaOveaOnuaOreaOneaOl+aOq+aOjuaNr+aOh+aOkOaNruaOr+aNteaOnOaNreaOruaNvOaOpOaMu+aOn1wiXSxcbltcImQ1YTFcIixcIuaNuOaOheaOgeaOkeaOjeaNsOaVk+aXjeaZpeaZoeaZm+aZmeaZnOaZouacmOahueaih+aikOainOahreahruairuaiq+alluahr+aio+airOaiqeahteahtOaisuaij+aht+aikuahvOahq+ahsuaiquaigOahseahvuaim+ailuaii+aioOaiieaipOahuOahu+aikeaijOaiiuahveastuass+ast+asuOaukeauj+aujeaujuaujOawqua3gOa2q+a2tOa2s+a5tOa2rOa3qea3oua2t+a3tua3lOa4gOa3iOa3oOa3n+a3lua2vua3pea3nOa3nea3m+a3tOa3iua2vea3rea3sOa2uua3lea3gua3j+a3iVwiXSxcbltcImQ2NDBcIixcIua3kOa3sua3k+a3vea3l+a3jea3o+a2u+eDuueEjeeDt+eEl+eDtOeEjOeDsOeEhOeDs+eEkOeDvOeDv+eEhueEk+eEgOeDuOeDtueEi+eEgueEjueJvueJu+eJvOeJv+eMneeMl+eMh+eMkeeMmOeMiueMiOeLv+eMj+eMnueOiOePtuePuOePteeQhOeQgeePveeQh+eQgOePuuePvOePv+eQjOeQi+ePtOeQiOeVpOeVo+eXjueXkueXj1wiXSxcbltcImQ2YTFcIixcIueXi+eXjOeXkeeXkOeaj+eaieebk+ecueecr+ecreecseecsuectOecs+ecveecpeecu+ecteehiOehkuehieehjeehiuehjOegpuehheehkOelpOelp+elqeelquelo+elq+eloeemu+enuuenuOentuent+eqj+eqlOeqkOesteeth+estOespeessOesouespOess+esmOesquesneesseesq+esreesr+essuesuOesmueso+eylOeymOeylueyo+e0tee0vee0uOe0tue0uue1hee0rOe0qee1gee1h+e0vue0v+e1iue0u+e0qOe9o+e+lee+nOe+nee+m+e/iue/i+e/jee/kOe/kee/h+e/j+e/ieiAn1wiXSxcbltcImQ3NDBcIixcIuiAnuiAm+iBh+iBg+iBiOiEmOiEpeiEmeiEm+iEreiEn+iErOiEnuiEoeiEleiEp+iEneiEouiIkeiIuOiIs+iIuuiItOiIsuiJtOiOkOiOo+iOqOiOjeiNuuiNs+iOpOiNtOiOj+iOgeiOleiOmeiNteiOlOiOqeiNveiOg+iOjOiOneiOm+iOquiOi+iNvuiOpeiOr+iOiOiOl+iOsOiNv+iOpuiOh+iOruiNtuiOmuiZmeiZluiav+iat1wiXSxcbltcImQ3YTFcIixcIuibguibgeibheiauuiasOibiOiaueias+iauOibjOiatOiau+iavOibg+iaveiavuihkuiiieiileiiqOiiouiiquiimuiikeiioeiin+iimOiip+iimeiim+iil+iipOiirOiijOiik+iijuimguinluinmeinleiosOiop+iorOionuiwueiwu+ixnOixneixveiypei1vei1u+i1uei2vOi3gui2uei2v+i3gei7mOi7nui7nei7nOi7l+i7oOi7oemApOmAi+mAkemAnOmAjOmAoemDr+mDqumDsOmDtOmDsumDs+mDlOmDq+mDrOmDqemFlumFmOmFmumFk+mFlemHrOmHtOmHsemHs+mHuOmHpOmHuemHqlwiXSxcbltcImQ4NDBcIixcIumHq+mHt+mHqOmHrumVuumWhumWiOmZvOmZremZq+mZsemZr+mav+mdqumghOmjpemml+WCm+WCleWClOWCnuWCi+WCo+WCg+WCjOWCjuWCneWBqOWCnOWCkuWCguWCh+WFn+WHlOWMkuWMkeWOpOWOp+WWkeWWqOWWpeWWreWVt+WZheWWouWWk+WWiOWWj+WWteWWgeWWo+WWkuWWpOWVveWWjOWWpuWVv+WWleWWoeWWjuWcjOWgqeWgt1wiXSxcbltcImQ4YTFcIixcIuWgmeWgnuWgp+Wgo+WgqOWfteWhiOWgpeWgnOWgm+Wgs+Wgv+WgtuWgruWgueWguOWgreWgrOWgu+WloeWqr+WqlOWqn+WpuuWqouWqnuWpuOWqpuWpvOWqpeWqrOWqleWqruWot+WqhOWqiuWql+Wqg+Wqi+WqqeWpu+WpveWqjOWqnOWqj+Wqk+WqneWvquWvjeWvi+WvlOWvkeWviuWvjuWwjOWwsOW0t+W1g+W1q+W1geW1i+W0v+W0teW1keW1juW1leW0s+W0uuW1kuW0veW0seW1meW1guW0ueW1ieW0uOW0vOW0suW0tuW1gOW1heW5hOW5geW9mOW+puW+peW+q+aDieaCueaDjOaDouaDjuaDhOaElFwiXSxcbltcImQ5NDBcIixcIuaDsuaEiuaEluaEheaDteaEk+aDuOaDvOaDvuaDgeaEg+aEmOaEneaEkOaDv+aEhOaEi+aJiuaOlOaOseaOsOaPjuaPpeaPqOaPr+aPg+aSneaPs+aPiuaPoOaPtuaPleaPsuaPteaRoeaPn+aOvuaPneaPnOaPhOaPmOaPk+aPguaPh+aPjOaPi+aPiOaPsOaPl+aPmeaUsuaVp+aVquaVpOaVnOaVqOaVpeaWjOaWneaWnuaWruaXkOaXklwiXSxcbltcImQ5YTFcIixcIuaZvOaZrOaZu+aagOaZseaZueaZquaZsuacgeakjOajk+akhOajnOakquajrOajquajseakj+ajluajt+ajq+ajpOajtuakk+akkOajs+ajoeakh+ajjOakiOalsOaitOakkeajr+ajhuaklOajuOajkOajveajvOajqOaki+akiuakl+ajjuajiOajneajnuajpuajtOajkeakhuajlOajqeakleakpeajh+asueasu+asv+asvOaulOaul+aumeauleauveavsOavsuavs+awsOa3vOa5hua5h+a4n+a5iea6iOa4vOa4vea5hea5oua4q+a4v+a5gea5nea5s+a4nOa4s+a5i+a5gOa5kea4u+a4g+a4rua5nlwiXSxcbltcImRhNDBcIixcIua5qOa5nOa5oea4sea4qOa5oOa5sea5q+a4uea4oua4sOa5k+a5pea4p+a5uOa5pOa5t+a5lea5uea5kua5pua4tea4tua5mueEoOeEnueEr+eDu+eErueEseeEo+eEpeeEoueEsueEn+eEqOeEuueEm+eJi+eJmueKiOeKieeKhueKheeKi+eMkueMi+eMsOeMoueMseeMs+eMp+eMsueMreeMpueMo+eMteeMjOeQrueQrOeQsOeQq+eQllwiXSxcbltcImRhYTFcIixcIueQmueQoeeQreeQseeQpOeQo+eQneeQqeeQoOeQsueTu+eUr+eVr+eVrOeXp+eXmueXoeeXpueXneeXn+eXpOeXl+ealeeakuebmuedhuedh+edhOedjeedheediuedjuedi+edjOefnuefrOehoOehpOehpeehnOehreehseehquehruehsOehqeehqOehnuehoueltOels+elsuelsOeogueoiueog+eojOeohOeqmeerpuerpOetiuesu+ethOetiOetjOetjuetgOetmOetheeyoueynueyqOeyoee1mOe1r+e1o+e1k+e1lue1p+e1que1j+e1ree1nOe1q+e1kue1lOe1qee1kee1n+e1jue8vue8v+e9pVwiXSxcbltcImRiNDBcIixcIue9pue+oue+oOe+oee/l+iBkeiBj+iBkOiDvuiDlOiFg+iFiuiFkuiFj+iFh+iEveiFjeiEuuiHpuiHruiHt+iHuOiHueiIhOiIvOiIveiIv+iJteiMu+iPj+iPueiQo+iPgOiPqOiQkuiPp+iPpOiPvOiPtuiQkOiPhuiPiOiPq+iPo+iOv+iQgeiPneiPpeiPmOiPv+iPoeiPi+iPjuiPluiPteiPieiQieiQj+iPnuiQkeiQhuiPguiPs1wiXSxcbltcImRiYTFcIixcIuiPleiPuuiPh+iPkeiPquiQk+iPg+iPrOiPruiPhOiPu+iPl+iPouiQm+iPm+iPvuibmOibouibpuibk+ibo+ibmuibquibneibq+ibnOibrOibqeibl+ibqOibkeihiOihluihleiiuuijl+iiueiiuOijgOiivuiituiivOiit+iiveiisuikgeijieimleimmOiml+inneinmuinm+ipjuipjeioueipmeipgOipl+ipmOiphOipheipkuipiOipkeipiuipjOipj+ixn+iygeiygOiyuuiyvuiysOiyueiytei2hOi2gOi2iei3mOi3k+i3jei3h+i3lui3nOi3j+i3lei3mei3iOi3l+i3hei7r+i7t+i7ulwiXSxcbltcImRjNDBcIixcIui7uei7pui7rui7pei7tei7p+i7qOi7tui7q+i7sei7rOi7tOi7qemAremAtOmAr+mEhumErOmEhOmDv+mDvOmEiOmDuemDu+mEgemEgOmEh+mEhemEg+mFoemFpOmFn+mFoumFoOmIgemIiumIpemIg+mImumIpumIj+mIjOmIgOmIkumHv+mHvemIhumIhOmIp+mIgumInOmIpOmImemIl+mIhemIlumVu+mWjemWjOmWkOmah+mZvumaiFwiXSxcbltcImRjYTFcIixcIumaiemag+magOmbgumbiOmbg+mbsembsOmdrOmdsOmdrumgh+miqemjq+mzpum7ueS6g+S6hOS6tuWCveWCv+WDhuWCruWDhOWDiuWCtOWDiOWDguWCsOWDgeWCuuWCseWDi+WDieWCtuWCuOWHl+WJuuWJuOWJu+WJvOWXg+WXm+WXjOWXkOWXi+WXiuWXneWXgOWXlOWXhOWXqeWWv+WXkuWWjeWXj+WXleWXouWXluWXiOWXsuWXjeWXmeWXguWclOWhk+WhqOWhpOWhj+WhjeWhieWhr+WhleWhjuWhneWhmeWhpeWhm+WgveWho+WhseWjvOWrh+WrhOWri+WquuWquOWqseWqteWqsOWqv+WriOWqu+WrhlwiXSxcbltcImRkNDBcIixcIuWqt+WrgOWriuWqtOWqtuWrjeWqueWqkOWvluWvmOWvmeWwn+Wws+W1seW1o+W1iuW1peW1suW1rOW1nuW1qOW1p+W1ouW3sOW5j+W5juW5iuW5jeW5i+W7heW7jOW7huW7i+W7h+W9gOW+r+W+reaDt+aFieaFiuaEq+aFheaEtuaEsuaEruaFhuaEr+aFj+aEqeaFgOaIoOmFqOaIo+aIpeaIpOaPheaPseaPq+aQkOaQkuaQieaQoOaQpFwiXSxcbltcImRkYTFcIixcIuaQs+aRg+aQn+aQleaQmOaQueaQt+aQouaQo+aQjOaQpuaQsOaQqOaRgeaQteaQr+aQiuaQmuaRgOaQpeaQp+aQi+aPp+aQm+aQruaQoeaQjuaVr+aWkuaXk+aahuaajOaaleaakOaai+aaiuaameaalOaZuOacoOalpualn+akuOaljualoualseakv+alhealquakuealguall+almealuualiOalieaktealrOaks+akvealpeajsOaluOaktOalqealgOalr+alhOaltualmOalgealtOaljOaku+ali+akt+alnOalj+alkeaksualkuakr+alu+akvOathuatheatg+atguatiOatgeaum++ojeavu+avvFwiXSxcbltcImRlNDBcIixcIuavueavt+avuOa6m+a7lua7iOa6j+a7gOa6n+a6k+a6lOa6oOa6sea6uea7hua7kua6vea7gea6nua7iea6t+a6sOa7jea6pua7j+a6sua6vua7g+a7nOa7mOa6mea6kua6jua6jea6pOa6oea6v+a6s+a7kOa7iua6l+a6rua6o+eFh+eFlOeFkueFo+eFoOeFgeeFneeFoueFsueFuOeFqueFoeeFgueFmOeFg+eFi+eFsOeFn+eFkOeFk1wiXSxcbltcImRlYTFcIixcIueFhOeFjeeFmueJj+eKjeeKjOeKkeeKkOeKjueMvOeNgueMu+eMuueNgOeNiueNieeRhOeRiueRi+eRkueRkeeRl+eRgOeRj+eRkOeRjueRgueRhueRjeeRlOeToeeTv+eTvueTveeUneeVueeVt+amg+eXr+eYj+eYg+eXt+eXvueXvOeXueeXuOeYkOeXu+eXtueXreeXteeXveeameeateebneedleedn+edoOedkuedluedmuedqeedp+edlOedmeedreefoOeih+eimueilOeij+eihOeileeiheeihueioeeig+ehueeimeeigOeiluehu+elvOemguelveelueeokeeomOeomeeokueol+eoleeooueok1wiXSxcbltcImRmNDBcIixcIueom+eokOeqo+eqoueqnuerq+etpuetpOetreettOetqeetsuetpeets+etseetsOetoeetuOettueto+eysueytOeyr+e2iOe2hue2gOe2jee1v+e2hee1uue2jue1u+e2g+e1vOe2jOe2lOe2hOe1vee2kue9ree9q+e9p+e9qOe9rOe+pue+pee+p+e/m+e/nOiAoeiFpOiFoOiFt+iFnOiFqeiFm+iFouiFsuacoeiFnuiFtuiFp+iFr1wiXSxcbltcImRmYTFcIixcIuiFhOiFoeiIneiJieiJhOiJgOiJguiJheiTseiQv+iRluiRtuiRueiSj+iSjeiRpeiRkeiRgOiShuiRp+iQsOiRjeiRveiRmuiRmeiRtOiRs+iRneiUh+iRnuiQt+iQuuiQtOiRuuiRg+iRuOiQsuiRheiQqeiPmeiRi+iQr+iRguiQreiRn+iRsOiQueiRjuiRjOiRkuiRr+iTheiSjuiQu+iRh+iQtuiQs+iRqOiRvuiRhOiQq+iRoOiRlOiRruiRkOici+ichOibt+icjOibuuibluibteidjeibuOicjuicieicgeibtuicjeicheijluiji+ijjeijjuijnuijm+ijmuijjOijkOimheimm+inn+inpeinpFwiXSxcbltcImUwNDBcIixcIuinoeinoOinouinnOinpuiptuiqhuipv+ipoeiov+ipt+iqguiqhOipteiqg+iqgeiptOipuuiwvOixi+ixiuixpeixpOixpuiyhuiyhOiyheizjOi1qOi1qei2kei2jOi2jui2j+i2jei2k+i2lOi2kOi2kui3sOi3oOi3rOi3sei3rui3kOi3qei3o+i3oui3p+i3sui3q+i3tOi8hui7v+i8gei8gOi8hei8h+i8iOi8gui8i+mBkumAv1wiXSxcbltcImUwYTFcIixcIumBhOmBiemAvemEkOmEjemEj+mEkemElumElOmEi+mEjumFrumFr+mJiOmJkumIsOmIuumJpumIs+mJpemJnumKg+mIrumJiumJhumJremJrOmJj+mJoOmJp+mJr+mItumJoemJsOmIsemJlOmJo+mJkOmJsumJjumJk+mJjOmJlumIsumWn+mWnOmWnumWm+makumak+makemal+mbjumbuumbvembuOmbtemds+mdt+mduOmdsumgj+mgjemgjumirOmjtumjuemmr+mmsummsOmmtemqremqq+mtm+mzqumzremzp+m6gOm7veWDpuWDlOWDl+WDqOWDs+WDm+WDquWDneWDpOWDk+WDrOWDsOWDr+WDo+WDoFwiXSxcbltcImUxNDBcIixcIuWHmOWKgOWKgeWLqeWLq+WMsOWOrOWYp+WYleWYjOWYkuWXvOWYj+WYnOWYgeWYk+WYguWXuuWYneWYhOWXv+WXueWiieWhvOWikOWimOWihuWigeWhv+WhtOWii+WhuuWih+WikeWijuWhtuWiguWiiOWhu+WilOWij+WjvuWlq+WrnOWrruWrpeWrleWrquWrmuWrreWrq+Wrs+WrouWroOWrm+WrrOWrnuWrneWrmeWrqOWrn+Wtt+WvoFwiXSxcbltcImUxYTFcIixcIuWvo+Wxo+W2guW2gOW1veW2huW1uuW2geW1t+W2iuW2ieW2iOW1vuW1vOW2jeW1ueW1v+W5mOW5meW5k+W7mOW7keW7l+W7juW7nOW7leW7meW7kuW7lOW9hOW9g+W9r+W+tuaErOaEqOaFgeaFnuaFseaFs+aFkuaFk+aFsuaFrOaGgOaFtOaFlOaFuuaFm+aFpeaEu+aFquaFoeaFluaIqeaIp+aIq+aQq+aRjeaRm+aRneaRtOaRtuaRsuaRs+aRveaRteaRpuaSpuaRjuaSguaRnuaRnOaRi+aRk+aRoOaRkOaRv+aQv+aRrOaRq+aRmeaRpeaRt+aVs+aWoOaaoeaaoOaan+acheachOacouamseamtuaniVwiXSxcbltcImUyNDBcIixcIuamoOanjuamluamsOamrOamvOamkeammeamjuamp+amjeamqeamvuamr+amv+anhOamveampOanlOamueaniuammuanj+ams+amk+amquamoeamnuanmeaml+amkOanguamteampeanhuatiuatjeati+aunuaun+auoOavg+avhOavvua7jua7tea7sea8g+a8pea7uOa8t+a7u+a8rua8iea9jua8mea8mua8p+a8mOa8u+a8kua7rea8ilwiXSxcbltcImUyYTFcIixcIua8tua9s+a7uea7rua8rea9gOa8sOa8vOa8tea7q+a8h+a8jua9g+a8hea7vea7tua8uea8nOa7vOa8uua8n+a8jea8nua8iOa8oeeGh+eGkOeGieeGgOeGheeGgueGj+eFu+eGhueGgeeGl+eJhOeJk+eKl+eKleeKk+eNg+eNjeeNkeeNjOeRoueRs+eRseeRteeRsueRp+eRrueUgOeUgueUg+eVveeWkOeYlueYiOeYjOeYleeYkeeYiueYlOeauOeegeedvOeeheeeguedrueegOedr+edvueeg+eisueiqueitOeireeiqOehvueiq+einueipeeioOeirOeioueipOemmOemiuemi+emluemleemlOemk1wiXSxcbltcImUzNDBcIixcIueml+emiOemkuemkOeoq+epiueosOeor+eoqOeopueqqOeqq+eqrOerrueuiOeunOeuiueukeeukOeulueujeeujOeum+eujueuheeumOWKhOeumeeupOeugueyu+eyv+eyvOeyuue2p+e2t+e3gue2o+e2que3gee3gOe3hee2nee3jue3hOe3hue3i+e3jOe2r+e2uee2lue2vOe2n+e2pue2rue2qee2oee3iee9s+e/oue/o+e/pee/nlwiXSxcbltcImUzYTFcIixcIuiApOiBneiBnOiGieiGhuiGg+iGh+iGjeiGjOiGi+iIleiSl+iSpOiSoeiSn+iSuuiTjuiTguiSrOiSruiSq+iSueiStOiTgeiTjeiSquiSmuiSseiTkOiSneiSp+iSu+iSouiSlOiTh+iTjOiSm+iSqeiSr+iSqOiTluiSmOiStuiTj+iSoOiTl+iTlOiTkuiTm+iSsOiSkeiZoeics+ico+icqOidq+idgOicruicnuicoeicmeicm+idg+icrOidgeicvuidhuicoOicsuicquicreicvOickuicuuicseicteidguicpuicp+icuOicpOicmuicsOickeijt+ijp+ijseijsuijuuijvuijruijvOijtuiju1wiXSxcbltcImU0NDBcIixcIuijsOijrOijq+imneimoeimn+imnuinqeinq+inqOiqq+iqmeiqi+iqkuiqj+iqluiwveixqOixqeizleizj+izl+i2lui4iei4gui3v+i4jei3vei4iui4g+i4h+i4hui4hei3vui4gOi4hOi8kOi8kei8jui8jemEo+mEnOmEoOmEoumEn+mEnemEmumEpOmEoemEm+mFuumFsumFuemFs+mKpemKpOmJtumKm+mJuumKoOmKlOmKqumKjVwiXSxcbltcImU0YTFcIixcIumKpumKmumKq+mJuemKl+mJv+mKo+mLrumKjumKgumKlemKoumJvemKiOmKoemKiumKhumKjOmKmemKp+mJvumKh+mKqemKnemKi+mIremanumaoembv+mdmOmdvemduumdvumeg+megOmegumdu+mehOmegemdv+mfjumfjemglumiremirumkgumkgOmkh+mmnemmnOmng+mmuemmu+mmuumngummvemnh+mqsemro+mrp+msvumsv+mtoOmtoemtn+mzsemzsumztem6p+WDv+WEg+WEsOWDuOWEhuWEh+WDtuWDvuWEi+WEjOWDveWEiuWKi+WKjOWLseWLr+WZiOWZguWZjOWYteWZgeWZiuWZieWZhuWZmFwiXSxcbltcImU1NDBcIixcIuWZmuWZgOWYs+WYveWYrOWYvuWYuOWYquWYuuWcmuWiq+WineWiseWioOWio+Wir+WirOWipeWioeWjv+Wrv+WrtOWrveWrt+WrtuWsg+WruOWsguWrueWsgeWsh+WsheWsj+Wxp+W2meW2l+W2n+W2kuW2ouW2k+W2leW2oOW2nOW2oeW2muW2nuW5qeW5neW5oOW5nOe3s+W7m+W7nuW7oeW9ieW+suaGi+aGg+aFueaGseaGsOaGouaGiVwiXSxcbltcImU1YTFcIixcIuaGm+aGk+aGr+aGreaGn+aGkuaGquaGoeaGjeaFpuaGs+aIreaRruaRsOaSluaSoOaSheaSl+aSnOaSj+aSi+aSiuaSjOaSo+aSn+aRqOaSseaSmOaVtuaVuuaVueaVu+aWsuaWs+aateaasOaaqeaasuaat+aaquaar+aogOaohuaol+anpeanuOaoleanseanpOaooOanv+anrOanouaom+aoneanvuaop+ansuanruaolOant+anp+apgOaoiOanpuanu+aojeanvOanq+aoieaohOaomOaopeaoj+antuaopuaoh+antOaoluatkeaupeauo+auouaupuawgeawgOavv+awgua9gea8pua9vua+h+a/hua+klwiXSxcbltcImU2NDBcIixcIua+jea+iea+jOa9oua9j+a+hea9mua+lua9tua9rOa+gua9lea9sua9kua9kOa9l+a+lOa+k+a9nea8gOa9oea9q+a9vea9p+a+kOa9k+a+i+a9qea9v+a+lea9o+a9t+a9qua9u+eGsueGr+eGm+eGsOeGoOeGmueGqeeGteeGneeGpeeGnueGpOeGoeeGqueGnOeGp+eGs+eKmOeKmueNmOeNkueNnueNn+eNoOeNneeNm+eNoeeNmueNmVwiXSxcbltcImU2YTFcIixcIueNoueSh+eSieeSiueShueSgeeRveeSheeSiOeRvOeRueeUiOeUh+eVvueYpeeYnueYmeeYneeYnOeYo+eYmueYqOeYm+eanOeaneeanueam+eejeeej+eeieeeiOejjeeiu+ejj+ejjOejkeejjuejlOejiOejg+ejhOejieemmuemoeemoOemnOemouemm+attueoueeqsueqtOeqs+eut+evi+euvueurOevjueur+euueeviueuteezheeziOezjOezi+e3t+e3m+e3que3p+e3l+e3oee4g+e3uue3pue3tue3see3sOe3rue3n+e9tue+rOe+sOe+ree/ree/q+e/que/rOe/pue/qOiBpOiBp+iGo+iGn1wiXSxcbltcImU3NDBcIixcIuiGnuiGleiGouiGmeiGl+iIluiJj+iJk+iJkuiJkOiJjuiJkeiUpOiUu+iUj+iUgOiUqeiUjuiUieiUjeiUn+iUiuiUp+iUnOiTu+iUq+iTuuiUiOiUjOiTtOiUquiTsuiUleiTt+iTq+iTs+iTvOiUkuiTquiTqeiUluiTvuiUqOiUneiUruiUguiTveiUnuiTtuiUseiUpuiTp+iTqOiTsOiTr+iTueiUmOiUoOiUsOiUi+iUmeiUr+iZolwiXSxcbltcImU3YTFcIixcIuidluido+idpOidt+ifoeids+idmOidlOidm+idkuidoeidmuidkeidnuidreidquidkOidjuidn+idneidr+idrOiduuidruidnOidpeidj+idu+idteidouidp+idqeihmuikheikjOiklOiki+ikl+ikmOikmeikhuikluikkeikjuikieimouimpOimo+inreinsOinrOirj+irhuiquOirk+irkeirlOirleiqu+irl+iqvuirgOirheirmOirg+iquuiqveirmeiwvuixjeiyj+izpeizn+izmeizqOizmuizneizp+i2oOi2nOi2oei2m+i4oOi4o+i4pei4pOi4rui4lei4m+i4lui4kei4mei4pui4p1wiXSxcbltcImU4NDBcIixcIui4lOi4kui4mOi4k+i4nOi4l+i4mui8rOi8pOi8mOi8mui8oOi8o+i8lui8l+mBs+mBsOmBr+mBp+mBq+mEr+mEq+mEqemEqumEsumEpumErumGhemGhumGiumGgemGgumGhOmGgOmLkOmLg+mLhOmLgOmLmemKtumLj+mLsemLn+mLmOmLqemLl+mLnemLjOmLr+mLgumLqOmLiumLiOmLjumLpumLjemLlemLiemLoOmLnumLp+mLkemLk1wiXSxcbltcImU4YTFcIixcIumKtemLoemLhumKtOmVvOmWrOmWq+mWrumWsOmapOmaoumbk+mchemciOmcgumdmumeiumejumeiOmfkOmfj+mgnumgnemgpumgqemgqOmgoOmgm+mgp+misumkiOmjuumkkemklOmklumkl+mklemnnOmnjemnj+mnk+mnlOmnjumniemnlumnmOmni+mnl+mnjOmqs+mrrOmrq+mrs+mrsumrsemthumtg+mtp+mttOmtsemtpumttumttemtsOmtqOmtpOmtrOmzvOmzuumzvemzv+mzt+m0h+m0gOmzuemzu+m0iOm0hem0hOm6g+m7k+m8j+m8kOWEnOWEk+WEl+WEmuWEkeWHnuWMtOWPoeWZsOWZoOWZrlwiXSxcbltcImU5NDBcIixcIuWZs+WZpuWZo+WZreWZsuWZnuWZt+WcnOWcm+WjiOWiveWjieWiv+WiuuWjguWivOWjhuWsl+WsmeWsm+WsoeWslOWsk+WskOWsluWsqOWsmuWsoOWsnuWvr+W2rOW2seW2qeW2p+W2teW2sOW2ruW2quW2qOW2suW2reW2r+W2tOW5p+W5qOW5puW5r+W7qeW7p+W7puW7qOW7peW9i+W+vOaGneaGqOaGluaHheaGtOaHhuaHgeaHjOaGulwiXSxcbltcImU5YTFcIixcIuaGv+aGuOaGjOaTl+aTluaTkOaTj+aTieaSveaSieaTg+aTm+aTs+aTmeaUs+aVv+aVvOaWouabiOaavuabgOabiuabi+abj+aaveaau+aauuabjOaco+aotOappuapieapp+aosuapqOaovuapneapreaptuapm+apkeaoqOapmuaou+aov+apgeapquappOapkOapj+aplOapr+apqeapoOaovOapnuapluapleapjeapjuaphuatleatlOatluaup+auquauq+aviOavh+awhOawg+awhua+rea/i+a+o+a/h+a+vOa/jua/iOa9nua/hOa+vea+nua/iua+qOeAhOa+pea+rua+uua+rOa+qua/j+a+v+a+uFwiXSxcbltcImVhNDBcIixcIua+oua/iea+q+a/jea+r+a+sua+sOeHheeHgueGv+eGuOeHlueHgOeHgeeHi+eHlOeHiueHh+eHj+eGveeHmOeGvOeHhueHmueHm+eKneeKnueNqeeNpueNp+eNrOeNpeeNq+eNqueRv+eSmueSoOeSlOeSkueSleeSoeeUi+eWgOeYr+eYreeYseeYveeYs+eYvOeYteeYsueYsOeau+ebpueemueeneeeoeeenOeem+eeoueeo+eeleeemVwiXSxcbltcImVhYTFcIixcIueel+ejneejqeejpeejquejnuejo+ejm+ejoeejouejreejn+ejoOempOephOepiOeph+eqtuequOeqteeqseeqt+evnuevo+evp+evneevleevpeevmuevqOevueevlOevquevouevnOevq+evmOevn+ezkuezlOezl+ezkOezkee4kue4oee4l+e4jOe4n+e4oOe4k+e4jue4nOe4lee4mue4oue4i+e4j+e4lue4jee4lOe4pee4pOe9g+e9u+e9vOe9uue+see/r+iAquiAqeiBrOiGseiGpuiGruiGueiGteiGq+iGsOiGrOiGtOiGsuiGt+iGp+iHsuiJleiJluiJl+iVluiVheiVq+iVjeiVk+iVoeiVmFwiXSxcbltcImViNDBcIixcIuiVgOiVhuiVpOiVgeiVouiVhOiVkeiVh+iVo+iUvuiVm+iVseiVjuiVruiVteiVleiVp+iVoOiWjOiVpuiVneiVlOiVpeiVrOiZo+iZpeiZpOiem+iej+iel+iek+iekuieiOiegeieluiemOidueieh+ieo+ieheiekOiekeieneiehOielOienOiemuieieiknuikpuiksOikreikruikp+ikseikouikqeiko+ikr+ikrOikn+inseiroFwiXSxcbltcImViYTFcIixcIuirouirsuirtOirteirneislOirpOirn+irsOiriOirnuiroeirqOirv+irr+iru+iykeiykuiykOizteizruizseizsOizs+i1rOi1rui2pei2p+i4s+i4vui4uOi5gOi5hei4tui4vOi4vei5gei4sOi4v+i6vei8tui8rui8tei8sui8uei8t+i8tOmBtumBuemBu+mChumDuumEs+mEtemEtumGk+mGkOmGkemGjemGj+mMp+mMnumMiOmMn+mMhumMj+mNuumMuOmMvOmMm+mMo+mMkumMgemNhumMremMjumMjemLi+mMnemLuumMpemMk+mLuemLt+mMtOmMgumMpOmLv+mMqemMuemMtemMqumMlOmMjFwiXSxcbltcImVjNDBcIixcIumMi+mLvumMiemMgOmLu+mMlumWvOmXjemWvumWuemWuumWtumWv+mWtemWvemaqemblOmci+mckumckOmememel+melOmfsOmfuOmgtemgr+mgsumkpOmkn+mkp+mkqemmnumnrumnrOmnpemnpOmnsOmno+mnqumnqemnp+mquemqv+mqtOmqu+mrtumruumruemrt+mss+mugOmuhemuh+mtvOmtvumtu+mugumuk+mukumukOmtuumulVwiXSxcbltcImVjYTFcIixcIumtvemuiOm0pem0l+m0oOm0num0lOm0qem0nem0mOm0oum0kOm0mem0n+m6iOm6hum6h+m6rum6rem7lem7lum7uum8kum8veWEpuWEpeWEouWEpOWEoOWEqeWLtOWak+WajOWajeWahuWahOWag+WZvuWaguWZv+WageWjluWjlOWjj+WjkuWsreWspeWssuWso+WsrOWsp+WspuWsr+WsruWtu+WvseWvsuW2t+W5rOW5quW+vuW+u+aHg+aGteaGvOaHp+aHoOaHpeaHpOaHqOaHnuaTr+aTqeaTo+aTq+aTpOaTqOaWgeaWgOaWtuaXmuabkuaqjeaqluaqgeaqpeaqieaqn+aqm+aqoeaqnuaqh+aqk+aqjlwiXSxcbltcImVkNDBcIixcIuaqleaqg+aqqOaqpOaqkeapv+aqpuaqmuaqheaqjOaqkuatm+aureawiea/jOa+qea/tOa/lOa/o+a/nOa/rea/p+a/pua/nua/sua/nea/oua/qOeHoeeHseeHqOeHsueHpOeHsOeHoueNs+eNrueNr+eSl+eSsueSq+eSkOeSqueSreeSseeSpeeSr+eUkOeUkeeUkueUj+eWhOeZg+eZiOeZieeZh+eapOebqeeeteeeq+eesueet+eetlwiXSxcbltcImVkYTFcIixcIueetOeeseeeqOefsOejs+ejveekgueju+ejvOejsuekheejueejvuekhOemq+emqOepnOepm+epluepmOeplOepmueqvuergOergeewheewj+evsuewgOevv+evu+ewjuevtOewi+evs+ewguewieewg+ewgeevuOevveewhuevsOevseewkOewiuezqOe4ree4vOe5gue4s+mhiOe4uOe4que5iee5gOe5h+e4qee5jOe4sOe4u+e4tue5hOe4uue9hee9v+e9vue9vee/tOe/suiArOiGu+iHhOiHjOiHiuiHheiHh+iGvOiHqeiJm+iJmuiJnOiWg+iWgOiWj+iWp+iWleiWoOiWi+iWo+iVu+iWpOiWmuiWnlwiXSxcbltcImVlNDBcIixcIuiVt+iVvOiWieiWoeiVuuiVuOiVl+iWjuiWluiWhuiWjeiWmeiWneiWgeiWouiWguiWiOiWheiVueiVtuiWmOiWkOiWn+iZqOievuiequiereifheiesOierOieueieteievOieruifieifg+ifguifjOiet+ier+ifhOifiuietOietuiev+ieuOieveifnuiesuikteiks+ikvOikvuilgeilkuikt+ilguimreimr+imruinsuins+isnlwiXSxcbltcImVlYTFcIixcIuismOisluiskeisheisi+isouisj+iskuisleish+isjeisiOishuisnOisk+ismuixj+ixsOixsuixseixr+iyleiylOizuei1r+i5jui5jei5k+i5kOi5jOi5h+i9g+i9gOmChemBvumEuOmGmumGoumGm+mGmemGn+mGoemGnemGoOmOoemOg+mOr+mNpOmNlumNh+mNvOmNmOmNnOmNtumNiemNkOmNkemNoOmNremOj+mNjOmNqumNuemNl+mNlemNkumNj+mNsemNt+mNu+mNoemNnumNo+mNp+mOgOmNjumNmemXh+mXgOmXiemXg+mXhemWt+marumasOmarOmcoOmcn+mcmOmcnemcmememumeoemenFwiXSxcbltcImVmNDBcIixcIumenumenemflemflOmfsemhgemhhOmhiumhiemhhemhg+mkpemkq+mkrOmkqumks+mksumkr+mkremksemksOmmmOmmo+mmoemogumnuumntOmnt+mnuemnuOmntumnu+mnvemnvumnvOmog+mqvumrvumrvemsgemrvOmtiOmumumuqOmunumum+mupumuoemupemupOmuhumuoumuoOmur+m0s+m1gem1p+m0tum0rum0r+m0sem0uOm0sFwiXSxcbltcImVmYTFcIixcIum1hem1gum1g+m0vum0t+m1gOm0vee/tem0rem6ium6iem6jem6sOm7iOm7mum7u+m7v+m8pOm8o+m8oum9lOm+oOWEseWEreWEruWamOWanOWal+WamuWaneWameWlsOWsvOWxqeWxquW3gOW5reW5ruaHmOaHn+aHreaHruaHseaHquaHsOaHq+aHluaHqeaTv+aUhOaTveaTuOaUgeaUg+aTvOaWlOaXm+abmuabm+abmOarheaqueaqvearoearhuaquuaqtuaqt+arh+aqtOaqreatnuavieawi+eAh+eAjOeAjeeAgeeAheeAlOeAjua/v+eAgOa/u+eApua/vOa/t+eAiueIgeeHv+eHueeIg+eHveeNtlwiXSxcbltcImYwNDBcIixcIueSuOeTgOeSteeTgeeSvueStueSu+eTgueUlOeUk+eZnOeZpOeZmeeZkOeZk+eZl+eZmueapueaveebrOefgueeuuejv+ekjOekk+eklOekieekkOekkuekkeemreemrOepn+ewnOewqeewmeewoOewn+ewreewneewpuewqOewouewpeewsOe5nOe5kOe5lue5o+e5mOe5oue5n+e5kee5oOe5l+e5k+e+tee+s+e/t+e/uOiBteiHkeiHklwiXSxcbltcImYwYTFcIixcIuiHkOiJn+iJnuiWtOiXhuiXgOiXg+iXguiWs+iWteiWveiXh+iXhOiWv+iXi+iXjuiXiOiXheiWseiWtuiXkuiYpOiWuOiWt+iWvuiZqeifp+ifpuifouifm+ifq+ifquifpeifn+ifs+ifpOiflOifnOifk+ifreifmOifo+iepOifl+ifmeiggeiftOifqOifneilk+ili+ilj+iljOilhuilkOilkeilieisquisp+iso+iss+issOisteith+isr+isvOisvuisseispeist+ispuistuisruispOisu+isveisuuixguixteiymeiymOiyl+izvui0hOi0gui0gOi5nOi5oui5oOi5l+i5lui5nui5pei5p1wiXSxcbltcImYxNDBcIixcIui5m+i5mui5oei5nei5qei5lOi9hui9h+i9iOi9i+mEqOmEuumEu+mEvumGqOmGpemGp+mGr+mGqumOtemOjOmOkumOt+mOm+mOnemOiemOp+mOjumOqumOnumOpumOlemOiOmOmemOn+mOjemOsemOkemOsumOpOmOqOmOtOmOo+mOpemXkumXk+mXkemas+mbl+mbmuW3gumbn+mbmOmbnemco+mcoumcpemerOmerumeqOmeq+mepOmeqlwiXSxcbltcImYxYTFcIixcIumeoumepemfl+mfmemflumfmOmfuumhkOmhkemhkumiuOmlgemkvOmkuumoj+moi+moiemojemohOmokemoiumohemoh+mohumrgOmrnOmsiOmshOmshemsqemstemtiumtjOmti+mvh+mvhumvg+muv+mvgemutemuuOmvk+mutumvhOmuuemuvem1nOm1k+m1j+m1ium1m+m1i+m1mem1lum1jOm1l+m1kum1lOm1n+m1mOm1mum6jum6jOm7n+m8gem8gOm8lum8pem8q+m8qum8qem8qOm9jOm9leWEtOWEteWKluWLt+WOtOWaq+WareWapuWap+WaquWarOWjmuWjneWjm+WkkuWsveWsvuWsv+W3g+W5sFwiXSxcbltcImYyNDBcIixcIuW+v+aHu+aUh+aUkOaUjeaUieaUjOaUjuaWhOaXnuaXneabnuarp+aroOarjOarkearmeari+arn+arnOarkOarq+arj+arjearnuatoOausOawjOeAmeeAp+eAoOeAlueAq+eAoeeAoueAo+eAqeeAl+eApOeAnOeAqueIjOeIiueIh+eIgueIheeKpeeKpueKpOeKo+eKoeeTi+eTheeSt+eTg+eUlueZoOefieefiuefhOefseekneekm1wiXSxcbltcImYyYTFcIixcIuekoeeknOekl+eknuemsOepp+epqOews+ewvOewueewrOewu+ezrOezque5tue5tee5uOe5sOe5t+e5r+e5uue5sue5tOe5qOe9i+e9iue+g+e+hue+t+e/vee/vuiBuOiHl+iHleiJpOiJoeiJo+iXq+iXseiXreiXmeiXoeiXqOiXmuiXl+iXrOiXsuiXuOiXmOiXn+iXo+iXnOiXkeiXsOiXpuiXr+iXnuiXouiggOifuuigg+iftuift+igieigjOigi+ighuifvOigiOifv+igiuigguilouilmuilm+ill+iloeilnOilmOilneilmeimiOimt+imtuintuitkOitiOitiuitgOitk+itluitlOiti+itlVwiXSxcbltcImYzNDBcIixcIuitkeitguitkuitl+ixg+ixt+ixtuiymui0hui0h+i0iei2rOi2qui2rei2q+i5rei5uOi5s+i5qui5r+i5u+i7gui9kui9kei9j+i9kOi9k+i+tOmFgOmEv+mGsOmGremPnumPh+mPj+mPgumPmumPkOmPuemPrOmPjOmPmemOqemPpumPiumPlOmPrumPo+mPlemPhOmPjumPgOmPkumPp+mVvemXmumXm+mboemcqemcq+mcrOmcqOmcplwiXSxcbltcImYzYTFcIixcIumes+met+metumfnemfnumfn+mhnOmhmemhnemhl+miv+mivemiu+mivumliOmlh+mlg+mmpummp+momumolemopemonemopOmom+mooumooOmop+moo+monumonOmolOmrgumsi+msiumsjumsjOmst+mvqumvq+mvoOmvnumvpOmvpumvoumvsOmvlOmvl+mvrOmvnOmvmemvpemvlemvoemvmum1t+m2gem2ium2hOm2iOm1sem2gOm1uOm2hum2i+m2jOm1vem1q+m1tOm1tem1sOm1qem2hem1s+m1u+m2gum1r+m1uem1v+m2h+m1qOm6lOm6kem7gOm7vOm8rem9gOm9gem9jem9lum9l+m9mOWMt+WaslwiXSxcbltcImY0NDBcIixcIuWateWas+Wjo+WtheW3huW3h+W7ruW7r+W/gOW/geaHueaUl+aUluaUleaUk+aXn+abqOabo+abpOars+arsOarquarqOaruearsearruarr+eAvOeAteeAr+eAt+eAtOeAseeBgueAuOeAv+eAuueAueeBgOeAu+eAs+eBgeeIk+eIlOeKqOeNveeNvOeSuueaq+eaqueavuebreefjOefjuefj+efjeefsuekpeeko+ekp+ekqOekpOekqVwiXSxcbltcImY0YTFcIixcIuemsueprueprOepreert+exieexiOexiuexh+exheezrue5u+e5vue6gee6gOe+uue/v+iBueiHm+iHmeiIi+iJqOiJqeiYouiXv+iYgeiXvuiYm+iYgOiXtuiYhOiYieiYheiYjOiXveigmeigkOigkeigl+igk+igluilo+ilpuimueint+itoOitquitneitqOito+itpeitp+itrei2rui6hui6iOi6hOi9mei9lui9l+i9lei9mOi9mumCjemFg+mFgemGt+mGtemGsumGs+mQi+mQk+mPu+mQoOmQj+mQlOmPvumQlemQkOmQqOmQmemQjemPtemQgOmPt+mQh+mQjumQlumQkumPuumQiemPuOmQiumPv1wiXSxcbltcImY1NDBcIixcIumPvOmQjOmPtumQkemQhumXnumXoOmXn+mcrumcr+meuemeu+mfvemfvumhoOmhoumho+mhn+mjgemjgumlkOmljumlmemljOmli+mlk+mosumotOmosemorOmoqumotumoqemorumouOmoremrh+mriumrhumskOmskumskemwi+mwiOmvt+mwhemwkumvuOmxgOmwh+mwjumwhumwl+mwlOmwiem2n+m2mem2pOm2nem2kum2mOm2kOm2m1wiXSxcbltcImY1YTFcIixcIum2oOm2lOm2nOm2qum2l+m2oem2mum2oum2qOm2num2o+m2v+m2qem2lum2pum2p+m6mem6m+m6mum7pem7pOm7p+m7pum8sOm8rum9m+m9oOm9num9nem9mem+keWEuuWEueWKmOWKl+Wbg+WaveWavuWtiOWth+W3i+W3j+W7seaHveaUm+asguarvOasg+aruOasgOeBg+eBhOeBiueBiOeBieeBheeBhueIneeImueImeeNvueUl+eZquefkOekreekseekr+exlOexk+ezsue6iue6h+e6iOe6i+e6hue6jee9jee+u+iAsOiHneiYmOiYquiYpuiYn+iYo+iYnOiYmeiYp+iYruiYoeiYoOiYqeiYnuiYpVwiXSxcbltcImY2NDBcIixcIuigqeigneigm+igoOigpOignOigq+ihiuilreilqeilruilq+inuuitueituOitheituuitu+i0kOi0lOi2r+i6jui6jOi9nui9m+i9nemFhumFhOmFhemGuemQv+mQu+mQtumQqemQvemQvOmQsOmQuemQqumQt+mQrOmRgOmQsemXpemXpOmXo+mctemcuumev+mfoemhpOmjiemjhumjgOmlmOmllumouemovemphumphOmpgumpgemoulwiXSxcbltcImY2YTFcIixcIumov+mrjemslemsl+msmOmslumsuumtkumwq+mwnemwnOmwrOmwo+mwqOmwqemwpOmwoem2t+m2tum2vOm3gem3h+m3ium3j+m2vum3hem3g+m2u+m2tem3jum2uem2uum2rOm3iOm2sem2rem3jOm2s+m3jem2sum5uum6nOm7q+m7rum7rem8m+m8mOm8mum8sem9jum9pem9pOm+kuS6ueWbhuWbheWbi+WlseWti+WtjOW3leW3keW7suaUoeaUoOaUpuaUouasi+asiOasieawjeeBleeBlueBl+eBkueInueIn+eKqeeNv+eTmOeTleeTmeeTl+eZreeareekteemtOepsOepseexl+exnOexmeexm+exmlwiXSxcbltcImY3NDBcIixcIueztOezsee6kee9j+e+h+iHnuiJq+iYtOiYteiYs+iYrOiYsuiYtuigrOigqOigpuigquigpeilseimv+imvuinu+itvuiuhOiuguiuhuiuheitv+i0lei6lei6lOi6mui6kui6kOi6lui6l+i9oOi9oumFh+mRjOmRkOmRiumRi+mRj+mRh+mRhemRiOmRiemRhumcv+mfo+mhqumhqemji+mllOmlm+mpjumpk+mplOmpjOmpj+mpiOmpilwiXSxcbltcImY3YTFcIixcIumpiempkumpkOmrkOmsmemsq+msu+mtlumtlemxhumxiOmwv+mxhOmwuemws+mxgemwvOmwt+mwtOmwsumwvemwtum3m+m3kum3num3mum3i+m3kOm3nOm3kem3n+m3qem3mem3mOm3lum3tem3lem3nem6tum7sOm8tem8s+m8sum9gum9q+m+lem+ouWEveWKmeWjqOWjp+WlsuWtjeW3mOigr+W9j+aIgeaIg+aIhOaUqeaUpeaWluabq+askeaskuasj+aviueBm+eBmueIoueOgueOgeeOg+eZsOeflOexp+expue6leiJrOiYuuiZgOiYueiYvOiYseiYu+iYvuigsOigsuigruigs+iltuiltOils+invlwiXSxcbltcImY4NDBcIixcIuiujOiujuiui+iuiOixhei0mei6mOi9pOi9o+mGvOmRoumRlemRnemRl+mRnumfhOmfhemggOmplumpmemsnumsn+msoOmxkumxmOmxkOmxiumxjemxi+mxlemxmemxjOmxjum3u+m3t+m3r+m3o+m3q+m3uOm3pOm3tum3oem3rum3pum3sum3sOm3oum3rOm3tOm3s+m3qOm3rem7gum7kOm7sum7s+m8hum8nOm8uOm8t+m8tum9g+m9j1wiXSxcbltcImY4YTFcIixcIum9sem9sOm9rum9r+Wbk+WbjeWtjuWxreaUreabreabruask+eBn+eBoeeBneeBoOeIo+eTm+eTpeefleekuOemt+emtuexque6l+e+ieiJreiZg+iguOigt+igteihi+iulOiulei6nui6n+i6oOi6nemGvumGvemHgumRq+mRqOmRqembpemdhumdg+mdh+mfh+mfpempnumrlemtmemxo+mxp+mxpumxoumxnumxoOm4gum3vum4h+m4g+m4hum4hem4gOm4gem4iem3v+m3vem4hOm6oOm8num9hum9tOm9tem9tuWblOaUruaWuOasmOasmeasl+asmueBoueIpueKquefmOefmeekueexqeexq+eztue6mlwiXSxcbltcImY5NDBcIixcIue6mOe6m+e6meiHoOiHoeiZhuiZh+iZiOilueiluuilvOilu+inv+iumOiumei6pei6pOi6o+mRrumRremRr+mRsemRs+mdiemhsumln+mxqOmxrumxrem4i+m4jem4kOm4j+m4kum4kem6oem7tem8iem9h+m9uOm9u+m9uum9ueWcnueBpuexr+igvOi2sui6pumHg+mRtOmRuOmRtumRtempoOmxtOmxs+mxsemxtem4lOm4k+m7tum8ilwiXSxcbltcImY5YTFcIixcIum+pOeBqOeBpeezt+iZquigvuigveigv+iunuiynOi6qei7iemdi+mhs+mhtOmjjOmloemmq+mppOmppumpp+mspOm4lem4l+m9iOaIh+asnueIp+iZjOi6qOmSgumSgOmSgempqempqOmsrum4meeIqeiZi+iun+mSg+mxuem6t+eZtempq+mxuum4neeBqeeBqum6pOm9vum9iem+mOeigemKueijj+Wiu+aBkueyp+WruuKVlOKVpuKVl+KVoOKVrOKVo+KVmuKVqeKVneKVkuKVpOKVleKVnuKVquKVoeKVmOKVp+KVm+KVk+KVpeKVluKVn+KVq+KVouKVmeKVqOKVnOKVkeKVkOKVreKVruKVsOKVr+KWk1wiXVxuXVxuIiwibW9kdWxlLmV4cG9ydHM9W1xuW1wiMFwiLFwiXFx1MDAwMFwiLDEyN10sXG5bXCI4ZWExXCIsXCLvvaFcIiw2Ml0sXG5bXCJhMWExXCIsXCLjgIDjgIHjgILvvIzvvI7jg7vvvJrvvJvvvJ/vvIHjgpvjgpzCtO+9gMKo77y+77+j77y/44O944O+44Kd44Ke44CD5Lud44CF44CG44CH44O84oCV4oCQ77yP77y8772e4oil772c4oCm4oCl4oCY4oCZ4oCc4oCd77yI77yJ44CU44CV77y777y9772b772d44CIXCIsOSxcIu+8i++8jcKxw5fDt++8neKJoO+8nO+8nuKJpuKJp+KInuKItOKZguKZgMKw4oCy4oCz4oSD77+l77yE77+g77+h77yF77yD77yG77yK77ygwqfimIbimIXil4vil4/il47il4dcIl0sXG5bXCJhMmExXCIsXCLil4bilqHilqDilrPilrLilr3ilrzigLvjgJLihpLihpDihpHihpPjgJNcIl0sXG5bXCJhMmJhXCIsXCLiiIjiiIviiobiiofiioLiioPiiKriiKlcIl0sXG5bXCJhMmNhXCIsXCLiiKfiiKjvv6Lih5Lih5TiiIDiiINcIl0sXG5bXCJhMmRjXCIsXCLiiKDiiqXijJLiiILiiIfiiaHiiZLiiariiaviiJriiL3iiJ3iiLXiiKviiKxcIl0sXG5bXCJhMmYyXCIsXCLihKvigLDima/ima3imarigKDigKHCtlwiXSxcbltcImEyZmVcIixcIuKXr1wiXSxcbltcImEzYjBcIixcIu+8kFwiLDldLFxuW1wiYTNjMVwiLFwi77yhXCIsMjVdLFxuW1wiYTNlMVwiLFwi772BXCIsMjVdLFxuW1wiYTRhMVwiLFwi44GBXCIsODJdLFxuW1wiYTVhMVwiLFwi44KhXCIsODVdLFxuW1wiYTZhMVwiLFwizpFcIiwxNixcIs6jXCIsNl0sXG5bXCJhNmMxXCIsXCLOsVwiLDE2LFwiz4NcIiw2XSxcbltcImE3YTFcIixcItCQXCIsNSxcItCB0JZcIiwyNV0sXG5bXCJhN2QxXCIsXCLQsFwiLDUsXCLRkdC2XCIsMjVdLFxuW1wiYThhMVwiLFwi4pSA4pSC4pSM4pSQ4pSY4pSU4pSc4pSs4pSk4pS04pS84pSB4pSD4pSP4pST4pSb4pSX4pSj4pSz4pSr4pS74pWL4pSg4pSv4pSo4pS34pS/4pSd4pSw4pSl4pS44pWCXCJdLFxuW1wiYWRhMVwiLFwi4pGgXCIsMTksXCLihaBcIiw5XSxcbltcImFkYzBcIixcIuONieOMlOOMouONjeOMmOOMp+OMg+OMtuONkeONl+OMjeOMpuOMo+OMq+ONiuOMu+OOnOOOneOOnuOOjuOOj+OPhOOOoVwiXSxcbltcImFkZGZcIixcIuONu+OAneOAn+KEluOPjeKEoeOKpFwiLDQsXCLjiLHjiLLjiLnjjb7jjb3jjbziiZLiiaHiiKviiK7iiJHiiJriiqXiiKDiiJ/iir/iiLXiiKniiKpcIl0sXG5bXCJiMGExXCIsXCLkupzllJblqIPpmL/lk4DmhJvmjKjlp7bpgKLokbXojJznqZDmgqrmj6HmuKXml63okaboiqbpr7XmopPlnKfmlqHmibHlrpvlp5Dombvpo7TntaLntr7pro7miJbnsp/oorflronlurXmjInmmpfmoYjpl4fpno3mnY/ku6XkvIrkvY3kvp3lgYnlm7LlpLflp5TlqIHlsInmg5/mhI/mhbDmmJPmpIXngrrnlY/nlbDnp7vntq3nt6/og4PokI7ooaPorILpgZXpgbrljLvkupXkuqXln5/ogrLpg4Hno6/kuIDlo7HmuqLpgLjnqLLojKjoiovpsK/lhYHljbDlkr3lk6Hlm6Dlp7vlvJXpo7Lmt6vog6TolK1cIl0sXG5bXCJiMWExXCIsXCLpmaLpmbDpmqDpn7vlkIvlj7Plrofng4/nvr3ov4Lpm6jlja/ptZznqrrkuJHnopPoh7zmuKblmJjllITmrJ3olJrpsLvlp6Xljqnmtabnk5zplo/lmYLkupHpgYvpm7LojY/ppIzlj6HllrblrLDlvbHmmKDmm7PmoITmsLjms7PmtKnnkZvnm4jnqY7poLToi7HooZvoqaDpi63mtrLnlqvnm4rpp4XmgqborIHotorplrLmpo7ljq3lhoblnJLloLDlpYTlrrTlu7bmgKjmjqnmj7Tmsr/mvJTngo7nhJTnhZnnh5XnjL/nuIHoibboi5HolpfpgaDpiZvptJvloanmlrzmsZrnlKXlh7nlpK7lpaXlvoDlv5xcIl0sXG5bXCJiMmExXCIsXCLmirzml7rmqKrmrKfmrrTnjovnv4HopZbptKzptI7pu4TlsqHmspbojbvlhITlsYvmhrboh4bmobbniaHkuZnkv7rljbjmganmuKnnqY/pn7PkuIvljJbku67kvZXkvL3kvqHkvbPliqDlj6/lmInlpI/lq4Hlrrblr6Hnp5HmmofmnpzmnrbmrYzmsrPngavnj4Lnpo3npr7nqLznrofoirHoi5vojITojbfoj6/oj5PonaboqrLlmKnosqjov6bpgY7pnJ7omorkv4Tls6jmiJHniZnnlLvoh6Xoir3om77os4Dpm4XppJPpp5Xku4vkvJrop6Plm57loYrlo4rlu7vlv6vmgKrmgpTmgaLmh5DmiJLmi5DmlLlcIl0sXG5bXCJiM2ExXCIsXCLprYHmmabmorDmtbfngbDnlYznmobntbXoiqXon7nplovpmo7osp3lh7Hlir7lpJblkrPlrrPltJbmhajmpoLmtq/noo3ok4vooZfoqbLpjqfpqrjmtazppqjom5nlnqPmn7/om47piI7lioPlmoflkITlu5Pmi6HmkrnmoLzmoLjmrrvnjbLnorrnqavopprop5LotavovIPpg63plqPpmpTpnanlrablsrPmpb3poY3poY7mjpvnrKDmqKvmqb/morbpsI3mvZ/libLllp3mgbDmi6zmtLvmuIfmu5HokZvopJDovYTkuJTpsLnlj7bmpJvmqLrpnoTmoKrlhZznq4PokrLph5zpjozlmZvptKjmoKLojIXokLFcIl0sXG5bXCJiNGExXCIsXCLnsqXliIjoi4Xnk6bkub7kvoPlhqDlr5LliIrli5jli6flt7vllprloKrlp6blrozlrpjlr5vlubLlubnmgqPmhJ/mhaPmhr7mj5vmlaLmn5HmoZPmo7rmrL7mrZPmsZfmvKLmvpfmvYXnkrDnlJjnm6PnnIvnq7/nrqHnsKHnt6nnvLbnv7Dogp3oiabojp7oprPoq4zosqvpgoTpkZHplpPplpHplqLpmaXpn5PppKjoiJjkuLjlkKvlsrjlt4znjqnnmYznnLzlsqnnv6votIvpm4HpoJHpoZTpoZjkvIHkvI7ljbHllpzlmajln7rlpYflrInlr4TlspDluIzlub7lv4zmj67mnLrml5fml6LmnJ/mo4vmo4RcIl0sXG5bXCJiNWExXCIsXCLmqZ/luLDmr4XmsJfmsb3nlb/npYjlraPnqIDntIDlvr3opo/oqJjosrTotbfou4zovJ3po6LpqI7prLzkuoDlgb3lhIDlppPlrpzmiK/mioDmk6zmrLrniqDnlpHnpYfnvqnon7voqrzorbDmjqzoj4rpnqDlkInlkIPllqvmoZTmqZjoqbDnoKfmnbXpu43ljbTlrqLohJromZDpgIbkuJjkuYXku4fkvJHlj4rlkLjlrq7lvJPmgKXmlZHmnL3msYLmsbLms6PngbjnkIPnqbbnqq7nrIjntJrns77ntabml6fniZvljrvlsYXlt6jmi5Lmi6DmjJnmuKDomZroqLHot53pi7jmvIHnpqbprZrkuqjkuqvkuqxcIl0sXG5bXCJiNmExXCIsXCLkvpvkvqDlg5HlhYfnq7blhbHlh7bljZTljKHljb/lj6vllqzlooPls6HlvLflvYrmgK/mgZDmga3mjJ/mlZnmqYvms4Hni4Lni63nn6/og7johIXoiIjolY7pg7fpj6Hpn7/ppZfpqZrku7Dlh53lsK3mmoHmpa3lsYDmm7LmpbXnjonmoZDnsoHlg4Xli6TlnYflt77pjKbmlqTmrKPmrL3nkLTnpoHnpr3nrYvnt4roirnoj4zoob/opZ/orLnov5Hph5HlkJ/pioDkuZ3lgLblj6XljLrni5fnjpbnn6noi6bouq/pp4bpp4jpp5LlhbfmhJromZ7llrDnqbrlgbblr5PpgYfpmoXkuLLmq5vph6flsZHlsYhcIl0sXG5bXCJiN2ExXCIsXCLmjpjnqp/mspPpnbTovaHnqqrnhorpmojnsoLmoJfnubDmoZHpjazli7LlkJvolqvoqJPnvqTou43pg6HljabooojnpYHkv4Llgr7liJHlhYTllZPlnK3nj6rlnovlpZHlvaLlvoTmgbXmhbbmhafmhqnmjrLmkLrmlazmma/moYLmuJPnlabnqL3ns7vntYzntpnnuYvnvavojI7ojYrom43oqIjoqaPorabou73poJrpto/oirjov47pr6jliofmiJ/mkoPmv4DpmpnmoYHlgpHmrKDmsbrmvZTnqbTntZDooYDoqKPmnIjku7blgLnlgKblgaXlhbzliLjliaPllqflnI/loIXlq4zlu7rmhrLmh7jmi7PmjbJcIl0sXG5bXCJiOGExXCIsXCLmpJzmqKnnib3niqznjK7noJTnoa/ntbnnnIzogqnopovorJnos6Lou5LpgaPpjbXpmbrpoZXpqJPpubjlhYPljp/ljrPlubvlvKbmuJvmupDnjoTnj77ntYPoiLfoqIDoq7rpmZDkuY7lgIvlj6Tlkbzlm7rlp5HlraTlt7HluqvlvKfmiLjmlYXmnq/muZbni5Dns4roorTogqHog6Hoj7DomY7oqofot6jpiLfpm4fpoafpvJPkupTkupLkvI3ljYjlkYnlkL7lqK/lvozlvqHmgp/moqfmqo7nkZrnooHoqp7oqqTorbfphpDkuZ7pr4nkuqTkvbzkvq/lgJnlgJblhYnlhazlip/lirnli77ljprlj6PlkJFcIl0sXG5bXCJiOWExXCIsXCLlkI7llonlnZHlnqLlpb3lrZTlrZ3lro/lt6Xlt6flt7flubjluoPluprlurflvJjmgZLmhYzmipfmi5jmjqfmlLvmmILmmYPmm7Tmna3moKHmopfmp4vmsZ/mtKrmtanmuK/mup3nlLLnmofnoaznqL/ns6DntIXntJjntZ7ntrHogJXogIPogq/ogrHohZToho/oiKrojZLooYzooaHorJvosqLos7zpg4rphbXpibHnoL/pi7zplqTpmY3poIXpppnpq5jptLvliZvliqvlj7flkIjlo5Xmi7fmv6DosarovZ/purnlhYvliLvlkYrlm73nqYDphbfptaDpu5LnjYTmvInohbDnlJHlv73mg5rpqqjni5vovrxcIl0sXG5bXCJiYWExXCIsXCLmraTpoIPku4rlm7DlnaTlor7lqZrmgajmh4fmmI/mmIbmoLnmorHmt7fnl5XntLroia7prYLkupvkvZDlj4nllIblta/lt6blt67mn7vmspnnkbPnoILoqZDpjpboo5/lnZDluqfmjKvlgrXlgqzlho3mnIDlk4nloZ7lprvlrrDlvanmiY3mjqHmoL3mrbPmuIjngb3ph4fnioDnoJXnoKbnpa3mlo7ntLDoj5zoo4HovInpmpvliaTlnKjmnZDnvarosqHlhrTlnYLpmKrloLrmporogrTlkrLltI7ln7znopXpt7rkvZzliYrlkovmkL7mmKjmnJTmn7XnqoTnrZbntKLpjK/moZzprq3nrLnljJnlhorliLdcIl0sXG5bXCJiYmExXCIsXCLlr5/mi7bmkq7mk6bmnK3mrrrolqnpm5HnmpDpr5bmjYzpjIbprqvnmr/mmZLkuInlgpjlj4LlsbHmg6jmkpLmlaPmoZ/nh6bnj4rnlKPnrpfnuoLompXoroPos5vphbjppJDmlqzmmqvmrovku5Xku5TkvLrkvb/liLrlj7jlj7Lll6Plm5vlo6vlp4vlp4nlp7/lrZDlsY3luILluKvlv5fmgJ3mjIfmlK/lrZzmlq/mlr3ml6jmnp3mraLmrbvmsI/njYXnpYnnp4Hns7jntJnntKvogqLohILoh7PoppboqZ7oqanoqaboqozoq67os4fos5zpm4zpo7zmra/kuovkvLzkvo3lhZDlrZflr7rmhYjmjIHmmYJcIl0sXG5bXCJiY2ExXCIsXCLmrKHmu4vmsrvniL7nkr3nl5Tno4HnpLrogIzogLPoh6rokpTovp7msZDpub/lvI/orZjptKvnq7rou7jlro3pm6vkuIPlj7Hln7flpLHlq4nlrqTmgonmub/mvIbnlr7os6rlrp/olIDnr6DlgbLmn7Toip3lsaHolYrnuJ7oiI7lhpnlsITmjajotabmlpznha7npL7ntJfogIXorJ3ou4rpga7om4fpgqrlgJ/li7rlsLrmnZPngbzniLXphYzph4jpjKvoi6Xlr4LlvLHmg7nkuLvlj5blrojmiYvmnLHmrorni6nnj6DnqK7ohavotqPphZLpppblhJLlj5flkarlr7/mjojmqLnntqzpnIDlm5rlj47lkahcIl0sXG5bXCJiZGExXCIsXCLlrpflsLHlt57kv67mhIHmi77mtLLnp4Dnp4vntYLnuY3nv5Loh63oiJ/okpDooYbopbLorpDoubTovK/pgLHphYvphazpm4bphpzku4DkvY/lhYXljYHlvpPmiI7mn5TmsYHmuIvnjaPnuKbph43pioPlj5TlpJnlrr/mt5HnpZ3nuK7nspvlob7nhp/lh7rooZPov7Dkv4rls7vmmKXnnqznq6PoiJzpp7/lh4blvqrml6zmpa/mronmt7PmupbmvaTnm77ntJTlt6HpgbXphofpoIblh6bliJ3miYDmmpHmm5nmuJrlurbnt5LnvbLmm7jolq/ol7foq7jliqnlj5nlpbPluo/lvpDmgZXpi6TpmaTlgrflhJ9cIl0sXG5bXCJiZWExXCIsXCLli53ljKDljYflj6zlk6jllYbllLHlmJflpajlpr7lqLzlrrXlsIblsI/lsJHlsJrluoTluorlu6DlvbDmib/mioTmi5vmjozmjbfmmIfmmIzmmK3mmbbmnb7moqLmqJ/mqLXmsrzmtojmuInmuZjnhLznhKbnhafnl4fnnIHnoZ3npIHnpaXnp7Dnq6DnrJHnsqfntLnogpboj5bokovolYnooZ3oo7PoqJ/oqLzoqZToqbPosaHos57phqTpiabpjb7pkJjpmpzpnpjkuIrkuIjkuJ7kuZflhpflibDln47loLTlo4zlrKLluLjmg4Xmk77mnaHmnZbmtYTnirbnlbPnqaPokrjorbLphrjpjKDlmLHln7Tpo75cIl0sXG5bXCJiZmExXCIsXCLmi63mpI3mrpbnh63nuZTogbfoibLop6bpo5/onZXovrHlsLvkvLjkv6HkvrXllIflqKDlr53lr6nlv4PmhY7mjK/mlrDmmYvmo67mppvmtbjmt7HnlLPnlrnnnJ/npZ7np6bntLPoh6Poiq/olqropqroqLrouqvovpvpgLLph53pnIfkurrku4HliIPlobXlo6zlsIvnlJrlsL3ohY7oqIrov4XpmaPpna3nrKXoq4/poIjphaLlm7PljqjpgJflkLnlnoLluKXmjqjmsLTngornnaHnsovnv6DoobDpgYLphZTpjJDpjJjpmo/nkZ7pq4TltIfltanmlbDmnqLotqjpm5vmja7mnYnmpJnoj4XpoJfpm4Doo75cIl0sXG5bXCJjMGExXCIsXCLmvoTmkbrlr7jkuJbngKznlZ3mmK/lh4TliLbli6Llp5PlvoHmgKfmiJDmlL/mlbTmmJ/mmbTmo7LmoJbmraPmuIXnibLnlJ/nm5vnsr7ogZblo7Doo73opb/oqqDoqpPoq4vpgJ3phpLpnZLpnZnmlonnqI7ohIbpmrvluK3mg5zmiJrmlqXmmJTmnpDnn7PnqY3nsY3nuL7ohIrosqzotaTot6HouZ/noqnliIfmi5nmjqXmkYLmipjoqK3nqoPnr4Doqqzpm6rntbboiIzonYnku5nlhYjljYPljaDlrqPlsILlsJblt53miKbmiYfmkrDmoJPmoLTms4nmtYXmtJfmn5PmvZznhY7nhb3ml4vnqb/nrq3nt5pcIl0sXG5bXCJjMWExXCIsXCLnuYrnvqjohbroiJvoiLnolqboqa7os47ot7Xpgbjpgbfpiq3pipHploPprq7liY3lloTmvLjnhLblhajnpoXnuZXohrPns47lmYzloZHlsqjmjqrmm77mm73mpZrni5nnlo/nlo7npI7npZbnp5/nspfntKDntYTomIfoqLTpmLvpgaHpvKDlg6flibXlj4zlj6LlgInllqrlo67lpY/niL3lrovlsaTljJ3mg6Pmg7PmjZzmjoPmjL/mjrvmk43ml6nmm7nlt6Pmp43mp73mvJXnh6Xkuonnl6nnm7jnqpPns5/nt4/ntpzogaHojYnojZjokazokrzol7voo4XotbDpgIHpga3pjpfpnJzpqJLlg4/lopfmho5cIl0sXG5bXCJjMmExXCIsXCLoh5PolLXotIjpgKDkv4PlgbTliYfljbPmga/mjYnmnZ/muKzotrPpgJ/kv5flsZ7os4rml4/ntprljZLoopblhbbmj4PlrZjlravlsIrmkI3mnZHpgZzku5blpJrlpKrmsbDoqZHllL7loJXlpqXmg7DmiZPmn4HoiLXmpZXpmYDpp4TpqKjkvZPloIblr77ogJDlsrHluK/lvoXmgKDmhYvmiLTmm7/ms7Dmu57og47ohb/oi5TooovosrjpgIDpgK7pmorpu5vpr5vku6Plj7DlpKfnrKzpho3poYzpt7nmu53ngKfljZPllYTlroXmiZjmip7mi5PmsqLmv6/nkKLoqJfpkLjmv4Hoq77ojLjlh6fom7jlj6pcIl0sXG5bXCJjM2ExXCIsXCLlj6nkvYbpgZTovrDlparohLHlt73nq6rovr/mo5rosLfni7jpsYjmqL3oqrDkuLnljZjlmIblnabmi4XmjqLml6bmrY7mt6HmuZvngq3nn63nq6/nrqrntrvogL3og4bom4voqpXpjZvlm6Plo4flvL7mlq3mmpbmqoDmrrXnlLfoq4flgKTnn6XlnLDlvJvmgaXmmbrmsaDnl7TnqJrnva7oh7TonJjpgYXpprPnr4nnlZznq7nnrZHok4TpgJDnp6nnqpLojLblq6HnnYDkuK3ku7Llrpnlv6Dmir3mmLzmn7Hms6jomavoobfoqLvphY7pi7Ppp5DmqJfngKbnjKroi6fokZfosq/kuIHlhYblh4vllovlr7VcIl0sXG5bXCJjNGExXCIsXCLluJbluLPluoHlvJTlvLXlvavlvrTmh7LmjJHmmqLmnJ3mva7niZLnlLrnnLrogbTohLnohbjonbboqr/oq5zotoXot7PpiprplbfpoILps6Xli4XmjZfnm7TmnJXmsojnj43os4Ppjq7pmbPmtKXlopzmpI7mp4zov73pjprnl5vpgJrloZrmoILmjrTmp7vkvYPmvKzmn5jovrvolKbntrTpjZTmpL/mvbDlnarlo7flrKzntKzniKrlkIrph6PptrTkuq3kvY7lgZzlgbXliYPosp7lkYjloKTlrprluJ3lupXluq3lu7flvJ/mgozmirXmjLrmj5Dmoq/msYDnoofnpo7nqIvnt6DoiYfoqILoq6bouYTpgJNcIl0sXG5bXCJjNWExXCIsXCLpgrjphK3ph5jpvI7ms6XmkZjmk6LmlbXmu7TnmoTnrJvpganpj5Hmurrlk7LlvrnmkqTovY3ov63piYTlhbjloavlpKnlsZXlupfmt7vnuo/nlJzosrzou6LpoZvngrnkvJ3mrr/mvrHnlLDpm7vlhY7lkJDloLXloZflpqzlsaDlvpLmlpfmnZzmuKHnmbvoj5/os63pgJTpg73pjY3noKXnoLrliqrluqblnJ/lpbTmgJLlgJLlhZrlhqzlh43liIDllJDloZTloZjlpZflrpXls7bltovmgrzmipXmkK3mnbHmoYPmorzmo5/nm5fmt5jmua/mtpvnga/nh4jlvZPnl5jnpbfnrYnnrZTnrZLns5bntbHliLBcIl0sXG5bXCJjNmExXCIsXCLokaPolanol6ToqI7orITosYbouI/pgIPpgI/pkJnpmbbpoK3pqLDpl5jlg43li5XlkIzloILlsI7mhqfmkp7mtJ7nnrPnq6Xog7TokITpgZPpioXls6DptIfljL/lvpflvrPmtpznibnnnaPnpr/nr6Tmr5Lni6zoqq3moIPmqaHlh7jnqoHmpLTlsYrps7boi6vlr4XphYnngJ7lmbjlsa/mg4fmlabmsozosZrpgYHpoJPlkZHmm4fpiI3lpYjpgqPlhoXkuY3lh6rolpnorI7ngZjmjbrpjYvmpaLpprTnuITnlbfljZfmpaDou5/pm6PmsZ3kuozlsLzlvJDov6nljILos5Hogonombnlu7/ml6XkubPlhaVcIl0sXG5bXCJjN2ExXCIsXCLlpoLlsL/pn67ku7vlporlv43oqo3mv6HnprDnpaLlr6fokbHnjKvnhrHlubTlv7Xmjbvmkprnh4PnspjkuYPlu7zkuYvln5zlmqLmgqnmv4PntI3og73ohLPohr/ovrLoppfomqTlt7Tmiormkq3opofmnbfms6LmtL7nkLbnoLTlqYbnvbXoiq3ppqzkv7Plu4Pmi53mjpLmlZfmna/nm4PniYzog4zogrrovKnphY3lgI3ln7nlqpLmooXmpbPnhaTni73osrflo7Los6DpmarpgJnonb/np6Tnn6fokKnkvK/liaXljZrmi43mn4/ms4rnmb3nrpTnspXoiLboloTov6vmm53mvKDniIbnuJvojqvpp4HpuqZcIl0sXG5bXCJjOGExXCIsXCLlh73nrrHnobLnrrjogofnrYjmq6jluaHogoznlZHnlaDlhavpiaLmuoznmbrphpfpq6rkvJDnvbDmipznrY/plqXps6nlmbrloZnom6TpmrzkvLTliKTljYrlj43lj5vluIbmkKzmlpHmnb/msL7msY7niYjniq/nj63nlZTnuYHoiKzol6nosqnnr4Tph4bnhanpoJLpo6/mjL3mmannlarnm6Tno5DolYPom67ljKrljZHlkKblpoPluoflvbzmgrLmiYnmibnmiqvmlpDmr5Tms4znlrLnmq7nopHnp5jnt4vnvbfogqXooqvoqrnosrvpgb/pnZ7po5vmqIvnsLjlgpnlsL7lvq7mnofmr5jnkLXnnInnvo5cIl0sXG5bXCJjOWExXCIsXCLpvLvmn4rnqJfljLnnlovpq63lvabohp3oj7HogpjlvLzlv4XnlaLnrYbpgLzmoaflp6vlqpvntJDnmb7orKzkv7XlvarmqJnmsLfmvILnk6LnpajooajoqZXosbnlu5/mj4/nl4Xnp5Loi5fpjKjpi7Lokpzom63psK3lk4HlvazmlozmtZzngJXosqfos5PpoLvmlY/nk7bkuI3ku5jln6DlpKvlqablr4zlhqjluIPlupzmgJbmibbmlbfmlqfmma7mta7niLbnrKbohZDohproipnorZzosqDos6botbTpmJzpmYTkvq7mkqvmraboiJ7okaHolarpg6jlsIHmpZPpoqjokbrolZfkvI/lia/lvqnluYXmnI1cIl0sXG5bXCJjYWExXCIsXCLnpo/ohbnopIfopobmt7XlvJfmiZXmsrjku4/nianprpLliIblkLvlmbTlorPmhqTmia7nhJrlpa7nsonns57ntJvpm7DmlofogZ7kuJnkvbXlhbXloYDluaPlubPlvIrmn4TkuKbolL3plonpmZvnsbPpoIHlg7vlo4HnmZbnoqfliKXnnqXolJHnroblgY/lpInniYfnr4fnt6jovrrov5TpgY3kvr/li4nlqKnlvIHpnq3kv53oiJfpi6rlnIPmjZXmrannlKvoo5zovJTnqYLli5/lopPmhZXmiIrmmq7mr43nsL/oj6nlgKPkv7jljIXlkYbloLHlpYnlrp3ls7Dls6/ltKnlupbmirHmjafmlL7mlrnmnItcIl0sXG5bXCJjYmExXCIsXCLms5Xms6Hng7nnoLLnuKvog57oirPokIzok6zonILopJLoqKrosYrpgqbpi5Lpo73ps7PptazkuY/kuqHlgo3liZblnYrlpqjluL3lv5jlv5nmiL/mmrTmnJvmn5Dmo5LlhpLntKHogqrohqjorIDosozosr/pib7pmLLlkKDpoKzljJflg5XljZzloqjmkrLmnLTniafnnabnqYbph6bli4PmsqHmrobloIDluYzlpZTmnKznv7vlh6Hnm4bmkanno6jprZTpurvln4vlprnmmKfmnprmr47lk6nmp5nluZXohpzmnpXprqrmn77psZLmoZ3kuqbkv6Plj4jmirnmnKvmsqvov4Tkvq3nua3pur/kuIfmhaLmuoBcIl0sXG5bXCJjY2ExXCIsXCLmvKvolJPlkbPmnKrprYXlt7PnrpXlsqzlr4bonJzmuYrok5HnqJTohIjlppnnso3msJHnnKDli5nlpKLnhKHniZ/nn5vpnKfptaHmpIvlqb/lqJjlhqXlkI3lkb3mmI7nm5/ov7fpipjps7Tlp6rniZ3mu4XlhY3mo4nntr/nt6zpnaLpurrmkbjmqKHojILlpoTlrZ/mr5vnjJvnm7LntrLogJfokpnlhLLmnKjpu5nnm67mnaLli7/ppIXlsKTmiLvnsb7osrDllY/mgrbntIvploDljIHkuZ/lhrblpJzniLrogLbph47lvKXnn6LljoTlvbnntITolqzoqLPouo3pnZbmn7Polq7pkZPmhInmhIjmsrnnmZJcIl0sXG5bXCJjZGExXCIsXCLoq63ovLjllK/kvZHlhKrli4flj4vlrqXlub3mgqDmhoLmj5bmnInmn5rmuafmtoznjLbnjLfnlLHnpZDoo5XoqpjpgYrpgpHpg7Xpm4Tono3lpJXkuojkvZnkuI7oqonovL/poJDlgq3lubzlppblrrnlurjmj5rmj7rmk4Hmm5zmpYrmp5jmtIvmurbnhpTnlKjnqq/nvorogIDokYnok4nopoHorKHouIrpgaXpmb3ppIrmhb7mipHmrLLmsoPmtbTnv4znv7zmt4DnvoXonrroo7jmnaXojrHpoLzpm7fmtJvntaHokL3pharkubHljbXltZDmrITmv6vol43omK3opqfliKnlkI/lsaXmnY7moqjnkIbnkoNcIl0sXG5bXCJjZWExXCIsXCLnl6Loo4/oo6Hph4zpm6Lpmbjlvovnjofnq4vokY7mjqDnlaXlionmtYHmupznkInnlZnnoavnspLpmobnq5zpvo3kvrbmha7ml4XomZzkuobkuq7lg5rkuKHlh4zlr67mlpnmooHmtrznjJ/nmYLnnq3nqJzns6foia/oq5Lpgbzph4/pmbXpoJjlipvnt5HlgKvljpjmnpfmt4vnh5DnkLPoh6jovKrpmqPpsZfpup/nkaDloYHmtpnntK/poZ7ku6TkvLbkvovlhrflirHltrrmgJznjrLnpLzoi5PpiLTpmrfpm7bpnIrpupfpvaLmmqbmrbTliJfliqPng4joo4Llu4nmgYvmhpDmvKPnhYnnsL7nt7Toga9cIl0sXG5bXCJjZmExXCIsXCLok67pgKPpjKzlkYLpra/mq5Pngonos4Lot6/pnLLlirTlqYHlu4rlvITmnJfmpbzmppTmtarmvI/niaLni7znr63ogIHogb7onYvpg47lha3pupPnpoTogovpjLLoq5blgK3lkozoqbHmraros4TohIfmg5HmnqDpt7LkupnkupjpsJDoqavol4HolajmpIDmub7nopfohZVcIl0sXG5bXCJkMGExXCIsXCLlvIzkuJDkuJXkuKrkuLHkuLbkuLzkuL/kuYLkuZbkuZjkuoLkuoXosavkuoroiJLlvI3kuo7kup7kup/kuqDkuqLkurDkurPkurbku47ku43ku4Tku4bku4Lku5fku57ku63ku5/ku7fkvInkvZrkvLDkvZvkvZ3kvZfkvYfkvbbkvojkvo/kvpjkvbvkvankvbDkvpHkva/kvobkvpblhJjkv5Tkv5/kv47kv5jkv5vkv5Hkv5rkv5Dkv6Tkv6XlgJrlgKjlgJTlgKrlgKXlgIXkvJzkv7blgKHlgKnlgKzkv77kv6/lgJHlgIblgYPlgYfmnIPlgZXlgZDlgYjlgZrlgZblgazlgbjlgoDlgprlgoXlgrTlgrJcIl0sXG5bXCJkMWExXCIsXCLlg4nlg4rlgrPlg4Llg5blg57lg6Xlg63lg6Plg67lg7nlg7XlhInlhIHlhILlhJblhJXlhJTlhJrlhKHlhLrlhLflhLzlhLvlhL/lhYDlhZLlhYzlhZTlhaLnq7jlhanlharlha7lhoDlhoLlm5jlhozlhonlho/lhpHlhpPlhpXlhpblhqTlhqblhqLlhqnlhqrlhqvlhrPlhrHlhrLlhrDlhrXlhr3lh4Xlh4nlh5vlh6DomZXlh6nlh63lh7Dlh7Xlh77liITliIvliJTliI7liKfliKrliK7liLPliLnliY/liYTliYvliYzliZ7liZTliarlibTlianlibPlib/lib3lio3lipTlipLlibHliojlipHovqhcIl0sXG5bXCJkMmExXCIsXCLovqfliqzliq3lirzlirXli4Hli43li5fli57li6Pli6bpo63li6Dli7Pli7Xli7jli7nljIbljIjnlLjljI3ljJDljI/ljJXljJrljKPljK/ljLHljLPljLjljYDljYbljYXkuJfljYnljY3lh5bljZ7ljanlja7lpJjljbvljbfljoLljpbljqDljqbljqXljq7ljrDljrblj4PnsJLpm5nlj5/mm7znh67lj67lj6jlj63lj7rlkIHlkL3lkYDlkKzlkK3lkLzlkK7lkLblkKnlkJ3lkY7lko/lkbXlko7lkZ/lkbHlkbflkbDlkpLlkbvlkoDlkbblkoTlkpDlkoblk4flkqLlkrjlkqXlkqzlk4Tlk4jlkqhcIl0sXG5bXCJkM2ExXCIsXCLlkqvlk4LlkqTlkr7lkrzlk5jlk6Xlk6bllI/llJTlk73lk67lk63lk7rlk6LllLnllYDllaPllYzllK7llZzllYXllZbllZfllLjllLPllZ3llpnlloDlkq/llorllp/llbvllb7llpjllp7llq7llbzlloPllqnllofllqjll5rll4Xll5/ll4Tll5zll6Tll5TlmJTll7flmJbll77ll73lmJvll7nlmY7lmZDnh5/lmLTlmLblmLLlmLjlmavlmaTlmK/lmazlmarlmoblmoDlmorlmqDlmpTlmo/lmqXlmq7lmrblmrTlm4Llmrzlm4Hlm4Plm4Dlm4jlm47lm5Hlm5Plm5flm67lm7nlnIDlm7/lnITlnIlcIl0sXG5bXCJkNGExXCIsXCLlnIjlnIvlnI3lnJPlnJjlnJbll4flnJzlnKblnLflnLjlnY7lnLvlnYDlnY/lnanln4DlnojlnaHlnb/lnonlnpPlnqDlnrPlnqTlnqrlnrDln4Pln4bln5Tln5Lln5PloIrln5bln6PloIvloJnloJ3lobLloKHloaLloYvlobDmr4DloZLloL3lobnlooXlornlop/loqvlorrlo57lorvlorjloq7lo4Xlo5Plo5Hlo5flo5nlo5jlo6Xlo5zlo6Tlo5/lo6/lo7rlo7nlo7vlo7zlo73lpILlpIrlpJDlpJvmoqblpKXlpKzlpK3lpLLlpLjlpL7nq5LlpZXlpZDlpY7lpZrlpZjlpaLlpaDlpaflpazlpalcIl0sXG5bXCJkNWExXCIsXCLlpbjlpoHlpp3kvZ7kvqvlpqPlprLlp4blp6jlp5zlpo3lp5nlp5rlqKXlqJ/lqJHlqJzlqInlqJrlqYDlqazlqYnlqLXlqLblqaLlqarlqprlqrzlqr7lq4vlq4Llqr3lq6Plq5flq6blq6nlq5blq7rlq7vlrIzlrIvlrJblrLLlq5DlrKrlrLblrL7lrYPlrYXlrYDlrZHlrZXlrZrlrZvlraXlranlrbDlrbPlrbXlrbjmlojlrbrlroDlroPlrqblrrjlr4Plr4flr4nlr5Tlr5Dlr6Tlr6blr6Llr57lr6Xlr6vlr7Dlr7blr7PlsIXlsIflsIjlsI3lsJPlsKDlsKLlsKjlsLjlsLnlsYHlsYblsY7lsZNcIl0sXG5bXCJkNmExXCIsXCLlsZDlsY/lrbHlsazlsa7kuaLlsbblsbnlsozlspHlspTlppvlsqvlsrvlsrblsrzlsrfls4Xlsr7ls4fls5nls6nls73ls7rls63ltozls6rltIvltJXltJfltZzltJ/ltJvltJHltJTltKLltJrltJnltJjltYzltZLltY7ltYvltazltbPltbbltofltoTltoLltqLltp3ltqzltq7ltr3ltpDltrfltrzlt4nlt43lt5Plt5Llt5blt5vlt6vlt7Llt7XluIvluJrluJnluJHluJvluLbluLfluYTluYPluYDluY7luZfluZTluZ/luaLluaTluYflubXlubblubrpurzlub/luqDlu4Hlu4Llu4jlu5Dlu49cIl0sXG5bXCJkN2ExXCIsXCLlu5blu6Plu53lu5rlu5vlu6Llu6Hlu6jlu6nlu6zlu7Hlu7Plu7Dlu7Tlu7jlu77lvIPlvInlvZ3lvZzlvIvlvJHlvJblvKnlvK3lvLjlvYHlvYjlvYzlvY7lvK/lvZHlvZblvZflvZnlvaHlva3lvbPlvbflvoPlvoLlvb/lvorlvojlvpHlvoflvp7lvpnlvpjlvqDlvqjlvq3lvrzlv5blv7vlv6Tlv7jlv7Hlv53mgrPlv7/mgKHmgaDmgJnmgJDmgKnmgI7mgLHmgJvmgJXmgKvmgKbmgI/mgLrmgZrmgYHmgarmgbfmgZ/mgYrmgYbmgY3mgaPmgYPmgaTmgYLmgazmgavmgZnmgoHmgo3mg6fmgoPmgppcIl0sXG5bXCJkOGExXCIsXCLmgoTmgpvmgpbmgpfmgpLmgqfmgovmg6Hmgrjmg6Dmg5PmgrTlv7Dmgr3mg4bmgrXmg5jmhY3mhJXmhIbmg7bmg7fmhIDmg7Tmg7rmhIPmhKHmg7vmg7HmhI3mhI7mhYfmhL7mhKjmhKfmhYrmhL/mhLzmhKzmhLTmhL3mhYLmhYTmhbPmhbfmhZjmhZnmhZrmhavmhbTmha/mhaXmhbHmhZ/mhZ3mhZPmhbXmhpnmhpbmhofmhqzmhpTmhprmhormhpHmhqvmhq7mh4zmh4rmh4nmh7fmh4jmh4Pmh4bmhrrmh4vnvbnmh43mh6bmh6Pmh7bmh7rmh7Tmh7/mh73mh7zmh77miIDmiIjmiInmiI3miIzmiJTmiJtcIl0sXG5bXCJkOWExXCIsXCLmiJ7miKHmiKrmiK7miLDmiLLmiLPmiYHmiY7miZ7miaPmiZvmiaDmiajmibzmioLmionmib7mipLmipPmipbmi5TmioPmipTmi5fmi5Hmirvmi4/mi7/mi4bmk5Tmi4jmi5zmi4zmi4rmi4Lmi4fmipvmi4nmjIzmi67mi7HmjKfmjILmjIjmi6/mi7XmjZDmjL7mjY3mkJzmjY/mjpbmjo7mjoDmjqvmjbbmjqPmjo/mjonmjp/mjrXmjavmjanmjr7mj6nmj4Dmj4bmj6Pmj4nmj5Lmj7bmj4TmkJbmkLTmkIbmkJPmkKbmkLbmlJ3mkJfmkKjmkI/mkafmka/mkbbmkY7mlKrmkpXmkpPmkqXmkqnmkojmkrxcIl0sXG5bXCJkYWExXCIsXCLmk5rmk5Lmk4Xmk4fmkrvmk5jmk4Lmk7Hmk6foiInmk6Dmk6Hmiqzmk6Pmk6/mlKzmk7bmk7Tmk7Lmk7rmlIDmk73mlJjmlJzmlIXmlKTmlKPmlKvmlLTmlLXmlLfmlLbmlLjnlYvmlYjmlZbmlZXmlY3mlZjmlZ7mlZ3mlbLmlbjmloLmloPorormlpvmlp/mlqvmlrfml4Pml4bml4Hml4Tml4zml5Lml5vml5nml6Dml6Hml7HmnbLmmIrmmIPml7vmnbPmmLXmmLbmmLTmmJzmmY/mmYTmmYnmmYHmmZ7mmZ3mmaTmmafmmajmmZ/mmaLmmbDmmoPmmojmmo7mmonmmoTmmpjmmp3mm4Hmmrnmm4nmmr7mmrxcIl0sXG5bXCJkYmExXCIsXCLmm4Tmmrjmm5bmm5rmm6DmmL/mm6bmm6nmm7Dmm7Xmm7fmnI/mnJbmnJ7mnKbmnKfpnLjmnK7mnL/mnLbmnYHmnLjmnLfmnYbmnZ7mnaDmnZnmnaPmnaTmnonmnbDmnqnmnbzmnarmnozmnovmnqbmnqHmnoXmnrfmn6/mnrTmn6zmnrPmn6nmnrjmn6Tmn57mn53mn6Lmn67mnrnmn47mn4bmn6fmqpzmoJ7moYbmoKnmoYDmoY3moLLmoY7morPmoKvmoZnmoaPmobfmob/mop/moo/moq3mopTmop3mopvmooPmqq7mornmobTmorXmoqDmorrmpI/moo3mob7mpIHmo4rmpIjmo5jmpKLmpKbmo6HmpIzmo41cIl0sXG5bXCJkY2ExXCIsXCLmo5Tmo6fmo5XmpLbmpJLmpITmo5fmo6PmpKXmo7nmo6Dmo6/mpKjmpKrmpJrmpKPmpKHmo4bmpbnmpbfmpZzmpbjmpavmpZTmpb7mpa7mpLnmpbTmpL3mpZnmpLDmpaHmpZ7mpZ3mpoHmparmprLmpq7mp5Dmpr/mp4Hmp5Pmpr7mp47lr6jmp4rmp53mprvmp4PmpqfmqK7mppHmpqDmppzmppXmprTmp57mp6jmqILmqJvmp7/mrIrmp7nmp7Lmp6fmqIXmprHmqJ7mp63mqJTmp6vmqIrmqJLmq4HmqKPmqJPmqYTmqIzmqbLmqLbmqbjmqYfmqaLmqZnmqabmqYjmqLjmqKLmqpDmqo3mqqDmqoTmqqLmqqNcIl0sXG5bXCJkZGExXCIsXCLmqpfomJfmqrvmq4Pmq4LmqrjmqrPmqqzmq57mq5Hmq5/mqqrmq5rmq6rmq7vmrIXomJbmq7rmrJLmrJbprLHmrJ/mrLjmrLfnm5zmrLnpo67mrYfmrYPmrYnmrZDmrZnmrZTmrZvmrZ/mraHmrbjmrbnmrb/mroDmroTmroPmro3mrpjmrpXmrp7mrqTmrqrmrqvmrq/mrrLmrrHmrrPmrrfmrrzmr4bmr4vmr5Pmr5/mr6zmr6vmr7Pmr6/pur7msIjmsJPmsJTmsJvmsKTmsKPmsZ7msZXmsaLmsarmsoLmso3msprmsoHmspvmsb7msajmsbPmspLmspDms4Tms7Hms5Pmsr3ms5fms4Xms53msq7msrHmsr5cIl0sXG5bXCJkZWExXCIsXCLmsrrms5vms6/ms5nms6rmtJ/ooY3mtLbmtKvmtL3mtLjmtJnmtLXmtLPmtJLmtIzmtaPmtpPmtaTmtZrmtbnmtZnmto7mtpXmv6TmtoXmt7nmuJXmuIrmtrXmt4fmt6bmtrjmt4bmt6zmt57mt4zmt6jmt5Lmt4Xmt7rmt5nmt6Tmt5Xmt6rmt67muK3mua7muK7muJnmubLmuZ/muL7muKPmuavmuKvmubbmuY3muJ/muYPmuLrmuY7muKTmu7/muJ3muLjmuoLmuqrmupjmu4nmurfmu5Pmur3muq/mu4TmurLmu5Tmu5Xmuo/muqXmu4Lmup/mvYHmvJHngYzmu6zmu7jmu77mvL/mu7LmvLHmu6/mvLLmu4xcIl0sXG5bXCJkZmExXCIsXCLmvL7mvJPmu7fmvobmvbrmvbjmvoHmvoDmva/mvZvmv7Pmva3mvoLmvbzmvZjmvo7mvpHmv4LmvabmvrPmvqPmvqHmvqTmvrnmv4bmvqrmv5/mv5Xmv6zmv5Tmv5jmv7Hmv67mv5vngInngIvmv7rngJHngIHngI/mv77ngJvngJrmvbTngJ3ngJjngJ/ngLDngL7ngLLngZHngaPngpnngpLngq/ng7HngqzngrjngrPngq7ng5/ng4vng53ng5nnhInng73nhJznhJnnhaXnhZXnhojnhabnhaLnhYznhZbnhaznho/nh7vnhoTnhpXnhqjnhqznh5fnhrnnhr7nh5Lnh4nnh5Tnh47nh6Dnh6znh6fnh7Xnh7xcIl0sXG5bXCJlMGExXCIsXCLnh7nnh7/niI3niJDniJvniKjniK3niKzniLDniLLniLvniLzniL/niYDniYbniYvniZjnibTnib7nioLnioHniofnipLnipbniqLniqfnirnnirLni4Pni4bni4Tni47ni5Lni6Lni6Dni6Hni7nni7flgI/njJfnjIrnjJznjJbnjJ3njLTnjK/njKnnjKXnjL7njY7njY/pu5jnjZfnjarnjajnjbDnjbjnjbXnjbvnjbrnj4jnjrPnj47njrvnj4Dnj6Xnj67nj57nkqLnkIXnka/nkKXnj7jnkLLnkLrnkZXnkL/nkZ/nkZnnkYHnkZznkannkbDnkaPnkarnkbbnkb7nkovnkp7nkqfnk4rnk4/nk5Tnj7FcIl0sXG5bXCJlMWExXCIsXCLnk6Dnk6Pnk6fnk6nnk67nk7Lnk7Dnk7Hnk7jnk7fnlITnlIPnlIXnlIznlI7nlI3nlJXnlJPnlJ7nlKbnlKznlLznlYTnlY3nlYrnlYnnlZvnlYbnlZrnlannlaTnlafnlavnla3nlbjnlbbnlobnlofnlbTnlornlonnloLnlpTnlprnlp3nlqXnlqPnl4LnlrPnl4PnlrXnlr3nlrjnlrznlrHnl43nl4rnl5Lnl5nnl6Pnl57nl77nl7/nl7znmIHnl7Dnl7rnl7Lnl7PnmIvnmI3nmInnmJ/nmKfnmKDnmKHnmKLnmKTnmLTnmLDnmLvnmYfnmYjnmYbnmZznmZjnmaHnmaLnmajnmannmarnmafnmaznmbBcIl0sXG5bXCJlMmExXCIsXCLnmbLnmbbnmbjnmbznmoDnmoPnmojnmovnmo7nmpbnmpPnmpnnmprnmrDnmrTnmrjnmrnnmrrnm4Lnm43nm5bnm5Lnm57nm6Hnm6Xnm6fnm6romK/nm7vnnIjnnIfnnITnnKnnnKTnnJ7nnKXnnKbnnJvnnLfnnLjnnYfnnZrnnajnnavnnZvnnaXnnb/nnb7nnbnnno7nnovnnpHnnqDnnp7nnrDnnrbnnrnnnr/nnrznnr3nnrvnn4fnn43nn5fnn5rnn5znn6Pnn67nn7znoIznoJLnpKbnoKDnpKrnoYXnoo7nobTnoobnobznoprnooznoqPnorXnoqrnoq/no5Hno4bno4vno5Tnor7norzno4Xno4rno6xcIl0sXG5bXCJlM2ExXCIsXCLno6fno5rno73no7TnpIfnpJLnpJHnpJnnpKznpKvnpYDnpaDnpZfnpZ/npZrnpZXnpZPnpbrnpb/npornpp3npqfpvYvnpqrnpq7nprPnprnnprrnp4nnp5Xnp6fnp6znp6Hnp6PnqIjnqI3nqJjnqJnnqKDnqJ/npoDnqLHnqLvnqL7nqLfnqYPnqZfnqYnnqaHnqaLnqanpvp3nqbDnqbnnqb3nqojnqpfnqpXnqpjnqpbnqqnnq4jnqrDnqrbnq4Xnq4Tnqr/pgoPnq4fnq4rnq43nq4/nq5Xnq5Pnq5nnq5rnq53nq6Hnq6Lnq6bnq63nq7DnrILnrI/nrIrnrIbnrLPnrJjnrJnnrJ7nrLXnrKjnrLbnrZBcIl0sXG5bXCJlNGExXCIsXCLnrbrnrITnrY3nrIvnrYznrYXnrbXnraXnrbTnrafnrbDnrbHnraznra7nrp3nrpjnrp/nro3nrpznrprnrovnrpLnro/nrZ3nrpnnr4vnr4Hnr4znr4/nrrTnr4bnr53nr6nnsJHnsJTnr6bnr6XnsaDnsIDnsIfnsJPnr7Pnr7fnsJfnsI3nr7bnsKPnsKfnsKrnsJ/nsLfnsKvnsL3nsYznsYPnsZTnsY/nsYDnsZDnsZjnsZ/nsaTnsZbnsaXnsaznsbXnsoPnspDnsqTnsq3nsqLnsqvnsqHnsqjnsrPnsrLnsrHnsq7nsrnnsr3ns4Dns4Xns4Lns5jns5Lns5zns6LprLvns6/ns7Lns7Tns7bns7rntIZcIl0sXG5bXCJlNWExXCIsXCLntILntJzntJXntIrntYXntYvntK7ntLLntL/ntLXntYbntbPntZbntY7ntbLntajnta7ntY/ntaPntpPntonntZvnto/ntb3ntpvntrrntq7ntqPntrXnt4fntr3ntqvnuL3ntqLntq/nt5zntrjntp/ntrDnt5jnt53nt6Tnt57nt7vnt7Lnt6HnuIXnuIrnuKPnuKHnuJLnuLHnuJ/nuInnuIvnuKLnuYbnuabnuLvnuLXnuLnnuYPnuLfnuLLnuLrnuafnuZ3nuZbnuZ7nuZnnuZrnubnnuarnuannubznubvnuoPnt5Xnub3ovq7nub/nuojnuonnuoznupLnupDnupPnupTnupbnuo7nupvnupznvLjnvLpcIl0sXG5bXCJlNmExXCIsXCLnvYXnvYznvY3nvY7nvZDnvZHnvZXnvZTnvZjnvZ/nvaDnvajnvannvafnvbjnvoLnvobnvoPnvojnvofnvoznvpTnvp7nvp3nvprnvqPnvq/nvrLnvrnnvq7nvrbnvrjorbHnv4Xnv4bnv4rnv5Xnv5Tnv6Hnv6bnv6nnv7Pnv7npo5zogIbogITogIvogJLogJjogJnogJzogKHogKjogL/ogLvogYrogYbogZLogZjogZrogZ/ogaLogajogbPogbLogbDogbbogbnogb3ogb/ogoTogobogoXogpvogpPogprogq3lhpDogqzog5vog6Xog5nog53og4Tog5rog5bohInog6/og7HohJvohKnohKPohK/ohYtcIl0sXG5bXCJlN2ExXCIsXCLpmovohYbohL7ohZPohZHog7zohbHoha7ohaXohabohbTohoPohojohorohoDohoLohqDohpXohqTohqPohZ/ohpPohqnohrDohrXohr7ohrjohr3oh4Doh4Lohrroh4noh43oh5Hoh5noh5joh4joh5roh5/oh6Doh6foh7roh7voh77oiIHoiILoiIXoiIfoiIroiI3oiJDoiJboiKnoiKvoiLjoiLPoiYDoiZnoiZjoiZ3oiZroiZ/oiaToiaLoiajoiaroiavoiK7oibHoibfoibjoib7oio3oipLoiqvoip/oirvoiqzoi6Hoi6Poi5/oi5Loi7Toi7Poi7rojpPojIPoi7voi7noi57ojIboi5zojInoi5lcIl0sXG5bXCJlOGExXCIsXCLojLXojLTojJbojLLojLHojYDojLnojZDojYXojK/ojKvojJfojJjojoXojprojqrojp/ojqLojpbojKPojo7ojofojorojbzojrXojbPojbXojqDojonojqjoj7TokJPoj6voj47oj73okIPoj5jokIvoj4Hoj7fokIfoj6Doj7LokI3okKLokKDojr3okLjolIboj7voka3okKrokLzolZrokoTokbfokavokq3oka7okoLokanokYbokKzoka/okbnokLXok4rokaLokrnokr/okp/ok5nok43okrvok5rok5Dok4Hok4bok5bokqHolKHok7/ok7TolJfolJjolKzolJ/olJXolJTok7zolYDolaPolZjolYhcIl0sXG5bXCJlOWExXCIsXCLolYHomILolYvolZXoloDolqTolojolpHolorolqjola3olpTolpvol6rolofolpzolbfolb7olpDol4nolrrol4/olrnol5Dol5Xol53ol6Xol5zol7nomIromJPomIvol77ol7romIbomKLomJromLDomL/omY3kuZXomZTomZ/omafombHompPomqPomqnomqromovomozomrbomq/om4Tom4bomrDom4nooKPomqvom5Tom57om6nom6zom5/om5vom6/onJLonIbonIjonIDonIPom7vonJHonInonI3om7nonIronLTonL/onLfonLvonKXonKnonJronaDonZ/onbjonYzonY7onbTonZfonajona7onZlcIl0sXG5bXCJlYWExXCIsXCLonZPonaPonarooIXonqLonp/onoLonq/on4vonr3on4Don5Dpm5bonqvon4TonrPon4fon4bonrvon6/on7Lon6DooI/ooI3on77on7bon7fooI7on5LooJHooJbooJXooKLooKHooLHooLbooLnooKfooLvooYTooYLooZLooZnooZ7ooaLooavoooHoob7oop7oobXoob3oorXoobLoooLoopfoopLooq7oopnooqLooo3ooqToorDoor/oorHoo4Poo4Too5Too5joo5noo53oo7nopILoo7zoo7Too6joo7LopITopIzopIropJPopYPopJ7opKXopKropKvopYHopYTopLvopLbopLjopYzopJ3opaDopZ5cIl0sXG5bXCJlYmExXCIsXCLopabopaTopa3oparopa/opbTopbfopb7opoPopojoporoppPoppjopqHopqnopqbopqzopq/oprLoprropr3opr/op4Dop5rop5zop53op6fop7Top7joqIPoqJboqJDoqIzoqJvoqJ3oqKXoqLboqYHoqZvoqZLoqYboqYjoqbzoqa3oqazoqaLoqoXoqoLoqoToqqjoqqHoqpHoqqXoqqboqproqqPoq4Toq43oq4Loq5roq6voq7Poq6foq6Toq7HorJToq6Doq6Loq7foq57oq5vorIzorIforJroq6HorJborJDorJforKDorLPpnqvorKborKvorL7orKjorYHorYzorY/orY7orYnorZborZvorZroratcIl0sXG5bXCJlY2ExXCIsXCLorZ/orazora/orbTorb3oroDorozoro7orpLorpPorpborpnorprosLrosYHosL/osYjosYzosY7osZDosZXosaLosazosbjosbrosoLosonosoXosoroso3oso7ospTosbzospjmiJ3osq3osqrosr3osrLosrPosq7osrbos4jos4Hos6Tos6Pos5ros73os7ros7votITotIXotIrotIfotI/otI3otJDpvY7otJPos43otJTotJbotafota3otbHotbPotoHotpnot4Lotr7otrrot4/ot5rot5bot4zot5vot4vot6rot6vot5/ot6Pot7zouIjouInot7/ouJ3ouJ7ouJDouJ/ouYLouLXouLDouLTouYpcIl0sXG5bXCJlZGExXCIsXCLouYfouYnouYzouZDouYjouZnouaTouaDouKrouaPouZXoubboubLoubzouoHouofouoXouoTouovouoroupPoupHoupToupnouqrouqHouqzourDou4bourHour7ou4Xou4jou4vou5vou6Pou7zou7vou6vou77ovIrovIXovJXovJLovJnovJPovJzovJ/ovJvovIzovKbovLPovLvovLnovYXovYLovL7ovYzovYnovYbovY7ovZfovZzovaLovaPovaTovpzovp/ovqPovq3ovq/ovrfov5rov6Xov6Lov6rov6/pgofov7TpgIXov7nov7rpgJHpgJXpgKHpgI3pgJ7pgJbpgIvpgKfpgLbpgLXpgLnov7hcIl0sXG5bXCJlZWExXCIsXCLpgY/pgZDpgZHpgZLpgI7pgYnpgL7pgZbpgZjpgZ7pgajpga/pgbbpmqjpgbLpgoLpgb3pgoHpgoDpgorpgonpgo/pgqjpgq/pgrHpgrXpg6Lpg6TmiYjpg5vphILphJLphJnphLLphLDphYrphZbphZjphaPphaXphanphbPphbLphovphonphoLphqLphqvphq/phqrphrXphrTphrrph4Dph4Hph4nph4vph5Dph5bph5/ph6Hph5vph7zph7Xph7bpiJ7ph7/piJTpiKzpiJXpiJHpiZ7piZfpiYXpiYnpiaTpiYjpipXpiL/piYvpiZDpipzpipbpipPpipvpiZrpi4/pirnpirfpi6npjI/pi7rpjYTpjK5cIl0sXG5bXCJlZmExXCIsXCLpjJnpjKLpjJrpjKPpjLrpjLXpjLvpjZzpjaDpjbzpja7pjZbpjrDpjqzpjq3pjpTpjrnpj5bpj5fpj6jpj6Xpj5jpj4Ppj53pj5Dpj4jpj6TpkJrpkJTpkJPpkIPpkIfpkJDpkLbpkKvpkLXpkKHpkLrpkYHpkZLpkYTpkZvpkaDpkaLpkZ7pkarpiKnpkbDpkbXpkbfpkb3pkZrpkbzpkb7pkoHpkb/ploLplofplorplpTplpbplpjplpnplqDplqjplqfplq3plrzplrvplrnplr7pl4rmv7bpl4Ppl43pl4zpl5Xpl5Tpl5bpl5zpl6Hpl6Xpl6LpmKHpmKjpmK7pmK/pmYLpmYzpmY/pmYvpmbfpmZzpmZ5cIl0sXG5bXCJmMGExXCIsXCLpmZ3pmZ/pmabpmbLpmazpmo3pmpjpmpXpmpfpmqrpmqfpmrHpmrLpmrDpmrTpmrbpmrjpmrnpm47pm4vpm4npm43opY3pm5zpnI3pm5Xpm7npnITpnIbpnIjpnJPpnI7pnJHpnI/pnJbpnJnpnKTpnKrpnLDpnLnpnL3pnL7pnYTpnYbpnYjpnYLpnYnpnZzpnaDpnaTpnabpnajli5LpnavpnbHpnbnpnoXpnbzpnoHpnbrpnobpnovpno/pnpDpnpzpnqjpnqbpnqPpnrPpnrTpn4Ppn4bpn4jpn4vpn5zpn63pvY/pn7Lnq5/pn7bpn7XpoI/poIzpoLjpoKTpoKHpoLfpoL3poYbpoY/poYvpoavpoa/pobBcIl0sXG5bXCJmMWExXCIsXCLpobHpobTpobPpoqrpoq/porHporbpo4Tpo4Ppo4bpo6npo6vppIPppInppJLppJTppJjppKHppJ3ppJ7ppKTppKDppKzppK7ppL3ppL7ppYLppYnppYXppZDppYvppZHppZLppYzppZXpppfpppjppqXppq3ppq7pprzpp5/pp5vpp53pp5jpp5Hpp63pp67pp7Hpp7Lpp7vpp7jpqIHpqI/pqIXpp6LpqJnpqKvpqLfpqYXpqYLpqYDpqYPpqL7pqZXpqY3pqZvpqZfpqZ/pqaLpqaXpqaTpqanpqavpqarpqq3pqrDpqrzpq4Dpq4/pq5Hpq5Ppq5Tpq57pq5/pq6Lpq6Ppq6bpq6/pq6vpq67pq7Tpq7Hpq7dcIl0sXG5bXCJmMmExXCIsXCLpq7vprIbprJjprJrprJ/prKLprKPprKXprKfprKjprKnprKrprK7prK/prLLprYTprYPprY/prY3prY7prZHprZjprbTprpPproPprpHprpbprpfprp/prqDprqjprrTpr4Dpr4rprrnpr4bpr4/pr5Hpr5Lpr6Ppr6Lpr6Tpr5Tpr6HpsLrpr7Lpr7Hpr7DpsJXpsJTpsInpsJPpsIzpsIbpsIjpsJLpsIrpsITpsK7psJvpsKXpsKTpsKHpsLDpsYfpsLLpsYbpsL7psZrpsaDpsafpsbbpsbjps6fps6zps7DptInptIjps6vptIPptIbptKrptKbptq/ptKPptJ/ptYTptJXptJLptYHptL/ptL7ptYbptYhcIl0sXG5bXCJmM2ExXCIsXCLptZ3ptZ7ptaTptZHptZDptZnptbLptonptofptqvpta/ptbrptprptqTptqnptrLpt4Tpt4Hptrvptrjptrrpt4bpt4/pt4Lpt5npt5Ppt7jpt6bpt63pt6/pt73puJrpuJvpuJ7pubXpubnpub3puoHpuojpuovpuozpupLpupXpupHpup3puqXpuqnpurjpuqrpuq3pnaHpu4zpu47pu4/pu5Dpu5Tpu5zpu57pu53pu6Dpu6Xpu6jpu6/pu7Tpu7bpu7fpu7npu7vpu7zpu73pvIfpvIjnmrfpvJXpvKHpvKzpvL7pvYrpvZLpvZTpvaPpvZ/pvaDpvaHpvabpvafpvazpvarpvbfpvbLpvbbpvpXpvpzpvqBcIl0sXG5bXCJmNGExXCIsXCLloK/mp4fpgZnnkaTlh5znhplcIl0sXG5bXCJmOWExXCIsXCLnuoropJzpjYjpiojok5zkv4nngrvmmLHmo4jpi7nmm7vlvYXkuKjku6Hku7zkvIDkvIPkvLnkvZbkvpLkvorkvprkvpTkv43lgYDlgKLkv7/lgJ7lgYblgbDlgYLlgpTlg7Tlg5jlhYrlhaTlhp3lhr7lh6zliJXlipzliqbli4Dli5vljIDljIfljKTljbLljpPljrLlj53vqI7lkpzlkorlkqnlk7/lloblnZnlnaXlnqzln4jln4fvqI/vqJDlop7lorLlpIvlpZPlpZvlpZ3lpaPlpqTlprrlrZblr4DnlK/lr5jlr6zlsJ7lsqblsrrls7XltKfltZPvqJHltYLlta3ltrjltrnlt5DlvKHlvLTlvaflvrdcIl0sXG5bXCJmYWExXCIsXCLlv57mgZ3mgoXmgormg57mg5XmhKDmg7LmhJHmhLfmhLDmhpjmiJPmiqbmj7XmkaDmkp3mk47mlY7mmIDmmJXmmLvmmInmmK7mmJ7mmKTmmaXmmZfmmZnvqJLmmbPmmpnmmqDmmrLmmr/mm7rmnI7vpKnmnabmnrvmoZLmn4DmoIHmoYTmo4/vqJPmpajvqJTmppjmp6LmqLDmqavmqYbmqbPmqb7mq6Lmq6Tmr5bmsL/msZzmsobmsa/ms5rmtITmtofmta/mtpbmtqzmt4/mt7jmt7Lmt7zmuLnmuZzmuKfmuLzmur/mvojmvrXmv7XngIXngIfngKjngoXngqvnhI/nhITnhZznhYbnhYfvqJXnh4Hnh77nirFcIl0sXG5bXCJmYmExXCIsXCLnir7njKTvqJbnjbfnjr3nj4nnj5bnj6Pnj5LnkIfnj7XnkKbnkKrnkKnnkK7nkaLnkonnkp/nlIHnla/nmoLnmpznmp7nmpvnmqbvqJfnnYbliq/noKHnoY7noaTnobrnpLDvqJjvqJnvqJrnppTvqJvnppvnq5Hnq6fvqJznq6vnrp7vqJ3ntYjntZzntrfntqDnt5bnuZLnvYfnvqHvqJ7ojIHojaLojb/oj4foj7bokYjokrTolZPolZnolavvqJ/olrDvqKDvqKHooIfoo7XoqJLoqLfoqbnoqqfoqr7oq5/vqKLoq7borZPorb/os7Dos7TotJLotbbvqKPou4/vqKTvqKXpgafpg57vqKbphJXphKfph5pcIl0sXG5bXCJmY2ExXCIsXCLph5fph57ph63ph67ph6Tph6XpiIbpiJDpiIrpiLrpiYDpiLzpiY7piZnpiZHpiLnpiafpiqfpibfpibjpi6fpi5fpi5npi5DvqKfpi5Xpi6Dpi5PpjKXpjKHpi7vvqKjpjJ7pi7/pjJ3pjILpjbDpjZfpjqTpj4bpj57pj7jpkLHpkYXpkYjplpLvp5zvqKnpmp3pmq/pnLPpnLvpnYPpnY3pnY/pnZHpnZXpoZfpoaXvqKrvqKvppKfvqKzppp7pqY7pq5npq5zprbXprbLpro/prrHprrvpsIDptbDptavvqK3puJnpu5FcIl0sXG5bXCJmY2YxXCIsXCLihbBcIiw5LFwi77+i77+k77yH77yCXCJdLFxuW1wiOGZhMmFmXCIsXCLLmMuHwrjLmcudwq/Lm8ua772ezoTOhVwiXSxcbltcIjhmYTJjMlwiLFwiwqHCpsK/XCJdLFxuW1wiOGZhMmViXCIsXCLCusKqwqnCruKEosKk4oSWXCJdLFxuW1wiOGZhNmUxXCIsXCLOhs6IzonOis6qXCJdLFxuW1wiOGZhNmU3XCIsXCLOjFwiXSxcbltcIjhmYTZlOVwiLFwizo7Oq1wiXSxcbltcIjhmYTZlY1wiLFwizo9cIl0sXG5bXCI4ZmE2ZjFcIixcIs6szq3Ors6vz4rOkM+Mz4LPjc+LzrDPjlwiXSxcbltcIjhmYTdjMlwiLFwi0IJcIiwxMCxcItCO0I9cIl0sXG5bXCI4ZmE3ZjJcIixcItGSXCIsMTAsXCLRntGfXCJdLFxuW1wiOGZhOWExXCIsXCLDhsSQXCJdLFxuW1wiOGZhOWE0XCIsXCLEplwiXSxcbltcIjhmYTlhNlwiLFwixLJcIl0sXG5bXCI4ZmE5YThcIixcIsWBxL9cIl0sXG5bXCI4ZmE5YWJcIixcIsWKw5jFklwiXSxcbltcIjhmYTlhZlwiLFwixabDnlwiXSxcbltcIjhmYTljMVwiLFwiw6bEkcOwxKfEscSzxLjFgsWAxYnFi8O4xZPDn8Wnw75cIl0sXG5bXCI4ZmFhYTFcIixcIsOBw4DDhMOCxILHjcSAxITDhcODxIbEiMSMw4fEisSOw4nDiMOLw4rEmsSWxJLEmFwiXSxcbltcIjhmYWFiYVwiLFwixJzEnsSixKDEpMONw4zDj8OOx4/EsMSqxK7EqMS0xLbEucS9xLvFg8WHxYXDkcOTw5LDlsOUx5HFkMWMw5XFlMWYxZbFmsWcxaDFnsWkxaLDmsOZw5zDm8Wsx5PFsMWqxbLFrsWox5fHm8eZx5XFtMOdxbjFtsW5xb3Fu1wiXSxcbltcIjhmYWJhMVwiLFwiw6HDoMOkw6LEg8eOxIHEhcOlw6PEh8SJxI3Dp8SLxI/DqcOow6vDqsSbxJfEk8SZx7XEncSfXCJdLFxuW1wiOGZhYmJkXCIsXCLEocSlw63DrMOvw67HkFwiXSxcbltcIjhmYWJjNVwiLFwixKvEr8SpxLXEt8S6xL7EvMWExYjFhsOxw7PDssO2w7THksWRxY3DtcWVxZnFl8WbxZ3FocWfxaXFo8O6w7nDvMO7xa3HlMWxxavFs8WvxanHmMecx5rHlsW1w73Dv8W3xbrFvsW8XCJdLFxuW1wiOGZiMGExXCIsXCLkuILkuITkuIXkuIzkuJLkuJ/kuKPkuKTkuKjkuKvkuK7kuK/kuLDkuLXkuYDkuYHkuYTkuYfkuZHkuZrkuZzkuaPkuajkuankubTkubXkubnkub/kuo3kupbkupfkup3kuq/kurnku4Pku5Dku5rku5vku6Dku6Hku6Lku6jku6/ku7Hku7Pku7Xku73ku77ku7/kvIDkvILkvIPkvIjkvIvkvIzkvJLkvJXkvJbkvJfkvJnkvK7kvLHkvaDkvLPkvLXkvLfkvLnkvLvkvL7kvYDkvYLkvYjkvYnkvYvkvYzkvZLkvZTkvZbkvZjkvZ/kvaPkvarkvazkva7kvbHkvbfkvbjkvbnkvbrkvb3kvb7kvoHkvoLkvoRcIl0sXG5bXCI4ZmIxYTFcIixcIuS+heS+ieS+iuS+jOS+juS+kOS+kuS+k+S+lOS+l+S+meS+muS+nuS+n+S+suS+t+S+ueS+u+S+vOS+veS+vuS/gOS/geS/heS/huS/iOS/ieS/i+S/jOS/jeS/j+S/kuS/nOS/oOS/ouS/sOS/suS/vOS/veS/v+WAgOWAgeWAhOWAh+WAiuWAjOWAjuWAkOWAk+WAl+WAmOWAm+WAnOWAneWAnuWAouWAp+WAruWAsOWAsuWAs+WAteWBgOWBgeWBguWBheWBhuWBiuWBjOWBjuWBkeWBkuWBk+WBl+WBmeWBn+WBoOWBouWBo+WBpuWBp+WBquWBreWBsOWBseWAu+WCgeWCg+WChOWChuWCiuWCjuWCj+WCkFwiXSxcbltcIjhmYjJhMVwiLFwi5YKS5YKT5YKU5YKW5YKb5YKc5YKeXCIsNCxcIuWCquWCr+WCsOWCueWCuuWCveWDgOWDg+WDhOWDh+WDjOWDjuWDkOWDk+WDlOWDmOWDnOWDneWDn+WDouWDpOWDpuWDqOWDqeWDr+WDseWDtuWDuuWDvuWEg+WEhuWEh+WEiOWEi+WEjOWEjeWEjuWDsuWEkOWEl+WEmeWEm+WEnOWEneWEnuWEo+WEp+WEqOWErOWEreWEr+WEseWEs+WEtOWEteWEuOWEueWFguWFiuWFj+WFk+WFleWFl+WFmOWFn+WFpOWFpuWFvuWGg+WGhOWGi+WGjuWGmOWGneWGoeWGo+WGreWGuOWGuuWGvOWGvuWGv+WHglwiXSxcbltcIjhmYjNhMVwiLFwi5YeI5YeP5YeR5YeS5YeT5YeV5YeY5Yee5Yei5Yel5Yeu5Yey5Yez5Ye05Ye35YiB5YiC5YiF5YiS5YiT5YiV5YiW5YiY5Yii5Yio5Yix5Yiy5Yi15Yi85YmF5YmJ5YmV5YmX5YmY5Yma5Ymc5Ymf5Ymg5Ymh5Ymm5Ymu5Ym35Ym45Ym55YqA5YqC5YqF5YqK5YqM5YqT5YqV5YqW5YqX5YqY5Yqa5Yqc5Yqk5Yql5Yqm5Yqn5Yqv5Yqw5Yq25Yq35Yq45Yq65Yq75Yq95YuA5YuE5YuG5YuI5YuM5YuP5YuR5YuU5YuW5Yub5Yuc5Yuh5Yul5Yuo5Yup5Yuq5Yus5Yuw5Yux5Yu05Yu25Yu35YyA5YyD5YyK5YyLXCJdLFxuW1wiOGZiNGExXCIsXCLljIzljJHljJPljJjljJvljJzljJ7ljJ/ljKXljKfljKjljKnljKvljKzljK3ljLDljLLljLXljLzljL3ljL7ljYLljYzljYvljZnljZvljaHljaPljaXljazlja3ljbLljbnljb7ljoPljofljojljo7ljpPljpTljpnljp3ljqHljqTljqrljqvljq/ljrLljrTljrXljrfljrjljrrljr3lj4Dlj4Xlj4/lj5Llj5Plj5Xlj5rlj53lj57lj6Dlj6blj6flj7XlkILlkJPlkJrlkKHlkKflkKjlkKrlkK/lkLHlkLTlkLXlkYPlkYTlkYflkY3lkY/lkZ7lkaLlkaTlkablkaflkanlkavlka3lka7lkbTlkb9cIl0sXG5bXCI4ZmI1YTFcIixcIuWSgeWSg+WSheWSiOWSieWSjeWSkeWSleWSluWSnOWSn+WSoeWSpuWSp+WSqeWSquWSreWSruWSseWSt+WSueWSuuWSu+WSv+WThuWTiuWTjeWTjuWToOWTquWTrOWTr+WTtuWTvOWTvuWTv+WUgOWUgeWUheWUiOWUieWUjOWUjeWUjuWUleWUquWUq+WUsuWUteWUtuWUu+WUvOWUveWVgeWVh+WVieWViuWVjeWVkOWVkeWVmOWVmuWVm+WVnuWVoOWVoeWVpOWVpuWVv+WWgeWWguWWhuWWiOWWjuWWj+WWkeWWkuWWk+WWlOWWl+WWo+WWpOWWreWWsuWWv+WXgeWXg+WXhuWXieWXi+WXjOWXjuWXkeWXklwiXSxcbltcIjhmYjZhMVwiLFwi5ZeT5ZeX5ZeY5Zeb5Zee5Zei5Zep5Ze25Ze/5ZiF5ZiI5ZiK5ZiNXCIsNSxcIuWYmeWYrOWYsOWYs+WYteWYt+WYueWYu+WYvOWYveWYv+WZgOWZgeWZg+WZhOWZhuWZieWZi+WZjeWZj+WZlOWZnuWZoOWZoeWZouWZo+WZpuWZqeWZreWZr+WZseWZsuWZteWahOWaheWaiOWai+WajOWaleWameWamuWaneWanuWan+WapuWap+WaqOWaqeWaq+WarOWareWaseWas+Wat+WavuWbheWbieWbiuWbi+Wbj+WbkOWbjOWbjeWbmeWbnOWbneWbn+WboeWbpFwiLDQsXCLlm7Hlm6vlm61cIl0sXG5bXCI4ZmI3YTFcIixcIuWbtuWbt+WcgeWcguWch+WciuWcjOWckeWcleWcmuWcm+WcneWcoOWcouWco+WcpOWcpeWcqeWcquWcrOWcruWcr+Wcs+WctOWcveWcvuWcv+WdheWdhuWdjOWdjeWdkuWdouWdpeWdp+WdqOWdq+WdrVwiLDQsXCLlnbPlnbTlnbXlnbflnbnlnbrlnbvlnbzlnb7lnoHlnoPlnozlnpTlnpflnpnlnprlnpzlnp3lnp7lnp/lnqHlnpXlnqflnqjlnqnlnqzlnrjlnr3ln4fln4jln4zln4/ln5Xln53ln57ln6Tln6bln6fln6nln63ln7Dln7Xln7bln7jln73ln77ln7/loIPloITloIjloInln6FcIl0sXG5bXCI4ZmI4YTFcIixcIuWgjOWgjeWgm+WgnuWgn+WgoOWgpuWgp+WgreWgsuWgueWgv+WhieWhjOWhjeWhj+WhkOWhleWhn+WhoeWhpOWhp+WhqOWhuOWhvOWhv+WigOWigeWih+WiiOWiieWiiuWijOWijeWij+WikOWilOWiluWineWioOWioeWiouWipuWiqeWiseWisuWjhOWivOWjguWjiOWjjeWjjuWjkOWjkuWjlOWjluWjmuWjneWjoeWjouWjqeWjs+WkheWkhuWki+WkjOWkkuWkk+WklOiZgeWkneWkoeWko+WkpOWkqOWkr+WksOWks+WkteWktuWkv+Wlg+WlhuWlkuWlk+WlmeWlm+WlneWlnuWln+WloeWlo+Wlq+WlrVwiXSxcbltcIjhmYjlhMVwiLFwi5aWv5aWy5aW15aW25aW55aW75aW85aaL5aaM5aaO5aaS5aaV5aaX5aaf5aak5aan5aat5aau5aav5aaw5aaz5aa35aa65aa85aeB5aeD5aeE5aeI5aeK5aeN5aeS5aed5aee5aef5aej5aek5aen5aeu5aev5aex5aey5ae05ae35aiA5aiE5aiM5aiN5aiO5aiS5aiT5aie5aij5aik5ain5aio5aiq5ait5aiw5amE5amF5amH5amI5amM5amQ5amV5ame5amj5aml5amn5amt5am35am65am75am+5aqL5aqQ5aqT5aqW5aqZ5aqc5aqe5aqf5aqg5aqi5aqn5aqs5aqx5aqy5aqz5aq15aq45aq65aq75aq/XCJdLFxuW1wiOGZiYWExXCIsXCLlq4Tlq4blq4jlq4/lq5rlq5zlq6Dlq6Xlq6rlq67lq7Xlq7blq73lrIDlrIHlrIjlrJflrLTlrJnlrJvlrJ3lrKHlrKXlrK3lrLjlrYHlrYvlrYzlrZLlrZblrZ7lrajlra7lra/lrbzlrb3lrb7lrb/lroHlroTlroblrorlro7lrpDlrpHlrpPlrpTlrpblrqjlrqnlrqzlrq3lrq/lrrHlrrLlrrflrrrlrrzlr4Dlr4Hlr43lr4/lr5ZcIiw0LFwi5a+g5a+v5a+x5a+05a+95bCM5bCX5bCe5bCf5bCj5bCm5bCp5bCr5bCs5bCu5bCw5bCy5bC15bC25bGZ5bGa5bGc5bGi5bGj5bGn5bGo5bGpXCJdLFxuW1wiOGZiYmExXCIsXCLlsa3lsbDlsbTlsbXlsbrlsbvlsbzlsb3lsoflsojlsorlso/lspLlsp3lsp/lsqDlsqLlsqPlsqblsqrlsrLlsrTlsrXlsrrls4nls4vls5Lls53ls5fls67ls7Hls7Lls7TltIHltIbltI3ltJLltKvltKPltKTltKbltKfltLHltLTltLnltL3ltL/ltYLltYPltYbltYjltZXltZHltZnltYrltZ/ltaDltaHltaLltaTltarlta3ltbDltbnltbrltb7ltb/ltoHltoPltojltorltpLltpPltpTltpXltpnltpvltp/ltqDltqfltqvltrDltrTltrjltrnlt4Plt4flt4vlt5Dlt47lt5jlt5nlt6Dlt6RcIl0sXG5bXCI4ZmJjYTFcIixcIuW3qeW3uOW3ueW4gOW4h+W4jeW4kuW4lOW4leW4mOW4n+W4oOW4ruW4qOW4suW4teW4vuW5i+W5kOW5ieW5keW5luW5mOW5m+W5nOW5nuW5qOW5qlwiLDQsXCLlubDluoDluovluo7luqLluqTluqXluqjluqrluqzlurHlurPlur3lur7lur/lu4blu4zlu4vlu47lu5Hlu5Llu5Tlu5Xlu5zlu57lu6Xlu6vlvILlvIblvIflvIjlvI7lvJnlvJzlvJ3lvKHlvKLlvKPlvKTlvKjlvKvlvKzlvK7lvLDlvLTlvLblvLvlvL3lvL/lvYDlvYTlvYXlvYflvY3lvZDlvZTlvZjlvZvlvaDlvaPlvaTlvadcIl0sXG5bXCI4ZmJkYTFcIixcIuW9r+W9suW9tOW9teW9uOW9uuW9veW9vuW+ieW+jeW+j+W+luW+nOW+neW+ouW+p+W+q+W+pOW+rOW+r+W+sOW+seW+uOW/hOW/h+W/iOW/ieW/i+W/kFwiLDQsXCLlv57lv6Hlv6Llv6jlv6nlv6rlv6zlv63lv67lv6/lv7Llv7Plv7blv7rlv7zmgIfmgIrmgI3mgJPmgJTmgJfmgJjmgJrmgJ/mgKTmgK3mgLPmgLXmgYDmgYfmgYjmgYnmgYzmgZHmgZTmgZbmgZfmgZ3mgaHmgafmgbHmgb7mgb/mgoLmgobmgojmgormgo7mgpHmgpPmgpXmgpjmgp3mgp7mgqLmgqTmgqXmgqjmgrDmgrHmgrdcIl0sXG5bXCI4ZmJlYTFcIixcIuaCu+aCvuaDguaDhOaDiOaDieaDiuaDi+aDjuaDj+aDlOaDleaDmeaDm+aDneaDnuaDouaDpeaDsuaDteaDuOaDvOaDveaEguaEh+aEiuaEjOaEkFwiLDQsXCLmhJbmhJfmhJnmhJzmhJ7mhKLmhKrmhKvmhLDmhLHmhLXmhLbmhLfmhLnmhYHmhYXmhYbmhYnmhZ7mhaDmhazmhbLmhbjmhbvmhbzmhb/mhoDmhoHmhoPmhoTmhovmho3mhpLmhpPmhpfmhpjmhpzmhp3mhp/mhqDmhqXmhqjmhqrmhq3mhrjmhrnmhrzmh4Dmh4Hmh4Lmh47mh4/mh5Xmh5zmh53mh57mh5/mh6Hmh6Lmh6fmh6nmh6VcIl0sXG5bXCI4ZmJmYTFcIixcIuaHrOaHreaHr+aIgeaIg+aIhOaIh+aIk+aIleaInOaIoOaIouaIo+aIp+aIqeaIq+aIueaIveaJguaJg+aJhOaJhuaJjOaJkOaJkeaJkuaJlOaJluaJmuaJnOaJpOaJreaJr+aJs+aJuuaJveaKjeaKjuaKj+aKkOaKpuaKqOaKs+aKtuaKt+aKuuaKvuaKv+aLhOaLjuaLleaLluaLmuaLquaLsuaLtOaLvOaLveaMg+aMhOaMiuaMi+aMjeaMkOaMk+aMluaMmOaMqeaMquaMreaMteaMtuaMueaMvOaNgeaNguaNg+aNhOaNhuaNiuaNi+aNjuaNkuaNk+aNlOaNmOaNm+aNpeaNpuaNrOaNreaNseaNtOaNtVwiXSxcbltcIjhmYzBhMVwiLFwi5o245o285o295o2/5o6C5o6E5o6H5o6K5o6Q5o6U5o6V5o6Z5o6a5o6e5o6k5o6m5o6t5o6u5o6v5o695o+B5o+F5o+I5o+O5o+R5o+T5o+U5o+V5o+c5o+g5o+l5o+q5o+s5o+y5o+z5o+15o+45o+55pCJ5pCK5pCQ5pCS5pCU5pCY5pCe5pCg5pCi5pCk5pCl5pCp5pCq5pCv5pCw5pC15pC95pC/5pGL5pGP5pGR5pGS5pGT5pGU5pGa5pGb5pGc5pGd5pGf5pGg5pGh5pGj5pGt5pGz5pG05pG75pG95pKF5pKH5pKP5pKQ5pKR5pKY5pKZ5pKb5pKd5pKf5pKh5pKj5pKm5pKo5pKs5pKz5pK95pK+5pK/XCJdLFxuW1wiOGZjMWExXCIsXCLmk4Tmk4nmk4rmk4vmk4zmk47mk5Dmk5Hmk5Xmk5fmk6Tmk6Xmk6nmk6rmk63mk7Dmk7Xmk7fmk7vmk7/mlIHmlITmlIjmlInmlIrmlI/mlJPmlJTmlJbmlJnmlJvmlJ7mlJ/mlKLmlKbmlKnmlK7mlLHmlLrmlLzmlL3mlYPmlYfmlYnmlZDmlZLmlZTmlZ/mlaDmlafmlavmlbrmlb3mloHmloXmlormlpLmlpXmlpjmlp3mlqDmlqPmlqbmlq7mlrLmlrPmlrTmlr/ml4Lml4jml4nml47ml5Dml5Tml5bml5jml5/ml7Dml7Lml7Tml7Xml7nml77ml7/mmIDmmITmmIjmmInmmI3mmJHmmJLmmJXmmJbmmJ1cIl0sXG5bXCI4ZmMyYTFcIixcIuaYnuaYoeaYouaYo+aYpOaYpuaYqeaYquaYq+aYrOaYruaYsOaYseaYs+aYueaYt+aZgOaZheaZhuaZiuaZjOaZkeaZjuaZl+aZmOaZmeaZm+aZnOaZoOaZoeabu+aZquaZq+aZrOaZvuaZs+aZteaZv+aZt+aZuOaZueaZu+aagOaZvOaai+aajOaajeaakOaakuaameaamuaam+aanOaan+aaoOaapOaareaaseaasuaateaau+aav+abgOabguabg+abiOabjOabjuabj+ablOabm+abn+abqOabq+abrOabruabuuacheach+acjuack+acmeacnOacoOacouacs+acvuadheadh+adiOadjOadlOadleadnVwiXSxcbltcIjhmYzNhMVwiLFwi5p2m5p2s5p2u5p205p225p275p6B5p6E5p6O5p6P5p6R5p6T5p6W5p6Y5p6Z5p6b5p6w5p6x5p6y5p615p675p685p695p+55p+A5p+C5p+D5p+F5p+I5p+J5p+S5p+X5p+Z5p+c5p+h5p+m5p+w5p+y5p+25p+35qGS5qCU5qCZ5qCd5qCf5qCo5qCn5qCs5qCt5qCv5qCw5qCx5qCz5qC75qC/5qGE5qGF5qGK5qGM5qGV5qGX5qGY5qGb5qGr5qGuXCIsNCxcIuahteahueahuuahu+ahvOaiguaihOaihuaiiOailuaimOaimuainOaioeaio+aipeaiqeaiquairuaisuaiu+ajheajiOajjOajj1wiXSxcbltcIjhmYzRhMVwiLFwi5qOQ5qOR5qOT5qOW5qOZ5qOc5qOd5qOl5qOo5qOq5qOr5qOs5qOt5qOw5qOx5qO15qO25qO75qO85qO95qSG5qSJ5qSK5qSQ5qSR5qST5qSW5qSX5qSx5qSz5qS15qS45qS75qWC5qWF5qWJ5qWO5qWX5qWb5qWj5qWk5qWl5qWm5qWo5qWp5qWs5qWw5qWx5qWy5qW65qW75qW/5qaA5qaN5qaS5qaW5qaY5qah5qal5qam5qao5qar5qat5qav5qa35qa45qa65qa85qeF5qeI5qeR5qeW5qeX5qei5qel5qeu5qev5qex5qez5qe15qe+5qiA5qiB5qiD5qiP5qiR5qiV5qia5qid5qig5qik5qio5qiw5qiyXCJdLFxuW1wiOGZjNWExXCIsXCLmqLTmqLfmqLvmqL7mqL/mqYXmqYbmqYnmqYrmqY7mqZDmqZHmqZLmqZXmqZbmqZvmqaTmqafmqarmqbHmqbPmqb7mqoHmqoPmqobmqofmqonmqovmqpHmqpvmqp3mqp7mqp/mqqXmqqvmqq/mqrDmqrHmqrTmqr3mqr7mqr/mq4bmq4nmq4jmq4zmq5Dmq5Tmq5Xmq5bmq5zmq53mq6Tmq6fmq6zmq7Dmq7Hmq7Lmq7zmq73mrILmrIPmrIbmrIfmrInmrI/mrJDmrJHmrJfmrJvmrJ7mrKTmrKjmrKvmrKzmrK/mrLXmrLbmrLvmrL/mrYbmrYrmrY3mrZLmrZbmrZjmrZ3mraDmrafmravmra7mrbDmrbXmrb1cIl0sXG5bXCI4ZmM2YTFcIixcIuatvuauguauheaul+aum+aun+auoOauouauo+auqOauqeaurOaureauruausOauuOauueauveauvuavg+avhOavieavjOavluavmuavoeavo+avpuavp+avruavseavt+avueavv+awguawhOawheawieawjeawjuawkOawkuawmeawn+awpuawp+awqOawrOawruaws+awteawtuawuuawu+awv+axiuaxi+axjeaxj+axkuaxlOaxmeaxm+axnOaxq+axreaxr+axtOaxtuaxuOaxueaxu+ayheayhuayh+ayieaylOayleayl+aymOaynOayn+aysOaysuaytOazguazhuazjeazj+azkOazkeazkuazlOazllwiXSxcbltcIjhmYzdhMVwiLFwi5rOa5rOc5rOg5rOn5rOp5rOr5rOs5rOu5rOy5rO05rSE5rSH5rSK5rSO5rSP5rSR5rST5rSa5rSm5rSn5rSo5rGn5rSu5rSv5rSx5rS55rS85rS/5rWX5rWe5rWf5rWh5rWl5rWn5rWv5rWw5rW85raC5raH5raR5raS5raU5raW5raX5raY5raq5ras5ra05ra35ra55ra95ra/5reE5reI5reK5reO5reP5reW5reb5red5ref5reg5rei5rel5rep5rev5rew5re05re25re85riA5riE5rie5rii5rin5riy5ri25ri55ri75ri85rmE5rmF5rmI5rmJ5rmL5rmP5rmR5rmS5rmT5rmU5rmX5rmc5rmd5rmeXCJdLFxuW1wiOGZjOGExXCIsXCLmuaLmuaPmuajmubPmubvmub3muo3mupPmupnmuqDmuqfmuq3muq7murHmurPmurvmur/mu4Dmu4Hmu4Pmu4fmu4jmu4rmu43mu47mu4/mu6vmu63mu67mu7nmu7vmu73mvITmvIjmvIrmvIzmvI3mvJbmvJjmvJrmvJvmvKbmvKnmvKrmvK/mvLDmvLPmvLbmvLvmvLzmvK3mvY/mvZHmvZLmvZPmvZfmvZnmvZrmvZ3mvZ7mvaHmvaLmvajmvazmvb3mvb7mvoPmvofmvojmvovmvozmvo3mvpDmvpLmvpPmvpTmvpbmvprmvp/mvqDmvqXmvqbmvqfmvqjmvq7mvq/mvrDmvrXmvrbmvrzmv4Xmv4fmv4jmv4pcIl0sXG5bXCI4ZmM5YTFcIixcIua/mua/nua/qOa/qea/sOa/tea/uea/vOa/veeAgOeAheeAhueAh+eAjeeAl+eAoOeAo+eAr+eAtOeAt+eAueeAvOeBg+eBhOeBiOeBieeBiueBi+eBlOeBleeBneeBnueBjueBpOeBpeeBrOeBrueBteeBtueBvueCgeeCheeChueClFwiLDQsXCLngpvngqTngqvngrDngrHngrTngrfng4rng5Hng5Png5Tng5Xng5bng5jng5zng6Tng7rnhINcIiw0LFwi54SL54SM54SP54Se54Sg54Sr54St54Sv54Sw54Sx54S454WB54WF54WG54WH54WK54WL54WQ54WS54WX54Wa54Wc54We54WgXCJdLFxuW1wiOGZjYWExXCIsXCLnhajnhbnnhoDnhoXnhofnhoznhpLnhprnhpvnhqDnhqLnhq/nhrDnhrLnhrPnhrrnhr/nh4Dnh4Hnh4Tnh4vnh4znh5Pnh5bnh5nnh5rnh5znh7jnh77niIDniIfniIjniInniJPniJfniJrniJ3niJ/niKTniKvniK/niLTniLjniLnniYHniYLniYPniYXniY7niY/niZDniZPniZXniZbniZrniZzniZ7niaDniaPniajniavnia7nia/nibHnibfnibjnibvnibznib/nioTnionnio3nio7nipPnipvniqjniq3niq7nirHnirTnir7ni4Hni4fni4nni4zni5Xni5bni5jni5/ni6Xni7Pni7Tni7rni7tcIl0sXG5bXCI4ZmNiYTFcIixcIueLvueMgueMhOeMheeMh+eMi+eMjeeMkueMk+eMmOeMmeeMnueMoueMpOeMp+eMqOeMrOeMseeMsueMteeMuueMu+eMveeNg+eNjeeNkOeNkueNlueNmOeNneeNnueNn+eNoOeNpueNp+eNqeeNq+eNrOeNrueNr+eNseeNt+eNueeNvOeOgOeOgeeOg+eOheeOhueOjueOkOeOk+eOleeOl+eOmOeOnOeOnueOn+eOoOeOoueOpeeOpueOqueOq+eOreeOteeOt+eOueeOvOeOveeOv+ePheePhuePieePi+ePjOePj+ePkuePk+ePluePmeePneePoeePo+ePpuePp+ePqeePtOePteePt+ePueePuuePu+ePvVwiXSxcbltcIjhmY2NhMVwiLFwi54+/55CA55CB55CE55CH55CK55CR55Ca55Cb55Ck55Cm55CoXCIsOSxcIueQueeRgOeRg+eRhOeRhueRh+eRi+eRjeeRkeeRkueRl+eRneeRoueRpueRp+eRqOeRq+eRreeRrueRseeRsueSgOeSgeeSheeShueSh+eSieeSj+eSkOeSkeeSkueSmOeSmeeSmueSnOeSn+eSoOeSoeeSo+eSpueSqOeSqeeSqueSq+eSrueSr+eSseeSsueSteeSueeSu+eSv+eTiOeTieeTjOeTkOeTk+eTmOeTmueTm+eTnueTn+eTpOeTqOeTqueTq+eTr+eTtOeTuueTu+eTvOeTv+eUhlwiXSxcbltcIjhmY2RhMVwiLFwi55SS55SW55SX55Sg55Sh55Sk55Sn55Sp55Sq55Sv55S255S555S955S+55S/55WA55WD55WH55WI55WO55WQ55WS55WX55We55Wf55Wh55Wv55Wx55W5XCIsNSxcIueWgeeWheeWkOeWkueWk+eWleeWmeeWnOeWoueWpOeWtOeWuueWv+eXgOeXgeeXhOeXhueXjOeXjueXj+eXl+eXnOeXn+eXoOeXoeeXpOeXp+eXrOeXrueXr+eXseeXueeYgOeYgueYg+eYhOeYh+eYiOeYiueYjOeYj+eYkueYk+eYleeYlueYmeeYm+eYnOeYneeYnueYo+eYpeeYpueYqeeYreeYsueYs+eYteeYuOeYuVwiXSxcbltcIjhmY2VhMVwiLFwi55i655i855mK55mA55mB55mD55mE55mF55mJ55mL55mV55mZ55mf55mk55ml55mt55mu55mv55mx55m055qB55qF55qM55qN55qV55qb55qc55qd55qf55qg55qiXCIsNixcIueaqueareeaveebgeebheebieebi+ebjOebjueblOebmeeboOebpuebqOebrOebsOebseebtuebueebvOecgOechueciuecjueckueclOecleecl+ecmeecmuecnOecouecqOecreecruecr+ectOecteectuecueecveecvuedguedheedhuediuedjeedjuedj+edkuedluedl+ednOednuedn+edoOedolwiXSxcbltcIjhmY2ZhMVwiLFwi552k552n552q552s552w552y552z552055265529556A556E556M556N556U556V556W556a556f556i556n556q556u556v556x5561556+55+D55+J55+R55+S55+V55+Z55+e55+f55+g55+k55+m55+q55+s55+w55+x55+055+455+756CF56CG56CJ56CN56CO56CR56Cd56Ch56Ci56Cj56Ct56Cu56Cw56C156C356GD56GE56GH56GI56GM56GO56GS56Gc56Ge56Gg56Gh56Gj56Gk56Go56Gq56Gu56G656G+56KK56KP56KU56KY56Kh56Kd56Ke56Kf56Kk56Ko56Ks56Kt56Kw56Kx56Ky56KzXCJdLFxuW1wiOGZkMGExXCIsXCLnorvnor3nor/no4fno4jno4nno4zno47no5Lno5Pno5Xno5bno6Tno5vno5/no6Dno6Hno6bno6rno7Lno7PnpIDno7bno7fno7rno7vno7/npIbnpIznpJDnpJrnpJznpJ7npJ/npKDnpKXnpKfnpKnnpK3npLHnpLTnpLXnpLvnpL3npL/npYTnpYXnpYbnpYrnpYvnpY/npZHnpZTnpZjnpZvnpZznpafnpannpavnpbLnpbnnpbvnpbznpb7npovnpoznppHnppPnppTnppXnppbnppjnppvnppznpqHnpqjnpqnnpqvnpq/nprHnprTnprjnprvnp4Lnp4Tnp4fnp4jnp4rnp4/np5Tnp5bnp5rnp53np55cIl0sXG5bXCI4ZmQxYTFcIixcIuenoOenouenpeenquenq+enreenseenuOenvOeogueog+eoh+eoieeoiueojOeokeeoleeom+eonueooeeop+eoq+eoreeor+eosOeotOeoteeouOeoueeouuephOepheeph+epiOepjOepleepluepmeepnOepneepn+epoOeppeepp+epquepreepteepuOepvueqgOeqgueqheeqhueqiueqi+eqkOeqkeeqlOeqnueqoOeqo+eqrOeqs+eqteequeequ+eqvOerhuerieerjOerjuerkeerm+erqOerqeerq+errOerseertOeru+erveervuesh+eslOesn+eso+esp+esqeesquesq+esreesruesr+essFwiXSxcbltcIjhmZDJhMVwiLFwi56yx56y056y956y/562A562B562H562O562V562g562k562m562p562q562t562v562y562z5623566E566J566O566Q566R566W566b566e566g566l566s566v566w566y56615662566656675668566956+C56+F56+I56+K56+U56+W56+X56+Z56+a56+b56+o56+q56+y56+056+156+456+556+656+856++57CB57CC57CD57CE57CG57CJ57CL57CM57CO57CP57CZ57Cb57Cg57Cl57Cm57Co57Cs57Cx57Cz57C057C257C557C657GG57GK57GV57GR57GS57GT57GZXCIsNV0sXG5bXCI4ZmQzYTFcIixcIuexoeexo+exp+exqeexreexruexsOexsuexueexvOexveeyhueyh+eyj+eylOeynueyoOeypueysOeytueyt+eyuueyu+eyvOeyv+ezhOezh+eziOezieezjeezj+ezk+ezlOezleezl+ezmeezmuezneezpuezqeezq+eztee0g+e0h+e0iOe0iee0j+e0kee0kue0k+e0lue0nee0nue0o+e0pue0que0ree0see0vOe0vee0vue1gOe1gee1h+e1iOe1jee1kee1k+e1l+e1mee1mue1nOe1nee1pee1p+e1que1sOe1uOe1uue1u+e1v+e2gee2gue2g+e2hee2hue2iOe2i+e2jOe2jee2kee2lue2l+e2nVwiXSxcbltcIjhmZDRhMVwiLFwi57ae57am57an57aq57az57a257a357a557eCXCIsNCxcIue3jOe3jee3jue3l+e3mee4gOe3oue3pee3pue3que3q+e3ree3see3tee3tue3uee3uue4iOe4kOe4kee4lee4l+e4nOe4nee4oOe4p+e4qOe4rOe4ree4r+e4s+e4tue4v+e5hOe5hee5h+e5jue5kOe5kue5mOe5n+e5oee5oue5pee5q+e5rue5r+e5s+e5uOe5vue6gee6hue6h+e6iue6jee6kee6lee6mOe6mue6nee6nue8vOe8u+e8vee8vue8v+e9g+e9hOe9h+e9j+e9kue9k+e9m+e9nOe9nee9oee9o+e9pOe9pee9pue9rVwiXSxcbltcIjhmZDVhMVwiLFwi572x5729572+572/576A576L576N576P576Q576R576W576X576c576h576i576m576q576t57605768576/57+A57+D57+I57+O57+P57+b57+f57+j57+l57+o57+s57+u57+v57+y57+657+957++57+/6ICH6ICI6ICK6ICN6ICO6ICP6ICR6ICT6ICU6ICW6ICd6ICe6ICf6ICg6ICk6ICm6ICs6ICu6ICw6IC06IC16IC36IC56IC66IC86IC+6IGA6IGE6IGg6IGk6IGm6IGt6IGx6IG16IKB6IKI6IKO6IKc6IKe6IKm6IKn6IKr6IK46IK56IOI6ION6IOP6IOS6IOU6IOV6IOX6IOY6IOg6IOt6IOuXCJdLFxuW1wiOGZkNmExXCIsXCLog7Dog7Log7Pog7bog7nog7rog77ohIPohIvohJbohJfohJjohJzohJ7ohKDohKTohKfohKzohLDohLXohLrohLzohYXohYfohYrohYzohZLohZfohaDohaHohafohajohanoha3oha/ohbfohoHohpDohoTohoXohobohovoho7ohpbohpjohpvohp7ohqLohq7ohrLohrTohrvoh4voh4Poh4Xoh4roh47oh4/oh5Xoh5foh5voh53oh57oh6Hoh6Toh6voh6zoh7Doh7Hoh7Loh7Xoh7boh7joh7noh73oh7/oiIDoiIPoiI/oiJPoiJToiJnoiJroiJ3oiKHoiKLoiKjoiLLoiLToiLroiYPoiYToiYXoiYZcIl0sXG5bXCI4ZmQ3YTFcIixcIuiJi+iJjuiJj+iJkeiJluiJnOiJoOiJo+iJp+iJreiJtOiJu+iJveiJv+iKgOiKgeiKg+iKhOiKh+iKieiKiuiKjuiKkeiKlOiKluiKmOiKmuiKm+iKoOiKoeiKo+iKpOiKp+iKqOiKqeiKquiKruiKsOiKsuiKtOiKt+iKuuiKvOiKvuiKv+iLhuiLkOiLleiLmuiLoOiLouiLpOiLqOiLquiLreiLr+iLtuiLt+iLveiLvuiMgOiMgeiMh+iMiOiMiuiMi+iNlOiMm+iMneiMnuiMn+iMoeiMouiMrOiMreiMruiMsOiMs+iMt+iMuuiMvOiMveiNguiNg+iNhOiNh+iNjeiNjuiNkeiNleiNluiNl+iNsOiNuFwiXSxcbltcIjhmZDhhMVwiLFwi6I296I2/6I6A6I6C6I6E6I6G6I6N6I6S6I6U6I6V6I6Y6I6Z6I6b6I6c6I6d6I6m6I6n6I6p6I6s6I6+6I6/6I+A6I+H6I+J6I+P6I+Q6I+R6I+U6I+d6I2T6I+o6I+q6I+26I+46I+56I+86JCB6JCG6JCK6JCP6JCR6JCV6JCZ6I6t6JCv6JC56JGF6JGH6JGI6JGK6JGN6JGP6JGR6JGS6JGW6JGY6JGZ6JGa6JGc6JGg6JGk6JGl6JGn6JGq6JGw6JGz6JG06JG26JG46JG86JG96JKB6JKF6JKS6JKT6JKV6JKe6JKm6JKo6JKp6JKq6JKv6JKx6JK06JK66JK96JK+6JOA6JOC6JOH6JOI6JOM6JOP6JOTXCJdLFxuW1wiOGZkOWExXCIsXCLok5zok6fok6rok6/ok7Dok7Hok7Lok7folLLok7rok7vok73olILolIPolIfolIzolI7olJDolJzolJ7olKLolKPolKTolKXolKfolKrolKvolK/olLPolLTolLbolL/olYbolY9cIiw0LFwi6JWW6JWZ6JWcXCIsNixcIuiVpOiVq+iVr+iVueiVuuiVu+iVveiVv+iWgeiWheiWhuiWieiWi+iWjOiWj+iWk+iWmOiWneiWn+iWoOiWouiWpeiWp+iWtOiWtuiWt+iWuOiWvOiWveiWvuiWv+iXguiXh+iXiuiXi+iXjuiWreiXmOiXmuiXn+iXoOiXpuiXqOiXreiXs+iXtuiXvFwiXSxcbltcIjhmZGFhMVwiLFwi6Je/6JiA6JiE6JiF6JiN6JiO6JiQ6JiR6JiS6JiY6JiZ6Jib6Jie6Jih6Jin6Jip6Ji26Ji46Ji66Ji86Ji96JmA6JmC6JmG6JmS6JmT6JmW6JmX6JmY6JmZ6Jmd6JmgXCIsNCxcIuiZqeiZrOiZr+iZteiZtuiZt+iZuuiajeiakeialuiamOiamuianOiaoeiapuiap+iaqOiareiaseias+iatOiateiat+iauOiaueiav+ibgOibgeibg+ibheibkeibkuibleibl+ibmuibnOiboOibo+ibpeibp+iaiOibuuibvOibveichOicheich+ici+icjuicj+ickOick+iclOicmeicnuicn+icoeico1wiXSxcbltcIjhmZGJhMVwiLFwi6Jyo6Jyu6Jyv6Jyx6Jyy6Jy56Jy66Jy86Jy96Jy+6J2A6J2D6J2F6J2N6J2Y6J2d6J2h6J2k6J2l6J2v6J2x6J2y6J276J6DXCIsNixcIuiei+iejOiekOiek+ieleiel+iemOiemeienuieoOieo+iep+ierOiereieruieseieteievuiev+ifgeifiOifieifiuifjuifleifluifmeifmuifnOifn+ifouifo+ifpOifquifq+ifreifseifs+ifuOifuuifv+iggeigg+ighuigieigiuigi+igkOigmeigkuigk+iglOigmOigmuigm+ignOignuign+igqOigreigruigsOigsuigtVwiXSxcbltcIjhmZGNhMVwiLFwi6KC66KC86KGB6KGD6KGF6KGI6KGJ6KGK6KGL6KGO6KGR6KGV6KGW6KGY6KGa6KGc6KGf6KGg6KGk6KGp6KGx6KG56KG76KKA6KKY6KKa6KKb6KKc6KKf6KKg6KKo6KKq6KK66KK96KK+6KOA6KOKXCIsNCxcIuijkeijkuijk+ijm+ijnuijp+ijr+ijsOijseijteijt+ikgeikhuikjeikjuikj+ikleikluikmOikmeikmuiknOikoOikpuikp+ikqOiksOikseiksuikteikueikuuikvuilgOilguilheilhuilieilj+ilkuill+ilmuilm+ilnOiloeilouilo+ilq+ilruilsOils+ilteilulwiXSxcbltcIjhmZGRhMVwiLFwi6KW76KW86KW96KaJ6KaN6KaQ6KaU6KaV6Kab6Kac6Kaf6Kag6Kal6Kaw6Ka06Ka16Ka26Ka36Ka86KeUXCIsNCxcIuinpeinqeinq+inreinseins+intuinueinveinv+iohOioheioh+ioj+iokeiokuiolOioleionuiooOioouiopOiopuioq+iorOior+ioteiot+ioveiovuipgOipg+ipheiph+ipieipjeipjuipk+ipluipl+ipmOipnOipneipoeippeipp+ipteiptuipt+ipueipuuipu+ipvuipv+iqgOiqg+iqhuiqi+iqj+iqkOiqkuiqluiql+iqmeiqn+iqp+iqqeiqruiqr+iqs1wiXSxcbltcIjhmZGVhMVwiLFwi6Kq26Kq36Kq76Kq+6KuD6KuG6KuI6KuJ6KuK6KuR6KuT6KuU6KuV6KuX6Kud6Kuf6Kus6Kuw6Ku06Ku16Ku26Ku86Ku/6KyF6KyG6KyL6KyR6Kyc6Kye6Kyf6KyK6Kyt6Kyw6Ky36Ky86K2CXCIsNCxcIuitiOitkuitk+itlOitmeitjeitnuito+itreittuituOitueitvOitvuiugeiuhOiuheiui+iujeiuj+iulOiuleiunOiunuiun+iwuOiwueiwveiwvuixheixh+ixieixi+ixj+ixkeixk+ixlOixl+ixmOixm+ixneixmeixo+ixpOixpuixqOixqeixreixs+ixteixtuixu+ixvuiyhlwiXSxcbltcIjhmZGZhMVwiLFwi6LKH6LKL6LKQ6LKS6LKT6LKZ6LKb6LKc6LKk6LK56LK66LOF6LOG6LOJ6LOL6LOP6LOW6LOV6LOZ6LOd6LOh6LOo6LOs6LOv6LOw6LOy6LO16LO36LO46LO+6LO/6LSB6LSD6LSJ6LSS6LSX6LSb6LWl6LWp6LWs6LWu6LW/6LaC6LaE6LaI6LaN6LaQ6LaR6LaV6Lae6Laf6Lag6Lam6Lar6Las6Lav6Lay6La16La36La56La76LeA6LeF6LeG6LeH6LeI6LeK6LeO6LeR6LeU6LeV6LeX6LeZ6Lek6Lel6Len6Les6Lew6La86Lex6Ley6Le06Le96LiB6LiE6LiF6LiG6LiL6LiR6LiU6LiW6Lig6Lih6LiiXCJdLFxuW1wiOGZlMGExXCIsXCLouKPouKbouKfouLHouLPouLbouLfouLjouLnouL3ouYDouYHouYvouY3ouY7ouY/ouZTouZvouZzouZ3ouZ7ouaHouaLouanouazoua3oua/oubDoubHoubnoubroubvouoLouoPouonoupDoupLoupXouproupvoup3oup7ouqLouqfouqnouq3ouq7ourPourXourrourvou4Dou4Hou4Pou4Tou4fou4/ou5Hou5Tou5zou6jou67ou7Dou7Hou7fou7nou7rou63ovIDovILovIfovIjovI/ovJDovJbovJfovJjovJ7ovKDovKHovKPovKXovKfovKjovKzovK3ovK7ovLTovLXovLbovLfovLrovYDovYFcIl0sXG5bXCI4ZmUxYTFcIixcIui9g+i9h+i9j+i9kVwiLDQsXCLovZjovZ3ovZ7ovaXovp3ovqDovqHovqTovqXovqbovrXovrbovrjovr7ov4Dov4Hov4bov4rov4vov43ov5Dov5Lov5Pov5Xov6Dov6Pov6Tov6jov67ov7Hov7Xov7bov7vov77pgILpgITpgIjpgIzpgJjpgJvpgKjpgKnpgK/pgKrpgKzpgK3pgLPpgLTpgLfpgL/pgYPpgYTpgYzpgZvpgZ3pgaLpgabpgafpgazpgbDpgbTpgbnpgoXpgojpgovpgozpgo7pgpDpgpXpgpfpgpjpgpnpgpvpgqDpgqHpgqLpgqXpgrDpgrLpgrPpgrTpgrbpgr3pg4zpgr7pg4NcIl0sXG5bXCI4ZmUyYTFcIixcIumDhOmDhemDh+mDiOmDlemDl+mDmOmDmemDnOmDnemDn+mDpemDkumDtumDq+mDr+mDsOmDtOmDvumDv+mEgOmEhOmEhemEhumEiOmEjemEkOmElOmElumEl+mEmOmEmumEnOmEnumEoOmEpemEoumEo+mEp+mEqemErumEr+mEsemEtOmEtumEt+mEuemEuumEvOmEvemFg+mFh+mFiOmFj+mFk+mFl+mFmemFmumFm+mFoemFpOmFp+mFremFtOmFuemFuumFu+mGgemGg+mGhemGhumGiumGjumGkemGk+mGlOmGlemGmOmGnumGoemGpumGqOmGrOmGremGrumGsOmGsemGsumGs+mGtumGu+mGvOmGvemGv1wiXSxcbltcIjhmZTNhMVwiLFwi6YeC6YeD6YeF6YeT6YeU6YeX6YeZ6Yea6Yee6Yek6Yel6Yep6Yeq6YesXCIsNSxcIumHt+mHuemHu+mHvemIgOmIgemIhOmIhemIhumIh+mIiemIiumIjOmIkOmIkumIk+mIlumImOmInOmInemIo+mIpOmIpemIpumIqOmIrumIr+mIsOmIs+mItemItumIuOmIuemIuumIvOmIvumJgOmJgumJg+mJhumJh+mJiumJjemJjumJj+mJkemJmOmJmemJnOmJnemJoOmJoemJpemJp+mJqOmJqemJrumJr+mJsOmJtVwiLDQsXCLpibvpibzpib3pib/piojpionpiorpio3pio7pipLpipdcIl0sXG5bXCI4ZmU0YTFcIixcIumKmemKn+mKoOmKpOmKpemKp+mKqOmKq+mKr+mKsumKtumKuOmKuumKu+mKvOmKvemKv1wiLDQsXCLpi4Xpi4bpi4fpi4jpi4vpi4zpi43pi47pi5Dpi5Ppi5Xpi5fpi5jpi5npi5zpi53pi5/pi6Dpi6Hpi6Ppi6Xpi6fpi6jpi6zpi67pi7Dpi7npi7vpi7/pjIDpjILpjIjpjI3pjJHpjJTpjJXpjJzpjJ3pjJ7pjJ/pjKHpjKTpjKXpjKfpjKnpjKrpjLPpjLTpjLbpjLfpjYfpjYjpjYnpjZDpjZHpjZLpjZXpjZfpjZjpjZrpjZ7pjaTpjaXpjafpjanpjarpja3pja/pjbDpjbHpjbPpjbTpjbZcIl0sXG5bXCI4ZmU1YTFcIixcIumNuumNvemNv+mOgOmOgemOgumOiOmOiumOi+mOjemOj+mOkumOlemOmOmOm+mOnumOoemOo+mOpOmOpumOqOmOq+mOtOmOtemOtumOuumOqemPgemPhOmPhemPhumPh+mPiVwiLDQsXCLpj5Ppj5npj5zpj57pj5/pj6Lpj6bpj6fpj7npj7fpj7jpj7rpj7vpj73pkIHpkILpkITpkIjpkInpkI3pkI7pkI/pkJXpkJbpkJfpkJ/pkK7pkK/pkLHpkLLpkLPpkLTpkLvpkL/pkL3pkYPpkYXpkYjpkYrpkYzpkZXpkZnpkZzpkZ/pkaHpkaPpkajpkavpka3pka7pka/pkbHpkbLpkoTpkoPplbjplblcIl0sXG5bXCI4ZmU2YTFcIixcIumVvumWhOmWiOmWjOmWjemWjumWnemWnumWn+mWoemWpumWqemWq+mWrOmWtOmWtumWuumWvemWv+mXhumXiOmXiemXi+mXkOmXkemXkumXk+mXmemXmumXnemXnumXn+mXoOmXpOmXpumYnemYnumYoumYpOmYpemYpumYrOmYsemYs+mYt+mYuOmYuemYuumYvOmYvemZgemZkumZlOmZlumZl+mZmOmZoemZrumZtOmZu+mZvOmZvumZv+magemagumag+mahOmaiemakemalumamumaneman+mapOmapemapumaqemarumar+mas+mauumbiumbkuW2sumbmOmbmumbnembnumbn+mbqembr+mbsembuumcglwiXSxcbltcIjhmZTdhMVwiLFwi6ZyD6ZyF6ZyJ6Zya6Zyb6Zyd6Zyh6Zyi6Zyj6Zyo6Zyx6Zyz6Z2B6Z2D6Z2K6Z2O6Z2P6Z2V6Z2X6Z2Y6Z2a6Z2b6Z2j6Z2n6Z2q6Z2u6Z2z6Z226Z236Z246Z276Z296Z2/6Z6A6Z6J6Z6V6Z6W6Z6X6Z6Z6Z6a6Z6e6Z6f6Z6i6Z6s6Z6u6Z6x6Z6y6Z616Z626Z646Z656Z666Z686Z6+6Z6/6Z+B6Z+E6Z+F6Z+H6Z+J6Z+K6Z+M6Z+N6Z+O6Z+Q6Z+R6Z+U6Z+X6Z+Y6Z+Z6Z+d6Z+e6Z+g6Z+b6Z+h6Z+k6Z+v6Z+x6Z+06Z+36Z+46Z+66aCH6aCK6aCZ6aCN6aCO6aCU6aCW6aCc6aCe6aCg6aCj6aCmXCJdLFxuW1wiOGZlOGExXCIsXCLpoKvpoK7poK/poLDpoLLpoLPpoLXpoKXpoL7poYTpoYfpoYrpoZHpoZLpoZPpoZbpoZfpoZnpoZrpoaLpoaPpoaXpoabpoarpoazpoqvpoq3poq7porDporTporfporjporrporvpor/po4Lpo4Xpo4jpo4zpo6Hpo6Ppo6Xpo6bpo6fpo6rpo7Ppo7bppILppIfppIjppJHppJXppJbppJfppJrppJvppJzppJ/ppKLppKbppKfppKvppLFcIiw0LFwi6aS56aS66aS76aS86aWA6aWB6aWG6aWH6aWI6aWN6aWO6aWU6aWY6aWZ6aWb6aWc6aWe6aWf6aWg6aab6aad6aaf6aam6aaw6aax6aay6aa1XCJdLFxuW1wiOGZlOWExXCIsXCLpprnpprrppr3ppr/pp4Ppp4npp5Ppp5Tpp5npp5rpp5zpp57pp6fpp6rpp6vpp6zpp7Dpp7Tpp7Xpp7npp73pp77pqILpqIPpqITpqIvpqIzpqJDpqJHpqJbpqJ7pqKDpqKLpqKPpqKTpqKfpqK3pqK7pqLPpqLXpqLbpqLjpqYfpqYHpqYTpqYrpqYvpqYzpqY7pqZHpqZTpqZbpqZ3pqqrpqqzpqq7pqq/pqrLpqrTpqrXpqrbpqrnpqrvpqr7pqr/pq4Hpq4Ppq4bpq4jpq47pq5Dpq5Lpq5Xpq5bpq5fpq5vpq5zpq6Dpq6Tpq6Xpq6fpq6npq6zpq7Lpq7Ppq7Xpq7npq7rpq73pq79cIiw0XSxcbltcIjhmZWFhMVwiLFwi6ayE6ayF6ayI6ayJ6ayL6ayM6ayN6ayO6ayQ6ayS6ayW6ayZ6ayb6ayc6ayg6aym6ayr6ayt6ayz6ay06ay16ay36ay56ay66ay96a2I6a2L6a2M6a2V6a2W6a2X6a2b6a2e6a2h6a2j6a2l6a2m6a2o6a2qXCIsNCxcIumts+mttemtt+mtuOmtuemtv+mugOmuhOmuhemuhumuh+muiemuiumui+mujemuj+mukOmulOmumumunemunumupumup+muqemurOmusOmusemusumut+muuOmuu+muvOmuvumuv+mvgemvh+mviOmvjumvkOmvl+mvmOmvnemvn+mvpemvp+mvqumvq+mvr+mvs+mvt+mvuFwiXSxcbltcIjhmZWJhMVwiLFwi6a+56a+66a+96a+/6bCA6bCC6bCL6bCP6bCR6bCW6bCY6bCZ6bCa6bCc6bCe6bCi6bCj6bCmXCIsNCxcIumwsemwtemwtumwt+mwvemxgemxg+mxhOmxhemxiemxiumxjumxj+mxkOmxk+mxlOmxlumxmOmxm+mxnemxnumxn+mxo+mxqemxqumxnOmxq+mxqOmxrumxsOmxsumxtemxt+mxu+mzpumzsumzt+mzuem0i+m0gum0kem0l+m0mOm0nOm0nem0num0r+m0sOm0sum0s+m0tOm0uum0vOm1hem0vem1gum1g+m1h+m1ium1k+m1lOm1n+m1o+m1oum1pem1qem1qum1q+m1sOm1tum1t+m1u1wiXSxcbltcIjhmZWNhMVwiLFwi6bW86bW+6baD6baE6baG6baK6baN6baO6baS6baT6baV6baW6baX6baY6bah6baq6bas6bau6bax6ba16ba56ba86ba/6beD6beH6beJ6beK6beU6beV6beW6beX6bea6bee6bef6beg6bel6ben6bep6ber6beu6bew6bez6be06be+6biK6biC6biH6biO6biQ6biR6biS6biV6biW6biZ6bic6bid6bm66bm76bm86bqA6bqC6bqD6bqE6bqF6bqH6bqO6bqP6bqW6bqY6bqb6bqe6bqk6bqo6bqs6bqu6bqv6bqw6bqz6bq06bq16buG6buI6buL6buV6buf6buk6bun6bus6but6buu6buw6bux6buy6bu1XCJdLFxuW1wiOGZlZGExXCIsXCLpu7jpu7/pvILpvIPpvInpvI/pvJDpvJHpvJLpvJTpvJbpvJfpvJnpvJrpvJvpvJ/pvKLpvKbpvKrpvKvpvK/pvLHpvLLpvLTpvLfpvLnpvLrpvLzpvL3pvL/pvYHpvYNcIiw0LFwi6b2T6b2V6b2W6b2X6b2Y6b2a6b2d6b2e6b2o6b2p6b2tXCIsNCxcIum9s+m9tem9uum9vem+j+m+kOm+kem+kum+lOm+lum+l+m+num+oem+oum+o+m+pVwiXVxuXVxuIiwibW9kdWxlLmV4cG9ydHM9e1widUNoYXJzXCI6WzEyOCwxNjUsMTY5LDE3OCwxODQsMjE2LDIyNiwyMzUsMjM4LDI0NCwyNDgsMjUxLDI1MywyNTgsMjc2LDI4NCwzMDAsMzI1LDMyOSwzMzQsMzY0LDQ2Myw0NjUsNDY3LDQ2OSw0NzEsNDczLDQ3NSw0NzcsNTA2LDU5NCw2MTAsNzEyLDcxNiw3MzAsOTMwLDkzOCw5NjIsOTcwLDEwMjYsMTEwNCwxMTA2LDgyMDksODIxNSw4MjE4LDgyMjIsODIzMSw4MjQxLDgyNDQsODI0Niw4MjUyLDgzNjUsODQ1Miw4NDU0LDg0NTgsODQ3MSw4NDgyLDg1NTYsODU3MCw4NTk2LDg2MDIsODcxMyw4NzIwLDg3MjIsODcyNiw4NzMxLDg3MzcsODc0MCw4NzQyLDg3NDgsODc1MSw4NzYwLDg3NjYsODc3Nyw4NzgxLDg3ODcsODgwMiw4ODA4LDg4MTYsODg1NCw4ODU4LDg4NzAsODg5Niw4OTc5LDkzMjIsOTM3Miw5NTQ4LDk1ODgsOTYxNiw5NjIyLDk2MzQsOTY1Miw5NjYyLDk2NzIsOTY3Niw5NjgwLDk3MDIsOTczNSw5NzM4LDk3OTMsOTc5NSwxMTkwNiwxMTkwOSwxMTkxMywxMTkxNywxMTkyOCwxMTk0NCwxMTk0NywxMTk1MSwxMTk1NiwxMTk2MCwxMTk2NCwxMTk3OSwxMjI4NCwxMjI5MiwxMjMxMiwxMjMxOSwxMjMzMCwxMjM1MSwxMjQzNiwxMjQ0NywxMjUzNSwxMjU0MywxMjU4NiwxMjg0MiwxMjg1MCwxMjk2NCwxMzIwMCwxMzIxNSwxMzIxOCwxMzI1MywxMzI2MywxMzI2NywxMzI3MCwxMzM4NCwxMzQyOCwxMzcyNywxMzgzOSwxMzg1MSwxNDYxNywxNDcwMywxNDgwMSwxNDgxNiwxNDk2NCwxNTE4MywxNTQ3MSwxNTU4NSwxNjQ3MSwxNjczNiwxNzIwOCwxNzMyNSwxNzMzMCwxNzM3NCwxNzYyMywxNzk5NywxODAxOCwxODIxMiwxODIxOCwxODMwMSwxODMxOCwxODc2MCwxODgxMSwxODgxNCwxODgyMCwxODgyMywxODg0NCwxODg0OCwxODg3MiwxOTU3NiwxOTYyMCwxOTczOCwxOTg4Nyw0MDg3MCw1OTI0NCw1OTMzNiw1OTM2Nyw1OTQxMyw1OTQxNyw1OTQyMyw1OTQzMSw1OTQzNyw1OTQ0Myw1OTQ1Miw1OTQ2MCw1OTQ3OCw1OTQ5Myw2Mzc4OSw2Mzg2Niw2Mzg5NCw2Mzk3Niw2Mzk4Niw2NDAxNiw2NDAxOCw2NDAyMSw2NDAyNSw2NDAzNCw2NDAzNyw2NDA0Miw2NTA3NCw2NTA5Myw2NTEwNyw2NTExMiw2NTEyNyw2NTEzMiw2NTM3NSw2NTUxMCw2NTUzNl0sXCJnYkNoYXJzXCI6WzAsMzYsMzgsNDUsNTAsODEsODksOTUsOTYsMTAwLDEwMywxMDQsMTA1LDEwOSwxMjYsMTMzLDE0OCwxNzIsMTc1LDE3OSwyMDgsMzA2LDMwNywzMDgsMzA5LDMxMCwzMTEsMzEyLDMxMywzNDEsNDI4LDQ0Myw1NDQsNTQ1LDU1OCw3NDEsNzQyLDc0OSw3NTAsODA1LDgxOSw4MjAsNzkyMiw3OTI0LDc5MjUsNzkyNyw3OTM0LDc5NDMsNzk0NCw3OTQ1LDc5NTAsODA2Miw4MTQ4LDgxNDksODE1Miw4MTY0LDgxNzQsODIzNiw4MjQwLDgyNjIsODI2NCw4Mzc0LDgzODAsODM4MSw4Mzg0LDgzODgsODM5MCw4MzkyLDgzOTMsODM5NCw4Mzk2LDg0MDEsODQwNiw4NDE2LDg0MTksODQyNCw4NDM3LDg0MzksODQ0NSw4NDgyLDg0ODUsODQ5Niw4NTIxLDg2MDMsODkzNiw4OTQ2LDkwNDYsOTA1MCw5MDYzLDkwNjYsOTA3Niw5MDkyLDkxMDAsOTEwOCw5MTExLDkxMTMsOTEzMSw5MTYyLDkxNjQsOTIxOCw5MjE5LDExMzI5LDExMzMxLDExMzM0LDExMzM2LDExMzQ2LDExMzYxLDExMzYzLDExMzY2LDExMzcwLDExMzcyLDExMzc1LDExMzg5LDExNjgyLDExNjg2LDExNjg3LDExNjkyLDExNjk0LDExNzE0LDExNzE2LDExNzIzLDExNzI1LDExNzMwLDExNzM2LDExOTgyLDExOTg5LDEyMTAyLDEyMzM2LDEyMzQ4LDEyMzUwLDEyMzg0LDEyMzkzLDEyMzk1LDEyMzk3LDEyNTEwLDEyNTUzLDEyODUxLDEyOTYyLDEyOTczLDEzNzM4LDEzODIzLDEzOTE5LDEzOTMzLDE0MDgwLDE0Mjk4LDE0NTg1LDE0Njk4LDE1NTgzLDE1ODQ3LDE2MzE4LDE2NDM0LDE2NDM4LDE2NDgxLDE2NzI5LDE3MTAyLDE3MTIyLDE3MzE1LDE3MzIwLDE3NDAyLDE3NDE4LDE3ODU5LDE3OTA5LDE3OTExLDE3OTE1LDE3OTE2LDE3OTM2LDE3OTM5LDE3OTYxLDE4NjY0LDE4NzAzLDE4ODE0LDE4OTYyLDE5MDQzLDMzNDY5LDMzNDcwLDMzNDcxLDMzNDg0LDMzNDg1LDMzNDkwLDMzNDk3LDMzNTAxLDMzNTA1LDMzNTEzLDMzNTIwLDMzNTM2LDMzNTUwLDM3ODQ1LDM3OTIxLDM3OTQ4LDM4MDI5LDM4MDM4LDM4MDY0LDM4MDY1LDM4MDY2LDM4MDY5LDM4MDc1LDM4MDc2LDM4MDc4LDM5MTA4LDM5MTA5LDM5MTEzLDM5MTE0LDM5MTE1LDM5MTE2LDM5MjY1LDM5Mzk0LDE4OTAwMF19IiwibW9kdWxlLmV4cG9ydHM9W1xuW1wiYTE0MFwiLFwi7pOGXCIsNjJdLFxuW1wiYTE4MFwiLFwi7pSFXCIsMzJdLFxuW1wiYTI0MFwiLFwi7pSmXCIsNjJdLFxuW1wiYTI4MFwiLFwi7pWlXCIsMzJdLFxuW1wiYTJhYlwiLFwi7p2mXCIsNV0sXG5bXCJhMmUzXCIsXCLigqzuna1cIl0sXG5bXCJhMmVmXCIsXCLuna7una9cIl0sXG5bXCJhMmZkXCIsXCLunbDunbFcIl0sXG5bXCJhMzQwXCIsXCLuloZcIiw2Ml0sXG5bXCJhMzgwXCIsXCLul4VcIiwzMSxcIuOAgFwiXSxcbltcImE0NDBcIixcIu6XplwiLDYyXSxcbltcImE0ODBcIixcIu6YpVwiLDMyXSxcbltcImE0ZjRcIixcIu6dslwiLDEwXSxcbltcImE1NDBcIixcIu6ZhlwiLDYyXSxcbltcImE1ODBcIixcIu6ahVwiLDMyXSxcbltcImE1ZjdcIixcIu6dvVwiLDddLFxuW1wiYTY0MFwiLFwi7pqmXCIsNjJdLFxuW1wiYTY4MFwiLFwi7pulXCIsMzJdLFxuW1wiYTZiOVwiLFwi7p6FXCIsN10sXG5bXCJhNmQ5XCIsXCLuno1cIiw2XSxcbltcImE2ZWNcIixcIu6elO6elVwiXSxcbltcImE2ZjNcIixcIu6ellwiXSxcbltcImE2ZjZcIixcIu6el1wiLDhdLFxuW1wiYTc0MFwiLFwi7pyGXCIsNjJdLFxuW1wiYTc4MFwiLFwi7p2FXCIsMzJdLFxuW1wiYTdjMlwiLFwi7p6gXCIsMTRdLFxuW1wiYTdmMlwiLFwi7p6vXCIsMTJdLFxuW1wiYTg5NlwiLFwi7p68XCIsMTBdLFxuW1wiYThiY1wiLFwi7p+HXCJdLFxuW1wiYThiZlwiLFwix7lcIl0sXG5bXCJhOGMxXCIsXCLun4nun4run4vun4xcIl0sXG5bXCJhOGVhXCIsXCLun41cIiwyMF0sXG5bXCJhOTU4XCIsXCLun6JcIl0sXG5bXCJhOTViXCIsXCLun6NcIl0sXG5bXCJhOTVkXCIsXCLun6Tun6Xun6ZcIl0sXG5bXCJhOTg5XCIsXCLjgL7iv7BcIiwxMV0sXG5bXCJhOTk3XCIsXCLun7RcIiwxMl0sXG5bXCJhOWYwXCIsXCLuoIFcIiwxNF0sXG5bXCJhYWExXCIsXCLugIBcIiw5M10sXG5bXCJhYmExXCIsXCLugZ5cIiw5M10sXG5bXCJhY2ExXCIsXCLugrxcIiw5M10sXG5bXCJhZGExXCIsXCLuhJpcIiw5M10sXG5bXCJhZWExXCIsXCLuhbhcIiw5M10sXG5bXCJhZmExXCIsXCLuh5ZcIiw5M10sXG5bXCJkN2ZhXCIsXCLuoJBcIiw0XSxcbltcImY4YTFcIixcIu6ItFwiLDkzXSxcbltcImY5YTFcIixcIu6KklwiLDkzXSxcbltcImZhYTFcIixcIu6LsFwiLDkzXSxcbltcImZiYTFcIixcIu6NjlwiLDkzXSxcbltcImZjYTFcIixcIu6OrFwiLDkzXSxcbltcImZkYTFcIixcIu6QilwiLDkzXSxcbltcImZlNTBcIixcIuK6ge6glu6gl+6gmOK6hOORs+ORh+K6iOK6i+6gnuOWnuOYmuOYjuK6jOK6l+OlruOkmO6gpuOnj+Onn+Ops+OnkO6gq+6grOOtjuOxruOzoOK6p+6gse6gsuK6quSBluSFn+K6ruSMt+K6s+K6tuK6t+6gu+SOseSOrOK6u+SPneSTluSZoeSZjO6hg1wiXSxcbltcImZlODBcIixcIuSco+ScqeSdvOSejeK7iuSlh+SluuSlveSmguSmg+SmheSmhuSmn+Smm+Smt+Smtu6hlO6hleSyo+Syn+SyoOSyoeSxt+SyouS0k1wiLDYsXCLktq7uoaTukahcIiw5M11cbl1cbiIsIm1vZHVsZS5leHBvcnRzPVtcbltcIjBcIixcIlxcdTAwMDBcIiwxMjhdLFxuW1wiYTFcIixcIu+9oVwiLDYyXSxcbltcIjgxNDBcIixcIuOAgOOAgeOAgu+8jO+8juODu++8mu+8m++8n++8geOCm+OCnMK0772AwqjvvL7vv6PvvL/jg73jg77jgp3jgp7jgIPku53jgIXjgIbjgIfjg7zigJXigJDvvI/vvLzvvZ7iiKXvvZzigKbigKXigJjigJnigJzigJ3vvIjvvInjgJTjgJXvvLvvvL3vvZvvvZ3jgIhcIiw5LFwi77yL77yNwrHDl1wiXSxcbltcIjgxODBcIixcIsO377yd4omg77yc77ye4omm4omn4oie4oi04pmC4pmAwrDigLLigLPihIPvv6XvvITvv6Dvv6HvvIXvvIPvvIbvvIrvvKDCp+KYhuKYheKXi+KXj+KXjuKXh+KXhuKWoeKWoOKWs+KWsuKWveKWvOKAu+OAkuKGkuKGkOKGkeKGk+OAk1wiXSxcbltcIjgxYjhcIixcIuKIiOKIi+KKhuKKh+KKguKKg+KIquKIqVwiXSxcbltcIjgxYzhcIixcIuKIp+KIqO+/ouKHkuKHlOKIgOKIg1wiXSxcbltcIjgxZGFcIixcIuKIoOKKpeKMkuKIguKIh+KJoeKJkuKJquKJq+KImuKIveKIneKIteKIq+KIrFwiXSxcbltcIjgxZjBcIixcIuKEq+KAsOKZr+KZreKZquKAoOKAocK2XCJdLFxuW1wiODFmY1wiLFwi4pevXCJdLFxuW1wiODI0ZlwiLFwi77yQXCIsOV0sXG5bXCI4MjYwXCIsXCLvvKFcIiwyNV0sXG5bXCI4MjgxXCIsXCLvvYFcIiwyNV0sXG5bXCI4MjlmXCIsXCLjgYFcIiw4Ml0sXG5bXCI4MzQwXCIsXCLjgqFcIiw2Ml0sXG5bXCI4MzgwXCIsXCLjg6BcIiwyMl0sXG5bXCI4MzlmXCIsXCLOkVwiLDE2LFwizqNcIiw2XSxcbltcIjgzYmZcIixcIs6xXCIsMTYsXCLPg1wiLDZdLFxuW1wiODQ0MFwiLFwi0JBcIiw1LFwi0IHQllwiLDI1XSxcbltcIjg0NzBcIixcItCwXCIsNSxcItGR0LZcIiw3XSxcbltcIjg0ODBcIixcItC+XCIsMTddLFxuW1wiODQ5ZlwiLFwi4pSA4pSC4pSM4pSQ4pSY4pSU4pSc4pSs4pSk4pS04pS84pSB4pSD4pSP4pST4pSb4pSX4pSj4pSz4pSr4pS74pWL4pSg4pSv4pSo4pS34pS/4pSd4pSw4pSl4pS44pWCXCJdLFxuW1wiODc0MFwiLFwi4pGgXCIsMTksXCLihaBcIiw5XSxcbltcIjg3NWZcIixcIuONieOMlOOMouONjeOMmOOMp+OMg+OMtuONkeONl+OMjeOMpuOMo+OMq+ONiuOMu+OOnOOOneOOnuOOjuOOj+OPhOOOoVwiXSxcbltcIjg3N2VcIixcIuONu1wiXSxcbltcIjg3ODBcIixcIuOAneOAn+KEluOPjeKEoeOKpFwiLDQsXCLjiLHjiLLjiLnjjb7jjb3jjbziiZLiiaHiiKviiK7iiJHiiJriiqXiiKDiiJ/iir/iiLXiiKniiKpcIl0sXG5bXCI4ODlmXCIsXCLkupzllJblqIPpmL/lk4DmhJvmjKjlp7bpgKLokbXojJznqZDmgqrmj6HmuKXml63okaboiqbpr7XmopPlnKfmlqHmibHlrpvlp5Dombvpo7TntaLntr7pro7miJbnsp/oorflronlurXmjInmmpfmoYjpl4fpno3mnY/ku6XkvIrkvY3kvp3lgYnlm7LlpLflp5TlqIHlsInmg5/mhI/mhbDmmJPmpIXngrrnlY/nlbDnp7vntq3nt6/og4PokI7ooaPorILpgZXpgbrljLvkupXkuqXln5/ogrLpg4Hno6/kuIDlo7HmuqLpgLjnqLLojKjoiovpsK/lhYHljbDlkr3lk6Hlm6Dlp7vlvJXpo7Lmt6vog6TolK1cIl0sXG5bXCI4OTQwXCIsXCLpmaLpmbDpmqDpn7vlkIvlj7Plrofng4/nvr3ov4Lpm6jlja/ptZznqrrkuJHnopPoh7zmuKblmJjllITmrJ3olJrpsLvlp6Xljqnmtabnk5zplo/lmYLkupHpgYvpm7LojY/ppIzlj6HllrblrLDlvbHmmKDmm7PmoITmsLjms7PmtKnnkZvnm4jnqY7poLToi7HooZvoqaDpi63mtrLnlqvnm4rpp4XmgqborIHotorplrLmpo7ljq3lhoZcIl0sXG5bXCI4OTgwXCIsXCLlnJLloLDlpYTlrrTlu7bmgKjmjqnmj7Tmsr/mvJTngo7nhJTnhZnnh5XnjL/nuIHoibboi5HolpfpgaDpiZvptJvloanmlrzmsZrnlKXlh7nlpK7lpaXlvoDlv5zmirzml7rmqKrmrKfmrrTnjovnv4HopZbptKzptI7pu4TlsqHmspbojbvlhITlsYvmhrboh4bmobbniaHkuZnkv7rljbjmganmuKnnqY/pn7PkuIvljJbku67kvZXkvL3kvqHkvbPliqDlj6/lmInlpI/lq4Hlrrblr6Hnp5HmmofmnpzmnrbmrYzmsrPngavnj4Lnpo3npr7nqLznrofoirHoi5vojITojbfoj6/oj5PonaboqrLlmKnosqjov6bpgY7pnJ7omorkv4Tls6jmiJHniZnnlLvoh6Xoir3om77os4Dpm4XppJPpp5Xku4vkvJrop6Plm57loYrlo4rlu7vlv6vmgKrmgpTmgaLmh5DmiJLmi5DmlLlcIl0sXG5bXCI4YTQwXCIsXCLprYHmmabmorDmtbfngbDnlYznmobntbXoiqXon7nplovpmo7osp3lh7Hlir7lpJblkrPlrrPltJbmhajmpoLmtq/noo3ok4vooZfoqbLpjqfpqrjmtazppqjom5nlnqPmn7/om47piI7lioPlmoflkITlu5Pmi6HmkrnmoLzmoLjmrrvnjbLnorrnqavopprop5LotavovIPpg63plqPpmpTpnanlrablsrPmpb3poY3poY7mjpvnrKDmqKtcIl0sXG5bXCI4YTgwXCIsXCLmqb/morbpsI3mvZ/libLllp3mgbDmi6zmtLvmuIfmu5HokZvopJDovYTkuJTpsLnlj7bmpJvmqLrpnoTmoKrlhZznq4PokrLph5zpjozlmZvptKjmoKLojIXokLHnsqXliIjoi4Xnk6bkub7kvoPlhqDlr5LliIrli5jli6flt7vllprloKrlp6blrozlrpjlr5vlubLlubnmgqPmhJ/mhaPmhr7mj5vmlaLmn5HmoZPmo7rmrL7mrZPmsZfmvKLmvpfmvYXnkrDnlJjnm6PnnIvnq7/nrqHnsKHnt6nnvLbnv7Dogp3oiabojp7oprPoq4zosqvpgoTpkZHplpPplpHplqLpmaXpn5PppKjoiJjkuLjlkKvlsrjlt4znjqnnmYznnLzlsqnnv6votIvpm4HpoJHpoZTpoZjkvIHkvI7ljbHllpzlmajln7rlpYflrInlr4TlspDluIzlub7lv4zmj67mnLrml5fml6LmnJ/mo4vmo4RcIl0sXG5bXCI4YjQwXCIsXCLmqZ/luLDmr4XmsJfmsb3nlb/npYjlraPnqIDntIDlvr3opo/oqJjosrTotbfou4zovJ3po6LpqI7prLzkuoDlgb3lhIDlppPlrpzmiK/mioDmk6zmrLrniqDnlpHnpYfnvqnon7voqrzorbDmjqzoj4rpnqDlkInlkIPllqvmoZTmqZjoqbDnoKfmnbXpu43ljbTlrqLohJromZDpgIbkuJjkuYXku4fkvJHlj4rlkLjlrq7lvJPmgKXmlZFcIl0sXG5bXCI4YjgwXCIsXCLmnL3msYLmsbLms6PngbjnkIPnqbbnqq7nrIjntJrns77ntabml6fniZvljrvlsYXlt6jmi5Lmi6DmjJnmuKDomZroqLHot53pi7jmvIHnpqbprZrkuqjkuqvkuqzkvpvkvqDlg5HlhYfnq7blhbHlh7bljZTljKHljb/lj6vllqzlooPls6HlvLflvYrmgK/mgZDmga3mjJ/mlZnmqYvms4Hni4Lni63nn6/og7johIXoiIjolY7pg7fpj6Hpn7/ppZfpqZrku7Dlh53lsK3mmoHmpa3lsYDmm7LmpbXnjonmoZDnsoHlg4Xli6TlnYflt77pjKbmlqTmrKPmrL3nkLTnpoHnpr3nrYvnt4roirnoj4zoob/opZ/orLnov5Hph5HlkJ/pioDkuZ3lgLblj6XljLrni5fnjpbnn6noi6bouq/pp4bpp4jpp5LlhbfmhJromZ7llrDnqbrlgbblr5PpgYfpmoXkuLLmq5vph6flsZHlsYhcIl0sXG5bXCI4YzQwXCIsXCLmjpjnqp/mspPpnbTovaHnqqrnhorpmojnsoLmoJfnubDmoZHpjazli7LlkJvolqvoqJPnvqTou43pg6HljabooojnpYHkv4Llgr7liJHlhYTllZPlnK3nj6rlnovlpZHlvaLlvoTmgbXmhbbmhafmhqnmjrLmkLrmlazmma/moYLmuJPnlabnqL3ns7vntYzntpnnuYvnvavojI7ojYrom43oqIjoqaPorabou73poJrpto/oirjov47pr6hcIl0sXG5bXCI4YzgwXCIsXCLliofmiJ/mkoPmv4DpmpnmoYHlgpHmrKDmsbrmvZTnqbTntZDooYDoqKPmnIjku7blgLnlgKblgaXlhbzliLjliaPllqflnI/loIXlq4zlu7rmhrLmh7jmi7PmjbLmpJzmqKnnib3niqznjK7noJTnoa/ntbnnnIzogqnopovorJnos6Lou5LpgaPpjbXpmbrpoZXpqJPpubjlhYPljp/ljrPlubvlvKbmuJvmupDnjoTnj77ntYPoiLfoqIDoq7rpmZDkuY7lgIvlj6Tlkbzlm7rlp5HlraTlt7HluqvlvKfmiLjmlYXmnq/muZbni5Dns4roorTogqHog6Hoj7DomY7oqofot6jpiLfpm4fpoafpvJPkupTkupLkvI3ljYjlkYnlkL7lqK/lvozlvqHmgp/moqfmqo7nkZrnooHoqp7oqqTorbfphpDkuZ7pr4nkuqTkvbzkvq/lgJnlgJblhYnlhazlip/lirnli77ljprlj6PlkJFcIl0sXG5bXCI4ZDQwXCIsXCLlkI7llonlnZHlnqLlpb3lrZTlrZ3lro/lt6Xlt6flt7flubjluoPluprlurflvJjmgZLmhYzmipfmi5jmjqfmlLvmmILmmYPmm7Tmna3moKHmopfmp4vmsZ/mtKrmtanmuK/mup3nlLLnmofnoaznqL/ns6DntIXntJjntZ7ntrHogJXogIPogq/ogrHohZToho/oiKrojZLooYzooaHorJvosqLos7zpg4rphbXpibHnoL/pi7zplqTpmY1cIl0sXG5bXCI4ZDgwXCIsXCLpoIXpppnpq5jptLvliZvliqvlj7flkIjlo5Xmi7fmv6DosarovZ/purnlhYvliLvlkYrlm73nqYDphbfptaDpu5LnjYTmvInohbDnlJHlv73mg5rpqqjni5vovrzmraTpoIPku4rlm7DlnaTlor7lqZrmgajmh4fmmI/mmIbmoLnmorHmt7fnl5XntLroia7prYLkupvkvZDlj4nllIblta/lt6blt67mn7vmspnnkbPnoILoqZDpjpboo5/lnZDluqfmjKvlgrXlgqzlho3mnIDlk4nloZ7lprvlrrDlvanmiY3mjqHmoL3mrbPmuIjngb3ph4fnioDnoJXnoKbnpa3mlo7ntLDoj5zoo4HovInpmpvliaTlnKjmnZDnvarosqHlhrTlnYLpmKrloLrmporogrTlkrLltI7ln7znopXpt7rkvZzliYrlkovmkL7mmKjmnJTmn7XnqoTnrZbntKLpjK/moZzprq3nrLnljJnlhorliLdcIl0sXG5bXCI4ZTQwXCIsXCLlr5/mi7bmkq7mk6bmnK3mrrrolqnpm5HnmpDpr5bmjYzpjIbprqvnmr/mmZLkuInlgpjlj4LlsbHmg6jmkpLmlaPmoZ/nh6bnj4rnlKPnrpfnuoLompXoroPos5vphbjppJDmlqzmmqvmrovku5Xku5TkvLrkvb/liLrlj7jlj7Lll6Plm5vlo6vlp4vlp4nlp7/lrZDlsY3luILluKvlv5fmgJ3mjIfmlK/lrZzmlq/mlr3ml6jmnp3mraJcIl0sXG5bXCI4ZTgwXCIsXCLmrbvmsI/njYXnpYnnp4Hns7jntJnntKvogqLohILoh7PoppboqZ7oqanoqaboqozoq67os4fos5zpm4zpo7zmra/kuovkvLzkvo3lhZDlrZflr7rmhYjmjIHmmYLmrKHmu4vmsrvniL7nkr3nl5Tno4HnpLrogIzogLPoh6rokpTovp7msZDpub/lvI/orZjptKvnq7rou7jlro3pm6vkuIPlj7Hln7flpLHlq4nlrqTmgonmub/mvIbnlr7os6rlrp/olIDnr6DlgbLmn7Toip3lsaHolYrnuJ7oiI7lhpnlsITmjajotabmlpznha7npL7ntJfogIXorJ3ou4rpga7om4fpgqrlgJ/li7rlsLrmnZPngbzniLXphYzph4jpjKvoi6Xlr4LlvLHmg7nkuLvlj5blrojmiYvmnLHmrorni6nnj6DnqK7ohavotqPphZLpppblhJLlj5flkarlr7/mjojmqLnntqzpnIDlm5rlj47lkahcIl0sXG5bXCI4ZjQwXCIsXCLlrpflsLHlt57kv67mhIHmi77mtLLnp4Dnp4vntYLnuY3nv5Loh63oiJ/okpDooYbopbLorpDoubTovK/pgLHphYvphazpm4bphpzku4DkvY/lhYXljYHlvpPmiI7mn5TmsYHmuIvnjaPnuKbph43pioPlj5TlpJnlrr/mt5HnpZ3nuK7nspvlob7nhp/lh7rooZPov7Dkv4rls7vmmKXnnqznq6PoiJzpp7/lh4blvqrml6zmpa/mronmt7NcIl0sXG5bXCI4ZjgwXCIsXCLmupbmvaTnm77ntJTlt6HpgbXphofpoIblh6bliJ3miYDmmpHmm5nmuJrlurbnt5LnvbLmm7jolq/ol7foq7jliqnlj5nlpbPluo/lvpDmgZXpi6TpmaTlgrflhJ/li53ljKDljYflj6zlk6jllYbllLHlmJflpajlpr7lqLzlrrXlsIblsI/lsJHlsJrluoTluorlu6DlvbDmib/mioTmi5vmjozmjbfmmIfmmIzmmK3mmbbmnb7moqLmqJ/mqLXmsrzmtojmuInmuZjnhLznhKbnhafnl4fnnIHnoZ3npIHnpaXnp7Dnq6DnrJHnsqfntLnogpboj5bokovolYnooZ3oo7PoqJ/oqLzoqZToqbPosaHos57phqTpiabpjb7pkJjpmpzpnpjkuIrkuIjkuJ7kuZflhpflibDln47loLTlo4zlrKLluLjmg4Xmk77mnaHmnZbmtYTnirbnlbPnqaPokrjorbLphrjpjKDlmLHln7Tpo75cIl0sXG5bXCI5MDQwXCIsXCLmi63mpI3mrpbnh63nuZTogbfoibLop6bpo5/onZXovrHlsLvkvLjkv6HkvrXllIflqKDlr53lr6nlv4PmhY7mjK/mlrDmmYvmo67mppvmtbjmt7HnlLPnlrnnnJ/npZ7np6bntLPoh6Poiq/olqropqroqLrouqvovpvpgLLph53pnIfkurrku4HliIPlobXlo6zlsIvnlJrlsL3ohY7oqIrov4XpmaPpna3nrKXoq4/poIjphaLlm7PljqhcIl0sXG5bXCI5MDgwXCIsXCLpgJflkLnlnoLluKXmjqjmsLTngornnaHnsovnv6DoobDpgYLphZTpjJDpjJjpmo/nkZ7pq4TltIfltanmlbDmnqLotqjpm5vmja7mnYnmpJnoj4XpoJfpm4Doo77mvoTmkbrlr7jkuJbngKznlZ3mmK/lh4TliLbli6Llp5PlvoHmgKfmiJDmlL/mlbTmmJ/mmbTmo7LmoJbmraPmuIXnibLnlJ/nm5vnsr7ogZblo7Doo73opb/oqqDoqpPoq4vpgJ3phpLpnZLpnZnmlonnqI7ohIbpmrvluK3mg5zmiJrmlqXmmJTmnpDnn7PnqY3nsY3nuL7ohIrosqzotaTot6HouZ/noqnliIfmi5nmjqXmkYLmipjoqK3nqoPnr4Doqqzpm6rntbboiIzonYnku5nlhYjljYPljaDlrqPlsILlsJblt53miKbmiYfmkrDmoJPmoLTms4nmtYXmtJfmn5PmvZznhY7nhb3ml4vnqb/nrq3nt5pcIl0sXG5bXCI5MTQwXCIsXCLnuYrnvqjohbroiJvoiLnolqboqa7os47ot7Xpgbjpgbfpiq3pipHploPprq7liY3lloTmvLjnhLblhajnpoXnuZXohrPns47lmYzloZHlsqjmjqrmm77mm73mpZrni5nnlo/nlo7npI7npZbnp5/nspfntKDntYTomIfoqLTpmLvpgaHpvKDlg6flibXlj4zlj6LlgInllqrlo67lpY/niL3lrovlsaTljJ3mg6Pmg7PmjZzmjoPmjL/mjrtcIl0sXG5bXCI5MTgwXCIsXCLmk43ml6nmm7nlt6Pmp43mp73mvJXnh6Xkuonnl6nnm7jnqpPns5/nt4/ntpzogaHojYnojZjokazokrzol7voo4XotbDpgIHpga3pjpfpnJzpqJLlg4/lopfmho7oh5PolLXotIjpgKDkv4PlgbTliYfljbPmga/mjYnmnZ/muKzotrPpgJ/kv5flsZ7os4rml4/ntprljZLoopblhbbmj4PlrZjlravlsIrmkI3mnZHpgZzku5blpJrlpKrmsbDoqZHllL7loJXlpqXmg7DmiZPmn4HoiLXmpZXpmYDpp4TpqKjkvZPloIblr77ogJDlsrHluK/lvoXmgKDmhYvmiLTmm7/ms7Dmu57og47ohb/oi5TooovosrjpgIDpgK7pmorpu5vpr5vku6Plj7DlpKfnrKzpho3poYzpt7nmu53ngKfljZPllYTlroXmiZjmip7mi5PmsqLmv6/nkKLoqJfpkLjmv4Hoq77ojLjlh6fom7jlj6pcIl0sXG5bXCI5MjQwXCIsXCLlj6nkvYbpgZTovrDlparohLHlt73nq6rovr/mo5rosLfni7jpsYjmqL3oqrDkuLnljZjlmIblnabmi4XmjqLml6bmrY7mt6HmuZvngq3nn63nq6/nrqrntrvogL3og4bom4voqpXpjZvlm6Plo4flvL7mlq3mmpbmqoDmrrXnlLfoq4flgKTnn6XlnLDlvJvmgaXmmbrmsaDnl7TnqJrnva7oh7TonJjpgYXpprPnr4nnlZznq7nnrZHok4RcIl0sXG5bXCI5MjgwXCIsXCLpgJDnp6nnqpLojLblq6HnnYDkuK3ku7Llrpnlv6Dmir3mmLzmn7Hms6jomavoobfoqLvphY7pi7Ppp5DmqJfngKbnjKroi6fokZfosq/kuIHlhYblh4vllovlr7XluJbluLPluoHlvJTlvLXlvavlvrTmh7LmjJHmmqLmnJ3mva7niZLnlLrnnLrogbTohLnohbjonbboqr/oq5zotoXot7PpiprplbfpoILps6Xli4XmjZfnm7TmnJXmsojnj43os4Ppjq7pmbPmtKXlopzmpI7mp4zov73pjprnl5vpgJrloZrmoILmjrTmp7vkvYPmvKzmn5jovrvolKbntrTpjZTmpL/mvbDlnarlo7flrKzntKzniKrlkIrph6PptrTkuq3kvY7lgZzlgbXliYPosp7lkYjloKTlrprluJ3lupXluq3lu7flvJ/mgozmirXmjLrmj5Dmoq/msYDnoofnpo7nqIvnt6DoiYfoqILoq6bouYTpgJNcIl0sXG5bXCI5MzQwXCIsXCLpgrjphK3ph5jpvI7ms6XmkZjmk6LmlbXmu7TnmoTnrJvpganpj5Hmurrlk7LlvrnmkqTovY3ov63piYTlhbjloavlpKnlsZXlupfmt7vnuo/nlJzosrzou6LpoZvngrnkvJ3mrr/mvrHnlLDpm7vlhY7lkJDloLXloZflpqzlsaDlvpLmlpfmnZzmuKHnmbvoj5/os63pgJTpg73pjY3noKXnoLrliqrluqblnJ/lpbTmgJLlgJLlhZrlhqxcIl0sXG5bXCI5MzgwXCIsXCLlh43liIDllJDloZTloZjlpZflrpXls7bltovmgrzmipXmkK3mnbHmoYPmorzmo5/nm5fmt5jmua/mtpvnga/nh4jlvZPnl5jnpbfnrYnnrZTnrZLns5bntbHliLDokaPolanol6ToqI7orITosYbouI/pgIPpgI/pkJnpmbbpoK3pqLDpl5jlg43li5XlkIzloILlsI7mhqfmkp7mtJ7nnrPnq6Xog7TokITpgZPpioXls6DptIfljL/lvpflvrPmtpznibnnnaPnpr/nr6Tmr5Lni6zoqq3moIPmqaHlh7jnqoHmpLTlsYrps7boi6vlr4XphYnngJ7lmbjlsa/mg4fmlabmsozosZrpgYHpoJPlkZHmm4fpiI3lpYjpgqPlhoXkuY3lh6rolpnorI7ngZjmjbrpjYvmpaLpprTnuITnlbfljZfmpaDou5/pm6PmsZ3kuozlsLzlvJDov6nljILos5Hogonombnlu7/ml6XkubPlhaVcIl0sXG5bXCI5NDQwXCIsXCLlpoLlsL/pn67ku7vlporlv43oqo3mv6HnprDnpaLlr6fokbHnjKvnhrHlubTlv7Xmjbvmkprnh4PnspjkuYPlu7zkuYvln5zlmqLmgqnmv4PntI3og73ohLPohr/ovrLoppfomqTlt7Tmiormkq3opofmnbfms6LmtL7nkLbnoLTlqYbnvbXoiq3ppqzkv7Plu4Pmi53mjpLmlZfmna/nm4PniYzog4zogrrovKnphY3lgI3ln7nlqpLmooVcIl0sXG5bXCI5NDgwXCIsXCLmpbPnhaTni73osrflo7Los6DpmarpgJnonb/np6Tnn6fokKnkvK/liaXljZrmi43mn4/ms4rnmb3nrpTnspXoiLboloTov6vmm53mvKDniIbnuJvojqvpp4Hpuqblh73nrrHnobLnrrjogofnrYjmq6jluaHogoznlZHnlaDlhavpiaLmuoznmbrphpfpq6rkvJDnvbDmipznrY/plqXps6nlmbrloZnom6TpmrzkvLTliKTljYrlj43lj5vluIbmkKzmlpHmnb/msL7msY7niYjniq/nj63nlZTnuYHoiKzol6nosqnnr4Tph4bnhanpoJLpo6/mjL3mmannlarnm6Tno5DolYPom67ljKrljZHlkKblpoPluoflvbzmgrLmiYnmibnmiqvmlpDmr5Tms4znlrLnmq7nopHnp5jnt4vnvbfogqXooqvoqrnosrvpgb/pnZ7po5vmqIvnsLjlgpnlsL7lvq7mnofmr5jnkLXnnInnvo5cIl0sXG5bXCI5NTQwXCIsXCLpvLvmn4rnqJfljLnnlovpq63lvabohp3oj7HogpjlvLzlv4XnlaLnrYbpgLzmoaflp6vlqpvntJDnmb7orKzkv7XlvarmqJnmsLfmvILnk6LnpajooajoqZXosbnlu5/mj4/nl4Xnp5Loi5fpjKjpi7Lokpzom63psK3lk4HlvazmlozmtZzngJXosqfos5PpoLvmlY/nk7bkuI3ku5jln6DlpKvlqablr4zlhqjluIPlupzmgJbmibbmlbdcIl0sXG5bXCI5NTgwXCIsXCLmlqfmma7mta7niLbnrKbohZDohproipnorZzosqDos6botbTpmJzpmYTkvq7mkqvmraboiJ7okaHolarpg6jlsIHmpZPpoqjokbrolZfkvI/lia/lvqnluYXmnI3npo/ohbnopIfopobmt7XlvJfmiZXmsrjku4/nianprpLliIblkLvlmbTlorPmhqTmia7nhJrlpa7nsonns57ntJvpm7DmlofogZ7kuJnkvbXlhbXloYDluaPlubPlvIrmn4TkuKbolL3plonpmZvnsbPpoIHlg7vlo4HnmZbnoqfliKXnnqXolJHnroblgY/lpInniYfnr4fnt6jovrrov5TpgY3kvr/li4nlqKnlvIHpnq3kv53oiJfpi6rlnIPmjZXmrannlKvoo5zovJTnqYLli5/lopPmhZXmiIrmmq7mr43nsL/oj6nlgKPkv7jljIXlkYbloLHlpYnlrp3ls7Dls6/ltKnlupbmirHmjafmlL7mlrnmnItcIl0sXG5bXCI5NjQwXCIsXCLms5Xms6Hng7nnoLLnuKvog57oirPokIzok6zonILopJLoqKrosYrpgqbpi5Lpo73ps7PptazkuY/kuqHlgo3liZblnYrlpqjluL3lv5jlv5nmiL/mmrTmnJvmn5Dmo5LlhpLntKHogqrohqjorIDosozosr/pib7pmLLlkKDpoKzljJflg5XljZzloqjmkrLmnLTniafnnabnqYbph6bli4PmsqHmrobloIDluYzlpZTmnKznv7vlh6Hnm4ZcIl0sXG5bXCI5NjgwXCIsXCLmkanno6jprZTpurvln4vlprnmmKfmnprmr47lk6nmp5nluZXohpzmnpXprqrmn77psZLmoZ3kuqbkv6Plj4jmirnmnKvmsqvov4Tkvq3nua3pur/kuIfmhaLmuoDmvKvolJPlkbPmnKrprYXlt7PnrpXlsqzlr4bonJzmuYrok5HnqJTohIjlppnnso3msJHnnKDli5nlpKLnhKHniZ/nn5vpnKfptaHmpIvlqb/lqJjlhqXlkI3lkb3mmI7nm5/ov7fpipjps7Tlp6rniZ3mu4XlhY3mo4nntr/nt6zpnaLpurrmkbjmqKHojILlpoTlrZ/mr5vnjJvnm7LntrLogJfokpnlhLLmnKjpu5nnm67mnaLli7/ppIXlsKTmiLvnsb7osrDllY/mgrbntIvploDljIHkuZ/lhrblpJzniLrogLbph47lvKXnn6LljoTlvbnntITolqzoqLPouo3pnZbmn7Polq7pkZPmhInmhIjmsrnnmZJcIl0sXG5bXCI5NzQwXCIsXCLoq63ovLjllK/kvZHlhKrli4flj4vlrqXlub3mgqDmhoLmj5bmnInmn5rmuafmtoznjLbnjLfnlLHnpZDoo5XoqpjpgYrpgpHpg7Xpm4Tono3lpJXkuojkvZnkuI7oqonovL/poJDlgq3lubzlppblrrnlurjmj5rmj7rmk4Hmm5zmpYrmp5jmtIvmurbnhpTnlKjnqq/nvorogIDokYnok4nopoHorKHouIrpgaXpmb3ppIrmhb7mipHmrLJcIl0sXG5bXCI5NzgwXCIsXCLmsoPmtbTnv4znv7zmt4DnvoXonrroo7jmnaXojrHpoLzpm7fmtJvntaHokL3pharkubHljbXltZDmrITmv6vol43omK3opqfliKnlkI/lsaXmnY7moqjnkIbnkoPnl6Loo4/oo6Hph4zpm6Lpmbjlvovnjofnq4vokY7mjqDnlaXlionmtYHmupznkInnlZnnoavnspLpmobnq5zpvo3kvrbmha7ml4XomZzkuobkuq7lg5rkuKHlh4zlr67mlpnmooHmtrznjJ/nmYLnnq3nqJzns6foia/oq5Lpgbzph4/pmbXpoJjlipvnt5HlgKvljpjmnpfmt4vnh5DnkLPoh6jovKrpmqPpsZfpup/nkaDloYHmtpnntK/poZ7ku6TkvLbkvovlhrflirHltrrmgJznjrLnpLzoi5PpiLTpmrfpm7bpnIrpupfpvaLmmqbmrbTliJfliqPng4joo4Llu4nmgYvmhpDmvKPnhYnnsL7nt7Toga9cIl0sXG5bXCI5ODQwXCIsXCLok67pgKPpjKzlkYLpra/mq5Pngonos4Lot6/pnLLlirTlqYHlu4rlvITmnJfmpbzmppTmtarmvI/niaLni7znr63ogIHogb7onYvpg47lha3pupPnpoTogovpjLLoq5blgK3lkozoqbHmraros4TohIfmg5HmnqDpt7LkupnkupjpsJDoqavol4HolajmpIDmub7nopfohZVcIl0sXG5bXCI5ODlmXCIsXCLlvIzkuJDkuJXkuKrkuLHkuLbkuLzkuL/kuYLkuZbkuZjkuoLkuoXosavkuoroiJLlvI3kuo7kup7kup/kuqDkuqLkurDkurPkurbku47ku43ku4Tku4bku4Lku5fku57ku63ku5/ku7fkvInkvZrkvLDkvZvkvZ3kvZfkvYfkvbbkvojkvo/kvpjkvbvkvankvbDkvpHkva/kvobkvpblhJjkv5Tkv5/kv47kv5jkv5vkv5Hkv5rkv5Dkv6Tkv6XlgJrlgKjlgJTlgKrlgKXlgIXkvJzkv7blgKHlgKnlgKzkv77kv6/lgJHlgIblgYPlgYfmnIPlgZXlgZDlgYjlgZrlgZblgazlgbjlgoDlgprlgoXlgrTlgrJcIl0sXG5bXCI5OTQwXCIsXCLlg4nlg4rlgrPlg4Llg5blg57lg6Xlg63lg6Plg67lg7nlg7XlhInlhIHlhILlhJblhJXlhJTlhJrlhKHlhLrlhLflhLzlhLvlhL/lhYDlhZLlhYzlhZTlhaLnq7jlhanlharlha7lhoDlhoLlm5jlhozlhonlho/lhpHlhpPlhpXlhpblhqTlhqblhqLlhqnlhqrlhqvlhrPlhrHlhrLlhrDlhrXlhr3lh4Xlh4nlh5vlh6DomZXlh6nlh61cIl0sXG5bXCI5OTgwXCIsXCLlh7Dlh7Xlh77liITliIvliJTliI7liKfliKrliK7liLPliLnliY/liYTliYvliYzliZ7liZTliarlibTlianlibPlib/lib3lio3lipTlipLlibHliojlipHovqjovqfliqzliq3lirzlirXli4Hli43li5fli57li6Pli6bpo63li6Dli7Pli7Xli7jli7nljIbljIjnlLjljI3ljJDljI/ljJXljJrljKPljK/ljLHljLPljLjljYDljYbljYXkuJfljYnljY3lh5bljZ7ljanlja7lpJjljbvljbfljoLljpbljqDljqbljqXljq7ljrDljrblj4PnsJLpm5nlj5/mm7znh67lj67lj6jlj63lj7rlkIHlkL3lkYDlkKzlkK3lkLzlkK7lkLblkKnlkJ3lkY7lko/lkbXlko7lkZ/lkbHlkbflkbDlkpLlkbvlkoDlkbblkoTlkpDlkoblk4flkqLlkrjlkqXlkqzlk4Tlk4jlkqhcIl0sXG5bXCI5YTQwXCIsXCLlkqvlk4LlkqTlkr7lkrzlk5jlk6Xlk6bllI/llJTlk73lk67lk63lk7rlk6LllLnllYDllaPllYzllK7llZzllYXllZbllZfllLjllLPllZ3llpnlloDlkq/llorllp/llbvllb7llpjllp7llq7llbzlloPllqnllofllqjll5rll4Xll5/ll4Tll5zll6Tll5TlmJTll7flmJbll77ll73lmJvll7nlmY7lmZDnh5/lmLTlmLblmLLlmLhcIl0sXG5bXCI5YTgwXCIsXCLlmavlmaTlmK/lmazlmarlmoblmoDlmorlmqDlmpTlmo/lmqXlmq7lmrblmrTlm4Llmrzlm4Hlm4Plm4Dlm4jlm47lm5Hlm5Plm5flm67lm7nlnIDlm7/lnITlnInlnIjlnIvlnI3lnJPlnJjlnJbll4flnJzlnKblnLflnLjlnY7lnLvlnYDlnY/lnanln4DlnojlnaHlnb/lnonlnpPlnqDlnrPlnqTlnqrlnrDln4Pln4bln5Tln5Lln5PloIrln5bln6PloIvloJnloJ3lobLloKHloaLloYvlobDmr4DloZLloL3lobnlooXlornlop/loqvlorrlo57lorvlorjloq7lo4Xlo5Plo5Hlo5flo5nlo5jlo6Xlo5zlo6Tlo5/lo6/lo7rlo7nlo7vlo7zlo73lpILlpIrlpJDlpJvmoqblpKXlpKzlpK3lpLLlpLjlpL7nq5LlpZXlpZDlpY7lpZrlpZjlpaLlpaDlpaflpazlpalcIl0sXG5bXCI5YjQwXCIsXCLlpbjlpoHlpp3kvZ7kvqvlpqPlprLlp4blp6jlp5zlpo3lp5nlp5rlqKXlqJ/lqJHlqJzlqInlqJrlqYDlqazlqYnlqLXlqLblqaLlqarlqprlqrzlqr7lq4vlq4Llqr3lq6Plq5flq6blq6nlq5blq7rlq7vlrIzlrIvlrJblrLLlq5DlrKrlrLblrL7lrYPlrYXlrYDlrZHlrZXlrZrlrZvlraXlranlrbDlrbPlrbXlrbjmlojlrbrlroBcIl0sXG5bXCI5YjgwXCIsXCLlroPlrqblrrjlr4Plr4flr4nlr5Tlr5Dlr6Tlr6blr6Llr57lr6Xlr6vlr7Dlr7blr7PlsIXlsIflsIjlsI3lsJPlsKDlsKLlsKjlsLjlsLnlsYHlsYblsY7lsZPlsZDlsY/lrbHlsazlsa7kuaLlsbblsbnlsozlspHlspTlppvlsqvlsrvlsrblsrzlsrfls4Xlsr7ls4fls5nls6nls73ls7rls63ltozls6rltIvltJXltJfltZzltJ/ltJvltJHltJTltKLltJrltJnltJjltYzltZLltY7ltYvltazltbPltbbltofltoTltoLltqLltp3ltqzltq7ltr3ltpDltrfltrzlt4nlt43lt5Plt5Llt5blt5vlt6vlt7Llt7XluIvluJrluJnluJHluJvluLbluLfluYTluYPluYDluY7luZfluZTluZ/luaLluaTluYflubXlubblubrpurzlub/luqDlu4Hlu4Llu4jlu5Dlu49cIl0sXG5bXCI5YzQwXCIsXCLlu5blu6Plu53lu5rlu5vlu6Llu6Hlu6jlu6nlu6zlu7Hlu7Plu7Dlu7Tlu7jlu77lvIPlvInlvZ3lvZzlvIvlvJHlvJblvKnlvK3lvLjlvYHlvYjlvYzlvY7lvK/lvZHlvZblvZflvZnlvaHlva3lvbPlvbflvoPlvoLlvb/lvorlvojlvpHlvoflvp7lvpnlvpjlvqDlvqjlvq3lvrzlv5blv7vlv6Tlv7jlv7Hlv53mgrPlv7/mgKHmgaBcIl0sXG5bXCI5YzgwXCIsXCLmgJnmgJDmgKnmgI7mgLHmgJvmgJXmgKvmgKbmgI/mgLrmgZrmgYHmgarmgbfmgZ/mgYrmgYbmgY3mgaPmgYPmgaTmgYLmgazmgavmgZnmgoHmgo3mg6fmgoPmgprmgoTmgpvmgpbmgpfmgpLmgqfmgovmg6Hmgrjmg6Dmg5PmgrTlv7Dmgr3mg4bmgrXmg5jmhY3mhJXmhIbmg7bmg7fmhIDmg7Tmg7rmhIPmhKHmg7vmg7HmhI3mhI7mhYfmhL7mhKjmhKfmhYrmhL/mhLzmhKzmhLTmhL3mhYLmhYTmhbPmhbfmhZjmhZnmhZrmhavmhbTmha/mhaXmhbHmhZ/mhZ3mhZPmhbXmhpnmhpbmhofmhqzmhpTmhprmhormhpHmhqvmhq7mh4zmh4rmh4nmh7fmh4jmh4Pmh4bmhrrmh4vnvbnmh43mh6bmh6Pmh7bmh7rmh7Tmh7/mh73mh7zmh77miIDmiIjmiInmiI3miIzmiJTmiJtcIl0sXG5bXCI5ZDQwXCIsXCLmiJ7miKHmiKrmiK7miLDmiLLmiLPmiYHmiY7miZ7miaPmiZvmiaDmiajmibzmioLmionmib7mipLmipPmipbmi5TmioPmipTmi5fmi5Hmirvmi4/mi7/mi4bmk5Tmi4jmi5zmi4zmi4rmi4Lmi4fmipvmi4nmjIzmi67mi7HmjKfmjILmjIjmi6/mi7XmjZDmjL7mjY3mkJzmjY/mjpbmjo7mjoDmjqvmjbbmjqPmjo/mjonmjp/mjrXmjatcIl0sXG5bXCI5ZDgwXCIsXCLmjanmjr7mj6nmj4Dmj4bmj6Pmj4nmj5Lmj7bmj4TmkJbmkLTmkIbmkJPmkKbmkLbmlJ3mkJfmkKjmkI/mkafmka/mkbbmkY7mlKrmkpXmkpPmkqXmkqnmkojmkrzmk5rmk5Lmk4Xmk4fmkrvmk5jmk4Lmk7Hmk6foiInmk6Dmk6Hmiqzmk6Pmk6/mlKzmk7bmk7Tmk7Lmk7rmlIDmk73mlJjmlJzmlIXmlKTmlKPmlKvmlLTmlLXmlLfmlLbmlLjnlYvmlYjmlZbmlZXmlY3mlZjmlZ7mlZ3mlbLmlbjmloLmloPorormlpvmlp/mlqvmlrfml4Pml4bml4Hml4Tml4zml5Lml5vml5nml6Dml6Hml7HmnbLmmIrmmIPml7vmnbPmmLXmmLbmmLTmmJzmmY/mmYTmmYnmmYHmmZ7mmZ3mmaTmmafmmajmmZ/mmaLmmbDmmoPmmojmmo7mmonmmoTmmpjmmp3mm4Hmmrnmm4nmmr7mmrxcIl0sXG5bXCI5ZTQwXCIsXCLmm4Tmmrjmm5bmm5rmm6DmmL/mm6bmm6nmm7Dmm7Xmm7fmnI/mnJbmnJ7mnKbmnKfpnLjmnK7mnL/mnLbmnYHmnLjmnLfmnYbmnZ7mnaDmnZnmnaPmnaTmnonmnbDmnqnmnbzmnarmnozmnovmnqbmnqHmnoXmnrfmn6/mnrTmn6zmnrPmn6nmnrjmn6Tmn57mn53mn6Lmn67mnrnmn47mn4bmn6fmqpzmoJ7moYbmoKnmoYDmoY3moLLmoY5cIl0sXG5bXCI5ZTgwXCIsXCLmorPmoKvmoZnmoaPmobfmob/mop/moo/moq3mopTmop3mopvmooPmqq7mornmobTmorXmoqDmorrmpI/moo3mob7mpIHmo4rmpIjmo5jmpKLmpKbmo6HmpIzmo43mo5Tmo6fmo5XmpLbmpJLmpITmo5fmo6PmpKXmo7nmo6Dmo6/mpKjmpKrmpJrmpKPmpKHmo4bmpbnmpbfmpZzmpbjmpavmpZTmpb7mpa7mpLnmpbTmpL3mpZnmpLDmpaHmpZ7mpZ3mpoHmparmprLmpq7mp5Dmpr/mp4Hmp5Pmpr7mp47lr6jmp4rmp53mprvmp4PmpqfmqK7mppHmpqDmppzmppXmprTmp57mp6jmqILmqJvmp7/mrIrmp7nmp7Lmp6fmqIXmprHmqJ7mp63mqJTmp6vmqIrmqJLmq4HmqKPmqJPmqYTmqIzmqbLmqLbmqbjmqYfmqaLmqZnmqabmqYjmqLjmqKLmqpDmqo3mqqDmqoTmqqLmqqNcIl0sXG5bXCI5ZjQwXCIsXCLmqpfomJfmqrvmq4Pmq4LmqrjmqrPmqqzmq57mq5Hmq5/mqqrmq5rmq6rmq7vmrIXomJbmq7rmrJLmrJbprLHmrJ/mrLjmrLfnm5zmrLnpo67mrYfmrYPmrYnmrZDmrZnmrZTmrZvmrZ/mraHmrbjmrbnmrb/mroDmroTmroPmro3mrpjmrpXmrp7mrqTmrqrmrqvmrq/mrrLmrrHmrrPmrrfmrrzmr4bmr4vmr5Pmr5/mr6zmr6vmr7Pmr69cIl0sXG5bXCI5ZjgwXCIsXCLpur7msIjmsJPmsJTmsJvmsKTmsKPmsZ7msZXmsaLmsarmsoLmso3msprmsoHmspvmsb7msajmsbPmspLmspDms4Tms7Hms5Pmsr3ms5fms4Xms53msq7msrHmsr7msrrms5vms6/ms5nms6rmtJ/ooY3mtLbmtKvmtL3mtLjmtJnmtLXmtLPmtJLmtIzmtaPmtpPmtaTmtZrmtbnmtZnmto7mtpXmv6TmtoXmt7nmuJXmuIrmtrXmt4fmt6bmtrjmt4bmt6zmt57mt4zmt6jmt5Lmt4Xmt7rmt5nmt6Tmt5Xmt6rmt67muK3mua7muK7muJnmubLmuZ/muL7muKPmuavmuKvmubbmuY3muJ/muYPmuLrmuY7muKTmu7/muJ3muLjmuoLmuqrmupjmu4nmurfmu5Pmur3muq/mu4TmurLmu5Tmu5Xmuo/muqXmu4Lmup/mvYHmvJHngYzmu6zmu7jmu77mvL/mu7LmvLHmu6/mvLLmu4xcIl0sXG5bXCJlMDQwXCIsXCLmvL7mvJPmu7fmvobmvbrmvbjmvoHmvoDmva/mvZvmv7Pmva3mvoLmvbzmvZjmvo7mvpHmv4LmvabmvrPmvqPmvqHmvqTmvrnmv4bmvqrmv5/mv5Xmv6zmv5Tmv5jmv7Hmv67mv5vngInngIvmv7rngJHngIHngI/mv77ngJvngJrmvbTngJ3ngJjngJ/ngLDngL7ngLLngZHngaPngpnngpLngq/ng7HngqzngrjngrPngq7ng5/ng4vng51cIl0sXG5bXCJlMDgwXCIsXCLng5nnhInng73nhJznhJnnhaXnhZXnhojnhabnhaLnhYznhZbnhaznho/nh7vnhoTnhpXnhqjnhqznh5fnhrnnhr7nh5Lnh4nnh5Tnh47nh6Dnh6znh6fnh7Xnh7znh7nnh7/niI3niJDniJvniKjniK3niKzniLDniLLniLvniLzniL/niYDniYbniYvniZjnibTnib7nioLnioHniofnipLnipbniqLniqfnirnnirLni4Pni4bni4Tni47ni5Lni6Lni6Dni6Hni7nni7flgI/njJfnjIrnjJznjJbnjJ3njLTnjK/njKnnjKXnjL7njY7njY/pu5jnjZfnjarnjajnjbDnjbjnjbXnjbvnjbrnj4jnjrPnj47njrvnj4Dnj6Xnj67nj57nkqLnkIXnka/nkKXnj7jnkLLnkLrnkZXnkL/nkZ/nkZnnkYHnkZznkannkbDnkaPnkarnkbbnkb7nkovnkp7nkqfnk4rnk4/nk5Tnj7FcIl0sXG5bXCJlMTQwXCIsXCLnk6Dnk6Pnk6fnk6nnk67nk7Lnk7Dnk7Hnk7jnk7fnlITnlIPnlIXnlIznlI7nlI3nlJXnlJPnlJ7nlKbnlKznlLznlYTnlY3nlYrnlYnnlZvnlYbnlZrnlannlaTnlafnlavnla3nlbjnlbbnlobnlofnlbTnlornlonnloLnlpTnlprnlp3nlqXnlqPnl4LnlrPnl4PnlrXnlr3nlrjnlrznlrHnl43nl4rnl5Lnl5nnl6Pnl57nl77nl79cIl0sXG5bXCJlMTgwXCIsXCLnl7znmIHnl7Dnl7rnl7Lnl7PnmIvnmI3nmInnmJ/nmKfnmKDnmKHnmKLnmKTnmLTnmLDnmLvnmYfnmYjnmYbnmZznmZjnmaHnmaLnmajnmannmarnmafnmaznmbDnmbLnmbbnmbjnmbznmoDnmoPnmojnmovnmo7nmpbnmpPnmpnnmprnmrDnmrTnmrjnmrnnmrrnm4Lnm43nm5bnm5Lnm57nm6Hnm6Xnm6fnm6romK/nm7vnnIjnnIfnnITnnKnnnKTnnJ7nnKXnnKbnnJvnnLfnnLjnnYfnnZrnnajnnavnnZvnnaXnnb/nnb7nnbnnno7nnovnnpHnnqDnnp7nnrDnnrbnnrnnnr/nnrznnr3nnrvnn4fnn43nn5fnn5rnn5znn6Pnn67nn7znoIznoJLnpKbnoKDnpKrnoYXnoo7nobTnoobnobznoprnooznoqPnorXnoqrnoq/no5Hno4bno4vno5Tnor7norzno4Xno4rno6xcIl0sXG5bXCJlMjQwXCIsXCLno6fno5rno73no7TnpIfnpJLnpJHnpJnnpKznpKvnpYDnpaDnpZfnpZ/npZrnpZXnpZPnpbrnpb/npornpp3npqfpvYvnpqrnpq7nprPnprnnprrnp4nnp5Xnp6fnp6znp6Hnp6PnqIjnqI3nqJjnqJnnqKDnqJ/npoDnqLHnqLvnqL7nqLfnqYPnqZfnqYnnqaHnqaLnqanpvp3nqbDnqbnnqb3nqojnqpfnqpXnqpjnqpbnqqnnq4jnqrBcIl0sXG5bXCJlMjgwXCIsXCLnqrbnq4Xnq4Tnqr/pgoPnq4fnq4rnq43nq4/nq5Xnq5Pnq5nnq5rnq53nq6Hnq6Lnq6bnq63nq7DnrILnrI/nrIrnrIbnrLPnrJjnrJnnrJ7nrLXnrKjnrLbnrZDnrbrnrITnrY3nrIvnrYznrYXnrbXnraXnrbTnrafnrbDnrbHnraznra7nrp3nrpjnrp/nro3nrpznrprnrovnrpLnro/nrZ3nrpnnr4vnr4Hnr4znr4/nrrTnr4bnr53nr6nnsJHnsJTnr6bnr6XnsaDnsIDnsIfnsJPnr7Pnr7fnsJfnsI3nr7bnsKPnsKfnsKrnsJ/nsLfnsKvnsL3nsYznsYPnsZTnsY/nsYDnsZDnsZjnsZ/nsaTnsZbnsaXnsaznsbXnsoPnspDnsqTnsq3nsqLnsqvnsqHnsqjnsrPnsrLnsrHnsq7nsrnnsr3ns4Dns4Xns4Lns5jns5Lns5zns6LprLvns6/ns7Lns7Tns7bns7rntIZcIl0sXG5bXCJlMzQwXCIsXCLntILntJzntJXntIrntYXntYvntK7ntLLntL/ntLXntYbntbPntZbntY7ntbLntajnta7ntY/ntaPntpPntonntZvnto/ntb3ntpvntrrntq7ntqPntrXnt4fntr3ntqvnuL3ntqLntq/nt5zntrjntp/ntrDnt5jnt53nt6Tnt57nt7vnt7Lnt6HnuIXnuIrnuKPnuKHnuJLnuLHnuJ/nuInnuIvnuKLnuYbnuabnuLvnuLXnuLnnuYPnuLdcIl0sXG5bXCJlMzgwXCIsXCLnuLLnuLrnuafnuZ3nuZbnuZ7nuZnnuZrnubnnuarnuannubznubvnuoPnt5Xnub3ovq7nub/nuojnuonnuoznupLnupDnupPnupTnupbnuo7nupvnupznvLjnvLrnvYXnvYznvY3nvY7nvZDnvZHnvZXnvZTnvZjnvZ/nvaDnvajnvannvafnvbjnvoLnvobnvoPnvojnvofnvoznvpTnvp7nvp3nvprnvqPnvq/nvrLnvrnnvq7nvrbnvrjorbHnv4Xnv4bnv4rnv5Xnv5Tnv6Hnv6bnv6nnv7Pnv7npo5zogIbogITogIvogJLogJjogJnogJzogKHogKjogL/ogLvogYrogYbogZLogZjogZrogZ/ogaLogajogbPogbLogbDogbbogbnogb3ogb/ogoTogobogoXogpvogpPogprogq3lhpDogqzog5vog6Xog5nog53og4Tog5rog5bohInog6/og7HohJvohKnohKPohK/ohYtcIl0sXG5bXCJlNDQwXCIsXCLpmovohYbohL7ohZPohZHog7zohbHoha7ohaXohabohbTohoPohojohorohoDohoLohqDohpXohqTohqPohZ/ohpPohqnohrDohrXohr7ohrjohr3oh4Doh4Lohrroh4noh43oh5Hoh5noh5joh4joh5roh5/oh6Doh6foh7roh7voh77oiIHoiILoiIXoiIfoiIroiI3oiJDoiJboiKnoiKvoiLjoiLPoiYDoiZnoiZjoiZ3oiZroiZ/oiaRcIl0sXG5bXCJlNDgwXCIsXCLoiaLoiajoiaroiavoiK7oibHoibfoibjoib7oio3oipLoiqvoip/oirvoiqzoi6Hoi6Poi5/oi5Loi7Toi7Poi7rojpPojIPoi7voi7noi57ojIboi5zojInoi5nojLXojLTojJbojLLojLHojYDojLnojZDojYXojK/ojKvojJfojJjojoXojprojqrojp/ojqLojpbojKPojo7ojofojorojbzojrXojbPojbXojqDojonojqjoj7TokJPoj6voj47oj73okIPoj5jokIvoj4Hoj7fokIfoj6Doj7LokI3okKLokKDojr3okLjolIboj7voka3okKrokLzolZrokoTokbfokavokq3oka7okoLokanokYbokKzoka/okbnokLXok4rokaLokrnokr/okp/ok5nok43okrvok5rok5Dok4Hok4bok5bokqHolKHok7/ok7TolJfolJjolKzolJ/olJXolJTok7zolYDolaPolZjolYhcIl0sXG5bXCJlNTQwXCIsXCLolYHomILolYvolZXoloDolqTolojolpHolorolqjola3olpTolpvol6rolofolpzolbfolb7olpDol4nolrrol4/olrnol5Dol5Xol53ol6Xol5zol7nomIromJPomIvol77ol7romIbomKLomJromLDomL/omY3kuZXomZTomZ/omafombHompPomqPomqnomqromovomozomrbomq/om4Tom4bomrDom4nooKPomqvom5Tom57om6nom6xcIl0sXG5bXCJlNTgwXCIsXCLom5/om5vom6/onJLonIbonIjonIDonIPom7vonJHonInonI3om7nonIronLTonL/onLfonLvonKXonKnonJronaDonZ/onbjonYzonY7onbTonZfonajona7onZnonZPonaPonarooIXonqLonp/onoLonq/on4vonr3on4Don5Dpm5bonqvon4TonrPon4fon4bonrvon6/on7Lon6DooI/ooI3on77on7bon7fooI7on5LooJHooJbooJXooKLooKHooLHooLbooLnooKfooLvooYTooYLooZLooZnooZ7ooaLooavoooHoob7oop7oobXoob3oorXoobLoooLoopfoopLooq7oopnooqLooo3ooqToorDoor/oorHoo4Poo4Too5Too5joo5noo53oo7nopILoo7zoo7Too6joo7LopITopIzopIropJPopYPopJ7opKXopKropKvopYHopYTopLvopLbopLjopYzopJ3opaDopZ5cIl0sXG5bXCJlNjQwXCIsXCLopabopaTopa3oparopa/opbTopbfopb7opoPopojoporoppPoppjopqHopqnopqbopqzopq/oprLoprropr3opr/op4Dop5rop5zop53op6fop7Top7joqIPoqJboqJDoqIzoqJvoqJ3oqKXoqLboqYHoqZvoqZLoqYboqYjoqbzoqa3oqazoqaLoqoXoqoLoqoToqqjoqqHoqpHoqqXoqqboqproqqPoq4Toq43oq4Loq5roq6voq7Poq6dcIl0sXG5bXCJlNjgwXCIsXCLoq6Toq7HorJToq6Doq6Loq7foq57oq5vorIzorIforJroq6HorJborJDorJforKDorLPpnqvorKborKvorL7orKjorYHorYzorY/orY7orYnorZborZvorZroravorZ/orazora/orbTorb3oroDorozoro7orpLorpPorpborpnorprosLrosYHosL/osYjosYzosY7osZDosZXosaLosazosbjosbrosoLosonosoXosoroso3oso7ospTosbzospjmiJ3osq3osqrosr3osrLosrPosq7osrbos4jos4Hos6Tos6Pos5ros73os7ros7votITotIXotIrotIfotI/otI3otJDpvY7otJPos43otJTotJbotafota3otbHotbPotoHotpnot4Lotr7otrrot4/ot5rot5bot4zot5vot4vot6rot6vot5/ot6Pot7zouIjouInot7/ouJ3ouJ7ouJDouJ/ouYLouLXouLDouLTouYpcIl0sXG5bXCJlNzQwXCIsXCLouYfouYnouYzouZDouYjouZnouaTouaDouKrouaPouZXoubboubLoubzouoHouofouoXouoTouovouoroupPoupHoupToupnouqrouqHouqzourDou4bourHour7ou4Xou4jou4vou5vou6Pou7zou7vou6vou77ovIrovIXovJXovJLovJnovJPovJzovJ/ovJvovIzovKbovLPovLvovLnovYXovYLovL7ovYzovYnovYbovY7ovZfovZxcIl0sXG5bXCJlNzgwXCIsXCLovaLovaPovaTovpzovp/ovqPovq3ovq/ovrfov5rov6Xov6Lov6rov6/pgofov7TpgIXov7nov7rpgJHpgJXpgKHpgI3pgJ7pgJbpgIvpgKfpgLbpgLXpgLnov7jpgY/pgZDpgZHpgZLpgI7pgYnpgL7pgZbpgZjpgZ7pgajpga/pgbbpmqjpgbLpgoLpgb3pgoHpgoDpgorpgonpgo/pgqjpgq/pgrHpgrXpg6Lpg6TmiYjpg5vphILphJLphJnphLLphLDphYrphZbphZjphaPphaXphanphbPphbLphovphonphoLphqLphqvphq/phqrphrXphrTphrrph4Dph4Hph4nph4vph5Dph5bph5/ph6Hph5vph7zph7Xph7bpiJ7ph7/piJTpiKzpiJXpiJHpiZ7piZfpiYXpiYnpiaTpiYjpipXpiL/piYvpiZDpipzpipbpipPpipvpiZrpi4/pirnpirfpi6npjI/pi7rpjYTpjK5cIl0sXG5bXCJlODQwXCIsXCLpjJnpjKLpjJrpjKPpjLrpjLXpjLvpjZzpjaDpjbzpja7pjZbpjrDpjqzpjq3pjpTpjrnpj5bpj5fpj6jpj6Xpj5jpj4Ppj53pj5Dpj4jpj6TpkJrpkJTpkJPpkIPpkIfpkJDpkLbpkKvpkLXpkKHpkLrpkYHpkZLpkYTpkZvpkaDpkaLpkZ7pkarpiKnpkbDpkbXpkbfpkb3pkZrpkbzpkb7pkoHpkb/ploLplofplorplpTplpbplpjplplcIl0sXG5bXCJlODgwXCIsXCLplqDplqjplqfplq3plrzplrvplrnplr7pl4rmv7bpl4Ppl43pl4zpl5Xpl5Tpl5bpl5zpl6Hpl6Xpl6LpmKHpmKjpmK7pmK/pmYLpmYzpmY/pmYvpmbfpmZzpmZ7pmZ3pmZ/pmabpmbLpmazpmo3pmpjpmpXpmpfpmqrpmqfpmrHpmrLpmrDpmrTpmrbpmrjpmrnpm47pm4vpm4npm43opY3pm5zpnI3pm5Xpm7npnITpnIbpnIjpnJPpnI7pnJHpnI/pnJbpnJnpnKTpnKrpnLDpnLnpnL3pnL7pnYTpnYbpnYjpnYLpnYnpnZzpnaDpnaTpnabpnajli5LpnavpnbHpnbnpnoXpnbzpnoHpnbrpnobpnovpno/pnpDpnpzpnqjpnqbpnqPpnrPpnrTpn4Ppn4bpn4jpn4vpn5zpn63pvY/pn7Lnq5/pn7bpn7XpoI/poIzpoLjpoKTpoKHpoLfpoL3poYbpoY/poYvpoavpoa/pobBcIl0sXG5bXCJlOTQwXCIsXCLpobHpobTpobPpoqrpoq/porHporbpo4Tpo4Ppo4bpo6npo6vppIPppInppJLppJTppJjppKHppJ3ppJ7ppKTppKDppKzppK7ppL3ppL7ppYLppYnppYXppZDppYvppZHppZLppYzppZXpppfpppjppqXppq3ppq7pprzpp5/pp5vpp53pp5jpp5Hpp63pp67pp7Hpp7Lpp7vpp7jpqIHpqI/pqIXpp6LpqJnpqKvpqLfpqYXpqYLpqYDpqYNcIl0sXG5bXCJlOTgwXCIsXCLpqL7pqZXpqY3pqZvpqZfpqZ/pqaLpqaXpqaTpqanpqavpqarpqq3pqrDpqrzpq4Dpq4/pq5Hpq5Ppq5Tpq57pq5/pq6Lpq6Ppq6bpq6/pq6vpq67pq7Tpq7Hpq7fpq7vprIbprJjprJrprJ/prKLprKPprKXprKfprKjprKnprKrprK7prK/prLLprYTprYPprY/prY3prY7prZHprZjprbTprpPproPprpHprpbprpfprp/prqDprqjprrTpr4Dpr4rprrnpr4bpr4/pr5Hpr5Lpr6Ppr6Lpr6Tpr5Tpr6HpsLrpr7Lpr7Hpr7DpsJXpsJTpsInpsJPpsIzpsIbpsIjpsJLpsIrpsITpsK7psJvpsKXpsKTpsKHpsLDpsYfpsLLpsYbpsL7psZrpsaDpsafpsbbpsbjps6fps6zps7DptInptIjps6vptIPptIbptKrptKbptq/ptKPptJ/ptYTptJXptJLptYHptL/ptL7ptYbptYhcIl0sXG5bXCJlYTQwXCIsXCLptZ3ptZ7ptaTptZHptZDptZnptbLptonptofptqvpta/ptbrptprptqTptqnptrLpt4Tpt4Hptrvptrjptrrpt4bpt4/pt4Lpt5npt5Ppt7jpt6bpt63pt6/pt73puJrpuJvpuJ7pubXpubnpub3puoHpuojpuovpuozpupLpupXpupHpup3puqXpuqnpurjpuqrpuq3pnaHpu4zpu47pu4/pu5Dpu5Tpu5zpu57pu53pu6Dpu6Xpu6jpu69cIl0sXG5bXCJlYTgwXCIsXCLpu7Tpu7bpu7fpu7npu7vpu7zpu73pvIfpvIjnmrfpvJXpvKHpvKzpvL7pvYrpvZLpvZTpvaPpvZ/pvaDpvaHpvabpvafpvazpvarpvbfpvbLpvbbpvpXpvpzpvqDloK/mp4fpgZnnkaTlh5znhplcIl0sXG5bXCJlZDQwXCIsXCLnuoropJzpjYjpiojok5zkv4nngrvmmLHmo4jpi7nmm7vlvYXkuKjku6Hku7zkvIDkvIPkvLnkvZbkvpLkvorkvprkvpTkv43lgYDlgKLkv7/lgJ7lgYblgbDlgYLlgpTlg7Tlg5jlhYrlhaTlhp3lhr7lh6zliJXlipzliqbli4Dli5vljIDljIfljKTljbLljpPljrLlj53vqI7lkpzlkorlkqnlk7/lloblnZnlnaXlnqzln4jln4fvqI9cIl0sXG5bXCJlZDgwXCIsXCLvqJDlop7lorLlpIvlpZPlpZvlpZ3lpaPlpqTlprrlrZblr4DnlK/lr5jlr6zlsJ7lsqblsrrls7XltKfltZPvqJHltYLlta3ltrjltrnlt5DlvKHlvLTlvaflvrflv57mgZ3mgoXmgormg57mg5XmhKDmg7LmhJHmhLfmhLDmhpjmiJPmiqbmj7XmkaDmkp3mk47mlY7mmIDmmJXmmLvmmInmmK7mmJ7mmKTmmaXmmZfmmZnvqJLmmbPmmpnmmqDmmrLmmr/mm7rmnI7vpKnmnabmnrvmoZLmn4DmoIHmoYTmo4/vqJPmpajvqJTmppjmp6LmqLDmqavmqYbmqbPmqb7mq6Lmq6Tmr5bmsL/msZzmsobmsa/ms5rmtITmtofmta/mtpbmtqzmt4/mt7jmt7Lmt7zmuLnmuZzmuKfmuLzmur/mvojmvrXmv7XngIXngIfngKjngoXngqvnhI/nhITnhZznhYbnhYfvqJXnh4Hnh77nirFcIl0sXG5bXCJlZTQwXCIsXCLnir7njKTvqJbnjbfnjr3nj4nnj5bnj6Pnj5LnkIfnj7XnkKbnkKrnkKnnkK7nkaLnkonnkp/nlIHnla/nmoLnmpznmp7nmpvnmqbvqJfnnYbliq/noKHnoY7noaTnobrnpLDvqJjvqJnvqJrnppTvqJvnppvnq5Hnq6fvqJznq6vnrp7vqJ3ntYjntZzntrfntqDnt5bnuZLnvYfnvqHvqJ7ojIHojaLojb/oj4foj7bokYjokrTolZPolZlcIl0sXG5bXCJlZTgwXCIsXCLolavvqJ/olrDvqKDvqKHooIfoo7XoqJLoqLfoqbnoqqfoqr7oq5/vqKLoq7borZPorb/os7Dos7TotJLotbbvqKPou4/vqKTvqKXpgafpg57vqKbphJXphKfph5rph5fph57ph63ph67ph6Tph6XpiIbpiJDpiIrpiLrpiYDpiLzpiY7piZnpiZHpiLnpiafpiqfpibfpibjpi6fpi5fpi5npi5DvqKfpi5Xpi6Dpi5PpjKXpjKHpi7vvqKjpjJ7pi7/pjJ3pjILpjbDpjZfpjqTpj4bpj57pj7jpkLHpkYXpkYjplpLvp5zvqKnpmp3pmq/pnLPpnLvpnYPpnY3pnY/pnZHpnZXpoZfpoaXvqKrvqKvppKfvqKzppp7pqY7pq5npq5zprbXprbLpro/prrHprrvpsIDptbDptavvqK3puJnpu5FcIl0sXG5bXCJlZWVmXCIsXCLihbBcIiw5LFwi77+i77+k77yH77yCXCJdLFxuW1wiZjA0MFwiLFwi7oCAXCIsNjJdLFxuW1wiZjA4MFwiLFwi7oC/XCIsMTI0XSxcbltcImYxNDBcIixcIu6CvFwiLDYyXSxcbltcImYxODBcIixcIu6Du1wiLDEyNF0sXG5bXCJmMjQwXCIsXCLuhbhcIiw2Ml0sXG5bXCJmMjgwXCIsXCLuhrdcIiwxMjRdLFxuW1wiZjM0MFwiLFwi7oi0XCIsNjJdLFxuW1wiZjM4MFwiLFwi7omzXCIsMTI0XSxcbltcImY0NDBcIixcIu6LsFwiLDYyXSxcbltcImY0ODBcIixcIu6Mr1wiLDEyNF0sXG5bXCJmNTQwXCIsXCLujqxcIiw2Ml0sXG5bXCJmNTgwXCIsXCLuj6tcIiwxMjRdLFxuW1wiZjY0MFwiLFwi7pGoXCIsNjJdLFxuW1wiZjY4MFwiLFwi7pKnXCIsMTI0XSxcbltcImY3NDBcIixcIu6UpFwiLDYyXSxcbltcImY3ODBcIixcIu6Vo1wiLDEyNF0sXG5bXCJmODQwXCIsXCLul6BcIiw2Ml0sXG5bXCJmODgwXCIsXCLumJ9cIiwxMjRdLFxuW1wiZjk0MFwiLFwi7pqcXCJdLFxuW1wiZmE0MFwiLFwi4oWwXCIsOSxcIuKFoFwiLDksXCLvv6Lvv6TvvIfvvILjiLHihJbihKHiiLXnuoropJzpjYjpiojok5zkv4nngrvmmLHmo4jpi7nmm7vlvYXkuKjku6Hku7zkvIDkvIPkvLnkvZbkvpLkvorkvprkvpTkv43lgYDlgKLkv7/lgJ7lgYblgbDlgYLlgpTlg7Tlg5jlhYpcIl0sXG5bXCJmYTgwXCIsXCLlhaTlhp3lhr7lh6zliJXlipzliqbli4Dli5vljIDljIfljKTljbLljpPljrLlj53vqI7lkpzlkorlkqnlk7/lloblnZnlnaXlnqzln4jln4fvqI/vqJDlop7lorLlpIvlpZPlpZvlpZ3lpaPlpqTlprrlrZblr4DnlK/lr5jlr6zlsJ7lsqblsrrls7XltKfltZPvqJHltYLlta3ltrjltrnlt5DlvKHlvLTlvaflvrflv57mgZ3mgoXmgormg57mg5XmhKDmg7LmhJHmhLfmhLDmhpjmiJPmiqbmj7XmkaDmkp3mk47mlY7mmIDmmJXmmLvmmInmmK7mmJ7mmKTmmaXmmZfmmZnvqJLmmbPmmpnmmqDmmrLmmr/mm7rmnI7vpKnmnabmnrvmoZLmn4DmoIHmoYTmo4/vqJPmpajvqJTmppjmp6LmqLDmqavmqYbmqbPmqb7mq6Lmq6Tmr5bmsL/msZzmsobmsa/ms5rmtITmtofmta9cIl0sXG5bXCJmYjQwXCIsXCLmtpbmtqzmt4/mt7jmt7Lmt7zmuLnmuZzmuKfmuLzmur/mvojmvrXmv7XngIXngIfngKjngoXngqvnhI/nhITnhZznhYbnhYfvqJXnh4Hnh77nirHnir7njKTvqJbnjbfnjr3nj4nnj5bnj6Pnj5LnkIfnj7XnkKbnkKrnkKnnkK7nkaLnkonnkp/nlIHnla/nmoLnmpznmp7nmpvnmqbvqJfnnYbliq/noKHnoY7noaTnobrnpLDvqJjvqJlcIl0sXG5bXCJmYjgwXCIsXCLvqJrnppTvqJvnppvnq5Hnq6fvqJznq6vnrp7vqJ3ntYjntZzntrfntqDnt5bnuZLnvYfnvqHvqJ7ojIHojaLojb/oj4foj7bokYjokrTolZPolZnolavvqJ/olrDvqKDvqKHooIfoo7XoqJLoqLfoqbnoqqfoqr7oq5/vqKLoq7borZPorb/os7Dos7TotJLotbbvqKPou4/vqKTvqKXpgafpg57vqKbphJXphKfph5rph5fph57ph63ph67ph6Tph6XpiIbpiJDpiIrpiLrpiYDpiLzpiY7piZnpiZHpiLnpiafpiqfpibfpibjpi6fpi5fpi5npi5DvqKfpi5Xpi6Dpi5PpjKXpjKHpi7vvqKjpjJ7pi7/pjJ3pjILpjbDpjZfpjqTpj4bpj57pj7jpkLHpkYXpkYjplpLvp5zvqKnpmp3pmq/pnLPpnLvpnYPpnY3pnY/pnZHpnZXpoZfpoaXvqKrvqKvppKfvqKzppp7pqY7pq5lcIl0sXG5bXCJmYzQwXCIsXCLpq5zprbXprbLpro/prrHprrvpsIDptbDptavvqK3puJnpu5FcIl1cbl1cbiIsIihmdW5jdGlvbiAoQnVmZmVyKXtcblwidXNlIHN0cmljdFwiXG5cbi8vID09IFVURjE2LUJFIGNvZGVjLiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG5cbmV4cG9ydHMudXRmMTZiZSA9IFV0ZjE2QkVDb2RlYztcbmZ1bmN0aW9uIFV0ZjE2QkVDb2RlYygpIHtcbn1cblxuVXRmMTZCRUNvZGVjLnByb3RvdHlwZS5lbmNvZGVyID0gVXRmMTZCRUVuY29kZXI7XG5VdGYxNkJFQ29kZWMucHJvdG90eXBlLmRlY29kZXIgPSBVdGYxNkJFRGVjb2RlcjtcblV0ZjE2QkVDb2RlYy5wcm90b3R5cGUuYm9tQXdhcmUgPSB0cnVlO1xuXG5cbi8vIC0tIEVuY29kaW5nXG5cbmZ1bmN0aW9uIFV0ZjE2QkVFbmNvZGVyKCkge1xufVxuXG5VdGYxNkJFRW5jb2Rlci5wcm90b3R5cGUud3JpdGUgPSBmdW5jdGlvbihzdHIpIHtcbiAgICB2YXIgYnVmID0gbmV3IEJ1ZmZlcihzdHIsICd1Y3MyJyk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBidWYubGVuZ3RoOyBpICs9IDIpIHtcbiAgICAgICAgdmFyIHRtcCA9IGJ1ZltpXTsgYnVmW2ldID0gYnVmW2krMV07IGJ1ZltpKzFdID0gdG1wO1xuICAgIH1cbiAgICByZXR1cm4gYnVmO1xufVxuXG5VdGYxNkJFRW5jb2Rlci5wcm90b3R5cGUuZW5kID0gZnVuY3Rpb24oKSB7XG59XG5cblxuLy8gLS0gRGVjb2RpbmdcblxuZnVuY3Rpb24gVXRmMTZCRURlY29kZXIoKSB7XG4gICAgdGhpcy5vdmVyZmxvd0J5dGUgPSAtMTtcbn1cblxuVXRmMTZCRURlY29kZXIucHJvdG90eXBlLndyaXRlID0gZnVuY3Rpb24oYnVmKSB7XG4gICAgaWYgKGJ1Zi5sZW5ndGggPT0gMClcbiAgICAgICAgcmV0dXJuICcnO1xuXG4gICAgdmFyIGJ1ZjIgPSBuZXcgQnVmZmVyKGJ1Zi5sZW5ndGggKyAxKSxcbiAgICAgICAgaSA9IDAsIGogPSAwO1xuXG4gICAgaWYgKHRoaXMub3ZlcmZsb3dCeXRlICE9PSAtMSkge1xuICAgICAgICBidWYyWzBdID0gYnVmWzBdO1xuICAgICAgICBidWYyWzFdID0gdGhpcy5vdmVyZmxvd0J5dGU7XG4gICAgICAgIGkgPSAxOyBqID0gMjtcbiAgICB9XG5cbiAgICBmb3IgKDsgaSA8IGJ1Zi5sZW5ndGgtMTsgaSArPSAyLCBqKz0gMikge1xuICAgICAgICBidWYyW2pdID0gYnVmW2krMV07XG4gICAgICAgIGJ1ZjJbaisxXSA9IGJ1ZltpXTtcbiAgICB9XG5cbiAgICB0aGlzLm92ZXJmbG93Qnl0ZSA9IChpID09IGJ1Zi5sZW5ndGgtMSkgPyBidWZbYnVmLmxlbmd0aC0xXSA6IC0xO1xuXG4gICAgcmV0dXJuIGJ1ZjIuc2xpY2UoMCwgaikudG9TdHJpbmcoJ3VjczInKTtcbn1cblxuVXRmMTZCRURlY29kZXIucHJvdG90eXBlLmVuZCA9IGZ1bmN0aW9uKCkge1xufVxuXG5cbi8vID09IFVURi0xNiBjb2RlYyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4vLyBEZWNvZGVyIGNob29zZXMgYXV0b21hdGljYWxseSBmcm9tIFVURi0xNkxFIGFuZCBVVEYtMTZCRSB1c2luZyBCT00gYW5kIHNwYWNlLWJhc2VkIGhldXJpc3RpYy5cbi8vIERlZmF1bHRzIHRvIFVURi0xNkxFLCBhcyBpdCdzIHByZXZhbGVudCBhbmQgZGVmYXVsdCBpbiBOb2RlLlxuLy8gaHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9VVEYtMTYgYW5kIGh0dHA6Ly9lbmNvZGluZy5zcGVjLndoYXR3Zy5vcmcvI3V0Zi0xNmxlXG4vLyBEZWNvZGVyIGRlZmF1bHQgY2FuIGJlIGNoYW5nZWQ6IGljb252LmRlY29kZShidWYsICd1dGYxNicsIHtkZWZhdWx0RW5jb2Rpbmc6ICd1dGYtMTZiZSd9KTtcblxuLy8gRW5jb2RlciB1c2VzIFVURi0xNkxFIGFuZCBwcmVwZW5kcyBCT00gKHdoaWNoIGNhbiBiZSBvdmVycmlkZGVuIHdpdGggYWRkQk9NOiBmYWxzZSkuXG5cbmV4cG9ydHMudXRmMTYgPSBVdGYxNkNvZGVjO1xuZnVuY3Rpb24gVXRmMTZDb2RlYyhjb2RlY09wdGlvbnMsIGljb252KSB7XG4gICAgdGhpcy5pY29udiA9IGljb252O1xufVxuXG5VdGYxNkNvZGVjLnByb3RvdHlwZS5lbmNvZGVyID0gVXRmMTZFbmNvZGVyO1xuVXRmMTZDb2RlYy5wcm90b3R5cGUuZGVjb2RlciA9IFV0ZjE2RGVjb2RlcjtcblxuXG4vLyAtLSBFbmNvZGluZyAocGFzcy10aHJvdWdoKVxuXG5mdW5jdGlvbiBVdGYxNkVuY29kZXIob3B0aW9ucywgY29kZWMpIHtcbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgICBpZiAob3B0aW9ucy5hZGRCT00gPT09IHVuZGVmaW5lZClcbiAgICAgICAgb3B0aW9ucy5hZGRCT00gPSB0cnVlO1xuICAgIHRoaXMuZW5jb2RlciA9IGNvZGVjLmljb252LmdldEVuY29kZXIoJ3V0Zi0xNmxlJywgb3B0aW9ucyk7XG59XG5cblV0ZjE2RW5jb2Rlci5wcm90b3R5cGUud3JpdGUgPSBmdW5jdGlvbihzdHIpIHtcbiAgICByZXR1cm4gdGhpcy5lbmNvZGVyLndyaXRlKHN0cik7XG59XG5cblV0ZjE2RW5jb2Rlci5wcm90b3R5cGUuZW5kID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMuZW5jb2Rlci5lbmQoKTtcbn1cblxuXG4vLyAtLSBEZWNvZGluZ1xuXG5mdW5jdGlvbiBVdGYxNkRlY29kZXIob3B0aW9ucywgY29kZWMpIHtcbiAgICB0aGlzLmRlY29kZXIgPSBudWxsO1xuICAgIHRoaXMuaW5pdGlhbEJ5dGVzID0gW107XG4gICAgdGhpcy5pbml0aWFsQnl0ZXNMZW4gPSAwO1xuXG4gICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgICB0aGlzLmljb252ID0gY29kZWMuaWNvbnY7XG59XG5cblV0ZjE2RGVjb2Rlci5wcm90b3R5cGUud3JpdGUgPSBmdW5jdGlvbihidWYpIHtcbiAgICBpZiAoIXRoaXMuZGVjb2Rlcikge1xuICAgICAgICAvLyBDb2RlYyBpcyBub3QgY2hvc2VuIHlldC4gQWNjdW11bGF0ZSBpbml0aWFsIGJ5dGVzLlxuICAgICAgICB0aGlzLmluaXRpYWxCeXRlcy5wdXNoKGJ1Zik7XG4gICAgICAgIHRoaXMuaW5pdGlhbEJ5dGVzTGVuICs9IGJ1Zi5sZW5ndGg7XG4gICAgICAgIFxuICAgICAgICBpZiAodGhpcy5pbml0aWFsQnl0ZXNMZW4gPCAxNikgLy8gV2UgbmVlZCBtb3JlIGJ5dGVzIHRvIHVzZSBzcGFjZSBoZXVyaXN0aWMgKHNlZSBiZWxvdylcbiAgICAgICAgICAgIHJldHVybiAnJztcblxuICAgICAgICAvLyBXZSBoYXZlIGVub3VnaCBieXRlcyAtPiBkZXRlY3QgZW5kaWFubmVzcy5cbiAgICAgICAgdmFyIGJ1ZiA9IEJ1ZmZlci5jb25jYXQodGhpcy5pbml0aWFsQnl0ZXMpLFxuICAgICAgICAgICAgZW5jb2RpbmcgPSBkZXRlY3RFbmNvZGluZyhidWYsIHRoaXMub3B0aW9ucy5kZWZhdWx0RW5jb2RpbmcpO1xuICAgICAgICB0aGlzLmRlY29kZXIgPSB0aGlzLmljb252LmdldERlY29kZXIoZW5jb2RpbmcsIHRoaXMub3B0aW9ucyk7XG4gICAgICAgIHRoaXMuaW5pdGlhbEJ5dGVzLmxlbmd0aCA9IHRoaXMuaW5pdGlhbEJ5dGVzTGVuID0gMDtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5kZWNvZGVyLndyaXRlKGJ1Zik7XG59XG5cblV0ZjE2RGVjb2Rlci5wcm90b3R5cGUuZW5kID0gZnVuY3Rpb24oKSB7XG4gICAgaWYgKCF0aGlzLmRlY29kZXIpIHtcbiAgICAgICAgdmFyIGJ1ZiA9IEJ1ZmZlci5jb25jYXQodGhpcy5pbml0aWFsQnl0ZXMpLFxuICAgICAgICAgICAgZW5jb2RpbmcgPSBkZXRlY3RFbmNvZGluZyhidWYsIHRoaXMub3B0aW9ucy5kZWZhdWx0RW5jb2RpbmcpO1xuICAgICAgICB0aGlzLmRlY29kZXIgPSB0aGlzLmljb252LmdldERlY29kZXIoZW5jb2RpbmcsIHRoaXMub3B0aW9ucyk7XG5cbiAgICAgICAgdmFyIHJlcyA9IHRoaXMuZGVjb2Rlci53cml0ZShidWYpLFxuICAgICAgICAgICAgdHJhaWwgPSB0aGlzLmRlY29kZXIuZW5kKCk7XG5cbiAgICAgICAgcmV0dXJuIHRyYWlsID8gKHJlcyArIHRyYWlsKSA6IHJlcztcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuZGVjb2Rlci5lbmQoKTtcbn1cblxuZnVuY3Rpb24gZGV0ZWN0RW5jb2RpbmcoYnVmLCBkZWZhdWx0RW5jb2RpbmcpIHtcbiAgICB2YXIgZW5jID0gZGVmYXVsdEVuY29kaW5nIHx8ICd1dGYtMTZsZSc7XG5cbiAgICBpZiAoYnVmLmxlbmd0aCA+PSAyKSB7XG4gICAgICAgIC8vIENoZWNrIEJPTS5cbiAgICAgICAgaWYgKGJ1ZlswXSA9PSAweEZFICYmIGJ1ZlsxXSA9PSAweEZGKSAvLyBVVEYtMTZCRSBCT01cbiAgICAgICAgICAgIGVuYyA9ICd1dGYtMTZiZSc7XG4gICAgICAgIGVsc2UgaWYgKGJ1ZlswXSA9PSAweEZGICYmIGJ1ZlsxXSA9PSAweEZFKSAvLyBVVEYtMTZMRSBCT01cbiAgICAgICAgICAgIGVuYyA9ICd1dGYtMTZsZSc7XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gTm8gQk9NIGZvdW5kLiBUcnkgdG8gZGVkdWNlIGVuY29kaW5nIGZyb20gaW5pdGlhbCBjb250ZW50LlxuICAgICAgICAgICAgLy8gTW9zdCBvZiB0aGUgdGltZSwgdGhlIGNvbnRlbnQgaGFzIEFTQ0lJIGNoYXJzIChVKzAwKiopLCBidXQgdGhlIG9wcG9zaXRlIChVKyoqMDApIGlzIHVuY29tbW9uLlxuICAgICAgICAgICAgLy8gU28sIHdlIGNvdW50IEFTQ0lJIGFzIGlmIGl0IHdhcyBMRSBvciBCRSwgYW5kIGRlY2lkZSBmcm9tIHRoYXQuXG4gICAgICAgICAgICB2YXIgYXNjaWlDaGFyc0xFID0gMCwgYXNjaWlDaGFyc0JFID0gMCwgLy8gQ291bnRzIG9mIGNoYXJzIGluIGJvdGggcG9zaXRpb25zXG4gICAgICAgICAgICAgICAgX2xlbiA9IE1hdGgubWluKGJ1Zi5sZW5ndGggLSAoYnVmLmxlbmd0aCAlIDIpLCA2NCk7IC8vIExlbiBpcyBhbHdheXMgZXZlbi5cblxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBfbGVuOyBpICs9IDIpIHtcbiAgICAgICAgICAgICAgICBpZiAoYnVmW2ldID09PSAwICYmIGJ1ZltpKzFdICE9PSAwKSBhc2NpaUNoYXJzQkUrKztcbiAgICAgICAgICAgICAgICBpZiAoYnVmW2ldICE9PSAwICYmIGJ1ZltpKzFdID09PSAwKSBhc2NpaUNoYXJzTEUrKztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGFzY2lpQ2hhcnNCRSA+IGFzY2lpQ2hhcnNMRSlcbiAgICAgICAgICAgICAgICBlbmMgPSAndXRmLTE2YmUnO1xuICAgICAgICAgICAgZWxzZSBpZiAoYXNjaWlDaGFyc0JFIDwgYXNjaWlDaGFyc0xFKVxuICAgICAgICAgICAgICAgIGVuYyA9ICd1dGYtMTZsZSc7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gZW5jO1xufVxuXG5cblxufSkuY2FsbCh0aGlzLHJlcXVpcmUoXCJidWZmZXJcIikuQnVmZmVyKSIsIihmdW5jdGlvbiAoQnVmZmVyKXtcblwidXNlIHN0cmljdFwiXG5cbi8vIFVURi03IGNvZGVjLCBhY2NvcmRpbmcgdG8gaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzIxNTJcbi8vIFNlZSBhbHNvIGJlbG93IGEgVVRGLTctSU1BUCBjb2RlYywgYWNjb3JkaW5nIHRvIGh0dHA6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzM1MDEjc2VjdGlvbi01LjEuM1xuXG5leHBvcnRzLnV0ZjcgPSBVdGY3Q29kZWM7XG5leHBvcnRzLnVuaWNvZGUxMXV0ZjcgPSAndXRmNyc7IC8vIEFsaWFzIFVOSUNPREUtMS0xLVVURi03XG5mdW5jdGlvbiBVdGY3Q29kZWMoY29kZWNPcHRpb25zLCBpY29udikge1xuICAgIHRoaXMuaWNvbnYgPSBpY29udjtcbn07XG5cblV0ZjdDb2RlYy5wcm90b3R5cGUuZW5jb2RlciA9IFV0ZjdFbmNvZGVyO1xuVXRmN0NvZGVjLnByb3RvdHlwZS5kZWNvZGVyID0gVXRmN0RlY29kZXI7XG5VdGY3Q29kZWMucHJvdG90eXBlLmJvbUF3YXJlID0gdHJ1ZTtcblxuXG4vLyAtLSBFbmNvZGluZ1xuXG52YXIgbm9uRGlyZWN0Q2hhcnMgPSAvW15BLVphLXowLTknXFwoXFwpLC1cXC5cXC86XFw/IFxcblxcclxcdF0rL2c7XG5cbmZ1bmN0aW9uIFV0ZjdFbmNvZGVyKG9wdGlvbnMsIGNvZGVjKSB7XG4gICAgdGhpcy5pY29udiA9IGNvZGVjLmljb252O1xufVxuXG5VdGY3RW5jb2Rlci5wcm90b3R5cGUud3JpdGUgPSBmdW5jdGlvbihzdHIpIHtcbiAgICAvLyBOYWl2ZSBpbXBsZW1lbnRhdGlvbi5cbiAgICAvLyBOb24tZGlyZWN0IGNoYXJzIGFyZSBlbmNvZGVkIGFzIFwiKzxiYXNlNjQ+LVwiOyBzaW5nbGUgXCIrXCIgY2hhciBpcyBlbmNvZGVkIGFzIFwiKy1cIi5cbiAgICByZXR1cm4gbmV3IEJ1ZmZlcihzdHIucmVwbGFjZShub25EaXJlY3RDaGFycywgZnVuY3Rpb24oY2h1bmspIHtcbiAgICAgICAgcmV0dXJuIFwiK1wiICsgKGNodW5rID09PSAnKycgPyAnJyA6IFxuICAgICAgICAgICAgdGhpcy5pY29udi5lbmNvZGUoY2h1bmssICd1dGYxNi1iZScpLnRvU3RyaW5nKCdiYXNlNjQnKS5yZXBsYWNlKC89KyQvLCAnJykpIFxuICAgICAgICAgICAgKyBcIi1cIjtcbiAgICB9LmJpbmQodGhpcykpKTtcbn1cblxuVXRmN0VuY29kZXIucHJvdG90eXBlLmVuZCA9IGZ1bmN0aW9uKCkge1xufVxuXG5cbi8vIC0tIERlY29kaW5nXG5cbmZ1bmN0aW9uIFV0ZjdEZWNvZGVyKG9wdGlvbnMsIGNvZGVjKSB7XG4gICAgdGhpcy5pY29udiA9IGNvZGVjLmljb252O1xuICAgIHRoaXMuaW5CYXNlNjQgPSBmYWxzZTtcbiAgICB0aGlzLmJhc2U2NEFjY3VtID0gJyc7XG59XG5cbnZhciBiYXNlNjRSZWdleCA9IC9bQS1aYS16MC05XFwvK10vO1xudmFyIGJhc2U2NENoYXJzID0gW107XG5mb3IgKHZhciBpID0gMDsgaSA8IDI1NjsgaSsrKVxuICAgIGJhc2U2NENoYXJzW2ldID0gYmFzZTY0UmVnZXgudGVzdChTdHJpbmcuZnJvbUNoYXJDb2RlKGkpKTtcblxudmFyIHBsdXNDaGFyID0gJysnLmNoYXJDb2RlQXQoMCksIFxuICAgIG1pbnVzQ2hhciA9ICctJy5jaGFyQ29kZUF0KDApLFxuICAgIGFuZENoYXIgPSAnJicuY2hhckNvZGVBdCgwKTtcblxuVXRmN0RlY29kZXIucHJvdG90eXBlLndyaXRlID0gZnVuY3Rpb24oYnVmKSB7XG4gICAgdmFyIHJlcyA9IFwiXCIsIGxhc3RJID0gMCxcbiAgICAgICAgaW5CYXNlNjQgPSB0aGlzLmluQmFzZTY0LFxuICAgICAgICBiYXNlNjRBY2N1bSA9IHRoaXMuYmFzZTY0QWNjdW07XG5cbiAgICAvLyBUaGUgZGVjb2RlciBpcyBtb3JlIGludm9sdmVkIGFzIHdlIG11c3QgaGFuZGxlIGNodW5rcyBpbiBzdHJlYW0uXG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGJ1Zi5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAoIWluQmFzZTY0KSB7IC8vIFdlJ3JlIGluIGRpcmVjdCBtb2RlLlxuICAgICAgICAgICAgLy8gV3JpdGUgZGlyZWN0IGNoYXJzIHVudGlsICcrJ1xuICAgICAgICAgICAgaWYgKGJ1ZltpXSA9PSBwbHVzQ2hhcikge1xuICAgICAgICAgICAgICAgIHJlcyArPSB0aGlzLmljb252LmRlY29kZShidWYuc2xpY2UobGFzdEksIGkpLCBcImFzY2lpXCIpOyAvLyBXcml0ZSBkaXJlY3QgY2hhcnMuXG4gICAgICAgICAgICAgICAgbGFzdEkgPSBpKzE7XG4gICAgICAgICAgICAgICAgaW5CYXNlNjQgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgeyAvLyBXZSBkZWNvZGUgYmFzZTY0LlxuICAgICAgICAgICAgaWYgKCFiYXNlNjRDaGFyc1tidWZbaV1dKSB7IC8vIEJhc2U2NCBlbmRlZC5cbiAgICAgICAgICAgICAgICBpZiAoaSA9PSBsYXN0SSAmJiBidWZbaV0gPT0gbWludXNDaGFyKSB7Ly8gXCIrLVwiIC0+IFwiK1wiXG4gICAgICAgICAgICAgICAgICAgIHJlcyArPSBcIitcIjtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB2YXIgYjY0c3RyID0gYmFzZTY0QWNjdW0gKyBidWYuc2xpY2UobGFzdEksIGkpLnRvU3RyaW5nKCk7XG4gICAgICAgICAgICAgICAgICAgIHJlcyArPSB0aGlzLmljb252LmRlY29kZShuZXcgQnVmZmVyKGI2NHN0ciwgJ2Jhc2U2NCcpLCBcInV0ZjE2LWJlXCIpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmIChidWZbaV0gIT0gbWludXNDaGFyKSAvLyBNaW51cyBpcyBhYnNvcmJlZCBhZnRlciBiYXNlNjQuXG4gICAgICAgICAgICAgICAgICAgIGktLTtcblxuICAgICAgICAgICAgICAgIGxhc3RJID0gaSsxO1xuICAgICAgICAgICAgICAgIGluQmFzZTY0ID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgYmFzZTY0QWNjdW0gPSAnJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIGlmICghaW5CYXNlNjQpIHtcbiAgICAgICAgcmVzICs9IHRoaXMuaWNvbnYuZGVjb2RlKGJ1Zi5zbGljZShsYXN0SSksIFwiYXNjaWlcIik7IC8vIFdyaXRlIGRpcmVjdCBjaGFycy5cbiAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgYjY0c3RyID0gYmFzZTY0QWNjdW0gKyBidWYuc2xpY2UobGFzdEkpLnRvU3RyaW5nKCk7XG5cbiAgICAgICAgdmFyIGNhbkJlRGVjb2RlZCA9IGI2NHN0ci5sZW5ndGggLSAoYjY0c3RyLmxlbmd0aCAlIDgpOyAvLyBNaW5pbWFsIGNodW5rOiAyIHF1YWRzIC0+IDJ4MyBieXRlcyAtPiAzIGNoYXJzLlxuICAgICAgICBiYXNlNjRBY2N1bSA9IGI2NHN0ci5zbGljZShjYW5CZURlY29kZWQpOyAvLyBUaGUgcmVzdCB3aWxsIGJlIGRlY29kZWQgaW4gZnV0dXJlLlxuICAgICAgICBiNjRzdHIgPSBiNjRzdHIuc2xpY2UoMCwgY2FuQmVEZWNvZGVkKTtcblxuICAgICAgICByZXMgKz0gdGhpcy5pY29udi5kZWNvZGUobmV3IEJ1ZmZlcihiNjRzdHIsICdiYXNlNjQnKSwgXCJ1dGYxNi1iZVwiKTtcbiAgICB9XG5cbiAgICB0aGlzLmluQmFzZTY0ID0gaW5CYXNlNjQ7XG4gICAgdGhpcy5iYXNlNjRBY2N1bSA9IGJhc2U2NEFjY3VtO1xuXG4gICAgcmV0dXJuIHJlcztcbn1cblxuVXRmN0RlY29kZXIucHJvdG90eXBlLmVuZCA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciByZXMgPSBcIlwiO1xuICAgIGlmICh0aGlzLmluQmFzZTY0ICYmIHRoaXMuYmFzZTY0QWNjdW0ubGVuZ3RoID4gMClcbiAgICAgICAgcmVzID0gdGhpcy5pY29udi5kZWNvZGUobmV3IEJ1ZmZlcih0aGlzLmJhc2U2NEFjY3VtLCAnYmFzZTY0JyksIFwidXRmMTYtYmVcIik7XG5cbiAgICB0aGlzLmluQmFzZTY0ID0gZmFsc2U7XG4gICAgdGhpcy5iYXNlNjRBY2N1bSA9ICcnO1xuICAgIHJldHVybiByZXM7XG59XG5cblxuLy8gVVRGLTctSU1BUCBjb2RlYy5cbi8vIFJGQzM1MDEgU2VjLiA1LjEuMyBNb2RpZmllZCBVVEYtNyAoaHR0cDovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjMzUwMSNzZWN0aW9uLTUuMS4zKVxuLy8gRGlmZmVyZW5jZXM6XG4vLyAgKiBCYXNlNjQgcGFydCBpcyBzdGFydGVkIGJ5IFwiJlwiIGluc3RlYWQgb2YgXCIrXCJcbi8vICAqIERpcmVjdCBjaGFyYWN0ZXJzIGFyZSAweDIwLTB4N0UsIGV4Y2VwdCBcIiZcIiAoMHgyNilcbi8vICAqIEluIEJhc2U2NCwgXCIsXCIgaXMgdXNlZCBpbnN0ZWFkIG9mIFwiL1wiXG4vLyAgKiBCYXNlNjQgbXVzdCBub3QgYmUgdXNlZCB0byByZXByZXNlbnQgZGlyZWN0IGNoYXJhY3RlcnMuXG4vLyAgKiBObyBpbXBsaWNpdCBzaGlmdCBiYWNrIGZyb20gQmFzZTY0IChzaG91bGQgYWx3YXlzIGVuZCB3aXRoICctJylcbi8vICAqIFN0cmluZyBtdXN0IGVuZCBpbiBub24tc2hpZnRlZCBwb3NpdGlvbi5cbi8vICAqIFwiLSZcIiB3aGlsZSBpbiBiYXNlNjQgaXMgbm90IGFsbG93ZWQuXG5cblxuZXhwb3J0cy51dGY3aW1hcCA9IFV0ZjdJTUFQQ29kZWM7XG5mdW5jdGlvbiBVdGY3SU1BUENvZGVjKGNvZGVjT3B0aW9ucywgaWNvbnYpIHtcbiAgICB0aGlzLmljb252ID0gaWNvbnY7XG59O1xuXG5VdGY3SU1BUENvZGVjLnByb3RvdHlwZS5lbmNvZGVyID0gVXRmN0lNQVBFbmNvZGVyO1xuVXRmN0lNQVBDb2RlYy5wcm90b3R5cGUuZGVjb2RlciA9IFV0ZjdJTUFQRGVjb2RlcjtcblV0ZjdJTUFQQ29kZWMucHJvdG90eXBlLmJvbUF3YXJlID0gdHJ1ZTtcblxuXG4vLyAtLSBFbmNvZGluZ1xuXG5mdW5jdGlvbiBVdGY3SU1BUEVuY29kZXIob3B0aW9ucywgY29kZWMpIHtcbiAgICB0aGlzLmljb252ID0gY29kZWMuaWNvbnY7XG4gICAgdGhpcy5pbkJhc2U2NCA9IGZhbHNlO1xuICAgIHRoaXMuYmFzZTY0QWNjdW0gPSBuZXcgQnVmZmVyKDYpO1xuICAgIHRoaXMuYmFzZTY0QWNjdW1JZHggPSAwO1xufVxuXG5VdGY3SU1BUEVuY29kZXIucHJvdG90eXBlLndyaXRlID0gZnVuY3Rpb24oc3RyKSB7XG4gICAgdmFyIGluQmFzZTY0ID0gdGhpcy5pbkJhc2U2NCxcbiAgICAgICAgYmFzZTY0QWNjdW0gPSB0aGlzLmJhc2U2NEFjY3VtLFxuICAgICAgICBiYXNlNjRBY2N1bUlkeCA9IHRoaXMuYmFzZTY0QWNjdW1JZHgsXG4gICAgICAgIGJ1ZiA9IG5ldyBCdWZmZXIoc3RyLmxlbmd0aCo1ICsgMTApLCBidWZJZHggPSAwO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdHIubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIHVDaGFyID0gc3RyLmNoYXJDb2RlQXQoaSk7XG4gICAgICAgIGlmICgweDIwIDw9IHVDaGFyICYmIHVDaGFyIDw9IDB4N0UpIHsgLy8gRGlyZWN0IGNoYXJhY3RlciBvciAnJicuXG4gICAgICAgICAgICBpZiAoaW5CYXNlNjQpIHtcbiAgICAgICAgICAgICAgICBpZiAoYmFzZTY0QWNjdW1JZHggPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGJ1ZklkeCArPSBidWYud3JpdGUoYmFzZTY0QWNjdW0uc2xpY2UoMCwgYmFzZTY0QWNjdW1JZHgpLnRvU3RyaW5nKCdiYXNlNjQnKS5yZXBsYWNlKC9cXC8vZywgJywnKS5yZXBsYWNlKC89KyQvLCAnJyksIGJ1ZklkeCk7XG4gICAgICAgICAgICAgICAgICAgIGJhc2U2NEFjY3VtSWR4ID0gMDtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBidWZbYnVmSWR4KytdID0gbWludXNDaGFyOyAvLyBXcml0ZSAnLScsIHRoZW4gZ28gdG8gZGlyZWN0IG1vZGUuXG4gICAgICAgICAgICAgICAgaW5CYXNlNjQgPSBmYWxzZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKCFpbkJhc2U2NCkge1xuICAgICAgICAgICAgICAgIGJ1ZltidWZJZHgrK10gPSB1Q2hhcjsgLy8gV3JpdGUgZGlyZWN0IGNoYXJhY3RlclxuXG4gICAgICAgICAgICAgICAgaWYgKHVDaGFyID09PSBhbmRDaGFyKSAgLy8gQW1wZXJzYW5kIC0+ICcmLSdcbiAgICAgICAgICAgICAgICAgICAgYnVmW2J1ZklkeCsrXSA9IG1pbnVzQ2hhcjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICB9IGVsc2UgeyAvLyBOb24tZGlyZWN0IGNoYXJhY3RlclxuICAgICAgICAgICAgaWYgKCFpbkJhc2U2NCkge1xuICAgICAgICAgICAgICAgIGJ1ZltidWZJZHgrK10gPSBhbmRDaGFyOyAvLyBXcml0ZSAnJicsIHRoZW4gZ28gdG8gYmFzZTY0IG1vZGUuXG4gICAgICAgICAgICAgICAgaW5CYXNlNjQgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGluQmFzZTY0KSB7XG4gICAgICAgICAgICAgICAgYmFzZTY0QWNjdW1bYmFzZTY0QWNjdW1JZHgrK10gPSB1Q2hhciA+PiA4O1xuICAgICAgICAgICAgICAgIGJhc2U2NEFjY3VtW2Jhc2U2NEFjY3VtSWR4KytdID0gdUNoYXIgJiAweEZGO1xuXG4gICAgICAgICAgICAgICAgaWYgKGJhc2U2NEFjY3VtSWR4ID09IGJhc2U2NEFjY3VtLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICBidWZJZHggKz0gYnVmLndyaXRlKGJhc2U2NEFjY3VtLnRvU3RyaW5nKCdiYXNlNjQnKS5yZXBsYWNlKC9cXC8vZywgJywnKSwgYnVmSWR4KTtcbiAgICAgICAgICAgICAgICAgICAgYmFzZTY0QWNjdW1JZHggPSAwO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIHRoaXMuaW5CYXNlNjQgPSBpbkJhc2U2NDtcbiAgICB0aGlzLmJhc2U2NEFjY3VtSWR4ID0gYmFzZTY0QWNjdW1JZHg7XG5cbiAgICByZXR1cm4gYnVmLnNsaWNlKDAsIGJ1ZklkeCk7XG59XG5cblV0ZjdJTUFQRW5jb2Rlci5wcm90b3R5cGUuZW5kID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIGJ1ZiA9IG5ldyBCdWZmZXIoMTApLCBidWZJZHggPSAwO1xuICAgIGlmICh0aGlzLmluQmFzZTY0KSB7XG4gICAgICAgIGlmICh0aGlzLmJhc2U2NEFjY3VtSWR4ID4gMCkge1xuICAgICAgICAgICAgYnVmSWR4ICs9IGJ1Zi53cml0ZSh0aGlzLmJhc2U2NEFjY3VtLnNsaWNlKDAsIHRoaXMuYmFzZTY0QWNjdW1JZHgpLnRvU3RyaW5nKCdiYXNlNjQnKS5yZXBsYWNlKC9cXC8vZywgJywnKS5yZXBsYWNlKC89KyQvLCAnJyksIGJ1ZklkeCk7XG4gICAgICAgICAgICB0aGlzLmJhc2U2NEFjY3VtSWR4ID0gMDtcbiAgICAgICAgfVxuXG4gICAgICAgIGJ1ZltidWZJZHgrK10gPSBtaW51c0NoYXI7IC8vIFdyaXRlICctJywgdGhlbiBnbyB0byBkaXJlY3QgbW9kZS5cbiAgICAgICAgdGhpcy5pbkJhc2U2NCA9IGZhbHNlO1xuICAgIH1cblxuICAgIHJldHVybiBidWYuc2xpY2UoMCwgYnVmSWR4KTtcbn1cblxuXG4vLyAtLSBEZWNvZGluZ1xuXG5mdW5jdGlvbiBVdGY3SU1BUERlY29kZXIob3B0aW9ucywgY29kZWMpIHtcbiAgICB0aGlzLmljb252ID0gY29kZWMuaWNvbnY7XG4gICAgdGhpcy5pbkJhc2U2NCA9IGZhbHNlO1xuICAgIHRoaXMuYmFzZTY0QWNjdW0gPSAnJztcbn1cblxudmFyIGJhc2U2NElNQVBDaGFycyA9IGJhc2U2NENoYXJzLnNsaWNlKCk7XG5iYXNlNjRJTUFQQ2hhcnNbJywnLmNoYXJDb2RlQXQoMCldID0gdHJ1ZTtcblxuVXRmN0lNQVBEZWNvZGVyLnByb3RvdHlwZS53cml0ZSA9IGZ1bmN0aW9uKGJ1Zikge1xuICAgIHZhciByZXMgPSBcIlwiLCBsYXN0SSA9IDAsXG4gICAgICAgIGluQmFzZTY0ID0gdGhpcy5pbkJhc2U2NCxcbiAgICAgICAgYmFzZTY0QWNjdW0gPSB0aGlzLmJhc2U2NEFjY3VtO1xuXG4gICAgLy8gVGhlIGRlY29kZXIgaXMgbW9yZSBpbnZvbHZlZCBhcyB3ZSBtdXN0IGhhbmRsZSBjaHVua3MgaW4gc3RyZWFtLlxuICAgIC8vIEl0IGlzIGZvcmdpdmluZywgY2xvc2VyIHRvIHN0YW5kYXJkIFVURi03IChmb3IgZXhhbXBsZSwgJy0nIGlzIG9wdGlvbmFsIGF0IHRoZSBlbmQpLlxuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBidWYubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKCFpbkJhc2U2NCkgeyAvLyBXZSdyZSBpbiBkaXJlY3QgbW9kZS5cbiAgICAgICAgICAgIC8vIFdyaXRlIGRpcmVjdCBjaGFycyB1bnRpbCAnJidcbiAgICAgICAgICAgIGlmIChidWZbaV0gPT0gYW5kQ2hhcikge1xuICAgICAgICAgICAgICAgIHJlcyArPSB0aGlzLmljb252LmRlY29kZShidWYuc2xpY2UobGFzdEksIGkpLCBcImFzY2lpXCIpOyAvLyBXcml0ZSBkaXJlY3QgY2hhcnMuXG4gICAgICAgICAgICAgICAgbGFzdEkgPSBpKzE7XG4gICAgICAgICAgICAgICAgaW5CYXNlNjQgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgeyAvLyBXZSBkZWNvZGUgYmFzZTY0LlxuICAgICAgICAgICAgaWYgKCFiYXNlNjRJTUFQQ2hhcnNbYnVmW2ldXSkgeyAvLyBCYXNlNjQgZW5kZWQuXG4gICAgICAgICAgICAgICAgaWYgKGkgPT0gbGFzdEkgJiYgYnVmW2ldID09IG1pbnVzQ2hhcikgeyAvLyBcIiYtXCIgLT4gXCImXCJcbiAgICAgICAgICAgICAgICAgICAgcmVzICs9IFwiJlwiO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBiNjRzdHIgPSBiYXNlNjRBY2N1bSArIGJ1Zi5zbGljZShsYXN0SSwgaSkudG9TdHJpbmcoKS5yZXBsYWNlKC8sL2csICcvJyk7XG4gICAgICAgICAgICAgICAgICAgIHJlcyArPSB0aGlzLmljb252LmRlY29kZShuZXcgQnVmZmVyKGI2NHN0ciwgJ2Jhc2U2NCcpLCBcInV0ZjE2LWJlXCIpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmIChidWZbaV0gIT0gbWludXNDaGFyKSAvLyBNaW51cyBtYXkgYmUgYWJzb3JiZWQgYWZ0ZXIgYmFzZTY0LlxuICAgICAgICAgICAgICAgICAgICBpLS07XG5cbiAgICAgICAgICAgICAgICBsYXN0SSA9IGkrMTtcbiAgICAgICAgICAgICAgICBpbkJhc2U2NCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIGJhc2U2NEFjY3VtID0gJyc7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoIWluQmFzZTY0KSB7XG4gICAgICAgIHJlcyArPSB0aGlzLmljb252LmRlY29kZShidWYuc2xpY2UobGFzdEkpLCBcImFzY2lpXCIpOyAvLyBXcml0ZSBkaXJlY3QgY2hhcnMuXG4gICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIGI2NHN0ciA9IGJhc2U2NEFjY3VtICsgYnVmLnNsaWNlKGxhc3RJKS50b1N0cmluZygpLnJlcGxhY2UoLywvZywgJy8nKTtcblxuICAgICAgICB2YXIgY2FuQmVEZWNvZGVkID0gYjY0c3RyLmxlbmd0aCAtIChiNjRzdHIubGVuZ3RoICUgOCk7IC8vIE1pbmltYWwgY2h1bms6IDIgcXVhZHMgLT4gMngzIGJ5dGVzIC0+IDMgY2hhcnMuXG4gICAgICAgIGJhc2U2NEFjY3VtID0gYjY0c3RyLnNsaWNlKGNhbkJlRGVjb2RlZCk7IC8vIFRoZSByZXN0IHdpbGwgYmUgZGVjb2RlZCBpbiBmdXR1cmUuXG4gICAgICAgIGI2NHN0ciA9IGI2NHN0ci5zbGljZSgwLCBjYW5CZURlY29kZWQpO1xuXG4gICAgICAgIHJlcyArPSB0aGlzLmljb252LmRlY29kZShuZXcgQnVmZmVyKGI2NHN0ciwgJ2Jhc2U2NCcpLCBcInV0ZjE2LWJlXCIpO1xuICAgIH1cblxuICAgIHRoaXMuaW5CYXNlNjQgPSBpbkJhc2U2NDtcbiAgICB0aGlzLmJhc2U2NEFjY3VtID0gYmFzZTY0QWNjdW07XG5cbiAgICByZXR1cm4gcmVzO1xufVxuXG5VdGY3SU1BUERlY29kZXIucHJvdG90eXBlLmVuZCA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciByZXMgPSBcIlwiO1xuICAgIGlmICh0aGlzLmluQmFzZTY0ICYmIHRoaXMuYmFzZTY0QWNjdW0ubGVuZ3RoID4gMClcbiAgICAgICAgcmVzID0gdGhpcy5pY29udi5kZWNvZGUobmV3IEJ1ZmZlcih0aGlzLmJhc2U2NEFjY3VtLCAnYmFzZTY0JyksIFwidXRmMTYtYmVcIik7XG5cbiAgICB0aGlzLmluQmFzZTY0ID0gZmFsc2U7XG4gICAgdGhpcy5iYXNlNjRBY2N1bSA9ICcnO1xuICAgIHJldHVybiByZXM7XG59XG5cblxuXG59KS5jYWxsKHRoaXMscmVxdWlyZShcImJ1ZmZlclwiKS5CdWZmZXIpIiwiXCJ1c2Ugc3RyaWN0XCJcblxudmFyIEJPTUNoYXIgPSAnXFx1RkVGRic7XG5cbmV4cG9ydHMuUHJlcGVuZEJPTSA9IFByZXBlbmRCT01XcmFwcGVyXG5mdW5jdGlvbiBQcmVwZW5kQk9NV3JhcHBlcihlbmNvZGVyLCBvcHRpb25zKSB7XG4gICAgdGhpcy5lbmNvZGVyID0gZW5jb2RlcjtcbiAgICB0aGlzLmFkZEJPTSA9IHRydWU7XG59XG5cblByZXBlbmRCT01XcmFwcGVyLnByb3RvdHlwZS53cml0ZSA9IGZ1bmN0aW9uKHN0cikge1xuICAgIGlmICh0aGlzLmFkZEJPTSkge1xuICAgICAgICBzdHIgPSBCT01DaGFyICsgc3RyO1xuICAgICAgICB0aGlzLmFkZEJPTSA9IGZhbHNlO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLmVuY29kZXIud3JpdGUoc3RyKTtcbn1cblxuUHJlcGVuZEJPTVdyYXBwZXIucHJvdG90eXBlLmVuZCA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLmVuY29kZXIuZW5kKCk7XG59XG5cblxuLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuZXhwb3J0cy5TdHJpcEJPTSA9IFN0cmlwQk9NV3JhcHBlcjtcbmZ1bmN0aW9uIFN0cmlwQk9NV3JhcHBlcihkZWNvZGVyLCBvcHRpb25zKSB7XG4gICAgdGhpcy5kZWNvZGVyID0gZGVjb2RlcjtcbiAgICB0aGlzLnBhc3MgPSBmYWxzZTtcbiAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xufVxuXG5TdHJpcEJPTVdyYXBwZXIucHJvdG90eXBlLndyaXRlID0gZnVuY3Rpb24oYnVmKSB7XG4gICAgdmFyIHJlcyA9IHRoaXMuZGVjb2Rlci53cml0ZShidWYpO1xuICAgIGlmICh0aGlzLnBhc3MgfHwgIXJlcylcbiAgICAgICAgcmV0dXJuIHJlcztcblxuICAgIGlmIChyZXNbMF0gPT09IEJPTUNoYXIpIHtcbiAgICAgICAgcmVzID0gcmVzLnNsaWNlKDEpO1xuICAgICAgICBpZiAodHlwZW9mIHRoaXMub3B0aW9ucy5zdHJpcEJPTSA9PT0gJ2Z1bmN0aW9uJylcbiAgICAgICAgICAgIHRoaXMub3B0aW9ucy5zdHJpcEJPTSgpO1xuICAgIH1cblxuICAgIHRoaXMucGFzcyA9IHRydWU7XG4gICAgcmV0dXJuIHJlcztcbn1cblxuU3RyaXBCT01XcmFwcGVyLnByb3RvdHlwZS5lbmQgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5kZWNvZGVyLmVuZCgpO1xufVxuXG4iLCIoZnVuY3Rpb24gKHByb2Nlc3MsQnVmZmVyKXtcblwidXNlIHN0cmljdFwiXG5cbnZhciBib21IYW5kbGluZyA9IHJlcXVpcmUoJy4vYm9tLWhhbmRsaW5nJyksXG4gICAgaWNvbnYgPSBtb2R1bGUuZXhwb3J0cztcblxuLy8gQWxsIGNvZGVjcyBhbmQgYWxpYXNlcyBhcmUga2VwdCBoZXJlLCBrZXllZCBieSBlbmNvZGluZyBuYW1lL2FsaWFzLlxuLy8gVGhleSBhcmUgbGF6eSBsb2FkZWQgaW4gYGljb252LmdldENvZGVjYCBmcm9tIGBlbmNvZGluZ3MvaW5kZXguanNgLlxuaWNvbnYuZW5jb2RpbmdzID0gbnVsbDtcblxuLy8gQ2hhcmFjdGVycyBlbWl0dGVkIGluIGNhc2Ugb2YgZXJyb3IuXG5pY29udi5kZWZhdWx0Q2hhclVuaWNvZGUgPSAn77+9Jztcbmljb252LmRlZmF1bHRDaGFyU2luZ2xlQnl0ZSA9ICc/JztcblxuLy8gUHVibGljIEFQSS5cbmljb252LmVuY29kZSA9IGZ1bmN0aW9uIGVuY29kZShzdHIsIGVuY29kaW5nLCBvcHRpb25zKSB7XG4gICAgc3RyID0gXCJcIiArIChzdHIgfHwgXCJcIik7IC8vIEVuc3VyZSBzdHJpbmcuXG5cbiAgICB2YXIgZW5jb2RlciA9IGljb252LmdldEVuY29kZXIoZW5jb2RpbmcsIG9wdGlvbnMpO1xuXG4gICAgdmFyIHJlcyA9IGVuY29kZXIud3JpdGUoc3RyKTtcbiAgICB2YXIgdHJhaWwgPSBlbmNvZGVyLmVuZCgpO1xuICAgIFxuICAgIHJldHVybiAodHJhaWwgJiYgdHJhaWwubGVuZ3RoID4gMCkgPyBCdWZmZXIuY29uY2F0KFtyZXMsIHRyYWlsXSkgOiByZXM7XG59XG5cbmljb252LmRlY29kZSA9IGZ1bmN0aW9uIGRlY29kZShidWYsIGVuY29kaW5nLCBvcHRpb25zKSB7XG4gICAgaWYgKHR5cGVvZiBidWYgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIGlmICghaWNvbnYuc2tpcERlY29kZVdhcm5pbmcpIHtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ0ljb252LWxpdGUgd2FybmluZzogZGVjb2RlKCktaW5nIHN0cmluZ3MgaXMgZGVwcmVjYXRlZC4gUmVmZXIgdG8gaHR0cHM6Ly9naXRodWIuY29tL2FzaHR1Y2hraW4vaWNvbnYtbGl0ZS93aWtpL1VzZS1CdWZmZXJzLXdoZW4tZGVjb2RpbmcnKTtcbiAgICAgICAgICAgIGljb252LnNraXBEZWNvZGVXYXJuaW5nID0gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGJ1ZiA9IG5ldyBCdWZmZXIoXCJcIiArIChidWYgfHwgXCJcIiksIFwiYmluYXJ5XCIpOyAvLyBFbnN1cmUgYnVmZmVyLlxuICAgIH1cblxuICAgIHZhciBkZWNvZGVyID0gaWNvbnYuZ2V0RGVjb2RlcihlbmNvZGluZywgb3B0aW9ucyk7XG5cbiAgICB2YXIgcmVzID0gZGVjb2Rlci53cml0ZShidWYpO1xuICAgIHZhciB0cmFpbCA9IGRlY29kZXIuZW5kKCk7XG5cbiAgICByZXR1cm4gdHJhaWwgPyAocmVzICsgdHJhaWwpIDogcmVzO1xufVxuXG5pY29udi5lbmNvZGluZ0V4aXN0cyA9IGZ1bmN0aW9uIGVuY29kaW5nRXhpc3RzKGVuYykge1xuICAgIHRyeSB7XG4gICAgICAgIGljb252LmdldENvZGVjKGVuYyk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbn1cblxuLy8gTGVnYWN5IGFsaWFzZXMgdG8gY29udmVydCBmdW5jdGlvbnNcbmljb252LnRvRW5jb2RpbmcgPSBpY29udi5lbmNvZGU7XG5pY29udi5mcm9tRW5jb2RpbmcgPSBpY29udi5kZWNvZGU7XG5cbi8vIFNlYXJjaCBmb3IgYSBjb2RlYyBpbiBpY29udi5lbmNvZGluZ3MuIENhY2hlIGNvZGVjIGRhdGEgaW4gaWNvbnYuX2NvZGVjRGF0YUNhY2hlLlxuaWNvbnYuX2NvZGVjRGF0YUNhY2hlID0ge307XG5pY29udi5nZXRDb2RlYyA9IGZ1bmN0aW9uIGdldENvZGVjKGVuY29kaW5nKSB7XG4gICAgaWYgKCFpY29udi5lbmNvZGluZ3MpXG4gICAgICAgIGljb252LmVuY29kaW5ncyA9IHJlcXVpcmUoXCIuLi9lbmNvZGluZ3NcIik7IC8vIExhenkgbG9hZCBhbGwgZW5jb2RpbmcgZGVmaW5pdGlvbnMuXG4gICAgXG4gICAgLy8gQ2Fub25pY2FsaXplIGVuY29kaW5nIG5hbWU6IHN0cmlwIGFsbCBub24tYWxwaGFudW1lcmljIGNoYXJzIGFuZCBhcHBlbmRlZCB5ZWFyLlxuICAgIHZhciBlbmMgPSAoJycrZW5jb2RpbmcpLnRvTG93ZXJDYXNlKCkucmVwbGFjZSgvW14wLTlhLXpdfDpcXGR7NH0kL2csIFwiXCIpO1xuXG4gICAgLy8gVHJhdmVyc2UgaWNvbnYuZW5jb2RpbmdzIHRvIGZpbmQgYWN0dWFsIGNvZGVjLlxuICAgIHZhciBjb2RlY09wdGlvbnMgPSB7fTtcbiAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICB2YXIgY29kZWMgPSBpY29udi5fY29kZWNEYXRhQ2FjaGVbZW5jXTtcbiAgICAgICAgaWYgKGNvZGVjKVxuICAgICAgICAgICAgcmV0dXJuIGNvZGVjO1xuXG4gICAgICAgIHZhciBjb2RlY0RlZiA9IGljb252LmVuY29kaW5nc1tlbmNdO1xuXG4gICAgICAgIHN3aXRjaCAodHlwZW9mIGNvZGVjRGVmKSB7XG4gICAgICAgICAgICBjYXNlIFwic3RyaW5nXCI6IC8vIERpcmVjdCBhbGlhcyB0byBvdGhlciBlbmNvZGluZy5cbiAgICAgICAgICAgICAgICBlbmMgPSBjb2RlY0RlZjtcbiAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgY2FzZSBcIm9iamVjdFwiOiAvLyBBbGlhcyB3aXRoIG9wdGlvbnMuIENhbiBiZSBsYXllcmVkLlxuICAgICAgICAgICAgICAgIGZvciAodmFyIGtleSBpbiBjb2RlY0RlZilcbiAgICAgICAgICAgICAgICAgICAgY29kZWNPcHRpb25zW2tleV0gPSBjb2RlY0RlZltrZXldO1xuXG4gICAgICAgICAgICAgICAgaWYgKCFjb2RlY09wdGlvbnMuZW5jb2RpbmdOYW1lKVxuICAgICAgICAgICAgICAgICAgICBjb2RlY09wdGlvbnMuZW5jb2RpbmdOYW1lID0gZW5jO1xuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIGVuYyA9IGNvZGVjRGVmLnR5cGU7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgIGNhc2UgXCJmdW5jdGlvblwiOiAvLyBDb2RlYyBpdHNlbGYuXG4gICAgICAgICAgICAgICAgaWYgKCFjb2RlY09wdGlvbnMuZW5jb2RpbmdOYW1lKVxuICAgICAgICAgICAgICAgICAgICBjb2RlY09wdGlvbnMuZW5jb2RpbmdOYW1lID0gZW5jO1xuXG4gICAgICAgICAgICAgICAgLy8gVGhlIGNvZGVjIGZ1bmN0aW9uIG11c3QgbG9hZCBhbGwgdGFibGVzIGFuZCByZXR1cm4gb2JqZWN0IHdpdGggLmVuY29kZXIgYW5kIC5kZWNvZGVyIG1ldGhvZHMuXG4gICAgICAgICAgICAgICAgLy8gSXQnbGwgYmUgY2FsbGVkIG9ubHkgb25jZSAoZm9yIGVhY2ggZGlmZmVyZW50IG9wdGlvbnMgb2JqZWN0KS5cbiAgICAgICAgICAgICAgICBjb2RlYyA9IG5ldyBjb2RlY0RlZihjb2RlY09wdGlvbnMsIGljb252KTtcblxuICAgICAgICAgICAgICAgIGljb252Ll9jb2RlY0RhdGFDYWNoZVtjb2RlY09wdGlvbnMuZW5jb2RpbmdOYW1lXSA9IGNvZGVjOyAvLyBTYXZlIGl0IHRvIGJlIHJldXNlZCBsYXRlci5cbiAgICAgICAgICAgICAgICByZXR1cm4gY29kZWM7XG5cbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRW5jb2Rpbmcgbm90IHJlY29nbml6ZWQ6ICdcIiArIGVuY29kaW5nICsgXCInIChzZWFyY2hlZCBhczogJ1wiK2VuYytcIicpXCIpO1xuICAgICAgICB9XG4gICAgfVxufVxuXG5pY29udi5nZXRFbmNvZGVyID0gZnVuY3Rpb24gZ2V0RW5jb2RlcihlbmNvZGluZywgb3B0aW9ucykge1xuICAgIHZhciBjb2RlYyA9IGljb252LmdldENvZGVjKGVuY29kaW5nKSxcbiAgICAgICAgZW5jb2RlciA9IG5ldyBjb2RlYy5lbmNvZGVyKG9wdGlvbnMsIGNvZGVjKTtcblxuICAgIGlmIChjb2RlYy5ib21Bd2FyZSAmJiBvcHRpb25zICYmIG9wdGlvbnMuYWRkQk9NKVxuICAgICAgICBlbmNvZGVyID0gbmV3IGJvbUhhbmRsaW5nLlByZXBlbmRCT00oZW5jb2Rlciwgb3B0aW9ucyk7XG5cbiAgICByZXR1cm4gZW5jb2Rlcjtcbn1cblxuaWNvbnYuZ2V0RGVjb2RlciA9IGZ1bmN0aW9uIGdldERlY29kZXIoZW5jb2RpbmcsIG9wdGlvbnMpIHtcbiAgICB2YXIgY29kZWMgPSBpY29udi5nZXRDb2RlYyhlbmNvZGluZyksXG4gICAgICAgIGRlY29kZXIgPSBuZXcgY29kZWMuZGVjb2RlcihvcHRpb25zLCBjb2RlYyk7XG5cbiAgICBpZiAoY29kZWMuYm9tQXdhcmUgJiYgIShvcHRpb25zICYmIG9wdGlvbnMuc3RyaXBCT00gPT09IGZhbHNlKSlcbiAgICAgICAgZGVjb2RlciA9IG5ldyBib21IYW5kbGluZy5TdHJpcEJPTShkZWNvZGVyLCBvcHRpb25zKTtcblxuICAgIHJldHVybiBkZWNvZGVyO1xufVxuXG5cbi8vIExvYWQgZXh0ZW5zaW9ucyBpbiBOb2RlLiBBbGwgb2YgdGhlbSBhcmUgb21pdHRlZCBpbiBCcm93c2VyaWZ5IGJ1aWxkIHZpYSAnYnJvd3NlcicgZmllbGQgaW4gcGFja2FnZS5qc29uLlxudmFyIG5vZGVWZXIgPSB0eXBlb2YgcHJvY2VzcyAhPT0gJ3VuZGVmaW5lZCcgJiYgcHJvY2Vzcy52ZXJzaW9ucyAmJiBwcm9jZXNzLnZlcnNpb25zLm5vZGU7XG5pZiAobm9kZVZlcikge1xuXG4gICAgLy8gTG9hZCBzdHJlYW1pbmcgc3VwcG9ydCBpbiBOb2RlIHYwLjEwK1xuICAgIHZhciBub2RlVmVyQXJyID0gbm9kZVZlci5zcGxpdChcIi5cIikubWFwKE51bWJlcik7XG4gICAgaWYgKG5vZGVWZXJBcnJbMF0gPiAwIHx8IG5vZGVWZXJBcnJbMV0gPj0gMTApIHtcbiAgICAgICAgcmVxdWlyZShcIi4vc3RyZWFtc1wiKShpY29udik7XG4gICAgfVxuXG4gICAgLy8gTG9hZCBOb2RlIHByaW1pdGl2ZSBleHRlbnNpb25zLlxuICAgIHJlcXVpcmUoXCIuL2V4dGVuZC1ub2RlXCIpKGljb252KTtcbn1cblxuXG59KS5jYWxsKHRoaXMscmVxdWlyZShcIjdZS0lQZVwiKSxyZXF1aXJlKFwiYnVmZmVyXCIpLkJ1ZmZlcikiLCIndXNlIHN0cmljdCc7XG5cbnZhciBpcCA9IGV4cG9ydHM7XG52YXIgQnVmZmVyID0gcmVxdWlyZSgnYnVmZmVyJykuQnVmZmVyO1xudmFyIG9zID0gcmVxdWlyZSgnb3MnKTtcblxuaXAudG9CdWZmZXIgPSBmdW5jdGlvbihpcCwgYnVmZiwgb2Zmc2V0KSB7XG4gIG9mZnNldCA9IH5+b2Zmc2V0O1xuXG4gIHZhciByZXN1bHQ7XG5cbiAgaWYgKHRoaXMuaXNWNEZvcm1hdChpcCkpIHtcbiAgICByZXN1bHQgPSBidWZmIHx8IG5ldyBCdWZmZXIob2Zmc2V0ICsgNCk7XG4gICAgaXAuc3BsaXQoL1xcLi9nKS5tYXAoZnVuY3Rpb24oYnl0ZSkge1xuICAgICAgcmVzdWx0W29mZnNldCsrXSA9IHBhcnNlSW50KGJ5dGUsIDEwKSAmIDB4ZmY7XG4gICAgfSk7XG4gIH0gZWxzZSBpZiAodGhpcy5pc1Y2Rm9ybWF0KGlwKSkge1xuICAgIHZhciBzZWN0aW9ucyA9IGlwLnNwbGl0KCc6JywgOCk7XG5cbiAgICB2YXIgaTtcbiAgICBmb3IgKGkgPSAwOyBpIDwgc2VjdGlvbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBpc3Y0ID0gdGhpcy5pc1Y0Rm9ybWF0KHNlY3Rpb25zW2ldKTtcbiAgICAgIHZhciB2NEJ1ZmZlcjtcblxuICAgICAgaWYgKGlzdjQpIHtcbiAgICAgICAgdjRCdWZmZXIgPSB0aGlzLnRvQnVmZmVyKHNlY3Rpb25zW2ldKTtcbiAgICAgICAgc2VjdGlvbnNbaV0gPSB2NEJ1ZmZlci5zbGljZSgwLCAyKS50b1N0cmluZygnaGV4Jyk7XG4gICAgICB9XG5cbiAgICAgIGlmICh2NEJ1ZmZlciAmJiArK2kgPCA4KSB7XG4gICAgICAgIHNlY3Rpb25zLnNwbGljZShpLCAwLCB2NEJ1ZmZlci5zbGljZSgyLCA0KS50b1N0cmluZygnaGV4JykpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChzZWN0aW9uc1swXSA9PT0gJycpIHtcbiAgICAgIHdoaWxlIChzZWN0aW9ucy5sZW5ndGggPCA4KSBzZWN0aW9ucy51bnNoaWZ0KCcwJyk7XG4gICAgfSBlbHNlIGlmIChzZWN0aW9uc1tzZWN0aW9ucy5sZW5ndGggLSAxXSA9PT0gJycpIHtcbiAgICAgIHdoaWxlIChzZWN0aW9ucy5sZW5ndGggPCA4KSBzZWN0aW9ucy5wdXNoKCcwJyk7XG4gICAgfSBlbHNlIGlmIChzZWN0aW9ucy5sZW5ndGggPCA4KSB7XG4gICAgICBmb3IgKGkgPSAwOyBpIDwgc2VjdGlvbnMubGVuZ3RoICYmIHNlY3Rpb25zW2ldICE9PSAnJzsgaSsrKTtcbiAgICAgIHZhciBhcmd2ID0gWyBpLCAxIF07XG4gICAgICBmb3IgKGkgPSA5IC0gc2VjdGlvbnMubGVuZ3RoOyBpID4gMDsgaS0tKSB7XG4gICAgICAgIGFyZ3YucHVzaCgnMCcpO1xuICAgICAgfVxuICAgICAgc2VjdGlvbnMuc3BsaWNlLmFwcGx5KHNlY3Rpb25zLCBhcmd2KTtcbiAgICB9XG5cbiAgICByZXN1bHQgPSBidWZmIHx8IG5ldyBCdWZmZXIob2Zmc2V0ICsgMTYpO1xuICAgIGZvciAoaSA9IDA7IGkgPCBzZWN0aW9ucy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIHdvcmQgPSBwYXJzZUludChzZWN0aW9uc1tpXSwgMTYpO1xuICAgICAgcmVzdWx0W29mZnNldCsrXSA9ICh3b3JkID4+IDgpICYgMHhmZjtcbiAgICAgIHJlc3VsdFtvZmZzZXQrK10gPSB3b3JkICYgMHhmZjtcbiAgICB9XG4gIH1cblxuICBpZiAoIXJlc3VsdCkge1xuICAgIHRocm93IEVycm9yKCdJbnZhbGlkIGlwIGFkZHJlc3M6ICcgKyBpcCk7XG4gIH1cblxuICByZXR1cm4gcmVzdWx0O1xufTtcblxuaXAudG9TdHJpbmcgPSBmdW5jdGlvbihidWZmLCBvZmZzZXQsIGxlbmd0aCkge1xuICBvZmZzZXQgPSB+fm9mZnNldDtcbiAgbGVuZ3RoID0gbGVuZ3RoIHx8IChidWZmLmxlbmd0aCAtIG9mZnNldCk7XG5cbiAgdmFyIHJlc3VsdCA9IFtdO1xuICBpZiAobGVuZ3RoID09PSA0KSB7XG4gICAgLy8gSVB2NFxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgIHJlc3VsdC5wdXNoKGJ1ZmZbb2Zmc2V0ICsgaV0pO1xuICAgIH1cbiAgICByZXN1bHQgPSByZXN1bHQuam9pbignLicpO1xuICB9IGVsc2UgaWYgKGxlbmd0aCA9PT0gMTYpIHtcbiAgICAvLyBJUHY2XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkgKz0gMikge1xuICAgICAgcmVzdWx0LnB1c2goYnVmZi5yZWFkVUludDE2QkUob2Zmc2V0ICsgaSkudG9TdHJpbmcoMTYpKTtcbiAgICB9XG4gICAgcmVzdWx0ID0gcmVzdWx0LmpvaW4oJzonKTtcbiAgICByZXN1bHQgPSByZXN1bHQucmVwbGFjZSgvKF58OikwKDowKSo6MCg6fCQpLywgJyQxOjokMycpO1xuICAgIHJlc3VsdCA9IHJlc3VsdC5yZXBsYWNlKC86ezMsNH0vLCAnOjonKTtcbiAgfVxuXG4gIHJldHVybiByZXN1bHQ7XG59O1xuXG52YXIgaXB2NFJlZ2V4ID0gL14oXFxkezEsM31cXC4pezMsM31cXGR7MSwzfSQvO1xudmFyIGlwdjZSZWdleCA9XG4gICAgL14oOjopPygoKFxcZHsxLDN9XFwuKXszfShcXGR7MSwzfSl7MX0pPyhbMC05YS1mXSl7MCw0fTp7MCwyfSl7MSw4fSg6Oik/JC9pO1xuXG5pcC5pc1Y0Rm9ybWF0ID0gZnVuY3Rpb24oaXApIHtcbiAgcmV0dXJuIGlwdjRSZWdleC50ZXN0KGlwKTtcbn07XG5cbmlwLmlzVjZGb3JtYXQgPSBmdW5jdGlvbihpcCkge1xuICByZXR1cm4gaXB2NlJlZ2V4LnRlc3QoaXApO1xufTtcbmZ1bmN0aW9uIF9ub3JtYWxpemVGYW1pbHkoZmFtaWx5KSB7XG4gIHJldHVybiBmYW1pbHkgPyBmYW1pbHkudG9Mb3dlckNhc2UoKSA6ICdpcHY0Jztcbn1cblxuaXAuZnJvbVByZWZpeExlbiA9IGZ1bmN0aW9uKHByZWZpeGxlbiwgZmFtaWx5KSB7XG4gIGlmIChwcmVmaXhsZW4gPiAzMikge1xuICAgIGZhbWlseSA9ICdpcHY2JztcbiAgfSBlbHNlIHtcbiAgICBmYW1pbHkgPSBfbm9ybWFsaXplRmFtaWx5KGZhbWlseSk7XG4gIH1cblxuICB2YXIgbGVuID0gNDtcbiAgaWYgKGZhbWlseSA9PT0gJ2lwdjYnKSB7XG4gICAgbGVuID0gMTY7XG4gIH1cbiAgdmFyIGJ1ZmYgPSBuZXcgQnVmZmVyKGxlbik7XG5cbiAgZm9yICh2YXIgaSA9IDAsIG4gPSBidWZmLmxlbmd0aDsgaSA8IG47ICsraSkge1xuICAgIHZhciBiaXRzID0gODtcbiAgICBpZiAocHJlZml4bGVuIDwgOCkge1xuICAgICAgYml0cyA9IHByZWZpeGxlbjtcbiAgICB9XG4gICAgcHJlZml4bGVuIC09IGJpdHM7XG5cbiAgICBidWZmW2ldID0gfigweGZmID4+IGJpdHMpO1xuICB9XG5cbiAgcmV0dXJuIGlwLnRvU3RyaW5nKGJ1ZmYpO1xufTtcblxuaXAubWFzayA9IGZ1bmN0aW9uKGFkZHIsIG1hc2spIHtcbiAgYWRkciA9IGlwLnRvQnVmZmVyKGFkZHIpO1xuICBtYXNrID0gaXAudG9CdWZmZXIobWFzayk7XG5cbiAgdmFyIHJlc3VsdCA9IG5ldyBCdWZmZXIoTWF0aC5tYXgoYWRkci5sZW5ndGgsIG1hc2subGVuZ3RoKSk7XG5cbiAgLy8gU2FtZSBwcm90b2NvbCAtIGRvIGJpdHdpc2UgYW5kXG4gIGlmIChhZGRyLmxlbmd0aCA9PT0gbWFzay5sZW5ndGgpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFkZHIubGVuZ3RoOyBpKyspIHtcbiAgICAgIHJlc3VsdFtpXSA9IGFkZHJbaV0gJiBtYXNrW2ldO1xuICAgIH1cbiAgfSBlbHNlIGlmIChtYXNrLmxlbmd0aCA9PT0gNCkge1xuICAgIC8vIElQdjYgYWRkcmVzcyBhbmQgSVB2NCBtYXNrXG4gICAgLy8gKE1hc2sgbG93IGJpdHMpXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBtYXNrLmxlbmd0aDsgaSsrKSB7XG4gICAgICByZXN1bHRbaV0gPSBhZGRyW2FkZHIubGVuZ3RoIC0gNCAgKyBpXSAmIG1hc2tbaV07XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIC8vIElQdjYgbWFzayBhbmQgSVB2NCBhZGRyXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCByZXN1bHQubGVuZ3RoIC0gNjsgaSsrKSB7XG4gICAgICByZXN1bHRbaV0gPSAwO1xuICAgIH1cblxuICAgIC8vIDo6ZmZmZjppcHY0XG4gICAgcmVzdWx0WzEwXSA9IDB4ZmY7XG4gICAgcmVzdWx0WzExXSA9IDB4ZmY7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhZGRyLmxlbmd0aDsgaSsrKSB7XG4gICAgICByZXN1bHRbaSArIDEyXSA9IGFkZHJbaV0gJiBtYXNrW2kgKyAxMl07XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGlwLnRvU3RyaW5nKHJlc3VsdCk7XG59O1xuXG5pcC5jaWRyID0gZnVuY3Rpb24oY2lkclN0cmluZykge1xuICB2YXIgY2lkclBhcnRzID0gY2lkclN0cmluZy5zcGxpdCgnLycpO1xuXG4gIHZhciBhZGRyID0gY2lkclBhcnRzWzBdO1xuICBpZiAoY2lkclBhcnRzLmxlbmd0aCAhPT0gMilcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgQ0lEUiBzdWJuZXQ6ICcgKyBhZGRyKTtcblxuICB2YXIgbWFzayA9IGlwLmZyb21QcmVmaXhMZW4ocGFyc2VJbnQoY2lkclBhcnRzWzFdLCAxMCkpO1xuXG4gIHJldHVybiBpcC5tYXNrKGFkZHIsIG1hc2spO1xufTtcblxuaXAuc3VibmV0ID0gZnVuY3Rpb24oYWRkciwgbWFzaykge1xuICB2YXIgbmV0d29ya0FkZHJlc3MgPSBpcC50b0xvbmcoaXAubWFzayhhZGRyLCBtYXNrKSk7XG5cbiAgLy8gQ2FsY3VsYXRlIHRoZSBtYXNrJ3MgbGVuZ3RoLlxuICB2YXIgbWFza0J1ZmZlciA9IGlwLnRvQnVmZmVyKG1hc2spO1xuICB2YXIgbWFza0xlbmd0aCA9IDA7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBtYXNrQnVmZmVyLmxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKG1hc2tCdWZmZXJbaV0gPT09IDB4ZmYpIHtcbiAgICAgIG1hc2tMZW5ndGggKz0gODtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIG9jdGV0ID0gbWFza0J1ZmZlcltpXSAmIDB4ZmY7XG4gICAgICB3aGlsZSAob2N0ZXQpIHtcbiAgICAgICAgb2N0ZXQgPSAob2N0ZXQgPDwgMSkgJiAweGZmO1xuICAgICAgICBtYXNrTGVuZ3RoKys7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgdmFyIG51bWJlck9mQWRkcmVzc2VzID0gTWF0aC5wb3coMiwgMzIgLSBtYXNrTGVuZ3RoKTtcblxuICByZXR1cm4ge1xuICAgIG5ldHdvcmtBZGRyZXNzOiBpcC5mcm9tTG9uZyhuZXR3b3JrQWRkcmVzcyksXG4gICAgZmlyc3RBZGRyZXNzOiBudW1iZXJPZkFkZHJlc3NlcyA8PSAyID9cbiAgICAgICAgICAgICAgICAgICAgaXAuZnJvbUxvbmcobmV0d29ya0FkZHJlc3MpIDpcbiAgICAgICAgICAgICAgICAgICAgaXAuZnJvbUxvbmcobmV0d29ya0FkZHJlc3MgKyAxKSxcbiAgICBsYXN0QWRkcmVzczogbnVtYmVyT2ZBZGRyZXNzZXMgPD0gMiA/XG4gICAgICAgICAgICAgICAgICAgIGlwLmZyb21Mb25nKG5ldHdvcmtBZGRyZXNzICsgbnVtYmVyT2ZBZGRyZXNzZXMgLSAxKSA6XG4gICAgICAgICAgICAgICAgICAgIGlwLmZyb21Mb25nKG5ldHdvcmtBZGRyZXNzICsgbnVtYmVyT2ZBZGRyZXNzZXMgLSAyKSxcbiAgICBicm9hZGNhc3RBZGRyZXNzOiBpcC5mcm9tTG9uZyhuZXR3b3JrQWRkcmVzcyArIG51bWJlck9mQWRkcmVzc2VzIC0gMSksXG4gICAgc3VibmV0TWFzazogbWFzayxcbiAgICBzdWJuZXRNYXNrTGVuZ3RoOiBtYXNrTGVuZ3RoLFxuICAgIG51bUhvc3RzOiBudW1iZXJPZkFkZHJlc3NlcyA8PSAyID9cbiAgICAgICAgICAgICAgICBudW1iZXJPZkFkZHJlc3NlcyA6IG51bWJlck9mQWRkcmVzc2VzIC0gMixcbiAgICBsZW5ndGg6IG51bWJlck9mQWRkcmVzc2VzLFxuICAgIGNvbnRhaW5zOiBmdW5jdGlvbihvdGhlcikge1xuICAgICAgcmV0dXJuIG5ldHdvcmtBZGRyZXNzID09PSBpcC50b0xvbmcoaXAubWFzayhvdGhlciwgbWFzaykpO1xuICAgIH1cbiAgfTtcbn07XG5cbmlwLmNpZHJTdWJuZXQgPSBmdW5jdGlvbihjaWRyU3RyaW5nKSB7XG4gIHZhciBjaWRyUGFydHMgPSBjaWRyU3RyaW5nLnNwbGl0KCcvJyk7XG5cbiAgdmFyIGFkZHIgPSBjaWRyUGFydHNbMF07XG4gIGlmIChjaWRyUGFydHMubGVuZ3RoICE9PSAyKVxuICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZCBDSURSIHN1Ym5ldDogJyArIGFkZHIpO1xuXG4gIHZhciBtYXNrID0gaXAuZnJvbVByZWZpeExlbihwYXJzZUludChjaWRyUGFydHNbMV0sIDEwKSk7XG5cbiAgcmV0dXJuIGlwLnN1Ym5ldChhZGRyLCBtYXNrKTtcbn07XG5cbmlwLm5vdCA9IGZ1bmN0aW9uKGFkZHIpIHtcbiAgdmFyIGJ1ZmYgPSBpcC50b0J1ZmZlcihhZGRyKTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBidWZmLmxlbmd0aDsgaSsrKSB7XG4gICAgYnVmZltpXSA9IDB4ZmYgXiBidWZmW2ldO1xuICB9XG4gIHJldHVybiBpcC50b1N0cmluZyhidWZmKTtcbn07XG5cbmlwLm9yID0gZnVuY3Rpb24oYSwgYikge1xuICBhID0gaXAudG9CdWZmZXIoYSk7XG4gIGIgPSBpcC50b0J1ZmZlcihiKTtcblxuICAvLyBzYW1lIHByb3RvY29sXG4gIGlmIChhLmxlbmd0aCA9PT0gYi5sZW5ndGgpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGEubGVuZ3RoOyArK2kpIHtcbiAgICAgIGFbaV0gfD0gYltpXTtcbiAgICB9XG4gICAgcmV0dXJuIGlwLnRvU3RyaW5nKGEpO1xuXG4gIC8vIG1peGVkIHByb3RvY29sc1xuICB9IGVsc2Uge1xuICAgIHZhciBidWZmID0gYTtcbiAgICB2YXIgb3RoZXIgPSBiO1xuICAgIGlmIChiLmxlbmd0aCA+IGEubGVuZ3RoKSB7XG4gICAgICBidWZmID0gYjtcbiAgICAgIG90aGVyID0gYTtcbiAgICB9XG5cbiAgICB2YXIgb2Zmc2V0ID0gYnVmZi5sZW5ndGggLSBvdGhlci5sZW5ndGg7XG4gICAgZm9yICh2YXIgaSA9IG9mZnNldDsgaSA8IGJ1ZmYubGVuZ3RoOyArK2kpIHtcbiAgICAgIGJ1ZmZbaV0gfD0gb3RoZXJbaSAtIG9mZnNldF07XG4gICAgfVxuXG4gICAgcmV0dXJuIGlwLnRvU3RyaW5nKGJ1ZmYpO1xuICB9XG59O1xuXG5pcC5pc0VxdWFsID0gZnVuY3Rpb24oYSwgYikge1xuICBhID0gaXAudG9CdWZmZXIoYSk7XG4gIGIgPSBpcC50b0J1ZmZlcihiKTtcblxuICAvLyBTYW1lIHByb3RvY29sXG4gIGlmIChhLmxlbmd0aCA9PT0gYi5sZW5ndGgpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGEubGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmIChhW2ldICE9PSBiW2ldKSByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgLy8gU3dhcFxuICBpZiAoYi5sZW5ndGggPT09IDQpIHtcbiAgICB2YXIgdCA9IGI7XG4gICAgYiA9IGE7XG4gICAgYSA9IHQ7XG4gIH1cblxuICAvLyBhIC0gSVB2NCwgYiAtIElQdjZcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCAxMDsgaSsrKSB7XG4gICAgaWYgKGJbaV0gIT09IDApIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHZhciB3b3JkID0gYi5yZWFkVUludDE2QkUoMTApO1xuICBpZiAod29yZCAhPT0gMCAmJiB3b3JkICE9PSAweGZmZmYpIHJldHVybiBmYWxzZTtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IDQ7IGkrKykge1xuICAgIGlmIChhW2ldICE9PSBiW2kgKyAxMl0pIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHJldHVybiB0cnVlO1xufTtcblxuaXAuaXNQcml2YXRlID0gZnVuY3Rpb24oYWRkcikge1xuICByZXR1cm4gL14oOjpmezR9Oik/MTBcXC4oWzAtOV17MSwzfSlcXC4oWzAtOV17MSwzfSlcXC4oWzAtOV17MSwzfSkkL2lcbiAgICAgIC50ZXN0KGFkZHIpIHx8XG4gICAgL14oOjpmezR9Oik/MTkyXFwuMTY4XFwuKFswLTldezEsM30pXFwuKFswLTldezEsM30pJC9pLnRlc3QoYWRkcikgfHxcbiAgICAvXig6OmZ7NH06KT8xNzJcXC4oMVs2LTldfDJcXGR8MzB8MzEpXFwuKFswLTldezEsM30pXFwuKFswLTldezEsM30pJC9pXG4gICAgICAudGVzdChhZGRyKSB8fFxuICAgIC9eKDo6Zns0fTopPzEyN1xcLihbMC05XXsxLDN9KVxcLihbMC05XXsxLDN9KVxcLihbMC05XXsxLDN9KSQvaS50ZXN0KGFkZHIpIHx8XG4gICAgL14oOjpmezR9Oik/MTY5XFwuMjU0XFwuKFswLTldezEsM30pXFwuKFswLTldezEsM30pJC9pLnRlc3QoYWRkcikgfHxcbiAgICAvXmZbY2RdWzAtOWEtZl17Mn06L2kudGVzdChhZGRyKSB8fFxuICAgIC9eZmU4MDovaS50ZXN0KGFkZHIpIHx8XG4gICAgL146OjEkLy50ZXN0KGFkZHIpIHx8XG4gICAgL146OiQvLnRlc3QoYWRkcik7XG59O1xuXG5pcC5pc1B1YmxpYyA9IGZ1bmN0aW9uKGFkZHIpIHtcbiAgcmV0dXJuICFpcC5pc1ByaXZhdGUoYWRkcik7XG59O1xuXG5pcC5pc0xvb3BiYWNrID0gZnVuY3Rpb24oYWRkcikge1xuICByZXR1cm4gL14oOjpmezR9Oik/MTI3XFwuKFswLTldezEsM30pXFwuKFswLTldezEsM30pXFwuKFswLTldezEsM30pL1xuICAgICAgLnRlc3QoYWRkcikgfHxcbiAgICAvXmZlODA6OjEkLy50ZXN0KGFkZHIpIHx8XG4gICAgL146OjEkLy50ZXN0KGFkZHIpIHx8XG4gICAgL146OiQvLnRlc3QoYWRkcik7XG59O1xuXG5pcC5sb29wYmFjayA9IGZ1bmN0aW9uKGZhbWlseSkge1xuICAvL1xuICAvLyBEZWZhdWx0IHRvIGBpcHY0YFxuICAvL1xuICBmYW1pbHkgPSBfbm9ybWFsaXplRmFtaWx5KGZhbWlseSk7XG5cbiAgaWYgKGZhbWlseSAhPT0gJ2lwdjQnICYmIGZhbWlseSAhPT0gJ2lwdjYnKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdmYW1pbHkgbXVzdCBiZSBpcHY0IG9yIGlwdjYnKTtcbiAgfVxuXG4gIHJldHVybiBmYW1pbHkgPT09ICdpcHY0JyA/ICcxMjcuMC4wLjEnIDogJ2ZlODA6OjEnO1xufTtcblxuLy9cbi8vICMjIyBmdW5jdGlvbiBhZGRyZXNzIChuYW1lLCBmYW1pbHkpXG4vLyAjIyMjIEBuYW1lIHtzdHJpbmd8J3B1YmxpYyd8J3ByaXZhdGUnfSAqKk9wdGlvbmFsKiogTmFtZSBvciBzZWN1cml0eVxuLy8gICAgICBvZiB0aGUgbmV0d29yayBpbnRlcmZhY2UuXG4vLyAjIyMjIEBmYW1pbHkge2lwdjR8aXB2Nn0gKipPcHRpb25hbCoqIElQIGZhbWlseSBvZiB0aGUgYWRkcmVzcyAoZGVmYXVsdHNcbi8vICAgICAgdG8gaXB2NCkuXG4vL1xuLy8gUmV0dXJucyB0aGUgYWRkcmVzcyBmb3IgdGhlIG5ldHdvcmsgaW50ZXJmYWNlIG9uIHRoZSBjdXJyZW50IHN5c3RlbSB3aXRoXG4vLyB0aGUgc3BlY2lmaWVkIGBuYW1lYDpcbi8vICAgKiBTdHJpbmc6IEZpcnN0IGBmYW1pbHlgIGFkZHJlc3Mgb2YgdGhlIGludGVyZmFjZS5cbi8vICAgICAgICAgICAgIElmIG5vdCBmb3VuZCBzZWUgYHVuZGVmaW5lZGAuXG4vLyAgICogJ3B1YmxpYyc6IHRoZSBmaXJzdCBwdWJsaWMgaXAgYWRkcmVzcyBvZiBmYW1pbHkuXG4vLyAgICogJ3ByaXZhdGUnOiB0aGUgZmlyc3QgcHJpdmF0ZSBpcCBhZGRyZXNzIG9mIGZhbWlseS5cbi8vICAgKiB1bmRlZmluZWQ6IEZpcnN0IGFkZHJlc3Mgd2l0aCBgaXB2NGAgb3IgbG9vcGJhY2sgYWRkcmVzcyBgMTI3LjAuMC4xYC5cbi8vXG5pcC5hZGRyZXNzID0gZnVuY3Rpb24obmFtZSwgZmFtaWx5KSB7XG4gIHZhciBpbnRlcmZhY2VzID0gb3MubmV0d29ya0ludGVyZmFjZXMoKTtcbiAgdmFyIGFsbDtcblxuICAvL1xuICAvLyBEZWZhdWx0IHRvIGBpcHY0YFxuICAvL1xuICBmYW1pbHkgPSBfbm9ybWFsaXplRmFtaWx5KGZhbWlseSk7XG5cbiAgLy9cbiAgLy8gSWYgYSBzcGVjaWZpYyBuZXR3b3JrIGludGVyZmFjZSBoYXMgYmVlbiBuYW1lZCxcbiAgLy8gcmV0dXJuIHRoZSBhZGRyZXNzLlxuICAvL1xuICBpZiAobmFtZSAmJiBuYW1lICE9PSAncHJpdmF0ZScgJiYgbmFtZSAhPT0gJ3B1YmxpYycpIHtcbiAgICB2YXIgcmVzID0gaW50ZXJmYWNlc1tuYW1lXS5maWx0ZXIoZnVuY3Rpb24oZGV0YWlscykge1xuICAgICAgdmFyIGl0ZW1GYW1pbHkgPSBkZXRhaWxzLmZhbWlseS50b0xvd2VyQ2FzZSgpO1xuICAgICAgcmV0dXJuIGl0ZW1GYW1pbHkgPT09IGZhbWlseTtcbiAgICB9KTtcbiAgICBpZiAocmVzLmxlbmd0aCA9PT0gMClcbiAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgcmV0dXJuIHJlc1swXS5hZGRyZXNzO1xuICB9XG5cbiAgdmFyIGFsbCA9IE9iamVjdC5rZXlzKGludGVyZmFjZXMpLm1hcChmdW5jdGlvbiAobmljKSB7XG4gICAgLy9cbiAgICAvLyBOb3RlOiBuYW1lIHdpbGwgb25seSBiZSBgcHVibGljYCBvciBgcHJpdmF0ZWBcbiAgICAvLyB3aGVuIHRoaXMgaXMgY2FsbGVkLlxuICAgIC8vXG4gICAgdmFyIGFkZHJlc3NlcyA9IGludGVyZmFjZXNbbmljXS5maWx0ZXIoZnVuY3Rpb24gKGRldGFpbHMpIHtcbiAgICAgIGRldGFpbHMuZmFtaWx5ID0gZGV0YWlscy5mYW1pbHkudG9Mb3dlckNhc2UoKTtcbiAgICAgIGlmIChkZXRhaWxzLmZhbWlseSAhPT0gZmFtaWx5IHx8IGlwLmlzTG9vcGJhY2soZGV0YWlscy5hZGRyZXNzKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9IGVsc2UgaWYgKCFuYW1lKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gbmFtZSA9PT0gJ3B1YmxpYycgPyBpcC5pc1ByaXZhdGUoZGV0YWlscy5hZGRyZXNzKSA6XG4gICAgICAgICAgaXAuaXNQdWJsaWMoZGV0YWlscy5hZGRyZXNzKTtcbiAgICB9KTtcblxuICAgIHJldHVybiBhZGRyZXNzZXMubGVuZ3RoID8gYWRkcmVzc2VzWzBdLmFkZHJlc3MgOiB1bmRlZmluZWQ7XG4gIH0pLmZpbHRlcihCb29sZWFuKTtcblxuICByZXR1cm4gIWFsbC5sZW5ndGggPyBpcC5sb29wYmFjayhmYW1pbHkpIDogYWxsWzBdO1xufTtcblxuaXAudG9Mb25nID0gZnVuY3Rpb24oaXApIHtcbiAgdmFyIGlwbCA9IDA7XG4gIGlwLnNwbGl0KCcuJykuZm9yRWFjaChmdW5jdGlvbihvY3RldCkge1xuICAgIGlwbCA8PD0gODtcbiAgICBpcGwgKz0gcGFyc2VJbnQob2N0ZXQpO1xuICB9KTtcbiAgcmV0dXJuKGlwbCA+Pj4gMCk7XG59O1xuXG5pcC5mcm9tTG9uZyA9IGZ1bmN0aW9uKGlwbCkge1xuICByZXR1cm4gKChpcGwgPj4+IDI0KSArICcuJyArXG4gICAgICAoaXBsID4+IDE2ICYgMjU1KSArICcuJyArXG4gICAgICAoaXBsID4+IDggJiAyNTUpICsgJy4nICtcbiAgICAgIChpcGwgJiAyNTUpICk7XG59O1xuIiwiKGZ1bmN0aW9uIChCdWZmZXIpe1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgc3RyZWFtID0gcmVxdWlyZSgnc3RyZWFtJyk7XG52YXIgdXRpbCA9IHJlcXVpcmUoJ3V0aWwnKTtcbnZhciBUcmFuc2Zvcm0gPSBzdHJlYW0uVHJhbnNmb3JtO1xuXG4vLyBleHBvc2UgdG8gdGhlIHdvcmxkXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgICBlbmNvZGU6IGVuY29kZSxcbiAgICBkZWNvZGU6IGRlY29kZSxcbiAgICB3cmFwOiB3cmFwLFxuICAgIEVuY29kZXI6IEVuY29kZXIsXG4gICAgRGVjb2RlcjogRGVjb2RlclxufTtcblxuLyoqXG4gKiBFbmNvZGVzIGEgQnVmZmVyIGludG8gYSBiYXNlNjQgZW5jb2RlZCBzdHJpbmdcbiAqXG4gKiBAcGFyYW0ge0J1ZmZlcn0gYnVmZmVyIEJ1ZmZlciB0byBjb252ZXJ0XG4gKiBAcmV0dXJucyB7U3RyaW5nfSBiYXNlNjQgZW5jb2RlZCBzdHJpbmdcbiAqL1xuZnVuY3Rpb24gZW5jb2RlKGJ1ZmZlcikge1xuICAgIGlmICh0eXBlb2YgYnVmZmVyID09PSAnc3RyaW5nJykge1xuICAgICAgICBidWZmZXIgPSBuZXcgQnVmZmVyKGJ1ZmZlciwgJ3V0Zi04Jyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGJ1ZmZlci50b1N0cmluZygnYmFzZTY0Jyk7XG59XG5cbi8qKlxuICogRGVjb2RlcyBhIGJhc2U2NCBlbmNvZGVkIHN0cmluZyB0byBhIEJ1ZmZlciBvYmplY3RcbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gc3RyIGJhc2U2NCBlbmNvZGVkIHN0cmluZ1xuICogQHJldHVybnMge0J1ZmZlcn0gRGVjb2RlZCB2YWx1ZVxuICovXG5mdW5jdGlvbiBkZWNvZGUoc3RyKSB7XG4gICAgc3RyID0gKHN0ciB8fCAnJyk7XG4gICAgcmV0dXJuIG5ldyBCdWZmZXIoc3RyLCAnYmFzZTY0Jyk7XG59XG5cbi8qKlxuICogQWRkcyBzb2Z0IGxpbmUgYnJlYWtzIHRvIGEgYmFzZTY0IHN0cmluZ1xuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBzdHIgYmFzZTY0IGVuY29kZWQgc3RyaW5nIHRoYXQgbWlnaHQgbmVlZCBsaW5lIHdyYXBwaW5nXG4gKiBAcGFyYW0ge051bWJlcn0gW2xpbmVMZW5ndGg9NzZdIE1heGltdW0gYWxsb3dlZCBsZW5ndGggZm9yIGEgbGluZVxuICogQHJldHVybnMge1N0cmluZ30gU29mdC13cmFwcGVkIGJhc2U2NCBlbmNvZGVkIHN0cmluZ1xuICovXG5mdW5jdGlvbiB3cmFwKHN0ciwgbGluZUxlbmd0aCkge1xuICAgIHN0ciA9IChzdHIgfHwgJycpLnRvU3RyaW5nKCk7XG4gICAgbGluZUxlbmd0aCA9IGxpbmVMZW5ndGggfHwgNzY7XG5cbiAgICBpZiAoc3RyLmxlbmd0aCA8PSBsaW5lTGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiBzdHI7XG4gICAgfVxuXG4gICAgcmV0dXJuIHN0ci5yZXBsYWNlKG5ldyBSZWdFeHAoJy57JyArIGxpbmVMZW5ndGggKyAnfScsICdnJyksICckJlxcclxcbicpLnRyaW0oKTtcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGEgdHJhbnNmb3JtIHN0cmVhbSBmb3IgZW5jb2RpbmcgZGF0YSB0byBiYXNlNjQgZW5jb2RpbmdcbiAqXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIFN0cmVhbSBvcHRpb25zXG4gKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMubGluZUxlbmd0aD03Nl0gTWF4aW11bSBsZW5naHQgZm9yIGxpbmVzLCBzZXQgdG8gZmFsc2UgdG8gZGlzYWJsZSB3cmFwcGluZ1xuICovXG5mdW5jdGlvbiBFbmNvZGVyKG9wdGlvbnMpIHtcbiAgICAvLyBpbml0IFRyYW5zZm9ybVxuICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cbiAgICBpZiAodGhpcy5vcHRpb25zLmxpbmVMZW5ndGggIT09IGZhbHNlKSB7XG4gICAgICAgIHRoaXMub3B0aW9ucy5saW5lTGVuZ3RoID0gdGhpcy5vcHRpb25zLmxpbmVMZW5ndGggfHwgNzY7XG4gICAgfVxuXG4gICAgdGhpcy5fY3VyTGluZSA9ICcnO1xuICAgIHRoaXMuX3JlbWFpbmluZ0J5dGVzID0gZmFsc2U7XG5cbiAgICB0aGlzLmlucHV0Qnl0ZXMgPSAwO1xuICAgIHRoaXMub3V0cHV0Qnl0ZXMgPSAwO1xuXG4gICAgVHJhbnNmb3JtLmNhbGwodGhpcywgdGhpcy5vcHRpb25zKTtcbn1cbnV0aWwuaW5oZXJpdHMoRW5jb2RlciwgVHJhbnNmb3JtKTtcblxuRW5jb2Rlci5wcm90b3R5cGUuX3RyYW5zZm9ybSA9IGZ1bmN0aW9uKGNodW5rLCBlbmNvZGluZywgZG9uZSkge1xuICAgIHZhciBiNjQsIF9zZWxmID0gdGhpcztcblxuICAgIGlmIChlbmNvZGluZyAhPT0gJ2J1ZmZlcicpIHtcbiAgICAgICAgY2h1bmsgPSBuZXcgQnVmZmVyKGNodW5rLCBlbmNvZGluZyk7XG4gICAgfVxuXG4gICAgaWYgKCFjaHVuayB8fCAhY2h1bmsubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiBkb25lKCk7XG4gICAgfVxuXG4gICAgdGhpcy5pbnB1dEJ5dGVzICs9IGNodW5rLmxlbmd0aDtcblxuICAgIGlmICh0aGlzLl9yZW1haW5pbmdCeXRlcyAmJiB0aGlzLl9yZW1haW5pbmdCeXRlcy5sZW5ndGgpIHtcbiAgICAgICAgY2h1bmsgPSBCdWZmZXIuY29uY2F0KFt0aGlzLl9yZW1haW5pbmdCeXRlcywgY2h1bmtdKTtcbiAgICAgICAgdGhpcy5fcmVtYWluaW5nQnl0ZXMgPSBmYWxzZTtcbiAgICB9XG5cbiAgICBpZiAoY2h1bmsubGVuZ3RoICUgMykge1xuICAgICAgICB0aGlzLl9yZW1haW5pbmdCeXRlcyA9IGNodW5rLnNsaWNlKGNodW5rLmxlbmd0aCAtIGNodW5rLmxlbmd0aCAlIDMpO1xuICAgICAgICBjaHVuayA9IGNodW5rLnNsaWNlKDAsIGNodW5rLmxlbmd0aCAtIGNodW5rLmxlbmd0aCAlIDMpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuX3JlbWFpbmluZ0J5dGVzID0gZmFsc2U7XG4gICAgfVxuXG4gICAgYjY0ID0gdGhpcy5fY3VyTGluZSArIGVuY29kZShjaHVuayk7XG5cbiAgICBpZiAodGhpcy5vcHRpb25zLmxpbmVMZW5ndGgpIHtcbiAgICAgICAgYjY0ID0gd3JhcChiNjQsIHRoaXMub3B0aW9ucy5saW5lTGVuZ3RoKTtcbiAgICAgICAgYjY0ID0gYjY0LnJlcGxhY2UoLyhefFxcbikoW15cXG5dKikkLywgZnVuY3Rpb24obWF0Y2gsIGxpbmVCcmVhaywgbGFzdExpbmUpIHtcbiAgICAgICAgICAgIF9zZWxmLl9jdXJMaW5lID0gbGFzdExpbmU7XG4gICAgICAgICAgICByZXR1cm4gbGluZUJyZWFrO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBpZiAoYjY0KSB7XG4gICAgICAgIHRoaXMub3V0cHV0Qnl0ZXMgKz0gYjY0Lmxlbmd0aDtcbiAgICAgICAgdGhpcy5wdXNoKGI2NCk7XG4gICAgfVxuXG4gICAgZG9uZSgpO1xufTtcblxuRW5jb2Rlci5wcm90b3R5cGUuX2ZsdXNoID0gZnVuY3Rpb24oZG9uZSkge1xuICAgIGlmICh0aGlzLl9yZW1haW5pbmdCeXRlcyAmJiB0aGlzLl9yZW1haW5pbmdCeXRlcy5sZW5ndGgpIHtcbiAgICAgICAgdGhpcy5fY3VyTGluZSArPSBlbmNvZGUodGhpcy5fcmVtYWluaW5nQnl0ZXMpO1xuICAgIH1cbiAgICBpZiAodGhpcy5fY3VyTGluZSkge1xuICAgICAgICB0aGlzLl9jdXJMaW5lID0gd3JhcCh0aGlzLl9jdXJMaW5lLCB0aGlzLm9wdGlvbnMubGluZUxlbmd0aCk7XG4gICAgICAgIHRoaXMub3V0cHV0Qnl0ZXMgKz0gdGhpcy5fY3VyTGluZS5sZW5ndGg7XG4gICAgICAgIHRoaXMucHVzaCh0aGlzLl9jdXJMaW5lLCAnYXNjaWknKTtcbiAgICAgICAgdGhpcy5fY3VyTGluZSA9ICcnO1xuICAgIH1cbiAgICBkb25lKCk7XG59O1xuXG4vKipcbiAqIENyZWF0ZXMgYSB0cmFuc2Zvcm0gc3RyZWFtIGZvciBkZWNvZGluZyBiYXNlNjQgZW5jb2RlZCBzdHJpbmdzXG4gKlxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyBTdHJlYW0gb3B0aW9uc1xuICovXG5mdW5jdGlvbiBEZWNvZGVyKG9wdGlvbnMpIHtcbiAgICAvLyBpbml0IFRyYW5zZm9ybVxuICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gICAgdGhpcy5fY3VyTGluZSA9ICcnO1xuXG4gICAgdGhpcy5pbnB1dEJ5dGVzID0gMDtcbiAgICB0aGlzLm91dHB1dEJ5dGVzID0gMDtcblxuICAgIFRyYW5zZm9ybS5jYWxsKHRoaXMsIHRoaXMub3B0aW9ucyk7XG59XG51dGlsLmluaGVyaXRzKERlY29kZXIsIFRyYW5zZm9ybSk7XG5cbkRlY29kZXIucHJvdG90eXBlLl90cmFuc2Zvcm0gPSBmdW5jdGlvbihjaHVuaywgZW5jb2RpbmcsIGRvbmUpIHtcbiAgICB2YXIgYjY0LCBidWY7XG5cbiAgICBjaHVuayA9IGNodW5rLnRvU3RyaW5nKCdhc2NpaScpO1xuXG4gICAgaWYgKCFjaHVuayB8fCAhY2h1bmsubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiBkb25lKCk7XG4gICAgfVxuXG4gICAgdGhpcy5pbnB1dEJ5dGVzICs9IGNodW5rLmxlbmd0aDtcblxuICAgIGI2NCA9ICh0aGlzLl9jdXJMaW5lICsgY2h1bmspO1xuICAgIHRoaXMuX2N1ckxpbmUgPSAnJztcblxuICAgIGI2NCA9IGI2NC5yZXBsYWNlKC9bXmEtekEtWjAtOStcXC89XS9nLCAnJyk7XG5cbiAgICBpZiAoYjY0Lmxlbmd0aCAlIDQpIHtcbiAgICAgICAgdGhpcy5fY3VyTGluZSA9IGI2NC5zdWJzdHIoLWI2NC5sZW5ndGggJSA0KTtcbiAgICAgICAgaWYgKHRoaXMuX2N1ckxpbmUubGVuZ3RoID09IGI2NC5sZW5ndGgpIHtcbiAgICAgICAgICAgIGI2NCA9ICcnO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgYjY0ID0gYjY0LnN1YnN0cigwLCB0aGlzLl9jdXJMaW5lLmxlbmd0aCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoYjY0KSB7XG4gICAgICAgIGJ1ZiA9IGRlY29kZShiNjQpO1xuICAgICAgICB0aGlzLm91dHB1dEJ5dGVzICs9IGJ1Zi5sZW5ndGg7XG4gICAgICAgIHRoaXMucHVzaChidWYpO1xuICAgIH1cblxuICAgIGRvbmUoKTtcbn07XG5cbkRlY29kZXIucHJvdG90eXBlLl9mbHVzaCA9IGZ1bmN0aW9uKGRvbmUpIHtcbiAgICB2YXIgYjY0LCBidWY7XG4gICAgaWYgKHRoaXMuX2N1ckxpbmUpIHtcbiAgICAgICAgYnVmID0gZGVjb2RlKHRoaXMuX2N1ckxpbmUpO1xuICAgICAgICB0aGlzLm91dHB1dEJ5dGVzICs9IGJ1Zi5sZW5ndGg7XG4gICAgICAgIHRoaXMucHVzaChidWYpO1xuICAgICAgICB0aGlzLl9jdXJMaW5lID0gJyc7XG4gICAgfVxuICAgIGRvbmUoKTtcbn07XG59KS5jYWxsKHRoaXMscmVxdWlyZShcImJ1ZmZlclwiKS5CdWZmZXIpIiwiKGZ1bmN0aW9uIChCdWZmZXIpe1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgaWNvbnYgPSByZXF1aXJlKCdpY29udi1saXRlJyk7XG5cbi8qKlxuICogQ2hhcmFjdGVyIHNldCBlbmNvZGluZyBhbmQgZGVjb2RpbmcgZnVuY3Rpb25zXG4gKi9cbnZhciBjaGFyc2V0ID0gbW9kdWxlLmV4cG9ydHMgPSB7XG5cbiAgICAvKipcbiAgICAgKiBFbmNvZGVzIGFuIHVuaWNvZGUgc3RyaW5nIGludG8gYW4gQnVmZmVyIG9iamVjdCBhcyBVVEYtOFxuICAgICAqXG4gICAgICogV2UgZm9yY2UgVVRGLTggaGVyZSwgbm8gc3RyYW5nZSBlbmNvZGluZ3MgYWxsb3dlZC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBzdHIgU3RyaW5nIHRvIGJlIGVuY29kZWRcbiAgICAgKiBAcmV0dXJuIHtCdWZmZXJ9IFVURi04IGVuY29kZWQgdHlwZWQgYXJyYXlcbiAgICAgKi9cbiAgICBlbmNvZGU6IGZ1bmN0aW9uIChzdHIpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBCdWZmZXIoc3RyLCAndXRmLTgnKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogRGVjb2RlcyBhIHN0cmluZyBmcm9tIEJ1ZmZlciB0byBhbiB1bmljb2RlIHN0cmluZyB1c2luZyBzcGVjaWZpZWQgZW5jb2RpbmdcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7QnVmZmVyfSBidWYgQmluYXJ5IGRhdGEgdG8gYmUgZGVjb2RlZFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbZnJvbUNoYXJzZXQ9J1VURi04J10gQmluYXJ5IGRhdGEgaXMgZGVjb2RlZCBpbnRvIHN0cmluZyB1c2luZyB0aGlzIGNoYXJzZXRcbiAgICAgKiBAcmV0dXJuIHtTdHJpbmd9IERlY2RlZCBzdHJpbmdcbiAgICAgKi9cbiAgICBkZWNvZGU6IGZ1bmN0aW9uIChidWYsIGZyb21DaGFyc2V0KSB7XG4gICAgICAgIGZyb21DaGFyc2V0ID0gY2hhcnNldC5ub3JtYWxpemVDaGFyc2V0KGZyb21DaGFyc2V0IHx8ICdVVEYtOCcpO1xuXG4gICAgICAgIGlmICgvXih1c1xcLSk/YXNjaWl8dXRmXFwtOHw3Yml0JC9pLnRlc3QoZnJvbUNoYXJzZXQpKSB7XG4gICAgICAgICAgICByZXR1cm4gYnVmLnRvU3RyaW5nKCd1dGYtOCcpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGljb252LmRlY29kZShidWYsIGZyb21DaGFyc2V0KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQ29udmVydCBhIHN0cmluZyBmcm9tIHNwZWNpZmljIGVuY29kaW5nIHRvIFVURi04IEJ1ZmZlclxuICAgICAqXG4gICAgICogQHBhcmFtIHtTdHJpbmd8QnVmZmVyfSBzdHIgU3RyaW5nIHRvIGJlIGVuY29kZWRcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW2Zyb21DaGFyc2V0PSdVVEYtOCddIFNvdXJjZSBlbmNvZGluZyBmb3IgdGhlIHN0cmluZ1xuICAgICAqIEByZXR1cm4ge0J1ZmZlcn0gVVRGLTggZW5jb2RlZCB0eXBlZCBhcnJheVxuICAgICAqL1xuICAgIGNvbnZlcnQ6IGZ1bmN0aW9uIChkYXRhLCBmcm9tQ2hhcnNldCkge1xuICAgICAgICBmcm9tQ2hhcnNldCA9IGNoYXJzZXQubm9ybWFsaXplQ2hhcnNldChmcm9tQ2hhcnNldCB8fCAnVVRGLTgnKTtcblxuICAgICAgICB2YXIgYnVmU3RyaW5nO1xuXG4gICAgICAgIGlmICh0eXBlb2YgZGF0YSAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIGlmICgvXih1c1xcLSk/YXNjaWl8dXRmXFwtOHw3Yml0JC9pLnRlc3QoZnJvbUNoYXJzZXQpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGRhdGE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBidWZTdHJpbmcgPSBjaGFyc2V0LmRlY29kZShkYXRhLCBmcm9tQ2hhcnNldCk7XG4gICAgICAgICAgICByZXR1cm4gY2hhcnNldC5lbmNvZGUoYnVmU3RyaW5nKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY2hhcnNldC5lbmNvZGUoZGF0YSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIENvbnZlcnRzIHdlbGwga25vd24gaW52YWxpZCBjaGFyYWN0ZXIgc2V0IG5hbWVzIHRvIHByb3BlciBuYW1lcy5cbiAgICAgKiBlZy4gd2luLTEyNTcgd2lsbCBiZSBjb252ZXJ0ZWQgdG8gV0lORE9XUy0xMjU3XG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gY2hhcnNldCBDaGFyc2V0IG5hbWUgdG8gY29udmVydFxuICAgICAqIEByZXR1cm4ge1N0cmluZ30gQ2Fub25pbmljYWxpemVkIGNoYXJzZXQgbmFtZVxuICAgICAqL1xuICAgIG5vcm1hbGl6ZUNoYXJzZXQ6IGZ1bmN0aW9uIChjaGFyc2V0KSB7XG4gICAgICAgIHZhciBtYXRjaDtcblxuICAgICAgICBpZiAoKG1hdGNoID0gY2hhcnNldC5tYXRjaCgvXnV0ZltcXC1fXT8oXFxkKykkL2kpKSkge1xuICAgICAgICAgICAgcmV0dXJuICdVVEYtJyArIG1hdGNoWzFdO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKChtYXRjaCA9IGNoYXJzZXQubWF0Y2goL153aW5bXFwtX10/KFxcZCspJC9pKSkpIHtcbiAgICAgICAgICAgIHJldHVybiAnV0lORE9XUy0nICsgbWF0Y2hbMV07XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoKG1hdGNoID0gY2hhcnNldC5tYXRjaCgvXmxhdGluW1xcLV9dPyhcXGQrKSQvaSkpKSB7XG4gICAgICAgICAgICByZXR1cm4gJ0lTTy04ODU5LScgKyBtYXRjaFsxXTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBjaGFyc2V0O1xuICAgIH1cbn07XG5cbn0pLmNhbGwodGhpcyxyZXF1aXJlKFwiYnVmZmVyXCIpLkJ1ZmZlcikiLCIoZnVuY3Rpb24gKEJ1ZmZlcil7XG4ndXNlIHN0cmljdCc7XG5cbnZhciBsaWJjaGFyc2V0ID0gcmVxdWlyZSgnLi9jaGFyc2V0Jyk7XG52YXIgbGliYmFzZTY0ID0gcmVxdWlyZSgnbGliYmFzZTY0Jyk7XG52YXIgbGlicXAgPSByZXF1aXJlKCdsaWJxcCcpO1xudmFyIG1pbWV0eXBlcyA9IHJlcXVpcmUoJy4vbWltZXR5cGVzJyk7XG5cbnZhciBsaWJtaW1lID0gbW9kdWxlLmV4cG9ydHMgPSB7XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgYSB2YWx1ZSBpcyBwbGFpbnRleHQgc3RyaW5nICh1c2VzIG9ubHkgcHJpbnRhYmxlIDdiaXQgY2hhcnMpXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gdmFsdWUgU3RyaW5nIHRvIGJlIHRlc3RlZFxuICAgICAqIEByZXR1cm5zIHtCb29sZWFufSB0cnVlIGlmIGl0IGlzIGEgcGxhaW50ZXh0IHN0cmluZ1xuICAgICAqL1xuICAgIGlzUGxhaW5UZXh0OiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gJ3N0cmluZycgfHwgL1tcXHgwMC1cXHgwOFxceDBiXFx4MGNcXHgwZS1cXHgxZlxcdTAwODAtXFx1RkZGRl0vLnRlc3QodmFsdWUpKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgYSBtdWx0aSBsaW5lIHN0cmluZyBjb250YWluZXMgbGluZXMgbG9uZ2VyIHRoYW4gdGhlIHNlbGVjdGVkIHZhbHVlLlxuICAgICAqXG4gICAgICogVXNlZnVsIHdoZW4gZGV0ZWN0aW5nIGlmIGEgbWFpbCBtZXNzYWdlIG5lZWRzIGFueSBwcm9jZXNzaW5nIGF0IGFsbCDigJNcbiAgICAgKiBpZiBvbmx5IHBsYWludGV4dCBjaGFyYWN0ZXJzIGFyZSB1c2VkIGFuZCBsaW5lcyBhcmUgc2hvcnQsIHRoZW4gdGhlcmUgaXNcbiAgICAgKiBubyBuZWVkIHRvIGVuY29kZSB0aGUgdmFsdWVzIGluIGFueSB3YXkuIElmIHRoZSB2YWx1ZSBpcyBwbGFpbnRleHQgYnV0IGhhc1xuICAgICAqIGxvbmdlciBsaW5lcyB0aGVuIGFsbG93ZWQsIHRoZW4gdXNlIGZvcm1hdD1mbG93ZWRcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBsaW5lTGVuZ3RoIE1heCBsaW5lIGxlbmd0aCB0byBjaGVjayBmb3JcbiAgICAgKiBAcmV0dXJucyB7Qm9vbGVhbn0gUmV0dXJucyB0cnVlIGlmIHRoZXJlIGlzIGF0IGxlYXN0IG9uZSBsaW5lIGxvbmdlciB0aGFuIGxpbmVMZW5ndGggY2hhcnNcbiAgICAgKi9cbiAgICBoYXNMb25nZXJMaW5lczogZnVuY3Rpb24gKHN0ciwgbGluZUxlbmd0aCkge1xuICAgICAgICByZXR1cm4gbmV3IFJlZ0V4cCgnXi57JyArIChsaW5lTGVuZ3RoICsgMSkgKyAnLH0nLCAnbScpLnRlc3Qoc3RyKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogRGVjb2RlcyBhIHN0cmluZyBmcm9tIGEgZm9ybWF0PWZsb3dlZCBzb2Z0IHdyYXBwaW5nLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHN0ciBQbGFpbnRleHQgc3RyaW5nIHdpdGggZm9ybWF0PWZsb3dlZCB0byBkZWNvZGVcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtkZWxTcF0gSWYgdHJ1ZSwgZGVsZXRlIGxlYWRpbmcgc3BhY2VzIChkZWxzcD15ZXMpXG4gICAgICogQHJldHVybiB7U3RyaW5nfSBNaW1lIGRlY29kZWQgc3RyaW5nXG4gICAgICovXG4gICAgZGVjb2RlRmxvd2VkOiBmdW5jdGlvbiAoc3RyLCBkZWxTcCkge1xuICAgICAgICBzdHIgPSAoc3RyIHx8ICcnKS50b1N0cmluZygpO1xuXG4gICAgICAgIHJldHVybiBzdHIuXG4gICAgICAgIHNwbGl0KC9cXHI/XFxuLykuXG4gICAgICAgICAgICAvLyByZW1vdmUgc29mdCBsaW5lYnJlYWtzXG4gICAgICAgICAgICAvLyBzb2Z0IGxpbmVicmVha3MgYXJlIGFkZGVkIGFmdGVyIHNwYWNlIHN5bWJvbHNcbiAgICAgICAgcmVkdWNlKFxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIChwcmV2aW91c1ZhbHVlLCBjdXJyZW50VmFsdWUsIGluZGV4KSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBib2R5ID0gcHJldmlvdXNWYWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGRlbFNwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBkZWxzcCBhZGRzIHNwYWNlcyB0byB0ZXh0IHRvIGJlIGFibGUgdG8gZm9sZCBpdFxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gdGhlc2Ugc3BhY2VzIGNhbiBiZSByZW1vdmVkIG9uY2UgdGhlIHRleHQgaXMgdW5mb2xkZWRcbiAgICAgICAgICAgICAgICAgICAgICAgIGJvZHkgPSBib2R5LnJlcGxhY2UoL1sgXSskLywgJycpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmICgvICQvLnRlc3QocHJldmlvdXNWYWx1ZSkgJiYgIS8oXnxcXG4pXFwtXFwtICQvLnRlc3QocHJldmlvdXNWYWx1ZSkgfHwgaW5kZXggPT09IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBib2R5ICsgY3VycmVudFZhbHVlO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGJvZHkgKyAnXFxuJyArIGN1cnJlbnRWYWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICkuXG4gICAgICAgICAgICAvLyByZW1vdmUgd2hpdGVzcGFjZSBzdHVmZmluZ1xuICAgICAgICAgICAgLy8gaHR0cDovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjMzY3NiNzZWN0aW9uLTQuNFxuICAgICAgICByZXBsYWNlKC9eIC9nbSwgJycpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBBZGRzIHNvZnQgbGluZSBicmVha3MgdG8gY29udGVudCBtYXJrZWQgd2l0aCBmb3JtYXQ9Zmxvd2VkIHRvXG4gICAgICogZW5zdXJlIHRoYXQgbm8gbGluZSBpbiB0aGUgbWVzc2FnZSBpcyBuZXZlciBsb25nZXIgdGhhbiBsaW5lTGVuZ3RoXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gc3RyIFBsYWludGV4dCBzdHJpbmcgdGhhdCByZXF1aXJlcyB3cmFwcGluZ1xuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbbGluZUxlbmd0aD03Nl0gTWF4aW11bSBsZW5ndGggb2YgYSBsaW5lXG4gICAgICogQHJldHVybiB7U3RyaW5nfSBTdHJpbmcgd2l0aCBmb3JjZWQgbGluZSBicmVha3NcbiAgICAgKi9cbiAgICBlbmNvZGVGbG93ZWQ6IGZ1bmN0aW9uIChzdHIsIGxpbmVMZW5ndGgpIHtcbiAgICAgICAgbGluZUxlbmd0aCA9IGxpbmVMZW5ndGggfHwgNzY7XG5cbiAgICAgICAgdmFyIGZsb3dlZCA9IFtdO1xuICAgICAgICBzdHIuc3BsaXQoL1xccj9cXG4vKS5mb3JFYWNoKGZ1bmN0aW9uIChsaW5lKSB7XG4gICAgICAgICAgICBmbG93ZWQucHVzaChsaWJtaW1lLmZvbGRMaW5lcyhsaW5lLlxuICAgICAgICAgICAgICAgIC8vIHNwYWNlIHN0dWZmaW5nIGh0dHA6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzM2NzYjc2VjdGlvbi00LjJcbiAgICAgICAgICAgICAgICByZXBsYWNlKC9eKCB8RnJvbXw+KS9pZ20sICcgJDEnKSxcbiAgICAgICAgICAgICAgICBsaW5lTGVuZ3RoLCB0cnVlKSk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gZmxvd2VkLmpvaW4oJ1xcclxcbicpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBFbmNvZGVzIGEgc3RyaW5nIG9yIGFuIEJ1ZmZlciB0byBhbiBVVEYtOCBNSU1FIFdvcmQgKHJmYzIwNDcpXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1N0cmluZ3xCdWZmZXJ9IGRhdGEgU3RyaW5nIHRvIGJlIGVuY29kZWRcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gbWltZVdvcmRFbmNvZGluZz0nUScgRW5jb2RpbmcgZm9yIHRoZSBtaW1lIHdvcmQsIGVpdGhlciBRIG9yIEJcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW21heExlbmd0aD0wXSBJZiBzZXQsIHNwbGl0IG1pbWUgd29yZHMgaW50byBzZXZlcmFsIGNodW5rcyBpZiBuZWVkZWRcbiAgICAgKiBAcmV0dXJuIHtTdHJpbmd9IFNpbmdsZSBvciBzZXZlcmFsIG1pbWUgd29yZHMgam9pbmVkIHRvZ2V0aGVyXG4gICAgICovXG4gICAgZW5jb2RlV29yZDogZnVuY3Rpb24gKGRhdGEsIG1pbWVXb3JkRW5jb2RpbmcsIG1heExlbmd0aCkge1xuICAgICAgICBtaW1lV29yZEVuY29kaW5nID0gKG1pbWVXb3JkRW5jb2RpbmcgfHwgJ1EnKS50b1N0cmluZygpLnRvVXBwZXJDYXNlKCkudHJpbSgpLmNoYXJBdCgwKTtcbiAgICAgICAgbWF4TGVuZ3RoID0gbWF4TGVuZ3RoIHx8IDA7XG5cbiAgICAgICAgdmFyIGVuY29kZWRTdHIsXG4gICAgICAgICAgICB0b0NoYXJzZXQgPSAnVVRGLTgnLFxuICAgICAgICAgICAgaSwgbGVuLCBwYXJ0cywgbHBhcnQsIGNocjtcblxuICAgICAgICBpZiAobWF4TGVuZ3RoICYmIG1heExlbmd0aCA+IDcgKyB0b0NoYXJzZXQubGVuZ3RoKSB7XG4gICAgICAgICAgICBtYXhMZW5ndGggLT0gKDcgKyB0b0NoYXJzZXQubGVuZ3RoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChtaW1lV29yZEVuY29kaW5nID09PSAnUScpIHtcbiAgICAgICAgICAgIC8vIGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmMyMDQ3I3NlY3Rpb24tNSBydWxlICgzKVxuICAgICAgICAgICAgZW5jb2RlZFN0ciA9IGxpYnFwLmVuY29kZShkYXRhKS5yZXBsYWNlKC9bXmEtejAtOSEqK1xcLVxcLz1dL2lnLCBmdW5jdGlvbiAoY2hyKSB7XG4gICAgICAgICAgICAgICAgdmFyIG9yZCA9IGNoci5jaGFyQ29kZUF0KDApLnRvU3RyaW5nKDE2KS50b1VwcGVyQ2FzZSgpO1xuICAgICAgICAgICAgICAgIGlmIChjaHIgPT09ICcgJykge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gJ18nO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAnPScgKyAob3JkLmxlbmd0aCA9PT0gMSA/ICcwJyArIG9yZCA6IG9yZCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSBpZiAobWltZVdvcmRFbmNvZGluZyA9PT0gJ0InKSB7XG4gICAgICAgICAgICBlbmNvZGVkU3RyID0gdHlwZW9mIGRhdGEgPT09ICdzdHJpbmcnID8gZGF0YSA6IGxpYmJhc2U2NC5lbmNvZGUoZGF0YSk7XG4gICAgICAgICAgICBtYXhMZW5ndGggPSBtYXhMZW5ndGggPyBNYXRoLm1heCgzLCAobWF4TGVuZ3RoIC0gbWF4TGVuZ3RoICUgNCkgLyA0ICogMykgOiAwO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG1heExlbmd0aCAmJiAobWltZVdvcmRFbmNvZGluZyAhPT0gJ0InID8gZW5jb2RlZFN0ciA6IGxpYmJhc2U2NC5lbmNvZGUoZGF0YSkpLmxlbmd0aCA+IG1heExlbmd0aCkge1xuICAgICAgICAgICAgaWYgKG1pbWVXb3JkRW5jb2RpbmcgPT09ICdRJykge1xuICAgICAgICAgICAgICAgIGVuY29kZWRTdHIgPSBzcGxpdE1pbWVFbmNvZGVkU3RyaW5nKGVuY29kZWRTdHIsIG1heExlbmd0aCkuam9pbignPz0gPT8nICsgdG9DaGFyc2V0ICsgJz8nICsgbWltZVdvcmRFbmNvZGluZyArICc/Jyk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIFJGQzIwNDcgNi4zICgyKSBzdGF0ZXMgdGhhdCBlbmNvZGVkLXdvcmQgbXVzdCBpbmNsdWRlIGFuIGludGVncmFsIG51bWJlciBvZiBjaGFyYWN0ZXJzLCBzbyBubyBjaG9wcGluZyB1bmljb2RlIHNlcXVlbmNlc1xuICAgICAgICAgICAgICAgIHBhcnRzID0gW107XG4gICAgICAgICAgICAgICAgbHBhcnQgPSAnJztcbiAgICAgICAgICAgICAgICBmb3IgKGkgPSAwLCBsZW4gPSBlbmNvZGVkU3RyLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIGNociA9IGVuY29kZWRTdHIuY2hhckF0KGkpO1xuICAgICAgICAgICAgICAgICAgICAvLyBjaGVjayBpZiB3ZSBjYW4gYWRkIHRoaXMgY2hhcmFjdGVyIHRvIHRoZSBleGlzdGluZyBzdHJpbmdcbiAgICAgICAgICAgICAgICAgICAgLy8gd2l0aG91dCBicmVha2luZyBieXRlIGxlbmd0aCBsaW1pdFxuICAgICAgICAgICAgICAgICAgICBpZiAoQnVmZmVyLmJ5dGVMZW5ndGgobHBhcnQgKyBjaHIpIDw9IG1heExlbmd0aCB8fCBpID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBscGFydCArPSBjaHI7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyB3ZSBoaXQgdGhlIGxlbmd0aCBsaW1pdCwgc28gcHVzaCB0aGUgZXhpc3Rpbmcgc3RyaW5nIGFuZCBzdGFydCBvdmVyXG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJ0cy5wdXNoKGxpYmJhc2U2NC5lbmNvZGUobHBhcnQpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxwYXJ0ID0gY2hyO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChscGFydCkge1xuICAgICAgICAgICAgICAgICAgICBwYXJ0cy5wdXNoKGxpYmJhc2U2NC5lbmNvZGUobHBhcnQpKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAocGFydHMubGVuZ3RoID4gMSkge1xuICAgICAgICAgICAgICAgICAgICBlbmNvZGVkU3RyID0gcGFydHMuam9pbignPz0gPT8nICsgdG9DaGFyc2V0ICsgJz8nICsgbWltZVdvcmRFbmNvZGluZyArICc/Jyk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgZW5jb2RlZFN0ciA9IHBhcnRzLmpvaW4oJycpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmIChtaW1lV29yZEVuY29kaW5nID09PSAnQicpIHtcbiAgICAgICAgICAgIGVuY29kZWRTdHIgPSBsaWJiYXNlNjQuZW5jb2RlKGRhdGEpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuICc9PycgKyB0b0NoYXJzZXQgKyAnPycgKyBtaW1lV29yZEVuY29kaW5nICsgJz8nICsgZW5jb2RlZFN0ciArIChlbmNvZGVkU3RyLnN1YnN0cigtMikgPT09ICc/PScgPyAnJyA6ICc/PScpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBEZWNvZGUgYSBjb21wbGV0ZSBtaW1lIHdvcmQgZW5jb2RlZCBzdHJpbmdcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBzdHIgTWltZSB3b3JkIGVuY29kZWQgc3RyaW5nXG4gICAgICogQHJldHVybiB7U3RyaW5nfSBEZWNvZGVkIHVuaWNvZGUgc3RyaW5nXG4gICAgICovXG4gICAgZGVjb2RlV29yZDogZnVuY3Rpb24gKHN0cikge1xuICAgICAgICBzdHIgPSAoc3RyIHx8ICcnKS50b1N0cmluZygpLnRyaW0oKTtcblxuICAgICAgICB2YXIgZnJvbUNoYXJzZXQsIGVuY29kaW5nLCBtYXRjaDtcblxuICAgICAgICBtYXRjaCA9IHN0ci5tYXRjaCgvXlxcPVxcPyhbXFx3X1xcLVxcKl0rKVxcPyhbUXFCYl0pXFw/KFteXFw/XSspXFw/XFw9JC9pKTtcbiAgICAgICAgaWYgKCFtYXRjaCkge1xuICAgICAgICAgICAgcmV0dXJuIHN0cjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFJGQzIyMzEgYWRkZWQgbGFuZ3VhZ2UgdGFnIHRvIHRoZSBlbmNvZGluZ1xuICAgICAgICAvLyBzZWU6IGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmMyMjMxI3NlY3Rpb24tNVxuICAgICAgICAvLyB0aGlzIGltcGxlbWVudGF0aW9uIHNpbGVudGx5IGlnbm9yZXMgdGhpcyB0YWdcbiAgICAgICAgZnJvbUNoYXJzZXQgPSBtYXRjaFsxXS5zcGxpdCgnKicpLnNoaWZ0KCk7XG5cbiAgICAgICAgZW5jb2RpbmcgPSAobWF0Y2hbMl0gfHwgJ1EnKS50b1N0cmluZygpLnRvVXBwZXJDYXNlKCk7XG4gICAgICAgIHN0ciA9IChtYXRjaFszXSB8fCAnJykucmVwbGFjZSgvXy9nLCAnICcpLnJlcGxhY2UoLyAkLywgJz0yMCcpO1xuXG4gICAgICAgIGlmIChlbmNvZGluZyA9PT0gJ0InKSB7XG4gICAgICAgICAgICByZXR1cm4gbGliY2hhcnNldC5kZWNvZGUobGliYmFzZTY0LmRlY29kZShzdHIpLCBmcm9tQ2hhcnNldCk7XG4gICAgICAgIH0gZWxzZSBpZiAoZW5jb2RpbmcgPT09ICdRJykge1xuICAgICAgICAgICAgcmV0dXJuIGxpYmNoYXJzZXQuZGVjb2RlKGxpYnFwLmRlY29kZShzdHIpLCBmcm9tQ2hhcnNldCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gc3RyO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEZpbmRzIHdvcmQgc2VxdWVuY2VzIHdpdGggbm9uIGFzY2lpIHRleHQgYW5kIGNvbnZlcnRzIHRoZXNlIHRvIG1pbWUgd29yZHNcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfEJ1ZmZlcn0gZGF0YSBTdHJpbmcgdG8gYmUgZW5jb2RlZFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBtaW1lV29yZEVuY29kaW5nPSdRJyBFbmNvZGluZyBmb3IgdGhlIG1pbWUgd29yZCwgZWl0aGVyIFEgb3IgQlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbbWF4TGVuZ3RoPTBdIElmIHNldCwgc3BsaXQgbWltZSB3b3JkcyBpbnRvIHNldmVyYWwgY2h1bmtzIGlmIG5lZWRlZFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbZnJvbUNoYXJzZXQ9J1VURi04J10gU291cmNlIHNoYXJhY3RlciBzZXRcbiAgICAgKiBAcmV0dXJuIHtTdHJpbmd9IFN0cmluZyB3aXRoIHBvc3NpYmxlIG1pbWUgd29yZHNcbiAgICAgKi9cbiAgICBlbmNvZGVXb3JkczogZnVuY3Rpb24gKGRhdGEsIG1pbWVXb3JkRW5jb2RpbmcsIG1heExlbmd0aCwgZnJvbUNoYXJzZXQpIHtcbiAgICAgICAgaWYgKCFmcm9tQ2hhcnNldCAmJiB0eXBlb2YgbWF4TGVuZ3RoID09PSAnc3RyaW5nJyAmJiAhbWF4TGVuZ3RoLm1hdGNoKC9eWzAtOV0rJC8pKSB7XG4gICAgICAgICAgICBmcm9tQ2hhcnNldCA9IG1heExlbmd0aDtcbiAgICAgICAgICAgIG1heExlbmd0aCA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuXG4gICAgICAgIG1heExlbmd0aCA9IG1heExlbmd0aCB8fCAwO1xuXG4gICAgICAgIHZhciBkZWNvZGVkVmFsdWUgPSBsaWJjaGFyc2V0LmRlY29kZShsaWJjaGFyc2V0LmNvbnZlcnQoKGRhdGEgfHwgJycpLCBmcm9tQ2hhcnNldCkpLFxuICAgICAgICAgICAgZW5jb2RlZFZhbHVlO1xuXG4gICAgICAgIGVuY29kZWRWYWx1ZSA9IGRlY29kZWRWYWx1ZS5yZXBsYWNlKC8oW15cXHNcXHUwMDgwLVxcdUZGRkZdKltcXHUwMDgwLVxcdUZGRkZdK1teXFxzXFx1MDA4MC1cXHVGRkZGXSooPzpcXHMrW15cXHNcXHUwMDgwLVxcdUZGRkZdKltcXHUwMDgwLVxcdUZGRkZdK1teXFxzXFx1MDA4MC1cXHVGRkZGXSpcXHMqKT8pKyg/PVxcc3wkKS9nLCBmdW5jdGlvbiAobWF0Y2gpIHtcbiAgICAgICAgICAgIHJldHVybiBtYXRjaC5sZW5ndGggPyBsaWJtaW1lLmVuY29kZVdvcmQobWF0Y2gsIG1pbWVXb3JkRW5jb2RpbmcgfHwgJ1EnLCBtYXhMZW5ndGgpIDogJyc7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJldHVybiBlbmNvZGVkVmFsdWU7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIERlY29kZSBhIHN0cmluZyB0aGF0IG1pZ2h0IGluY2x1ZGUgb25lIG9yIHNldmVyYWwgbWltZSB3b3Jkc1xuICAgICAqXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHN0ciBTdHJpbmcgaW5jbHVkaW5nIHNvbWUgbWltZSB3b3JkcyB0aGF0IHdpbGwgYmUgZW5jb2RlZFxuICAgICAqIEByZXR1cm4ge1N0cmluZ30gRGVjb2RlZCB1bmljb2RlIHN0cmluZ1xuICAgICAqL1xuICAgIGRlY29kZVdvcmRzOiBmdW5jdGlvbiAoc3RyKSB7XG4gICAgICAgIHN0ciA9IChzdHIgfHwgJycpLnRvU3RyaW5nKCk7XG4gICAgICAgIHN0ciA9IHN0ci5cbiAgICAgICAgcmVwbGFjZSgvKD1cXD9bXj9dK1xcP1tRcUJiXVxcP1teP10rXFw/PSlcXHMrKD89PVxcP1teP10rXFw/W1FxQmJdXFw/W14/XStcXD89KS9nLCAnJDEnKS5cbiAgICAgICAgcmVwbGFjZSgvXFw9XFw/KFtcXHdfXFwtXFwqXSspXFw/KFtRcUJiXSlcXD9bXlxcP10rXFw/XFw9L2csIGZ1bmN0aW9uIChtaW1lV29yZCkge1xuICAgICAgICAgICAgcmV0dXJuIGxpYm1pbWUuZGVjb2RlV29yZChtaW1lV29yZCk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJldHVybiBzdHI7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFNwbGl0cyBhIHN0cmluZyBieSA6XG4gICAgICogVGhlIHJlc3VsdCBpcyBub3QgbWltZSB3b3JkIGRlY29kZWQsIHlvdSBuZWVkIHRvIGRvIHlvdXIgb3duIGRlY29kaW5nIGJhc2VkXG4gICAgICogb24gdGhlIHJ1bGVzIGZvciB0aGUgc3BlY2lmaWMgaGVhZGVyIGtleVxuICAgICAqXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGhlYWRlckxpbmUgU2luZ2xlIGhlYWRlciBsaW5lLCBtaWdodCBpbmNsdWRlIGxpbmVicmVha3MgYXMgd2VsbCBpZiBmb2xkZWRcbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9IEFuZCBvYmplY3Qgb2Yge2tleSwgdmFsdWV9XG4gICAgICovXG4gICAgZGVjb2RlSGVhZGVyOiBmdW5jdGlvbiAoaGVhZGVyTGluZSkge1xuICAgICAgICB2YXIgbGluZSA9IChoZWFkZXJMaW5lIHx8ICcnKS50b1N0cmluZygpLnJlcGxhY2UoLyg/Olxccj9cXG58XFxyKVsgXFx0XSovZywgJyAnKS50cmltKCksXG4gICAgICAgICAgICBtYXRjaCA9IGxpbmUubWF0Y2goL15cXHMqKFteOl0rKTooLiopJC8pLFxuICAgICAgICAgICAga2V5ID0gKG1hdGNoICYmIG1hdGNoWzFdIHx8ICcnKS50cmltKCkudG9Mb3dlckNhc2UoKSxcbiAgICAgICAgICAgIHZhbHVlID0gKG1hdGNoICYmIG1hdGNoWzJdIHx8ICcnKS50cmltKCk7XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGtleToga2V5LFxuICAgICAgICAgICAgdmFsdWU6IHZhbHVlXG4gICAgICAgIH07XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFBhcnNlcyBhIGJsb2NrIG9mIGhlYWRlciBsaW5lcy4gRG9lcyBub3QgZGVjb2RlIG1pbWUgd29yZHMgYXMgZXZlcnlcbiAgICAgKiBoZWFkZXIgbWlnaHQgaGF2ZSBpdHMgb3duIHJ1bGVzIChlZy4gZm9ybWF0dGVkIGVtYWlsIGFkZHJlc3NlcyBhbmQgc3VjaClcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBoZWFkZXJzIEhlYWRlcnMgc3RyaW5nXG4gICAgICogQHJldHVybiB7T2JqZWN0fSBBbiBvYmplY3Qgb2YgaGVhZGVycywgd2hlcmUgaGVhZGVyIGtleXMgYXJlIG9iamVjdCBrZXlzLiBOQiEgU2V2ZXJhbCB2YWx1ZXMgd2l0aCB0aGUgc2FtZSBrZXkgbWFrZSB1cCBhbiBBcnJheVxuICAgICAqL1xuICAgIGRlY29kZUhlYWRlcnM6IGZ1bmN0aW9uIChoZWFkZXJzKSB7XG4gICAgICAgIHZhciBsaW5lcyA9IGhlYWRlcnMuc3BsaXQoL1xccj9cXG58XFxyLyksXG4gICAgICAgICAgICBoZWFkZXJzT2JqID0ge30sXG4gICAgICAgICAgICBoZWFkZXIsXG4gICAgICAgICAgICBpLCBsZW47XG5cbiAgICAgICAgZm9yIChpID0gbGluZXMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgICAgIGlmIChpICYmIGxpbmVzW2ldLm1hdGNoKC9eXFxzLykpIHtcbiAgICAgICAgICAgICAgICBsaW5lc1tpIC0gMV0gKz0gJ1xcclxcbicgKyBsaW5lc1tpXTtcbiAgICAgICAgICAgICAgICBsaW5lcy5zcGxpY2UoaSwgMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKGkgPSAwLCBsZW4gPSBsaW5lcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgaGVhZGVyID0gbGlibWltZS5kZWNvZGVIZWFkZXIobGluZXNbaV0pO1xuICAgICAgICAgICAgaWYgKCFoZWFkZXJzT2JqW2hlYWRlci5rZXldKSB7XG4gICAgICAgICAgICAgICAgaGVhZGVyc09ialtoZWFkZXIua2V5XSA9IFtoZWFkZXIudmFsdWVdO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBoZWFkZXJzT2JqW2hlYWRlci5rZXldLnB1c2goaGVhZGVyLnZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBoZWFkZXJzT2JqO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBKb2lucyBwYXJzZWQgaGVhZGVyIHZhbHVlIHRvZ2V0aGVyIGFzICd2YWx1ZTsgcGFyYW0xPXZhbHVlMTsgcGFyYW0yPXZhbHVlMidcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBzdHJ1Y3R1cmVkIFBhcnNlZCBoZWFkZXIgdmFsdWVcbiAgICAgKiBAcmV0dXJuIHtTdHJpbmd9IGpvaW5lZCBoZWFkZXIgdmFsdWVcbiAgICAgKi9cbiAgICBidWlsZEhlYWRlclZhbHVlOiBmdW5jdGlvbiAoc3RydWN0dXJlZCkge1xuICAgICAgICB2YXIgcGFyYW1zQXJyYXkgPSBbXTtcblxuICAgICAgICBPYmplY3Qua2V5cyhzdHJ1Y3R1cmVkLnBhcmFtcyB8fCB7fSkuZm9yRWFjaChmdW5jdGlvbiAocGFyYW0pIHtcbiAgICAgICAgICAgIC8vIGZpbGVuYW1lIG1pZ2h0IGluY2x1ZGUgdW5pY29kZSBjaGFyYWN0ZXJzIHNvIGl0IGlzIGEgc3BlY2lhbCBjYXNlXG4gICAgICAgICAgICB2YXIgdmFsdWUgPSBzdHJ1Y3R1cmVkLnBhcmFtc1twYXJhbV07XG4gICAgICAgICAgICBpZiAoIWxpYm1pbWUuaXNQbGFpblRleHQodmFsdWUpIHx8IHZhbHVlLmxlbmd0aCA+PSA3NSkge1xuICAgICAgICAgICAgICAgIGxpYm1pbWUuYnVpbGRIZWFkZXJQYXJhbShwYXJhbSwgdmFsdWUsIDUwKS5mb3JFYWNoKGZ1bmN0aW9uIChlbmNvZGVkUGFyYW0pIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCEvW1xcc1wiXFxcXDtcXC89XXxeW1xcLSddfCckLy50ZXN0KGVuY29kZWRQYXJhbS52YWx1ZSkgfHwgZW5jb2RlZFBhcmFtLmtleS5zdWJzdHIoLTEpID09PSAnKicpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcmFtc0FycmF5LnB1c2goZW5jb2RlZFBhcmFtLmtleSArICc9JyArIGVuY29kZWRQYXJhbS52YWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJhbXNBcnJheS5wdXNoKGVuY29kZWRQYXJhbS5rZXkgKyAnPScgKyBKU09OLnN0cmluZ2lmeShlbmNvZGVkUGFyYW0udmFsdWUpKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSBlbHNlIGlmICgvW1xccydcIlxcXFw7XFwvPV18XlxcLS8udGVzdCh2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICBwYXJhbXNBcnJheS5wdXNoKHBhcmFtICsgJz0nICsgSlNPTi5zdHJpbmdpZnkodmFsdWUpKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcGFyYW1zQXJyYXkucHVzaChwYXJhbSArICc9JyArIHZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfS5iaW5kKHRoaXMpKTtcblxuICAgICAgICByZXR1cm4gc3RydWN0dXJlZC52YWx1ZSArIChwYXJhbXNBcnJheS5sZW5ndGggPyAnOyAnICsgcGFyYW1zQXJyYXkuam9pbignOyAnKSA6ICcnKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUGFyc2VzIGEgaGVhZGVyIHZhbHVlIHdpdGgga2V5PXZhbHVlIGFyZ3VtZW50cyBpbnRvIGEgc3RydWN0dXJlZFxuICAgICAqIG9iamVjdC5cbiAgICAgKlxuICAgICAqICAgcGFyc2VIZWFkZXJWYWx1ZSgnY29udGVudC10eXBlOiB0ZXh0L3BsYWluOyBDSEFSU0VUPSdVVEYtOCcnKSAtPlxuICAgICAqICAge1xuICAgICAqICAgICAndmFsdWUnOiAndGV4dC9wbGFpbicsXG4gICAgICogICAgICdwYXJhbXMnOiB7XG4gICAgICogICAgICAgJ2NoYXJzZXQnOiAnVVRGLTgnXG4gICAgICogICAgIH1cbiAgICAgKiAgIH1cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBzdHIgSGVhZGVyIHZhbHVlXG4gICAgICogQHJldHVybiB7T2JqZWN0fSBIZWFkZXIgdmFsdWUgYXMgYSBwYXJzZWQgc3RydWN0dXJlXG4gICAgICovXG4gICAgcGFyc2VIZWFkZXJWYWx1ZTogZnVuY3Rpb24gKHN0cikge1xuICAgICAgICB2YXIgcmVzcG9uc2UgPSB7XG4gICAgICAgICAgICAgICAgdmFsdWU6IGZhbHNlLFxuICAgICAgICAgICAgICAgIHBhcmFtczoge31cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBrZXkgPSBmYWxzZSxcbiAgICAgICAgICAgIHZhbHVlID0gJycsXG4gICAgICAgICAgICB0eXBlID0gJ3ZhbHVlJyxcbiAgICAgICAgICAgIHF1b3RlID0gZmFsc2UsXG4gICAgICAgICAgICBlc2NhcGVkID0gZmFsc2UsXG4gICAgICAgICAgICBjaHI7XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IHN0ci5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgY2hyID0gc3RyLmNoYXJBdChpKTtcbiAgICAgICAgICAgIGlmICh0eXBlID09PSAna2V5Jykge1xuICAgICAgICAgICAgICAgIGlmIChjaHIgPT09ICc9Jykge1xuICAgICAgICAgICAgICAgICAgICBrZXkgPSB2YWx1ZS50cmltKCkudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgICAgICAgICAgICAgdHlwZSA9ICd2YWx1ZSc7XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlID0gJyc7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB2YWx1ZSArPSBjaHI7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmIChlc2NhcGVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlICs9IGNocjtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGNociA9PT0gJ1xcXFwnKSB7XG4gICAgICAgICAgICAgICAgICAgIGVzY2FwZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHF1b3RlICYmIGNociA9PT0gcXVvdGUpIHtcbiAgICAgICAgICAgICAgICAgICAgcXVvdGUgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKCFxdW90ZSAmJiBjaHIgPT09ICdcIicpIHtcbiAgICAgICAgICAgICAgICAgICAgcXVvdGUgPSBjaHI7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmICghcXVvdGUgJiYgY2hyID09PSAnOycpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGtleSA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3BvbnNlLnZhbHVlID0gdmFsdWUudHJpbSgpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzcG9uc2UucGFyYW1zW2tleV0gPSB2YWx1ZS50cmltKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdHlwZSA9ICdrZXknO1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9ICcnO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlICs9IGNocjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZXNjYXBlZCA9IGZhbHNlO1xuXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZSA9PT0gJ3ZhbHVlJykge1xuICAgICAgICAgICAgaWYgKGtleSA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICByZXNwb25zZS52YWx1ZSA9IHZhbHVlLnRyaW0oKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmVzcG9uc2UucGFyYW1zW2tleV0gPSB2YWx1ZS50cmltKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAodmFsdWUudHJpbSgpKSB7XG4gICAgICAgICAgICByZXNwb25zZS5wYXJhbXNbdmFsdWUudHJpbSgpLnRvTG93ZXJDYXNlKCldID0gJyc7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBoYW5kbGUgcGFyYW1ldGVyIHZhbHVlIGNvbnRpbnVhdGlvbnNcbiAgICAgICAgLy8gaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzIyMzEjc2VjdGlvbi0zXG5cbiAgICAgICAgLy8gcHJlcHJvY2VzcyB2YWx1ZXNcbiAgICAgICAgT2JqZWN0LmtleXMocmVzcG9uc2UucGFyYW1zKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgICAgIHZhciBhY3R1YWxLZXksIG5yLCBtYXRjaCwgdmFsdWU7XG4gICAgICAgICAgICBpZiAoKG1hdGNoID0ga2V5Lm1hdGNoKC8oXFwqKFxcZCspfFxcKihcXGQrKVxcKnxcXCopJC8pKSkge1xuICAgICAgICAgICAgICAgIGFjdHVhbEtleSA9IGtleS5zdWJzdHIoMCwgbWF0Y2guaW5kZXgpO1xuICAgICAgICAgICAgICAgIG5yID0gTnVtYmVyKG1hdGNoWzJdIHx8IG1hdGNoWzNdKSB8fCAwO1xuXG4gICAgICAgICAgICAgICAgaWYgKCFyZXNwb25zZS5wYXJhbXNbYWN0dWFsS2V5XSB8fCB0eXBlb2YgcmVzcG9uc2UucGFyYW1zW2FjdHVhbEtleV0gIT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3BvbnNlLnBhcmFtc1thY3R1YWxLZXldID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2hhcnNldDogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZXM6IFtdXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgdmFsdWUgPSByZXNwb25zZS5wYXJhbXNba2V5XTtcblxuICAgICAgICAgICAgICAgIGlmIChuciA9PT0gMCAmJiBtYXRjaFswXS5zdWJzdHIoLTEpID09PSAnKicgJiYgKG1hdGNoID0gdmFsdWUubWF0Y2goL14oW14nXSopJ1teJ10qJyguKikkLykpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3BvbnNlLnBhcmFtc1thY3R1YWxLZXldLmNoYXJzZXQgPSBtYXRjaFsxXSB8fCAnaXNvLTg4NTktMSc7XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlID0gbWF0Y2hbMl07XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcmVzcG9uc2UucGFyYW1zW2FjdHVhbEtleV0udmFsdWVzW25yXSA9IHZhbHVlO1xuXG4gICAgICAgICAgICAgICAgLy8gcmVtb3ZlIHRoZSBvbGQgcmVmZXJlbmNlXG4gICAgICAgICAgICAgICAgZGVsZXRlIHJlc3BvbnNlLnBhcmFtc1trZXldO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICAvLyBjb25jYXRlbmF0ZSBzcGxpdCByZmMyMjMxIHN0cmluZ3MgYW5kIGNvbnZlcnQgZW5jb2RlZCBzdHJpbmdzIHRvIG1pbWUgZW5jb2RlZCB3b3Jkc1xuICAgICAgICBPYmplY3Qua2V5cyhyZXNwb25zZS5wYXJhbXMpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgICAgICAgICAgdmFyIHZhbHVlO1xuICAgICAgICAgICAgaWYgKHJlc3BvbnNlLnBhcmFtc1trZXldICYmIEFycmF5LmlzQXJyYXkocmVzcG9uc2UucGFyYW1zW2tleV0udmFsdWVzKSkge1xuICAgICAgICAgICAgICAgIHZhbHVlID0gcmVzcG9uc2UucGFyYW1zW2tleV0udmFsdWVzLm1hcChmdW5jdGlvbiAodmFsKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB2YWwgfHwgJyc7XG4gICAgICAgICAgICAgICAgfSkuam9pbignJyk7XG5cbiAgICAgICAgICAgICAgICBpZiAocmVzcG9uc2UucGFyYW1zW2tleV0uY2hhcnNldCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBjb252ZXJ0IFwiJUFCXCIgdG8gXCI9P2NoYXJzZXQ/UT89QUI/PVwiXG4gICAgICAgICAgICAgICAgICAgIHJlc3BvbnNlLnBhcmFtc1trZXldID0gJz0/JyArXG4gICAgICAgICAgICAgICAgICAgICAgICByZXNwb25zZS5wYXJhbXNba2V5XS5jaGFyc2V0ICtcbiAgICAgICAgICAgICAgICAgICAgICAgICc/UT8nICtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlLlxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gZml4IGludmFsaWRseSBlbmNvZGVkIGNoYXJzXG4gICAgICAgICAgICAgICAgICAgIHJlcGxhY2UoL1s9XFw/X1xcc10vZyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbiAocykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgYyA9IHMuY2hhckNvZGVBdCgwKS50b1N0cmluZygxNik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzID09PSAnICcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAnXyc7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gJyUnICsgKGMubGVuZ3RoIDwgMiA/ICcwJyA6ICcnKSArIGM7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICApLlxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gY2hhbmdlIGZyb20gdXJsZW5jb2RpbmcgdG8gcGVyY2VudCBlbmNvZGluZ1xuICAgICAgICAgICAgICAgICAgICByZXBsYWNlKC8lL2csICc9JykgK1xuICAgICAgICAgICAgICAgICAgICAgICAgJz89JztcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXNwb25zZS5wYXJhbXNba2V5XSA9IHZhbHVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfS5iaW5kKHRoaXMpKTtcblxuICAgICAgICByZXR1cm4gcmVzcG9uc2U7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEVuY29kZXMgYSBzdHJpbmcgb3IgYW4gQnVmZmVyIHRvIGFuIFVURi04IFBhcmFtZXRlciBWYWx1ZSBDb250aW51YXRpb24gZW5jb2RpbmcgKHJmYzIyMzEpXG4gICAgICogVXNlZnVsIGZvciBzcGxpdHRpbmcgbG9uZyBwYXJhbWV0ZXIgdmFsdWVzLlxuICAgICAqXG4gICAgICogRm9yIGV4YW1wbGVcbiAgICAgKiAgICAgIHRpdGxlPVwidW5pY29kZSBzdHJpbmdcIlxuICAgICAqIGJlY29tZXNcbiAgICAgKiAgICAgdGl0bGUqMCo9dXRmLTgnJ3VuaWNvZGVcbiAgICAgKiAgICAgdGl0bGUqMSo9JTIwc3RyaW5nXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1N0cmluZ3xCdWZmZXJ9IGRhdGEgU3RyaW5nIHRvIGJlIGVuY29kZWRcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW21heExlbmd0aD01MF0gTWF4IGxlbmd0aCBmb3IgZ2VuZXJhdGVkIGNodW5rc1xuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbZnJvbUNoYXJzZXQ9J1VURi04J10gU291cmNlIHNoYXJhY3RlciBzZXRcbiAgICAgKiBAcmV0dXJuIHtBcnJheX0gQSBsaXN0IG9mIGVuY29kZWQga2V5cyBhbmQgaGVhZGVyc1xuICAgICAqL1xuICAgIGJ1aWxkSGVhZGVyUGFyYW06IGZ1bmN0aW9uIChrZXksIGRhdGEsIG1heExlbmd0aCwgZnJvbUNoYXJzZXQpIHtcbiAgICAgICAgdmFyIGxpc3QgPSBbXTtcbiAgICAgICAgdmFyIGVuY29kZWRTdHIgPSB0eXBlb2YgZGF0YSA9PT0gJ3N0cmluZycgPyBkYXRhIDogbGlibWltZS5kZWNvZGUoZGF0YSwgZnJvbUNoYXJzZXQpO1xuICAgICAgICB2YXIgZW5jb2RlZFN0ckFycjtcbiAgICAgICAgdmFyIGNociwgb3JkO1xuICAgICAgICB2YXIgbGluZTtcbiAgICAgICAgdmFyIHN0YXJ0UG9zID0gMDtcbiAgICAgICAgdmFyIGlzRW5jb2RlZCA9IGZhbHNlO1xuICAgICAgICB2YXIgaSwgbGVuO1xuXG4gICAgICAgIG1heExlbmd0aCA9IG1heExlbmd0aCB8fCA1MDtcblxuICAgICAgICAvLyBwcm9jZXNzIGFzY2lpIG9ubHkgdGV4dFxuICAgICAgICBpZiAobGlibWltZS5pc1BsYWluVGV4dChkYXRhKSkge1xuXG4gICAgICAgICAgICAvLyBjaGVjayBpZiBjb252ZXJzaW9uIGlzIGV2ZW4gbmVlZGVkXG4gICAgICAgICAgICBpZiAoZW5jb2RlZFN0ci5sZW5ndGggPD0gbWF4TGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFt7XG4gICAgICAgICAgICAgICAgICAgIGtleToga2V5LFxuICAgICAgICAgICAgICAgICAgICB2YWx1ZTogZW5jb2RlZFN0clxuICAgICAgICAgICAgICAgIH1dO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBlbmNvZGVkU3RyID0gZW5jb2RlZFN0ci5yZXBsYWNlKG5ldyBSZWdFeHAoJy57JyArIG1heExlbmd0aCArICd9JywgJ2cnKSwgZnVuY3Rpb24gKHN0cikge1xuICAgICAgICAgICAgICAgIGxpc3QucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgIGxpbmU6IHN0clxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHJldHVybiAnJztcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBpZiAoZW5jb2RlZFN0cikge1xuICAgICAgICAgICAgICAgIGxpc3QucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgIGxpbmU6IGVuY29kZWRTdHJcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICB9IGVsc2Uge1xuXG4gICAgICAgICAgICBpZiAoL1tcXHVEODAwLVxcdURCRkZdLy50ZXN0KGVuY29kZWRTdHIpKSB7XG4gICAgICAgICAgICAgICAgLy8gc3RyaW5nIGNvbnRhaW50cyBzdXJyb2dhdGUgcGFpcnMsIHNvIG5vcm1hbGl6ZSBpdCB0byBhbiBhcnJheSBvZiBieXRlc1xuICAgICAgICAgICAgICAgIGVuY29kZWRTdHJBcnIgPSBbXTtcbiAgICAgICAgICAgICAgICBmb3IgKGkgPSAwLCBsZW4gPSBlbmNvZGVkU3RyLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIGNociA9IGVuY29kZWRTdHIuY2hhckF0KGkpO1xuICAgICAgICAgICAgICAgICAgICBvcmQgPSBjaHIuY2hhckNvZGVBdCgwKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG9yZCA+PSAweEQ4MDAgJiYgb3JkIDw9IDB4REJGRiAmJiBpIDwgbGVuIC0gMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2hyICs9IGVuY29kZWRTdHIuY2hhckF0KGkgKyAxKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVuY29kZWRTdHJBcnIucHVzaChjaHIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaSsrO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgZW5jb2RlZFN0ckFyci5wdXNoKGNocik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZW5jb2RlZFN0ciA9IGVuY29kZWRTdHJBcnI7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIGZpcnN0IGxpbmUgaW5jbHVkZXMgdGhlIGNoYXJzZXQgYW5kIGxhbmd1YWdlIGluZm8gYW5kIG5lZWRzIHRvIGJlIGVuY29kZWRcbiAgICAgICAgICAgIC8vIGV2ZW4gaWYgaXQgZG9lcyBub3QgY29udGFpbiBhbnkgdW5pY29kZSBjaGFyYWN0ZXJzXG4gICAgICAgICAgICBsaW5lID0gJ3V0Zi04XFwnXFwnJztcbiAgICAgICAgICAgIGlzRW5jb2RlZCA9IHRydWU7XG4gICAgICAgICAgICBzdGFydFBvcyA9IDA7XG5cbiAgICAgICAgICAgIC8vIHByb2Nlc3MgdGV4dCB3aXRoIHVuaWNvZGUgb3Igc3BlY2lhbCBjaGFyc1xuICAgICAgICAgICAgZm9yIChpID0gMCwgbGVuID0gZW5jb2RlZFN0ci5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuXG4gICAgICAgICAgICAgICAgY2hyID0gZW5jb2RlZFN0cltpXTtcblxuICAgICAgICAgICAgICAgIGlmIChpc0VuY29kZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgY2hyID0gc2FmZUVuY29kZVVSSUNvbXBvbmVudChjaHIpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIHRyeSB0byB1cmxlbmNvZGUgY3VycmVudCBjaGFyXG4gICAgICAgICAgICAgICAgICAgIGNociA9IGNociA9PT0gJyAnID8gY2hyIDogc2FmZUVuY29kZVVSSUNvbXBvbmVudChjaHIpO1xuICAgICAgICAgICAgICAgICAgICAvLyBCeSBkZWZhdWx0IGl0IGlzIG5vdCByZXF1aXJlZCB0byBlbmNvZGUgYSBsaW5lLCB0aGUgbmVlZFxuICAgICAgICAgICAgICAgICAgICAvLyBvbmx5IGFwcGVhcnMgd2hlbiB0aGUgc3RyaW5nIGNvbnRhaW5zIHVuaWNvZGUgb3Igc3BlY2lhbCBjaGFyc1xuICAgICAgICAgICAgICAgICAgICAvLyBpbiB0aGlzIGNhc2Ugd2Ugc3RhcnQgcHJvY2Vzc2luZyB0aGUgbGluZSBvdmVyIGFuZCBlbmNvZGUgYWxsIGNoYXJzXG4gICAgICAgICAgICAgICAgICAgIGlmIChjaHIgIT09IGVuY29kZWRTdHJbaV0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIENoZWNrIGlmIGl0IGlzIGV2ZW4gcG9zc2libGUgdG8gYWRkIHRoZSBlbmNvZGVkIGNoYXIgdG8gdGhlIGxpbmVcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIElmIG5vdCwgdGhlcmUgaXMgbm8gcmVhc29uIHRvIHVzZSB0aGlzIGxpbmUsIGp1c3QgcHVzaCBpdCB0byB0aGUgbGlzdFxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gYW5kIHN0YXJ0IGEgbmV3IGxpbmUgd2l0aCB0aGUgY2hhciB0aGF0IG5lZWRzIGVuY29kaW5nXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoKHNhZmVFbmNvZGVVUklDb21wb25lbnQobGluZSkgKyBjaHIpLmxlbmd0aCA+PSBtYXhMZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsaXN0LnB1c2goe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsaW5lOiBsaW5lLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbmNvZGVkOiBpc0VuY29kZWRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsaW5lID0gJyc7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhcnRQb3MgPSBpIC0gMTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaXNFbmNvZGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpID0gc3RhcnRQb3M7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGluZSA9ICcnO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gaWYgdGhlIGxpbmUgaXMgYWxyZWFkeSB0b28gbG9uZywgcHVzaCBpdCB0byB0aGUgbGlzdCBhbmQgc3RhcnQgYSBuZXcgb25lXG4gICAgICAgICAgICAgICAgaWYgKChsaW5lICsgY2hyKS5sZW5ndGggPj0gbWF4TGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIGxpc3QucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgICAgICBsaW5lOiBsaW5lLFxuICAgICAgICAgICAgICAgICAgICAgICAgZW5jb2RlZDogaXNFbmNvZGVkXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBsaW5lID0gY2hyID0gZW5jb2RlZFN0cltpXSA9PT0gJyAnID8gJyAnIDogc2FmZUVuY29kZVVSSUNvbXBvbmVudChlbmNvZGVkU3RyW2ldKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNociA9PT0gZW5jb2RlZFN0cltpXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaXNFbmNvZGVkID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdGFydFBvcyA9IGkgLSAxO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgaXNFbmNvZGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGxpbmUgKz0gY2hyO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGxpbmUpIHtcbiAgICAgICAgICAgICAgICBsaXN0LnB1c2goe1xuICAgICAgICAgICAgICAgICAgICBsaW5lOiBsaW5lLFxuICAgICAgICAgICAgICAgICAgICBlbmNvZGVkOiBpc0VuY29kZWRcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBsaXN0Lm1hcChmdW5jdGlvbiAoaXRlbSwgaSkge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAvLyBlbmNvZGVkIGxpbmVzOiB7bmFtZX0qe3BhcnR9KlxuICAgICAgICAgICAgICAgIC8vIHVuZW5jb2RlZCBsaW5lczoge25hbWV9KntwYXJ0fVxuICAgICAgICAgICAgICAgIC8vIGlmIGFueSBsaW5lIG5lZWRzIHRvIGJlIGVuY29kZWQgdGhlbiB0aGUgZmlyc3QgbGluZSAocGFydD09MCkgaXMgYWx3YXlzIGVuY29kZWRcbiAgICAgICAgICAgICAgICBrZXk6IGtleSArICcqJyArIGkgKyAoaXRlbS5lbmNvZGVkID8gJyonIDogJycpLFxuICAgICAgICAgICAgICAgIHZhbHVlOiBpdGVtLmxpbmVcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0pO1xuICAgIH0sXG5cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgZmlsZSBleHRlbnNpb24gZm9yIGEgY29udGVudCB0eXBlIHN0cmluZy4gSWYgbm8gc3VpdGFibGUgZXh0ZW5zaW9uc1xuICAgICAqIGFyZSBmb3VuZCwgJ2JpbicgaXMgdXNlZCBhcyB0aGUgZGVmYXVsdCBleHRlbnNpb25cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBtaW1lVHlwZSBDb250ZW50IHR5cGUgdG8gYmUgY2hlY2tlZCBmb3JcbiAgICAgKiBAcmV0dXJuIHtTdHJpbmd9IEZpbGUgZXh0ZW5zaW9uXG4gICAgICovXG4gICAgZGV0ZWN0RXh0ZW5zaW9uOiBmdW5jdGlvbiAobWltZVR5cGUpIHtcbiAgICAgICAgbWltZVR5cGUgPSAobWltZVR5cGUgfHwgJycpLnRvU3RyaW5nKCkudG9Mb3dlckNhc2UoKS5yZXBsYWNlKC9cXHMvZywgJycpO1xuICAgICAgICBpZiAoIShtaW1lVHlwZSBpbiBtaW1ldHlwZXMubGlzdCkpIHtcbiAgICAgICAgICAgIHJldHVybiAnYmluJztcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2YgbWltZXR5cGVzLmxpc3RbbWltZVR5cGVdID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgcmV0dXJuIG1pbWV0eXBlcy5saXN0W21pbWVUeXBlXTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBtaW1lUGFydHMgPSBtaW1lVHlwZS5zcGxpdCgnLycpO1xuXG4gICAgICAgIC8vIHNlYXJjaCBmb3IgbmFtZSBtYXRjaFxuICAgICAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gbWltZXR5cGVzLmxpc3RbbWltZVR5cGVdLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICBpZiAobWltZVBhcnRzWzFdID09PSBtaW1ldHlwZXMubGlzdFttaW1lVHlwZV1baV0pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbWltZXR5cGVzLmxpc3RbbWltZVR5cGVdW2ldO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gdXNlIHRoZSBmaXJzdCBvbmVcbiAgICAgICAgcmV0dXJuIG1pbWV0eXBlcy5saXN0W21pbWVUeXBlXVswXSAhPT0gJyonID8gbWltZXR5cGVzLmxpc3RbbWltZVR5cGVdWzBdIDogJ2Jpbic7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgY29udGVudCB0eXBlIGZvciBhIGZpbGUgZXh0ZW5zaW9uLiBJZiBubyBzdWl0YWJsZSBjb250ZW50IHR5cGVzXG4gICAgICogYXJlIGZvdW5kLCAnYXBwbGljYXRpb24vb2N0ZXQtc3RyZWFtJyBpcyB1c2VkIGFzIHRoZSBkZWZhdWx0IGNvbnRlbnQgdHlwZVxuICAgICAqXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGV4dGVuc2lvbiBFeHRlbnNpb24gdG8gYmUgY2hlY2tlZCBmb3JcbiAgICAgKiBAcmV0dXJuIHtTdHJpbmd9IEZpbGUgZXh0ZW5zaW9uXG4gICAgICovXG4gICAgZGV0ZWN0TWltZVR5cGU6IGZ1bmN0aW9uIChleHRlbnNpb24pIHtcbiAgICAgICAgZXh0ZW5zaW9uID0gKGV4dGVuc2lvbiB8fCAnJykudG9TdHJpbmcoKS50b0xvd2VyQ2FzZSgpLnJlcGxhY2UoL1xccy9nLCAnJykucmVwbGFjZSgvXlxcLi9nLCAnJykuc3BsaXQoJy4nKS5wb3AoKTtcblxuICAgICAgICBpZiAoIShleHRlbnNpb24gaW4gbWltZXR5cGVzLmV4dGVuc2lvbnMpKSB7XG4gICAgICAgICAgICByZXR1cm4gJ2FwcGxpY2F0aW9uL29jdGV0LXN0cmVhbSc7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIG1pbWV0eXBlcy5leHRlbnNpb25zW2V4dGVuc2lvbl0gPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICByZXR1cm4gbWltZXR5cGVzLmV4dGVuc2lvbnNbZXh0ZW5zaW9uXTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBtaW1lUGFydHM7XG5cbiAgICAgICAgLy8gc2VhcmNoIGZvciBuYW1lIG1hdGNoXG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBtaW1ldHlwZXMuZXh0ZW5zaW9uc1tleHRlbnNpb25dLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICBtaW1lUGFydHMgPSBtaW1ldHlwZXMuZXh0ZW5zaW9uc1tleHRlbnNpb25dW2ldLnNwbGl0KCcvJyk7XG4gICAgICAgICAgICBpZiAobWltZVBhcnRzWzFdID09PSBleHRlbnNpb24pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbWltZXR5cGVzLmV4dGVuc2lvbnNbZXh0ZW5zaW9uXVtpXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHVzZSB0aGUgZmlyc3Qgb25lXG4gICAgICAgIHJldHVybiBtaW1ldHlwZXMuZXh0ZW5zaW9uc1tleHRlbnNpb25dWzBdO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBGb2xkcyBsb25nIGxpbmVzLCB1c2VmdWwgZm9yIGZvbGRpbmcgaGVhZGVyIGxpbmVzIChhZnRlclNwYWNlPWZhbHNlKSBhbmRcbiAgICAgKiBmbG93ZWQgdGV4dCAoYWZ0ZXJTcGFjZT10cnVlKVxuICAgICAqXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHN0ciBTdHJpbmcgdG8gYmUgZm9sZGVkXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtsaW5lTGVuZ3RoPTc2XSBNYXhpbXVtIGxlbmd0aCBvZiBhIGxpbmVcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IGFmdGVyU3BhY2UgSWYgdHJ1ZSwgbGVhdmUgYSBzcGFjZSBpbiB0aCBlbmQgb2YgYSBsaW5lXG4gICAgICogQHJldHVybiB7U3RyaW5nfSBTdHJpbmcgd2l0aCBmb2xkZWQgbGluZXNcbiAgICAgKi9cbiAgICBmb2xkTGluZXM6IGZ1bmN0aW9uIChzdHIsIGxpbmVMZW5ndGgsIGFmdGVyU3BhY2UpIHtcbiAgICAgICAgc3RyID0gKHN0ciB8fCAnJykudG9TdHJpbmcoKTtcbiAgICAgICAgbGluZUxlbmd0aCA9IGxpbmVMZW5ndGggfHwgNzY7XG5cbiAgICAgICAgdmFyIHBvcyA9IDAsXG4gICAgICAgICAgICBsZW4gPSBzdHIubGVuZ3RoLFxuICAgICAgICAgICAgcmVzdWx0ID0gJycsXG4gICAgICAgICAgICBsaW5lLCBtYXRjaDtcblxuICAgICAgICB3aGlsZSAocG9zIDwgbGVuKSB7XG4gICAgICAgICAgICBsaW5lID0gc3RyLnN1YnN0cihwb3MsIGxpbmVMZW5ndGgpO1xuICAgICAgICAgICAgaWYgKGxpbmUubGVuZ3RoIDwgbGluZUxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHJlc3VsdCArPSBsaW5lO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKChtYXRjaCA9IGxpbmUubWF0Y2goL15bXlxcblxccl0qKFxccj9cXG58XFxyKS8pKSkge1xuICAgICAgICAgICAgICAgIGxpbmUgPSBtYXRjaFswXTtcbiAgICAgICAgICAgICAgICByZXN1bHQgKz0gbGluZTtcbiAgICAgICAgICAgICAgICBwb3MgKz0gbGluZS5sZW5ndGg7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKChtYXRjaCA9IGxpbmUubWF0Y2goLyhcXHMrKVteXFxzXSokLykpICYmIG1hdGNoWzBdLmxlbmd0aCAtIChhZnRlclNwYWNlID8gKG1hdGNoWzFdIHx8ICcnKS5sZW5ndGggOiAwKSA8IGxpbmUubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgbGluZSA9IGxpbmUuc3Vic3RyKDAsIGxpbmUubGVuZ3RoIC0gKG1hdGNoWzBdLmxlbmd0aCAtIChhZnRlclNwYWNlID8gKG1hdGNoWzFdIHx8ICcnKS5sZW5ndGggOiAwKSkpO1xuICAgICAgICAgICAgfSBlbHNlIGlmICgobWF0Y2ggPSBzdHIuc3Vic3RyKHBvcyArIGxpbmUubGVuZ3RoKS5tYXRjaCgvXlteXFxzXSsoXFxzKikvKSkpIHtcbiAgICAgICAgICAgICAgICBsaW5lID0gbGluZSArIG1hdGNoWzBdLnN1YnN0cigwLCBtYXRjaFswXS5sZW5ndGggLSAoIWFmdGVyU3BhY2UgPyAobWF0Y2hbMV0gfHwgJycpLmxlbmd0aCA6IDApKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmVzdWx0ICs9IGxpbmU7XG4gICAgICAgICAgICBwb3MgKz0gbGluZS5sZW5ndGg7XG4gICAgICAgICAgICBpZiAocG9zIDwgbGVuKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0ICs9ICdcXHJcXG4nO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG59O1xuXG4vKipcbiAqIFNwbGl0cyBhIG1pbWUgZW5jb2RlZCBzdHJpbmcuIE5lZWRlZCBmb3IgZGl2aWRpbmcgbWltZSB3b3JkcyBpbnRvIHNtYWxsZXIgY2h1bmtzXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHN0ciBNaW1lIGVuY29kZWQgc3RyaW5nIHRvIGJlIHNwbGl0IHVwXG4gKiBAcGFyYW0ge051bWJlcn0gbWF4bGVuIE1heGltdW0gbGVuZ3RoIG9mIGNoYXJhY3RlcnMgZm9yIG9uZSBwYXJ0IChtaW5pbXVtIDEyKVxuICogQHJldHVybiB7QXJyYXl9IFNwbGl0IHN0cmluZ1xuICovXG5mdW5jdGlvbiBzcGxpdE1pbWVFbmNvZGVkU3RyaW5nKHN0ciwgbWF4bGVuKSB7XG4gICAgdmFyIGN1ckxpbmUsIG1hdGNoLCBjaHIsIGRvbmUsXG4gICAgICAgIGxpbmVzID0gW107XG5cbiAgICAvLyByZXF1aXJlIGF0IGxlYXN0IDEyIHN5bWJvbHMgdG8gZml0IHBvc3NpYmxlIDQgb2N0ZXQgVVRGLTggc2VxdWVuY2VzXG4gICAgbWF4bGVuID0gTWF0aC5tYXgobWF4bGVuIHx8IDAsIDEyKTtcblxuICAgIHdoaWxlIChzdHIubGVuZ3RoKSB7XG4gICAgICAgIGN1ckxpbmUgPSBzdHIuc3Vic3RyKDAsIG1heGxlbik7XG5cbiAgICAgICAgLy8gbW92ZSBpbmNvbXBsZXRlIGVzY2FwZWQgY2hhciBiYWNrIHRvIG1haW5cbiAgICAgICAgaWYgKChtYXRjaCA9IGN1ckxpbmUubWF0Y2goL1xcPVswLTlBLUZdPyQvaSkpKSB7XG4gICAgICAgICAgICBjdXJMaW5lID0gY3VyTGluZS5zdWJzdHIoMCwgbWF0Y2guaW5kZXgpO1xuICAgICAgICB9XG5cbiAgICAgICAgZG9uZSA9IGZhbHNlO1xuICAgICAgICB3aGlsZSAoIWRvbmUpIHtcbiAgICAgICAgICAgIGRvbmUgPSB0cnVlO1xuICAgICAgICAgICAgLy8gY2hlY2sgaWYgbm90IG1pZGRsZSBvZiBhIHVuaWNvZGUgY2hhciBzZXF1ZW5jZVxuICAgICAgICAgICAgaWYgKChtYXRjaCA9IHN0ci5zdWJzdHIoY3VyTGluZS5sZW5ndGgpLm1hdGNoKC9eXFw9KFswLTlBLUZdezJ9KS9pKSkpIHtcbiAgICAgICAgICAgICAgICBjaHIgPSBwYXJzZUludChtYXRjaFsxXSwgMTYpO1xuICAgICAgICAgICAgICAgIC8vIGludmFsaWQgc2VxdWVuY2UsIG1vdmUgb25lIGNoYXIgYmFjayBhbmMgcmVjaGVja1xuICAgICAgICAgICAgICAgIGlmIChjaHIgPCAweEMyICYmIGNociA+IDB4N0YpIHtcbiAgICAgICAgICAgICAgICAgICAgY3VyTGluZSA9IGN1ckxpbmUuc3Vic3RyKDAsIGN1ckxpbmUubGVuZ3RoIC0gMyk7XG4gICAgICAgICAgICAgICAgICAgIGRvbmUgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoY3VyTGluZS5sZW5ndGgpIHtcbiAgICAgICAgICAgIGxpbmVzLnB1c2goY3VyTGluZSk7XG4gICAgICAgIH1cbiAgICAgICAgc3RyID0gc3RyLnN1YnN0cihjdXJMaW5lLmxlbmd0aCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGxpbmVzO1xufVxuXG5mdW5jdGlvbiBlbmNvZGVVUklDaGFyQ29tcG9uZW50KGNocikge1xuICAgIHZhciBpLCBsZW4sIG9yZDtcbiAgICB2YXIgcmVzID0gJyc7XG5cbiAgICBvcmQgPSBjaHIuY2hhckNvZGVBdCgwKS50b1N0cmluZygxNikudG9VcHBlckNhc2UoKTtcbiAgICBpZiAob3JkLmxlbmd0aCAlIDIpIHtcbiAgICAgICAgb3JkID0gJzAnICsgb3JkO1xuICAgIH1cbiAgICBpZiAob3JkLmxlbmd0aCA+IDIpIHtcbiAgICAgICAgZm9yIChpID0gMCwgbGVuID0gb3JkLmxlbmd0aCAvIDI7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgcmVzICs9ICclJyArIG9yZC5zdWJzdHIoaSwgMik7XG4gICAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgICByZXMgKz0gJyUnICsgb3JkO1xuICAgIH1cblxuICAgIHJldHVybiByZXM7XG59XG5cbmZ1bmN0aW9uIHNhZmVFbmNvZGVVUklDb21wb25lbnQoc3RyKSB7XG4gICAgc3RyID0gKHN0ciB8fCAnJykudG9TdHJpbmcoKTtcblxuICAgIHRyeSB7XG4gICAgICAgIC8vIG1pZ2h0IHRocm93IGlmIHdlIHRyeSB0byBlbmNvZGUgaW52YWxpZCBzZXF1ZW5jZXMsIGVnLiBwYXJ0aWFsIGVtb2ppXG4gICAgICAgIHN0ciA9IGVuY29kZVVSSUNvbXBvbmVudChzdHIpO1xuICAgIH0gY2F0Y2ggKEUpIHtcbiAgICAgICAgLy8gc2hvdWxkIG5ldmVyIHJ1blxuICAgICAgICByZXR1cm4gc3RyLnJlcGxhY2UoL1teXFx4MDAtXFx4MUYgKicoKTw+QCw7OlxcXFxcIlxcW1xcXT89XFx1MDA3Ri1cXHVGRkZGXSsvZywgJycpO1xuICAgIH1cblxuICAgIC8vIGVuc3VyZSBjaGFycyB0aGF0IGFyZSBub3QgaGFuZGxlZCBieSBlbmNvZGVVUklDb21wZW50IGFyZSBjb252ZXJ0ZWQgYXMgd2VsbFxuICAgIHJldHVybiBzdHIucmVwbGFjZSgvW1xceDAwLVxceDFGIConKCk8PkAsOzpcXFxcXCJcXFtcXF0/PVxcdTAwN0YtXFx1RkZGRl0vZywgZW5jb2RlVVJJQ2hhckNvbXBvbmVudCk7XG59XG5cbn0pLmNhbGwodGhpcyxyZXF1aXJlKFwiYnVmZmVyXCIpLkJ1ZmZlcikiLCIvKiBlc2xpbnQgcXVvdGUtcHJvcHM6IDAgKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgICBsaXN0OiB7XG4gICAgICAgICdhcHBsaWNhdGlvbi9hY2FkJzogJ2R3ZycsXG4gICAgICAgICdhcHBsaWNhdGlvbi9hcHBsaXh3YXJlJzogJ2F3JyxcbiAgICAgICAgJ2FwcGxpY2F0aW9uL2Fyaic6ICdhcmonLFxuICAgICAgICAnYXBwbGljYXRpb24vYXRvbSt4bWwnOiAneG1sJyxcbiAgICAgICAgJ2FwcGxpY2F0aW9uL2F0b21jYXQreG1sJzogJ2F0b21jYXQnLFxuICAgICAgICAnYXBwbGljYXRpb24vYXRvbXN2Yyt4bWwnOiAnYXRvbXN2YycsXG4gICAgICAgICdhcHBsaWNhdGlvbi9iYXNlNjQnOiBbJ21tJywgJ21tZSddLFxuICAgICAgICAnYXBwbGljYXRpb24vYmluaGV4JzogJ2hxeCcsXG4gICAgICAgICdhcHBsaWNhdGlvbi9iaW5oZXg0JzogJ2hxeCcsXG4gICAgICAgICdhcHBsaWNhdGlvbi9ib29rJzogWydib29rJywgJ2JvbyddLFxuICAgICAgICAnYXBwbGljYXRpb24vY2N4bWwreG1sLCc6ICdjY3htbCcsXG4gICAgICAgICdhcHBsaWNhdGlvbi9jZGYnOiAnY2RmJyxcbiAgICAgICAgJ2FwcGxpY2F0aW9uL2NkbWktY2FwYWJpbGl0eSc6ICdjZG1pYScsXG4gICAgICAgICdhcHBsaWNhdGlvbi9jZG1pLWNvbnRhaW5lcic6ICdjZG1pYycsXG4gICAgICAgICdhcHBsaWNhdGlvbi9jZG1pLWRvbWFpbic6ICdjZG1pZCcsXG4gICAgICAgICdhcHBsaWNhdGlvbi9jZG1pLW9iamVjdCc6ICdjZG1pbycsXG4gICAgICAgICdhcHBsaWNhdGlvbi9jZG1pLXF1ZXVlJzogJ2NkbWlxJyxcbiAgICAgICAgJ2FwcGxpY2F0aW9uL2NsYXJpc2NhZCc6ICdjY2FkJyxcbiAgICAgICAgJ2FwcGxpY2F0aW9uL2NvbW1vbmdyb3VuZCc6ICdkcCcsXG4gICAgICAgICdhcHBsaWNhdGlvbi9jdS1zZWVtZSc6ICdjdScsXG4gICAgICAgICdhcHBsaWNhdGlvbi9kYXZtb3VudCt4bWwnOiAnZGF2bW91bnQnLFxuICAgICAgICAnYXBwbGljYXRpb24vZHJhZnRpbmcnOiAnZHJ3JyxcbiAgICAgICAgJ2FwcGxpY2F0aW9uL2RzcHR5cGUnOiAndHNwJyxcbiAgICAgICAgJ2FwcGxpY2F0aW9uL2Rzc2MrZGVyJzogJ2Rzc2MnLFxuICAgICAgICAnYXBwbGljYXRpb24vZHNzYyt4bWwnOiAneGRzc2MnLFxuICAgICAgICAnYXBwbGljYXRpb24vZHhmJzogJ2R4ZicsXG4gICAgICAgICdhcHBsaWNhdGlvbi9lY21hc2NyaXB0JzogWydqcycsICdlcyddLFxuICAgICAgICAnYXBwbGljYXRpb24vZW1tYSt4bWwnOiAnZW1tYScsXG4gICAgICAgICdhcHBsaWNhdGlvbi9lbnZveSc6ICdldnknLFxuICAgICAgICAnYXBwbGljYXRpb24vZXB1Yit6aXAnOiAnZXB1YicsXG4gICAgICAgICdhcHBsaWNhdGlvbi9leGNlbCc6IFsneGxzJywgJ3hsJywgJ3hsYScsICd4bGInLCAneGxjJywgJ3hsZCcsICd4bGsnLCAneGxsJywgJ3hsbScsICd4bHQnLCAneGx2JywgJ3hsdyddLFxuICAgICAgICAnYXBwbGljYXRpb24vZXhpJzogJ2V4aScsXG4gICAgICAgICdhcHBsaWNhdGlvbi9mb250LXRkcGZyJzogJ3BmcicsXG4gICAgICAgICdhcHBsaWNhdGlvbi9mcmFjdGFscyc6ICdmaWYnLFxuICAgICAgICAnYXBwbGljYXRpb24vZnJlZWxvYWRlcic6ICdmcmwnLFxuICAgICAgICAnYXBwbGljYXRpb24vZnV0dXJlc3BsYXNoJzogJ3NwbCcsXG4gICAgICAgICdhcHBsaWNhdGlvbi9nbnV0YXInOiAndGd6JyxcbiAgICAgICAgJ2FwcGxpY2F0aW9uL2dyb3Vwd2lzZSc6ICd2ZXcnLFxuICAgICAgICAnYXBwbGljYXRpb24vaGxwJzogJ2hscCcsXG4gICAgICAgICdhcHBsaWNhdGlvbi9odGEnOiAnaHRhJyxcbiAgICAgICAgJ2FwcGxpY2F0aW9uL2h5cGVyc3R1ZGlvJzogJ3N0aycsXG4gICAgICAgICdhcHBsaWNhdGlvbi9pLWRlYXMnOiAndW52JyxcbiAgICAgICAgJ2FwcGxpY2F0aW9uL2lnZXMnOiBbJ2lnZXMnLCAnaWdzJ10sXG4gICAgICAgICdhcHBsaWNhdGlvbi9pbmYnOiAnaW5mJyxcbiAgICAgICAgJ2FwcGxpY2F0aW9uL2ludGVybmV0LXByb3BlcnR5LXN0cmVhbSc6ICdhY3gnLFxuICAgICAgICAnYXBwbGljYXRpb24vaXBmaXgnOiAnaXBmaXgnLFxuICAgICAgICAnYXBwbGljYXRpb24vamF2YSc6ICdjbGFzcycsXG4gICAgICAgICdhcHBsaWNhdGlvbi9qYXZhLWFyY2hpdmUnOiAnamFyJyxcbiAgICAgICAgJ2FwcGxpY2F0aW9uL2phdmEtYnl0ZS1jb2RlJzogJ2NsYXNzJyxcbiAgICAgICAgJ2FwcGxpY2F0aW9uL2phdmEtc2VyaWFsaXplZC1vYmplY3QnOiAnc2VyJyxcbiAgICAgICAgJ2FwcGxpY2F0aW9uL2phdmEtdm0nOiAnY2xhc3MnLFxuICAgICAgICAnYXBwbGljYXRpb24vamF2YXNjcmlwdCc6ICdqcycsXG4gICAgICAgICdhcHBsaWNhdGlvbi9qc29uJzogJ2pzb24nLFxuICAgICAgICAnYXBwbGljYXRpb24vbGhhJzogJ2xoYScsXG4gICAgICAgICdhcHBsaWNhdGlvbi9sengnOiAnbHp4JyxcbiAgICAgICAgJ2FwcGxpY2F0aW9uL21hYy1iaW5hcnknOiAnYmluJyxcbiAgICAgICAgJ2FwcGxpY2F0aW9uL21hYy1iaW5oZXgnOiAnaHF4JyxcbiAgICAgICAgJ2FwcGxpY2F0aW9uL21hYy1iaW5oZXg0MCc6ICdocXgnLFxuICAgICAgICAnYXBwbGljYXRpb24vbWFjLWNvbXBhY3Rwcm8nOiAnY3B0JyxcbiAgICAgICAgJ2FwcGxpY2F0aW9uL21hY2JpbmFyeSc6ICdiaW4nLFxuICAgICAgICAnYXBwbGljYXRpb24vbWFkcyt4bWwnOiAnbWFkcycsXG4gICAgICAgICdhcHBsaWNhdGlvbi9tYXJjJzogJ21yYycsXG4gICAgICAgICdhcHBsaWNhdGlvbi9tYXJjeG1sK3htbCc6ICdtcmN4JyxcbiAgICAgICAgJ2FwcGxpY2F0aW9uL21hdGhlbWF0aWNhJzogJ21hJyxcbiAgICAgICAgJ2FwcGxpY2F0aW9uL21hdGhtbCt4bWwnOiAnbWF0aG1sJyxcbiAgICAgICAgJ2FwcGxpY2F0aW9uL21iZWRsZXQnOiAnbWJkJyxcbiAgICAgICAgJ2FwcGxpY2F0aW9uL21ib3gnOiAnbWJveCcsXG4gICAgICAgICdhcHBsaWNhdGlvbi9tY2FkJzogJ21jZCcsXG4gICAgICAgICdhcHBsaWNhdGlvbi9tZWRpYXNlcnZlcmNvbnRyb2wreG1sJzogJ21zY21sJyxcbiAgICAgICAgJ2FwcGxpY2F0aW9uL21ldGFsaW5rNCt4bWwnOiAnbWV0YTQnLFxuICAgICAgICAnYXBwbGljYXRpb24vbWV0cyt4bWwnOiAnbWV0cycsXG4gICAgICAgICdhcHBsaWNhdGlvbi9taW1lJzogJ2FwcycsXG4gICAgICAgICdhcHBsaWNhdGlvbi9tb2RzK3htbCc6ICdtb2RzJyxcbiAgICAgICAgJ2FwcGxpY2F0aW9uL21wMjEnOiAnbTIxJyxcbiAgICAgICAgJ2FwcGxpY2F0aW9uL21wNCc6ICdtcDQnLFxuICAgICAgICAnYXBwbGljYXRpb24vbXNwb3dlcnBvaW50JzogWydwcHQnLCAncG90JywgJ3BwcycsICdwcHonXSxcbiAgICAgICAgJ2FwcGxpY2F0aW9uL21zd29yZCc6IFsnZG9jJywgJ2RvdCcsICd3NncnLCAnd2l6JywgJ3dvcmQnXSxcbiAgICAgICAgJ2FwcGxpY2F0aW9uL21zd3JpdGUnOiAnd3JpJyxcbiAgICAgICAgJ2FwcGxpY2F0aW9uL214Zic6ICdteGYnLFxuICAgICAgICAnYXBwbGljYXRpb24vbmV0bWMnOiAnbWNwJyxcbiAgICAgICAgJ2FwcGxpY2F0aW9uL29jdGV0LXN0cmVhbSc6IFsnKiddLFxuICAgICAgICAnYXBwbGljYXRpb24vb2RhJzogJ29kYScsXG4gICAgICAgICdhcHBsaWNhdGlvbi9vZWJwcy1wYWNrYWdlK3htbCc6ICdvcGYnLFxuICAgICAgICAnYXBwbGljYXRpb24vb2dnJzogJ29neCcsXG4gICAgICAgICdhcHBsaWNhdGlvbi9vbGVzY3JpcHQnOiAnYXhzJyxcbiAgICAgICAgJ2FwcGxpY2F0aW9uL29uZW5vdGUnOiAnb25ldG9jJyxcbiAgICAgICAgJ2FwcGxpY2F0aW9uL3BhdGNoLW9wcy1lcnJvcit4bWwnOiAneGVyJyxcbiAgICAgICAgJ2FwcGxpY2F0aW9uL3BkZic6ICdwZGYnLFxuICAgICAgICAnYXBwbGljYXRpb24vcGdwLWVuY3J5cHRlZCc6ICdhc2MnLFxuICAgICAgICAnYXBwbGljYXRpb24vcGdwLXNpZ25hdHVyZSc6ICdwZ3AnLFxuICAgICAgICAnYXBwbGljYXRpb24vcGljcy1ydWxlcyc6ICdwcmYnLFxuICAgICAgICAnYXBwbGljYXRpb24vcGtjcy0xMic6ICdwMTInLFxuICAgICAgICAnYXBwbGljYXRpb24vcGtjcy1jcmwnOiAnY3JsJyxcbiAgICAgICAgJ2FwcGxpY2F0aW9uL3BrY3MxMCc6ICdwMTAnLFxuICAgICAgICAnYXBwbGljYXRpb24vcGtjczctbWltZSc6IFsncDdjJywgJ3A3bSddLFxuICAgICAgICAnYXBwbGljYXRpb24vcGtjczctc2lnbmF0dXJlJzogJ3A3cycsXG4gICAgICAgICdhcHBsaWNhdGlvbi9wa2NzOCc6ICdwOCcsXG4gICAgICAgICdhcHBsaWNhdGlvbi9wa2l4LWF0dHItY2VydCc6ICdhYycsXG4gICAgICAgICdhcHBsaWNhdGlvbi9wa2l4LWNlcnQnOiBbJ2NlcicsICdjcnQnXSxcbiAgICAgICAgJ2FwcGxpY2F0aW9uL3BraXgtY3JsJzogJ2NybCcsXG4gICAgICAgICdhcHBsaWNhdGlvbi9wa2l4LXBraXBhdGgnOiAncGtpcGF0aCcsXG4gICAgICAgICdhcHBsaWNhdGlvbi9wa2l4Y21wJzogJ3BraScsXG4gICAgICAgICdhcHBsaWNhdGlvbi9wbGFpbic6ICd0ZXh0JyxcbiAgICAgICAgJ2FwcGxpY2F0aW9uL3Bscyt4bWwnOiAncGxzJyxcbiAgICAgICAgJ2FwcGxpY2F0aW9uL3Bvc3RzY3JpcHQnOiBbJ3BzJywgJ2FpJywgJ2VwcyddLFxuICAgICAgICAnYXBwbGljYXRpb24vcG93ZXJwb2ludCc6ICdwcHQnLFxuICAgICAgICAnYXBwbGljYXRpb24vcHJvX2VuZyc6IFsncGFydCcsICdwcnQnXSxcbiAgICAgICAgJ2FwcGxpY2F0aW9uL3Bycy5jd3cnOiAnY3d3JyxcbiAgICAgICAgJ2FwcGxpY2F0aW9uL3Bza2MreG1sJzogJ3Bza2N4bWwnLFxuICAgICAgICAnYXBwbGljYXRpb24vcmRmK3htbCc6ICdyZGYnLFxuICAgICAgICAnYXBwbGljYXRpb24vcmVnaW5mbyt4bWwnOiAncmlmJyxcbiAgICAgICAgJ2FwcGxpY2F0aW9uL3JlbGF4LW5nLWNvbXBhY3Qtc3ludGF4JzogJ3JuYycsXG4gICAgICAgICdhcHBsaWNhdGlvbi9yZXNvdXJjZS1saXN0cyt4bWwnOiAncmwnLFxuICAgICAgICAnYXBwbGljYXRpb24vcmVzb3VyY2UtbGlzdHMtZGlmZit4bWwnOiAncmxkJyxcbiAgICAgICAgJ2FwcGxpY2F0aW9uL3JpbmdpbmctdG9uZXMnOiAncm5nJyxcbiAgICAgICAgJ2FwcGxpY2F0aW9uL3Jscy1zZXJ2aWNlcyt4bWwnOiAncnMnLFxuICAgICAgICAnYXBwbGljYXRpb24vcnNkK3htbCc6ICdyc2QnLFxuICAgICAgICAnYXBwbGljYXRpb24vcnNzK3htbCc6ICd4bWwnLFxuICAgICAgICAnYXBwbGljYXRpb24vcnRmJzogWydydGYnLCAncnR4J10sXG4gICAgICAgICdhcHBsaWNhdGlvbi9zYm1sK3htbCc6ICdzYm1sJyxcbiAgICAgICAgJ2FwcGxpY2F0aW9uL3NjdnAtY3YtcmVxdWVzdCc6ICdzY3EnLFxuICAgICAgICAnYXBwbGljYXRpb24vc2N2cC1jdi1yZXNwb25zZSc6ICdzY3MnLFxuICAgICAgICAnYXBwbGljYXRpb24vc2N2cC12cC1yZXF1ZXN0JzogJ3NwcScsXG4gICAgICAgICdhcHBsaWNhdGlvbi9zY3ZwLXZwLXJlc3BvbnNlJzogJ3NwcCcsXG4gICAgICAgICdhcHBsaWNhdGlvbi9zZHAnOiAnc2RwJyxcbiAgICAgICAgJ2FwcGxpY2F0aW9uL3NlYSc6ICdzZWEnLFxuICAgICAgICAnYXBwbGljYXRpb24vc2V0JzogJ3NldCcsXG4gICAgICAgICdhcHBsaWNhdGlvbi9zZXQtcGF5bWVudC1pbml0aWF0aW9uJzogJ3NldHBheScsXG4gICAgICAgICdhcHBsaWNhdGlvbi9zZXQtcmVnaXN0cmF0aW9uLWluaXRpYXRpb24nOiAnc2V0cmVnJyxcbiAgICAgICAgJ2FwcGxpY2F0aW9uL3NoZit4bWwnOiAnc2hmJyxcbiAgICAgICAgJ2FwcGxpY2F0aW9uL3NsYSc6ICdzdGwnLFxuICAgICAgICAnYXBwbGljYXRpb24vc21pbCc6IFsnc21pJywgJ3NtaWwnXSxcbiAgICAgICAgJ2FwcGxpY2F0aW9uL3NtaWwreG1sJzogJ3NtaScsXG4gICAgICAgICdhcHBsaWNhdGlvbi9zb2xpZHMnOiAnc29sJyxcbiAgICAgICAgJ2FwcGxpY2F0aW9uL3NvdW5kZXInOiAnc2RyJyxcbiAgICAgICAgJ2FwcGxpY2F0aW9uL3NwYXJxbC1xdWVyeSc6ICdycScsXG4gICAgICAgICdhcHBsaWNhdGlvbi9zcGFycWwtcmVzdWx0cyt4bWwnOiAnc3J4JyxcbiAgICAgICAgJ2FwcGxpY2F0aW9uL3NyZ3MnOiAnZ3JhbScsXG4gICAgICAgICdhcHBsaWNhdGlvbi9zcmdzK3htbCc6ICdncnhtbCcsXG4gICAgICAgICdhcHBsaWNhdGlvbi9zcnUreG1sJzogJ3NydScsXG4gICAgICAgICdhcHBsaWNhdGlvbi9zc21sK3htbCc6ICdzc21sJyxcbiAgICAgICAgJ2FwcGxpY2F0aW9uL3N0ZXAnOiBbJ3N0ZXAnLCAnc3RwJ10sXG4gICAgICAgICdhcHBsaWNhdGlvbi9zdHJlYW1pbmdtZWRpYSc6ICdzc20nLFxuICAgICAgICAnYXBwbGljYXRpb24vdGVpK3htbCc6ICd0ZWknLFxuICAgICAgICAnYXBwbGljYXRpb24vdGhyYXVkK3htbCc6ICd0ZmknLFxuICAgICAgICAnYXBwbGljYXRpb24vdGltZXN0YW1wZWQtZGF0YSc6ICd0c2QnLFxuICAgICAgICAnYXBwbGljYXRpb24vdG9vbGJvb2snOiAndGJrJyxcbiAgICAgICAgJ2FwcGxpY2F0aW9uL3ZkYSc6ICd2ZGEnLFxuICAgICAgICAnYXBwbGljYXRpb24vdm5kLjNncHAucGljLWJ3LWxhcmdlJzogJ3BsYicsXG4gICAgICAgICdhcHBsaWNhdGlvbi92bmQuM2dwcC5waWMtYnctc21hbGwnOiAncHNiJyxcbiAgICAgICAgJ2FwcGxpY2F0aW9uL3ZuZC4zZ3BwLnBpYy1idy12YXInOiAncHZiJyxcbiAgICAgICAgJ2FwcGxpY2F0aW9uL3ZuZC4zZ3BwMi50Y2FwJzogJ3RjYXAnLFxuICAgICAgICAnYXBwbGljYXRpb24vdm5kLjNtLnBvc3QtaXQtbm90ZXMnOiAncHduJyxcbiAgICAgICAgJ2FwcGxpY2F0aW9uL3ZuZC5hY2NwYWMuc2ltcGx5LmFzbyc6ICdhc28nLFxuICAgICAgICAnYXBwbGljYXRpb24vdm5kLmFjY3BhYy5zaW1wbHkuaW1wJzogJ2ltcCcsXG4gICAgICAgICdhcHBsaWNhdGlvbi92bmQuYWN1Y29ib2wnOiAnYWN1JyxcbiAgICAgICAgJ2FwcGxpY2F0aW9uL3ZuZC5hY3Vjb3JwJzogJ2F0YycsXG4gICAgICAgICdhcHBsaWNhdGlvbi92bmQuYWRvYmUuYWlyLWFwcGxpY2F0aW9uLWluc3RhbGxlci1wYWNrYWdlK3ppcCc6ICdhaXInLFxuICAgICAgICAnYXBwbGljYXRpb24vdm5kLmFkb2JlLmZ4cCc6ICdmeHAnLFxuICAgICAgICAnYXBwbGljYXRpb24vdm5kLmFkb2JlLnhkcCt4bWwnOiAneGRwJyxcbiAgICAgICAgJ2FwcGxpY2F0aW9uL3ZuZC5hZG9iZS54ZmRmJzogJ3hmZGYnLFxuICAgICAgICAnYXBwbGljYXRpb24vdm5kLmFoZWFkLnNwYWNlJzogJ2FoZWFkJyxcbiAgICAgICAgJ2FwcGxpY2F0aW9uL3ZuZC5haXJ6aXAuZmlsZXNlY3VyZS5hemYnOiAnYXpmJyxcbiAgICAgICAgJ2FwcGxpY2F0aW9uL3ZuZC5haXJ6aXAuZmlsZXNlY3VyZS5henMnOiAnYXpzJyxcbiAgICAgICAgJ2FwcGxpY2F0aW9uL3ZuZC5hbWF6b24uZWJvb2snOiAnYXp3JyxcbiAgICAgICAgJ2FwcGxpY2F0aW9uL3ZuZC5hbWVyaWNhbmR5bmFtaWNzLmFjYyc6ICdhY2MnLFxuICAgICAgICAnYXBwbGljYXRpb24vdm5kLmFtaWdhLmFtaSc6ICdhbWknLFxuICAgICAgICAnYXBwbGljYXRpb24vdm5kLmFuZHJvaWQucGFja2FnZS1hcmNoaXZlJzogJ2FwaycsXG4gICAgICAgICdhcHBsaWNhdGlvbi92bmQuYW5zZXItd2ViLWNlcnRpZmljYXRlLWlzc3VlLWluaXRpYXRpb24nOiAnY2lpJyxcbiAgICAgICAgJ2FwcGxpY2F0aW9uL3ZuZC5hbnNlci13ZWItZnVuZHMtdHJhbnNmZXItaW5pdGlhdGlvbic6ICdmdGknLFxuICAgICAgICAnYXBwbGljYXRpb24vdm5kLmFudGl4LmdhbWUtY29tcG9uZW50JzogJ2F0eCcsXG4gICAgICAgICdhcHBsaWNhdGlvbi92bmQuYXBwbGUuaW5zdGFsbGVyK3htbCc6ICdtcGtnJyxcbiAgICAgICAgJ2FwcGxpY2F0aW9uL3ZuZC5hcHBsZS5tcGVndXJsJzogJ20zdTgnLFxuICAgICAgICAnYXBwbGljYXRpb24vdm5kLmFyaXN0YW5ldHdvcmtzLnN3aSc6ICdzd2knLFxuICAgICAgICAnYXBwbGljYXRpb24vdm5kLmF1ZGlvZ3JhcGgnOiAnYWVwJyxcbiAgICAgICAgJ2FwcGxpY2F0aW9uL3ZuZC5ibHVlaWNlLm11bHRpcGFzcyc6ICdtcG0nLFxuICAgICAgICAnYXBwbGljYXRpb24vdm5kLmJtaSc6ICdibWknLFxuICAgICAgICAnYXBwbGljYXRpb24vdm5kLmJ1c2luZXNzb2JqZWN0cyc6ICdyZXAnLFxuICAgICAgICAnYXBwbGljYXRpb24vdm5kLmNoZW1kcmF3K3htbCc6ICdjZHhtbCcsXG4gICAgICAgICdhcHBsaWNhdGlvbi92bmQuY2hpcG51dHMua2FyYW9rZS1tbWQnOiAnbW1kJyxcbiAgICAgICAgJ2FwcGxpY2F0aW9uL3ZuZC5jaW5kZXJlbGxhJzogJ2NkeScsXG4gICAgICAgICdhcHBsaWNhdGlvbi92bmQuY2xheW1vcmUnOiAnY2xhJyxcbiAgICAgICAgJ2FwcGxpY2F0aW9uL3ZuZC5jbG9hbnRvLnJwOSc6ICdycDknLFxuICAgICAgICAnYXBwbGljYXRpb24vdm5kLmNsb25rLmM0Z3JvdXAnOiAnYzRnJyxcbiAgICAgICAgJ2FwcGxpY2F0aW9uL3ZuZC5jbHVldHJ1c3QuY2FydG9tb2JpbGUtY29uZmlnJzogJ2MxMWFtYycsXG4gICAgICAgICdhcHBsaWNhdGlvbi92bmQuY2x1ZXRydXN0LmNhcnRvbW9iaWxlLWNvbmZpZy1wa2cnOiAnYzExYW16JyxcbiAgICAgICAgJ2FwcGxpY2F0aW9uL3ZuZC5jb21tb25zcGFjZSc6ICdjc3AnLFxuICAgICAgICAnYXBwbGljYXRpb24vdm5kLmNvbnRhY3QuY21zZyc6ICdjZGJjbXNnJyxcbiAgICAgICAgJ2FwcGxpY2F0aW9uL3ZuZC5jb3Ntb2NhbGxlcic6ICdjbWMnLFxuICAgICAgICAnYXBwbGljYXRpb24vdm5kLmNyaWNrLmNsaWNrZXInOiAnY2xreCcsXG4gICAgICAgICdhcHBsaWNhdGlvbi92bmQuY3JpY2suY2xpY2tlci5rZXlib2FyZCc6ICdjbGtrJyxcbiAgICAgICAgJ2FwcGxpY2F0aW9uL3ZuZC5jcmljay5jbGlja2VyLnBhbGV0dGUnOiAnY2xrcCcsXG4gICAgICAgICdhcHBsaWNhdGlvbi92bmQuY3JpY2suY2xpY2tlci50ZW1wbGF0ZSc6ICdjbGt0JyxcbiAgICAgICAgJ2FwcGxpY2F0aW9uL3ZuZC5jcmljay5jbGlja2VyLndvcmRiYW5rJzogJ2Nsa3cnLFxuICAgICAgICAnYXBwbGljYXRpb24vdm5kLmNyaXRpY2FsdG9vbHMud2JzK3htbCc6ICd3YnMnLFxuICAgICAgICAnYXBwbGljYXRpb24vdm5kLmN0Yy1wb3NtbCc6ICdwbWwnLFxuICAgICAgICAnYXBwbGljYXRpb24vdm5kLmN1cHMtcHBkJzogJ3BwZCcsXG4gICAgICAgICdhcHBsaWNhdGlvbi92bmQuY3VybC5jYXInOiAnY2FyJyxcbiAgICAgICAgJ2FwcGxpY2F0aW9uL3ZuZC5jdXJsLnBjdXJsJzogJ3BjdXJsJyxcbiAgICAgICAgJ2FwcGxpY2F0aW9uL3ZuZC5kYXRhLXZpc2lvbi5yZHonOiAncmR6JyxcbiAgICAgICAgJ2FwcGxpY2F0aW9uL3ZuZC5kZW5vdm8uZmNzZWxheW91dC1saW5rJzogJ2ZlX2xhdW5jaCcsXG4gICAgICAgICdhcHBsaWNhdGlvbi92bmQuZG5hJzogJ2RuYScsXG4gICAgICAgICdhcHBsaWNhdGlvbi92bmQuZG9sYnkubWxwJzogJ21scCcsXG4gICAgICAgICdhcHBsaWNhdGlvbi92bmQuZHBncmFwaCc6ICdkcGcnLFxuICAgICAgICAnYXBwbGljYXRpb24vdm5kLmRyZWFtZmFjdG9yeSc6ICdkZmFjJyxcbiAgICAgICAgJ2FwcGxpY2F0aW9uL3ZuZC5kdmIuYWl0JzogJ2FpdCcsXG4gICAgICAgICdhcHBsaWNhdGlvbi92bmQuZHZiLnNlcnZpY2UnOiAnc3ZjJyxcbiAgICAgICAgJ2FwcGxpY2F0aW9uL3ZuZC5keW5hZ2VvJzogJ2dlbycsXG4gICAgICAgICdhcHBsaWNhdGlvbi92bmQuZWNvd2luLmNoYXJ0JzogJ21hZycsXG4gICAgICAgICdhcHBsaWNhdGlvbi92bmQuZW5saXZlbic6ICdubWwnLFxuICAgICAgICAnYXBwbGljYXRpb24vdm5kLmVwc29uLmVzZic6ICdlc2YnLFxuICAgICAgICAnYXBwbGljYXRpb24vdm5kLmVwc29uLm1zZic6ICdtc2YnLFxuICAgICAgICAnYXBwbGljYXRpb24vdm5kLmVwc29uLnF1aWNrYW5pbWUnOiAncWFtJyxcbiAgICAgICAgJ2FwcGxpY2F0aW9uL3ZuZC5lcHNvbi5zYWx0JzogJ3NsdCcsXG4gICAgICAgICdhcHBsaWNhdGlvbi92bmQuZXBzb24uc3NmJzogJ3NzZicsXG4gICAgICAgICdhcHBsaWNhdGlvbi92bmQuZXN6aWdubzMreG1sJzogJ2VzMycsXG4gICAgICAgICdhcHBsaWNhdGlvbi92bmQuZXpwaXgtYWxidW0nOiAnZXoyJyxcbiAgICAgICAgJ2FwcGxpY2F0aW9uL3ZuZC5lenBpeC1wYWNrYWdlJzogJ2V6MycsXG4gICAgICAgICdhcHBsaWNhdGlvbi92bmQuZmRmJzogJ2ZkZicsXG4gICAgICAgICdhcHBsaWNhdGlvbi92bmQuZmRzbi5zZWVkJzogJ3NlZWQnLFxuICAgICAgICAnYXBwbGljYXRpb24vdm5kLmZsb2dyYXBoaXQnOiAnZ3BoJyxcbiAgICAgICAgJ2FwcGxpY2F0aW9uL3ZuZC5mbHV4dGltZS5jbGlwJzogJ2Z0YycsXG4gICAgICAgICdhcHBsaWNhdGlvbi92bmQuZnJhbWVtYWtlcic6ICdmbScsXG4gICAgICAgICdhcHBsaWNhdGlvbi92bmQuZnJvZ2Fucy5mbmMnOiAnZm5jJyxcbiAgICAgICAgJ2FwcGxpY2F0aW9uL3ZuZC5mcm9nYW5zLmx0Zic6ICdsdGYnLFxuICAgICAgICAnYXBwbGljYXRpb24vdm5kLmZzYy53ZWJsYXVuY2gnOiAnZnNjJyxcbiAgICAgICAgJ2FwcGxpY2F0aW9uL3ZuZC5mdWppdHN1Lm9hc3lzJzogJ29hcycsXG4gICAgICAgICdhcHBsaWNhdGlvbi92bmQuZnVqaXRzdS5vYXN5czInOiAnb2EyJyxcbiAgICAgICAgJ2FwcGxpY2F0aW9uL3ZuZC5mdWppdHN1Lm9hc3lzMyc6ICdvYTMnLFxuICAgICAgICAnYXBwbGljYXRpb24vdm5kLmZ1aml0c3Uub2FzeXNncCc6ICdmZzUnLFxuICAgICAgICAnYXBwbGljYXRpb24vdm5kLmZ1aml0c3Uub2FzeXNwcnMnOiAnYmgyJyxcbiAgICAgICAgJ2FwcGxpY2F0aW9uL3ZuZC5mdWppeGVyb3guZGRkJzogJ2RkZCcsXG4gICAgICAgICdhcHBsaWNhdGlvbi92bmQuZnVqaXhlcm94LmRvY3V3b3Jrcyc6ICd4ZHcnLFxuICAgICAgICAnYXBwbGljYXRpb24vdm5kLmZ1aml4ZXJveC5kb2N1d29ya3MuYmluZGVyJzogJ3hiZCcsXG4gICAgICAgICdhcHBsaWNhdGlvbi92bmQuZnV6enlzaGVldCc6ICdmenMnLFxuICAgICAgICAnYXBwbGljYXRpb24vdm5kLmdlbm9tYXRpeC50dXhlZG8nOiAndHhkJyxcbiAgICAgICAgJ2FwcGxpY2F0aW9uL3ZuZC5nZW9nZWJyYS5maWxlJzogJ2dnYicsXG4gICAgICAgICdhcHBsaWNhdGlvbi92bmQuZ2VvZ2VicmEudG9vbCc6ICdnZ3QnLFxuICAgICAgICAnYXBwbGljYXRpb24vdm5kLmdlb21ldHJ5LWV4cGxvcmVyJzogJ2dleCcsXG4gICAgICAgICdhcHBsaWNhdGlvbi92bmQuZ2VvbmV4dCc6ICdneHQnLFxuICAgICAgICAnYXBwbGljYXRpb24vdm5kLmdlb3BsYW4nOiAnZzJ3JyxcbiAgICAgICAgJ2FwcGxpY2F0aW9uL3ZuZC5nZW9zcGFjZSc6ICdnM3cnLFxuICAgICAgICAnYXBwbGljYXRpb24vdm5kLmdteCc6ICdnbXgnLFxuICAgICAgICAnYXBwbGljYXRpb24vdm5kLmdvb2dsZS1lYXJ0aC5rbWwreG1sJzogJ2ttbCcsXG4gICAgICAgICdhcHBsaWNhdGlvbi92bmQuZ29vZ2xlLWVhcnRoLmtteic6ICdrbXonLFxuICAgICAgICAnYXBwbGljYXRpb24vdm5kLmdyYWZlcSc6ICdncWYnLFxuICAgICAgICAnYXBwbGljYXRpb24vdm5kLmdyb292ZS1hY2NvdW50JzogJ2dhYycsXG4gICAgICAgICdhcHBsaWNhdGlvbi92bmQuZ3Jvb3ZlLWhlbHAnOiAnZ2hmJyxcbiAgICAgICAgJ2FwcGxpY2F0aW9uL3ZuZC5ncm9vdmUtaWRlbnRpdHktbWVzc2FnZSc6ICdnaW0nLFxuICAgICAgICAnYXBwbGljYXRpb24vdm5kLmdyb292ZS1pbmplY3Rvcic6ICdncnYnLFxuICAgICAgICAnYXBwbGljYXRpb24vdm5kLmdyb292ZS10b29sLW1lc3NhZ2UnOiAnZ3RtJyxcbiAgICAgICAgJ2FwcGxpY2F0aW9uL3ZuZC5ncm9vdmUtdG9vbC10ZW1wbGF0ZSc6ICd0cGwnLFxuICAgICAgICAnYXBwbGljYXRpb24vdm5kLmdyb292ZS12Y2FyZCc6ICd2Y2cnLFxuICAgICAgICAnYXBwbGljYXRpb24vdm5kLmhhbCt4bWwnOiAnaGFsJyxcbiAgICAgICAgJ2FwcGxpY2F0aW9uL3ZuZC5oYW5kaGVsZC1lbnRlcnRhaW5tZW50K3htbCc6ICd6bW0nLFxuICAgICAgICAnYXBwbGljYXRpb24vdm5kLmhiY2knOiAnaGJjaScsXG4gICAgICAgICdhcHBsaWNhdGlvbi92bmQuaGhlLmxlc3Nvbi1wbGF5ZXInOiAnbGVzJyxcbiAgICAgICAgJ2FwcGxpY2F0aW9uL3ZuZC5ocC1ocGdsJzogWydoZ2wnLCAnaHBnJywgJ2hwZ2wnXSxcbiAgICAgICAgJ2FwcGxpY2F0aW9uL3ZuZC5ocC1ocGlkJzogJ2hwaWQnLFxuICAgICAgICAnYXBwbGljYXRpb24vdm5kLmhwLWhwcyc6ICdocHMnLFxuICAgICAgICAnYXBwbGljYXRpb24vdm5kLmhwLWpseXQnOiAnamx0JyxcbiAgICAgICAgJ2FwcGxpY2F0aW9uL3ZuZC5ocC1wY2wnOiAncGNsJyxcbiAgICAgICAgJ2FwcGxpY2F0aW9uL3ZuZC5ocC1wY2x4bCc6ICdwY2x4bCcsXG4gICAgICAgICdhcHBsaWNhdGlvbi92bmQuaHlkcm9zdGF0aXguc29mLWRhdGEnOiAnc2ZkLWhkc3R4JyxcbiAgICAgICAgJ2FwcGxpY2F0aW9uL3ZuZC5oem4tM2QtY3Jvc3N3b3JkJzogJ3gzZCcsXG4gICAgICAgICdhcHBsaWNhdGlvbi92bmQuaWJtLm1pbmlwYXknOiAnbXB5JyxcbiAgICAgICAgJ2FwcGxpY2F0aW9uL3ZuZC5pYm0ubW9kY2FwJzogJ2FmcCcsXG4gICAgICAgICdhcHBsaWNhdGlvbi92bmQuaWJtLnJpZ2h0cy1tYW5hZ2VtZW50JzogJ2lybScsXG4gICAgICAgICdhcHBsaWNhdGlvbi92bmQuaWJtLnNlY3VyZS1jb250YWluZXInOiAnc2MnLFxuICAgICAgICAnYXBwbGljYXRpb24vdm5kLmljY3Byb2ZpbGUnOiAnaWNjJyxcbiAgICAgICAgJ2FwcGxpY2F0aW9uL3ZuZC5pZ2xvYWRlcic6ICdpZ2wnLFxuICAgICAgICAnYXBwbGljYXRpb24vdm5kLmltbWVydmlzaW9uLWl2cCc6ICdpdnAnLFxuICAgICAgICAnYXBwbGljYXRpb24vdm5kLmltbWVydmlzaW9uLWl2dSc6ICdpdnUnLFxuICAgICAgICAnYXBwbGljYXRpb24vdm5kLmluc29ycy5pZ20nOiAnaWdtJyxcbiAgICAgICAgJ2FwcGxpY2F0aW9uL3ZuZC5pbnRlcmNvbi5mb3JtbmV0JzogJ3hwdycsXG4gICAgICAgICdhcHBsaWNhdGlvbi92bmQuaW50ZXJnZW8nOiAnaTJnJyxcbiAgICAgICAgJ2FwcGxpY2F0aW9uL3ZuZC5pbnR1LnFibyc6ICdxYm8nLFxuICAgICAgICAnYXBwbGljYXRpb24vdm5kLmludHUucWZ4JzogJ3FmeCcsXG4gICAgICAgICdhcHBsaWNhdGlvbi92bmQuaXB1bnBsdWdnZWQucmNwcm9maWxlJzogJ3JjcHJvZmlsZScsXG4gICAgICAgICdhcHBsaWNhdGlvbi92bmQuaXJlcG9zaXRvcnkucGFja2FnZSt4bWwnOiAnaXJwJyxcbiAgICAgICAgJ2FwcGxpY2F0aW9uL3ZuZC5pcy14cHInOiAneHByJyxcbiAgICAgICAgJ2FwcGxpY2F0aW9uL3ZuZC5pc2FjLmZjcyc6ICdmY3MnLFxuICAgICAgICAnYXBwbGljYXRpb24vdm5kLmphbSc6ICdqYW0nLFxuICAgICAgICAnYXBwbGljYXRpb24vdm5kLmpjcC5qYXZhbWUubWlkbGV0LXJtcyc6ICdybXMnLFxuICAgICAgICAnYXBwbGljYXRpb24vdm5kLmppc3AnOiAnamlzcCcsXG4gICAgICAgICdhcHBsaWNhdGlvbi92bmQuam9vc3Quam9kYS1hcmNoaXZlJzogJ2pvZGEnLFxuICAgICAgICAnYXBwbGljYXRpb24vdm5kLmthaG9vdHonOiAna3R6JyxcbiAgICAgICAgJ2FwcGxpY2F0aW9uL3ZuZC5rZGUua2FyYm9uJzogJ2thcmJvbicsXG4gICAgICAgICdhcHBsaWNhdGlvbi92bmQua2RlLmtjaGFydCc6ICdjaHJ0JyxcbiAgICAgICAgJ2FwcGxpY2F0aW9uL3ZuZC5rZGUua2Zvcm11bGEnOiAna2ZvJyxcbiAgICAgICAgJ2FwcGxpY2F0aW9uL3ZuZC5rZGUua2l2aW8nOiAnZmx3JyxcbiAgICAgICAgJ2FwcGxpY2F0aW9uL3ZuZC5rZGUua29udG91cic6ICdrb24nLFxuICAgICAgICAnYXBwbGljYXRpb24vdm5kLmtkZS5rcHJlc2VudGVyJzogJ2twcicsXG4gICAgICAgICdhcHBsaWNhdGlvbi92bmQua2RlLmtzcHJlYWQnOiAna3NwJyxcbiAgICAgICAgJ2FwcGxpY2F0aW9uL3ZuZC5rZGUua3dvcmQnOiAna3dkJyxcbiAgICAgICAgJ2FwcGxpY2F0aW9uL3ZuZC5rZW5hbWVhYXBwJzogJ2h0a2UnLFxuICAgICAgICAnYXBwbGljYXRpb24vdm5kLmtpZHNwaXJhdGlvbic6ICdraWEnLFxuICAgICAgICAnYXBwbGljYXRpb24vdm5kLmtpbmFyJzogJ2tuZScsXG4gICAgICAgICdhcHBsaWNhdGlvbi92bmQua29hbic6ICdza3AnLFxuICAgICAgICAnYXBwbGljYXRpb24vdm5kLmtvZGFrLWRlc2NyaXB0b3InOiAnc3NlJyxcbiAgICAgICAgJ2FwcGxpY2F0aW9uL3ZuZC5sYXMubGFzK3htbCc6ICdsYXN4bWwnLFxuICAgICAgICAnYXBwbGljYXRpb24vdm5kLmxsYW1hZ3JhcGhpY3MubGlmZS1iYWxhbmNlLmRlc2t0b3AnOiAnbGJkJyxcbiAgICAgICAgJ2FwcGxpY2F0aW9uL3ZuZC5sbGFtYWdyYXBoaWNzLmxpZmUtYmFsYW5jZS5leGNoYW5nZSt4bWwnOiAnbGJlJyxcbiAgICAgICAgJ2FwcGxpY2F0aW9uL3ZuZC5sb3R1cy0xLTItMyc6ICcxMjMnLFxuICAgICAgICAnYXBwbGljYXRpb24vdm5kLmxvdHVzLWFwcHJvYWNoJzogJ2FwcicsXG4gICAgICAgICdhcHBsaWNhdGlvbi92bmQubG90dXMtZnJlZWxhbmNlJzogJ3ByZScsXG4gICAgICAgICdhcHBsaWNhdGlvbi92bmQubG90dXMtbm90ZXMnOiAnbnNmJyxcbiAgICAgICAgJ2FwcGxpY2F0aW9uL3ZuZC5sb3R1cy1vcmdhbml6ZXInOiAnb3JnJyxcbiAgICAgICAgJ2FwcGxpY2F0aW9uL3ZuZC5sb3R1cy1zY3JlZW5jYW0nOiAnc2NtJyxcbiAgICAgICAgJ2FwcGxpY2F0aW9uL3ZuZC5sb3R1cy13b3JkcHJvJzogJ2x3cCcsXG4gICAgICAgICdhcHBsaWNhdGlvbi92bmQubWFjcG9ydHMucG9ydHBrZyc6ICdwb3J0cGtnJyxcbiAgICAgICAgJ2FwcGxpY2F0aW9uL3ZuZC5tY2QnOiAnbWNkJyxcbiAgICAgICAgJ2FwcGxpY2F0aW9uL3ZuZC5tZWRjYWxjZGF0YSc6ICdtYzEnLFxuICAgICAgICAnYXBwbGljYXRpb24vdm5kLm1lZGlhc3RhdGlvbi5jZGtleSc6ICdjZGtleScsXG4gICAgICAgICdhcHBsaWNhdGlvbi92bmQubWZlcic6ICdtd2YnLFxuICAgICAgICAnYXBwbGljYXRpb24vdm5kLm1mbXAnOiAnbWZtJyxcbiAgICAgICAgJ2FwcGxpY2F0aW9uL3ZuZC5taWNyb2dyYWZ4LmZsbyc6ICdmbG8nLFxuICAgICAgICAnYXBwbGljYXRpb24vdm5kLm1pY3JvZ3JhZnguaWd4JzogJ2lneCcsXG4gICAgICAgICdhcHBsaWNhdGlvbi92bmQubWlmJzogJ21pZicsXG4gICAgICAgICdhcHBsaWNhdGlvbi92bmQubW9iaXVzLmRhZic6ICdkYWYnLFxuICAgICAgICAnYXBwbGljYXRpb24vdm5kLm1vYml1cy5kaXMnOiAnZGlzJyxcbiAgICAgICAgJ2FwcGxpY2F0aW9uL3ZuZC5tb2JpdXMubWJrJzogJ21iaycsXG4gICAgICAgICdhcHBsaWNhdGlvbi92bmQubW9iaXVzLm1xeSc6ICdtcXknLFxuICAgICAgICAnYXBwbGljYXRpb24vdm5kLm1vYml1cy5tc2wnOiAnbXNsJyxcbiAgICAgICAgJ2FwcGxpY2F0aW9uL3ZuZC5tb2JpdXMucGxjJzogJ3BsYycsXG4gICAgICAgICdhcHBsaWNhdGlvbi92bmQubW9iaXVzLnR4Zic6ICd0eGYnLFxuICAgICAgICAnYXBwbGljYXRpb24vdm5kLm1vcGh1bi5hcHBsaWNhdGlvbic6ICdtcG4nLFxuICAgICAgICAnYXBwbGljYXRpb24vdm5kLm1vcGh1bi5jZXJ0aWZpY2F0ZSc6ICdtcGMnLFxuICAgICAgICAnYXBwbGljYXRpb24vdm5kLm1vemlsbGEueHVsK3htbCc6ICd4dWwnLFxuICAgICAgICAnYXBwbGljYXRpb24vdm5kLm1zLWFydGdhbHJ5JzogJ2NpbCcsXG4gICAgICAgICdhcHBsaWNhdGlvbi92bmQubXMtY2FiLWNvbXByZXNzZWQnOiAnY2FiJyxcbiAgICAgICAgJ2FwcGxpY2F0aW9uL3ZuZC5tcy1leGNlbCc6IFsneGxzJywgJ3hsYScsICd4bGMnLCAneGxtJywgJ3hsdCcsICd4bHcnLCAneGxiJywgJ3hsbCddLFxuICAgICAgICAnYXBwbGljYXRpb24vdm5kLm1zLWV4Y2VsLmFkZGluLm1hY3JvZW5hYmxlZC4xMic6ICd4bGFtJyxcbiAgICAgICAgJ2FwcGxpY2F0aW9uL3ZuZC5tcy1leGNlbC5zaGVldC5iaW5hcnkubWFjcm9lbmFibGVkLjEyJzogJ3hsc2InLFxuICAgICAgICAnYXBwbGljYXRpb24vdm5kLm1zLWV4Y2VsLnNoZWV0Lm1hY3JvZW5hYmxlZC4xMic6ICd4bHNtJyxcbiAgICAgICAgJ2FwcGxpY2F0aW9uL3ZuZC5tcy1leGNlbC50ZW1wbGF0ZS5tYWNyb2VuYWJsZWQuMTInOiAneGx0bScsXG4gICAgICAgICdhcHBsaWNhdGlvbi92bmQubXMtZm9udG9iamVjdCc6ICdlb3QnLFxuICAgICAgICAnYXBwbGljYXRpb24vdm5kLm1zLWh0bWxoZWxwJzogJ2NobScsXG4gICAgICAgICdhcHBsaWNhdGlvbi92bmQubXMtaW1zJzogJ2ltcycsXG4gICAgICAgICdhcHBsaWNhdGlvbi92bmQubXMtbHJtJzogJ2xybScsXG4gICAgICAgICdhcHBsaWNhdGlvbi92bmQubXMtb2ZmaWNldGhlbWUnOiAndGhteCcsXG4gICAgICAgICdhcHBsaWNhdGlvbi92bmQubXMtb3V0bG9vayc6ICdtc2cnLFxuICAgICAgICAnYXBwbGljYXRpb24vdm5kLm1zLXBraS5jZXJ0c3RvcmUnOiAnc3N0JyxcbiAgICAgICAgJ2FwcGxpY2F0aW9uL3ZuZC5tcy1wa2kucGtvJzogJ3BrbycsXG4gICAgICAgICdhcHBsaWNhdGlvbi92bmQubXMtcGtpLnNlY2NhdCc6ICdjYXQnLFxuICAgICAgICAnYXBwbGljYXRpb24vdm5kLm1zLXBraS5zdGwnOiAnc3RsJyxcbiAgICAgICAgJ2FwcGxpY2F0aW9uL3ZuZC5tcy1wa2ljZXJ0c3RvcmUnOiAnc3N0JyxcbiAgICAgICAgJ2FwcGxpY2F0aW9uL3ZuZC5tcy1wa2lzZWNjYXQnOiAnY2F0JyxcbiAgICAgICAgJ2FwcGxpY2F0aW9uL3ZuZC5tcy1wa2lzdGwnOiAnc3RsJyxcbiAgICAgICAgJ2FwcGxpY2F0aW9uL3ZuZC5tcy1wb3dlcnBvaW50JzogWydwcHQnLCAncG90JywgJ3BwcycsICdwcGEnLCAncHd6J10sXG4gICAgICAgICdhcHBsaWNhdGlvbi92bmQubXMtcG93ZXJwb2ludC5hZGRpbi5tYWNyb2VuYWJsZWQuMTInOiAncHBhbScsXG4gICAgICAgICdhcHBsaWNhdGlvbi92bmQubXMtcG93ZXJwb2ludC5wcmVzZW50YXRpb24ubWFjcm9lbmFibGVkLjEyJzogJ3BwdG0nLFxuICAgICAgICAnYXBwbGljYXRpb24vdm5kLm1zLXBvd2VycG9pbnQuc2xpZGUubWFjcm9lbmFibGVkLjEyJzogJ3NsZG0nLFxuICAgICAgICAnYXBwbGljYXRpb24vdm5kLm1zLXBvd2VycG9pbnQuc2xpZGVzaG93Lm1hY3JvZW5hYmxlZC4xMic6ICdwcHNtJyxcbiAgICAgICAgJ2FwcGxpY2F0aW9uL3ZuZC5tcy1wb3dlcnBvaW50LnRlbXBsYXRlLm1hY3JvZW5hYmxlZC4xMic6ICdwb3RtJyxcbiAgICAgICAgJ2FwcGxpY2F0aW9uL3ZuZC5tcy1wcm9qZWN0JzogJ21wcCcsXG4gICAgICAgICdhcHBsaWNhdGlvbi92bmQubXMtd29yZC5kb2N1bWVudC5tYWNyb2VuYWJsZWQuMTInOiAnZG9jbScsXG4gICAgICAgICdhcHBsaWNhdGlvbi92bmQubXMtd29yZC50ZW1wbGF0ZS5tYWNyb2VuYWJsZWQuMTInOiAnZG90bScsXG4gICAgICAgICdhcHBsaWNhdGlvbi92bmQubXMtd29ya3MnOiBbJ3drcycsICd3Y20nLCAnd2RiJywgJ3dwcyddLFxuICAgICAgICAnYXBwbGljYXRpb24vdm5kLm1zLXdwbCc6ICd3cGwnLFxuICAgICAgICAnYXBwbGljYXRpb24vdm5kLm1zLXhwc2RvY3VtZW50JzogJ3hwcycsXG4gICAgICAgICdhcHBsaWNhdGlvbi92bmQubXNlcSc6ICdtc2VxJyxcbiAgICAgICAgJ2FwcGxpY2F0aW9uL3ZuZC5tdXNpY2lhbic6ICdtdXMnLFxuICAgICAgICAnYXBwbGljYXRpb24vdm5kLm11dmVlLnN0eWxlJzogJ21zdHknLFxuICAgICAgICAnYXBwbGljYXRpb24vdm5kLm5ldXJvbGFuZ3VhZ2Uubmx1JzogJ25sdScsXG4gICAgICAgICdhcHBsaWNhdGlvbi92bmQubm9ibGVuZXQtZGlyZWN0b3J5JzogJ25uZCcsXG4gICAgICAgICdhcHBsaWNhdGlvbi92bmQubm9ibGVuZXQtc2VhbGVyJzogJ25ucycsXG4gICAgICAgICdhcHBsaWNhdGlvbi92bmQubm9ibGVuZXQtd2ViJzogJ25udycsXG4gICAgICAgICdhcHBsaWNhdGlvbi92bmQubm9raWEuY29uZmlndXJhdGlvbi1tZXNzYWdlJzogJ25jbScsXG4gICAgICAgICdhcHBsaWNhdGlvbi92bmQubm9raWEubi1nYWdlLmRhdGEnOiAnbmdkYXQnLFxuICAgICAgICAnYXBwbGljYXRpb24vdm5kLm5va2lhLm4tZ2FnZS5zeW1iaWFuLmluc3RhbGwnOiAnbi1nYWdlJyxcbiAgICAgICAgJ2FwcGxpY2F0aW9uL3ZuZC5ub2tpYS5yYWRpby1wcmVzZXQnOiAncnBzdCcsXG4gICAgICAgICdhcHBsaWNhdGlvbi92bmQubm9raWEucmFkaW8tcHJlc2V0cyc6ICdycHNzJyxcbiAgICAgICAgJ2FwcGxpY2F0aW9uL3ZuZC5ub2tpYS5yaW5naW5nLXRvbmUnOiAncm5nJyxcbiAgICAgICAgJ2FwcGxpY2F0aW9uL3ZuZC5ub3ZhZGlnbS5lZG0nOiAnZWRtJyxcbiAgICAgICAgJ2FwcGxpY2F0aW9uL3ZuZC5ub3ZhZGlnbS5lZHgnOiAnZWR4JyxcbiAgICAgICAgJ2FwcGxpY2F0aW9uL3ZuZC5ub3ZhZGlnbS5leHQnOiAnZXh0JyxcbiAgICAgICAgJ2FwcGxpY2F0aW9uL3ZuZC5vYXNpcy5vcGVuZG9jdW1lbnQuY2hhcnQnOiAnb2RjJyxcbiAgICAgICAgJ2FwcGxpY2F0aW9uL3ZuZC5vYXNpcy5vcGVuZG9jdW1lbnQuY2hhcnQtdGVtcGxhdGUnOiAnb3RjJyxcbiAgICAgICAgJ2FwcGxpY2F0aW9uL3ZuZC5vYXNpcy5vcGVuZG9jdW1lbnQuZGF0YWJhc2UnOiAnb2RiJyxcbiAgICAgICAgJ2FwcGxpY2F0aW9uL3ZuZC5vYXNpcy5vcGVuZG9jdW1lbnQuZm9ybXVsYSc6ICdvZGYnLFxuICAgICAgICAnYXBwbGljYXRpb24vdm5kLm9hc2lzLm9wZW5kb2N1bWVudC5mb3JtdWxhLXRlbXBsYXRlJzogJ29kZnQnLFxuICAgICAgICAnYXBwbGljYXRpb24vdm5kLm9hc2lzLm9wZW5kb2N1bWVudC5ncmFwaGljcyc6ICdvZGcnLFxuICAgICAgICAnYXBwbGljYXRpb24vdm5kLm9hc2lzLm9wZW5kb2N1bWVudC5ncmFwaGljcy10ZW1wbGF0ZSc6ICdvdGcnLFxuICAgICAgICAnYXBwbGljYXRpb24vdm5kLm9hc2lzLm9wZW5kb2N1bWVudC5pbWFnZSc6ICdvZGknLFxuICAgICAgICAnYXBwbGljYXRpb24vdm5kLm9hc2lzLm9wZW5kb2N1bWVudC5pbWFnZS10ZW1wbGF0ZSc6ICdvdGknLFxuICAgICAgICAnYXBwbGljYXRpb24vdm5kLm9hc2lzLm9wZW5kb2N1bWVudC5wcmVzZW50YXRpb24nOiAnb2RwJyxcbiAgICAgICAgJ2FwcGxpY2F0aW9uL3ZuZC5vYXNpcy5vcGVuZG9jdW1lbnQucHJlc2VudGF0aW9uLXRlbXBsYXRlJzogJ290cCcsXG4gICAgICAgICdhcHBsaWNhdGlvbi92bmQub2FzaXMub3BlbmRvY3VtZW50LnNwcmVhZHNoZWV0JzogJ29kcycsXG4gICAgICAgICdhcHBsaWNhdGlvbi92bmQub2FzaXMub3BlbmRvY3VtZW50LnNwcmVhZHNoZWV0LXRlbXBsYXRlJzogJ290cycsXG4gICAgICAgICdhcHBsaWNhdGlvbi92bmQub2FzaXMub3BlbmRvY3VtZW50LnRleHQnOiAnb2R0JyxcbiAgICAgICAgJ2FwcGxpY2F0aW9uL3ZuZC5vYXNpcy5vcGVuZG9jdW1lbnQudGV4dC1tYXN0ZXInOiAnb2RtJyxcbiAgICAgICAgJ2FwcGxpY2F0aW9uL3ZuZC5vYXNpcy5vcGVuZG9jdW1lbnQudGV4dC10ZW1wbGF0ZSc6ICdvdHQnLFxuICAgICAgICAnYXBwbGljYXRpb24vdm5kLm9hc2lzLm9wZW5kb2N1bWVudC50ZXh0LXdlYic6ICdvdGgnLFxuICAgICAgICAnYXBwbGljYXRpb24vdm5kLm9scGMtc3VnYXInOiAneG8nLFxuICAgICAgICAnYXBwbGljYXRpb24vdm5kLm9tYS5kZDIreG1sJzogJ2RkMicsXG4gICAgICAgICdhcHBsaWNhdGlvbi92bmQub3Blbm9mZmljZW9yZy5leHRlbnNpb24nOiAnb3h0JyxcbiAgICAgICAgJ2FwcGxpY2F0aW9uL3ZuZC5vcGVueG1sZm9ybWF0cy1vZmZpY2Vkb2N1bWVudC5wcmVzZW50YXRpb25tbC5wcmVzZW50YXRpb24nOiAncHB0eCcsXG4gICAgICAgICdhcHBsaWNhdGlvbi92bmQub3BlbnhtbGZvcm1hdHMtb2ZmaWNlZG9jdW1lbnQucHJlc2VudGF0aW9ubWwuc2xpZGUnOiAnc2xkeCcsXG4gICAgICAgICdhcHBsaWNhdGlvbi92bmQub3BlbnhtbGZvcm1hdHMtb2ZmaWNlZG9jdW1lbnQucHJlc2VudGF0aW9ubWwuc2xpZGVzaG93JzogJ3Bwc3gnLFxuICAgICAgICAnYXBwbGljYXRpb24vdm5kLm9wZW54bWxmb3JtYXRzLW9mZmljZWRvY3VtZW50LnByZXNlbnRhdGlvbm1sLnRlbXBsYXRlJzogJ3BvdHgnLFxuICAgICAgICAnYXBwbGljYXRpb24vdm5kLm9wZW54bWxmb3JtYXRzLW9mZmljZWRvY3VtZW50LnNwcmVhZHNoZWV0bWwuc2hlZXQnOiAneGxzeCcsXG4gICAgICAgICdhcHBsaWNhdGlvbi92bmQub3BlbnhtbGZvcm1hdHMtb2ZmaWNlZG9jdW1lbnQuc3ByZWFkc2hlZXRtbC50ZW1wbGF0ZSc6ICd4bHR4JyxcbiAgICAgICAgJ2FwcGxpY2F0aW9uL3ZuZC5vcGVueG1sZm9ybWF0cy1vZmZpY2Vkb2N1bWVudC53b3JkcHJvY2Vzc2luZ21sLmRvY3VtZW50JzogJ2RvY3gnLFxuICAgICAgICAnYXBwbGljYXRpb24vdm5kLm9wZW54bWxmb3JtYXRzLW9mZmljZWRvY3VtZW50LndvcmRwcm9jZXNzaW5nbWwudGVtcGxhdGUnOiAnZG90eCcsXG4gICAgICAgICdhcHBsaWNhdGlvbi92bmQub3NnZW8ubWFwZ3VpZGUucGFja2FnZSc6ICdtZ3AnLFxuICAgICAgICAnYXBwbGljYXRpb24vdm5kLm9zZ2kuZHAnOiAnZHAnLFxuICAgICAgICAnYXBwbGljYXRpb24vdm5kLnBhbG0nOiAncGRiJyxcbiAgICAgICAgJ2FwcGxpY2F0aW9uL3ZuZC5wYXdhYWZpbGUnOiAncGF3JyxcbiAgICAgICAgJ2FwcGxpY2F0aW9uL3ZuZC5wZy5mb3JtYXQnOiAnc3RyJyxcbiAgICAgICAgJ2FwcGxpY2F0aW9uL3ZuZC5wZy5vc2FzbGknOiAnZWk2JyxcbiAgICAgICAgJ2FwcGxpY2F0aW9uL3ZuZC5waWNzZWwnOiAnZWZpZicsXG4gICAgICAgICdhcHBsaWNhdGlvbi92bmQucG1pLndpZGdldCc6ICd3ZycsXG4gICAgICAgICdhcHBsaWNhdGlvbi92bmQucG9ja2V0bGVhcm4nOiAncGxmJyxcbiAgICAgICAgJ2FwcGxpY2F0aW9uL3ZuZC5wb3dlcmJ1aWxkZXI2JzogJ3BiZCcsXG4gICAgICAgICdhcHBsaWNhdGlvbi92bmQucHJldmlld3N5c3RlbXMuYm94JzogJ2JveCcsXG4gICAgICAgICdhcHBsaWNhdGlvbi92bmQucHJvdGV1cy5tYWdhemluZSc6ICdtZ3onLFxuICAgICAgICAnYXBwbGljYXRpb24vdm5kLnB1Ymxpc2hhcmUtZGVsdGEtdHJlZSc6ICdxcHMnLFxuICAgICAgICAnYXBwbGljYXRpb24vdm5kLnB2aS5wdGlkMSc6ICdwdGlkJyxcbiAgICAgICAgJ2FwcGxpY2F0aW9uL3ZuZC5xdWFyay5xdWFya3hwcmVzcyc6ICdxeGQnLFxuICAgICAgICAnYXBwbGljYXRpb24vdm5kLnJlYWx2bmMuYmVkJzogJ2JlZCcsXG4gICAgICAgICdhcHBsaWNhdGlvbi92bmQucmVjb3JkYXJlLm11c2ljeG1sJzogJ214bCcsXG4gICAgICAgICdhcHBsaWNhdGlvbi92bmQucmVjb3JkYXJlLm11c2ljeG1sK3htbCc6ICdtdXNpY3htbCcsXG4gICAgICAgICdhcHBsaWNhdGlvbi92bmQucmlnLmNyeXB0b25vdGUnOiAnY3J5cHRvbm90ZScsXG4gICAgICAgICdhcHBsaWNhdGlvbi92bmQucmltLmNvZCc6ICdjb2QnLFxuICAgICAgICAnYXBwbGljYXRpb24vdm5kLnJuLXJlYWxtZWRpYSc6ICdybScsXG4gICAgICAgICdhcHBsaWNhdGlvbi92bmQucm4tcmVhbHBsYXllcic6ICdybngnLFxuICAgICAgICAnYXBwbGljYXRpb24vdm5kLnJvdXRlNjYubGluazY2K3htbCc6ICdsaW5rNjYnLFxuICAgICAgICAnYXBwbGljYXRpb24vdm5kLnNhaWxpbmd0cmFja2VyLnRyYWNrJzogJ3N0JyxcbiAgICAgICAgJ2FwcGxpY2F0aW9uL3ZuZC5zZWVtYWlsJzogJ3NlZScsXG4gICAgICAgICdhcHBsaWNhdGlvbi92bmQuc2VtYSc6ICdzZW1hJyxcbiAgICAgICAgJ2FwcGxpY2F0aW9uL3ZuZC5zZW1kJzogJ3NlbWQnLFxuICAgICAgICAnYXBwbGljYXRpb24vdm5kLnNlbWYnOiAnc2VtZicsXG4gICAgICAgICdhcHBsaWNhdGlvbi92bmQuc2hhbmEuaW5mb3JtZWQuZm9ybWRhdGEnOiAnaWZtJyxcbiAgICAgICAgJ2FwcGxpY2F0aW9uL3ZuZC5zaGFuYS5pbmZvcm1lZC5mb3JtdGVtcGxhdGUnOiAnaXRwJyxcbiAgICAgICAgJ2FwcGxpY2F0aW9uL3ZuZC5zaGFuYS5pbmZvcm1lZC5pbnRlcmNoYW5nZSc6ICdpaWYnLFxuICAgICAgICAnYXBwbGljYXRpb24vdm5kLnNoYW5hLmluZm9ybWVkLnBhY2thZ2UnOiAnaXBrJyxcbiAgICAgICAgJ2FwcGxpY2F0aW9uL3ZuZC5zaW10ZWNoLW1pbmRtYXBwZXInOiAndHdkJyxcbiAgICAgICAgJ2FwcGxpY2F0aW9uL3ZuZC5zbWFmJzogJ21tZicsXG4gICAgICAgICdhcHBsaWNhdGlvbi92bmQuc21hcnQudGVhY2hlcic6ICd0ZWFjaGVyJyxcbiAgICAgICAgJ2FwcGxpY2F0aW9uL3ZuZC5zb2xlbnQuc2RrbSt4bWwnOiAnc2RrbScsXG4gICAgICAgICdhcHBsaWNhdGlvbi92bmQuc3BvdGZpcmUuZHhwJzogJ2R4cCcsXG4gICAgICAgICdhcHBsaWNhdGlvbi92bmQuc3BvdGZpcmUuc2ZzJzogJ3NmcycsXG4gICAgICAgICdhcHBsaWNhdGlvbi92bmQuc3RhcmRpdmlzaW9uLmNhbGMnOiAnc2RjJyxcbiAgICAgICAgJ2FwcGxpY2F0aW9uL3ZuZC5zdGFyZGl2aXNpb24uZHJhdyc6ICdzZGEnLFxuICAgICAgICAnYXBwbGljYXRpb24vdm5kLnN0YXJkaXZpc2lvbi5pbXByZXNzJzogJ3NkZCcsXG4gICAgICAgICdhcHBsaWNhdGlvbi92bmQuc3RhcmRpdmlzaW9uLm1hdGgnOiAnc21mJyxcbiAgICAgICAgJ2FwcGxpY2F0aW9uL3ZuZC5zdGFyZGl2aXNpb24ud3JpdGVyJzogJ3NkdycsXG4gICAgICAgICdhcHBsaWNhdGlvbi92bmQuc3RhcmRpdmlzaW9uLndyaXRlci1nbG9iYWwnOiAnc2dsJyxcbiAgICAgICAgJ2FwcGxpY2F0aW9uL3ZuZC5zdGVwbWFuaWEuc3RlcGNoYXJ0JzogJ3NtJyxcbiAgICAgICAgJ2FwcGxpY2F0aW9uL3ZuZC5zdW4ueG1sLmNhbGMnOiAnc3hjJyxcbiAgICAgICAgJ2FwcGxpY2F0aW9uL3ZuZC5zdW4ueG1sLmNhbGMudGVtcGxhdGUnOiAnc3RjJyxcbiAgICAgICAgJ2FwcGxpY2F0aW9uL3ZuZC5zdW4ueG1sLmRyYXcnOiAnc3hkJyxcbiAgICAgICAgJ2FwcGxpY2F0aW9uL3ZuZC5zdW4ueG1sLmRyYXcudGVtcGxhdGUnOiAnc3RkJyxcbiAgICAgICAgJ2FwcGxpY2F0aW9uL3ZuZC5zdW4ueG1sLmltcHJlc3MnOiAnc3hpJyxcbiAgICAgICAgJ2FwcGxpY2F0aW9uL3ZuZC5zdW4ueG1sLmltcHJlc3MudGVtcGxhdGUnOiAnc3RpJyxcbiAgICAgICAgJ2FwcGxpY2F0aW9uL3ZuZC5zdW4ueG1sLm1hdGgnOiAnc3htJyxcbiAgICAgICAgJ2FwcGxpY2F0aW9uL3ZuZC5zdW4ueG1sLndyaXRlcic6ICdzeHcnLFxuICAgICAgICAnYXBwbGljYXRpb24vdm5kLnN1bi54bWwud3JpdGVyLmdsb2JhbCc6ICdzeGcnLFxuICAgICAgICAnYXBwbGljYXRpb24vdm5kLnN1bi54bWwud3JpdGVyLnRlbXBsYXRlJzogJ3N0dycsXG4gICAgICAgICdhcHBsaWNhdGlvbi92bmQuc3VzLWNhbGVuZGFyJzogJ3N1cycsXG4gICAgICAgICdhcHBsaWNhdGlvbi92bmQuc3ZkJzogJ3N2ZCcsXG4gICAgICAgICdhcHBsaWNhdGlvbi92bmQuc3ltYmlhbi5pbnN0YWxsJzogJ3NpcycsXG4gICAgICAgICdhcHBsaWNhdGlvbi92bmQuc3luY21sK3htbCc6ICd4c20nLFxuICAgICAgICAnYXBwbGljYXRpb24vdm5kLnN5bmNtbC5kbSt3YnhtbCc6ICdiZG0nLFxuICAgICAgICAnYXBwbGljYXRpb24vdm5kLnN5bmNtbC5kbSt4bWwnOiAneGRtJyxcbiAgICAgICAgJ2FwcGxpY2F0aW9uL3ZuZC50YW8uaW50ZW50LW1vZHVsZS1hcmNoaXZlJzogJ3RhbycsXG4gICAgICAgICdhcHBsaWNhdGlvbi92bmQudG1vYmlsZS1saXZldHYnOiAndG1vJyxcbiAgICAgICAgJ2FwcGxpY2F0aW9uL3ZuZC50cmlkLnRwdCc6ICd0cHQnLFxuICAgICAgICAnYXBwbGljYXRpb24vdm5kLnRyaXNjYXBlLm14cyc6ICdteHMnLFxuICAgICAgICAnYXBwbGljYXRpb24vdm5kLnRydWVhcHAnOiAndHJhJyxcbiAgICAgICAgJ2FwcGxpY2F0aW9uL3ZuZC51ZmRsJzogJ3VmZCcsXG4gICAgICAgICdhcHBsaWNhdGlvbi92bmQudWlxLnRoZW1lJzogJ3V0eicsXG4gICAgICAgICdhcHBsaWNhdGlvbi92bmQudW1hamluJzogJ3VtaicsXG4gICAgICAgICdhcHBsaWNhdGlvbi92bmQudW5pdHknOiAndW5pdHl3ZWInLFxuICAgICAgICAnYXBwbGljYXRpb24vdm5kLnVvbWwreG1sJzogJ3VvbWwnLFxuICAgICAgICAnYXBwbGljYXRpb24vdm5kLnZjeCc6ICd2Y3gnLFxuICAgICAgICAnYXBwbGljYXRpb24vdm5kLnZpc2lvJzogJ3ZzZCcsXG4gICAgICAgICdhcHBsaWNhdGlvbi92bmQudmlzaW9uYXJ5JzogJ3ZpcycsXG4gICAgICAgICdhcHBsaWNhdGlvbi92bmQudnNmJzogJ3ZzZicsXG4gICAgICAgICdhcHBsaWNhdGlvbi92bmQud2FwLndieG1sJzogJ3dieG1sJyxcbiAgICAgICAgJ2FwcGxpY2F0aW9uL3ZuZC53YXAud21sYyc6ICd3bWxjJyxcbiAgICAgICAgJ2FwcGxpY2F0aW9uL3ZuZC53YXAud21sc2NyaXB0Yyc6ICd3bWxzYycsXG4gICAgICAgICdhcHBsaWNhdGlvbi92bmQud2VidHVyYm8nOiAnd3RiJyxcbiAgICAgICAgJ2FwcGxpY2F0aW9uL3ZuZC53b2xmcmFtLnBsYXllcic6ICduYnAnLFxuICAgICAgICAnYXBwbGljYXRpb24vdm5kLndvcmRwZXJmZWN0JzogJ3dwZCcsXG4gICAgICAgICdhcHBsaWNhdGlvbi92bmQud3FkJzogJ3dxZCcsXG4gICAgICAgICdhcHBsaWNhdGlvbi92bmQud3Quc3RmJzogJ3N0ZicsXG4gICAgICAgICdhcHBsaWNhdGlvbi92bmQueGFyYSc6IFsnd2ViJywgJ3hhciddLFxuICAgICAgICAnYXBwbGljYXRpb24vdm5kLnhmZGwnOiAneGZkbCcsXG4gICAgICAgICdhcHBsaWNhdGlvbi92bmQueWFtYWhhLmh2LWRpYyc6ICdodmQnLFxuICAgICAgICAnYXBwbGljYXRpb24vdm5kLnlhbWFoYS5odi1zY3JpcHQnOiAnaHZzJyxcbiAgICAgICAgJ2FwcGxpY2F0aW9uL3ZuZC55YW1haGEuaHYtdm9pY2UnOiAnaHZwJyxcbiAgICAgICAgJ2FwcGxpY2F0aW9uL3ZuZC55YW1haGEub3BlbnNjb3JlZm9ybWF0JzogJ29zZicsXG4gICAgICAgICdhcHBsaWNhdGlvbi92bmQueWFtYWhhLm9wZW5zY29yZWZvcm1hdC5vc2ZwdmcreG1sJzogJ29zZnB2ZycsXG4gICAgICAgICdhcHBsaWNhdGlvbi92bmQueWFtYWhhLnNtYWYtYXVkaW8nOiAnc2FmJyxcbiAgICAgICAgJ2FwcGxpY2F0aW9uL3ZuZC55YW1haGEuc21hZi1waHJhc2UnOiAnc3BmJyxcbiAgICAgICAgJ2FwcGxpY2F0aW9uL3ZuZC55ZWxsb3dyaXZlci1jdXN0b20tbWVudSc6ICdjbXAnLFxuICAgICAgICAnYXBwbGljYXRpb24vdm5kLnp1bCc6ICd6aXInLFxuICAgICAgICAnYXBwbGljYXRpb24vdm5kLnp6YXp6LmRlY2sreG1sJzogJ3pheicsXG4gICAgICAgICdhcHBsaWNhdGlvbi92b2NhbHRlYy1tZWRpYS1kZXNjJzogJ3ZtZCcsXG4gICAgICAgICdhcHBsaWNhdGlvbi92b2NhbHRlYy1tZWRpYS1maWxlJzogJ3ZtZicsXG4gICAgICAgICdhcHBsaWNhdGlvbi92b2ljZXhtbCt4bWwnOiAndnhtbCcsXG4gICAgICAgICdhcHBsaWNhdGlvbi93aWRnZXQnOiAnd2d0JyxcbiAgICAgICAgJ2FwcGxpY2F0aW9uL3dpbmhscCc6ICdobHAnLFxuICAgICAgICAnYXBwbGljYXRpb24vd29yZHBlcmZlY3QnOiBbJ3dwJywgJ3dwNScsICd3cDYnLCAnd3BkJ10sXG4gICAgICAgICdhcHBsaWNhdGlvbi93b3JkcGVyZmVjdDYuMCc6IFsndzYwJywgJ3dwNSddLFxuICAgICAgICAnYXBwbGljYXRpb24vd29yZHBlcmZlY3Q2LjEnOiAndzYxJyxcbiAgICAgICAgJ2FwcGxpY2F0aW9uL3dzZGwreG1sJzogJ3dzZGwnLFxuICAgICAgICAnYXBwbGljYXRpb24vd3Nwb2xpY3kreG1sJzogJ3dzcG9saWN5JyxcbiAgICAgICAgJ2FwcGxpY2F0aW9uL3gtMTIzJzogJ3drMScsXG4gICAgICAgICdhcHBsaWNhdGlvbi94LTd6LWNvbXByZXNzZWQnOiAnN3onLFxuICAgICAgICAnYXBwbGljYXRpb24veC1hYml3b3JkJzogJ2FidycsXG4gICAgICAgICdhcHBsaWNhdGlvbi94LWFjZS1jb21wcmVzc2VkJzogJ2FjZScsXG4gICAgICAgICdhcHBsaWNhdGlvbi94LWFpbSc6ICdhaW0nLFxuICAgICAgICAnYXBwbGljYXRpb24veC1hdXRob3J3YXJlLWJpbic6ICdhYWInLFxuICAgICAgICAnYXBwbGljYXRpb24veC1hdXRob3J3YXJlLW1hcCc6ICdhYW0nLFxuICAgICAgICAnYXBwbGljYXRpb24veC1hdXRob3J3YXJlLXNlZyc6ICdhYXMnLFxuICAgICAgICAnYXBwbGljYXRpb24veC1iY3Bpbyc6ICdiY3BpbycsXG4gICAgICAgICdhcHBsaWNhdGlvbi94LWJpbmFyeSc6ICdiaW4nLFxuICAgICAgICAnYXBwbGljYXRpb24veC1iaW5oZXg0MCc6ICdocXgnLFxuICAgICAgICAnYXBwbGljYXRpb24veC1iaXR0b3JyZW50JzogJ3RvcnJlbnQnLFxuICAgICAgICAnYXBwbGljYXRpb24veC1ic2gnOiBbJ2JzaCcsICdzaCcsICdzaGFyJ10sXG4gICAgICAgICdhcHBsaWNhdGlvbi94LWJ5dGVjb2RlLmVsaXNwJzogJ2VsYycsXG4gICAgICAgICdhcHBsaWNhaXRvbi94LWJ5dGVjb2RlLnB5dGhvbic6ICdweWMnLFxuICAgICAgICAnYXBwbGljYXRpb24veC1iemlwJzogJ2J6JyxcbiAgICAgICAgJ2FwcGxpY2F0aW9uL3gtYnppcDInOiBbJ2JveicsICdiejInXSxcbiAgICAgICAgJ2FwcGxpY2F0aW9uL3gtY2RmJzogJ2NkZicsXG4gICAgICAgICdhcHBsaWNhdGlvbi94LWNkbGluayc6ICd2Y2QnLFxuICAgICAgICAnYXBwbGljYXRpb24veC1jaGF0JzogWydjaGEnLCAnY2hhdCddLFxuICAgICAgICAnYXBwbGljYXRpb24veC1jaGVzcy1wZ24nOiAncGduJyxcbiAgICAgICAgJ2FwcGxpY2F0aW9uL3gtY211LXJhc3Rlcic6ICdyYXMnLFxuICAgICAgICAnYXBwbGljYXRpb24veC1jb2NvYSc6ICdjY28nLFxuICAgICAgICAnYXBwbGljYXRpb24veC1jb21wYWN0cHJvJzogJ2NwdCcsXG4gICAgICAgICdhcHBsaWNhdGlvbi94LWNvbXByZXNzJzogJ3onLFxuICAgICAgICAnYXBwbGljYXRpb24veC1jb21wcmVzc2VkJzogWyd0Z3onLCAnZ3onLCAneicsICd6aXAnXSxcbiAgICAgICAgJ2FwcGxpY2F0aW9uL3gtY29uZmVyZW5jZSc6ICduc2MnLFxuICAgICAgICAnYXBwbGljYXRpb24veC1jcGlvJzogJ2NwaW8nLFxuICAgICAgICAnYXBwbGljYXRpb24veC1jcHQnOiAnY3B0JyxcbiAgICAgICAgJ2FwcGxpY2F0aW9uL3gtY3NoJzogJ2NzaCcsXG4gICAgICAgICdhcHBsaWNhdGlvbi94LWRlYmlhbi1wYWNrYWdlJzogJ2RlYicsXG4gICAgICAgICdhcHBsaWNhdGlvbi94LWRlZXB2JzogJ2RlZXB2JyxcbiAgICAgICAgJ2FwcGxpY2F0aW9uL3gtZGlyZWN0b3InOiBbJ2RpcicsICdkY3InLCAnZHhyJ10sXG4gICAgICAgICdhcHBsaWNhdGlvbi94LWRvb20nOiAnd2FkJyxcbiAgICAgICAgJ2FwcGxpY2F0aW9uL3gtZHRibmN4K3htbCc6ICduY3gnLFxuICAgICAgICAnYXBwbGljYXRpb24veC1kdGJvb2sreG1sJzogJ2R0YicsXG4gICAgICAgICdhcHBsaWNhdGlvbi94LWR0YnJlc291cmNlK3htbCc6ICdyZXMnLFxuICAgICAgICAnYXBwbGljYXRpb24veC1kdmknOiAnZHZpJyxcbiAgICAgICAgJ2FwcGxpY2F0aW9uL3gtZWxjJzogJ2VsYycsXG4gICAgICAgICdhcHBsaWNhdGlvbi94LWVudm95JzogWydlbnYnLCAnZXZ5J10sXG4gICAgICAgICdhcHBsaWNhdGlvbi94LWVzcmVoYmVyJzogJ2VzJyxcbiAgICAgICAgJ2FwcGxpY2F0aW9uL3gtZXhjZWwnOiBbJ3hscycsICd4bGEnLCAneGxiJywgJ3hsYycsICd4bGQnLCAneGxrJywgJ3hsbCcsICd4bG0nLCAneGx0JywgJ3hsdicsICd4bHcnXSxcbiAgICAgICAgJ2FwcGxpY2F0aW9uL3gtZm9udC1iZGYnOiAnYmRmJyxcbiAgICAgICAgJ2FwcGxpY2F0aW9uL3gtZm9udC1naG9zdHNjcmlwdCc6ICdnc2YnLFxuICAgICAgICAnYXBwbGljYXRpb24veC1mb250LWxpbnV4LXBzZic6ICdwc2YnLFxuICAgICAgICAnYXBwbGljYXRpb24veC1mb250LW90Zic6ICdvdGYnLFxuICAgICAgICAnYXBwbGljYXRpb24veC1mb250LXBjZic6ICdwY2YnLFxuICAgICAgICAnYXBwbGljYXRpb24veC1mb250LXNuZic6ICdzbmYnLFxuICAgICAgICAnYXBwbGljYXRpb24veC1mb250LXR0Zic6ICd0dGYnLFxuICAgICAgICAnYXBwbGljYXRpb24veC1mb250LXR5cGUxJzogJ3BmYScsXG4gICAgICAgICdhcHBsaWNhdGlvbi94LWZvbnQtd29mZic6ICd3b2ZmJyxcbiAgICAgICAgJ2FwcGxpY2F0aW9uL3gtZnJhbWUnOiAnbWlmJyxcbiAgICAgICAgJ2FwcGxpY2F0aW9uL3gtZnJlZWxhbmNlJzogJ3ByZScsXG4gICAgICAgICdhcHBsaWNhdGlvbi94LWZ1dHVyZXNwbGFzaCc6ICdzcGwnLFxuICAgICAgICAnYXBwbGljYXRpb24veC1nbnVtZXJpYyc6ICdnbnVtZXJpYycsXG4gICAgICAgICdhcHBsaWNhdGlvbi94LWdzcCc6ICdnc3AnLFxuICAgICAgICAnYXBwbGljYXRpb24veC1nc3MnOiAnZ3NzJyxcbiAgICAgICAgJ2FwcGxpY2F0aW9uL3gtZ3Rhcic6ICdndGFyJyxcbiAgICAgICAgJ2FwcGxpY2F0aW9uL3gtZ3ppcCc6IFsnZ3onLCAnZ3ppcCddLFxuICAgICAgICAnYXBwbGljYXRpb24veC1oZGYnOiAnaGRmJyxcbiAgICAgICAgJ2FwcGxpY2F0aW9uL3gtaGVscGZpbGUnOiBbJ2hlbHAnLCAnaGxwJ10sXG4gICAgICAgICdhcHBsaWNhdGlvbi94LWh0dHBkLWltYXAnOiAnaW1hcCcsXG4gICAgICAgICdhcHBsaWNhdGlvbi94LWltYSc6ICdpbWEnLFxuICAgICAgICAnYXBwbGljYXRpb24veC1pbnRlcm5ldC1zaWdudXAnOiBbJ2lucycsICdpc3AnXSxcbiAgICAgICAgJ2FwcGxpY2F0aW9uL3gtaW50ZXJuZXR0LXNpZ251cCc6ICdpbnMnLFxuICAgICAgICAnYXBwbGljYXRpb24veC1pbnZlbnRvcic6ICdpdicsXG4gICAgICAgICdhcHBsaWNhdGlvbi94LWlwMic6ICdpcCcsXG4gICAgICAgICdhcHBsaWNhdGlvbi94LWlwaG9uZSc6ICdpaWknLFxuICAgICAgICAnYXBwbGljYXRpb24veC1qYXZhLWNsYXNzJzogJ2NsYXNzJyxcbiAgICAgICAgJ2FwcGxpY2F0aW9uL3gtamF2YS1jb21tZXJjZSc6ICdqY20nLFxuICAgICAgICAnYXBwbGljYXRpb24veC1qYXZhLWpubHAtZmlsZSc6ICdqbmxwJyxcbiAgICAgICAgJ2FwcGxpY2F0aW9uL3gtamF2YXNjcmlwdCc6ICdqcycsXG4gICAgICAgICdhcHBsaWNhdGlvbi94LWtvYW4nOiBbJ3NrZCcsICdza20nLCAnc2twJywgJ3NrdCddLFxuICAgICAgICAnYXBwbGljYXRpb24veC1rc2gnOiAna3NoJyxcbiAgICAgICAgJ2FwcGxpY2F0aW9uL3gtbGF0ZXgnOiBbJ2xhdGV4JywgJ2x0eCddLFxuICAgICAgICAnYXBwbGljYXRpb24veC1saGEnOiAnbGhhJyxcbiAgICAgICAgJ2FwcGxpY2F0aW9uL3gtbGlzcCc6ICdsc3AnLFxuICAgICAgICAnYXBwbGljYXRpb24veC1saXZlc2NyZWVuJzogJ2l2eScsXG4gICAgICAgICdhcHBsaWNhdGlvbi94LWxvdHVzJzogJ3dxMScsXG4gICAgICAgICdhcHBsaWNhdGlvbi94LWxvdHVzc2NyZWVuY2FtJzogJ3NjbScsXG4gICAgICAgICdhcHBsaWNhdGlvbi94LWx6aCc6ICdsemgnLFxuICAgICAgICAnYXBwbGljYXRpb24veC1sengnOiAnbHp4JyxcbiAgICAgICAgJ2FwcGxpY2F0aW9uL3gtbWFjLWJpbmhleDQwJzogJ2hxeCcsXG4gICAgICAgICdhcHBsaWNhdGlvbi94LW1hY2JpbmFyeSc6ICdiaW4nLFxuICAgICAgICAnYXBwbGljYXRpb24veC1tYWdpYy1jYXAtcGFja2FnZS0xLjAnOiAnbWMkJyxcbiAgICAgICAgJ2FwcGxpY2F0aW9uL3gtbWF0aGNhZCc6ICdtY2QnLFxuICAgICAgICAnYXBwbGljYXRpb24veC1tZW1lJzogJ21tJyxcbiAgICAgICAgJ2FwcGxpY2F0aW9uL3gtbWlkaSc6IFsnbWlkJywgJ21pZGknXSxcbiAgICAgICAgJ2FwcGxpY2F0aW9uL3gtbWlmJzogJ21pZicsXG4gICAgICAgICdhcHBsaWNhdGlvbi94LW1peC10cmFuc2Zlcic6ICduaXgnLFxuICAgICAgICAnYXBwbGljYXRpb24veC1tb2JpcG9ja2V0LWVib29rJzogJ3ByYycsXG4gICAgICAgICdhcHBsaWNhdGlvbi94LW1wbGF5ZXIyJzogJ2FzeCcsXG4gICAgICAgICdhcHBsaWNhdGlvbi94LW1zLWFwcGxpY2F0aW9uJzogJ2FwcGxpY2F0aW9uJyxcbiAgICAgICAgJ2FwcGxpY2F0aW9uL3gtbXMtd21kJzogJ3dtZCcsXG4gICAgICAgICdhcHBsaWNhdGlvbi94LW1zLXdteic6ICd3bXonLFxuICAgICAgICAnYXBwbGljYXRpb24veC1tcy14YmFwJzogJ3hiYXAnLFxuICAgICAgICAnYXBwbGljYXRpb24veC1tc2FjY2Vzcyc6ICdtZGInLFxuICAgICAgICAnYXBwbGljYXRpb24veC1tc2JpbmRlcic6ICdvYmQnLFxuICAgICAgICAnYXBwbGljYXRpb24veC1tc2NhcmRmaWxlJzogJ2NyZCcsXG4gICAgICAgICdhcHBsaWNhdGlvbi94LW1zY2xpcCc6ICdjbHAnLFxuICAgICAgICAnYXBwbGljYXRpb24veC1tc2Rvd25sb2FkJzogWydleGUnLCAnZGxsJ10sXG4gICAgICAgICdhcHBsaWNhdGlvbi94LW1zZXhjZWwnOiBbJ3hscycsICd4bGEnLCAneGx3J10sXG4gICAgICAgICdhcHBsaWNhdGlvbi94LW1zbWVkaWF2aWV3JzogWydtdmInLCAnbTEzJywgJ20xNCddLFxuICAgICAgICAnYXBwbGljYXRpb24veC1tc21ldGFmaWxlJzogJ3dtZicsXG4gICAgICAgICdhcHBsaWNhdGlvbi94LW1zbW9uZXknOiAnbW55JyxcbiAgICAgICAgJ2FwcGxpY2F0aW9uL3gtbXNwb3dlcnBvaW50JzogJ3BwdCcsXG4gICAgICAgICdhcHBsaWNhdGlvbi94LW1zcHVibGlzaGVyJzogJ3B1YicsXG4gICAgICAgICdhcHBsaWNhdGlvbi94LW1zc2NoZWR1bGUnOiAnc2NkJyxcbiAgICAgICAgJ2FwcGxpY2F0aW9uL3gtbXN0ZXJtaW5hbCc6ICd0cm0nLFxuICAgICAgICAnYXBwbGljYXRpb24veC1tc3dyaXRlJzogJ3dyaScsXG4gICAgICAgICdhcHBsaWNhdGlvbi94LW5hdmktYW5pbWF0aW9uJzogJ2FuaScsXG4gICAgICAgICdhcHBsaWNhdGlvbi94LW5hdmlkb2MnOiAnbnZkJyxcbiAgICAgICAgJ2FwcGxpY2F0aW9uL3gtbmF2aW1hcCc6ICdtYXAnLFxuICAgICAgICAnYXBwbGljYXRpb24veC1uYXZpc3R5bGUnOiAnc3RsJyxcbiAgICAgICAgJ2FwcGxpY2F0aW9uL3gtbmV0Y2RmJzogWydjZGYnLCAnbmMnXSxcbiAgICAgICAgJ2FwcGxpY2F0aW9uL3gtbmV3dG9uLWNvbXBhdGlibGUtcGtnJzogJ3BrZycsXG4gICAgICAgICdhcHBsaWNhdGlvbi94LW5va2lhLTkwMDAtY29tbXVuaWNhdG9yLWFkZC1vbi1zb2Z0d2FyZSc6ICdhb3MnLFxuICAgICAgICAnYXBwbGljYXRpb24veC1vbWMnOiAnb21jJyxcbiAgICAgICAgJ2FwcGxpY2F0aW9uL3gtb21jZGF0YW1ha2VyJzogJ29tY2QnLFxuICAgICAgICAnYXBwbGljYXRpb24veC1vbWNyZWdlcmF0b3InOiAnb21jcicsXG4gICAgICAgICdhcHBsaWNhdGlvbi94LXBhZ2VtYWtlcic6IFsncG00JywgJ3BtNSddLFxuICAgICAgICAnYXBwbGljYXRpb24veC1wY2wnOiAncGNsJyxcbiAgICAgICAgJ2FwcGxpY2F0aW9uL3gtcGVyZm1vbic6IFsncG1hJywgJ3BtYycsICdwbWwnLCAncG1yJywgJ3BtdyddLFxuICAgICAgICAnYXBwbGljYXRpb24veC1waXhjbHNjcmlwdCc6ICdwbHgnLFxuICAgICAgICAnYXBwbGljYXRpb24veC1wa2NzMTAnOiAncDEwJyxcbiAgICAgICAgJ2FwcGxpY2F0aW9uL3gtcGtjczEyJzogWydwMTInLCAncGZ4J10sXG4gICAgICAgICdhcHBsaWNhdGlvbi94LXBrY3M3LWNlcnRpZmljYXRlcyc6IFsncDdiJywgJ3NwYyddLFxuICAgICAgICAnYXBwbGljYXRpb24veC1wa2NzNy1jZXJ0cmVxcmVzcCc6ICdwN3InLFxuICAgICAgICAnYXBwbGljYXRpb24veC1wa2NzNy1taW1lJzogWydwN20nLCAncDdjJ10sXG4gICAgICAgICdhcHBsaWNhdGlvbi94LXBrY3M3LXNpZ25hdHVyZSc6IFsncDdzJywgJ3A3YSddLFxuICAgICAgICAnYXBwbGljYXRpb24veC1wb2ludHBsdXMnOiAnY3NzJyxcbiAgICAgICAgJ2FwcGxpY2F0aW9uL3gtcG9ydGFibGUtYW55bWFwJzogJ3BubScsXG4gICAgICAgICdhcHBsaWNhdGlvbi94LXByb2plY3QnOiBbJ21wYycsICdtcHQnLCAnbXB2JywgJ21weCddLFxuICAgICAgICAnYXBwbGljYXRpb24veC1xcHJvJzogJ3diMScsXG4gICAgICAgICdhcHBsaWNhdGlvbi94LXJhci1jb21wcmVzc2VkJzogJ3JhcicsXG4gICAgICAgICdhcHBsaWNhdGlvbi94LXJ0Zic6ICdydGYnLFxuICAgICAgICAnYXBwbGljYXRpb24veC1zZHAnOiAnc2RwJyxcbiAgICAgICAgJ2FwcGxpY2F0aW9uL3gtc2VhJzogJ3NlYScsXG4gICAgICAgICdhcHBsaWNhdGlvbi94LXNlZWxvZ28nOiAnc2wnLFxuICAgICAgICAnYXBwbGljYXRpb24veC1zaCc6ICdzaCcsXG4gICAgICAgICdhcHBsaWNhdGlvbi94LXNoYXInOiBbJ3NoYXInLCAnc2gnXSxcbiAgICAgICAgJ2FwcGxpY2F0aW9uL3gtc2hvY2t3YXZlLWZsYXNoJzogJ3N3ZicsXG4gICAgICAgICdhcHBsaWNhdGlvbi94LXNpbHZlcmxpZ2h0LWFwcCc6ICd4YXAnLFxuICAgICAgICAnYXBwbGljYXRpb24veC1zaXQnOiAnc2l0JyxcbiAgICAgICAgJ2FwcGxpY2F0aW9uL3gtc3ByaXRlJzogWydzcHInLCAnc3ByaXRlJ10sXG4gICAgICAgICdhcHBsaWNhdGlvbi94LXN0dWZmaXQnOiAnc2l0JyxcbiAgICAgICAgJ2FwcGxpY2F0aW9uL3gtc3R1ZmZpdHgnOiAnc2l0eCcsXG4gICAgICAgICdhcHBsaWNhdGlvbi94LXN2NGNwaW8nOiAnc3Y0Y3BpbycsXG4gICAgICAgICdhcHBsaWNhdGlvbi94LXN2NGNyYyc6ICdzdjRjcmMnLFxuICAgICAgICAnYXBwbGljYXRpb24veC10YXInOiAndGFyJyxcbiAgICAgICAgJ2FwcGxpY2F0aW9uL3gtdGJvb2snOiBbJ3NiaycsICd0YmsnXSxcbiAgICAgICAgJ2FwcGxpY2F0aW9uL3gtdGNsJzogJ3RjbCcsXG4gICAgICAgICdhcHBsaWNhdGlvbi94LXRleCc6ICd0ZXgnLFxuICAgICAgICAnYXBwbGljYXRpb24veC10ZXgtdGZtJzogJ3RmbScsXG4gICAgICAgICdhcHBsaWNhdGlvbi94LXRleGluZm8nOiBbJ3RleGknLCAndGV4aW5mbyddLFxuICAgICAgICAnYXBwbGljYXRpb24veC10cm9mZic6IFsncm9mZicsICd0JywgJ3RyJ10sXG4gICAgICAgICdhcHBsaWNhdGlvbi94LXRyb2ZmLW1hbic6ICdtYW4nLFxuICAgICAgICAnYXBwbGljYXRpb24veC10cm9mZi1tZSc6ICdtZScsXG4gICAgICAgICdhcHBsaWNhdGlvbi94LXRyb2ZmLW1zJzogJ21zJyxcbiAgICAgICAgJ2FwcGxpY2F0aW9uL3gtdHJvZmYtbXN2aWRlbyc6ICdhdmknLFxuICAgICAgICAnYXBwbGljYXRpb24veC11c3Rhcic6ICd1c3RhcicsXG4gICAgICAgICdhcHBsaWNhdGlvbi94LXZpc2lvJzogWyd2c2QnLCAndnN0JywgJ3ZzdyddLFxuICAgICAgICAnYXBwbGljYXRpb24veC12bmQuYXVkaW9leHBsb3Npb24ubXp6JzogJ216eicsXG4gICAgICAgICdhcHBsaWNhdGlvbi94LXZuZC5scy14cGl4JzogJ3hwaXgnLFxuICAgICAgICAnYXBwbGljYXRpb24veC12cm1sJzogJ3ZybWwnLFxuICAgICAgICAnYXBwbGljYXRpb24veC13YWlzLXNvdXJjZSc6IFsnc3JjJywgJ3dzcmMnXSxcbiAgICAgICAgJ2FwcGxpY2F0aW9uL3gtd2luaGVscCc6ICdobHAnLFxuICAgICAgICAnYXBwbGljYXRpb24veC13aW50YWxrJzogJ3d0aycsXG4gICAgICAgICdhcHBsaWNhdGlvbi94LXdvcmxkJzogWyd3cmwnLCAnc3ZyJ10sXG4gICAgICAgICdhcHBsaWNhdGlvbi94LXdwd2luJzogJ3dwZCcsXG4gICAgICAgICdhcHBsaWNhdGlvbi94LXdyaSc6ICd3cmknLFxuICAgICAgICAnYXBwbGljYXRpb24veC14NTA5LWNhLWNlcnQnOiBbJ2NlcicsICdjcnQnLCAnZGVyJ10sXG4gICAgICAgICdhcHBsaWNhdGlvbi94LXg1MDktdXNlci1jZXJ0JzogJ2NydCcsXG4gICAgICAgICdhcHBsaWNhdGlvbi94LXhmaWcnOiAnZmlnJyxcbiAgICAgICAgJ2FwcGxpY2F0aW9uL3gteHBpbnN0YWxsJzogJ3hwaScsXG4gICAgICAgICdhcHBsaWNhdGlvbi94LXppcC1jb21wcmVzc2VkJzogJ3ppcCcsXG4gICAgICAgICdhcHBsaWNhdGlvbi94Y2FwLWRpZmYreG1sJzogJ3hkZicsXG4gICAgICAgICdhcHBsaWNhdGlvbi94ZW5jK3htbCc6ICd4ZW5jJyxcbiAgICAgICAgJ2FwcGxpY2F0aW9uL3hodG1sK3htbCc6ICd4aHRtbCcsXG4gICAgICAgICdhcHBsaWNhdGlvbi94bWwnOiAneG1sJyxcbiAgICAgICAgJ2FwcGxpY2F0aW9uL3htbC1kdGQnOiAnZHRkJyxcbiAgICAgICAgJ2FwcGxpY2F0aW9uL3hvcCt4bWwnOiAneG9wJyxcbiAgICAgICAgJ2FwcGxpY2F0aW9uL3hzbHQreG1sJzogJ3hzbHQnLFxuICAgICAgICAnYXBwbGljYXRpb24veHNwZit4bWwnOiAneHNwZicsXG4gICAgICAgICdhcHBsaWNhdGlvbi94dit4bWwnOiAnbXhtbCcsXG4gICAgICAgICdhcHBsaWNhdGlvbi95YW5nJzogJ3lhbmcnLFxuICAgICAgICAnYXBwbGljYXRpb24veWluK3htbCc6ICd5aW4nLFxuICAgICAgICAnYXBwbGljYXRpb24veW5kLm1zLXBraXBrbyc6ICdwa28nLFxuICAgICAgICAnYXBwbGljYXRpb24vemlwJzogJ3ppcCcsXG4gICAgICAgICdhdWRpby9hZHBjbSc6ICdhZHAnLFxuICAgICAgICAnYXVkaW8vYWlmZic6IFsnYWlmZicsICdhaWYnLCAnYWlmYyddLFxuICAgICAgICAnYXVkaW8vYmFzaWMnOiBbJ3NuZCcsICdhdSddLFxuICAgICAgICAnYXVkaW8vaXQnOiAnaXQnLFxuICAgICAgICAnYXVkaW8vbWFrZSc6IFsnZnVuaycsICdteScsICdwZnVuayddLFxuICAgICAgICAnYXVkaW8vbWFrZS5teS5mdW5rJzogJ3BmdW5rJyxcbiAgICAgICAgJ2F1ZGlvL21pZCc6IFsnbWlkJywgJ3JtaSddLFxuICAgICAgICAnYXVkaW8vbWlkaSc6IFsnbWlkaScsICdrYXInLCAnbWlkJ10sXG4gICAgICAgICdhdWRpby9tb2QnOiAnbW9kJyxcbiAgICAgICAgJ2F1ZGlvL21wNCc6ICdtcDRhJyxcbiAgICAgICAgJ2F1ZGlvL21wZWcnOiBbJ21wZ2EnLCAnbXAzJywgJ20yYScsICdtcDInLCAnbXBhJywgJ21wZyddLFxuICAgICAgICAnYXVkaW8vbXBlZzMnOiAnbXAzJyxcbiAgICAgICAgJ2F1ZGlvL25zcGF1ZGlvJzogWydsYScsICdsbWEnXSxcbiAgICAgICAgJ2F1ZGlvL29nZyc6ICdvZ2EnLFxuICAgICAgICAnYXVkaW8vczNtJzogJ3MzbScsXG4gICAgICAgICdhdWRpby90c3AtYXVkaW8nOiAndHNpJyxcbiAgICAgICAgJ2F1ZGlvL3RzcGxheWVyJzogJ3RzcCcsXG4gICAgICAgICdhdWRpby92bmQuZGVjZS5hdWRpbyc6ICd1dmEnLFxuICAgICAgICAnYXVkaW8vdm5kLmRpZ2l0YWwtd2luZHMnOiAnZW9sJyxcbiAgICAgICAgJ2F1ZGlvL3ZuZC5kcmEnOiAnZHJhJyxcbiAgICAgICAgJ2F1ZGlvL3ZuZC5kdHMnOiAnZHRzJyxcbiAgICAgICAgJ2F1ZGlvL3ZuZC5kdHMuaGQnOiAnZHRzaGQnLFxuICAgICAgICAnYXVkaW8vdm5kLmx1Y2VudC52b2ljZSc6ICdsdnAnLFxuICAgICAgICAnYXVkaW8vdm5kLm1zLXBsYXlyZWFkeS5tZWRpYS5weWEnOiAncHlhJyxcbiAgICAgICAgJ2F1ZGlvL3ZuZC5udWVyYS5lY2VscDQ4MDAnOiAnZWNlbHA0ODAwJyxcbiAgICAgICAgJ2F1ZGlvL3ZuZC5udWVyYS5lY2VscDc0NzAnOiAnZWNlbHA3NDcwJyxcbiAgICAgICAgJ2F1ZGlvL3ZuZC5udWVyYS5lY2VscDk2MDAnOiAnZWNlbHA5NjAwJyxcbiAgICAgICAgJ2F1ZGlvL3ZuZC5xY2VscCc6ICdxY3AnLFxuICAgICAgICAnYXVkaW8vdm5kLnJpcCc6ICdyaXAnLFxuICAgICAgICAnYXVkaW8vdm9jJzogJ3ZvYycsXG4gICAgICAgICdhdWRpby92b3h3YXJlJzogJ3ZveCcsXG4gICAgICAgICdhdWRpby93YXYnOiAnd2F2JyxcbiAgICAgICAgJ2F1ZGlvL3dlYm0nOiAnd2ViYScsXG4gICAgICAgICdhdWRpby94LWFhYyc6ICdhYWMnLFxuICAgICAgICAnYXVkaW8veC1hZHBjbSc6ICdzbmQnLFxuICAgICAgICAnYXVkaW8veC1haWZmJzogWydhaWZmJywgJ2FpZicsICdhaWZjJ10sXG4gICAgICAgICdhdWRpby94LWF1JzogJ2F1JyxcbiAgICAgICAgJ2F1ZGlvL3gtZ3NtJzogWydnc2QnLCAnZ3NtJ10sXG4gICAgICAgICdhdWRpby94LWphbSc6ICdqYW0nLFxuICAgICAgICAnYXVkaW8veC1saXZlYXVkaW8nOiAnbGFtJyxcbiAgICAgICAgJ2F1ZGlvL3gtbWlkJzogWydtaWQnLCAnbWlkaSddLFxuICAgICAgICAnYXVkaW8veC1taWRpJzogWydtaWRpJywgJ21pZCddLFxuICAgICAgICAnYXVkaW8veC1tb2QnOiAnbW9kJyxcbiAgICAgICAgJ2F1ZGlvL3gtbXBlZyc6ICdtcDInLFxuICAgICAgICAnYXVkaW8veC1tcGVnLTMnOiAnbXAzJyxcbiAgICAgICAgJ2F1ZGlvL3gtbXBlZ3VybCc6ICdtM3UnLFxuICAgICAgICAnYXVkaW8veC1tcGVxdXJsJzogJ20zdScsXG4gICAgICAgICdhdWRpby94LW1zLXdheCc6ICd3YXgnLFxuICAgICAgICAnYXVkaW8veC1tcy13bWEnOiAnd21hJyxcbiAgICAgICAgJ2F1ZGlvL3gtbnNwYXVkaW8nOiBbJ2xhJywgJ2xtYSddLFxuICAgICAgICAnYXVkaW8veC1wbi1yZWFsYXVkaW8nOiBbJ3JhJywgJ3JhbScsICdybScsICdybW0nLCAncm1wJ10sXG4gICAgICAgICdhdWRpby94LXBuLXJlYWxhdWRpby1wbHVnaW4nOiBbJ3JhJywgJ3JtcCcsICdycG0nXSxcbiAgICAgICAgJ2F1ZGlvL3gtcHNpZCc6ICdzaWQnLFxuICAgICAgICAnYXVkaW8veC1yZWFsYXVkaW8nOiAncmEnLFxuICAgICAgICAnYXVkaW8veC10d2ludnEnOiAndnFmJyxcbiAgICAgICAgJ2F1ZGlvL3gtdHdpbnZxLXBsdWdpbic6IFsndnFlJywgJ3ZxbCddLFxuICAgICAgICAnYXVkaW8veC12bmQuYXVkaW9leHBsb3Npb24ubWp1aWNlbWVkaWFmaWxlJzogJ21qZicsXG4gICAgICAgICdhdWRpby94LXZvYyc6ICd2b2MnLFxuICAgICAgICAnYXVkaW8veC13YXYnOiAnd2F2JyxcbiAgICAgICAgJ2F1ZGlvL3htJzogJ3htJyxcbiAgICAgICAgJ2NoZW1pY2FsL3gtY2R4JzogJ2NkeCcsXG4gICAgICAgICdjaGVtaWNhbC94LWNpZic6ICdjaWYnLFxuICAgICAgICAnY2hlbWljYWwveC1jbWRmJzogJ2NtZGYnLFxuICAgICAgICAnY2hlbWljYWwveC1jbWwnOiAnY21sJyxcbiAgICAgICAgJ2NoZW1pY2FsL3gtY3NtbCc6ICdjc21sJyxcbiAgICAgICAgJ2NoZW1pY2FsL3gtcGRiJzogWydwZGInLCAneHl6J10sXG4gICAgICAgICdjaGVtaWNhbC94LXh5eic6ICd4eXonLFxuICAgICAgICAnZHJhd2luZy94LWR3Zic6ICdkd2YnLFxuICAgICAgICAnaS13b3JsZC9pLXZybWwnOiAnaXZyJyxcbiAgICAgICAgJ2ltYWdlL2JtcCc6IFsnYm1wJywgJ2JtJ10sXG4gICAgICAgICdpbWFnZS9jZ20nOiAnY2dtJyxcbiAgICAgICAgJ2ltYWdlL2Npcy1jb2QnOiAnY29kJyxcbiAgICAgICAgJ2ltYWdlL2NtdS1yYXN0ZXInOiBbJ3JhcycsICdyYXN0J10sXG4gICAgICAgICdpbWFnZS9maWYnOiAnZmlmJyxcbiAgICAgICAgJ2ltYWdlL2Zsb3JpYW4nOiBbJ2ZsbycsICd0dXJib3QnXSxcbiAgICAgICAgJ2ltYWdlL2czZmF4JzogJ2czJyxcbiAgICAgICAgJ2ltYWdlL2dpZic6ICdnaWYnLFxuICAgICAgICAnaW1hZ2UvaWVmJzogWydpZWYnLCAnaWVmcyddLFxuICAgICAgICAnaW1hZ2UvanBlZyc6IFsnanBlZycsICdqcGUnLCAnanBnJywgJ2pmaWYnLCAnamZpZi10Ym5sJ10sXG4gICAgICAgICdpbWFnZS9qdXR2aXNpb24nOiAnanV0JyxcbiAgICAgICAgJ2ltYWdlL2t0eCc6ICdrdHgnLFxuICAgICAgICAnaW1hZ2UvbmFwbHBzJzogWyduYXAnLCAnbmFwbHBzJ10sXG4gICAgICAgICdpbWFnZS9waWN0JzogWydwaWMnLCAncGljdCddLFxuICAgICAgICAnaW1hZ2UvcGlwZWcnOiAnamZpZicsXG4gICAgICAgICdpbWFnZS9wanBlZyc6IFsnamZpZicsICdqcGUnLCAnanBlZycsICdqcGcnXSxcbiAgICAgICAgJ2ltYWdlL3BuZyc6IFsncG5nJywgJ3gtcG5nJ10sXG4gICAgICAgICdpbWFnZS9wcnMuYnRpZic6ICdidGlmJyxcbiAgICAgICAgJ2ltYWdlL3N2Zyt4bWwnOiAnc3ZnJyxcbiAgICAgICAgJ2ltYWdlL3RpZmYnOiBbJ3RpZicsICd0aWZmJ10sXG4gICAgICAgICdpbWFnZS92YXNhJzogJ21jZicsXG4gICAgICAgICdpbWFnZS92bmQuYWRvYmUucGhvdG9zaG9wJzogJ3BzZCcsXG4gICAgICAgICdpbWFnZS92bmQuZGVjZS5ncmFwaGljJzogJ3V2aScsXG4gICAgICAgICdpbWFnZS92bmQuZGp2dSc6ICdkanZ1JyxcbiAgICAgICAgJ2ltYWdlL3ZuZC5kdmIuc3VidGl0bGUnOiAnc3ViJyxcbiAgICAgICAgJ2ltYWdlL3ZuZC5kd2cnOiBbJ2R3ZycsICdkeGYnLCAnc3ZmJ10sXG4gICAgICAgICdpbWFnZS92bmQuZHhmJzogJ2R4ZicsXG4gICAgICAgICdpbWFnZS92bmQuZmFzdGJpZHNoZWV0JzogJ2ZicycsXG4gICAgICAgICdpbWFnZS92bmQuZnB4JzogJ2ZweCcsXG4gICAgICAgICdpbWFnZS92bmQuZnN0JzogJ2ZzdCcsXG4gICAgICAgICdpbWFnZS92bmQuZnVqaXhlcm94LmVkbWljcy1tbXInOiAnbW1yJyxcbiAgICAgICAgJ2ltYWdlL3ZuZC5mdWppeGVyb3guZWRtaWNzLXJsYyc6ICdybGMnLFxuICAgICAgICAnaW1hZ2Uvdm5kLm1zLW1vZGknOiAnbWRpJyxcbiAgICAgICAgJ2ltYWdlL3ZuZC5uZXQtZnB4JzogWydmcHgnLCAnbnB4J10sXG4gICAgICAgICdpbWFnZS92bmQucm4tcmVhbGZsYXNoJzogJ3JmJyxcbiAgICAgICAgJ2ltYWdlL3ZuZC5ybi1yZWFscGl4JzogJ3JwJyxcbiAgICAgICAgJ2ltYWdlL3ZuZC53YXAud2JtcCc6ICd3Ym1wJyxcbiAgICAgICAgJ2ltYWdlL3ZuZC54aWZmJzogJ3hpZicsXG4gICAgICAgICdpbWFnZS93ZWJwJzogJ3dlYnAnLFxuICAgICAgICAnaW1hZ2UveC1jbXUtcmFzdGVyJzogJ3JhcycsXG4gICAgICAgICdpbWFnZS94LWNteCc6ICdjbXgnLFxuICAgICAgICAnaW1hZ2UveC1kd2cnOiBbJ2R3ZycsICdkeGYnLCAnc3ZmJ10sXG4gICAgICAgICdpbWFnZS94LWZyZWVoYW5kJzogJ2ZoJyxcbiAgICAgICAgJ2ltYWdlL3gtaWNvbic6ICdpY28nLFxuICAgICAgICAnaW1hZ2UveC1qZyc6ICdhcnQnLFxuICAgICAgICAnaW1hZ2UveC1qcHMnOiAnanBzJyxcbiAgICAgICAgJ2ltYWdlL3gtbmlmZic6IFsnbmlmZicsICduaWYnXSxcbiAgICAgICAgJ2ltYWdlL3gtcGN4JzogJ3BjeCcsXG4gICAgICAgICdpbWFnZS94LXBpY3QnOiBbJ3BjdCcsICdwaWMnXSxcbiAgICAgICAgJ2ltYWdlL3gtcG9ydGFibGUtYW55bWFwJzogJ3BubScsXG4gICAgICAgICdpbWFnZS94LXBvcnRhYmxlLWJpdG1hcCc6ICdwYm0nLFxuICAgICAgICAnaW1hZ2UveC1wb3J0YWJsZS1ncmF5bWFwJzogJ3BnbScsXG4gICAgICAgICdpbWFnZS94LXBvcnRhYmxlLWdyZXltYXAnOiAncGdtJyxcbiAgICAgICAgJ2ltYWdlL3gtcG9ydGFibGUtcGl4bWFwJzogJ3BwbScsXG4gICAgICAgICdpbWFnZS94LXF1aWNrdGltZSc6IFsncWlmJywgJ3F0aScsICdxdGlmJ10sXG4gICAgICAgICdpbWFnZS94LXJnYic6ICdyZ2InLFxuICAgICAgICAnaW1hZ2UveC10aWZmJzogWyd0aWYnLCAndGlmZiddLFxuICAgICAgICAnaW1hZ2UveC13aW5kb3dzLWJtcCc6ICdibXAnLFxuICAgICAgICAnaW1hZ2UveC14Yml0bWFwJzogJ3hibScsXG4gICAgICAgICdpbWFnZS94LXhibSc6ICd4Ym0nLFxuICAgICAgICAnaW1hZ2UveC14cGl4bWFwJzogWyd4cG0nLCAncG0nXSxcbiAgICAgICAgJ2ltYWdlL3gteHdkJzogJ3h3ZCcsXG4gICAgICAgICdpbWFnZS94LXh3aW5kb3dkdW1wJzogJ3h3ZCcsXG4gICAgICAgICdpbWFnZS94Ym0nOiAneGJtJyxcbiAgICAgICAgJ2ltYWdlL3hwbSc6ICd4cG0nLFxuICAgICAgICAnbWVzc2FnZS9yZmM4MjInOiBbJ2VtbCcsICdtaHQnLCAnbWh0bWwnLCAnbndzJywgJ21pbWUnXSxcbiAgICAgICAgJ21vZGVsL2lnZXMnOiBbJ2lnZXMnLCAnaWdzJ10sXG4gICAgICAgICdtb2RlbC9tZXNoJzogJ21zaCcsXG4gICAgICAgICdtb2RlbC92bmQuY29sbGFkYSt4bWwnOiAnZGFlJyxcbiAgICAgICAgJ21vZGVsL3ZuZC5kd2YnOiAnZHdmJyxcbiAgICAgICAgJ21vZGVsL3ZuZC5nZGwnOiAnZ2RsJyxcbiAgICAgICAgJ21vZGVsL3ZuZC5ndHcnOiAnZ3R3JyxcbiAgICAgICAgJ21vZGVsL3ZuZC5tdHMnOiAnbXRzJyxcbiAgICAgICAgJ21vZGVsL3ZuZC52dHUnOiAndnR1JyxcbiAgICAgICAgJ21vZGVsL3ZybWwnOiBbJ3ZybWwnLCAnd3JsJywgJ3dyeiddLFxuICAgICAgICAnbW9kZWwveC1wb3YnOiAncG92JyxcbiAgICAgICAgJ211bHRpcGFydC94LWd6aXAnOiAnZ3ppcCcsXG4gICAgICAgICdtdWx0aXBhcnQveC11c3Rhcic6ICd1c3RhcicsXG4gICAgICAgICdtdWx0aXBhcnQveC16aXAnOiAnemlwJyxcbiAgICAgICAgJ211c2ljL2NyZXNjZW5kbyc6IFsnbWlkJywgJ21pZGknXSxcbiAgICAgICAgJ211c2ljL3gta2FyYW9rZSc6ICdrYXInLFxuICAgICAgICAncGFsZW92dS94LXB2JzogJ3B2dScsXG4gICAgICAgICd0ZXh0L2FzcCc6ICdhc3AnLFxuICAgICAgICAndGV4dC9jYWxlbmRhcic6ICdpY3MnLFxuICAgICAgICAndGV4dC9jc3MnOiAnY3NzJyxcbiAgICAgICAgJ3RleHQvY3N2JzogJ2NzdicsXG4gICAgICAgICd0ZXh0L2VjbWFzY3JpcHQnOiAnanMnLFxuICAgICAgICAndGV4dC9oMzIzJzogJzMyMycsXG4gICAgICAgICd0ZXh0L2h0bWwnOiBbJ2h0bWwnLCAnaHRtJywgJ3N0bScsICdhY2dpJywgJ2h0bWxzJywgJ2h0eCcsICdzaHRtbCddLFxuICAgICAgICAndGV4dC9pdWxzJzogJ3VscycsXG4gICAgICAgICd0ZXh0L2phdmFzY3JpcHQnOiAnanMnLFxuICAgICAgICAndGV4dC9tY2YnOiAnbWNmJyxcbiAgICAgICAgJ3RleHQvbjMnOiAnbjMnLFxuICAgICAgICAndGV4dC9wYXNjYWwnOiAncGFzJyxcbiAgICAgICAgJ3RleHQvcGxhaW4nOiBbJ3R4dCcsICdiYXMnLCAnYycsICdoJywgJ2MrKycsICdjYycsICdjb20nLCAnY29uZicsICdjeHgnLCAnZGVmJywgJ2YnLCAnZjkwJywgJ2ZvcicsICdnJywgJ2hoJywgJ2lkYycsICdqYXYnLCAnamF2YScsICdsaXN0JywgJ2xvZycsICdsc3QnLCAnbScsICdtYXInLCAncGwnLCAnc2RtbCcsICd0ZXh0J10sXG4gICAgICAgICd0ZXh0L3BsYWluLWJhcyc6ICdwYXInLFxuICAgICAgICAndGV4dC9wcnMubGluZXMudGFnJzogJ2RzYycsXG4gICAgICAgICd0ZXh0L3JpY2h0ZXh0JzogWydydHgnLCAncnQnLCAncnRmJ10sXG4gICAgICAgICd0ZXh0L3NjcmlwbGV0JzogJ3dzYycsXG4gICAgICAgICd0ZXh0L3NjcmlwdGxldCc6ICdzY3QnLFxuICAgICAgICAndGV4dC9zZ21sJzogWydzZ20nLCAnc2dtbCddLFxuICAgICAgICAndGV4dC90YWItc2VwYXJhdGVkLXZhbHVlcyc6ICd0c3YnLFxuICAgICAgICAndGV4dC90cm9mZic6ICd0JyxcbiAgICAgICAgJ3RleHQvdHVydGxlJzogJ3R0bCcsXG4gICAgICAgICd0ZXh0L3VyaS1saXN0JzogWyd1bmknLCAndW5pcycsICd1cmknLCAndXJpcyddLFxuICAgICAgICAndGV4dC92bmQuYWJjJzogJ2FiYycsXG4gICAgICAgICd0ZXh0L3ZuZC5jdXJsJzogJ2N1cmwnLFxuICAgICAgICAndGV4dC92bmQuY3VybC5kY3VybCc6ICdkY3VybCcsXG4gICAgICAgICd0ZXh0L3ZuZC5jdXJsLm1jdXJsJzogJ21jdXJsJyxcbiAgICAgICAgJ3RleHQvdm5kLmN1cmwuc2N1cmwnOiAnc2N1cmwnLFxuICAgICAgICAndGV4dC92bmQuZmx5JzogJ2ZseScsXG4gICAgICAgICd0ZXh0L3ZuZC5mbWkuZmxleHN0b3InOiAnZmx4JyxcbiAgICAgICAgJ3RleHQvdm5kLmdyYXBodml6JzogJ2d2JyxcbiAgICAgICAgJ3RleHQvdm5kLmluM2QuM2RtbCc6ICczZG1sJyxcbiAgICAgICAgJ3RleHQvdm5kLmluM2Quc3BvdCc6ICdzcG90JyxcbiAgICAgICAgJ3RleHQvdm5kLnJuLXJlYWx0ZXh0JzogJ3J0JyxcbiAgICAgICAgJ3RleHQvdm5kLnN1bi5qMm1lLmFwcC1kZXNjcmlwdG9yJzogJ2phZCcsXG4gICAgICAgICd0ZXh0L3ZuZC53YXAud21sJzogJ3dtbCcsXG4gICAgICAgICd0ZXh0L3ZuZC53YXAud21sc2NyaXB0JzogJ3dtbHMnLFxuICAgICAgICAndGV4dC93ZWJ2aWV3aHRtbCc6ICdodHQnLFxuICAgICAgICAndGV4dC94LWFzbSc6IFsnYXNtJywgJ3MnXSxcbiAgICAgICAgJ3RleHQveC1hdWRpb3NvZnQtaW50cmEnOiAnYWlwJyxcbiAgICAgICAgJ3RleHQveC1jJzogWydjJywgJ2NjJywgJ2NwcCddLFxuICAgICAgICAndGV4dC94LWNvbXBvbmVudCc6ICdodGMnLFxuICAgICAgICAndGV4dC94LWZvcnRyYW4nOiBbJ2ZvcicsICdmJywgJ2Y3NycsICdmOTAnXSxcbiAgICAgICAgJ3RleHQveC1oJzogWydoJywgJ2hoJ10sXG4gICAgICAgICd0ZXh0L3gtamF2YS1zb3VyY2UnOiBbJ2phdmEnLCAnamF2J10sXG4gICAgICAgICd0ZXh0L3gtamF2YS1zb3VyY2UsamF2YSc6ICdqYXZhJyxcbiAgICAgICAgJ3RleHQveC1sYS1hc2YnOiAnbHN4JyxcbiAgICAgICAgJ3RleHQveC1tJzogJ20nLFxuICAgICAgICAndGV4dC94LXBhc2NhbCc6ICdwJyxcbiAgICAgICAgJ3RleHQveC1zY3JpcHQnOiAnaGxiJyxcbiAgICAgICAgJ3RleHQveC1zY3JpcHQuY3NoJzogJ2NzaCcsXG4gICAgICAgICd0ZXh0L3gtc2NyaXB0LmVsaXNwJzogJ2VsJyxcbiAgICAgICAgJ3RleHQveC1zY3JpcHQuZ3VpbGUnOiAnc2NtJyxcbiAgICAgICAgJ3RleHQveC1zY3JpcHQua3NoJzogJ2tzaCcsXG4gICAgICAgICd0ZXh0L3gtc2NyaXB0Lmxpc3AnOiAnbHNwJyxcbiAgICAgICAgJ3RleHQveC1zY3JpcHQucGVybCc6ICdwbCcsXG4gICAgICAgICd0ZXh0L3gtc2NyaXB0LnBlcmwtbW9kdWxlJzogJ3BtJyxcbiAgICAgICAgJ3RleHQveC1zY3JpcHQucGh5dG9uJzogJ3B5JyxcbiAgICAgICAgJ3RleHQveC1zY3JpcHQucmV4eCc6ICdyZXh4JyxcbiAgICAgICAgJ3RleHQveC1zY3JpcHQuc2NoZW1lJzogJ3NjbScsXG4gICAgICAgICd0ZXh0L3gtc2NyaXB0LnNoJzogJ3NoJyxcbiAgICAgICAgJ3RleHQveC1zY3JpcHQudGNsJzogJ3RjbCcsXG4gICAgICAgICd0ZXh0L3gtc2NyaXB0LnRjc2gnOiAndGNzaCcsXG4gICAgICAgICd0ZXh0L3gtc2NyaXB0LnpzaCc6ICd6c2gnLFxuICAgICAgICAndGV4dC94LXNlcnZlci1wYXJzZWQtaHRtbCc6IFsnc2h0bWwnLCAnc3NpJ10sXG4gICAgICAgICd0ZXh0L3gtc2V0ZXh0JzogJ2V0eCcsXG4gICAgICAgICd0ZXh0L3gtc2dtbCc6IFsnc2dtJywgJ3NnbWwnXSxcbiAgICAgICAgJ3RleHQveC1zcGVlY2gnOiBbJ3NwYycsICd0YWxrJ10sXG4gICAgICAgICd0ZXh0L3gtdWlsJzogJ3VpbCcsXG4gICAgICAgICd0ZXh0L3gtdXVlbmNvZGUnOiBbJ3V1JywgJ3V1ZSddLFxuICAgICAgICAndGV4dC94LXZjYWxlbmRhcic6ICd2Y3MnLFxuICAgICAgICAndGV4dC94LXZjYXJkJzogJ3ZjZicsXG4gICAgICAgICd0ZXh0L3htbCc6ICd4bWwnLFxuICAgICAgICAndmlkZW8vM2dwcCc6ICczZ3AnLFxuICAgICAgICAndmlkZW8vM2dwcDInOiAnM2cyJyxcbiAgICAgICAgJ3ZpZGVvL2FuaW1hZmxleCc6ICdhZmwnLFxuICAgICAgICAndmlkZW8vYXZpJzogJ2F2aScsXG4gICAgICAgICd2aWRlby9hdnMtdmlkZW8nOiAnYXZzJyxcbiAgICAgICAgJ3ZpZGVvL2RsJzogJ2RsJyxcbiAgICAgICAgJ3ZpZGVvL2ZsaSc6ICdmbGknLFxuICAgICAgICAndmlkZW8vZ2wnOiAnZ2wnLFxuICAgICAgICAndmlkZW8vaDI2MSc6ICdoMjYxJyxcbiAgICAgICAgJ3ZpZGVvL2gyNjMnOiAnaDI2MycsXG4gICAgICAgICd2aWRlby9oMjY0JzogJ2gyNjQnLFxuICAgICAgICAndmlkZW8vanBlZyc6ICdqcGd2JyxcbiAgICAgICAgJ3ZpZGVvL2pwbSc6ICdqcG0nLFxuICAgICAgICAndmlkZW8vbWoyJzogJ21qMicsXG4gICAgICAgICd2aWRlby9tcDQnOiAnbXA0JyxcbiAgICAgICAgJ3ZpZGVvL21wZWcnOiBbJ21wZWcnLCAnbXAyJywgJ21wYScsICdtcGUnLCAnbXBnJywgJ21wdjInLCAnbTF2JywgJ20ydicsICdtcDMnXSxcbiAgICAgICAgJ3ZpZGVvL21zdmlkZW8nOiAnYXZpJyxcbiAgICAgICAgJ3ZpZGVvL29nZyc6ICdvZ3YnLFxuICAgICAgICAndmlkZW8vcXVpY2t0aW1lJzogWydtb3YnLCAncXQnLCAnbW9vdiddLFxuICAgICAgICAndmlkZW8vdmRvJzogJ3ZkbycsXG4gICAgICAgICd2aWRlby92aXZvJzogWyd2aXYnLCAndml2byddLFxuICAgICAgICAndmlkZW8vdm5kLmRlY2UuaGQnOiAndXZoJyxcbiAgICAgICAgJ3ZpZGVvL3ZuZC5kZWNlLm1vYmlsZSc6ICd1dm0nLFxuICAgICAgICAndmlkZW8vdm5kLmRlY2UucGQnOiAndXZwJyxcbiAgICAgICAgJ3ZpZGVvL3ZuZC5kZWNlLnNkJzogJ3V2cycsXG4gICAgICAgICd2aWRlby92bmQuZGVjZS52aWRlbyc6ICd1dnYnLFxuICAgICAgICAndmlkZW8vdm5kLmZ2dCc6ICdmdnQnLFxuICAgICAgICAndmlkZW8vdm5kLm1wZWd1cmwnOiAnbXh1JyxcbiAgICAgICAgJ3ZpZGVvL3ZuZC5tcy1wbGF5cmVhZHkubWVkaWEucHl2JzogJ3B5dicsXG4gICAgICAgICd2aWRlby92bmQucm4tcmVhbHZpZGVvJzogJ3J2JyxcbiAgICAgICAgJ3ZpZGVvL3ZuZC51dnZ1Lm1wNCc6ICd1dnUnLFxuICAgICAgICAndmlkZW8vdm5kLnZpdm8nOiBbJ3ZpdicsICd2aXZvJ10sXG4gICAgICAgICd2aWRlby92b3NhaWMnOiAndm9zJyxcbiAgICAgICAgJ3ZpZGVvL3dlYm0nOiAnd2VibScsXG4gICAgICAgICd2aWRlby94LWFtdC1kZW1vcnVuJzogJ3hkcicsXG4gICAgICAgICd2aWRlby94LWFtdC1zaG93cnVuJzogJ3hzcicsXG4gICAgICAgICd2aWRlby94LWF0b21pYzNkLWZlYXR1cmUnOiAnZm1mJyxcbiAgICAgICAgJ3ZpZGVvL3gtZGwnOiAnZGwnLFxuICAgICAgICAndmlkZW8veC1kdic6IFsnZGlmJywgJ2R2J10sXG4gICAgICAgICd2aWRlby94LWY0dic6ICdmNHYnLFxuICAgICAgICAndmlkZW8veC1mbGknOiAnZmxpJyxcbiAgICAgICAgJ3ZpZGVvL3gtZmx2JzogJ2ZsdicsXG4gICAgICAgICd2aWRlby94LWdsJzogJ2dsJyxcbiAgICAgICAgJ3ZpZGVvL3gtaXN2aWRlbyc6ICdpc3UnLFxuICAgICAgICAndmlkZW8veC1sYS1hc2YnOiBbJ2xzZicsICdsc3gnXSxcbiAgICAgICAgJ3ZpZGVvL3gtbTR2JzogJ200dicsXG4gICAgICAgICd2aWRlby94LW1vdGlvbi1qcGVnJzogJ21qcGcnLFxuICAgICAgICAndmlkZW8veC1tcGVnJzogWydtcDMnLCAnbXAyJ10sXG4gICAgICAgICd2aWRlby94LW1wZXEyYSc6ICdtcDInLFxuICAgICAgICAndmlkZW8veC1tcy1hc2YnOiBbJ2FzZicsICdhc3InLCAnYXN4J10sXG4gICAgICAgICd2aWRlby94LW1zLWFzZi1wbHVnaW4nOiAnYXN4JyxcbiAgICAgICAgJ3ZpZGVvL3gtbXMtd20nOiAnd20nLFxuICAgICAgICAndmlkZW8veC1tcy13bXYnOiAnd212JyxcbiAgICAgICAgJ3ZpZGVvL3gtbXMtd214JzogJ3dteCcsXG4gICAgICAgICd2aWRlby94LW1zLXd2eCc6ICd3dngnLFxuICAgICAgICAndmlkZW8veC1tc3ZpZGVvJzogJ2F2aScsXG4gICAgICAgICd2aWRlby94LXF0Yyc6ICdxdGMnLFxuICAgICAgICAndmlkZW8veC1zY20nOiAnc2NtJyxcbiAgICAgICAgJ3ZpZGVvL3gtc2dpLW1vdmllJzogWydtb3ZpZScsICdtdiddLFxuICAgICAgICAnd2luZG93cy9tZXRhZmlsZSc6ICd3bWYnLFxuICAgICAgICAnd3d3L21pbWUnOiAnbWltZScsXG4gICAgICAgICd4LWNvbmZlcmVuY2UveC1jb29sdGFsayc6ICdpY2UnLFxuICAgICAgICAneC1tdXNpYy94LW1pZGknOiBbJ21pZCcsICdtaWRpJ10sXG4gICAgICAgICd4LXdvcmxkL3gtM2RtZic6IFsnM2RtJywgJzNkbWYnLCAncWQzJywgJ3FkM2QnXSxcbiAgICAgICAgJ3gtd29ybGQveC1zdnInOiAnc3ZyJyxcbiAgICAgICAgJ3gtd29ybGQveC12cm1sJzogWydmbHInLCAndnJtbCcsICd3cmwnLCAnd3J6JywgJ3hhZicsICd4b2YnXSxcbiAgICAgICAgJ3gtd29ybGQveC12cnQnOiAndnJ0JyxcbiAgICAgICAgJ3hnbC9kcmF3aW5nJzogJ3hneicsXG4gICAgICAgICd4Z2wvbW92aWUnOiAneG16J1xuICAgIH0sXG5cbiAgICBleHRlbnNpb25zOiB7XG4gICAgICAgICcqJzogJ2FwcGxpY2F0aW9uL29jdGV0LXN0cmVhbScsXG4gICAgICAgICcxMjMnOiAnYXBwbGljYXRpb24vdm5kLmxvdHVzLTEtMi0zJyxcbiAgICAgICAgJzMyMyc6ICd0ZXh0L2gzMjMnLFxuICAgICAgICAnM2RtJzogJ3gtd29ybGQveC0zZG1mJyxcbiAgICAgICAgJzNkbWYnOiAneC13b3JsZC94LTNkbWYnLFxuICAgICAgICAnM2RtbCc6ICd0ZXh0L3ZuZC5pbjNkLjNkbWwnLFxuICAgICAgICAnM2cyJzogJ3ZpZGVvLzNncHAyJyxcbiAgICAgICAgJzNncCc6ICd2aWRlby8zZ3BwJyxcbiAgICAgICAgJzd6JzogJ2FwcGxpY2F0aW9uL3gtN3otY29tcHJlc3NlZCcsXG4gICAgICAgICdhJzogJ2FwcGxpY2F0aW9uL29jdGV0LXN0cmVhbScsXG4gICAgICAgICdhYWInOiAnYXBwbGljYXRpb24veC1hdXRob3J3YXJlLWJpbicsXG4gICAgICAgICdhYWMnOiAnYXVkaW8veC1hYWMnLFxuICAgICAgICAnYWFtJzogJ2FwcGxpY2F0aW9uL3gtYXV0aG9yd2FyZS1tYXAnLFxuICAgICAgICAnYWFzJzogJ2FwcGxpY2F0aW9uL3gtYXV0aG9yd2FyZS1zZWcnLFxuICAgICAgICAnYWJjJzogJ3RleHQvdm5kLmFiYycsXG4gICAgICAgICdhYncnOiAnYXBwbGljYXRpb24veC1hYml3b3JkJyxcbiAgICAgICAgJ2FjJzogJ2FwcGxpY2F0aW9uL3BraXgtYXR0ci1jZXJ0JyxcbiAgICAgICAgJ2FjYyc6ICdhcHBsaWNhdGlvbi92bmQuYW1lcmljYW5keW5hbWljcy5hY2MnLFxuICAgICAgICAnYWNlJzogJ2FwcGxpY2F0aW9uL3gtYWNlLWNvbXByZXNzZWQnLFxuICAgICAgICAnYWNnaSc6ICd0ZXh0L2h0bWwnLFxuICAgICAgICAnYWN1JzogJ2FwcGxpY2F0aW9uL3ZuZC5hY3Vjb2JvbCcsXG4gICAgICAgICdhY3gnOiAnYXBwbGljYXRpb24vaW50ZXJuZXQtcHJvcGVydHktc3RyZWFtJyxcbiAgICAgICAgJ2FkcCc6ICdhdWRpby9hZHBjbScsXG4gICAgICAgICdhZXAnOiAnYXBwbGljYXRpb24vdm5kLmF1ZGlvZ3JhcGgnLFxuICAgICAgICAnYWZsJzogJ3ZpZGVvL2FuaW1hZmxleCcsXG4gICAgICAgICdhZnAnOiAnYXBwbGljYXRpb24vdm5kLmlibS5tb2RjYXAnLFxuICAgICAgICAnYWhlYWQnOiAnYXBwbGljYXRpb24vdm5kLmFoZWFkLnNwYWNlJyxcbiAgICAgICAgJ2FpJzogJ2FwcGxpY2F0aW9uL3Bvc3RzY3JpcHQnLFxuICAgICAgICAnYWlmJzogWydhdWRpby9haWZmJywgJ2F1ZGlvL3gtYWlmZiddLFxuICAgICAgICAnYWlmYyc6IFsnYXVkaW8vYWlmZicsICdhdWRpby94LWFpZmYnXSxcbiAgICAgICAgJ2FpZmYnOiBbJ2F1ZGlvL2FpZmYnLCAnYXVkaW8veC1haWZmJ10sXG4gICAgICAgICdhaW0nOiAnYXBwbGljYXRpb24veC1haW0nLFxuICAgICAgICAnYWlwJzogJ3RleHQveC1hdWRpb3NvZnQtaW50cmEnLFxuICAgICAgICAnYWlyJzogJ2FwcGxpY2F0aW9uL3ZuZC5hZG9iZS5haXItYXBwbGljYXRpb24taW5zdGFsbGVyLXBhY2thZ2UremlwJyxcbiAgICAgICAgJ2FpdCc6ICdhcHBsaWNhdGlvbi92bmQuZHZiLmFpdCcsXG4gICAgICAgICdhbWknOiAnYXBwbGljYXRpb24vdm5kLmFtaWdhLmFtaScsXG4gICAgICAgICdhbmknOiAnYXBwbGljYXRpb24veC1uYXZpLWFuaW1hdGlvbicsXG4gICAgICAgICdhb3MnOiAnYXBwbGljYXRpb24veC1ub2tpYS05MDAwLWNvbW11bmljYXRvci1hZGQtb24tc29mdHdhcmUnLFxuICAgICAgICAnYXBrJzogJ2FwcGxpY2F0aW9uL3ZuZC5hbmRyb2lkLnBhY2thZ2UtYXJjaGl2ZScsXG4gICAgICAgICdhcHBsaWNhdGlvbic6ICdhcHBsaWNhdGlvbi94LW1zLWFwcGxpY2F0aW9uJyxcbiAgICAgICAgJ2Fwcic6ICdhcHBsaWNhdGlvbi92bmQubG90dXMtYXBwcm9hY2gnLFxuICAgICAgICAnYXBzJzogJ2FwcGxpY2F0aW9uL21pbWUnLFxuICAgICAgICAnYXJjJzogJ2FwcGxpY2F0aW9uL29jdGV0LXN0cmVhbScsXG4gICAgICAgICdhcmonOiBbJ2FwcGxpY2F0aW9uL2FyaicsICdhcHBsaWNhdGlvbi9vY3RldC1zdHJlYW0nXSxcbiAgICAgICAgJ2FydCc6ICdpbWFnZS94LWpnJyxcbiAgICAgICAgJ2FzZic6ICd2aWRlby94LW1zLWFzZicsXG4gICAgICAgICdhc20nOiAndGV4dC94LWFzbScsXG4gICAgICAgICdhc28nOiAnYXBwbGljYXRpb24vdm5kLmFjY3BhYy5zaW1wbHkuYXNvJyxcbiAgICAgICAgJ2FzcCc6ICd0ZXh0L2FzcCcsXG4gICAgICAgICdhc3InOiAndmlkZW8veC1tcy1hc2YnLFxuICAgICAgICAnYXN4JzogWyd2aWRlby94LW1zLWFzZicsICdhcHBsaWNhdGlvbi94LW1wbGF5ZXIyJywgJ3ZpZGVvL3gtbXMtYXNmLXBsdWdpbiddLFxuICAgICAgICAnYXRjJzogJ2FwcGxpY2F0aW9uL3ZuZC5hY3Vjb3JwJyxcbiAgICAgICAgJ2F0b21jYXQnOiAnYXBwbGljYXRpb24vYXRvbWNhdCt4bWwnLFxuICAgICAgICAnYXRvbXN2Yyc6ICdhcHBsaWNhdGlvbi9hdG9tc3ZjK3htbCcsXG4gICAgICAgICdhdHgnOiAnYXBwbGljYXRpb24vdm5kLmFudGl4LmdhbWUtY29tcG9uZW50JyxcbiAgICAgICAgJ2F1JzogWydhdWRpby9iYXNpYycsICdhdWRpby94LWF1J10sXG4gICAgICAgICdhdmknOiBbJ3ZpZGVvL2F2aScsICd2aWRlby9tc3ZpZGVvJywgJ2FwcGxpY2F0aW9uL3gtdHJvZmYtbXN2aWRlbycsICd2aWRlby94LW1zdmlkZW8nXSxcbiAgICAgICAgJ2F2cyc6ICd2aWRlby9hdnMtdmlkZW8nLFxuICAgICAgICAnYXcnOiAnYXBwbGljYXRpb24vYXBwbGl4d2FyZScsXG4gICAgICAgICdheHMnOiAnYXBwbGljYXRpb24vb2xlc2NyaXB0JyxcbiAgICAgICAgJ2F6Zic6ICdhcHBsaWNhdGlvbi92bmQuYWlyemlwLmZpbGVzZWN1cmUuYXpmJyxcbiAgICAgICAgJ2F6cyc6ICdhcHBsaWNhdGlvbi92bmQuYWlyemlwLmZpbGVzZWN1cmUuYXpzJyxcbiAgICAgICAgJ2F6dyc6ICdhcHBsaWNhdGlvbi92bmQuYW1hem9uLmVib29rJyxcbiAgICAgICAgJ2Jhcyc6ICd0ZXh0L3BsYWluJyxcbiAgICAgICAgJ2JjcGlvJzogJ2FwcGxpY2F0aW9uL3gtYmNwaW8nLFxuICAgICAgICAnYmRmJzogJ2FwcGxpY2F0aW9uL3gtZm9udC1iZGYnLFxuICAgICAgICAnYmRtJzogJ2FwcGxpY2F0aW9uL3ZuZC5zeW5jbWwuZG0rd2J4bWwnLFxuICAgICAgICAnYmVkJzogJ2FwcGxpY2F0aW9uL3ZuZC5yZWFsdm5jLmJlZCcsXG4gICAgICAgICdiaDInOiAnYXBwbGljYXRpb24vdm5kLmZ1aml0c3Uub2FzeXNwcnMnLFxuICAgICAgICAnYmluJzogWydhcHBsaWNhdGlvbi9vY3RldC1zdHJlYW0nLCAnYXBwbGljYXRpb24vbWFjLWJpbmFyeScsICdhcHBsaWNhdGlvbi9tYWNiaW5hcnknLCAnYXBwbGljYXRpb24veC1tYWNiaW5hcnknLCAnYXBwbGljYXRpb24veC1iaW5hcnknXSxcbiAgICAgICAgJ2JtJzogJ2ltYWdlL2JtcCcsXG4gICAgICAgICdibWknOiAnYXBwbGljYXRpb24vdm5kLmJtaScsXG4gICAgICAgICdibXAnOiBbJ2ltYWdlL2JtcCcsICdpbWFnZS94LXdpbmRvd3MtYm1wJ10sXG4gICAgICAgICdib28nOiAnYXBwbGljYXRpb24vYm9vaycsXG4gICAgICAgICdib29rJzogJ2FwcGxpY2F0aW9uL2Jvb2snLFxuICAgICAgICAnYm94JzogJ2FwcGxpY2F0aW9uL3ZuZC5wcmV2aWV3c3lzdGVtcy5ib3gnLFxuICAgICAgICAnYm96JzogJ2FwcGxpY2F0aW9uL3gtYnppcDInLFxuICAgICAgICAnYnNoJzogJ2FwcGxpY2F0aW9uL3gtYnNoJyxcbiAgICAgICAgJ2J0aWYnOiAnaW1hZ2UvcHJzLmJ0aWYnLFxuICAgICAgICAnYnonOiAnYXBwbGljYXRpb24veC1iemlwJyxcbiAgICAgICAgJ2J6Mic6ICdhcHBsaWNhdGlvbi94LWJ6aXAyJyxcbiAgICAgICAgJ2MnOiBbJ3RleHQvcGxhaW4nLCAndGV4dC94LWMnXSxcbiAgICAgICAgJ2MrKyc6ICd0ZXh0L3BsYWluJyxcbiAgICAgICAgJ2MxMWFtYyc6ICdhcHBsaWNhdGlvbi92bmQuY2x1ZXRydXN0LmNhcnRvbW9iaWxlLWNvbmZpZycsXG4gICAgICAgICdjMTFhbXonOiAnYXBwbGljYXRpb24vdm5kLmNsdWV0cnVzdC5jYXJ0b21vYmlsZS1jb25maWctcGtnJyxcbiAgICAgICAgJ2M0Zyc6ICdhcHBsaWNhdGlvbi92bmQuY2xvbmsuYzRncm91cCcsXG4gICAgICAgICdjYWInOiAnYXBwbGljYXRpb24vdm5kLm1zLWNhYi1jb21wcmVzc2VkJyxcbiAgICAgICAgJ2Nhcic6ICdhcHBsaWNhdGlvbi92bmQuY3VybC5jYXInLFxuICAgICAgICAnY2F0JzogWydhcHBsaWNhdGlvbi92bmQubXMtcGtpc2VjY2F0JywgJ2FwcGxpY2F0aW9uL3ZuZC5tcy1wa2kuc2VjY2F0J10sXG4gICAgICAgICdjYyc6IFsndGV4dC9wbGFpbicsICd0ZXh0L3gtYyddLFxuICAgICAgICAnY2NhZCc6ICdhcHBsaWNhdGlvbi9jbGFyaXNjYWQnLFxuICAgICAgICAnY2NvJzogJ2FwcGxpY2F0aW9uL3gtY29jb2EnLFxuICAgICAgICAnY2N4bWwnOiAnYXBwbGljYXRpb24vY2N4bWwreG1sLCcsXG4gICAgICAgICdjZGJjbXNnJzogJ2FwcGxpY2F0aW9uL3ZuZC5jb250YWN0LmNtc2cnLFxuICAgICAgICAnY2RmJzogWydhcHBsaWNhdGlvbi9jZGYnLCAnYXBwbGljYXRpb24veC1jZGYnLCAnYXBwbGljYXRpb24veC1uZXRjZGYnXSxcbiAgICAgICAgJ2Nka2V5JzogJ2FwcGxpY2F0aW9uL3ZuZC5tZWRpYXN0YXRpb24uY2RrZXknLFxuICAgICAgICAnY2RtaWEnOiAnYXBwbGljYXRpb24vY2RtaS1jYXBhYmlsaXR5JyxcbiAgICAgICAgJ2NkbWljJzogJ2FwcGxpY2F0aW9uL2NkbWktY29udGFpbmVyJyxcbiAgICAgICAgJ2NkbWlkJzogJ2FwcGxpY2F0aW9uL2NkbWktZG9tYWluJyxcbiAgICAgICAgJ2NkbWlvJzogJ2FwcGxpY2F0aW9uL2NkbWktb2JqZWN0JyxcbiAgICAgICAgJ2NkbWlxJzogJ2FwcGxpY2F0aW9uL2NkbWktcXVldWUnLFxuICAgICAgICAnY2R4JzogJ2NoZW1pY2FsL3gtY2R4JyxcbiAgICAgICAgJ2NkeG1sJzogJ2FwcGxpY2F0aW9uL3ZuZC5jaGVtZHJhdyt4bWwnLFxuICAgICAgICAnY2R5JzogJ2FwcGxpY2F0aW9uL3ZuZC5jaW5kZXJlbGxhJyxcbiAgICAgICAgJ2Nlcic6IFsnYXBwbGljYXRpb24vcGtpeC1jZXJ0JywgJ2FwcGxpY2F0aW9uL3gteDUwOS1jYS1jZXJ0J10sXG4gICAgICAgICdjZ20nOiAnaW1hZ2UvY2dtJyxcbiAgICAgICAgJ2NoYSc6ICdhcHBsaWNhdGlvbi94LWNoYXQnLFxuICAgICAgICAnY2hhdCc6ICdhcHBsaWNhdGlvbi94LWNoYXQnLFxuICAgICAgICAnY2htJzogJ2FwcGxpY2F0aW9uL3ZuZC5tcy1odG1saGVscCcsXG4gICAgICAgICdjaHJ0JzogJ2FwcGxpY2F0aW9uL3ZuZC5rZGUua2NoYXJ0JyxcbiAgICAgICAgJ2NpZic6ICdjaGVtaWNhbC94LWNpZicsXG4gICAgICAgICdjaWknOiAnYXBwbGljYXRpb24vdm5kLmFuc2VyLXdlYi1jZXJ0aWZpY2F0ZS1pc3N1ZS1pbml0aWF0aW9uJyxcbiAgICAgICAgJ2NpbCc6ICdhcHBsaWNhdGlvbi92bmQubXMtYXJ0Z2FscnknLFxuICAgICAgICAnY2xhJzogJ2FwcGxpY2F0aW9uL3ZuZC5jbGF5bW9yZScsXG4gICAgICAgICdjbGFzcyc6IFsnYXBwbGljYXRpb24vb2N0ZXQtc3RyZWFtJywgJ2FwcGxpY2F0aW9uL2phdmEnLCAnYXBwbGljYXRpb24vamF2YS1ieXRlLWNvZGUnLCAnYXBwbGljYXRpb24vamF2YS12bScsICdhcHBsaWNhdGlvbi94LWphdmEtY2xhc3MnXSxcbiAgICAgICAgJ2Nsa2snOiAnYXBwbGljYXRpb24vdm5kLmNyaWNrLmNsaWNrZXIua2V5Ym9hcmQnLFxuICAgICAgICAnY2xrcCc6ICdhcHBsaWNhdGlvbi92bmQuY3JpY2suY2xpY2tlci5wYWxldHRlJyxcbiAgICAgICAgJ2Nsa3QnOiAnYXBwbGljYXRpb24vdm5kLmNyaWNrLmNsaWNrZXIudGVtcGxhdGUnLFxuICAgICAgICAnY2xrdyc6ICdhcHBsaWNhdGlvbi92bmQuY3JpY2suY2xpY2tlci53b3JkYmFuaycsXG4gICAgICAgICdjbGt4JzogJ2FwcGxpY2F0aW9uL3ZuZC5jcmljay5jbGlja2VyJyxcbiAgICAgICAgJ2NscCc6ICdhcHBsaWNhdGlvbi94LW1zY2xpcCcsXG4gICAgICAgICdjbWMnOiAnYXBwbGljYXRpb24vdm5kLmNvc21vY2FsbGVyJyxcbiAgICAgICAgJ2NtZGYnOiAnY2hlbWljYWwveC1jbWRmJyxcbiAgICAgICAgJ2NtbCc6ICdjaGVtaWNhbC94LWNtbCcsXG4gICAgICAgICdjbXAnOiAnYXBwbGljYXRpb24vdm5kLnllbGxvd3JpdmVyLWN1c3RvbS1tZW51JyxcbiAgICAgICAgJ2NteCc6ICdpbWFnZS94LWNteCcsXG4gICAgICAgICdjb2QnOiBbJ2ltYWdlL2Npcy1jb2QnLCAnYXBwbGljYXRpb24vdm5kLnJpbS5jb2QnXSxcbiAgICAgICAgJ2NvbSc6IFsnYXBwbGljYXRpb24vb2N0ZXQtc3RyZWFtJywgJ3RleHQvcGxhaW4nXSxcbiAgICAgICAgJ2NvbmYnOiAndGV4dC9wbGFpbicsXG4gICAgICAgICdjcGlvJzogJ2FwcGxpY2F0aW9uL3gtY3BpbycsXG4gICAgICAgICdjcHAnOiAndGV4dC94LWMnLFxuICAgICAgICAnY3B0JzogWydhcHBsaWNhdGlvbi9tYWMtY29tcGFjdHBybycsICdhcHBsaWNhdGlvbi94LWNvbXBhY3Rwcm8nLCAnYXBwbGljYXRpb24veC1jcHQnXSxcbiAgICAgICAgJ2NyZCc6ICdhcHBsaWNhdGlvbi94LW1zY2FyZGZpbGUnLFxuICAgICAgICAnY3JsJzogWydhcHBsaWNhdGlvbi9wa2l4LWNybCcsICdhcHBsaWNhdGlvbi9wa2NzLWNybCddLFxuICAgICAgICAnY3J0JzogWydhcHBsaWNhdGlvbi9wa2l4LWNlcnQnLCAnYXBwbGljYXRpb24veC14NTA5LXVzZXItY2VydCcsICdhcHBsaWNhdGlvbi94LXg1MDktY2EtY2VydCddLFxuICAgICAgICAnY3J5cHRvbm90ZSc6ICdhcHBsaWNhdGlvbi92bmQucmlnLmNyeXB0b25vdGUnLFxuICAgICAgICAnY3NoJzogWyd0ZXh0L3gtc2NyaXB0LmNzaCcsICdhcHBsaWNhdGlvbi94LWNzaCddLFxuICAgICAgICAnY3NtbCc6ICdjaGVtaWNhbC94LWNzbWwnLFxuICAgICAgICAnY3NwJzogJ2FwcGxpY2F0aW9uL3ZuZC5jb21tb25zcGFjZScsXG4gICAgICAgICdjc3MnOiBbJ3RleHQvY3NzJywgJ2FwcGxpY2F0aW9uL3gtcG9pbnRwbHVzJ10sXG4gICAgICAgICdjc3YnOiAndGV4dC9jc3YnLFxuICAgICAgICAnY3UnOiAnYXBwbGljYXRpb24vY3Utc2VlbWUnLFxuICAgICAgICAnY3VybCc6ICd0ZXh0L3ZuZC5jdXJsJyxcbiAgICAgICAgJ2N3dyc6ICdhcHBsaWNhdGlvbi9wcnMuY3d3JyxcbiAgICAgICAgJ2N4eCc6ICd0ZXh0L3BsYWluJyxcbiAgICAgICAgJ2RhZSc6ICdtb2RlbC92bmQuY29sbGFkYSt4bWwnLFxuICAgICAgICAnZGFmJzogJ2FwcGxpY2F0aW9uL3ZuZC5tb2JpdXMuZGFmJyxcbiAgICAgICAgJ2Rhdm1vdW50JzogJ2FwcGxpY2F0aW9uL2Rhdm1vdW50K3htbCcsXG4gICAgICAgICdkY3InOiAnYXBwbGljYXRpb24veC1kaXJlY3RvcicsXG4gICAgICAgICdkY3VybCc6ICd0ZXh0L3ZuZC5jdXJsLmRjdXJsJyxcbiAgICAgICAgJ2RkMic6ICdhcHBsaWNhdGlvbi92bmQub21hLmRkMit4bWwnLFxuICAgICAgICAnZGRkJzogJ2FwcGxpY2F0aW9uL3ZuZC5mdWppeGVyb3guZGRkJyxcbiAgICAgICAgJ2RlYic6ICdhcHBsaWNhdGlvbi94LWRlYmlhbi1wYWNrYWdlJyxcbiAgICAgICAgJ2RlZXB2JzogJ2FwcGxpY2F0aW9uL3gtZGVlcHYnLFxuICAgICAgICAnZGVmJzogJ3RleHQvcGxhaW4nLFxuICAgICAgICAnZGVyJzogJ2FwcGxpY2F0aW9uL3gteDUwOS1jYS1jZXJ0JyxcbiAgICAgICAgJ2RmYWMnOiAnYXBwbGljYXRpb24vdm5kLmRyZWFtZmFjdG9yeScsXG4gICAgICAgICdkaWYnOiAndmlkZW8veC1kdicsXG4gICAgICAgICdkaXInOiAnYXBwbGljYXRpb24veC1kaXJlY3RvcicsXG4gICAgICAgICdkaXMnOiAnYXBwbGljYXRpb24vdm5kLm1vYml1cy5kaXMnLFxuICAgICAgICAnZGp2dSc6ICdpbWFnZS92bmQuZGp2dScsXG4gICAgICAgICdkbCc6IFsndmlkZW8vZGwnLCAndmlkZW8veC1kbCddLFxuICAgICAgICAnZGxsJzogJ2FwcGxpY2F0aW9uL3gtbXNkb3dubG9hZCcsXG4gICAgICAgICdkbXMnOiAnYXBwbGljYXRpb24vb2N0ZXQtc3RyZWFtJyxcbiAgICAgICAgJ2RuYSc6ICdhcHBsaWNhdGlvbi92bmQuZG5hJyxcbiAgICAgICAgJ2RvYyc6ICdhcHBsaWNhdGlvbi9tc3dvcmQnLFxuICAgICAgICAnZG9jbSc6ICdhcHBsaWNhdGlvbi92bmQubXMtd29yZC5kb2N1bWVudC5tYWNyb2VuYWJsZWQuMTInLFxuICAgICAgICAnZG9jeCc6ICdhcHBsaWNhdGlvbi92bmQub3BlbnhtbGZvcm1hdHMtb2ZmaWNlZG9jdW1lbnQud29yZHByb2Nlc3NpbmdtbC5kb2N1bWVudCcsXG4gICAgICAgICdkb3QnOiAnYXBwbGljYXRpb24vbXN3b3JkJyxcbiAgICAgICAgJ2RvdG0nOiAnYXBwbGljYXRpb24vdm5kLm1zLXdvcmQudGVtcGxhdGUubWFjcm9lbmFibGVkLjEyJyxcbiAgICAgICAgJ2RvdHgnOiAnYXBwbGljYXRpb24vdm5kLm9wZW54bWxmb3JtYXRzLW9mZmljZWRvY3VtZW50LndvcmRwcm9jZXNzaW5nbWwudGVtcGxhdGUnLFxuICAgICAgICAnZHAnOiBbJ2FwcGxpY2F0aW9uL2NvbW1vbmdyb3VuZCcsICdhcHBsaWNhdGlvbi92bmQub3NnaS5kcCddLFxuICAgICAgICAnZHBnJzogJ2FwcGxpY2F0aW9uL3ZuZC5kcGdyYXBoJyxcbiAgICAgICAgJ2RyYSc6ICdhdWRpby92bmQuZHJhJyxcbiAgICAgICAgJ2Rydyc6ICdhcHBsaWNhdGlvbi9kcmFmdGluZycsXG4gICAgICAgICdkc2MnOiAndGV4dC9wcnMubGluZXMudGFnJyxcbiAgICAgICAgJ2Rzc2MnOiAnYXBwbGljYXRpb24vZHNzYytkZXInLFxuICAgICAgICAnZHRiJzogJ2FwcGxpY2F0aW9uL3gtZHRib29rK3htbCcsXG4gICAgICAgICdkdGQnOiAnYXBwbGljYXRpb24veG1sLWR0ZCcsXG4gICAgICAgICdkdHMnOiAnYXVkaW8vdm5kLmR0cycsXG4gICAgICAgICdkdHNoZCc6ICdhdWRpby92bmQuZHRzLmhkJyxcbiAgICAgICAgJ2R1bXAnOiAnYXBwbGljYXRpb24vb2N0ZXQtc3RyZWFtJyxcbiAgICAgICAgJ2R2JzogJ3ZpZGVvL3gtZHYnLFxuICAgICAgICAnZHZpJzogJ2FwcGxpY2F0aW9uL3gtZHZpJyxcbiAgICAgICAgJ2R3Zic6IFsnbW9kZWwvdm5kLmR3ZicsICdkcmF3aW5nL3gtZHdmJ10sXG4gICAgICAgICdkd2cnOiBbJ2FwcGxpY2F0aW9uL2FjYWQnLCAnaW1hZ2Uvdm5kLmR3ZycsICdpbWFnZS94LWR3ZyddLFxuICAgICAgICAnZHhmJzogWydhcHBsaWNhdGlvbi9keGYnLCAnaW1hZ2Uvdm5kLmR3ZycsICdpbWFnZS92bmQuZHhmJywgJ2ltYWdlL3gtZHdnJ10sXG4gICAgICAgICdkeHAnOiAnYXBwbGljYXRpb24vdm5kLnNwb3RmaXJlLmR4cCcsXG4gICAgICAgICdkeHInOiAnYXBwbGljYXRpb24veC1kaXJlY3RvcicsXG4gICAgICAgICdlY2VscDQ4MDAnOiAnYXVkaW8vdm5kLm51ZXJhLmVjZWxwNDgwMCcsXG4gICAgICAgICdlY2VscDc0NzAnOiAnYXVkaW8vdm5kLm51ZXJhLmVjZWxwNzQ3MCcsXG4gICAgICAgICdlY2VscDk2MDAnOiAnYXVkaW8vdm5kLm51ZXJhLmVjZWxwOTYwMCcsXG4gICAgICAgICdlZG0nOiAnYXBwbGljYXRpb24vdm5kLm5vdmFkaWdtLmVkbScsXG4gICAgICAgICdlZHgnOiAnYXBwbGljYXRpb24vdm5kLm5vdmFkaWdtLmVkeCcsXG4gICAgICAgICdlZmlmJzogJ2FwcGxpY2F0aW9uL3ZuZC5waWNzZWwnLFxuICAgICAgICAnZWk2JzogJ2FwcGxpY2F0aW9uL3ZuZC5wZy5vc2FzbGknLFxuICAgICAgICAnZWwnOiAndGV4dC94LXNjcmlwdC5lbGlzcCcsXG4gICAgICAgICdlbGMnOiBbJ2FwcGxpY2F0aW9uL3gtZWxjJywgJ2FwcGxpY2F0aW9uL3gtYnl0ZWNvZGUuZWxpc3AnXSxcbiAgICAgICAgJ2VtbCc6ICdtZXNzYWdlL3JmYzgyMicsXG4gICAgICAgICdlbW1hJzogJ2FwcGxpY2F0aW9uL2VtbWEreG1sJyxcbiAgICAgICAgJ2Vudic6ICdhcHBsaWNhdGlvbi94LWVudm95JyxcbiAgICAgICAgJ2VvbCc6ICdhdWRpby92bmQuZGlnaXRhbC13aW5kcycsXG4gICAgICAgICdlb3QnOiAnYXBwbGljYXRpb24vdm5kLm1zLWZvbnRvYmplY3QnLFxuICAgICAgICAnZXBzJzogJ2FwcGxpY2F0aW9uL3Bvc3RzY3JpcHQnLFxuICAgICAgICAnZXB1Yic6ICdhcHBsaWNhdGlvbi9lcHViK3ppcCcsXG4gICAgICAgICdlcyc6IFsnYXBwbGljYXRpb24vZWNtYXNjcmlwdCcsICdhcHBsaWNhdGlvbi94LWVzcmVoYmVyJ10sXG4gICAgICAgICdlczMnOiAnYXBwbGljYXRpb24vdm5kLmVzemlnbm8zK3htbCcsXG4gICAgICAgICdlc2YnOiAnYXBwbGljYXRpb24vdm5kLmVwc29uLmVzZicsXG4gICAgICAgICdldHgnOiAndGV4dC94LXNldGV4dCcsXG4gICAgICAgICdldnknOiBbJ2FwcGxpY2F0aW9uL2Vudm95JywgJ2FwcGxpY2F0aW9uL3gtZW52b3knXSxcbiAgICAgICAgJ2V4ZSc6IFsnYXBwbGljYXRpb24vb2N0ZXQtc3RyZWFtJywgJ2FwcGxpY2F0aW9uL3gtbXNkb3dubG9hZCddLFxuICAgICAgICAnZXhpJzogJ2FwcGxpY2F0aW9uL2V4aScsXG4gICAgICAgICdleHQnOiAnYXBwbGljYXRpb24vdm5kLm5vdmFkaWdtLmV4dCcsXG4gICAgICAgICdlejInOiAnYXBwbGljYXRpb24vdm5kLmV6cGl4LWFsYnVtJyxcbiAgICAgICAgJ2V6Myc6ICdhcHBsaWNhdGlvbi92bmQuZXpwaXgtcGFja2FnZScsXG4gICAgICAgICdmJzogWyd0ZXh0L3BsYWluJywgJ3RleHQveC1mb3J0cmFuJ10sXG4gICAgICAgICdmNHYnOiAndmlkZW8veC1mNHYnLFxuICAgICAgICAnZjc3JzogJ3RleHQveC1mb3J0cmFuJyxcbiAgICAgICAgJ2Y5MCc6IFsndGV4dC9wbGFpbicsICd0ZXh0L3gtZm9ydHJhbiddLFxuICAgICAgICAnZmJzJzogJ2ltYWdlL3ZuZC5mYXN0Ymlkc2hlZXQnLFxuICAgICAgICAnZmNzJzogJ2FwcGxpY2F0aW9uL3ZuZC5pc2FjLmZjcycsXG4gICAgICAgICdmZGYnOiAnYXBwbGljYXRpb24vdm5kLmZkZicsXG4gICAgICAgICdmZV9sYXVuY2gnOiAnYXBwbGljYXRpb24vdm5kLmRlbm92by5mY3NlbGF5b3V0LWxpbmsnLFxuICAgICAgICAnZmc1JzogJ2FwcGxpY2F0aW9uL3ZuZC5mdWppdHN1Lm9hc3lzZ3AnLFxuICAgICAgICAnZmgnOiAnaW1hZ2UveC1mcmVlaGFuZCcsXG4gICAgICAgICdmaWYnOiBbJ2FwcGxpY2F0aW9uL2ZyYWN0YWxzJywgJ2ltYWdlL2ZpZiddLFxuICAgICAgICAnZmlnJzogJ2FwcGxpY2F0aW9uL3gteGZpZycsXG4gICAgICAgICdmbGknOiBbJ3ZpZGVvL2ZsaScsICd2aWRlby94LWZsaSddLFxuICAgICAgICAnZmxvJzogWydpbWFnZS9mbG9yaWFuJywgJ2FwcGxpY2F0aW9uL3ZuZC5taWNyb2dyYWZ4LmZsbyddLFxuICAgICAgICAnZmxyJzogJ3gtd29ybGQveC12cm1sJyxcbiAgICAgICAgJ2Zsdic6ICd2aWRlby94LWZsdicsXG4gICAgICAgICdmbHcnOiAnYXBwbGljYXRpb24vdm5kLmtkZS5raXZpbycsXG4gICAgICAgICdmbHgnOiAndGV4dC92bmQuZm1pLmZsZXhzdG9yJyxcbiAgICAgICAgJ2ZseSc6ICd0ZXh0L3ZuZC5mbHknLFxuICAgICAgICAnZm0nOiAnYXBwbGljYXRpb24vdm5kLmZyYW1lbWFrZXInLFxuICAgICAgICAnZm1mJzogJ3ZpZGVvL3gtYXRvbWljM2QtZmVhdHVyZScsXG4gICAgICAgICdmbmMnOiAnYXBwbGljYXRpb24vdm5kLmZyb2dhbnMuZm5jJyxcbiAgICAgICAgJ2Zvcic6IFsndGV4dC9wbGFpbicsICd0ZXh0L3gtZm9ydHJhbiddLFxuICAgICAgICAnZnB4JzogWydpbWFnZS92bmQuZnB4JywgJ2ltYWdlL3ZuZC5uZXQtZnB4J10sXG4gICAgICAgICdmcmwnOiAnYXBwbGljYXRpb24vZnJlZWxvYWRlcicsXG4gICAgICAgICdmc2MnOiAnYXBwbGljYXRpb24vdm5kLmZzYy53ZWJsYXVuY2gnLFxuICAgICAgICAnZnN0JzogJ2ltYWdlL3ZuZC5mc3QnLFxuICAgICAgICAnZnRjJzogJ2FwcGxpY2F0aW9uL3ZuZC5mbHV4dGltZS5jbGlwJyxcbiAgICAgICAgJ2Z0aSc6ICdhcHBsaWNhdGlvbi92bmQuYW5zZXItd2ViLWZ1bmRzLXRyYW5zZmVyLWluaXRpYXRpb24nLFxuICAgICAgICAnZnVuayc6ICdhdWRpby9tYWtlJyxcbiAgICAgICAgJ2Z2dCc6ICd2aWRlby92bmQuZnZ0JyxcbiAgICAgICAgJ2Z4cCc6ICdhcHBsaWNhdGlvbi92bmQuYWRvYmUuZnhwJyxcbiAgICAgICAgJ2Z6cyc6ICdhcHBsaWNhdGlvbi92bmQuZnV6enlzaGVldCcsXG4gICAgICAgICdnJzogJ3RleHQvcGxhaW4nLFxuICAgICAgICAnZzJ3JzogJ2FwcGxpY2F0aW9uL3ZuZC5nZW9wbGFuJyxcbiAgICAgICAgJ2czJzogJ2ltYWdlL2czZmF4JyxcbiAgICAgICAgJ2czdyc6ICdhcHBsaWNhdGlvbi92bmQuZ2Vvc3BhY2UnLFxuICAgICAgICAnZ2FjJzogJ2FwcGxpY2F0aW9uL3ZuZC5ncm9vdmUtYWNjb3VudCcsXG4gICAgICAgICdnZGwnOiAnbW9kZWwvdm5kLmdkbCcsXG4gICAgICAgICdnZW8nOiAnYXBwbGljYXRpb24vdm5kLmR5bmFnZW8nLFxuICAgICAgICAnZ2V4JzogJ2FwcGxpY2F0aW9uL3ZuZC5nZW9tZXRyeS1leHBsb3JlcicsXG4gICAgICAgICdnZ2InOiAnYXBwbGljYXRpb24vdm5kLmdlb2dlYnJhLmZpbGUnLFxuICAgICAgICAnZ2d0JzogJ2FwcGxpY2F0aW9uL3ZuZC5nZW9nZWJyYS50b29sJyxcbiAgICAgICAgJ2doZic6ICdhcHBsaWNhdGlvbi92bmQuZ3Jvb3ZlLWhlbHAnLFxuICAgICAgICAnZ2lmJzogJ2ltYWdlL2dpZicsXG4gICAgICAgICdnaW0nOiAnYXBwbGljYXRpb24vdm5kLmdyb292ZS1pZGVudGl0eS1tZXNzYWdlJyxcbiAgICAgICAgJ2dsJzogWyd2aWRlby9nbCcsICd2aWRlby94LWdsJ10sXG4gICAgICAgICdnbXgnOiAnYXBwbGljYXRpb24vdm5kLmdteCcsXG4gICAgICAgICdnbnVtZXJpYyc6ICdhcHBsaWNhdGlvbi94LWdudW1lcmljJyxcbiAgICAgICAgJ2dwaCc6ICdhcHBsaWNhdGlvbi92bmQuZmxvZ3JhcGhpdCcsXG4gICAgICAgICdncWYnOiAnYXBwbGljYXRpb24vdm5kLmdyYWZlcScsXG4gICAgICAgICdncmFtJzogJ2FwcGxpY2F0aW9uL3NyZ3MnLFxuICAgICAgICAnZ3J2JzogJ2FwcGxpY2F0aW9uL3ZuZC5ncm9vdmUtaW5qZWN0b3InLFxuICAgICAgICAnZ3J4bWwnOiAnYXBwbGljYXRpb24vc3Jncyt4bWwnLFxuICAgICAgICAnZ3NkJzogJ2F1ZGlvL3gtZ3NtJyxcbiAgICAgICAgJ2dzZic6ICdhcHBsaWNhdGlvbi94LWZvbnQtZ2hvc3RzY3JpcHQnLFxuICAgICAgICAnZ3NtJzogJ2F1ZGlvL3gtZ3NtJyxcbiAgICAgICAgJ2dzcCc6ICdhcHBsaWNhdGlvbi94LWdzcCcsXG4gICAgICAgICdnc3MnOiAnYXBwbGljYXRpb24veC1nc3MnLFxuICAgICAgICAnZ3Rhcic6ICdhcHBsaWNhdGlvbi94LWd0YXInLFxuICAgICAgICAnZ3RtJzogJ2FwcGxpY2F0aW9uL3ZuZC5ncm9vdmUtdG9vbC1tZXNzYWdlJyxcbiAgICAgICAgJ2d0dyc6ICdtb2RlbC92bmQuZ3R3JyxcbiAgICAgICAgJ2d2JzogJ3RleHQvdm5kLmdyYXBodml6JyxcbiAgICAgICAgJ2d4dCc6ICdhcHBsaWNhdGlvbi92bmQuZ2VvbmV4dCcsXG4gICAgICAgICdneic6IFsnYXBwbGljYXRpb24veC1nemlwJywgJ2FwcGxpY2F0aW9uL3gtY29tcHJlc3NlZCddLFxuICAgICAgICAnZ3ppcCc6IFsnbXVsdGlwYXJ0L3gtZ3ppcCcsICdhcHBsaWNhdGlvbi94LWd6aXAnXSxcbiAgICAgICAgJ2gnOiBbJ3RleHQvcGxhaW4nLCAndGV4dC94LWgnXSxcbiAgICAgICAgJ2gyNjEnOiAndmlkZW8vaDI2MScsXG4gICAgICAgICdoMjYzJzogJ3ZpZGVvL2gyNjMnLFxuICAgICAgICAnaDI2NCc6ICd2aWRlby9oMjY0JyxcbiAgICAgICAgJ2hhbCc6ICdhcHBsaWNhdGlvbi92bmQuaGFsK3htbCcsXG4gICAgICAgICdoYmNpJzogJ2FwcGxpY2F0aW9uL3ZuZC5oYmNpJyxcbiAgICAgICAgJ2hkZic6ICdhcHBsaWNhdGlvbi94LWhkZicsXG4gICAgICAgICdoZWxwJzogJ2FwcGxpY2F0aW9uL3gtaGVscGZpbGUnLFxuICAgICAgICAnaGdsJzogJ2FwcGxpY2F0aW9uL3ZuZC5ocC1ocGdsJyxcbiAgICAgICAgJ2hoJzogWyd0ZXh0L3BsYWluJywgJ3RleHQveC1oJ10sXG4gICAgICAgICdobGInOiAndGV4dC94LXNjcmlwdCcsXG4gICAgICAgICdobHAnOiBbJ2FwcGxpY2F0aW9uL3dpbmhscCcsICdhcHBsaWNhdGlvbi9obHAnLCAnYXBwbGljYXRpb24veC1oZWxwZmlsZScsICdhcHBsaWNhdGlvbi94LXdpbmhlbHAnXSxcbiAgICAgICAgJ2hwZyc6ICdhcHBsaWNhdGlvbi92bmQuaHAtaHBnbCcsXG4gICAgICAgICdocGdsJzogJ2FwcGxpY2F0aW9uL3ZuZC5ocC1ocGdsJyxcbiAgICAgICAgJ2hwaWQnOiAnYXBwbGljYXRpb24vdm5kLmhwLWhwaWQnLFxuICAgICAgICAnaHBzJzogJ2FwcGxpY2F0aW9uL3ZuZC5ocC1ocHMnLFxuICAgICAgICAnaHF4JzogWydhcHBsaWNhdGlvbi9tYWMtYmluaGV4NDAnLCAnYXBwbGljYXRpb24vYmluaGV4JywgJ2FwcGxpY2F0aW9uL2JpbmhleDQnLCAnYXBwbGljYXRpb24vbWFjLWJpbmhleCcsICdhcHBsaWNhdGlvbi94LWJpbmhleDQwJywgJ2FwcGxpY2F0aW9uL3gtbWFjLWJpbmhleDQwJ10sXG4gICAgICAgICdodGEnOiAnYXBwbGljYXRpb24vaHRhJyxcbiAgICAgICAgJ2h0Yyc6ICd0ZXh0L3gtY29tcG9uZW50JyxcbiAgICAgICAgJ2h0a2UnOiAnYXBwbGljYXRpb24vdm5kLmtlbmFtZWFhcHAnLFxuICAgICAgICAnaHRtJzogJ3RleHQvaHRtbCcsXG4gICAgICAgICdodG1sJzogJ3RleHQvaHRtbCcsXG4gICAgICAgICdodG1scyc6ICd0ZXh0L2h0bWwnLFxuICAgICAgICAnaHR0JzogJ3RleHQvd2Vidmlld2h0bWwnLFxuICAgICAgICAnaHR4JzogJ3RleHQvaHRtbCcsXG4gICAgICAgICdodmQnOiAnYXBwbGljYXRpb24vdm5kLnlhbWFoYS5odi1kaWMnLFxuICAgICAgICAnaHZwJzogJ2FwcGxpY2F0aW9uL3ZuZC55YW1haGEuaHYtdm9pY2UnLFxuICAgICAgICAnaHZzJzogJ2FwcGxpY2F0aW9uL3ZuZC55YW1haGEuaHYtc2NyaXB0JyxcbiAgICAgICAgJ2kyZyc6ICdhcHBsaWNhdGlvbi92bmQuaW50ZXJnZW8nLFxuICAgICAgICAnaWNjJzogJ2FwcGxpY2F0aW9uL3ZuZC5pY2Nwcm9maWxlJyxcbiAgICAgICAgJ2ljZSc6ICd4LWNvbmZlcmVuY2UveC1jb29sdGFsaycsXG4gICAgICAgICdpY28nOiAnaW1hZ2UveC1pY29uJyxcbiAgICAgICAgJ2ljcyc6ICd0ZXh0L2NhbGVuZGFyJyxcbiAgICAgICAgJ2lkYyc6ICd0ZXh0L3BsYWluJyxcbiAgICAgICAgJ2llZic6ICdpbWFnZS9pZWYnLFxuICAgICAgICAnaWVmcyc6ICdpbWFnZS9pZWYnLFxuICAgICAgICAnaWZtJzogJ2FwcGxpY2F0aW9uL3ZuZC5zaGFuYS5pbmZvcm1lZC5mb3JtZGF0YScsXG4gICAgICAgICdpZ2VzJzogWydhcHBsaWNhdGlvbi9pZ2VzJywgJ21vZGVsL2lnZXMnXSxcbiAgICAgICAgJ2lnbCc6ICdhcHBsaWNhdGlvbi92bmQuaWdsb2FkZXInLFxuICAgICAgICAnaWdtJzogJ2FwcGxpY2F0aW9uL3ZuZC5pbnNvcnMuaWdtJyxcbiAgICAgICAgJ2lncyc6IFsnYXBwbGljYXRpb24vaWdlcycsICdtb2RlbC9pZ2VzJ10sXG4gICAgICAgICdpZ3gnOiAnYXBwbGljYXRpb24vdm5kLm1pY3JvZ3JhZnguaWd4JyxcbiAgICAgICAgJ2lpZic6ICdhcHBsaWNhdGlvbi92bmQuc2hhbmEuaW5mb3JtZWQuaW50ZXJjaGFuZ2UnLFxuICAgICAgICAnaWlpJzogJ2FwcGxpY2F0aW9uL3gtaXBob25lJyxcbiAgICAgICAgJ2ltYSc6ICdhcHBsaWNhdGlvbi94LWltYScsXG4gICAgICAgICdpbWFwJzogJ2FwcGxpY2F0aW9uL3gtaHR0cGQtaW1hcCcsXG4gICAgICAgICdpbXAnOiAnYXBwbGljYXRpb24vdm5kLmFjY3BhYy5zaW1wbHkuaW1wJyxcbiAgICAgICAgJ2ltcyc6ICdhcHBsaWNhdGlvbi92bmQubXMtaW1zJyxcbiAgICAgICAgJ2luZic6ICdhcHBsaWNhdGlvbi9pbmYnLFxuICAgICAgICAnaW5zJzogWydhcHBsaWNhdGlvbi94LWludGVybmV0LXNpZ251cCcsICdhcHBsaWNhdGlvbi94LWludGVybmV0dC1zaWdudXAnXSxcbiAgICAgICAgJ2lwJzogJ2FwcGxpY2F0aW9uL3gtaXAyJyxcbiAgICAgICAgJ2lwZml4JzogJ2FwcGxpY2F0aW9uL2lwZml4JyxcbiAgICAgICAgJ2lwayc6ICdhcHBsaWNhdGlvbi92bmQuc2hhbmEuaW5mb3JtZWQucGFja2FnZScsXG4gICAgICAgICdpcm0nOiAnYXBwbGljYXRpb24vdm5kLmlibS5yaWdodHMtbWFuYWdlbWVudCcsXG4gICAgICAgICdpcnAnOiAnYXBwbGljYXRpb24vdm5kLmlyZXBvc2l0b3J5LnBhY2thZ2UreG1sJyxcbiAgICAgICAgJ2lzcCc6ICdhcHBsaWNhdGlvbi94LWludGVybmV0LXNpZ251cCcsXG4gICAgICAgICdpc3UnOiAndmlkZW8veC1pc3ZpZGVvJyxcbiAgICAgICAgJ2l0JzogJ2F1ZGlvL2l0JyxcbiAgICAgICAgJ2l0cCc6ICdhcHBsaWNhdGlvbi92bmQuc2hhbmEuaW5mb3JtZWQuZm9ybXRlbXBsYXRlJyxcbiAgICAgICAgJ2l2JzogJ2FwcGxpY2F0aW9uL3gtaW52ZW50b3InLFxuICAgICAgICAnaXZwJzogJ2FwcGxpY2F0aW9uL3ZuZC5pbW1lcnZpc2lvbi1pdnAnLFxuICAgICAgICAnaXZyJzogJ2ktd29ybGQvaS12cm1sJyxcbiAgICAgICAgJ2l2dSc6ICdhcHBsaWNhdGlvbi92bmQuaW1tZXJ2aXNpb24taXZ1JyxcbiAgICAgICAgJ2l2eSc6ICdhcHBsaWNhdGlvbi94LWxpdmVzY3JlZW4nLFxuICAgICAgICAnamFkJzogJ3RleHQvdm5kLnN1bi5qMm1lLmFwcC1kZXNjcmlwdG9yJyxcbiAgICAgICAgJ2phbSc6IFsnYXBwbGljYXRpb24vdm5kLmphbScsICdhdWRpby94LWphbSddLFxuICAgICAgICAnamFyJzogJ2FwcGxpY2F0aW9uL2phdmEtYXJjaGl2ZScsXG4gICAgICAgICdqYXYnOiBbJ3RleHQvcGxhaW4nLCAndGV4dC94LWphdmEtc291cmNlJ10sXG4gICAgICAgICdqYXZhJzogWyd0ZXh0L3BsYWluJywgJ3RleHQveC1qYXZhLXNvdXJjZSxqYXZhJywgJ3RleHQveC1qYXZhLXNvdXJjZSddLFxuICAgICAgICAnamNtJzogJ2FwcGxpY2F0aW9uL3gtamF2YS1jb21tZXJjZScsXG4gICAgICAgICdqZmlmJzogWydpbWFnZS9waXBlZycsICdpbWFnZS9qcGVnJywgJ2ltYWdlL3BqcGVnJ10sXG4gICAgICAgICdqZmlmLXRibmwnOiAnaW1hZ2UvanBlZycsXG4gICAgICAgICdqaXNwJzogJ2FwcGxpY2F0aW9uL3ZuZC5qaXNwJyxcbiAgICAgICAgJ2psdCc6ICdhcHBsaWNhdGlvbi92bmQuaHAtamx5dCcsXG4gICAgICAgICdqbmxwJzogJ2FwcGxpY2F0aW9uL3gtamF2YS1qbmxwLWZpbGUnLFxuICAgICAgICAnam9kYSc6ICdhcHBsaWNhdGlvbi92bmQuam9vc3Quam9kYS1hcmNoaXZlJyxcbiAgICAgICAgJ2pwZSc6IFsnaW1hZ2UvanBlZycsICdpbWFnZS9wanBlZyddLFxuICAgICAgICAnanBlZyc6IFsnaW1hZ2UvanBlZycsICdpbWFnZS9wanBlZyddLFxuICAgICAgICAnanBnJzogWydpbWFnZS9qcGVnJywgJ2ltYWdlL3BqcGVnJ10sXG4gICAgICAgICdqcGd2JzogJ3ZpZGVvL2pwZWcnLFxuICAgICAgICAnanBtJzogJ3ZpZGVvL2pwbScsXG4gICAgICAgICdqcHMnOiAnaW1hZ2UveC1qcHMnLFxuICAgICAgICAnanMnOiBbJ2FwcGxpY2F0aW9uL2phdmFzY3JpcHQnLCAnYXBwbGljYXRpb24vZWNtYXNjcmlwdCcsICd0ZXh0L2phdmFzY3JpcHQnLCAndGV4dC9lY21hc2NyaXB0JywgJ2FwcGxpY2F0aW9uL3gtamF2YXNjcmlwdCddLFxuICAgICAgICAnanNvbic6ICdhcHBsaWNhdGlvbi9qc29uJyxcbiAgICAgICAgJ2p1dCc6ICdpbWFnZS9qdXR2aXNpb24nLFxuICAgICAgICAna2FyJzogWydhdWRpby9taWRpJywgJ211c2ljL3gta2FyYW9rZSddLFxuICAgICAgICAna2FyYm9uJzogJ2FwcGxpY2F0aW9uL3ZuZC5rZGUua2FyYm9uJyxcbiAgICAgICAgJ2tmbyc6ICdhcHBsaWNhdGlvbi92bmQua2RlLmtmb3JtdWxhJyxcbiAgICAgICAgJ2tpYSc6ICdhcHBsaWNhdGlvbi92bmQua2lkc3BpcmF0aW9uJyxcbiAgICAgICAgJ2ttbCc6ICdhcHBsaWNhdGlvbi92bmQuZ29vZ2xlLWVhcnRoLmttbCt4bWwnLFxuICAgICAgICAna216JzogJ2FwcGxpY2F0aW9uL3ZuZC5nb29nbGUtZWFydGgua216JyxcbiAgICAgICAgJ2tuZSc6ICdhcHBsaWNhdGlvbi92bmQua2luYXInLFxuICAgICAgICAna29uJzogJ2FwcGxpY2F0aW9uL3ZuZC5rZGUua29udG91cicsXG4gICAgICAgICdrcHInOiAnYXBwbGljYXRpb24vdm5kLmtkZS5rcHJlc2VudGVyJyxcbiAgICAgICAgJ2tzaCc6IFsnYXBwbGljYXRpb24veC1rc2gnLCAndGV4dC94LXNjcmlwdC5rc2gnXSxcbiAgICAgICAgJ2tzcCc6ICdhcHBsaWNhdGlvbi92bmQua2RlLmtzcHJlYWQnLFxuICAgICAgICAna3R4JzogJ2ltYWdlL2t0eCcsXG4gICAgICAgICdrdHonOiAnYXBwbGljYXRpb24vdm5kLmthaG9vdHonLFxuICAgICAgICAna3dkJzogJ2FwcGxpY2F0aW9uL3ZuZC5rZGUua3dvcmQnLFxuICAgICAgICAnbGEnOiBbJ2F1ZGlvL25zcGF1ZGlvJywgJ2F1ZGlvL3gtbnNwYXVkaW8nXSxcbiAgICAgICAgJ2xhbSc6ICdhdWRpby94LWxpdmVhdWRpbycsXG4gICAgICAgICdsYXN4bWwnOiAnYXBwbGljYXRpb24vdm5kLmxhcy5sYXMreG1sJyxcbiAgICAgICAgJ2xhdGV4JzogJ2FwcGxpY2F0aW9uL3gtbGF0ZXgnLFxuICAgICAgICAnbGJkJzogJ2FwcGxpY2F0aW9uL3ZuZC5sbGFtYWdyYXBoaWNzLmxpZmUtYmFsYW5jZS5kZXNrdG9wJyxcbiAgICAgICAgJ2xiZSc6ICdhcHBsaWNhdGlvbi92bmQubGxhbWFncmFwaGljcy5saWZlLWJhbGFuY2UuZXhjaGFuZ2UreG1sJyxcbiAgICAgICAgJ2xlcyc6ICdhcHBsaWNhdGlvbi92bmQuaGhlLmxlc3Nvbi1wbGF5ZXInLFxuICAgICAgICAnbGhhJzogWydhcHBsaWNhdGlvbi9vY3RldC1zdHJlYW0nLCAnYXBwbGljYXRpb24vbGhhJywgJ2FwcGxpY2F0aW9uL3gtbGhhJ10sXG4gICAgICAgICdsaHgnOiAnYXBwbGljYXRpb24vb2N0ZXQtc3RyZWFtJyxcbiAgICAgICAgJ2xpbms2Nic6ICdhcHBsaWNhdGlvbi92bmQucm91dGU2Ni5saW5rNjYreG1sJyxcbiAgICAgICAgJ2xpc3QnOiAndGV4dC9wbGFpbicsXG4gICAgICAgICdsbWEnOiBbJ2F1ZGlvL25zcGF1ZGlvJywgJ2F1ZGlvL3gtbnNwYXVkaW8nXSxcbiAgICAgICAgJ2xvZyc6ICd0ZXh0L3BsYWluJyxcbiAgICAgICAgJ2xybSc6ICdhcHBsaWNhdGlvbi92bmQubXMtbHJtJyxcbiAgICAgICAgJ2xzZic6ICd2aWRlby94LWxhLWFzZicsXG4gICAgICAgICdsc3AnOiBbJ2FwcGxpY2F0aW9uL3gtbGlzcCcsICd0ZXh0L3gtc2NyaXB0Lmxpc3AnXSxcbiAgICAgICAgJ2xzdCc6ICd0ZXh0L3BsYWluJyxcbiAgICAgICAgJ2xzeCc6IFsndmlkZW8veC1sYS1hc2YnLCAndGV4dC94LWxhLWFzZiddLFxuICAgICAgICAnbHRmJzogJ2FwcGxpY2F0aW9uL3ZuZC5mcm9nYW5zLmx0ZicsXG4gICAgICAgICdsdHgnOiAnYXBwbGljYXRpb24veC1sYXRleCcsXG4gICAgICAgICdsdnAnOiAnYXVkaW8vdm5kLmx1Y2VudC52b2ljZScsXG4gICAgICAgICdsd3AnOiAnYXBwbGljYXRpb24vdm5kLmxvdHVzLXdvcmRwcm8nLFxuICAgICAgICAnbHpoJzogWydhcHBsaWNhdGlvbi9vY3RldC1zdHJlYW0nLCAnYXBwbGljYXRpb24veC1semgnXSxcbiAgICAgICAgJ2x6eCc6IFsnYXBwbGljYXRpb24vbHp4JywgJ2FwcGxpY2F0aW9uL29jdGV0LXN0cmVhbScsICdhcHBsaWNhdGlvbi94LWx6eCddLFxuICAgICAgICAnbSc6IFsndGV4dC9wbGFpbicsICd0ZXh0L3gtbSddLFxuICAgICAgICAnbTEzJzogJ2FwcGxpY2F0aW9uL3gtbXNtZWRpYXZpZXcnLFxuICAgICAgICAnbTE0JzogJ2FwcGxpY2F0aW9uL3gtbXNtZWRpYXZpZXcnLFxuICAgICAgICAnbTF2JzogJ3ZpZGVvL21wZWcnLFxuICAgICAgICAnbTIxJzogJ2FwcGxpY2F0aW9uL21wMjEnLFxuICAgICAgICAnbTJhJzogJ2F1ZGlvL21wZWcnLFxuICAgICAgICAnbTJ2JzogJ3ZpZGVvL21wZWcnLFxuICAgICAgICAnbTN1JzogWydhdWRpby94LW1wZWd1cmwnLCAnYXVkaW8veC1tcGVxdXJsJ10sXG4gICAgICAgICdtM3U4JzogJ2FwcGxpY2F0aW9uL3ZuZC5hcHBsZS5tcGVndXJsJyxcbiAgICAgICAgJ200dic6ICd2aWRlby94LW00dicsXG4gICAgICAgICdtYSc6ICdhcHBsaWNhdGlvbi9tYXRoZW1hdGljYScsXG4gICAgICAgICdtYWRzJzogJ2FwcGxpY2F0aW9uL21hZHMreG1sJyxcbiAgICAgICAgJ21hZyc6ICdhcHBsaWNhdGlvbi92bmQuZWNvd2luLmNoYXJ0JyxcbiAgICAgICAgJ21hbic6ICdhcHBsaWNhdGlvbi94LXRyb2ZmLW1hbicsXG4gICAgICAgICdtYXAnOiAnYXBwbGljYXRpb24veC1uYXZpbWFwJyxcbiAgICAgICAgJ21hcic6ICd0ZXh0L3BsYWluJyxcbiAgICAgICAgJ21hdGhtbCc6ICdhcHBsaWNhdGlvbi9tYXRobWwreG1sJyxcbiAgICAgICAgJ21iZCc6ICdhcHBsaWNhdGlvbi9tYmVkbGV0JyxcbiAgICAgICAgJ21iayc6ICdhcHBsaWNhdGlvbi92bmQubW9iaXVzLm1iaycsXG4gICAgICAgICdtYm94JzogJ2FwcGxpY2F0aW9uL21ib3gnLFxuICAgICAgICAnbWMkJzogJ2FwcGxpY2F0aW9uL3gtbWFnaWMtY2FwLXBhY2thZ2UtMS4wJyxcbiAgICAgICAgJ21jMSc6ICdhcHBsaWNhdGlvbi92bmQubWVkY2FsY2RhdGEnLFxuICAgICAgICAnbWNkJzogWydhcHBsaWNhdGlvbi9tY2FkJywgJ2FwcGxpY2F0aW9uL3ZuZC5tY2QnLCAnYXBwbGljYXRpb24veC1tYXRoY2FkJ10sXG4gICAgICAgICdtY2YnOiBbJ2ltYWdlL3Zhc2EnLCAndGV4dC9tY2YnXSxcbiAgICAgICAgJ21jcCc6ICdhcHBsaWNhdGlvbi9uZXRtYycsXG4gICAgICAgICdtY3VybCc6ICd0ZXh0L3ZuZC5jdXJsLm1jdXJsJyxcbiAgICAgICAgJ21kYic6ICdhcHBsaWNhdGlvbi94LW1zYWNjZXNzJyxcbiAgICAgICAgJ21kaSc6ICdpbWFnZS92bmQubXMtbW9kaScsXG4gICAgICAgICdtZSc6ICdhcHBsaWNhdGlvbi94LXRyb2ZmLW1lJyxcbiAgICAgICAgJ21ldGE0JzogJ2FwcGxpY2F0aW9uL21ldGFsaW5rNCt4bWwnLFxuICAgICAgICAnbWV0cyc6ICdhcHBsaWNhdGlvbi9tZXRzK3htbCcsXG4gICAgICAgICdtZm0nOiAnYXBwbGljYXRpb24vdm5kLm1mbXAnLFxuICAgICAgICAnbWdwJzogJ2FwcGxpY2F0aW9uL3ZuZC5vc2dlby5tYXBndWlkZS5wYWNrYWdlJyxcbiAgICAgICAgJ21neic6ICdhcHBsaWNhdGlvbi92bmQucHJvdGV1cy5tYWdhemluZScsXG4gICAgICAgICdtaHQnOiAnbWVzc2FnZS9yZmM4MjInLFxuICAgICAgICAnbWh0bWwnOiAnbWVzc2FnZS9yZmM4MjInLFxuICAgICAgICAnbWlkJzogWydhdWRpby9taWQnLCAnYXVkaW8vbWlkaScsICdtdXNpYy9jcmVzY2VuZG8nLCAneC1tdXNpYy94LW1pZGknLCAnYXVkaW8veC1taWRpJywgJ2FwcGxpY2F0aW9uL3gtbWlkaScsICdhdWRpby94LW1pZCddLFxuICAgICAgICAnbWlkaSc6IFsnYXVkaW8vbWlkaScsICdtdXNpYy9jcmVzY2VuZG8nLCAneC1tdXNpYy94LW1pZGknLCAnYXVkaW8veC1taWRpJywgJ2FwcGxpY2F0aW9uL3gtbWlkaScsICdhdWRpby94LW1pZCddLFxuICAgICAgICAnbWlmJzogWydhcHBsaWNhdGlvbi92bmQubWlmJywgJ2FwcGxpY2F0aW9uL3gtbWlmJywgJ2FwcGxpY2F0aW9uL3gtZnJhbWUnXSxcbiAgICAgICAgJ21pbWUnOiBbJ21lc3NhZ2UvcmZjODIyJywgJ3d3dy9taW1lJ10sXG4gICAgICAgICdtajInOiAndmlkZW8vbWoyJyxcbiAgICAgICAgJ21qZic6ICdhdWRpby94LXZuZC5hdWRpb2V4cGxvc2lvbi5tanVpY2VtZWRpYWZpbGUnLFxuICAgICAgICAnbWpwZyc6ICd2aWRlby94LW1vdGlvbi1qcGVnJyxcbiAgICAgICAgJ21scCc6ICdhcHBsaWNhdGlvbi92bmQuZG9sYnkubWxwJyxcbiAgICAgICAgJ21tJzogWydhcHBsaWNhdGlvbi9iYXNlNjQnLCAnYXBwbGljYXRpb24veC1tZW1lJ10sXG4gICAgICAgICdtbWQnOiAnYXBwbGljYXRpb24vdm5kLmNoaXBudXRzLmthcmFva2UtbW1kJyxcbiAgICAgICAgJ21tZSc6ICdhcHBsaWNhdGlvbi9iYXNlNjQnLFxuICAgICAgICAnbW1mJzogJ2FwcGxpY2F0aW9uL3ZuZC5zbWFmJyxcbiAgICAgICAgJ21tcic6ICdpbWFnZS92bmQuZnVqaXhlcm94LmVkbWljcy1tbXInLFxuICAgICAgICAnbW55JzogJ2FwcGxpY2F0aW9uL3gtbXNtb25leScsXG4gICAgICAgICdtb2QnOiBbJ2F1ZGlvL21vZCcsICdhdWRpby94LW1vZCddLFxuICAgICAgICAnbW9kcyc6ICdhcHBsaWNhdGlvbi9tb2RzK3htbCcsXG4gICAgICAgICdtb292JzogJ3ZpZGVvL3F1aWNrdGltZScsXG4gICAgICAgICdtb3YnOiAndmlkZW8vcXVpY2t0aW1lJyxcbiAgICAgICAgJ21vdmllJzogJ3ZpZGVvL3gtc2dpLW1vdmllJyxcbiAgICAgICAgJ21wMic6IFsndmlkZW8vbXBlZycsICdhdWRpby9tcGVnJywgJ3ZpZGVvL3gtbXBlZycsICdhdWRpby94LW1wZWcnLCAndmlkZW8veC1tcGVxMmEnXSxcbiAgICAgICAgJ21wMyc6IFsnYXVkaW8vbXBlZycsICdhdWRpby9tcGVnMycsICd2aWRlby9tcGVnJywgJ2F1ZGlvL3gtbXBlZy0zJywgJ3ZpZGVvL3gtbXBlZyddLFxuICAgICAgICAnbXA0JzogWyd2aWRlby9tcDQnLCAnYXBwbGljYXRpb24vbXA0J10sXG4gICAgICAgICdtcDRhJzogJ2F1ZGlvL21wNCcsXG4gICAgICAgICdtcGEnOiBbJ3ZpZGVvL21wZWcnLCAnYXVkaW8vbXBlZyddLFxuICAgICAgICAnbXBjJzogWydhcHBsaWNhdGlvbi92bmQubW9waHVuLmNlcnRpZmljYXRlJywgJ2FwcGxpY2F0aW9uL3gtcHJvamVjdCddLFxuICAgICAgICAnbXBlJzogJ3ZpZGVvL21wZWcnLFxuICAgICAgICAnbXBlZyc6ICd2aWRlby9tcGVnJyxcbiAgICAgICAgJ21wZyc6IFsndmlkZW8vbXBlZycsICdhdWRpby9tcGVnJ10sXG4gICAgICAgICdtcGdhJzogJ2F1ZGlvL21wZWcnLFxuICAgICAgICAnbXBrZyc6ICdhcHBsaWNhdGlvbi92bmQuYXBwbGUuaW5zdGFsbGVyK3htbCcsXG4gICAgICAgICdtcG0nOiAnYXBwbGljYXRpb24vdm5kLmJsdWVpY2UubXVsdGlwYXNzJyxcbiAgICAgICAgJ21wbic6ICdhcHBsaWNhdGlvbi92bmQubW9waHVuLmFwcGxpY2F0aW9uJyxcbiAgICAgICAgJ21wcCc6ICdhcHBsaWNhdGlvbi92bmQubXMtcHJvamVjdCcsXG4gICAgICAgICdtcHQnOiAnYXBwbGljYXRpb24veC1wcm9qZWN0JyxcbiAgICAgICAgJ21wdic6ICdhcHBsaWNhdGlvbi94LXByb2plY3QnLFxuICAgICAgICAnbXB2Mic6ICd2aWRlby9tcGVnJyxcbiAgICAgICAgJ21weCc6ICdhcHBsaWNhdGlvbi94LXByb2plY3QnLFxuICAgICAgICAnbXB5JzogJ2FwcGxpY2F0aW9uL3ZuZC5pYm0ubWluaXBheScsXG4gICAgICAgICdtcXknOiAnYXBwbGljYXRpb24vdm5kLm1vYml1cy5tcXknLFxuICAgICAgICAnbXJjJzogJ2FwcGxpY2F0aW9uL21hcmMnLFxuICAgICAgICAnbXJjeCc6ICdhcHBsaWNhdGlvbi9tYXJjeG1sK3htbCcsXG4gICAgICAgICdtcyc6ICdhcHBsaWNhdGlvbi94LXRyb2ZmLW1zJyxcbiAgICAgICAgJ21zY21sJzogJ2FwcGxpY2F0aW9uL21lZGlhc2VydmVyY29udHJvbCt4bWwnLFxuICAgICAgICAnbXNlcSc6ICdhcHBsaWNhdGlvbi92bmQubXNlcScsXG4gICAgICAgICdtc2YnOiAnYXBwbGljYXRpb24vdm5kLmVwc29uLm1zZicsXG4gICAgICAgICdtc2cnOiAnYXBwbGljYXRpb24vdm5kLm1zLW91dGxvb2snLFxuICAgICAgICAnbXNoJzogJ21vZGVsL21lc2gnLFxuICAgICAgICAnbXNsJzogJ2FwcGxpY2F0aW9uL3ZuZC5tb2JpdXMubXNsJyxcbiAgICAgICAgJ21zdHknOiAnYXBwbGljYXRpb24vdm5kLm11dmVlLnN0eWxlJyxcbiAgICAgICAgJ210cyc6ICdtb2RlbC92bmQubXRzJyxcbiAgICAgICAgJ211cyc6ICdhcHBsaWNhdGlvbi92bmQubXVzaWNpYW4nLFxuICAgICAgICAnbXVzaWN4bWwnOiAnYXBwbGljYXRpb24vdm5kLnJlY29yZGFyZS5tdXNpY3htbCt4bWwnLFxuICAgICAgICAnbXYnOiAndmlkZW8veC1zZ2ktbW92aWUnLFxuICAgICAgICAnbXZiJzogJ2FwcGxpY2F0aW9uL3gtbXNtZWRpYXZpZXcnLFxuICAgICAgICAnbXdmJzogJ2FwcGxpY2F0aW9uL3ZuZC5tZmVyJyxcbiAgICAgICAgJ214Zic6ICdhcHBsaWNhdGlvbi9teGYnLFxuICAgICAgICAnbXhsJzogJ2FwcGxpY2F0aW9uL3ZuZC5yZWNvcmRhcmUubXVzaWN4bWwnLFxuICAgICAgICAnbXhtbCc6ICdhcHBsaWNhdGlvbi94dit4bWwnLFxuICAgICAgICAnbXhzJzogJ2FwcGxpY2F0aW9uL3ZuZC50cmlzY2FwZS5teHMnLFxuICAgICAgICAnbXh1JzogJ3ZpZGVvL3ZuZC5tcGVndXJsJyxcbiAgICAgICAgJ215JzogJ2F1ZGlvL21ha2UnLFxuICAgICAgICAnbXp6JzogJ2FwcGxpY2F0aW9uL3gtdm5kLmF1ZGlvZXhwbG9zaW9uLm16eicsXG4gICAgICAgICduLWdhZ2UnOiAnYXBwbGljYXRpb24vdm5kLm5va2lhLm4tZ2FnZS5zeW1iaWFuLmluc3RhbGwnLFxuICAgICAgICAnbjMnOiAndGV4dC9uMycsXG4gICAgICAgICduYXAnOiAnaW1hZ2UvbmFwbHBzJyxcbiAgICAgICAgJ25hcGxwcyc6ICdpbWFnZS9uYXBscHMnLFxuICAgICAgICAnbmJwJzogJ2FwcGxpY2F0aW9uL3ZuZC53b2xmcmFtLnBsYXllcicsXG4gICAgICAgICduYyc6ICdhcHBsaWNhdGlvbi94LW5ldGNkZicsXG4gICAgICAgICduY20nOiAnYXBwbGljYXRpb24vdm5kLm5va2lhLmNvbmZpZ3VyYXRpb24tbWVzc2FnZScsXG4gICAgICAgICduY3gnOiAnYXBwbGljYXRpb24veC1kdGJuY3greG1sJyxcbiAgICAgICAgJ25nZGF0JzogJ2FwcGxpY2F0aW9uL3ZuZC5ub2tpYS5uLWdhZ2UuZGF0YScsXG4gICAgICAgICduaWYnOiAnaW1hZ2UveC1uaWZmJyxcbiAgICAgICAgJ25pZmYnOiAnaW1hZ2UveC1uaWZmJyxcbiAgICAgICAgJ25peCc6ICdhcHBsaWNhdGlvbi94LW1peC10cmFuc2ZlcicsXG4gICAgICAgICdubHUnOiAnYXBwbGljYXRpb24vdm5kLm5ldXJvbGFuZ3VhZ2Uubmx1JyxcbiAgICAgICAgJ25tbCc6ICdhcHBsaWNhdGlvbi92bmQuZW5saXZlbicsXG4gICAgICAgICdubmQnOiAnYXBwbGljYXRpb24vdm5kLm5vYmxlbmV0LWRpcmVjdG9yeScsXG4gICAgICAgICdubnMnOiAnYXBwbGljYXRpb24vdm5kLm5vYmxlbmV0LXNlYWxlcicsXG4gICAgICAgICdubncnOiAnYXBwbGljYXRpb24vdm5kLm5vYmxlbmV0LXdlYicsXG4gICAgICAgICducHgnOiAnaW1hZ2Uvdm5kLm5ldC1mcHgnLFxuICAgICAgICAnbnNjJzogJ2FwcGxpY2F0aW9uL3gtY29uZmVyZW5jZScsXG4gICAgICAgICduc2YnOiAnYXBwbGljYXRpb24vdm5kLmxvdHVzLW5vdGVzJyxcbiAgICAgICAgJ252ZCc6ICdhcHBsaWNhdGlvbi94LW5hdmlkb2MnLFxuICAgICAgICAnbndzJzogJ21lc3NhZ2UvcmZjODIyJyxcbiAgICAgICAgJ28nOiAnYXBwbGljYXRpb24vb2N0ZXQtc3RyZWFtJyxcbiAgICAgICAgJ29hMic6ICdhcHBsaWNhdGlvbi92bmQuZnVqaXRzdS5vYXN5czInLFxuICAgICAgICAnb2EzJzogJ2FwcGxpY2F0aW9uL3ZuZC5mdWppdHN1Lm9hc3lzMycsXG4gICAgICAgICdvYXMnOiAnYXBwbGljYXRpb24vdm5kLmZ1aml0c3Uub2FzeXMnLFxuICAgICAgICAnb2JkJzogJ2FwcGxpY2F0aW9uL3gtbXNiaW5kZXInLFxuICAgICAgICAnb2RhJzogJ2FwcGxpY2F0aW9uL29kYScsXG4gICAgICAgICdvZGInOiAnYXBwbGljYXRpb24vdm5kLm9hc2lzLm9wZW5kb2N1bWVudC5kYXRhYmFzZScsXG4gICAgICAgICdvZGMnOiAnYXBwbGljYXRpb24vdm5kLm9hc2lzLm9wZW5kb2N1bWVudC5jaGFydCcsXG4gICAgICAgICdvZGYnOiAnYXBwbGljYXRpb24vdm5kLm9hc2lzLm9wZW5kb2N1bWVudC5mb3JtdWxhJyxcbiAgICAgICAgJ29kZnQnOiAnYXBwbGljYXRpb24vdm5kLm9hc2lzLm9wZW5kb2N1bWVudC5mb3JtdWxhLXRlbXBsYXRlJyxcbiAgICAgICAgJ29kZyc6ICdhcHBsaWNhdGlvbi92bmQub2FzaXMub3BlbmRvY3VtZW50LmdyYXBoaWNzJyxcbiAgICAgICAgJ29kaSc6ICdhcHBsaWNhdGlvbi92bmQub2FzaXMub3BlbmRvY3VtZW50LmltYWdlJyxcbiAgICAgICAgJ29kbSc6ICdhcHBsaWNhdGlvbi92bmQub2FzaXMub3BlbmRvY3VtZW50LnRleHQtbWFzdGVyJyxcbiAgICAgICAgJ29kcCc6ICdhcHBsaWNhdGlvbi92bmQub2FzaXMub3BlbmRvY3VtZW50LnByZXNlbnRhdGlvbicsXG4gICAgICAgICdvZHMnOiAnYXBwbGljYXRpb24vdm5kLm9hc2lzLm9wZW5kb2N1bWVudC5zcHJlYWRzaGVldCcsXG4gICAgICAgICdvZHQnOiAnYXBwbGljYXRpb24vdm5kLm9hc2lzLm9wZW5kb2N1bWVudC50ZXh0JyxcbiAgICAgICAgJ29nYSc6ICdhdWRpby9vZ2cnLFxuICAgICAgICAnb2d2JzogJ3ZpZGVvL29nZycsXG4gICAgICAgICdvZ3gnOiAnYXBwbGljYXRpb24vb2dnJyxcbiAgICAgICAgJ29tYyc6ICdhcHBsaWNhdGlvbi94LW9tYycsXG4gICAgICAgICdvbWNkJzogJ2FwcGxpY2F0aW9uL3gtb21jZGF0YW1ha2VyJyxcbiAgICAgICAgJ29tY3InOiAnYXBwbGljYXRpb24veC1vbWNyZWdlcmF0b3InLFxuICAgICAgICAnb25ldG9jJzogJ2FwcGxpY2F0aW9uL29uZW5vdGUnLFxuICAgICAgICAnb3BmJzogJ2FwcGxpY2F0aW9uL29lYnBzLXBhY2thZ2UreG1sJyxcbiAgICAgICAgJ29yZyc6ICdhcHBsaWNhdGlvbi92bmQubG90dXMtb3JnYW5pemVyJyxcbiAgICAgICAgJ29zZic6ICdhcHBsaWNhdGlvbi92bmQueWFtYWhhLm9wZW5zY29yZWZvcm1hdCcsXG4gICAgICAgICdvc2ZwdmcnOiAnYXBwbGljYXRpb24vdm5kLnlhbWFoYS5vcGVuc2NvcmVmb3JtYXQub3NmcHZnK3htbCcsXG4gICAgICAgICdvdGMnOiAnYXBwbGljYXRpb24vdm5kLm9hc2lzLm9wZW5kb2N1bWVudC5jaGFydC10ZW1wbGF0ZScsXG4gICAgICAgICdvdGYnOiAnYXBwbGljYXRpb24veC1mb250LW90ZicsXG4gICAgICAgICdvdGcnOiAnYXBwbGljYXRpb24vdm5kLm9hc2lzLm9wZW5kb2N1bWVudC5ncmFwaGljcy10ZW1wbGF0ZScsXG4gICAgICAgICdvdGgnOiAnYXBwbGljYXRpb24vdm5kLm9hc2lzLm9wZW5kb2N1bWVudC50ZXh0LXdlYicsXG4gICAgICAgICdvdGknOiAnYXBwbGljYXRpb24vdm5kLm9hc2lzLm9wZW5kb2N1bWVudC5pbWFnZS10ZW1wbGF0ZScsXG4gICAgICAgICdvdHAnOiAnYXBwbGljYXRpb24vdm5kLm9hc2lzLm9wZW5kb2N1bWVudC5wcmVzZW50YXRpb24tdGVtcGxhdGUnLFxuICAgICAgICAnb3RzJzogJ2FwcGxpY2F0aW9uL3ZuZC5vYXNpcy5vcGVuZG9jdW1lbnQuc3ByZWFkc2hlZXQtdGVtcGxhdGUnLFxuICAgICAgICAnb3R0JzogJ2FwcGxpY2F0aW9uL3ZuZC5vYXNpcy5vcGVuZG9jdW1lbnQudGV4dC10ZW1wbGF0ZScsXG4gICAgICAgICdveHQnOiAnYXBwbGljYXRpb24vdm5kLm9wZW5vZmZpY2VvcmcuZXh0ZW5zaW9uJyxcbiAgICAgICAgJ3AnOiAndGV4dC94LXBhc2NhbCcsXG4gICAgICAgICdwMTAnOiBbJ2FwcGxpY2F0aW9uL3BrY3MxMCcsICdhcHBsaWNhdGlvbi94LXBrY3MxMCddLFxuICAgICAgICAncDEyJzogWydhcHBsaWNhdGlvbi9wa2NzLTEyJywgJ2FwcGxpY2F0aW9uL3gtcGtjczEyJ10sXG4gICAgICAgICdwN2EnOiAnYXBwbGljYXRpb24veC1wa2NzNy1zaWduYXR1cmUnLFxuICAgICAgICAncDdiJzogJ2FwcGxpY2F0aW9uL3gtcGtjczctY2VydGlmaWNhdGVzJyxcbiAgICAgICAgJ3A3Yyc6IFsnYXBwbGljYXRpb24vcGtjczctbWltZScsICdhcHBsaWNhdGlvbi94LXBrY3M3LW1pbWUnXSxcbiAgICAgICAgJ3A3bSc6IFsnYXBwbGljYXRpb24vcGtjczctbWltZScsICdhcHBsaWNhdGlvbi94LXBrY3M3LW1pbWUnXSxcbiAgICAgICAgJ3A3cic6ICdhcHBsaWNhdGlvbi94LXBrY3M3LWNlcnRyZXFyZXNwJyxcbiAgICAgICAgJ3A3cyc6IFsnYXBwbGljYXRpb24vcGtjczctc2lnbmF0dXJlJywgJ2FwcGxpY2F0aW9uL3gtcGtjczctc2lnbmF0dXJlJ10sXG4gICAgICAgICdwOCc6ICdhcHBsaWNhdGlvbi9wa2NzOCcsXG4gICAgICAgICdwYXInOiAndGV4dC9wbGFpbi1iYXMnLFxuICAgICAgICAncGFydCc6ICdhcHBsaWNhdGlvbi9wcm9fZW5nJyxcbiAgICAgICAgJ3Bhcyc6ICd0ZXh0L3Bhc2NhbCcsXG4gICAgICAgICdwYXcnOiAnYXBwbGljYXRpb24vdm5kLnBhd2FhZmlsZScsXG4gICAgICAgICdwYmQnOiAnYXBwbGljYXRpb24vdm5kLnBvd2VyYnVpbGRlcjYnLFxuICAgICAgICAncGJtJzogJ2ltYWdlL3gtcG9ydGFibGUtYml0bWFwJyxcbiAgICAgICAgJ3BjZic6ICdhcHBsaWNhdGlvbi94LWZvbnQtcGNmJyxcbiAgICAgICAgJ3BjbCc6IFsnYXBwbGljYXRpb24vdm5kLmhwLXBjbCcsICdhcHBsaWNhdGlvbi94LXBjbCddLFxuICAgICAgICAncGNseGwnOiAnYXBwbGljYXRpb24vdm5kLmhwLXBjbHhsJyxcbiAgICAgICAgJ3BjdCc6ICdpbWFnZS94LXBpY3QnLFxuICAgICAgICAncGN1cmwnOiAnYXBwbGljYXRpb24vdm5kLmN1cmwucGN1cmwnLFxuICAgICAgICAncGN4JzogJ2ltYWdlL3gtcGN4JyxcbiAgICAgICAgJ3BkYic6IFsnYXBwbGljYXRpb24vdm5kLnBhbG0nLCAnY2hlbWljYWwveC1wZGInXSxcbiAgICAgICAgJ3BkZic6ICdhcHBsaWNhdGlvbi9wZGYnLFxuICAgICAgICAncGZhJzogJ2FwcGxpY2F0aW9uL3gtZm9udC10eXBlMScsXG4gICAgICAgICdwZnInOiAnYXBwbGljYXRpb24vZm9udC10ZHBmcicsXG4gICAgICAgICdwZnVuayc6IFsnYXVkaW8vbWFrZScsICdhdWRpby9tYWtlLm15LmZ1bmsnXSxcbiAgICAgICAgJ3BmeCc6ICdhcHBsaWNhdGlvbi94LXBrY3MxMicsXG4gICAgICAgICdwZ20nOiBbJ2ltYWdlL3gtcG9ydGFibGUtZ3JheW1hcCcsICdpbWFnZS94LXBvcnRhYmxlLWdyZXltYXAnXSxcbiAgICAgICAgJ3Bnbic6ICdhcHBsaWNhdGlvbi94LWNoZXNzLXBnbicsXG4gICAgICAgICdwZ3AnOiAnYXBwbGljYXRpb24vcGdwLXNpZ25hdHVyZScsXG4gICAgICAgICdwaWMnOiBbJ2ltYWdlL3BpY3QnLCAnaW1hZ2UveC1waWN0J10sXG4gICAgICAgICdwaWN0JzogJ2ltYWdlL3BpY3QnLFxuICAgICAgICAncGtnJzogJ2FwcGxpY2F0aW9uL3gtbmV3dG9uLWNvbXBhdGlibGUtcGtnJyxcbiAgICAgICAgJ3BraSc6ICdhcHBsaWNhdGlvbi9wa2l4Y21wJyxcbiAgICAgICAgJ3BraXBhdGgnOiAnYXBwbGljYXRpb24vcGtpeC1wa2lwYXRoJyxcbiAgICAgICAgJ3Brbyc6IFsnYXBwbGljYXRpb24veW5kLm1zLXBraXBrbycsICdhcHBsaWNhdGlvbi92bmQubXMtcGtpLnBrbyddLFxuICAgICAgICAncGwnOiBbJ3RleHQvcGxhaW4nLCAndGV4dC94LXNjcmlwdC5wZXJsJ10sXG4gICAgICAgICdwbGInOiAnYXBwbGljYXRpb24vdm5kLjNncHAucGljLWJ3LWxhcmdlJyxcbiAgICAgICAgJ3BsYyc6ICdhcHBsaWNhdGlvbi92bmQubW9iaXVzLnBsYycsXG4gICAgICAgICdwbGYnOiAnYXBwbGljYXRpb24vdm5kLnBvY2tldGxlYXJuJyxcbiAgICAgICAgJ3Bscyc6ICdhcHBsaWNhdGlvbi9wbHMreG1sJyxcbiAgICAgICAgJ3BseCc6ICdhcHBsaWNhdGlvbi94LXBpeGNsc2NyaXB0JyxcbiAgICAgICAgJ3BtJzogWyd0ZXh0L3gtc2NyaXB0LnBlcmwtbW9kdWxlJywgJ2ltYWdlL3gteHBpeG1hcCddLFxuICAgICAgICAncG00JzogJ2FwcGxpY2F0aW9uL3gtcGFnZW1ha2VyJyxcbiAgICAgICAgJ3BtNSc6ICdhcHBsaWNhdGlvbi94LXBhZ2VtYWtlcicsXG4gICAgICAgICdwbWEnOiAnYXBwbGljYXRpb24veC1wZXJmbW9uJyxcbiAgICAgICAgJ3BtYyc6ICdhcHBsaWNhdGlvbi94LXBlcmZtb24nLFxuICAgICAgICAncG1sJzogWydhcHBsaWNhdGlvbi92bmQuY3RjLXBvc21sJywgJ2FwcGxpY2F0aW9uL3gtcGVyZm1vbiddLFxuICAgICAgICAncG1yJzogJ2FwcGxpY2F0aW9uL3gtcGVyZm1vbicsXG4gICAgICAgICdwbXcnOiAnYXBwbGljYXRpb24veC1wZXJmbW9uJyxcbiAgICAgICAgJ3BuZyc6ICdpbWFnZS9wbmcnLFxuICAgICAgICAncG5tJzogWydhcHBsaWNhdGlvbi94LXBvcnRhYmxlLWFueW1hcCcsICdpbWFnZS94LXBvcnRhYmxlLWFueW1hcCddLFxuICAgICAgICAncG9ydHBrZyc6ICdhcHBsaWNhdGlvbi92bmQubWFjcG9ydHMucG9ydHBrZycsXG4gICAgICAgICdwb3QnOiBbJ2FwcGxpY2F0aW9uL3ZuZC5tcy1wb3dlcnBvaW50JywgJ2FwcGxpY2F0aW9uL21zcG93ZXJwb2ludCddLFxuICAgICAgICAncG90bSc6ICdhcHBsaWNhdGlvbi92bmQubXMtcG93ZXJwb2ludC50ZW1wbGF0ZS5tYWNyb2VuYWJsZWQuMTInLFxuICAgICAgICAncG90eCc6ICdhcHBsaWNhdGlvbi92bmQub3BlbnhtbGZvcm1hdHMtb2ZmaWNlZG9jdW1lbnQucHJlc2VudGF0aW9ubWwudGVtcGxhdGUnLFxuICAgICAgICAncG92JzogJ21vZGVsL3gtcG92JyxcbiAgICAgICAgJ3BwYSc6ICdhcHBsaWNhdGlvbi92bmQubXMtcG93ZXJwb2ludCcsXG4gICAgICAgICdwcGFtJzogJ2FwcGxpY2F0aW9uL3ZuZC5tcy1wb3dlcnBvaW50LmFkZGluLm1hY3JvZW5hYmxlZC4xMicsXG4gICAgICAgICdwcGQnOiAnYXBwbGljYXRpb24vdm5kLmN1cHMtcHBkJyxcbiAgICAgICAgJ3BwbSc6ICdpbWFnZS94LXBvcnRhYmxlLXBpeG1hcCcsXG4gICAgICAgICdwcHMnOiBbJ2FwcGxpY2F0aW9uL3ZuZC5tcy1wb3dlcnBvaW50JywgJ2FwcGxpY2F0aW9uL21zcG93ZXJwb2ludCddLFxuICAgICAgICAncHBzbSc6ICdhcHBsaWNhdGlvbi92bmQubXMtcG93ZXJwb2ludC5zbGlkZXNob3cubWFjcm9lbmFibGVkLjEyJyxcbiAgICAgICAgJ3Bwc3gnOiAnYXBwbGljYXRpb24vdm5kLm9wZW54bWxmb3JtYXRzLW9mZmljZWRvY3VtZW50LnByZXNlbnRhdGlvbm1sLnNsaWRlc2hvdycsXG4gICAgICAgICdwcHQnOiBbJ2FwcGxpY2F0aW9uL3ZuZC5tcy1wb3dlcnBvaW50JywgJ2FwcGxpY2F0aW9uL21zcG93ZXJwb2ludCcsICdhcHBsaWNhdGlvbi9wb3dlcnBvaW50JywgJ2FwcGxpY2F0aW9uL3gtbXNwb3dlcnBvaW50J10sXG4gICAgICAgICdwcHRtJzogJ2FwcGxpY2F0aW9uL3ZuZC5tcy1wb3dlcnBvaW50LnByZXNlbnRhdGlvbi5tYWNyb2VuYWJsZWQuMTInLFxuICAgICAgICAncHB0eCc6ICdhcHBsaWNhdGlvbi92bmQub3BlbnhtbGZvcm1hdHMtb2ZmaWNlZG9jdW1lbnQucHJlc2VudGF0aW9ubWwucHJlc2VudGF0aW9uJyxcbiAgICAgICAgJ3Bweic6ICdhcHBsaWNhdGlvbi9tc3Bvd2VycG9pbnQnLFxuICAgICAgICAncHJjJzogJ2FwcGxpY2F0aW9uL3gtbW9iaXBvY2tldC1lYm9vaycsXG4gICAgICAgICdwcmUnOiBbJ2FwcGxpY2F0aW9uL3ZuZC5sb3R1cy1mcmVlbGFuY2UnLCAnYXBwbGljYXRpb24veC1mcmVlbGFuY2UnXSxcbiAgICAgICAgJ3ByZic6ICdhcHBsaWNhdGlvbi9waWNzLXJ1bGVzJyxcbiAgICAgICAgJ3BydCc6ICdhcHBsaWNhdGlvbi9wcm9fZW5nJyxcbiAgICAgICAgJ3BzJzogJ2FwcGxpY2F0aW9uL3Bvc3RzY3JpcHQnLFxuICAgICAgICAncHNiJzogJ2FwcGxpY2F0aW9uL3ZuZC4zZ3BwLnBpYy1idy1zbWFsbCcsXG4gICAgICAgICdwc2QnOiBbJ2FwcGxpY2F0aW9uL29jdGV0LXN0cmVhbScsICdpbWFnZS92bmQuYWRvYmUucGhvdG9zaG9wJ10sXG4gICAgICAgICdwc2YnOiAnYXBwbGljYXRpb24veC1mb250LWxpbnV4LXBzZicsXG4gICAgICAgICdwc2tjeG1sJzogJ2FwcGxpY2F0aW9uL3Bza2MreG1sJyxcbiAgICAgICAgJ3B0aWQnOiAnYXBwbGljYXRpb24vdm5kLnB2aS5wdGlkMScsXG4gICAgICAgICdwdWInOiAnYXBwbGljYXRpb24veC1tc3B1Ymxpc2hlcicsXG4gICAgICAgICdwdmInOiAnYXBwbGljYXRpb24vdm5kLjNncHAucGljLWJ3LXZhcicsXG4gICAgICAgICdwdnUnOiAncGFsZW92dS94LXB2JyxcbiAgICAgICAgJ3B3bic6ICdhcHBsaWNhdGlvbi92bmQuM20ucG9zdC1pdC1ub3RlcycsXG4gICAgICAgICdwd3onOiAnYXBwbGljYXRpb24vdm5kLm1zLXBvd2VycG9pbnQnLFxuICAgICAgICAncHknOiAndGV4dC94LXNjcmlwdC5waHl0b24nLFxuICAgICAgICAncHlhJzogJ2F1ZGlvL3ZuZC5tcy1wbGF5cmVhZHkubWVkaWEucHlhJyxcbiAgICAgICAgJ3B5Yyc6ICdhcHBsaWNhaXRvbi94LWJ5dGVjb2RlLnB5dGhvbicsXG4gICAgICAgICdweXYnOiAndmlkZW8vdm5kLm1zLXBsYXlyZWFkeS5tZWRpYS5weXYnLFxuICAgICAgICAncWFtJzogJ2FwcGxpY2F0aW9uL3ZuZC5lcHNvbi5xdWlja2FuaW1lJyxcbiAgICAgICAgJ3Fibyc6ICdhcHBsaWNhdGlvbi92bmQuaW50dS5xYm8nLFxuICAgICAgICAncWNwJzogJ2F1ZGlvL3ZuZC5xY2VscCcsXG4gICAgICAgICdxZDMnOiAneC13b3JsZC94LTNkbWYnLFxuICAgICAgICAncWQzZCc6ICd4LXdvcmxkL3gtM2RtZicsXG4gICAgICAgICdxZngnOiAnYXBwbGljYXRpb24vdm5kLmludHUucWZ4JyxcbiAgICAgICAgJ3FpZic6ICdpbWFnZS94LXF1aWNrdGltZScsXG4gICAgICAgICdxcHMnOiAnYXBwbGljYXRpb24vdm5kLnB1Ymxpc2hhcmUtZGVsdGEtdHJlZScsXG4gICAgICAgICdxdCc6ICd2aWRlby9xdWlja3RpbWUnLFxuICAgICAgICAncXRjJzogJ3ZpZGVvL3gtcXRjJyxcbiAgICAgICAgJ3F0aSc6ICdpbWFnZS94LXF1aWNrdGltZScsXG4gICAgICAgICdxdGlmJzogJ2ltYWdlL3gtcXVpY2t0aW1lJyxcbiAgICAgICAgJ3F4ZCc6ICdhcHBsaWNhdGlvbi92bmQucXVhcmsucXVhcmt4cHJlc3MnLFxuICAgICAgICAncmEnOiBbJ2F1ZGlvL3gtcmVhbGF1ZGlvJywgJ2F1ZGlvL3gtcG4tcmVhbGF1ZGlvJywgJ2F1ZGlvL3gtcG4tcmVhbGF1ZGlvLXBsdWdpbiddLFxuICAgICAgICAncmFtJzogJ2F1ZGlvL3gtcG4tcmVhbGF1ZGlvJyxcbiAgICAgICAgJ3Jhcic6ICdhcHBsaWNhdGlvbi94LXJhci1jb21wcmVzc2VkJyxcbiAgICAgICAgJ3Jhcyc6IFsnaW1hZ2UvY211LXJhc3RlcicsICdhcHBsaWNhdGlvbi94LWNtdS1yYXN0ZXInLCAnaW1hZ2UveC1jbXUtcmFzdGVyJ10sXG4gICAgICAgICdyYXN0JzogJ2ltYWdlL2NtdS1yYXN0ZXInLFxuICAgICAgICAncmNwcm9maWxlJzogJ2FwcGxpY2F0aW9uL3ZuZC5pcHVucGx1Z2dlZC5yY3Byb2ZpbGUnLFxuICAgICAgICAncmRmJzogJ2FwcGxpY2F0aW9uL3JkZit4bWwnLFxuICAgICAgICAncmR6JzogJ2FwcGxpY2F0aW9uL3ZuZC5kYXRhLXZpc2lvbi5yZHonLFxuICAgICAgICAncmVwJzogJ2FwcGxpY2F0aW9uL3ZuZC5idXNpbmVzc29iamVjdHMnLFxuICAgICAgICAncmVzJzogJ2FwcGxpY2F0aW9uL3gtZHRicmVzb3VyY2UreG1sJyxcbiAgICAgICAgJ3JleHgnOiAndGV4dC94LXNjcmlwdC5yZXh4JyxcbiAgICAgICAgJ3JmJzogJ2ltYWdlL3ZuZC5ybi1yZWFsZmxhc2gnLFxuICAgICAgICAncmdiJzogJ2ltYWdlL3gtcmdiJyxcbiAgICAgICAgJ3JpZic6ICdhcHBsaWNhdGlvbi9yZWdpbmZvK3htbCcsXG4gICAgICAgICdyaXAnOiAnYXVkaW8vdm5kLnJpcCcsXG4gICAgICAgICdybCc6ICdhcHBsaWNhdGlvbi9yZXNvdXJjZS1saXN0cyt4bWwnLFxuICAgICAgICAncmxjJzogJ2ltYWdlL3ZuZC5mdWppeGVyb3guZWRtaWNzLXJsYycsXG4gICAgICAgICdybGQnOiAnYXBwbGljYXRpb24vcmVzb3VyY2UtbGlzdHMtZGlmZit4bWwnLFxuICAgICAgICAncm0nOiBbJ2FwcGxpY2F0aW9uL3ZuZC5ybi1yZWFsbWVkaWEnLCAnYXVkaW8veC1wbi1yZWFsYXVkaW8nXSxcbiAgICAgICAgJ3JtaSc6ICdhdWRpby9taWQnLFxuICAgICAgICAncm1tJzogJ2F1ZGlvL3gtcG4tcmVhbGF1ZGlvJyxcbiAgICAgICAgJ3JtcCc6IFsnYXVkaW8veC1wbi1yZWFsYXVkaW8tcGx1Z2luJywgJ2F1ZGlvL3gtcG4tcmVhbGF1ZGlvJ10sXG4gICAgICAgICdybXMnOiAnYXBwbGljYXRpb24vdm5kLmpjcC5qYXZhbWUubWlkbGV0LXJtcycsXG4gICAgICAgICdybmMnOiAnYXBwbGljYXRpb24vcmVsYXgtbmctY29tcGFjdC1zeW50YXgnLFxuICAgICAgICAncm5nJzogWydhcHBsaWNhdGlvbi9yaW5naW5nLXRvbmVzJywgJ2FwcGxpY2F0aW9uL3ZuZC5ub2tpYS5yaW5naW5nLXRvbmUnXSxcbiAgICAgICAgJ3JueCc6ICdhcHBsaWNhdGlvbi92bmQucm4tcmVhbHBsYXllcicsXG4gICAgICAgICdyb2ZmJzogJ2FwcGxpY2F0aW9uL3gtdHJvZmYnLFxuICAgICAgICAncnAnOiAnaW1hZ2Uvdm5kLnJuLXJlYWxwaXgnLFxuICAgICAgICAncnA5JzogJ2FwcGxpY2F0aW9uL3ZuZC5jbG9hbnRvLnJwOScsXG4gICAgICAgICdycG0nOiAnYXVkaW8veC1wbi1yZWFsYXVkaW8tcGx1Z2luJyxcbiAgICAgICAgJ3Jwc3MnOiAnYXBwbGljYXRpb24vdm5kLm5va2lhLnJhZGlvLXByZXNldHMnLFxuICAgICAgICAncnBzdCc6ICdhcHBsaWNhdGlvbi92bmQubm9raWEucmFkaW8tcHJlc2V0JyxcbiAgICAgICAgJ3JxJzogJ2FwcGxpY2F0aW9uL3NwYXJxbC1xdWVyeScsXG4gICAgICAgICdycyc6ICdhcHBsaWNhdGlvbi9ybHMtc2VydmljZXMreG1sJyxcbiAgICAgICAgJ3JzZCc6ICdhcHBsaWNhdGlvbi9yc2QreG1sJyxcbiAgICAgICAgJ3J0JzogWyd0ZXh0L3JpY2h0ZXh0JywgJ3RleHQvdm5kLnJuLXJlYWx0ZXh0J10sXG4gICAgICAgICdydGYnOiBbJ2FwcGxpY2F0aW9uL3J0ZicsICd0ZXh0L3JpY2h0ZXh0JywgJ2FwcGxpY2F0aW9uL3gtcnRmJ10sXG4gICAgICAgICdydHgnOiBbJ3RleHQvcmljaHRleHQnLCAnYXBwbGljYXRpb24vcnRmJ10sXG4gICAgICAgICdydic6ICd2aWRlby92bmQucm4tcmVhbHZpZGVvJyxcbiAgICAgICAgJ3MnOiAndGV4dC94LWFzbScsXG4gICAgICAgICdzM20nOiAnYXVkaW8vczNtJyxcbiAgICAgICAgJ3NhZic6ICdhcHBsaWNhdGlvbi92bmQueWFtYWhhLnNtYWYtYXVkaW8nLFxuICAgICAgICAnc2F2ZW1lJzogJ2FwcGxpY2F0aW9uL29jdGV0LXN0cmVhbScsXG4gICAgICAgICdzYmsnOiAnYXBwbGljYXRpb24veC10Ym9vaycsXG4gICAgICAgICdzYm1sJzogJ2FwcGxpY2F0aW9uL3NibWwreG1sJyxcbiAgICAgICAgJ3NjJzogJ2FwcGxpY2F0aW9uL3ZuZC5pYm0uc2VjdXJlLWNvbnRhaW5lcicsXG4gICAgICAgICdzY2QnOiAnYXBwbGljYXRpb24veC1tc3NjaGVkdWxlJyxcbiAgICAgICAgJ3NjbSc6IFsnYXBwbGljYXRpb24vdm5kLmxvdHVzLXNjcmVlbmNhbScsICd2aWRlby94LXNjbScsICd0ZXh0L3gtc2NyaXB0Lmd1aWxlJywgJ2FwcGxpY2F0aW9uL3gtbG90dXNzY3JlZW5jYW0nLCAndGV4dC94LXNjcmlwdC5zY2hlbWUnXSxcbiAgICAgICAgJ3NjcSc6ICdhcHBsaWNhdGlvbi9zY3ZwLWN2LXJlcXVlc3QnLFxuICAgICAgICAnc2NzJzogJ2FwcGxpY2F0aW9uL3NjdnAtY3YtcmVzcG9uc2UnLFxuICAgICAgICAnc2N0JzogJ3RleHQvc2NyaXB0bGV0JyxcbiAgICAgICAgJ3NjdXJsJzogJ3RleHQvdm5kLmN1cmwuc2N1cmwnLFxuICAgICAgICAnc2RhJzogJ2FwcGxpY2F0aW9uL3ZuZC5zdGFyZGl2aXNpb24uZHJhdycsXG4gICAgICAgICdzZGMnOiAnYXBwbGljYXRpb24vdm5kLnN0YXJkaXZpc2lvbi5jYWxjJyxcbiAgICAgICAgJ3NkZCc6ICdhcHBsaWNhdGlvbi92bmQuc3RhcmRpdmlzaW9uLmltcHJlc3MnLFxuICAgICAgICAnc2RrbSc6ICdhcHBsaWNhdGlvbi92bmQuc29sZW50LnNka20reG1sJyxcbiAgICAgICAgJ3NkbWwnOiAndGV4dC9wbGFpbicsXG4gICAgICAgICdzZHAnOiBbJ2FwcGxpY2F0aW9uL3NkcCcsICdhcHBsaWNhdGlvbi94LXNkcCddLFxuICAgICAgICAnc2RyJzogJ2FwcGxpY2F0aW9uL3NvdW5kZXInLFxuICAgICAgICAnc2R3JzogJ2FwcGxpY2F0aW9uL3ZuZC5zdGFyZGl2aXNpb24ud3JpdGVyJyxcbiAgICAgICAgJ3NlYSc6IFsnYXBwbGljYXRpb24vc2VhJywgJ2FwcGxpY2F0aW9uL3gtc2VhJ10sXG4gICAgICAgICdzZWUnOiAnYXBwbGljYXRpb24vdm5kLnNlZW1haWwnLFxuICAgICAgICAnc2VlZCc6ICdhcHBsaWNhdGlvbi92bmQuZmRzbi5zZWVkJyxcbiAgICAgICAgJ3NlbWEnOiAnYXBwbGljYXRpb24vdm5kLnNlbWEnLFxuICAgICAgICAnc2VtZCc6ICdhcHBsaWNhdGlvbi92bmQuc2VtZCcsXG4gICAgICAgICdzZW1mJzogJ2FwcGxpY2F0aW9uL3ZuZC5zZW1mJyxcbiAgICAgICAgJ3Nlcic6ICdhcHBsaWNhdGlvbi9qYXZhLXNlcmlhbGl6ZWQtb2JqZWN0JyxcbiAgICAgICAgJ3NldCc6ICdhcHBsaWNhdGlvbi9zZXQnLFxuICAgICAgICAnc2V0cGF5JzogJ2FwcGxpY2F0aW9uL3NldC1wYXltZW50LWluaXRpYXRpb24nLFxuICAgICAgICAnc2V0cmVnJzogJ2FwcGxpY2F0aW9uL3NldC1yZWdpc3RyYXRpb24taW5pdGlhdGlvbicsXG4gICAgICAgICdzZmQtaGRzdHgnOiAnYXBwbGljYXRpb24vdm5kLmh5ZHJvc3RhdGl4LnNvZi1kYXRhJyxcbiAgICAgICAgJ3Nmcyc6ICdhcHBsaWNhdGlvbi92bmQuc3BvdGZpcmUuc2ZzJyxcbiAgICAgICAgJ3NnbCc6ICdhcHBsaWNhdGlvbi92bmQuc3RhcmRpdmlzaW9uLndyaXRlci1nbG9iYWwnLFxuICAgICAgICAnc2dtJzogWyd0ZXh0L3NnbWwnLCAndGV4dC94LXNnbWwnXSxcbiAgICAgICAgJ3NnbWwnOiBbJ3RleHQvc2dtbCcsICd0ZXh0L3gtc2dtbCddLFxuICAgICAgICAnc2gnOiBbJ2FwcGxpY2F0aW9uL3gtc2hhcicsICdhcHBsaWNhdGlvbi94LWJzaCcsICdhcHBsaWNhdGlvbi94LXNoJywgJ3RleHQveC1zY3JpcHQuc2gnXSxcbiAgICAgICAgJ3NoYXInOiBbJ2FwcGxpY2F0aW9uL3gtYnNoJywgJ2FwcGxpY2F0aW9uL3gtc2hhciddLFxuICAgICAgICAnc2hmJzogJ2FwcGxpY2F0aW9uL3NoZit4bWwnLFxuICAgICAgICAnc2h0bWwnOiBbJ3RleHQvaHRtbCcsICd0ZXh0L3gtc2VydmVyLXBhcnNlZC1odG1sJ10sXG4gICAgICAgICdzaWQnOiAnYXVkaW8veC1wc2lkJyxcbiAgICAgICAgJ3Npcyc6ICdhcHBsaWNhdGlvbi92bmQuc3ltYmlhbi5pbnN0YWxsJyxcbiAgICAgICAgJ3NpdCc6IFsnYXBwbGljYXRpb24veC1zdHVmZml0JywgJ2FwcGxpY2F0aW9uL3gtc2l0J10sXG4gICAgICAgICdzaXR4JzogJ2FwcGxpY2F0aW9uL3gtc3R1ZmZpdHgnLFxuICAgICAgICAnc2tkJzogJ2FwcGxpY2F0aW9uL3gta29hbicsXG4gICAgICAgICdza20nOiAnYXBwbGljYXRpb24veC1rb2FuJyxcbiAgICAgICAgJ3NrcCc6IFsnYXBwbGljYXRpb24vdm5kLmtvYW4nLCAnYXBwbGljYXRpb24veC1rb2FuJ10sXG4gICAgICAgICdza3QnOiAnYXBwbGljYXRpb24veC1rb2FuJyxcbiAgICAgICAgJ3NsJzogJ2FwcGxpY2F0aW9uL3gtc2VlbG9nbycsXG4gICAgICAgICdzbGRtJzogJ2FwcGxpY2F0aW9uL3ZuZC5tcy1wb3dlcnBvaW50LnNsaWRlLm1hY3JvZW5hYmxlZC4xMicsXG4gICAgICAgICdzbGR4JzogJ2FwcGxpY2F0aW9uL3ZuZC5vcGVueG1sZm9ybWF0cy1vZmZpY2Vkb2N1bWVudC5wcmVzZW50YXRpb25tbC5zbGlkZScsXG4gICAgICAgICdzbHQnOiAnYXBwbGljYXRpb24vdm5kLmVwc29uLnNhbHQnLFxuICAgICAgICAnc20nOiAnYXBwbGljYXRpb24vdm5kLnN0ZXBtYW5pYS5zdGVwY2hhcnQnLFxuICAgICAgICAnc21mJzogJ2FwcGxpY2F0aW9uL3ZuZC5zdGFyZGl2aXNpb24ubWF0aCcsXG4gICAgICAgICdzbWknOiBbJ2FwcGxpY2F0aW9uL3NtaWwnLCAnYXBwbGljYXRpb24vc21pbCt4bWwnXSxcbiAgICAgICAgJ3NtaWwnOiAnYXBwbGljYXRpb24vc21pbCcsXG4gICAgICAgICdzbmQnOiBbJ2F1ZGlvL2Jhc2ljJywgJ2F1ZGlvL3gtYWRwY20nXSxcbiAgICAgICAgJ3NuZic6ICdhcHBsaWNhdGlvbi94LWZvbnQtc25mJyxcbiAgICAgICAgJ3NvbCc6ICdhcHBsaWNhdGlvbi9zb2xpZHMnLFxuICAgICAgICAnc3BjJzogWyd0ZXh0L3gtc3BlZWNoJywgJ2FwcGxpY2F0aW9uL3gtcGtjczctY2VydGlmaWNhdGVzJ10sXG4gICAgICAgICdzcGYnOiAnYXBwbGljYXRpb24vdm5kLnlhbWFoYS5zbWFmLXBocmFzZScsXG4gICAgICAgICdzcGwnOiBbJ2FwcGxpY2F0aW9uL2Z1dHVyZXNwbGFzaCcsICdhcHBsaWNhdGlvbi94LWZ1dHVyZXNwbGFzaCddLFxuICAgICAgICAnc3BvdCc6ICd0ZXh0L3ZuZC5pbjNkLnNwb3QnLFxuICAgICAgICAnc3BwJzogJ2FwcGxpY2F0aW9uL3NjdnAtdnAtcmVzcG9uc2UnLFxuICAgICAgICAnc3BxJzogJ2FwcGxpY2F0aW9uL3NjdnAtdnAtcmVxdWVzdCcsXG4gICAgICAgICdzcHInOiAnYXBwbGljYXRpb24veC1zcHJpdGUnLFxuICAgICAgICAnc3ByaXRlJzogJ2FwcGxpY2F0aW9uL3gtc3ByaXRlJyxcbiAgICAgICAgJ3NyYyc6ICdhcHBsaWNhdGlvbi94LXdhaXMtc291cmNlJyxcbiAgICAgICAgJ3NydSc6ICdhcHBsaWNhdGlvbi9zcnUreG1sJyxcbiAgICAgICAgJ3NyeCc6ICdhcHBsaWNhdGlvbi9zcGFycWwtcmVzdWx0cyt4bWwnLFxuICAgICAgICAnc3NlJzogJ2FwcGxpY2F0aW9uL3ZuZC5rb2Rhay1kZXNjcmlwdG9yJyxcbiAgICAgICAgJ3NzZic6ICdhcHBsaWNhdGlvbi92bmQuZXBzb24uc3NmJyxcbiAgICAgICAgJ3NzaSc6ICd0ZXh0L3gtc2VydmVyLXBhcnNlZC1odG1sJyxcbiAgICAgICAgJ3NzbSc6ICdhcHBsaWNhdGlvbi9zdHJlYW1pbmdtZWRpYScsXG4gICAgICAgICdzc21sJzogJ2FwcGxpY2F0aW9uL3NzbWwreG1sJyxcbiAgICAgICAgJ3NzdCc6IFsnYXBwbGljYXRpb24vdm5kLm1zLXBraWNlcnRzdG9yZScsICdhcHBsaWNhdGlvbi92bmQubXMtcGtpLmNlcnRzdG9yZSddLFxuICAgICAgICAnc3QnOiAnYXBwbGljYXRpb24vdm5kLnNhaWxpbmd0cmFja2VyLnRyYWNrJyxcbiAgICAgICAgJ3N0Yyc6ICdhcHBsaWNhdGlvbi92bmQuc3VuLnhtbC5jYWxjLnRlbXBsYXRlJyxcbiAgICAgICAgJ3N0ZCc6ICdhcHBsaWNhdGlvbi92bmQuc3VuLnhtbC5kcmF3LnRlbXBsYXRlJyxcbiAgICAgICAgJ3N0ZXAnOiAnYXBwbGljYXRpb24vc3RlcCcsXG4gICAgICAgICdzdGYnOiAnYXBwbGljYXRpb24vdm5kLnd0LnN0ZicsXG4gICAgICAgICdzdGknOiAnYXBwbGljYXRpb24vdm5kLnN1bi54bWwuaW1wcmVzcy50ZW1wbGF0ZScsXG4gICAgICAgICdzdGsnOiAnYXBwbGljYXRpb24vaHlwZXJzdHVkaW8nLFxuICAgICAgICAnc3RsJzogWydhcHBsaWNhdGlvbi92bmQubXMtcGtpc3RsJywgJ2FwcGxpY2F0aW9uL3NsYScsICdhcHBsaWNhdGlvbi92bmQubXMtcGtpLnN0bCcsICdhcHBsaWNhdGlvbi94LW5hdmlzdHlsZSddLFxuICAgICAgICAnc3RtJzogJ3RleHQvaHRtbCcsXG4gICAgICAgICdzdHAnOiAnYXBwbGljYXRpb24vc3RlcCcsXG4gICAgICAgICdzdHInOiAnYXBwbGljYXRpb24vdm5kLnBnLmZvcm1hdCcsXG4gICAgICAgICdzdHcnOiAnYXBwbGljYXRpb24vdm5kLnN1bi54bWwud3JpdGVyLnRlbXBsYXRlJyxcbiAgICAgICAgJ3N1Yic6ICdpbWFnZS92bmQuZHZiLnN1YnRpdGxlJyxcbiAgICAgICAgJ3N1cyc6ICdhcHBsaWNhdGlvbi92bmQuc3VzLWNhbGVuZGFyJyxcbiAgICAgICAgJ3N2NGNwaW8nOiAnYXBwbGljYXRpb24veC1zdjRjcGlvJyxcbiAgICAgICAgJ3N2NGNyYyc6ICdhcHBsaWNhdGlvbi94LXN2NGNyYycsXG4gICAgICAgICdzdmMnOiAnYXBwbGljYXRpb24vdm5kLmR2Yi5zZXJ2aWNlJyxcbiAgICAgICAgJ3N2ZCc6ICdhcHBsaWNhdGlvbi92bmQuc3ZkJyxcbiAgICAgICAgJ3N2Zic6IFsnaW1hZ2Uvdm5kLmR3ZycsICdpbWFnZS94LWR3ZyddLFxuICAgICAgICAnc3ZnJzogJ2ltYWdlL3N2Zyt4bWwnLFxuICAgICAgICAnc3ZyJzogWyd4LXdvcmxkL3gtc3ZyJywgJ2FwcGxpY2F0aW9uL3gtd29ybGQnXSxcbiAgICAgICAgJ3N3Zic6ICdhcHBsaWNhdGlvbi94LXNob2Nrd2F2ZS1mbGFzaCcsXG4gICAgICAgICdzd2knOiAnYXBwbGljYXRpb24vdm5kLmFyaXN0YW5ldHdvcmtzLnN3aScsXG4gICAgICAgICdzeGMnOiAnYXBwbGljYXRpb24vdm5kLnN1bi54bWwuY2FsYycsXG4gICAgICAgICdzeGQnOiAnYXBwbGljYXRpb24vdm5kLnN1bi54bWwuZHJhdycsXG4gICAgICAgICdzeGcnOiAnYXBwbGljYXRpb24vdm5kLnN1bi54bWwud3JpdGVyLmdsb2JhbCcsXG4gICAgICAgICdzeGknOiAnYXBwbGljYXRpb24vdm5kLnN1bi54bWwuaW1wcmVzcycsXG4gICAgICAgICdzeG0nOiAnYXBwbGljYXRpb24vdm5kLnN1bi54bWwubWF0aCcsXG4gICAgICAgICdzeHcnOiAnYXBwbGljYXRpb24vdm5kLnN1bi54bWwud3JpdGVyJyxcbiAgICAgICAgJ3QnOiBbJ3RleHQvdHJvZmYnLCAnYXBwbGljYXRpb24veC10cm9mZiddLFxuICAgICAgICAndGFsayc6ICd0ZXh0L3gtc3BlZWNoJyxcbiAgICAgICAgJ3Rhbyc6ICdhcHBsaWNhdGlvbi92bmQudGFvLmludGVudC1tb2R1bGUtYXJjaGl2ZScsXG4gICAgICAgICd0YXInOiAnYXBwbGljYXRpb24veC10YXInLFxuICAgICAgICAndGJrJzogWydhcHBsaWNhdGlvbi90b29sYm9vaycsICdhcHBsaWNhdGlvbi94LXRib29rJ10sXG4gICAgICAgICd0Y2FwJzogJ2FwcGxpY2F0aW9uL3ZuZC4zZ3BwMi50Y2FwJyxcbiAgICAgICAgJ3RjbCc6IFsndGV4dC94LXNjcmlwdC50Y2wnLCAnYXBwbGljYXRpb24veC10Y2wnXSxcbiAgICAgICAgJ3Rjc2gnOiAndGV4dC94LXNjcmlwdC50Y3NoJyxcbiAgICAgICAgJ3RlYWNoZXInOiAnYXBwbGljYXRpb24vdm5kLnNtYXJ0LnRlYWNoZXInLFxuICAgICAgICAndGVpJzogJ2FwcGxpY2F0aW9uL3RlaSt4bWwnLFxuICAgICAgICAndGV4JzogJ2FwcGxpY2F0aW9uL3gtdGV4JyxcbiAgICAgICAgJ3RleGknOiAnYXBwbGljYXRpb24veC10ZXhpbmZvJyxcbiAgICAgICAgJ3RleGluZm8nOiAnYXBwbGljYXRpb24veC10ZXhpbmZvJyxcbiAgICAgICAgJ3RleHQnOiBbJ2FwcGxpY2F0aW9uL3BsYWluJywgJ3RleHQvcGxhaW4nXSxcbiAgICAgICAgJ3RmaSc6ICdhcHBsaWNhdGlvbi90aHJhdWQreG1sJyxcbiAgICAgICAgJ3RmbSc6ICdhcHBsaWNhdGlvbi94LXRleC10Zm0nLFxuICAgICAgICAndGd6JzogWydhcHBsaWNhdGlvbi9nbnV0YXInLCAnYXBwbGljYXRpb24veC1jb21wcmVzc2VkJ10sXG4gICAgICAgICd0aG14JzogJ2FwcGxpY2F0aW9uL3ZuZC5tcy1vZmZpY2V0aGVtZScsXG4gICAgICAgICd0aWYnOiBbJ2ltYWdlL3RpZmYnLCAnaW1hZ2UveC10aWZmJ10sXG4gICAgICAgICd0aWZmJzogWydpbWFnZS90aWZmJywgJ2ltYWdlL3gtdGlmZiddLFxuICAgICAgICAndG1vJzogJ2FwcGxpY2F0aW9uL3ZuZC50bW9iaWxlLWxpdmV0dicsXG4gICAgICAgICd0b3JyZW50JzogJ2FwcGxpY2F0aW9uL3gtYml0dG9ycmVudCcsXG4gICAgICAgICd0cGwnOiAnYXBwbGljYXRpb24vdm5kLmdyb292ZS10b29sLXRlbXBsYXRlJyxcbiAgICAgICAgJ3RwdCc6ICdhcHBsaWNhdGlvbi92bmQudHJpZC50cHQnLFxuICAgICAgICAndHInOiAnYXBwbGljYXRpb24veC10cm9mZicsXG4gICAgICAgICd0cmEnOiAnYXBwbGljYXRpb24vdm5kLnRydWVhcHAnLFxuICAgICAgICAndHJtJzogJ2FwcGxpY2F0aW9uL3gtbXN0ZXJtaW5hbCcsXG4gICAgICAgICd0c2QnOiAnYXBwbGljYXRpb24vdGltZXN0YW1wZWQtZGF0YScsXG4gICAgICAgICd0c2knOiAnYXVkaW8vdHNwLWF1ZGlvJyxcbiAgICAgICAgJ3RzcCc6IFsnYXBwbGljYXRpb24vZHNwdHlwZScsICdhdWRpby90c3BsYXllciddLFxuICAgICAgICAndHN2JzogJ3RleHQvdGFiLXNlcGFyYXRlZC12YWx1ZXMnLFxuICAgICAgICAndHRmJzogJ2FwcGxpY2F0aW9uL3gtZm9udC10dGYnLFxuICAgICAgICAndHRsJzogJ3RleHQvdHVydGxlJyxcbiAgICAgICAgJ3R1cmJvdCc6ICdpbWFnZS9mbG9yaWFuJyxcbiAgICAgICAgJ3R3ZCc6ICdhcHBsaWNhdGlvbi92bmQuc2ltdGVjaC1taW5kbWFwcGVyJyxcbiAgICAgICAgJ3R4ZCc6ICdhcHBsaWNhdGlvbi92bmQuZ2Vub21hdGl4LnR1eGVkbycsXG4gICAgICAgICd0eGYnOiAnYXBwbGljYXRpb24vdm5kLm1vYml1cy50eGYnLFxuICAgICAgICAndHh0JzogJ3RleHQvcGxhaW4nLFxuICAgICAgICAndWZkJzogJ2FwcGxpY2F0aW9uL3ZuZC51ZmRsJyxcbiAgICAgICAgJ3VpbCc6ICd0ZXh0L3gtdWlsJyxcbiAgICAgICAgJ3Vscyc6ICd0ZXh0L2l1bHMnLFxuICAgICAgICAndW1qJzogJ2FwcGxpY2F0aW9uL3ZuZC51bWFqaW4nLFxuICAgICAgICAndW5pJzogJ3RleHQvdXJpLWxpc3QnLFxuICAgICAgICAndW5pcyc6ICd0ZXh0L3VyaS1saXN0JyxcbiAgICAgICAgJ3VuaXR5d2ViJzogJ2FwcGxpY2F0aW9uL3ZuZC51bml0eScsXG4gICAgICAgICd1bnYnOiAnYXBwbGljYXRpb24vaS1kZWFzJyxcbiAgICAgICAgJ3VvbWwnOiAnYXBwbGljYXRpb24vdm5kLnVvbWwreG1sJyxcbiAgICAgICAgJ3VyaSc6ICd0ZXh0L3VyaS1saXN0JyxcbiAgICAgICAgJ3VyaXMnOiAndGV4dC91cmktbGlzdCcsXG4gICAgICAgICd1c3Rhcic6IFsnYXBwbGljYXRpb24veC11c3RhcicsICdtdWx0aXBhcnQveC11c3RhciddLFxuICAgICAgICAndXR6JzogJ2FwcGxpY2F0aW9uL3ZuZC51aXEudGhlbWUnLFxuICAgICAgICAndXUnOiBbJ2FwcGxpY2F0aW9uL29jdGV0LXN0cmVhbScsICd0ZXh0L3gtdXVlbmNvZGUnXSxcbiAgICAgICAgJ3V1ZSc6ICd0ZXh0L3gtdXVlbmNvZGUnLFxuICAgICAgICAndXZhJzogJ2F1ZGlvL3ZuZC5kZWNlLmF1ZGlvJyxcbiAgICAgICAgJ3V2aCc6ICd2aWRlby92bmQuZGVjZS5oZCcsXG4gICAgICAgICd1dmknOiAnaW1hZ2Uvdm5kLmRlY2UuZ3JhcGhpYycsXG4gICAgICAgICd1dm0nOiAndmlkZW8vdm5kLmRlY2UubW9iaWxlJyxcbiAgICAgICAgJ3V2cCc6ICd2aWRlby92bmQuZGVjZS5wZCcsXG4gICAgICAgICd1dnMnOiAndmlkZW8vdm5kLmRlY2Uuc2QnLFxuICAgICAgICAndXZ1JzogJ3ZpZGVvL3ZuZC51dnZ1Lm1wNCcsXG4gICAgICAgICd1dnYnOiAndmlkZW8vdm5kLmRlY2UudmlkZW8nLFxuICAgICAgICAndmNkJzogJ2FwcGxpY2F0aW9uL3gtY2RsaW5rJyxcbiAgICAgICAgJ3ZjZic6ICd0ZXh0L3gtdmNhcmQnLFxuICAgICAgICAndmNnJzogJ2FwcGxpY2F0aW9uL3ZuZC5ncm9vdmUtdmNhcmQnLFxuICAgICAgICAndmNzJzogJ3RleHQveC12Y2FsZW5kYXInLFxuICAgICAgICAndmN4JzogJ2FwcGxpY2F0aW9uL3ZuZC52Y3gnLFxuICAgICAgICAndmRhJzogJ2FwcGxpY2F0aW9uL3ZkYScsXG4gICAgICAgICd2ZG8nOiAndmlkZW8vdmRvJyxcbiAgICAgICAgJ3Zldyc6ICdhcHBsaWNhdGlvbi9ncm91cHdpc2UnLFxuICAgICAgICAndmlzJzogJ2FwcGxpY2F0aW9uL3ZuZC52aXNpb25hcnknLFxuICAgICAgICAndml2JzogWyd2aWRlby92aXZvJywgJ3ZpZGVvL3ZuZC52aXZvJ10sXG4gICAgICAgICd2aXZvJzogWyd2aWRlby92aXZvJywgJ3ZpZGVvL3ZuZC52aXZvJ10sXG4gICAgICAgICd2bWQnOiAnYXBwbGljYXRpb24vdm9jYWx0ZWMtbWVkaWEtZGVzYycsXG4gICAgICAgICd2bWYnOiAnYXBwbGljYXRpb24vdm9jYWx0ZWMtbWVkaWEtZmlsZScsXG4gICAgICAgICd2b2MnOiBbJ2F1ZGlvL3ZvYycsICdhdWRpby94LXZvYyddLFxuICAgICAgICAndm9zJzogJ3ZpZGVvL3Zvc2FpYycsXG4gICAgICAgICd2b3gnOiAnYXVkaW8vdm94d2FyZScsXG4gICAgICAgICd2cWUnOiAnYXVkaW8veC10d2ludnEtcGx1Z2luJyxcbiAgICAgICAgJ3ZxZic6ICdhdWRpby94LXR3aW52cScsXG4gICAgICAgICd2cWwnOiAnYXVkaW8veC10d2ludnEtcGx1Z2luJyxcbiAgICAgICAgJ3ZybWwnOiBbJ21vZGVsL3ZybWwnLCAneC13b3JsZC94LXZybWwnLCAnYXBwbGljYXRpb24veC12cm1sJ10sXG4gICAgICAgICd2cnQnOiAneC13b3JsZC94LXZydCcsXG4gICAgICAgICd2c2QnOiBbJ2FwcGxpY2F0aW9uL3ZuZC52aXNpbycsICdhcHBsaWNhdGlvbi94LXZpc2lvJ10sXG4gICAgICAgICd2c2YnOiAnYXBwbGljYXRpb24vdm5kLnZzZicsXG4gICAgICAgICd2c3QnOiAnYXBwbGljYXRpb24veC12aXNpbycsXG4gICAgICAgICd2c3cnOiAnYXBwbGljYXRpb24veC12aXNpbycsXG4gICAgICAgICd2dHUnOiAnbW9kZWwvdm5kLnZ0dScsXG4gICAgICAgICd2eG1sJzogJ2FwcGxpY2F0aW9uL3ZvaWNleG1sK3htbCcsXG4gICAgICAgICd3NjAnOiAnYXBwbGljYXRpb24vd29yZHBlcmZlY3Q2LjAnLFxuICAgICAgICAndzYxJzogJ2FwcGxpY2F0aW9uL3dvcmRwZXJmZWN0Ni4xJyxcbiAgICAgICAgJ3c2dyc6ICdhcHBsaWNhdGlvbi9tc3dvcmQnLFxuICAgICAgICAnd2FkJzogJ2FwcGxpY2F0aW9uL3gtZG9vbScsXG4gICAgICAgICd3YXYnOiBbJ2F1ZGlvL3dhdicsICdhdWRpby94LXdhdiddLFxuICAgICAgICAnd2F4JzogJ2F1ZGlvL3gtbXMtd2F4JyxcbiAgICAgICAgJ3diMSc6ICdhcHBsaWNhdGlvbi94LXFwcm8nLFxuICAgICAgICAnd2JtcCc6ICdpbWFnZS92bmQud2FwLndibXAnLFxuICAgICAgICAnd2JzJzogJ2FwcGxpY2F0aW9uL3ZuZC5jcml0aWNhbHRvb2xzLndicyt4bWwnLFxuICAgICAgICAnd2J4bWwnOiAnYXBwbGljYXRpb24vdm5kLndhcC53YnhtbCcsXG4gICAgICAgICd3Y20nOiAnYXBwbGljYXRpb24vdm5kLm1zLXdvcmtzJyxcbiAgICAgICAgJ3dkYic6ICdhcHBsaWNhdGlvbi92bmQubXMtd29ya3MnLFxuICAgICAgICAnd2ViJzogJ2FwcGxpY2F0aW9uL3ZuZC54YXJhJyxcbiAgICAgICAgJ3dlYmEnOiAnYXVkaW8vd2VibScsXG4gICAgICAgICd3ZWJtJzogJ3ZpZGVvL3dlYm0nLFxuICAgICAgICAnd2VicCc6ICdpbWFnZS93ZWJwJyxcbiAgICAgICAgJ3dnJzogJ2FwcGxpY2F0aW9uL3ZuZC5wbWkud2lkZ2V0JyxcbiAgICAgICAgJ3dndCc6ICdhcHBsaWNhdGlvbi93aWRnZXQnLFxuICAgICAgICAnd2l6JzogJ2FwcGxpY2F0aW9uL21zd29yZCcsXG4gICAgICAgICd3azEnOiAnYXBwbGljYXRpb24veC0xMjMnLFxuICAgICAgICAnd2tzJzogJ2FwcGxpY2F0aW9uL3ZuZC5tcy13b3JrcycsXG4gICAgICAgICd3bSc6ICd2aWRlby94LW1zLXdtJyxcbiAgICAgICAgJ3dtYSc6ICdhdWRpby94LW1zLXdtYScsXG4gICAgICAgICd3bWQnOiAnYXBwbGljYXRpb24veC1tcy13bWQnLFxuICAgICAgICAnd21mJzogWyd3aW5kb3dzL21ldGFmaWxlJywgJ2FwcGxpY2F0aW9uL3gtbXNtZXRhZmlsZSddLFxuICAgICAgICAnd21sJzogJ3RleHQvdm5kLndhcC53bWwnLFxuICAgICAgICAnd21sYyc6ICdhcHBsaWNhdGlvbi92bmQud2FwLndtbGMnLFxuICAgICAgICAnd21scyc6ICd0ZXh0L3ZuZC53YXAud21sc2NyaXB0JyxcbiAgICAgICAgJ3dtbHNjJzogJ2FwcGxpY2F0aW9uL3ZuZC53YXAud21sc2NyaXB0YycsXG4gICAgICAgICd3bXYnOiAndmlkZW8veC1tcy13bXYnLFxuICAgICAgICAnd214JzogJ3ZpZGVvL3gtbXMtd214JyxcbiAgICAgICAgJ3dteic6ICdhcHBsaWNhdGlvbi94LW1zLXdteicsXG4gICAgICAgICd3b2ZmJzogJ2FwcGxpY2F0aW9uL3gtZm9udC13b2ZmJyxcbiAgICAgICAgJ3dvcmQnOiAnYXBwbGljYXRpb24vbXN3b3JkJyxcbiAgICAgICAgJ3dwJzogJ2FwcGxpY2F0aW9uL3dvcmRwZXJmZWN0JyxcbiAgICAgICAgJ3dwNSc6IFsnYXBwbGljYXRpb24vd29yZHBlcmZlY3QnLCAnYXBwbGljYXRpb24vd29yZHBlcmZlY3Q2LjAnXSxcbiAgICAgICAgJ3dwNic6ICdhcHBsaWNhdGlvbi93b3JkcGVyZmVjdCcsXG4gICAgICAgICd3cGQnOiBbJ2FwcGxpY2F0aW9uL3dvcmRwZXJmZWN0JywgJ2FwcGxpY2F0aW9uL3ZuZC53b3JkcGVyZmVjdCcsICdhcHBsaWNhdGlvbi94LXdwd2luJ10sXG4gICAgICAgICd3cGwnOiAnYXBwbGljYXRpb24vdm5kLm1zLXdwbCcsXG4gICAgICAgICd3cHMnOiAnYXBwbGljYXRpb24vdm5kLm1zLXdvcmtzJyxcbiAgICAgICAgJ3dxMSc6ICdhcHBsaWNhdGlvbi94LWxvdHVzJyxcbiAgICAgICAgJ3dxZCc6ICdhcHBsaWNhdGlvbi92bmQud3FkJyxcbiAgICAgICAgJ3dyaSc6IFsnYXBwbGljYXRpb24vbXN3cml0ZScsICdhcHBsaWNhdGlvbi94LXdyaScsICdhcHBsaWNhdGlvbi94LW1zd3JpdGUnXSxcbiAgICAgICAgJ3dybCc6IFsnbW9kZWwvdnJtbCcsICd4LXdvcmxkL3gtdnJtbCcsICdhcHBsaWNhdGlvbi94LXdvcmxkJ10sXG4gICAgICAgICd3cnonOiBbJ21vZGVsL3ZybWwnLCAneC13b3JsZC94LXZybWwnXSxcbiAgICAgICAgJ3dzYyc6ICd0ZXh0L3NjcmlwbGV0JyxcbiAgICAgICAgJ3dzZGwnOiAnYXBwbGljYXRpb24vd3NkbCt4bWwnLFxuICAgICAgICAnd3Nwb2xpY3knOiAnYXBwbGljYXRpb24vd3Nwb2xpY3kreG1sJyxcbiAgICAgICAgJ3dzcmMnOiAnYXBwbGljYXRpb24veC13YWlzLXNvdXJjZScsXG4gICAgICAgICd3dGInOiAnYXBwbGljYXRpb24vdm5kLndlYnR1cmJvJyxcbiAgICAgICAgJ3d0ayc6ICdhcHBsaWNhdGlvbi94LXdpbnRhbGsnLFxuICAgICAgICAnd3Z4JzogJ3ZpZGVvL3gtbXMtd3Z4JyxcbiAgICAgICAgJ3gtcG5nJzogJ2ltYWdlL3BuZycsXG4gICAgICAgICd4M2QnOiAnYXBwbGljYXRpb24vdm5kLmh6bi0zZC1jcm9zc3dvcmQnLFxuICAgICAgICAneGFmJzogJ3gtd29ybGQveC12cm1sJyxcbiAgICAgICAgJ3hhcCc6ICdhcHBsaWNhdGlvbi94LXNpbHZlcmxpZ2h0LWFwcCcsXG4gICAgICAgICd4YXInOiAnYXBwbGljYXRpb24vdm5kLnhhcmEnLFxuICAgICAgICAneGJhcCc6ICdhcHBsaWNhdGlvbi94LW1zLXhiYXAnLFxuICAgICAgICAneGJkJzogJ2FwcGxpY2F0aW9uL3ZuZC5mdWppeGVyb3guZG9jdXdvcmtzLmJpbmRlcicsXG4gICAgICAgICd4Ym0nOiBbJ2ltYWdlL3hibScsICdpbWFnZS94LXhibScsICdpbWFnZS94LXhiaXRtYXAnXSxcbiAgICAgICAgJ3hkZic6ICdhcHBsaWNhdGlvbi94Y2FwLWRpZmYreG1sJyxcbiAgICAgICAgJ3hkbSc6ICdhcHBsaWNhdGlvbi92bmQuc3luY21sLmRtK3htbCcsXG4gICAgICAgICd4ZHAnOiAnYXBwbGljYXRpb24vdm5kLmFkb2JlLnhkcCt4bWwnLFxuICAgICAgICAneGRyJzogJ3ZpZGVvL3gtYW10LWRlbW9ydW4nLFxuICAgICAgICAneGRzc2MnOiAnYXBwbGljYXRpb24vZHNzYyt4bWwnLFxuICAgICAgICAneGR3JzogJ2FwcGxpY2F0aW9uL3ZuZC5mdWppeGVyb3guZG9jdXdvcmtzJyxcbiAgICAgICAgJ3hlbmMnOiAnYXBwbGljYXRpb24veGVuYyt4bWwnLFxuICAgICAgICAneGVyJzogJ2FwcGxpY2F0aW9uL3BhdGNoLW9wcy1lcnJvcit4bWwnLFxuICAgICAgICAneGZkZic6ICdhcHBsaWNhdGlvbi92bmQuYWRvYmUueGZkZicsXG4gICAgICAgICd4ZmRsJzogJ2FwcGxpY2F0aW9uL3ZuZC54ZmRsJyxcbiAgICAgICAgJ3hneic6ICd4Z2wvZHJhd2luZycsXG4gICAgICAgICd4aHRtbCc6ICdhcHBsaWNhdGlvbi94aHRtbCt4bWwnLFxuICAgICAgICAneGlmJzogJ2ltYWdlL3ZuZC54aWZmJyxcbiAgICAgICAgJ3hsJzogJ2FwcGxpY2F0aW9uL2V4Y2VsJyxcbiAgICAgICAgJ3hsYSc6IFsnYXBwbGljYXRpb24vdm5kLm1zLWV4Y2VsJywgJ2FwcGxpY2F0aW9uL2V4Y2VsJywgJ2FwcGxpY2F0aW9uL3gtbXNleGNlbCcsICdhcHBsaWNhdGlvbi94LWV4Y2VsJ10sXG4gICAgICAgICd4bGFtJzogJ2FwcGxpY2F0aW9uL3ZuZC5tcy1leGNlbC5hZGRpbi5tYWNyb2VuYWJsZWQuMTInLFxuICAgICAgICAneGxiJzogWydhcHBsaWNhdGlvbi9leGNlbCcsICdhcHBsaWNhdGlvbi92bmQubXMtZXhjZWwnLCAnYXBwbGljYXRpb24veC1leGNlbCddLFxuICAgICAgICAneGxjJzogWydhcHBsaWNhdGlvbi92bmQubXMtZXhjZWwnLCAnYXBwbGljYXRpb24vZXhjZWwnLCAnYXBwbGljYXRpb24veC1leGNlbCddLFxuICAgICAgICAneGxkJzogWydhcHBsaWNhdGlvbi9leGNlbCcsICdhcHBsaWNhdGlvbi94LWV4Y2VsJ10sXG4gICAgICAgICd4bGsnOiBbJ2FwcGxpY2F0aW9uL2V4Y2VsJywgJ2FwcGxpY2F0aW9uL3gtZXhjZWwnXSxcbiAgICAgICAgJ3hsbCc6IFsnYXBwbGljYXRpb24vZXhjZWwnLCAnYXBwbGljYXRpb24vdm5kLm1zLWV4Y2VsJywgJ2FwcGxpY2F0aW9uL3gtZXhjZWwnXSxcbiAgICAgICAgJ3hsbSc6IFsnYXBwbGljYXRpb24vdm5kLm1zLWV4Y2VsJywgJ2FwcGxpY2F0aW9uL2V4Y2VsJywgJ2FwcGxpY2F0aW9uL3gtZXhjZWwnXSxcbiAgICAgICAgJ3hscyc6IFsnYXBwbGljYXRpb24vdm5kLm1zLWV4Y2VsJywgJ2FwcGxpY2F0aW9uL2V4Y2VsJywgJ2FwcGxpY2F0aW9uL3gtbXNleGNlbCcsICdhcHBsaWNhdGlvbi94LWV4Y2VsJ10sXG4gICAgICAgICd4bHNiJzogJ2FwcGxpY2F0aW9uL3ZuZC5tcy1leGNlbC5zaGVldC5iaW5hcnkubWFjcm9lbmFibGVkLjEyJyxcbiAgICAgICAgJ3hsc20nOiAnYXBwbGljYXRpb24vdm5kLm1zLWV4Y2VsLnNoZWV0Lm1hY3JvZW5hYmxlZC4xMicsXG4gICAgICAgICd4bHN4JzogJ2FwcGxpY2F0aW9uL3ZuZC5vcGVueG1sZm9ybWF0cy1vZmZpY2Vkb2N1bWVudC5zcHJlYWRzaGVldG1sLnNoZWV0JyxcbiAgICAgICAgJ3hsdCc6IFsnYXBwbGljYXRpb24vdm5kLm1zLWV4Y2VsJywgJ2FwcGxpY2F0aW9uL2V4Y2VsJywgJ2FwcGxpY2F0aW9uL3gtZXhjZWwnXSxcbiAgICAgICAgJ3hsdG0nOiAnYXBwbGljYXRpb24vdm5kLm1zLWV4Y2VsLnRlbXBsYXRlLm1hY3JvZW5hYmxlZC4xMicsXG4gICAgICAgICd4bHR4JzogJ2FwcGxpY2F0aW9uL3ZuZC5vcGVueG1sZm9ybWF0cy1vZmZpY2Vkb2N1bWVudC5zcHJlYWRzaGVldG1sLnRlbXBsYXRlJyxcbiAgICAgICAgJ3hsdic6IFsnYXBwbGljYXRpb24vZXhjZWwnLCAnYXBwbGljYXRpb24veC1leGNlbCddLFxuICAgICAgICAneGx3JzogWydhcHBsaWNhdGlvbi92bmQubXMtZXhjZWwnLCAnYXBwbGljYXRpb24vZXhjZWwnLCAnYXBwbGljYXRpb24veC1tc2V4Y2VsJywgJ2FwcGxpY2F0aW9uL3gtZXhjZWwnXSxcbiAgICAgICAgJ3htJzogJ2F1ZGlvL3htJyxcbiAgICAgICAgJ3htbCc6IFsnYXBwbGljYXRpb24veG1sJywgJ3RleHQveG1sJywgJ2FwcGxpY2F0aW9uL2F0b20reG1sJywgJ2FwcGxpY2F0aW9uL3Jzcyt4bWwnXSxcbiAgICAgICAgJ3hteic6ICd4Z2wvbW92aWUnLFxuICAgICAgICAneG8nOiAnYXBwbGljYXRpb24vdm5kLm9scGMtc3VnYXInLFxuICAgICAgICAneG9mJzogJ3gtd29ybGQveC12cm1sJyxcbiAgICAgICAgJ3hvcCc6ICdhcHBsaWNhdGlvbi94b3AreG1sJyxcbiAgICAgICAgJ3hwaSc6ICdhcHBsaWNhdGlvbi94LXhwaW5zdGFsbCcsXG4gICAgICAgICd4cGl4JzogJ2FwcGxpY2F0aW9uL3gtdm5kLmxzLXhwaXgnLFxuICAgICAgICAneHBtJzogWydpbWFnZS94cG0nLCAnaW1hZ2UveC14cGl4bWFwJ10sXG4gICAgICAgICd4cHInOiAnYXBwbGljYXRpb24vdm5kLmlzLXhwcicsXG4gICAgICAgICd4cHMnOiAnYXBwbGljYXRpb24vdm5kLm1zLXhwc2RvY3VtZW50JyxcbiAgICAgICAgJ3hwdyc6ICdhcHBsaWNhdGlvbi92bmQuaW50ZXJjb24uZm9ybW5ldCcsXG4gICAgICAgICd4c2x0JzogJ2FwcGxpY2F0aW9uL3hzbHQreG1sJyxcbiAgICAgICAgJ3hzbSc6ICdhcHBsaWNhdGlvbi92bmQuc3luY21sK3htbCcsXG4gICAgICAgICd4c3BmJzogJ2FwcGxpY2F0aW9uL3hzcGYreG1sJyxcbiAgICAgICAgJ3hzcic6ICd2aWRlby94LWFtdC1zaG93cnVuJyxcbiAgICAgICAgJ3h1bCc6ICdhcHBsaWNhdGlvbi92bmQubW96aWxsYS54dWwreG1sJyxcbiAgICAgICAgJ3h3ZCc6IFsnaW1hZ2UveC14d2QnLCAnaW1hZ2UveC14d2luZG93ZHVtcCddLFxuICAgICAgICAneHl6JzogWydjaGVtaWNhbC94LXh5eicsICdjaGVtaWNhbC94LXBkYiddLFxuICAgICAgICAneWFuZyc6ICdhcHBsaWNhdGlvbi95YW5nJyxcbiAgICAgICAgJ3lpbic6ICdhcHBsaWNhdGlvbi95aW4reG1sJyxcbiAgICAgICAgJ3onOiBbJ2FwcGxpY2F0aW9uL3gtY29tcHJlc3NlZCcsICdhcHBsaWNhdGlvbi94LWNvbXByZXNzJ10sXG4gICAgICAgICd6YXonOiAnYXBwbGljYXRpb24vdm5kLnp6YXp6LmRlY2sreG1sJyxcbiAgICAgICAgJ3ppcCc6IFsnYXBwbGljYXRpb24vemlwJywgJ211bHRpcGFydC94LXppcCcsICdhcHBsaWNhdGlvbi94LXppcC1jb21wcmVzc2VkJywgJ2FwcGxpY2F0aW9uL3gtY29tcHJlc3NlZCddLFxuICAgICAgICAnemlyJzogJ2FwcGxpY2F0aW9uL3ZuZC56dWwnLFxuICAgICAgICAnem1tJzogJ2FwcGxpY2F0aW9uL3ZuZC5oYW5kaGVsZC1lbnRlcnRhaW5tZW50K3htbCcsXG4gICAgICAgICd6b28nOiAnYXBwbGljYXRpb24vb2N0ZXQtc3RyZWFtJyxcbiAgICAgICAgJ3pzaCc6ICd0ZXh0L3gtc2NyaXB0LnpzaCdcbiAgICB9XG59O1xuIiwiKGZ1bmN0aW9uIChCdWZmZXIpe1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgc3RyZWFtID0gcmVxdWlyZSgnc3RyZWFtJyk7XG52YXIgdXRpbCA9IHJlcXVpcmUoJ3V0aWwnKTtcbnZhciBUcmFuc2Zvcm0gPSBzdHJlYW0uVHJhbnNmb3JtO1xuXG4vLyBleHBvc2UgdG8gdGhlIHdvcmxkXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgICBlbmNvZGU6IGVuY29kZSxcbiAgICBkZWNvZGU6IGRlY29kZSxcbiAgICB3cmFwOiB3cmFwLFxuICAgIEVuY29kZXI6IEVuY29kZXIsXG4gICAgRGVjb2RlcjogRGVjb2RlclxufTtcblxuLyoqXG4gKiBFbmNvZGVzIGEgQnVmZmVyIGludG8gYSBRdW90ZWQtUHJpbnRhYmxlIGVuY29kZWQgc3RyaW5nXG4gKlxuICogQHBhcmFtIHtCdWZmZXJ9IGJ1ZmZlciBCdWZmZXIgdG8gY29udmVydFxuICogQHJldHVybnMge1N0cmluZ30gUXVvdGVkLVByaW50YWJsZSBlbmNvZGVkIHN0cmluZ1xuICovXG5mdW5jdGlvbiBlbmNvZGUoYnVmZmVyKSB7XG4gICAgaWYgKHR5cGVvZiBidWZmZXIgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIGJ1ZmZlciA9IG5ldyBCdWZmZXIoYnVmZmVyLCAndXRmLTgnKTtcbiAgICB9XG5cbiAgICAvLyB1c2FibGUgY2hhcmFjdGVycyB0aGF0IGRvIG5vdCBuZWVkIGVuY29kaW5nXG4gICAgdmFyIHJhbmdlcyA9IFtcbiAgICAgICAgLy8gaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzIwNDUjc2VjdGlvbi02LjdcbiAgICAgICAgWzB4MDldLCAvLyA8VEFCPlxuICAgICAgICBbMHgwQV0sIC8vIDxMRj5cbiAgICAgICAgWzB4MERdLCAvLyA8Q1I+XG4gICAgICAgIFsweDIwLCAweDNDXSwgLy8gPFNQPiFcIiMkJSYnKCkqKywtLi8wMTIzNDU2Nzg5OjtcbiAgICAgICAgWzB4M0UsIDB4N0VdIC8vID4/QEFCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaW1xcXV5fYGFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6e3x9XG4gICAgXTtcbiAgICB2YXIgcmVzdWx0ID0gJyc7XG4gICAgdmFyIG9yZDtcblxuICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBidWZmZXIubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgb3JkID0gYnVmZmVyW2ldO1xuICAgICAgICAvLyBpZiB0aGUgY2hhciBpcyBpbiBhbGxvd2VkIHJhbmdlLCB0aGVuIGtlZXAgYXMgaXMsIHVubGVzcyBpdCBpcyBhIHdzIGluIHRoZSBlbmQgb2YgYSBsaW5lXG4gICAgICAgIGlmIChjaGVja1JhbmdlcyhvcmQsIHJhbmdlcykgJiYgISgob3JkID09PSAweDIwIHx8IG9yZCA9PT0gMHgwOSkgJiYgKGkgPT09IGxlbiAtIDEgfHwgYnVmZmVyW2kgKyAxXSA9PT0gMHgwYSB8fCBidWZmZXJbaSArIDFdID09PSAweDBkKSkpIHtcbiAgICAgICAgICAgIHJlc3VsdCArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKG9yZCk7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICByZXN1bHQgKz0gJz0nICsgKG9yZCA8IDB4MTAgPyAnMCcgOiAnJykgKyBvcmQudG9TdHJpbmcoMTYpLnRvVXBwZXJDYXNlKCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cblxuLyoqXG4gKiBEZWNvZGVzIGEgUXVvdGVkLVByaW50YWJsZSBlbmNvZGVkIHN0cmluZyB0byBhIEJ1ZmZlciBvYmplY3RcbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gc3RyIFF1b3RlZC1QcmludGFibGUgZW5jb2RlZCBzdHJpbmdcbiAqIEByZXR1cm5zIHtCdWZmZXJ9IERlY29kZWQgdmFsdWVcbiAqL1xuZnVuY3Rpb24gZGVjb2RlKHN0cikge1xuICAgIHN0ciA9IChzdHIgfHwgJycpLnRvU3RyaW5nKCkuXG4gICAgICAgIC8vIHJlbW92ZSBpbnZhbGlkIHdoaXRlc3BhY2UgZnJvbSB0aGUgZW5kIG9mIGxpbmVzXG4gICAgcmVwbGFjZSgvW1xcdCBdKyQvZ20sICcnKS5cbiAgICAgICAgLy8gcmVtb3ZlIHNvZnQgbGluZSBicmVha3NcbiAgICByZXBsYWNlKC9cXD0oPzpcXHI/XFxufCQpL2csICcnKTtcblxuICAgIHZhciBlbmNvZGVkQnl0ZXNDb3VudCA9IChzdHIubWF0Y2goL1xcPVtcXGRhLWZBLUZdezJ9L2cpIHx8IFtdKS5sZW5ndGgsXG4gICAgICAgIGJ1ZmZlckxlbmd0aCA9IHN0ci5sZW5ndGggLSBlbmNvZGVkQnl0ZXNDb3VudCAqIDIsXG4gICAgICAgIGNociwgaGV4LFxuICAgICAgICBidWZmZXIgPSBuZXcgQnVmZmVyKGJ1ZmZlckxlbmd0aCksXG4gICAgICAgIGJ1ZmZlclBvcyA9IDA7XG5cbiAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gc3RyLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgIGNociA9IHN0ci5jaGFyQXQoaSk7XG4gICAgICAgIGlmIChjaHIgPT09ICc9JyAmJiAoaGV4ID0gc3RyLnN1YnN0cihpICsgMSwgMikpICYmIC9bXFxkYS1mQS1GXXsyfS8udGVzdChoZXgpKSB7XG4gICAgICAgICAgICBidWZmZXJbYnVmZmVyUG9zKytdID0gcGFyc2VJbnQoaGV4LCAxNik7XG4gICAgICAgICAgICBpICs9IDI7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBidWZmZXJbYnVmZmVyUG9zKytdID0gY2hyLmNoYXJDb2RlQXQoMCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGJ1ZmZlcjtcbn1cblxuLyoqXG4gKiBBZGRzIHNvZnQgbGluZSBicmVha3MgdG8gYSBRdW90ZWQtUHJpbnRhYmxlIHN0cmluZ1xuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBzdHIgUXVvdGVkLVByaW50YWJsZSBlbmNvZGVkIHN0cmluZyB0aGF0IG1pZ2h0IG5lZWQgbGluZSB3cmFwcGluZ1xuICogQHBhcmFtIHtOdW1iZXJ9IFtsaW5lTGVuZ3RoPTc2XSBNYXhpbXVtIGFsbG93ZWQgbGVuZ3RoIGZvciBhIGxpbmVcbiAqIEByZXR1cm5zIHtTdHJpbmd9IFNvZnQtd3JhcHBlZCBRdW90ZWQtUHJpbnRhYmxlIGVuY29kZWQgc3RyaW5nXG4gKi9cbmZ1bmN0aW9uIHdyYXAoc3RyLCBsaW5lTGVuZ3RoKSB7XG4gICAgc3RyID0gKHN0ciB8fCAnJykudG9TdHJpbmcoKTtcbiAgICBsaW5lTGVuZ3RoID0gbGluZUxlbmd0aCB8fCA3NjtcblxuICAgIGlmIChzdHIubGVuZ3RoIDw9IGxpbmVMZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIHN0cjtcbiAgICB9XG5cbiAgICB2YXIgcG9zID0gMCxcbiAgICAgICAgbGVuID0gc3RyLmxlbmd0aCxcbiAgICAgICAgbWF0Y2gsIGNvZGUsIGxpbmUsXG4gICAgICAgIGxpbmVNYXJnaW4gPSBNYXRoLmZsb29yKGxpbmVMZW5ndGggLyAzKSxcbiAgICAgICAgcmVzdWx0ID0gJyc7XG5cbiAgICAvLyBpbnNlcnQgc29mdCBsaW5lYnJlYWtzIHdoZXJlIG5lZWRlZFxuICAgIHdoaWxlIChwb3MgPCBsZW4pIHtcbiAgICAgICAgbGluZSA9IHN0ci5zdWJzdHIocG9zLCBsaW5lTGVuZ3RoKTtcbiAgICAgICAgaWYgKChtYXRjaCA9IGxpbmUubWF0Y2goL1xcclxcbi8pKSkge1xuICAgICAgICAgICAgbGluZSA9IGxpbmUuc3Vic3RyKDAsIG1hdGNoLmluZGV4ICsgbWF0Y2hbMF0ubGVuZ3RoKTtcbiAgICAgICAgICAgIHJlc3VsdCArPSBsaW5lO1xuICAgICAgICAgICAgcG9zICs9IGxpbmUubGVuZ3RoO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAobGluZS5zdWJzdHIoLTEpID09PSAnXFxuJykge1xuICAgICAgICAgICAgLy8gbm90aGluZyB0byBjaGFuZ2UgaGVyZVxuICAgICAgICAgICAgcmVzdWx0ICs9IGxpbmU7XG4gICAgICAgICAgICBwb3MgKz0gbGluZS5sZW5ndGg7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfSBlbHNlIGlmICgobWF0Y2ggPSBsaW5lLnN1YnN0cigtbGluZU1hcmdpbikubWF0Y2goL1xcbi4qPyQvKSkpIHtcbiAgICAgICAgICAgIC8vIHRydW5jYXRlIHRvIG5lYXJlc3QgbGluZSBicmVha1xuICAgICAgICAgICAgbGluZSA9IGxpbmUuc3Vic3RyKDAsIGxpbmUubGVuZ3RoIC0gKG1hdGNoWzBdLmxlbmd0aCAtIDEpKTtcbiAgICAgICAgICAgIHJlc3VsdCArPSBsaW5lO1xuICAgICAgICAgICAgcG9zICs9IGxpbmUubGVuZ3RoO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH0gZWxzZSBpZiAobGluZS5sZW5ndGggPiBsaW5lTGVuZ3RoIC0gbGluZU1hcmdpbiAmJiAobWF0Y2ggPSBsaW5lLnN1YnN0cigtbGluZU1hcmdpbikubWF0Y2goL1sgXFx0XFwuLCFcXD9dW14gXFx0XFwuLCFcXD9dKiQvKSkpIHtcbiAgICAgICAgICAgIC8vIHRydW5jYXRlIHRvIG5lYXJlc3Qgc3BhY2VcbiAgICAgICAgICAgIGxpbmUgPSBsaW5lLnN1YnN0cigwLCBsaW5lLmxlbmd0aCAtIChtYXRjaFswXS5sZW5ndGggLSAxKSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAobGluZS5tYXRjaCgvXFw9W1xcZGEtZl17MCwyfSQvaSkpIHtcblxuICAgICAgICAgICAgICAgIC8vIHB1c2ggaW5jb21wbGV0ZSBlbmNvZGluZyBzZXF1ZW5jZXMgdG8gdGhlIG5leHQgbGluZVxuICAgICAgICAgICAgICAgIGlmICgobWF0Y2ggPSBsaW5lLm1hdGNoKC9cXD1bXFxkYS1mXXswLDF9JC9pKSkpIHtcbiAgICAgICAgICAgICAgICAgICAgbGluZSA9IGxpbmUuc3Vic3RyKDAsIGxpbmUubGVuZ3RoIC0gbWF0Y2hbMF0ubGVuZ3RoKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBlbnN1cmUgdGhhdCB1dGYtOCBzZXF1ZW5jZXMgYXJlIG5vdCBzcGxpdFxuICAgICAgICAgICAgICAgIHdoaWxlIChsaW5lLmxlbmd0aCA+IDMgJiYgbGluZS5sZW5ndGggPCBsZW4gLSBwb3MgJiYgIWxpbmUubWF0Y2goL14oPzo9W1xcZGEtZl17Mn0pezEsNH0kL2kpICYmIChtYXRjaCA9IGxpbmUubWF0Y2goL1xcPVtcXGRhLWZdezJ9JC9pZykpKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvZGUgPSBwYXJzZUludChtYXRjaFswXS5zdWJzdHIoMSwgMiksIDE2KTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNvZGUgPCAxMjgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgbGluZSA9IGxpbmUuc3Vic3RyKDAsIGxpbmUubGVuZ3RoIC0gMyk7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKGNvZGUgPj0gMHhDMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAocG9zICsgbGluZS5sZW5ndGggPCBsZW4gJiYgbGluZS5zdWJzdHIoLTEpICE9PSAnXFxuJykge1xuICAgICAgICAgICAgaWYgKGxpbmUubGVuZ3RoID09PSBsaW5lTGVuZ3RoICYmIGxpbmUubWF0Y2goL1xcPVtcXGRhLWZdezJ9JC9pKSkge1xuICAgICAgICAgICAgICAgIGxpbmUgPSBsaW5lLnN1YnN0cigwLCBsaW5lLmxlbmd0aCAtIDMpO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChsaW5lLmxlbmd0aCA9PT0gbGluZUxlbmd0aCkge1xuICAgICAgICAgICAgICAgIGxpbmUgPSBsaW5lLnN1YnN0cigwLCBsaW5lLmxlbmd0aCAtIDEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcG9zICs9IGxpbmUubGVuZ3RoO1xuICAgICAgICAgICAgbGluZSArPSAnPVxcclxcbic7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBwb3MgKz0gbGluZS5sZW5ndGg7XG4gICAgICAgIH1cblxuICAgICAgICByZXN1bHQgKz0gbGluZTtcbiAgICB9XG5cbiAgICByZXR1cm4gcmVzdWx0O1xufVxuXG4vKipcbiAqIEhlbHBlciBmdW5jdGlvbiB0byBjaGVjayBpZiBhIG51bWJlciBpcyBpbnNpZGUgcHJvdmlkZWQgcmFuZ2VzXG4gKlxuICogQHBhcmFtIHtOdW1iZXJ9IG5yIE51bWJlciB0byBjaGVjayBmb3JcbiAqIEBwYXJhbSB7QXJyYXl9IHJhbmdlcyBBbiBBcnJheSBvZiBhbGxvd2VkIHZhbHVlc1xuICogQHJldHVybnMge0Jvb2xlYW59IFRydWUgaWYgdGhlIHZhbHVlIHdhcyBmb3VuZCBpbnNpZGUgYWxsb3dlZCByYW5nZXMsIGZhbHNlIG90aGVyd2lzZVxuICovXG5mdW5jdGlvbiBjaGVja1JhbmdlcyhuciwgcmFuZ2VzKSB7XG4gICAgZm9yICh2YXIgaSA9IHJhbmdlcy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICBpZiAoIXJhbmdlc1tpXS5sZW5ndGgpIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChyYW5nZXNbaV0ubGVuZ3RoID09PSAxICYmIG5yID09PSByYW5nZXNbaV1bMF0pIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChyYW5nZXNbaV0ubGVuZ3RoID09PSAyICYmIG5yID49IHJhbmdlc1tpXVswXSAmJiBuciA8PSByYW5nZXNbaV1bMV0pIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGEgdHJhbnNmb3JtIHN0cmVhbSBmb3IgZW5jb2RpbmcgZGF0YSB0byBRdW90ZWQtUHJpbnRhYmxlIGVuY29kaW5nXG4gKlxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyBTdHJlYW0gb3B0aW9uc1xuICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLmxpbmVMZW5ndGg9NzZdIE1heGltdW0gbGVuZ2h0IGZvciBsaW5lcywgc2V0IHRvIGZhbHNlIHRvIGRpc2FibGUgd3JhcHBpbmdcbiAqL1xuZnVuY3Rpb24gRW5jb2RlcihvcHRpb25zKSB7XG4gICAgLy8gaW5pdCBUcmFuc2Zvcm1cbiAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG4gICAgaWYgKHRoaXMub3B0aW9ucy5saW5lTGVuZ3RoICE9PSBmYWxzZSkge1xuICAgICAgICB0aGlzLm9wdGlvbnMubGluZUxlbmd0aCA9IHRoaXMub3B0aW9ucy5saW5lTGVuZ3RoIHx8IDc2O1xuICAgIH1cblxuICAgIHRoaXMuX2N1ckxpbmUgPSAnJztcblxuICAgIHRoaXMuaW5wdXRCeXRlcyA9IDA7XG4gICAgdGhpcy5vdXRwdXRCeXRlcyA9IDA7XG5cbiAgICBUcmFuc2Zvcm0uY2FsbCh0aGlzLCB0aGlzLm9wdGlvbnMpO1xufVxudXRpbC5pbmhlcml0cyhFbmNvZGVyLCBUcmFuc2Zvcm0pO1xuXG5FbmNvZGVyLnByb3RvdHlwZS5fdHJhbnNmb3JtID0gZnVuY3Rpb24oY2h1bmssIGVuY29kaW5nLCBkb25lKSB7XG4gICAgdmFyIHFwLCBfc2VsZiA9IHRoaXM7XG5cbiAgICBpZiAoZW5jb2RpbmcgIT09ICdidWZmZXInKSB7XG4gICAgICAgIGNodW5rID0gbmV3IEJ1ZmZlcihjaHVuaywgZW5jb2RpbmcpO1xuICAgIH1cblxuICAgIGlmICghY2h1bmsgfHwgIWNodW5rLmxlbmd0aCkge1xuICAgICAgICByZXR1cm4gZG9uZSgpO1xuICAgIH1cblxuICAgIHRoaXMuaW5wdXRCeXRlcyArPSBjaHVuay5sZW5ndGg7XG5cbiAgICBpZiAodGhpcy5vcHRpb25zLmxpbmVMZW5ndGgpIHtcbiAgICAgICAgcXAgPSB0aGlzLl9jdXJMaW5lICsgZW5jb2RlKGNodW5rKTtcbiAgICAgICAgcXAgPSB3cmFwKHFwLCB0aGlzLm9wdGlvbnMubGluZUxlbmd0aCk7XG4gICAgICAgIHFwID0gcXAucmVwbGFjZSgvKF58XFxuKShbXlxcbl0qKSQvLCBmdW5jdGlvbihtYXRjaCwgbGluZUJyZWFrLCBsYXN0TGluZSkge1xuICAgICAgICAgICAgX3NlbGYuX2N1ckxpbmUgPSBsYXN0TGluZTtcbiAgICAgICAgICAgIHJldHVybiBsaW5lQnJlYWs7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGlmIChxcCkge1xuICAgICAgICAgICAgdGhpcy5vdXRwdXRCeXRlcyArPSBxcC5sZW5ndGg7XG4gICAgICAgICAgICB0aGlzLnB1c2gocXApO1xuICAgICAgICB9XG5cbiAgICB9IGVsc2Uge1xuICAgICAgICBxcCA9IGVuY29kZShjaHVuayk7XG4gICAgICAgIHRoaXMub3V0cHV0Qnl0ZXMgKz0gcXAubGVuZ3RoO1xuICAgICAgICB0aGlzLnB1c2gocXAsICdhc2NpaScpO1xuICAgIH1cblxuICAgIGRvbmUoKTtcbn07XG5cbkVuY29kZXIucHJvdG90eXBlLl9mbHVzaCA9IGZ1bmN0aW9uKGRvbmUpIHtcbiAgICBpZiAodGhpcy5fY3VyTGluZSkge1xuICAgICAgICB0aGlzLm91dHB1dEJ5dGVzICs9IHRoaXMuX2N1ckxpbmUubGVuZ3RoO1xuICAgICAgICB0aGlzLnB1c2godGhpcy5fY3VyTGluZSwgJ2FzY2lpJyk7XG4gICAgfVxuICAgIGRvbmUoKTtcbn07XG5cbi8qKlxuICogQ3JlYXRlcyBhIHRyYW5zZm9ybSBzdHJlYW0gZm9yIGRlY29kaW5nIFF1b3RlZC1QcmludGFibGUgZW5jb2RlZCBzdHJpbmdzXG4gKlxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyBTdHJlYW0gb3B0aW9uc1xuICovXG5mdW5jdGlvbiBEZWNvZGVyKG9wdGlvbnMpIHtcbiAgICAvLyBpbml0IFRyYW5zZm9ybVxuICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gICAgdGhpcy5fY3VyTGluZSA9ICcnO1xuXG4gICAgdGhpcy5pbnB1dEJ5dGVzID0gMDtcbiAgICB0aGlzLm91dHB1dEJ5dGVzID0gMDtcblxuICAgIFRyYW5zZm9ybS5jYWxsKHRoaXMsIHRoaXMub3B0aW9ucyk7XG59XG51dGlsLmluaGVyaXRzKERlY29kZXIsIFRyYW5zZm9ybSk7XG5cbkRlY29kZXIucHJvdG90eXBlLl90cmFuc2Zvcm0gPSBmdW5jdGlvbihjaHVuaywgZW5jb2RpbmcsIGRvbmUpIHtcbiAgICB2YXIgcXAsIGJ1ZiwgX3NlbGYgPSB0aGlzO1xuXG4gICAgY2h1bmsgPSBjaHVuay50b1N0cmluZygnYXNjaWknKTtcblxuICAgIGlmICghY2h1bmsgfHwgIWNodW5rLmxlbmd0aCkge1xuICAgICAgICByZXR1cm4gZG9uZSgpO1xuICAgIH1cblxuICAgIHRoaXMuaW5wdXRCeXRlcyArPSBjaHVuay5sZW5ndGg7XG5cbiAgICBxcCA9ICh0aGlzLl9jdXJMaW5lICsgY2h1bmspO1xuICAgIHRoaXMuX2N1ckxpbmUgPSAnJztcbiAgICBxcCA9IHFwLnJlcGxhY2UoLz1bXlxcbl0/JC8sIGZ1bmN0aW9uKGxhc3RMaW5lKSB7XG4gICAgICAgIF9zZWxmLl9jdXJMaW5lID0gbGFzdExpbmU7XG4gICAgICAgIHJldHVybiAnJztcbiAgICB9KTtcblxuICAgIGlmIChxcCkge1xuICAgICAgICBidWYgPSBkZWNvZGUocXApO1xuICAgICAgICB0aGlzLm91dHB1dEJ5dGVzICs9IGJ1Zi5sZW5ndGg7XG4gICAgICAgIHRoaXMucHVzaChidWYpO1xuICAgIH1cblxuICAgIGRvbmUoKTtcbn07XG5cbkRlY29kZXIucHJvdG90eXBlLl9mbHVzaCA9IGZ1bmN0aW9uKGRvbmUpIHtcbiAgICB2YXIgcXAsIGJ1ZjtcbiAgICBpZiAodGhpcy5fY3VyTGluZSkge1xuICAgICAgICBidWYgPSBkZWNvZGUodGhpcy5fY3VyTGluZSk7XG4gICAgICAgIHRoaXMub3V0cHV0Qnl0ZXMgKz0gYnVmLmxlbmd0aDtcbiAgICAgICAgdGhpcy5wdXNoKGJ1Zik7XG4gICAgfVxuICAgIGRvbmUoKTtcbn07XG59KS5jYWxsKHRoaXMscmVxdWlyZShcImJ1ZmZlclwiKS5CdWZmZXIpIiwiKGZ1bmN0aW9uIChCdWZmZXIpe1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgQnVpbGRNYWlsID0gcmVxdWlyZSgnYnVpbGRtYWlsJyk7XG52YXIgbGlibWltZSA9IHJlcXVpcmUoJ2xpYm1pbWUnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAobWFpbCkge1xuICAgIHJldHVybiBuZXcgTWFpbENvbXBvc2VyKG1haWwpLmNvbXBpbGUoKTtcbn07XG5cbm1vZHVsZS5leHBvcnRzLk1haWxDb21wb3NlciA9IE1haWxDb21wb3NlcjtcblxuLyoqXG4gKiBDcmVhdGVzIHRoZSBvYmplY3QgZm9yIGNvbXBvc2luZyBhIEJ1aWxkTWFpbCBpbnN0YW5jZSBvdXQgZnJvbSB0aGUgbWFpbCBvcHRpb25zXG4gKlxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge09iamVjdH0gbWFpbCBNYWlsIG9wdGlvbnNcbiAqL1xuZnVuY3Rpb24gTWFpbENvbXBvc2VyKG1haWwpIHtcbiAgICBpZiAoISh0aGlzIGluc3RhbmNlb2YgTWFpbENvbXBvc2VyKSkge1xuICAgICAgICByZXR1cm4gbmV3IE1haWxDb21wb3NlcihtYWlsKTtcbiAgICB9XG5cbiAgICB0aGlzLm1haWwgPSBtYWlsIHx8IHt9O1xuICAgIHRoaXMubWVzc2FnZSA9IGZhbHNlO1xufVxuXG4vKipcbiAqIEJ1aWxkcyBCdWlsZE1haWwgaW5zdGFuY2VcbiAqL1xuTWFpbENvbXBvc2VyLnByb3RvdHlwZS5jb21waWxlID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuX2FsdGVybmF0aXZlcyA9IHRoaXMuX2dldEFsdGVybmF0aXZlcygpO1xuICAgIHRoaXMuX2h0bWxOb2RlID0gdGhpcy5fYWx0ZXJuYXRpdmVzLmZpbHRlcihmdW5jdGlvbiAoYWx0ZXJuYXRpdmUpIHtcbiAgICAgICAgcmV0dXJuIC9edGV4dFxcL2h0bWxcXGIvaS50ZXN0KGFsdGVybmF0aXZlLmNvbnRlbnRUeXBlKTtcbiAgICB9KS5wb3AoKTtcbiAgICB0aGlzLl9hdHRhY2htZW50cyA9IHRoaXMuX2dldEF0dGFjaG1lbnRzKCEhdGhpcy5faHRtbE5vZGUpO1xuXG4gICAgdGhpcy5fdXNlUmVsYXRlZCA9ICEhKHRoaXMuX2h0bWxOb2RlICYmIHRoaXMuX2F0dGFjaG1lbnRzLnJlbGF0ZWQubGVuZ3RoKTtcbiAgICB0aGlzLl91c2VBbHRlcm5hdGl2ZSA9IHRoaXMuX2FsdGVybmF0aXZlcy5sZW5ndGggPiAxO1xuICAgIHRoaXMuX3VzZU1peGVkID0gdGhpcy5fYXR0YWNobWVudHMuYXR0YWNoZWQubGVuZ3RoID4gMSB8fCAodGhpcy5fYWx0ZXJuYXRpdmVzLmxlbmd0aCAmJiB0aGlzLl9hdHRhY2htZW50cy5hdHRhY2hlZC5sZW5ndGggPT09IDEpO1xuXG4gICAgLy8gQ29tcG9zZSBNSU1FIHRyZWVcbiAgICBpZiAodGhpcy5tYWlsLnJhdykge1xuICAgICAgICB0aGlzLm1lc3NhZ2UgPSBuZXcgQnVpbGRNYWlsKCkuc2V0UmF3KHRoaXMubWFpbC5yYXcpO1xuICAgIH0gZWxzZSBpZiAodGhpcy5fdXNlTWl4ZWQpIHtcbiAgICAgICAgdGhpcy5tZXNzYWdlID0gdGhpcy5fY3JlYXRlTWl4ZWQoKTtcbiAgICB9IGVsc2UgaWYgKHRoaXMuX3VzZUFsdGVybmF0aXZlKSB7XG4gICAgICAgIHRoaXMubWVzc2FnZSA9IHRoaXMuX2NyZWF0ZUFsdGVybmF0aXZlKCk7XG4gICAgfSBlbHNlIGlmICh0aGlzLl91c2VSZWxhdGVkKSB7XG4gICAgICAgIHRoaXMubWVzc2FnZSA9IHRoaXMuX2NyZWF0ZVJlbGF0ZWQoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLm1lc3NhZ2UgPSB0aGlzLl9jcmVhdGVDb250ZW50Tm9kZShmYWxzZSwgW10uY29uY2F0KHRoaXMuX2FsdGVybmF0aXZlcyB8fCBbXSkuY29uY2F0KHRoaXMuX2F0dGFjaG1lbnRzLmF0dGFjaGVkIHx8IFtdKS5zaGlmdCgpIHx8IHtcbiAgICAgICAgICAgIGNvbnRlbnRUeXBlOiAndGV4dC9wbGFpbicsXG4gICAgICAgICAgICBjb250ZW50OiAnJ1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICAvLyBBZGQgY3VzdG9tIGhlYWRlcnNcbiAgICBpZiAodGhpcy5tYWlsLmhlYWRlcnMpIHtcbiAgICAgICAgdGhpcy5tZXNzYWdlLmFkZEhlYWRlcih0aGlzLm1haWwuaGVhZGVycyk7XG4gICAgfVxuXG4gICAgLy8gQWRkIGhlYWRlcnMgdG8gdGhlIHJvb3Qgbm9kZSwgYWx3YXlzIG92ZXJyaWRlcyBjdXN0b20gaGVhZGVyc1xuICAgIFtcbiAgICAgICAgJ2Zyb20nLFxuICAgICAgICAnc2VuZGVyJyxcbiAgICAgICAgJ3RvJyxcbiAgICAgICAgJ2NjJyxcbiAgICAgICAgJ2JjYycsXG4gICAgICAgICdyZXBseS10bycsXG4gICAgICAgICdpbi1yZXBseS10bycsXG4gICAgICAgICdyZWZlcmVuY2VzJyxcbiAgICAgICAgJ3N1YmplY3QnLFxuICAgICAgICAnbWVzc2FnZS1pZCcsXG4gICAgICAgICdkYXRlJ1xuICAgIF0uZm9yRWFjaChmdW5jdGlvbiAoaGVhZGVyKSB7XG4gICAgICAgIHZhciBrZXkgPSBoZWFkZXIucmVwbGFjZSgvLShcXHcpL2csIGZ1bmN0aW9uIChvLCBjKSB7XG4gICAgICAgICAgICByZXR1cm4gYy50b1VwcGVyQ2FzZSgpO1xuICAgICAgICB9KTtcbiAgICAgICAgaWYgKHRoaXMubWFpbFtrZXldKSB7XG4gICAgICAgICAgICB0aGlzLm1lc3NhZ2Uuc2V0SGVhZGVyKGhlYWRlciwgdGhpcy5tYWlsW2tleV0pO1xuICAgICAgICB9XG4gICAgfS5iaW5kKHRoaXMpKTtcblxuICAgIC8vIFNldHMgY3VzdG9tIGVudmVsb3BlXG4gICAgaWYgKHRoaXMubWFpbC5lbnZlbG9wZSkge1xuICAgICAgICB0aGlzLm1lc3NhZ2Uuc2V0RW52ZWxvcGUodGhpcy5tYWlsLmVudmVsb3BlKTtcbiAgICB9XG5cbiAgICAvLyBlbnN1cmUgTWVzc2FnZS1JZCB2YWx1ZVxuICAgIHRoaXMubWVzc2FnZS5tZXNzYWdlSWQoKTtcblxuICAgIHJldHVybiB0aGlzLm1lc3NhZ2U7XG59O1xuXG4vKipcbiAqIEJ1aWxkcyBtdWx0aXBhcnQvbWl4ZWQgbm9kZS4gSXQgc2hvdWxkIGFsd2F5cyBjb250YWluIGRpZmZlcmVudCB0eXBlIG9mIGVsZW1lbnRzIG9uIHRoZSBzYW1lIGxldmVsXG4gKiBlZy4gdGV4dCArIGF0dGFjaG1lbnRzXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHBhcmVudE5vZGUgUGFyZW50IGZvciB0aGlzIG5vdGUuIElmIGl0IGRvZXMgbm90IGV4aXN0LCBhIHJvb3Qgbm9kZSBpcyBjcmVhdGVkXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBCdWlsZE1haWwgbm9kZSBlbGVtZW50XG4gKi9cbk1haWxDb21wb3Nlci5wcm90b3R5cGUuX2NyZWF0ZU1peGVkID0gZnVuY3Rpb24gKHBhcmVudE5vZGUpIHtcbiAgICB2YXIgbm9kZTtcblxuICAgIGlmICghcGFyZW50Tm9kZSkge1xuICAgICAgICBub2RlID0gbmV3IEJ1aWxkTWFpbCgnbXVsdGlwYXJ0L21peGVkJywge1xuICAgICAgICAgICAgYmFzZUJvdW5kYXJ5OiB0aGlzLm1haWwuYmFzZUJvdW5kYXJ5LFxuICAgICAgICAgICAgdGV4dEVuY29kaW5nOiB0aGlzLm1haWwudGV4dEVuY29kaW5nXG4gICAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIG5vZGUgPSBwYXJlbnROb2RlLmNyZWF0ZUNoaWxkKCdtdWx0aXBhcnQvbWl4ZWQnKTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5fdXNlQWx0ZXJuYXRpdmUpIHtcbiAgICAgICAgdGhpcy5fY3JlYXRlQWx0ZXJuYXRpdmUobm9kZSk7XG4gICAgfSBlbHNlIGlmICh0aGlzLl91c2VSZWxhdGVkKSB7XG4gICAgICAgIHRoaXMuX2NyZWF0ZVJlbGF0ZWQobm9kZSk7XG4gICAgfVxuXG4gICAgW10uY29uY2F0KCF0aGlzLl91c2VBbHRlcm5hdGl2ZSAmJiB0aGlzLl9hbHRlcm5hdGl2ZXMgfHwgW10pLmNvbmNhdCh0aGlzLl9hdHRhY2htZW50cy5hdHRhY2hlZCB8fCBbXSkuZm9yRWFjaChmdW5jdGlvbiAoZWxlbWVudCkge1xuICAgICAgICAvLyBpZiB0aGUgZWxlbWVudCBpcyBhIGh0bWwgbm9kZSBmcm9tIHJlbGF0ZWQgc3VicGFydCB0aGVuIGlnbm9yZSBpdFxuICAgICAgICBpZiAoIXRoaXMuX3VzZVJlbGF0ZWQgfHwgZWxlbWVudCAhPT0gdGhpcy5faHRtbE5vZGUpIHtcbiAgICAgICAgICAgIHRoaXMuX2NyZWF0ZUNvbnRlbnROb2RlKG5vZGUsIGVsZW1lbnQpO1xuICAgICAgICB9XG4gICAgfS5iaW5kKHRoaXMpKTtcblxuICAgIHJldHVybiBub2RlO1xufTtcblxuLyoqXG4gKiBCdWlsZHMgbXVsdGlwYXJ0L2FsdGVybmF0aXZlIG5vZGUuIEl0IHNob3VsZCBhbHdheXMgY29udGFpbiBzYW1lIHR5cGUgb2YgZWxlbWVudHMgb24gdGhlIHNhbWUgbGV2ZWxcbiAqIGVnLiB0ZXh0ICsgaHRtbCB2aWV3IG9mIHRoZSBzYW1lIGRhdGFcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gcGFyZW50Tm9kZSBQYXJlbnQgZm9yIHRoaXMgbm90ZS4gSWYgaXQgZG9lcyBub3QgZXhpc3QsIGEgcm9vdCBub2RlIGlzIGNyZWF0ZWRcbiAqIEByZXR1cm5zIHtPYmplY3R9IEJ1aWxkTWFpbCBub2RlIGVsZW1lbnRcbiAqL1xuTWFpbENvbXBvc2VyLnByb3RvdHlwZS5fY3JlYXRlQWx0ZXJuYXRpdmUgPSBmdW5jdGlvbiAocGFyZW50Tm9kZSkge1xuICAgIHZhciBub2RlO1xuXG4gICAgaWYgKCFwYXJlbnROb2RlKSB7XG4gICAgICAgIG5vZGUgPSBuZXcgQnVpbGRNYWlsKCdtdWx0aXBhcnQvYWx0ZXJuYXRpdmUnLCB7XG4gICAgICAgICAgICBiYXNlQm91bmRhcnk6IHRoaXMubWFpbC5iYXNlQm91bmRhcnksXG4gICAgICAgICAgICB0ZXh0RW5jb2Rpbmc6IHRoaXMubWFpbC50ZXh0RW5jb2RpbmdcbiAgICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgbm9kZSA9IHBhcmVudE5vZGUuY3JlYXRlQ2hpbGQoJ211bHRpcGFydC9hbHRlcm5hdGl2ZScpO1xuICAgIH1cblxuICAgIHRoaXMuX2FsdGVybmF0aXZlcy5mb3JFYWNoKGZ1bmN0aW9uIChhbHRlcm5hdGl2ZSkge1xuICAgICAgICBpZiAodGhpcy5fdXNlUmVsYXRlZCAmJiB0aGlzLl9odG1sTm9kZSA9PT0gYWx0ZXJuYXRpdmUpIHtcbiAgICAgICAgICAgIHRoaXMuX2NyZWF0ZVJlbGF0ZWQobm9kZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLl9jcmVhdGVDb250ZW50Tm9kZShub2RlLCBhbHRlcm5hdGl2ZSk7XG4gICAgICAgIH1cbiAgICB9LmJpbmQodGhpcykpO1xuXG4gICAgcmV0dXJuIG5vZGU7XG59O1xuXG4vKipcbiAqIEJ1aWxkcyBtdWx0aXBhcnQvcmVsYXRlZCBub2RlLiBJdCBzaG91bGQgYWx3YXlzIGNvbnRhaW4gaHRtbCBub2RlIHdpdGggcmVsYXRlZCBhdHRhY2htZW50c1xuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBwYXJlbnROb2RlIFBhcmVudCBmb3IgdGhpcyBub3RlLiBJZiBpdCBkb2VzIG5vdCBleGlzdCwgYSByb290IG5vZGUgaXMgY3JlYXRlZFxuICogQHJldHVybnMge09iamVjdH0gQnVpbGRNYWlsIG5vZGUgZWxlbWVudFxuICovXG5NYWlsQ29tcG9zZXIucHJvdG90eXBlLl9jcmVhdGVSZWxhdGVkID0gZnVuY3Rpb24gKHBhcmVudE5vZGUpIHtcbiAgICB2YXIgbm9kZTtcblxuICAgIGlmICghcGFyZW50Tm9kZSkge1xuICAgICAgICBub2RlID0gbmV3IEJ1aWxkTWFpbCgnbXVsdGlwYXJ0L3JlbGF0ZWQ7IHR5cGU9XCJ0ZXh0L2h0bWxcIicsIHtcbiAgICAgICAgICAgIGJhc2VCb3VuZGFyeTogdGhpcy5tYWlsLmJhc2VCb3VuZGFyeSxcbiAgICAgICAgICAgIHRleHRFbmNvZGluZzogdGhpcy5tYWlsLnRleHRFbmNvZGluZ1xuICAgICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBub2RlID0gcGFyZW50Tm9kZS5jcmVhdGVDaGlsZCgnbXVsdGlwYXJ0L3JlbGF0ZWQ7IHR5cGU9XCJ0ZXh0L2h0bWxcIicpO1xuICAgIH1cblxuICAgIHRoaXMuX2NyZWF0ZUNvbnRlbnROb2RlKG5vZGUsIHRoaXMuX2h0bWxOb2RlKTtcblxuICAgIHRoaXMuX2F0dGFjaG1lbnRzLnJlbGF0ZWQuZm9yRWFjaChmdW5jdGlvbiAoYWx0ZXJuYXRpdmUpIHtcbiAgICAgICAgdGhpcy5fY3JlYXRlQ29udGVudE5vZGUobm9kZSwgYWx0ZXJuYXRpdmUpO1xuICAgIH0uYmluZCh0aGlzKSk7XG5cbiAgICByZXR1cm4gbm9kZTtcbn07XG5cbi8qKlxuICogQ3JlYXRlcyBhIHJlZ3VsYXIgbm9kZSB3aXRoIGNvbnRlbnRzXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHBhcmVudE5vZGUgUGFyZW50IGZvciB0aGlzIG5vdGUuIElmIGl0IGRvZXMgbm90IGV4aXN0LCBhIHJvb3Qgbm9kZSBpcyBjcmVhdGVkXG4gKiBAcGFyYW0ge09iamVjdH0gZWxlbWVudCBOb2RlIGRhdGFcbiAqIEByZXR1cm5zIHtPYmplY3R9IEJ1aWxkTWFpbCBub2RlIGVsZW1lbnRcbiAqL1xuTWFpbENvbXBvc2VyLnByb3RvdHlwZS5fY3JlYXRlQ29udGVudE5vZGUgPSBmdW5jdGlvbiAocGFyZW50Tm9kZSwgZWxlbWVudCkge1xuICAgIGVsZW1lbnQgPSBlbGVtZW50IHx8IHt9O1xuICAgIGVsZW1lbnQuY29udGVudCA9IGVsZW1lbnQuY29udGVudCB8fCAnJztcblxuICAgIHZhciBub2RlO1xuICAgIHZhciBlbmNvZGluZyA9IChlbGVtZW50LmVuY29kaW5nIHx8ICd1dGY4JylcbiAgICAgICAgLnRvU3RyaW5nKClcbiAgICAgICAgLnRvTG93ZXJDYXNlKClcbiAgICAgICAgLnJlcGxhY2UoL1stX1xcc10vZywgJycpO1xuXG4gICAgaWYgKCFwYXJlbnROb2RlKSB7XG4gICAgICAgIG5vZGUgPSBuZXcgQnVpbGRNYWlsKGVsZW1lbnQuY29udGVudFR5cGUsIHtcbiAgICAgICAgICAgIGZpbGVuYW1lOiBlbGVtZW50LmZpbGVuYW1lLFxuICAgICAgICAgICAgYmFzZUJvdW5kYXJ5OiB0aGlzLm1haWwuYmFzZUJvdW5kYXJ5LFxuICAgICAgICAgICAgdGV4dEVuY29kaW5nOiB0aGlzLm1haWwudGV4dEVuY29kaW5nXG4gICAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIG5vZGUgPSBwYXJlbnROb2RlLmNyZWF0ZUNoaWxkKGVsZW1lbnQuY29udGVudFR5cGUsIHtcbiAgICAgICAgICAgIGZpbGVuYW1lOiBlbGVtZW50LmZpbGVuYW1lXG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIC8vIGFkZCBjdXN0b20gaGVhZGVyc1xuICAgIGlmIChlbGVtZW50LmhlYWRlcnMpIHtcbiAgICAgICAgbm9kZS5hZGRIZWFkZXIoZWxlbWVudC5oZWFkZXJzKTtcbiAgICB9XG5cbiAgICBpZiAoZWxlbWVudC5jaWQpIHtcbiAgICAgICAgbm9kZS5zZXRIZWFkZXIoJ0NvbnRlbnQtSWQnLCAnPCcgKyBlbGVtZW50LmNpZC5yZXBsYWNlKC9bPD5dL2csICcnKSArICc+Jyk7XG4gICAgfVxuXG4gICAgaWYgKGVsZW1lbnQuY29udGVudFRyYW5zZmVyRW5jb2RpbmcpIHtcbiAgICAgICAgbm9kZS5zZXRIZWFkZXIoJ0NvbnRlbnQtVHJhbnNmZXItRW5jb2RpbmcnLCBlbGVtZW50LmNvbnRlbnRUcmFuc2ZlckVuY29kaW5nKTtcbiAgICB9IGVsc2UgaWYgKHRoaXMubWFpbC5lbmNvZGluZyAmJiAvXnRleHRcXC8vaS50ZXN0KGVsZW1lbnQuY29udGVudFR5cGUpKSB7XG4gICAgICAgIG5vZGUuc2V0SGVhZGVyKCdDb250ZW50LVRyYW5zZmVyLUVuY29kaW5nJywgdGhpcy5tYWlsLmVuY29kaW5nKTtcbiAgICB9XG5cbiAgICBpZiAoIS9edGV4dFxcLy9pLnRlc3QoZWxlbWVudC5jb250ZW50VHlwZSkgfHwgZWxlbWVudC5jb250ZW50RGlzcG9zaXRpb24pIHtcbiAgICAgICAgbm9kZS5zZXRIZWFkZXIoJ0NvbnRlbnQtRGlzcG9zaXRpb24nLCBlbGVtZW50LmNvbnRlbnREaXNwb3NpdGlvbiB8fCAnYXR0YWNobWVudCcpO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2YgZWxlbWVudC5jb250ZW50ID09PSAnc3RyaW5nJyAmJiBbJ3V0ZjgnLCAndXNhc2NpaScsICdhc2NpaSddLmluZGV4T2YoZW5jb2RpbmcpIDwgMCkge1xuICAgICAgICBlbGVtZW50LmNvbnRlbnQgPSBuZXcgQnVmZmVyKGVsZW1lbnQuY29udGVudCwgZW5jb2RpbmcpO1xuICAgIH1cblxuICAgIC8vIHByZWZlciBwcmVnZW5lcmF0ZWQgcmF3IGNvbnRlbnRcbiAgICBpZiAoZWxlbWVudC5yYXcpIHtcbiAgICAgICAgbm9kZS5zZXRSYXcoZWxlbWVudC5yYXcpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIG5vZGUuc2V0Q29udGVudChlbGVtZW50LmNvbnRlbnQpO1xuICAgIH1cblxuICAgIHJldHVybiBub2RlO1xufTtcblxuLyoqXG4gKiBMaXN0IGFsbCBhdHRhY2htZW50cy4gUmVzdWx0aW5nIGF0dGFjaG1lbnQgb2JqZWN0cyBjYW4gYmUgdXNlZCBhcyBpbnB1dCBmb3IgQnVpbGRNYWlsIG5vZGVzXG4gKlxuICogQHBhcmFtIHtCb29sZWFufSBmaW5kUmVsYXRlZCBJZiB0cnVlIHNlcGFyYXRlIHJlbGF0ZWQgYXR0YWNobWVudHMgZnJvbSBhdHRhY2hlZCBvbmVzXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBBbiBvYmplY3Qgb2YgYXJyYXlzIChgcmVsYXRlZGAgYW5kIGBhdHRhY2hlZGApXG4gKi9cbk1haWxDb21wb3Nlci5wcm90b3R5cGUuX2dldEF0dGFjaG1lbnRzID0gZnVuY3Rpb24gKGZpbmRSZWxhdGVkKSB7XG4gICAgdmFyIGF0dGFjaG1lbnRzID0gW10uY29uY2F0KHRoaXMubWFpbC5hdHRhY2htZW50cyB8fCBbXSkubWFwKGZ1bmN0aW9uIChhdHRhY2htZW50LCBpKSB7XG4gICAgICAgIHZhciBkYXRhO1xuICAgICAgICB2YXIgaXNNZXNzYWdlTm9kZSA9IC9ebWVzc2FnZVxcLy9pLnRlc3QoYXR0YWNobWVudC5jb250ZW50VHlwZSk7XG5cbiAgICAgICAgaWYgKC9eZGF0YTovaS50ZXN0KGF0dGFjaG1lbnQucGF0aCB8fCBhdHRhY2htZW50LmhyZWYpKSB7XG4gICAgICAgICAgICBhdHRhY2htZW50ID0gdGhpcy5fcHJvY2Vzc0RhdGFVcmwoYXR0YWNobWVudCk7XG4gICAgICAgIH1cblxuICAgICAgICBkYXRhID0ge1xuICAgICAgICAgICAgY29udGVudFR5cGU6IGF0dGFjaG1lbnQuY29udGVudFR5cGUgfHxcbiAgICAgICAgICAgICAgICBsaWJtaW1lLmRldGVjdE1pbWVUeXBlKGF0dGFjaG1lbnQuZmlsZW5hbWUgfHwgYXR0YWNobWVudC5wYXRoIHx8IGF0dGFjaG1lbnQuaHJlZiB8fCAnYmluJyksXG4gICAgICAgICAgICBjb250ZW50RGlzcG9zaXRpb246IGF0dGFjaG1lbnQuY29udGVudERpc3Bvc2l0aW9uIHx8IChpc01lc3NhZ2VOb2RlID8gJ2lubGluZScgOiAnYXR0YWNobWVudCcpLFxuICAgICAgICAgICAgY29udGVudFRyYW5zZmVyRW5jb2Rpbmc6IGF0dGFjaG1lbnQuY29udGVudFRyYW5zZmVyRW5jb2RpbmdcbiAgICAgICAgfTtcblxuICAgICAgICBpZiAoYXR0YWNobWVudC5maWxlbmFtZSkge1xuICAgICAgICAgICAgZGF0YS5maWxlbmFtZSA9IGF0dGFjaG1lbnQuZmlsZW5hbWU7XG4gICAgICAgIH0gZWxzZSBpZiAoIWlzTWVzc2FnZU5vZGUgJiYgYXR0YWNobWVudC5maWxlbmFtZSAhPT0gZmFsc2UpIHtcbiAgICAgICAgICAgIGRhdGEuZmlsZW5hbWUgPSAoYXR0YWNobWVudC5wYXRoIHx8IGF0dGFjaG1lbnQuaHJlZiB8fCAnJykuc3BsaXQoJy8nKS5wb3AoKSB8fCAnYXR0YWNobWVudC0nICsgKGkgKyAxKTtcbiAgICAgICAgICAgIGlmIChkYXRhLmZpbGVuYW1lLmluZGV4T2YoJy4nKSA8IDApIHtcbiAgICAgICAgICAgICAgICBkYXRhLmZpbGVuYW1lICs9ICcuJyArIGxpYm1pbWUuZGV0ZWN0RXh0ZW5zaW9uKGRhdGEuY29udGVudFR5cGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKC9eaHR0cHM/OlxcL1xcLy9pLnRlc3QoYXR0YWNobWVudC5wYXRoKSkge1xuICAgICAgICAgICAgYXR0YWNobWVudC5ocmVmID0gYXR0YWNobWVudC5wYXRoO1xuICAgICAgICAgICAgYXR0YWNobWVudC5wYXRoID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGF0dGFjaG1lbnQuY2lkKSB7XG4gICAgICAgICAgICBkYXRhLmNpZCA9IGF0dGFjaG1lbnQuY2lkO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGF0dGFjaG1lbnQucmF3KSB7XG4gICAgICAgICAgICBkYXRhLnJhdyA9IGF0dGFjaG1lbnQucmF3O1xuICAgICAgICB9IGVsc2UgaWYgKGF0dGFjaG1lbnQucGF0aCkge1xuICAgICAgICAgICAgZGF0YS5jb250ZW50ID0ge1xuICAgICAgICAgICAgICAgIHBhdGg6IGF0dGFjaG1lbnQucGF0aFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSBlbHNlIGlmIChhdHRhY2htZW50LmhyZWYpIHtcbiAgICAgICAgICAgIGRhdGEuY29udGVudCA9IHtcbiAgICAgICAgICAgICAgICBocmVmOiBhdHRhY2htZW50LmhyZWZcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBkYXRhLmNvbnRlbnQgPSBhdHRhY2htZW50LmNvbnRlbnQgfHwgJyc7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoYXR0YWNobWVudC5lbmNvZGluZykge1xuICAgICAgICAgICAgZGF0YS5lbmNvZGluZyA9IGF0dGFjaG1lbnQuZW5jb2Rpbmc7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoYXR0YWNobWVudC5oZWFkZXJzKSB7XG4gICAgICAgICAgICBkYXRhLmhlYWRlcnMgPSBhdHRhY2htZW50LmhlYWRlcnM7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZGF0YTtcbiAgICB9LmJpbmQodGhpcykpO1xuXG4gICAgaWYgKCFmaW5kUmVsYXRlZCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgYXR0YWNoZWQ6IGF0dGFjaG1lbnRzLFxuICAgICAgICAgICAgcmVsYXRlZDogW11cbiAgICAgICAgfTtcbiAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgYXR0YWNoZWQ6IGF0dGFjaG1lbnRzLmZpbHRlcihmdW5jdGlvbiAoYXR0YWNobWVudCkge1xuICAgICAgICAgICAgICAgIHJldHVybiAhYXR0YWNobWVudC5jaWQ7XG4gICAgICAgICAgICB9KSxcbiAgICAgICAgICAgIHJlbGF0ZWQ6IGF0dGFjaG1lbnRzLmZpbHRlcihmdW5jdGlvbiAoYXR0YWNobWVudCkge1xuICAgICAgICAgICAgICAgIHJldHVybiAhIWF0dGFjaG1lbnQuY2lkO1xuICAgICAgICAgICAgfSlcbiAgICAgICAgfTtcbiAgICB9XG59O1xuXG4vKipcbiAqIExpc3QgYWx0ZXJuYXRpdmVzLiBSZXN1bHRpbmcgb2JqZWN0cyBjYW4gYmUgdXNlZCBhcyBpbnB1dCBmb3IgQnVpbGRNYWlsIG5vZGVzXG4gKlxuICogQHJldHVybnMge0FycmF5fSBBbiBhcnJheSBvZiBhbHRlcm5hdGl2ZSBlbGVtZW50cy4gSW5jbHVkZXMgdGhlIGB0ZXh0YCBhbmQgYGh0bWxgIHZhbHVlcyBhcyB3ZWxsXG4gKi9cbk1haWxDb21wb3Nlci5wcm90b3R5cGUuX2dldEFsdGVybmF0aXZlcyA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgYWx0ZXJuYXRpdmVzID0gW10sXG4gICAgICAgIHRleHQsIGh0bWwsIHdhdGNoSHRtbCwgaWNhbEV2ZW50O1xuXG4gICAgaWYgKHRoaXMubWFpbC50ZXh0KSB7XG4gICAgICAgIGlmICh0eXBlb2YgdGhpcy5tYWlsLnRleHQgPT09ICdvYmplY3QnICYmICh0aGlzLm1haWwudGV4dC5jb250ZW50IHx8IHRoaXMubWFpbC50ZXh0LnBhdGggfHwgdGhpcy5tYWlsLnRleHQuaHJlZiB8fCB0aGlzLm1haWwudGV4dC5yYXcpKSB7XG4gICAgICAgICAgICB0ZXh0ID0gdGhpcy5tYWlsLnRleHQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0ZXh0ID0ge1xuICAgICAgICAgICAgICAgIGNvbnRlbnQ6IHRoaXMubWFpbC50ZXh0XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIHRleHQuY29udGVudFR5cGUgPSAndGV4dC9wbGFpbicgKyAoIXRleHQuZW5jb2RpbmcgJiYgbGlibWltZS5pc1BsYWluVGV4dCh0ZXh0LmNvbnRlbnQpID8gJycgOiAnOyBjaGFyc2V0PXV0Zi04Jyk7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMubWFpbC53YXRjaEh0bWwpIHtcbiAgICAgICAgaWYgKHR5cGVvZiB0aGlzLm1haWwud2F0Y2hIdG1sID09PSAnb2JqZWN0JyAmJiAodGhpcy5tYWlsLndhdGNoSHRtbC5jb250ZW50IHx8IHRoaXMubWFpbC53YXRjaEh0bWwucGF0aCB8fCB0aGlzLm1haWwud2F0Y2hIdG1sLmhyZWYgfHwgdGhpcy5tYWlsLndhdGNoSHRtbC5yYXcpKSB7XG4gICAgICAgICAgICB3YXRjaEh0bWwgPSB0aGlzLm1haWwud2F0Y2hIdG1sO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgd2F0Y2hIdG1sID0ge1xuICAgICAgICAgICAgICAgIGNvbnRlbnQ6IHRoaXMubWFpbC53YXRjaEh0bWxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgd2F0Y2hIdG1sLmNvbnRlbnRUeXBlID0gJ3RleHQvd2F0Y2gtaHRtbCcgKyAoIXdhdGNoSHRtbC5lbmNvZGluZyAmJiBsaWJtaW1lLmlzUGxhaW5UZXh0KHdhdGNoSHRtbC5jb250ZW50KSA/ICcnIDogJzsgY2hhcnNldD11dGYtOCcpO1xuICAgIH1cblxuICAgIGlmICh0aGlzLm1haWwuaWNhbEV2ZW50KSB7XG4gICAgICAgIGlmICh0eXBlb2YgdGhpcy5tYWlsLmljYWxFdmVudCA9PT0gJ29iamVjdCcgJiYgKHRoaXMubWFpbC5pY2FsRXZlbnQuY29udGVudCB8fCB0aGlzLm1haWwuaWNhbEV2ZW50LnBhdGggfHwgdGhpcy5tYWlsLmljYWxFdmVudC5ocmVmIHx8IHRoaXMubWFpbC5pY2FsRXZlbnQucmF3KSkge1xuICAgICAgICAgICAgaWNhbEV2ZW50ID0gdGhpcy5tYWlsLmljYWxFdmVudDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGljYWxFdmVudCA9IHtcbiAgICAgICAgICAgICAgICBjb250ZW50OiB0aGlzLm1haWwuaWNhbEV2ZW50XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGljYWxFdmVudC5jb250ZW50VHlwZSA9ICd0ZXh0L2NhbGVuZGFyOyBjaGFyc2V0PVwidXRmLThcIjsgbWV0aG9kPScgKyAoaWNhbEV2ZW50Lm1ldGhvZCB8fCAnUFVCTElTSCcpLnRvU3RyaW5nKCkudHJpbSgpLnRvVXBwZXJDYXNlKCk7XG4gICAgICAgIGlmICghaWNhbEV2ZW50LmhlYWRlcnMpIHtcbiAgICAgICAgICAgIGljYWxFdmVudC5oZWFkZXJzID0ge307XG4gICAgICAgIH1cbiAgICAgICAgaWNhbEV2ZW50LmhlYWRlcnNbJ0NvbnRlbnQtVHJhbnNmZXItRW5jb2RpbmcnXSA9ICdiYXNlNjQnO1xuICAgIH1cblxuICAgIGlmICh0aGlzLm1haWwuaHRtbCkge1xuICAgICAgICBpZiAodHlwZW9mIHRoaXMubWFpbC5odG1sID09PSAnb2JqZWN0JyAmJiAodGhpcy5tYWlsLmh0bWwuY29udGVudCB8fCB0aGlzLm1haWwuaHRtbC5wYXRoIHx8IHRoaXMubWFpbC5odG1sLmhyZWYgfHwgdGhpcy5tYWlsLmh0bWwucmF3KSkge1xuICAgICAgICAgICAgaHRtbCA9IHRoaXMubWFpbC5odG1sO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaHRtbCA9IHtcbiAgICAgICAgICAgICAgICBjb250ZW50OiB0aGlzLm1haWwuaHRtbFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBodG1sLmNvbnRlbnRUeXBlID0gJ3RleHQvaHRtbCcgKyAoIWh0bWwuZW5jb2RpbmcgJiYgbGlibWltZS5pc1BsYWluVGV4dChodG1sLmNvbnRlbnQpID8gJycgOiAnOyBjaGFyc2V0PXV0Zi04Jyk7XG4gICAgfVxuXG4gICAgW10uXG4gICAgY29uY2F0KHRleHQgfHwgW10pLlxuICAgIGNvbmNhdCh3YXRjaEh0bWwgfHwgW10pLlxuICAgIGNvbmNhdChodG1sIHx8IFtdKS5cbiAgICBjb25jYXQoaWNhbEV2ZW50IHx8IFtdKS5cbiAgICBjb25jYXQodGhpcy5tYWlsLmFsdGVybmF0aXZlcyB8fCBbXSkuXG4gICAgZm9yRWFjaChmdW5jdGlvbiAoYWx0ZXJuYXRpdmUpIHtcbiAgICAgICAgdmFyIGRhdGE7XG5cbiAgICAgICAgaWYgKC9eZGF0YTovaS50ZXN0KGFsdGVybmF0aXZlLnBhdGggfHwgYWx0ZXJuYXRpdmUuaHJlZikpIHtcbiAgICAgICAgICAgIGFsdGVybmF0aXZlID0gdGhpcy5fcHJvY2Vzc0RhdGFVcmwoYWx0ZXJuYXRpdmUpO1xuICAgICAgICB9XG5cbiAgICAgICAgZGF0YSA9IHtcbiAgICAgICAgICAgIGNvbnRlbnRUeXBlOiBhbHRlcm5hdGl2ZS5jb250ZW50VHlwZSB8fFxuICAgICAgICAgICAgICAgIGxpYm1pbWUuZGV0ZWN0TWltZVR5cGUoYWx0ZXJuYXRpdmUuZmlsZW5hbWUgfHwgYWx0ZXJuYXRpdmUucGF0aCB8fCBhbHRlcm5hdGl2ZS5ocmVmIHx8ICd0eHQnKSxcbiAgICAgICAgICAgIGNvbnRlbnRUcmFuc2ZlckVuY29kaW5nOiBhbHRlcm5hdGl2ZS5jb250ZW50VHJhbnNmZXJFbmNvZGluZ1xuICAgICAgICB9O1xuXG4gICAgICAgIGlmIChhbHRlcm5hdGl2ZS5maWxlbmFtZSkge1xuICAgICAgICAgICAgZGF0YS5maWxlbmFtZSA9IGFsdGVybmF0aXZlLmZpbGVuYW1lO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKC9eaHR0cHM/OlxcL1xcLy9pLnRlc3QoYWx0ZXJuYXRpdmUucGF0aCkpIHtcbiAgICAgICAgICAgIGFsdGVybmF0aXZlLmhyZWYgPSBhbHRlcm5hdGl2ZS5wYXRoO1xuICAgICAgICAgICAgYWx0ZXJuYXRpdmUucGF0aCA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChhbHRlcm5hdGl2ZS5yYXcpIHtcbiAgICAgICAgICAgIGRhdGEucmF3ID0gYWx0ZXJuYXRpdmUucmF3O1xuICAgICAgICB9IGVsc2UgaWYgKGFsdGVybmF0aXZlLnBhdGgpIHtcbiAgICAgICAgICAgIGRhdGEuY29udGVudCA9IHtcbiAgICAgICAgICAgICAgICBwYXRoOiBhbHRlcm5hdGl2ZS5wYXRoXG4gICAgICAgICAgICB9O1xuICAgICAgICB9IGVsc2UgaWYgKGFsdGVybmF0aXZlLmhyZWYpIHtcbiAgICAgICAgICAgIGRhdGEuY29udGVudCA9IHtcbiAgICAgICAgICAgICAgICBocmVmOiBhbHRlcm5hdGl2ZS5ocmVmXG4gICAgICAgICAgICB9O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZGF0YS5jb250ZW50ID0gYWx0ZXJuYXRpdmUuY29udGVudCB8fCAnJztcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChhbHRlcm5hdGl2ZS5lbmNvZGluZykge1xuICAgICAgICAgICAgZGF0YS5lbmNvZGluZyA9IGFsdGVybmF0aXZlLmVuY29kaW5nO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGFsdGVybmF0aXZlLmhlYWRlcnMpIHtcbiAgICAgICAgICAgIGRhdGEuaGVhZGVycyA9IGFsdGVybmF0aXZlLmhlYWRlcnM7XG4gICAgICAgIH1cblxuICAgICAgICBhbHRlcm5hdGl2ZXMucHVzaChkYXRhKTtcbiAgICB9LmJpbmQodGhpcykpO1xuXG4gICAgcmV0dXJuIGFsdGVybmF0aXZlcztcbn07XG5cbi8qKlxuICogUGFyc2VzIGRhdGEgdXJpIGFuZCBjb252ZXJ0cyBpdCB0byBhIEJ1ZmZlclxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBlbGVtZW50IENvbnRlbnQgZWxlbWVudFxuICogQHJldHVybiB7T2JqZWN0fSBQYXJzZWQgZWxlbWVudFxuICovXG5NYWlsQ29tcG9zZXIucHJvdG90eXBlLl9wcm9jZXNzRGF0YVVybCA9IGZ1bmN0aW9uIChlbGVtZW50KSB7XG4gICAgdmFyIHBhcnRzID0gKGVsZW1lbnQucGF0aCB8fCBlbGVtZW50LmhyZWYpLm1hdGNoKC9eZGF0YTooKD86W147XSo7KSooPzpbXixdKikpLCguKikkL2kpO1xuICAgIGlmICghcGFydHMpIHtcbiAgICAgICAgcmV0dXJuIGVsZW1lbnQ7XG4gICAgfVxuXG4gICAgZWxlbWVudC5jb250ZW50ID0gL1xcYmJhc2U2NCQvaS50ZXN0KHBhcnRzWzFdKSA/IG5ldyBCdWZmZXIocGFydHNbMl0sICdiYXNlNjQnKSA6IG5ldyBCdWZmZXIoZGVjb2RlVVJJQ29tcG9uZW50KHBhcnRzWzJdKSk7XG5cbiAgICBpZiAoJ3BhdGgnIGluIGVsZW1lbnQpIHtcbiAgICAgICAgZWxlbWVudC5wYXRoID0gZmFsc2U7XG4gICAgfVxuXG4gICAgaWYgKCdocmVmJyBpbiBlbGVtZW50KSB7XG4gICAgICAgIGVsZW1lbnQuaHJlZiA9IGZhbHNlO1xuICAgIH1cblxuICAgIHBhcnRzWzFdLnNwbGl0KCc7JykuZm9yRWFjaChmdW5jdGlvbiAoaXRlbSkge1xuICAgICAgICBpZiAoL15cXHcrXFwvW15cXC9dKyQvaS50ZXN0KGl0ZW0pKSB7XG4gICAgICAgICAgICBlbGVtZW50LmNvbnRlbnRUeXBlID0gZWxlbWVudC5jb250ZW50VHlwZSB8fCBpdGVtLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgIH1cbiAgICB9KTtcblxuICAgIHJldHVybiBlbGVtZW50O1xufTtcblxufSkuY2FsbCh0aGlzLHJlcXVpcmUoXCJidWZmZXJcIikuQnVmZmVyKSIsIid1c2Ugc3RyaWN0JztcblxudmFyIGNyZWF0ZVF1ZXVlID0gcmVxdWlyZSgnLi9tZXNzYWdlLXF1ZXVlJyk7XG52YXIgU01UUENvbm5lY3Rpb24gPSByZXF1aXJlKCdzbXRwLWNvbm5lY3Rpb24nKTtcbnZhciBkbnMgPSByZXF1aXJlKCdkbnMnKTtcbnZhciBuZXQgPSByZXF1aXJlKCduZXQnKTtcbnZhciBvcyA9IHJlcXVpcmUoJ29zJyk7XG52YXIgdXRpbCA9IHJlcXVpcmUoJ3V0aWwnKTtcbnZhciBwYWNrYWdlRGF0YSA9IHJlcXVpcmUoJy4uL3BhY2thZ2UuanNvbicpO1xudmFyIEV2ZW50RW1pdHRlciA9IHJlcXVpcmUoJ2V2ZW50cycpLkV2ZW50RW1pdHRlcjtcbnZhciBzaGFyZWQgPSByZXF1aXJlKCdub2RlbWFpbGVyLXNoYXJlZCcpO1xuXG4vLyBFeHBvc2UgdG8gdGhlIHdvcmxkXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgcmV0dXJuIG5ldyBEaXJlY3RNYWlsZXIob3B0aW9ucyk7XG59O1xuXG4vKipcbiAqIENyZWF0ZXMgYSBuZXcgRGlyZWN0TWFpbGVyIGluc3RhbmNlLiBQcm92aWRlcyBtZXRob2QgJ3NlbmQnIHRvIHF1ZXVlXG4gKiBvdXRnb2luZyBlLW1haWxzLiBUaGUgcXVldWUgaXMgcHJvY2Vzc2VkIGluIHRoZSBiYWNrZ3JvdW5kLlxuICpcbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSBPcHRpb25hbCBvcHRpb25zIG9iamVjdFxuICovXG5mdW5jdGlvbiBEaXJlY3RNYWlsZXIob3B0aW9ucykge1xuICAgIEV2ZW50RW1pdHRlci5jYWxsKHRoaXMpO1xuICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gICAgdGhpcy5fcXVldWUgPSBjcmVhdGVRdWV1ZSgpO1xuICAgIHRoaXMuX3N0YXJ0ZWQgPSBmYWxzZTtcbiAgICB0aGlzLl9sYXN0SWQgPSAwO1xuXG4gICAgaWYgKG9wdGlvbnMgJiYgdHlwZW9mIG9wdGlvbnMuZ2V0U29ja2V0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHRoaXMuZ2V0U29ja2V0ID0gb3B0aW9ucy5nZXRTb2NrZXQ7XG4gICAgfVxuXG4gICAgdGhpcy5sb2dnZXIgPSBzaGFyZWQuZ2V0TG9nZ2VyKHRoaXMub3B0aW9ucyk7XG5cbiAgICAvLyB0ZW1wb3Jhcnkgb2JqZWN0XG4gICAgdmFyIGNvbm5lY3Rpb24gPSBuZXcgU01UUENvbm5lY3Rpb24oe30pO1xuXG4gICAgdGhpcy5uYW1lID0gJ1NNVFAgKGRpcmVjdCknO1xuICAgIHRoaXMudmVyc2lvbiA9IHBhY2thZ2VEYXRhLnZlcnNpb24gKyAnW2NsaWVudDonICsgY29ubmVjdGlvbi52ZXJzaW9uICsgJ10nO1xufVxudXRpbC5pbmhlcml0cyhEaXJlY3RNYWlsZXIsIEV2ZW50RW1pdHRlcik7XG5cbi8vIEFkZHMgYSBkeW5hbWljIHByb3BlcnR5ICdsZW5ndGgnXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoRGlyZWN0TWFpbGVyLnByb3RvdHlwZSwgJ2xlbmd0aCcsIHtcbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3F1ZXVlLl9pbnN0YW50UXVldWUubGVuZ3RoICsgdGhpcy5fcXVldWUuX3NvcnRlZFF1ZXVlLmxlbmd0aDtcbiAgICB9XG59KTtcblxuLyoqXG4gKiBQbGFjZWhvbGRlciBmdW5jdGlvbiBmb3IgY3JlYXRpbmcgcHJveHkgc29ja2V0cy4gVGhpcyBtZXRob2QgaW1tZWRpYXRlbGx5IHJldHVybnNcbiAqIHdpdGhvdXQgYSBzb2NrZXRcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyBDb25uZWN0aW9uIG9wdGlvbnNcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIENhbGxiYWNrIGZ1bmN0aW9uIHRvIHJ1biB3aXRoIHRoZSBzb2NrZXQga2V5c1xuICovXG5EaXJlY3RNYWlsZXIucHJvdG90eXBlLmdldFNvY2tldCA9IGZ1bmN0aW9uIChvcHRpb25zLCBjYWxsYmFjaykge1xuICAgIC8vIHJldHVybiBpbW1lZGlhdGVsbHlcbiAgICByZXR1cm4gY2FsbGJhY2sobnVsbCwgZmFsc2UpO1xufTtcblxuLyoqXG4gKiBBZGRzIGFuIG91dGdvaW5nIG1lc3NhZ2UgdG8gdGhlIHF1ZXVlLiBSZWNpcGllbnQgYWRkcmVzc2VzIGFyZSBzb3J0ZWRcbiAqIGJ5IHRoZSByZWNlaXZpbmcgZG9tYWluIGFuZCBmb3IgZXZlcnkgZG9tYWluLCBhIGNvcHkgb2YgdGhlIG1lc3NhZ2UgaXMgcXVldWVkLlxuICpcbiAqIElmIGlucHV0IGlzIGRlZW1lZCBpbnZhbGlkLCBhbiBlcnJvciBpcyB0aHJvd24sIHNvIGJlIHJlYWR5IHRvIGNhdGNoIHRoZXNlXG4gKiB3aGVuIGNhbGxpbmcgZGlyZWN0bWFpbC5zZW5kKC4uLilcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gbWFpbCBNYWlsIG9iamVjdFxuICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgQ2FsbGJhY2sgZnVuY3Rpb25cbiAqL1xuRGlyZWN0TWFpbGVyLnByb3RvdHlwZS5zZW5kID0gZnVuY3Rpb24gKG1haWwsIGNhbGxiYWNrKSB7XG5cbiAgICB2YXIgZW52ZWxvcGUgPSBtYWlsLmRhdGEuZW52ZWxvcGUgfHwgbWFpbC5tZXNzYWdlLmdldEVudmVsb3BlKCk7XG4gICAgdmFyIGRvbWFpbkVudmVsb3BlcyA9IHt9O1xuXG4gICAgaWYgKCFlbnZlbG9wZS5mcm9tKSB7XG4gICAgICAgIHJldHVybiBjYWxsYmFjayhuZXcgRXJyb3IoJ1wiRnJvbVwiIGFkZHJlc3MgbWlzc2luZycpKTtcbiAgICB9XG5cbiAgICBlbnZlbG9wZS50byA9IFtdLmNvbmNhdChlbnZlbG9wZS50byB8fCBbXSk7XG5cbiAgICBpZiAoIWVudmVsb3BlLnRvLmxlbmd0aCkge1xuICAgICAgICByZXR1cm4gY2FsbGJhY2soJ1wiUmVjaXBpZW50c1wiIGFkZHJlc3NlcyBtaXNzaW5nJyk7XG4gICAgfVxuXG4gICAgLy8gV2UgY2FudCd0IHJ1biBleGlzdGluZyBzdHJlYW1zIG1vcmUgdGhhbiBvbmNlIHNvIHdlIG5lZWQgdG8gY2hhbmdlIHRoZXNlXG4gICAgLy8gdG8gYnVmZmVycy4gRmlsZW5hbWVzLCBVUkxzIGV0YyBhcmUgbm90IGFmZmVjdGVkIOKAkyBmb3IgZXZlcnlcbiAgICAvLyBtZXNzYWdlIGNvcHkgYSBuZXcgZmlsZSBzdHJlYW0gd2lsbCBiZSBjcmVhdGVkXG4gICAgdGhpcy5fY2xlYXJTdHJlYW1zKG1haWwsIGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKGVycik7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLl9mb3JtYXRNZXNzYWdlKG1haWwubWVzc2FnZSk7XG5cbiAgICAgICAgZW52ZWxvcGUudG8uZm9yRWFjaChmdW5jdGlvbiAocmVjaXBpZW50KSB7XG4gICAgICAgICAgICByZWNpcGllbnQgPSAocmVjaXBpZW50IHx8ICcnKS50b1N0cmluZygpO1xuXG4gICAgICAgICAgICB2YXIgZG9tYWluID0gKHJlY2lwaWVudC5zcGxpdCgnQCcpLnBvcCgpIHx8ICcnKS50b0xvd2VyQ2FzZSgpLnRyaW0oKTtcblxuICAgICAgICAgICAgaWYgKCFkb21haW5FbnZlbG9wZXNbZG9tYWluXSkge1xuICAgICAgICAgICAgICAgIGRvbWFpbkVudmVsb3Blc1tkb21haW5dID0ge1xuICAgICAgICAgICAgICAgICAgICBmcm9tOiBlbnZlbG9wZS5mcm9tLFxuICAgICAgICAgICAgICAgICAgICB0bzogW3JlY2lwaWVudF1cbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfSBlbHNlIGlmIChkb21haW5FbnZlbG9wZXNbZG9tYWluXS50by5pbmRleE9mKHJlY2lwaWVudCkgPCAwKSB7XG4gICAgICAgICAgICAgICAgZG9tYWluRW52ZWxvcGVzW2RvbWFpbl0udG8ucHVzaChyZWNpcGllbnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICB2YXIgcmV0dXJuZWQgPSAwO1xuICAgICAgICB2YXIgZG9tYWlucyA9IE9iamVjdC5rZXlzKGRvbWFpbkVudmVsb3Blcyk7XG4gICAgICAgIHZhciBjb21iaW5lZEluZm8gPSB7XG4gICAgICAgICAgICBhY2NlcHRlZDogW10sXG4gICAgICAgICAgICByZWplY3RlZDogW10sXG4gICAgICAgICAgICBwZW5kaW5nOiBbXSxcbiAgICAgICAgICAgIGVycm9yczogW10sXG4gICAgICAgICAgICBlbnZlbG9wZTogbWFpbC5kYXRhLmVudmVsb3BlIHx8IG1haWwubWVzc2FnZS5nZXRFbnZlbG9wZSgpXG4gICAgICAgIH07XG5cbiAgICAgICAgZG9tYWlucy5mb3JFYWNoKChmdW5jdGlvbiAoZG9tYWluKSB7XG4gICAgICAgICAgICB2YXIgY2FsbGVkID0gZmFsc2U7XG4gICAgICAgICAgICB2YXIgaWQgPSArK3RoaXMuX2xhc3RJZDtcbiAgICAgICAgICAgIHZhciBpdGVtID0ge1xuICAgICAgICAgICAgICAgIGVudmVsb3BlOiBkb21haW5FbnZlbG9wZXNbZG9tYWluXSxcbiAgICAgICAgICAgICAgICBkYXRhOiBtYWlsLmRhdGEsXG4gICAgICAgICAgICAgICAgbWVzc2FnZTogbWFpbC5tZXNzYWdlLFxuICAgICAgICAgICAgICAgIGRvbWFpbjogZG9tYWluLFxuICAgICAgICAgICAgICAgIGlkOiBpZCxcbiAgICAgICAgICAgICAgICBjYWxsYmFjazogZnVuY3Rpb24gKGVyciwgaW5mbykge1xuICAgICAgICAgICAgICAgICAgICBpZiAoY2FsbGVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmxvZ2dlci5pbmZvKCdDYWxsYmFjayBmb3IgIyVzIGFscmVhZHkgY2FsbGVkLiBVcGRhdGVkIHZhbHVlczogJXMnLCBpZCwgSlNPTi5zdHJpbmdpZnkoZXJyIHx8IGluZm8pKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGNhbGxlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybmVkKys7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29tYmluZWRJbmZvLmVycm9ycy5wdXNoKGVycik7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZXJyLnJlY2lwaWVudHMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb21iaW5lZEluZm8ucmVqZWN0ZWQgPSBjb21iaW5lZEluZm8ucmVqZWN0ZWQuY29uY2F0KGVyci5yZWNpcGllbnRzIHx8IFtdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChpbmZvKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb21iaW5lZEluZm8uYWNjZXB0ZWQgPSBjb21iaW5lZEluZm8uYWNjZXB0ZWQuY29uY2F0KGluZm8uYWNjZXB0ZWQgfHwgW10pO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29tYmluZWRJbmZvLnJlamVjdGVkID0gY29tYmluZWRJbmZvLnJlamVjdGVkLmNvbmNhdChpbmZvLnJlamVjdGVkIHx8IFtdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbWJpbmVkSW5mby5wZW5kaW5nID0gY29tYmluZWRJbmZvLnBlbmRpbmcuY29uY2F0KGluZm8ucGVuZGluZyB8fCBbXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb21iaW5lZEluZm8ubWVzc2FnZUlkID0gaW5mby5tZXNzYWdlSWQ7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBpZiAocmV0dXJuZWQgPj0gZG9tYWlucy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjb21iaW5lZEluZm8uZXJyb3JzLmxlbmd0aCA9PT0gZG9tYWlucy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgZXJyb3IgPSBuZXcgRXJyb3IoJ1NlbmRpbmcgZmFpbGVkJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3IuZXJyb3JzID0gY29tYmluZWRJbmZvLmVycm9ycztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gY2FsbGJhY2soZXJyb3IpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gY2FsbGJhY2sobnVsbCwgY29tYmluZWRJbmZvKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0uYmluZCh0aGlzKVxuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgdGhpcy5fcXVldWUuaW5zZXJ0KGl0ZW0pO1xuICAgICAgICB9KS5iaW5kKHRoaXMpKTtcblxuICAgICAgICAvLyBzdGFydCBzZW5kIGxvb3AgaWYgbmVlZGVkXG4gICAgICAgIGlmICghdGhpcy5fc3RhcnRlZCkge1xuICAgICAgICAgICAgdGhpcy5fc3RhcnRlZCA9IHRydWU7XG5cbiAgICAgICAgICAgIC8vIGRvIG5vdCBzdGFydCB0aGUgbG9vcCBiZWZvcmUgY3VycmVudCBleGVjdXRpb24gY29udGV4dCBpcyBmaW5pc2hlZFxuICAgICAgICAgICAgc2V0SW1tZWRpYXRlKHRoaXMuX2xvb3AuYmluZCh0aGlzKSk7XG4gICAgICAgIH1cblxuICAgIH0uYmluZCh0aGlzKSk7XG59O1xuXG4vKipcbiAqIExvb3BpbmcgZnVuY3Rpb24gdG8gZmV0Y2ggYSBtZXNzYWdlIGZyb20gdGhlIHF1ZXVlIGFuZCBzZW5kIGl0LlxuICovXG5EaXJlY3RNYWlsZXIucHJvdG90eXBlLl9sb29wID0gZnVuY3Rpb24gKCkge1xuXG4gICAgLy8gY2FsbGJhY2sgaXMgZmlyZWQgd2hlbiBhIG1lc3NhZ2UgaXMgYWRkZWQgdG8gdGhlIHF1ZXVlXG4gICAgdGhpcy5fcXVldWUuZ2V0KChmdW5jdGlvbiAoZGF0YSkge1xuXG4gICAgICAgIHRoaXMubG9nZ2VyLmluZm8oJ1JldHJpZXZlZCBtZXNzYWdlICMlcyBmcm9tIHRoZSBxdWV1ZSwgcmVzb2x2aW5nICVzJywgZGF0YS5pZCwgZGF0YS5kb21haW4pO1xuXG4gICAgICAgIC8vIFJlc29sdmUgZGVzdGluYXRpb24gTVggc2VydmVyXG4gICAgICAgIHRoaXMuX3Jlc29sdmVNeChkYXRhLmRvbWFpbiwgKGZ1bmN0aW9uIChlcnIsIGxpc3QpIHtcblxuICAgICAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgICAgIHRoaXMubG9nZ2VyLmluZm8oJ1Jlc29sdmluZyAlcyBmb3IgIyVzIGZhaWxlZCcsIGRhdGEuZG9tYWluLCBkYXRhLmlkKTtcbiAgICAgICAgICAgICAgICB0aGlzLmxvZ2dlci5pbmZvKGVycik7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKCFsaXN0IHx8ICFsaXN0Lmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHRoaXMubG9nZ2VyLmluZm8oJ0NvdWxkIG5vdCByZXNvbHZlIGFueSBNWCBzZXJ2ZXJzIGZvciAlcycsIGRhdGEuZG9tYWluKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChlcnIgfHwgIWxpc3QgfHwgIWxpc3QubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgZGF0YS5jYWxsYmFjayhlcnIgfHwgbmV3IEVycm9yKCdDb3VsZCBub3QgcmVzb2x2ZSBNWCBmb3IgJyArIGRhdGEuZG9tYWluKSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHNldEltbWVkaWF0ZSh0aGlzLl9sb29wLmJpbmQodGhpcykpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBTb3J0IE1YIGxpc3QgYnkgcHJpb3JpdHkgZmllbGRcbiAgICAgICAgICAgIGxpc3Quc29ydChmdW5jdGlvbiAoYSwgYikge1xuICAgICAgICAgICAgICAgIHJldHVybiAoYSAmJiBhLnByaW9yaXR5IHx8IDApIC0gKGIgJiYgYi5wcmlvcml0eSB8fCAwKTtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAvLyBVc2UgdGhlIGZpcnN0IHNlcnZlciBvbiB0aGUgbGlzdFxuICAgICAgICAgICAgdmFyIGV4Y2hhbmdlID0gbGlzdFswXSAmJiBsaXN0WzBdLmV4Y2hhbmdlO1xuXG4gICAgICAgICAgICB0aGlzLmxvZ2dlci5pbmZvKCclcyByZXNvbHZlZCB0byAlcyBmb3IgIyVzJywgZGF0YS5kb21haW4sIGV4Y2hhbmdlLCBkYXRhLmlkKTtcblxuICAgICAgICAgICAgLy8gVHJ5IHRvIHNlbmQgdGhlIG1lc3NhZ2VcbiAgICAgICAgICAgIHRoaXMuX3Byb2Nlc3MoZXhjaGFuZ2UsIGRhdGEsIChmdW5jdGlvbiAoZXJyLCByZXNwb25zZSkge1xuICAgICAgICAgICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5sb2dnZXIuaW5mbygnRmFpbGVkIHByb2Nlc3NpbmcgbWVzc2FnZSAjJXMnLCBkYXRhLmlkKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmxvZ2dlci5pbmZvKCdTZXJ2ZXIgcmVzcG9uZGVkIGZvciAjJXM6ICVzJywgZGF0YS5pZCwgSlNPTi5zdHJpbmdpZnkocmVzcG9uc2UpKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChlcnIucmVzcG9uc2VDb2RlICYmIGVyci5yZXNwb25zZUNvZGUgPj0gNTAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBlcnIuZG9tYWluID0gZGF0YS5kb21haW47XG4gICAgICAgICAgICAgICAgICAgICAgICBlcnIuZXhjaGFuZ2UgPSBleGNoYW5nZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVyci5yZWNpcGllbnRzID0gZGF0YS5lbnZlbG9wZS50bztcbiAgICAgICAgICAgICAgICAgICAgICAgIGRhdGEuY2FsbGJhY2soZXJyKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRhdGEucmVwbGllcyA9IChkYXRhLnJlcGxpZXMgfHwgMCkgKyAxO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGRhdGEucmVwbGllcyA8PSA1KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fcXVldWUuaW5zZXJ0KGRhdGEsIHRoaXMub3B0aW9ucy5yZXRyeURlbGF5IHx8IGRhdGEucmVwbGllcyAqIDE1ICogNjAgKiAxMDAwKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmxvZ2dlci5pbmZvKCdNZXNzYWdlICMlcyByZXF1ZXVlZCcsIGRhdGEuaWQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGEuY2FsbGJhY2sobnVsbCwge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwZW5kaW5nOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkb21haW46IGRhdGEuZG9tYWluLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZXhjaGFuZ2U6IGV4Y2hhbmdlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVjaXBpZW50czogZGF0YS5lbnZlbG9wZS50byxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3BvbnNlOiBlcnIucmVzcG9uc2VcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlcnIuZG9tYWluID0gZGF0YS5kb21haW47XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZXJyLmV4Y2hhbmdlID0gZXhjaGFuZ2U7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZXJyLnJlY2lwaWVudHMgPSBkYXRhLmVudmVsb3BlLnRvO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGEuY2FsbGJhY2soZXJyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGRhdGEuY2FsbGJhY2sobnVsbCwgcmVzcG9uc2UpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHNldEltbWVkaWF0ZSh0aGlzLl9sb29wLmJpbmQodGhpcykpO1xuICAgICAgICAgICAgfSkuYmluZCh0aGlzKSk7XG4gICAgICAgIH0pLmJpbmQodGhpcykpO1xuICAgIH0pLmJpbmQodGhpcykpO1xufTtcblxuLyoqXG4gKiBTZW5kcyBhIG1lc3NhZ2UgdG8gcHJvdmlkZWQgTVggc2VydmVyXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IGV4Y2hhbmdlIE1YIHNlcnZlclxuICogQHBhcmFtIHtPYmplY3R9IGRhdGEgTWVzc2FnZSBvYmplY3RcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIENhbGxiYWNrIHRvIHJ1biBvbmNlIHRoZSBtZXNzYWdlIGlzIGVpdGhlciBzZW50IG9yIHNlbmRpbmcgZmFpbHNcbiAqL1xuRGlyZWN0TWFpbGVyLnByb3RvdHlwZS5fcHJvY2VzcyA9IGZ1bmN0aW9uIChleGNoYW5nZSwgZGF0YSwgY2FsbGJhY2spIHtcbiAgICB0aGlzLmxvZ2dlci5pbmZvKCdDb25uZWN0aW5nIHRvICVzOiVzIGZvciBtZXNzYWdlICMlcyAlcyBTVEFSVFRMUycsIGV4Y2hhbmdlLCB0aGlzLm9wdGlvbnMucG9ydCB8fCAyNSwgZGF0YS5pZCwgZGF0YS5pZ25vcmVUTFMgPyAnd2l0aG91dCcgOiAnd2l0aCcpO1xuXG4gICAgdmFyIG9wdGlvbnMgPSB7XG4gICAgICAgIGhvc3Q6IGV4Y2hhbmdlLFxuICAgICAgICBwb3J0OiB0aGlzLm9wdGlvbnMucG9ydCB8fCAyNSxcbiAgICAgICAgcmVxdWlyZVRMUzogIWRhdGEuaWdub3JlVExTLFxuICAgICAgICBpZ25vcmVUTFM6IGRhdGEuaWdub3JlVExTLFxuICAgICAgICB0bHM6IHtcbiAgICAgICAgICAgIHJlamVjdFVuYXV0aG9yaXplZDogZmFsc2VcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICAvLyBBZGQgb3B0aW9ucyBmcm9tIERpcmVjdE1haWxlciBvcHRpb25zIHRvIHNpbXBsZXNtdHAgY2xpZW50XG4gICAgT2JqZWN0LmtleXModGhpcy5vcHRpb25zKS5mb3JFYWNoKChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgIG9wdGlvbnNba2V5XSA9IHRoaXMub3B0aW9uc1trZXldO1xuICAgIH0pLmJpbmQodGhpcykpO1xuXG4gICAgdGhpcy5nZXRTb2NrZXQob3B0aW9ucywgZnVuY3Rpb24gKGVyciwgc29ja2V0T3B0aW9ucykge1xuICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICByZXR1cm4gY2FsbGJhY2soZXJyKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChzb2NrZXRPcHRpb25zICYmIHNvY2tldE9wdGlvbnMuY29ubmVjdGlvbikge1xuICAgICAgICAgICAgdGhpcy5sb2dnZXIuaW5mbygnVXNpbmcgcHJveGllZCBzb2NrZXQgZnJvbSAlczolcyB0byAlczolcycsIHNvY2tldE9wdGlvbnMuY29ubmVjdGlvbi5yZW1vdGVBZGRyZXNzLCBzb2NrZXRPcHRpb25zLmNvbm5lY3Rpb24ucmVtb3RlUG9ydCwgb3B0aW9ucy5ob3N0IHx8ICcnLCBvcHRpb25zLnBvcnQgfHwgJycpO1xuICAgICAgICAgICAgT2JqZWN0LmtleXMoc29ja2V0T3B0aW9ucykuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgICAgICAgICAgb3B0aW9uc1trZXldID0gc29ja2V0T3B0aW9uc1trZXldO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgY29ubmVjdGlvbiA9IG5ldyBTTVRQQ29ubmVjdGlvbihvcHRpb25zKTtcbiAgICAgICAgdmFyIHJldHVybmVkID0gZmFsc2U7XG5cbiAgICAgICAgY29ubmVjdGlvbi5vbmNlKCdlcnJvcicsIGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgICAgIGlmIChyZXR1cm5lZCkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybmVkID0gdHJ1ZTtcbiAgICAgICAgICAgIGlmIChlcnIuY29kZSA9PT0gJ0VUTFMnKSB7XG4gICAgICAgICAgICAgICAgLy8gU1RBUlRUTFMgZmFpbGVkLCB0cnkgYWdhaW4sIHRoaXMgdGltZSB3aXRob3V0IGVuY3J5cHRpb25cbiAgICAgICAgICAgICAgICBkYXRhLmlnbm9yZVRMUyA9IHRydWU7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3Byb2Nlc3MoZXhjaGFuZ2UsIGRhdGEsIGNhbGxiYWNrKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBjYWxsYmFjayhlcnIpO1xuICAgICAgICB9LmJpbmQodGhpcykpO1xuXG4gICAgICAgIHZhciBzZW5kTWVzc2FnZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBtZXNzYWdlSWQgPSAoZGF0YS5tZXNzYWdlLmdldEhlYWRlcignbWVzc2FnZS1pZCcpIHx8ICcnKS5yZXBsYWNlKC9bPD5cXHNdL2csICcnKTtcbiAgICAgICAgICAgIHZhciByZWNpcGllbnRzID0gW10uY29uY2F0KGRhdGEuZW52ZWxvcGUudG8gfHwgW10pO1xuICAgICAgICAgICAgaWYgKHJlY2lwaWVudHMubGVuZ3RoID4gMykge1xuICAgICAgICAgICAgICAgIHJlY2lwaWVudHMucHVzaCgnLi4uYW5kICcgKyByZWNpcGllbnRzLnNwbGljZSgyKS5sZW5ndGggKyAnIG1vcmUnKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGhpcy5sb2dnZXIuaW5mbygnU2VuZGluZyBtZXNzYWdlIDwlcz4gdG8gPCVzPicsIG1lc3NhZ2VJZCwgcmVjaXBpZW50cy5qb2luKCcsICcpKTtcbiAgICAgICAgICAgIGNvbm5lY3Rpb24uc2VuZChkYXRhLmVudmVsb3BlLCBkYXRhLm1lc3NhZ2UuY3JlYXRlUmVhZFN0cmVhbSgpLCBmdW5jdGlvbiAoZXJyLCBpbmZvKSB7XG4gICAgICAgICAgICAgICAgaWYgKHJldHVybmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuZWQgPSB0cnVlO1xuXG4gICAgICAgICAgICAgICAgY29ubmVjdGlvbi5jbG9zZSgpO1xuICAgICAgICAgICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKGVycik7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaW5mby5tZXNzYWdlSWQgPSAoZGF0YS5tZXNzYWdlLmdldEhlYWRlcignbWVzc2FnZS1pZCcpIHx8ICcnKS5yZXBsYWNlKC9bPD5cXHNdL2csICcnKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gY2FsbGJhY2sobnVsbCwgaW5mbyk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfS5iaW5kKHRoaXMpO1xuXG4gICAgICAgIGNvbm5lY3Rpb24uY29ubmVjdChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAocmV0dXJuZWQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzZW5kTWVzc2FnZSgpO1xuICAgICAgICB9LmJpbmQodGhpcykpO1xuICAgIH0uYmluZCh0aGlzKSk7XG59O1xuXG4vKipcbiAqIEFkZHMgYWRkaXRpb25hbCBoZWFkZXJzIHRvIHRoZSBvdXRnb2luZyBtZXNzYWdlXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IG1lc3NhZ2UgQnVpbGRNYWlsIG1lc3NhZ2Ugb2JqZWN0XG4gKi9cbkRpcmVjdE1haWxlci5wcm90b3R5cGUuX2Zvcm1hdE1lc3NhZ2UgPSBmdW5jdGlvbiAobWVzc2FnZSkge1xuICAgIHZhciBob3N0bmFtZSA9IHRoaXMuX3Jlc29sdmVIb3N0bmFtZSh0aGlzLm9wdGlvbnMubmFtZSk7XG5cbiAgICAvLyBzZXQgdGhlIGZpcnN0IGhlYWRlciBhcyAnUmVjZWl2ZWQ6J1xuICAgIG1lc3NhZ2UuX2hlYWRlcnMudW5zaGlmdCh7XG4gICAgICAgIGtleTogJ1JlY2VpdmVkJyxcbiAgICAgICAgdmFsdWU6ICdmcm9tIGxvY2FsaG9zdCAoMTI3LjAuMC4xKSBieSAnICsgaG9zdG5hbWUgKyAnIHdpdGggU01UUDsgJyArIERhdGUoKVxuICAgIH0pO1xufTtcblxuLyoqXG4gKiBEZXRlY3RzIHN0cmVhbSBvYmplY3RzIGFuZCByZXNvbHZlcyB0aGVzZSB0byBidWZmZXJzIGJlZm9yZSBzZW5kaW5nLiBGaWxlIHBhdGhzLFxuICogdXJscyBldGMuIGFyZSBub3QgYWZmZWN0ZWQuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IG1lc3NhZ2UgQnVpbGRNYWlsIG1lc3NhZ2Ugb2JqZWN0XG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayBDYWxsYmFjayB0byBydW5cbiAqL1xuRGlyZWN0TWFpbGVyLnByb3RvdHlwZS5fY2xlYXJTdHJlYW1zID0gZnVuY3Rpb24gKG1haWwsIGNhbGxiYWNrKSB7XG4gICAgdmFyIHN0cmVhbU5vZGVzID0gW107XG5cbiAgICBmdW5jdGlvbiB3YWxrTm9kZShub2RlKSB7XG4gICAgICAgIGlmIChub2RlLmNvbnRlbnQgJiYgdHlwZW9mIG5vZGUuY29udGVudC5waXBlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBzdHJlYW1Ob2Rlcy5wdXNoKG5vZGUpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChub2RlLmNoaWxkTm9kZXMgJiYgbm9kZS5jaGlsZE5vZGVzLmxlbmd0aCkge1xuICAgICAgICAgICAgbm9kZS5jaGlsZE5vZGVzLmZvckVhY2god2Fsa05vZGUpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHdhbGtOb2RlKG1haWwubWVzc2FnZSk7XG5cbiAgICBmdW5jdGlvbiByZXNvbHZlTm9kZXMoKSB7XG4gICAgICAgIGlmICghc3RyZWFtTm9kZXMubGVuZ3RoKSB7XG4gICAgICAgICAgICByZXR1cm4gY2FsbGJhY2soKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgbm9kZSA9IHN0cmVhbU5vZGVzLnNoaWZ0KCk7XG5cbiAgICAgICAgbWFpbC5yZXNvbHZlQ29udGVudChub2RlLCAnY29udGVudCcsIGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gY2FsbGJhY2soZXJyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHNldEltbWVkaWF0ZShyZXNvbHZlTm9kZXMpO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICByZXNvbHZlTm9kZXMoKTtcbn07XG5cbi8qKlxuICogUmVzb2x2ZXMgTVggc2VydmVyIGZvciBhIGRvbWFpbi4gVGhpcyBzb2x1dGlvbiBpcyBzb21ld2hhdCBpbmNvbXBsZXRlIGFzXG4gKiBpdCBvbmx5IGNvbnNpZGVycyB0aGUgaG9zdG5hbWUgd2l0aCBsb3dlc3QgcHJpb3JpdHkgYW5kIGlnbm9yZXMgYWxsIHRoZSByZXN0XG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IGRvbWFpbiBEb21haW4gdG8gcmVzb2x2ZSB0aGUgTVggdG9cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIENhbGxiYWNrIGZ1bmN0aW9uIHRvIHJ1blxuICovXG5EaXJlY3RNYWlsZXIucHJvdG90eXBlLl9yZXNvbHZlTXggPSBmdW5jdGlvbiAoZG9tYWluLCBjYWxsYmFjaykge1xuICAgIGRvbWFpbiA9IGRvbWFpbi5yZXBsYWNlKC9eXFxbKGlwdjY6KT98XFxdJC9naSwgJycpO1xuXG4gICAgLy8gRG8gbm90IHRyeSB0byByZXNvbHZlIHRoZSBkb21haW4gbmFtZSBpZiBpdCBpcyBhbiBJUCBhZGRyZXNzXG4gICAgaWYgKG5ldC5pc0lQKGRvbWFpbikpIHtcbiAgICAgICAgcmV0dXJuIGNhbGxiYWNrKG51bGwsIFt7XG4gICAgICAgICAgICBwcmlvcml0eTogMCxcbiAgICAgICAgICAgIGV4Y2hhbmdlOiBkb21haW5cbiAgICAgICAgfV0pO1xuICAgIH1cblxuICAgIGRucy5yZXNvbHZlTXgoZG9tYWluLCBmdW5jdGlvbiAoZXJyLCBsaXN0KSB7XG4gICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgIGlmIChlcnIuY29kZSA9PT0gJ0VOT0RBVEEnKSB7XG4gICAgICAgICAgICAgICAgLy8gZmFsbGJhY2sgdG8gQVxuICAgICAgICAgICAgICAgIGRucy5yZXNvbHZlNChkb21haW4sIGZ1bmN0aW9uIChlcnIsIGxpc3QpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGVyci5jb2RlID09PSAnRU5PREFUQScpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBmYWxsYmFjayB0byBBQUFBXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZG5zLnJlc29sdmU2KGRvbWFpbiwgZnVuY3Rpb24gKGVyciwgbGlzdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gY2FsbGJhY2soZXJyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHJldHVybiB0aGUgZmlyc3QgcmVzb2x2ZWQgSXB2NiB3aXRoIHByaW9yaXR5IDBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKG51bGwsIFtdLmNvbmNhdChsaXN0IHx8IFtdKS5tYXAoZnVuY3Rpb24gKGVudHJ5KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByaW9yaXR5OiAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV4Y2hhbmdlOiBlbnRyeVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSkuc2xpY2UoMCwgMSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gY2FsbGJhY2soZXJyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIC8vIHJldHVybiB0aGUgZmlyc3QgcmVzb2x2ZWQgSXB2NCB3aXRoIHByaW9yaXR5IDBcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKG51bGwsIFtdLmNvbmNhdChsaXN0IHx8IFtdKS5tYXAoZnVuY3Rpb24gKGVudHJ5KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByaW9yaXR5OiAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV4Y2hhbmdlOiBlbnRyeVxuICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgfSkuc2xpY2UoMCwgMSkpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gY2FsbGJhY2soZXJyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjYWxsYmFjayhudWxsLCBsaXN0KTtcbiAgICB9KTtcbn07XG5cbi8qKlxuICogUmVzb2x2ZXMgY3VycmVudCBob3N0bmFtZS4gSWYgcmVzb2x2ZWQgbmFtZSBpcyBhbiBJUCBhZGRyZXNzLCB1c2VzICdsb2NhbGhvc3QnLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBbbmFtZV0gUHJlZmVycmVkIGhvc3RuYW1lXG4gKiBAcmV0dXJuIHtTdHJpbmd9IFJlc29sdmVkIGhvc3RuYW1lXG4gKi9cbkRpcmVjdE1haWxlci5wcm90b3R5cGUuX3Jlc29sdmVIb3N0bmFtZSA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgaWYgKCFuYW1lIHx8IG5ldC5pc0lQKG5hbWUucmVwbGFjZSgvW1xcW1xcXV0vZywgJycpLnRyaW0oKSkpIHtcbiAgICAgICAgbmFtZSA9IChvcy5ob3N0bmFtZSAmJiBvcy5ob3N0bmFtZSgpKSB8fCAnJztcbiAgICB9XG5cbiAgICBpZiAoIW5hbWUgfHwgbmV0LmlzSVAobmFtZS5yZXBsYWNlKC9bXFxbXFxdXS9nLCAnJykudHJpbSgpKSkge1xuICAgICAgICBuYW1lID0gJ2xvY2FsaG9zdCc7XG4gICAgfVxuXG4gICAgcmV0dXJuIG5hbWUudG9Mb3dlckNhc2UoKTtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbi8vIGV4cG9zZSB0byB0aGUgd29ybGRcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBuZXcgTWVzc2FnZVF1ZXVlKCk7XG59O1xuXG4vKipcbiAqIENyZWF0ZXMgYSBxdWV1ZSBvYmplY3RcbiAqXG4gKiBAY29uc3RydWN0b3JcbiAqL1xuZnVuY3Rpb24gTWVzc2FnZVF1ZXVlKCkge1xuICAgIHRoaXMuX2luc3RhbnRRdWV1ZSA9IFtdO1xuICAgIHRoaXMuX3NvcnRlZFF1ZXVlID0gW107XG4gICAgdGhpcy5fc2hpZnRUaW1lciA9IG51bGw7XG4gICAgdGhpcy5fY2FsbGJhY2tRdWV1ZSA9IFtdO1xufVxuXG4vKipcbiAqIFNldHMgYSBjYWxsYmFjayB0byBiZSBydW4gd2hlbiBzb21ldGhpbmcgY29tZXMgYXZhaWxhYmxlIGZyb20gdGhlIHF1ZXVlXG4gKlxuICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgQ2FsbGJhY2sgZnVuY3Rpb24gdG8gcnVuIHdpdGggcXVldWUgZWxlbWVudCBhcyBhbiBhcmd1bWVudFxuICovXG5NZXNzYWdlUXVldWUucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uIChjYWxsYmFjaykge1xuICAgIGlmICh0aGlzLl9pbnN0YW50UXVldWUubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiBjYWxsYmFjayh0aGlzLl9pbnN0YW50UXVldWUucG9wKCkpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuX2NhbGxiYWNrUXVldWUudW5zaGlmdChjYWxsYmFjayk7XG4gICAgfVxufTtcblxuLyoqXG4gKiBBZGRzIGFuIGVsZW1lbnQgdG8gdGhlIHF1ZXVlLiBJZiBkZWxheSAobXMpIGlzIHNldCwgdGhlIGRhdGEgd2lsbCBub3QgYmUgYXZhaWxhYmxlIGJlZm9yZVxuICogc3BlY2lmaWVkIGRlbGF5IGhhcyBwYXNzZWQuIE90aGVyd2lzZSB0aGUgZGF0YSB3aWxsIGJlIGF2YWlsYWJsZSBmb3IgcHJvY2Vzc2luZyBpbW1lZGlhdGVsbHkuXG4gKlxuICogQHBhcmFtIHtNaXhlZH0gZGF0YSBWYWx1ZSB0byBiZSBxdWV1ZWRcbiAqIEBwYXJhbSB7TnVtYmVyfSBbZGVsYXldIElmIHNldCwgZGVsYXkgdGhlIGF2YWlsYWJpbGl0eSBvZiB0aGUgZGF0YSBieSB7ZGVsYXl9IG1pbGxpc2Vjb25kc1xuICovXG5NZXNzYWdlUXVldWUucHJvdG90eXBlLmluc2VydCA9IGZ1bmN0aW9uIChkYXRhLCBkZWxheSkge1xuICAgIHZhciBjb250YWluZXIsIGFkZGVkID0gLTE7XG4gICAgaWYgKHR5cGVvZiBkZWxheSAhPT0gJ251bWJlcicpIHtcbiAgICAgICAgdGhpcy5faW5zdGFudFF1ZXVlLnVuc2hpZnQoZGF0YSk7XG4gICAgICAgIHRoaXMuX3Byb2Nlc3NJbnNlcnQoKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgY29udGFpbmVyID0ge1xuICAgICAgICAgICAgZGF0YTogZGF0YSxcbiAgICAgICAgICAgIGF2YWlsYWJsZTogRGF0ZS5ub3coKSArIGRlbGF5XG4gICAgICAgIH07XG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSB0aGlzLl9zb3J0ZWRRdWV1ZS5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgaWYgKHRoaXMuX3NvcnRlZFF1ZXVlW2ldLmF2YWlsYWJsZSA+PSBjb250YWluZXIuYXZhaWxhYmxlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fc29ydGVkUXVldWUuc3BsaWNlKGksIDAsIGNvbnRhaW5lcik7XG4gICAgICAgICAgICAgICAgYWRkZWQgPSBpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChhZGRlZCA8IDApIHtcbiAgICAgICAgICAgIHRoaXMuX3NvcnRlZFF1ZXVlLnB1c2goY29udGFpbmVyKTtcbiAgICAgICAgICAgIGFkZGVkID0gMDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChhZGRlZCA9PT0gMCkge1xuICAgICAgICAgICAgdGhpcy5fdXBkYXRlU2hpZnRUaW1lcigpO1xuICAgICAgICB9XG4gICAgfVxufTtcblxuLyoqXG4gKiBDbGVhcnMgcHJldmlvdXMgdGltZXIgYW5kIGNyZWF0ZXMgYSBuZXcgb25lIChpZiBuZWVkZWQpIHRvIHByb2Nlc3MgdGhlIGVsZW1lbnRcbiAqIGluIHRoZSBxdWV1ZSB0aGF0IG5lZWRzIHRvIGJlIHByb2Nlc3NlZCBmaXJzdC5cbiAqL1xuTWVzc2FnZVF1ZXVlLnByb3RvdHlwZS5fdXBkYXRlU2hpZnRUaW1lciA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgbmV4dFNoaWZ0LCBub3cgPSBEYXRlLm5vdygpO1xuICAgIGNsZWFyVGltZW91dCh0aGlzLl9zaGlmdFRpbWVyKTtcblxuICAgIGlmICghdGhpcy5fc29ydGVkUXVldWUubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBuZXh0U2hpZnQgPSB0aGlzLl9zb3J0ZWRRdWV1ZVswXS5hdmFpbGFibGU7XG5cbiAgICBpZiAobmV4dFNoaWZ0IDw9IG5vdykge1xuICAgICAgICB0aGlzLl9zaGlmdFNvcnRlZCgpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHNldFRpbWVvdXQodGhpcy5fc2hpZnRTb3J0ZWQuYmluZCh0aGlzKSxcbiAgICAgICAgICAgIC8vIGFkZCArMTVtcyB0byBlbnN1cmUgdGhhdCBkYXRhIGlzIGFscmVhZHkgYXZhaWxhYmxlIHdoZW4gdGhlIHRpbWVyIGlzIGZpcmVkXG4gICAgICAgICAgICB0aGlzLl9zb3J0ZWRRdWV1ZVswXS5hdmFpbGFibGUgLSBEYXRlLm5vdygpICsgMTUpO1xuICAgIH1cbn07XG5cbi8qKlxuICogTW92ZXMgYW4gZWxlbWVudCBmcm9tIHRoZSBkZWxheWVkIHF1ZXVlIHRvIHRoZSBpbW1lZGlhdGUgcXVldWUgaWYgYW4gZWxtZW5ldFxuICogYmVjb21lcyBhdmlsYWJsZVxuICovXG5NZXNzYWdlUXVldWUucHJvdG90eXBlLl9zaGlmdFNvcnRlZCA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgY29udGFpbmVyO1xuICAgIGlmICghdGhpcy5fc29ydGVkUXVldWUubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5fc29ydGVkUXVldWVbMF0uYXZhaWxhYmxlIDw9IERhdGUubm93KCkpIHtcbiAgICAgICAgY29udGFpbmVyID0gdGhpcy5fc29ydGVkUXVldWUuc2hpZnQoKTtcbiAgICAgICAgdGhpcy5pbnNlcnQoY29udGFpbmVyLmRhdGEpO1xuICAgIH1cblxuICAgIHRoaXMuX3VwZGF0ZVNoaWZ0VGltZXIoKTtcbn07XG5cbi8qKlxuICogSWYgZGF0YSBmcm9tIGEgcXVldWUgaXMgYXZhaWxhYmxlIGFuZCBhIGNhbGxiYWNrIGlzIHNldCwgcnVuIHRoZSBjYWxsYmFja1xuICogd2l0aCBhdmFpbGFibGUgZGF0YVxuICovXG5NZXNzYWdlUXVldWUucHJvdG90eXBlLl9wcm9jZXNzSW5zZXJ0ID0gZnVuY3Rpb24gKCkge1xuICAgIGlmICh0aGlzLl9pbnN0YW50UXVldWUubGVuZ3RoICYmIHRoaXMuX2NhbGxiYWNrUXVldWUubGVuZ3RoKSB7XG4gICAgICAgIHRoaXMuX2NhbGxiYWNrUXVldWUucG9wKCkodGhpcy5faW5zdGFudFF1ZXVlLnBvcCgpKTtcbiAgICB9XG59O1xuIiwibW9kdWxlLmV4cG9ydHM9e1xuICBcIl9hcmdzXCI6IFtcbiAgICBbXG4gICAgICBcIm5vZGVtYWlsZXItZGlyZWN0LXRyYW5zcG9ydEBodHRwczovL3JlZ2lzdHJ5Lm5wbWpzLm9yZy9ub2RlbWFpbGVyLWRpcmVjdC10cmFuc3BvcnQvLS9ub2RlbWFpbGVyLWRpcmVjdC10cmFuc3BvcnQtMy4xLjAudGd6XCIsXG4gICAgICBcIi9Vc2Vycy9uaG9uZy9uaWNraG9uZy5pby9ub2RlX21vZHVsZXMvbm9kZW1haWxlclwiXG4gICAgXVxuICBdLFxuICBcIl9mcm9tXCI6IFwibm9kZW1haWxlci1kaXJlY3QtdHJhbnNwb3J0QDMuMS4wXCIsXG4gIFwiX2lkXCI6IFwibm9kZW1haWxlci1kaXJlY3QtdHJhbnNwb3J0QDMuMS4wXCIsXG4gIFwiX2luQ2FjaGVcIjogdHJ1ZSxcbiAgXCJfbG9jYXRpb25cIjogXCIvbm9kZW1haWxlci9ub2RlbWFpbGVyLWRpcmVjdC10cmFuc3BvcnRcIixcbiAgXCJfcGhhbnRvbUNoaWxkcmVuXCI6IHt9LFxuICBcIl9yZXF1ZXN0ZWRcIjoge1xuICAgIFwibmFtZVwiOiBcIm5vZGVtYWlsZXItZGlyZWN0LXRyYW5zcG9ydFwiLFxuICAgIFwicmF3XCI6IFwibm9kZW1haWxlci1kaXJlY3QtdHJhbnNwb3J0QGh0dHBzOi8vcmVnaXN0cnkubnBtanMub3JnL25vZGVtYWlsZXItZGlyZWN0LXRyYW5zcG9ydC8tL25vZGVtYWlsZXItZGlyZWN0LXRyYW5zcG9ydC0zLjEuMC50Z3pcIixcbiAgICBcInJhd1NwZWNcIjogXCJodHRwczovL3JlZ2lzdHJ5Lm5wbWpzLm9yZy9ub2RlbWFpbGVyLWRpcmVjdC10cmFuc3BvcnQvLS9ub2RlbWFpbGVyLWRpcmVjdC10cmFuc3BvcnQtMy4xLjAudGd6XCIsXG4gICAgXCJzY29wZVwiOiBudWxsLFxuICAgIFwic3BlY1wiOiBcImh0dHBzOi8vcmVnaXN0cnkubnBtanMub3JnL25vZGVtYWlsZXItZGlyZWN0LXRyYW5zcG9ydC8tL25vZGVtYWlsZXItZGlyZWN0LXRyYW5zcG9ydC0zLjEuMC50Z3pcIixcbiAgICBcInR5cGVcIjogXCJyZW1vdGVcIlxuICB9LFxuICBcIl9yZXF1aXJlZEJ5XCI6IFtcbiAgICBcIi9ub2RlbWFpbGVyXCJcbiAgXSxcbiAgXCJfcmVzb2x2ZWRcIjogXCJodHRwczovL3JlZ2lzdHJ5Lm5wbWpzLm9yZy9ub2RlbWFpbGVyLWRpcmVjdC10cmFuc3BvcnQvLS9ub2RlbWFpbGVyLWRpcmVjdC10cmFuc3BvcnQtMy4xLjAudGd6XCIsXG4gIFwiX3NoYXN1bVwiOiBcIjMwOGI2ZjRjMTYwMDBhM2FmMWFmMWJiNDllYWZkNmEwYjI3NDdiNjJcIixcbiAgXCJfc2hyaW5rd3JhcFwiOiBudWxsLFxuICBcIl9zcGVjXCI6IFwibm9kZW1haWxlci1kaXJlY3QtdHJhbnNwb3J0QGh0dHBzOi8vcmVnaXN0cnkubnBtanMub3JnL25vZGVtYWlsZXItZGlyZWN0LXRyYW5zcG9ydC8tL25vZGVtYWlsZXItZGlyZWN0LXRyYW5zcG9ydC0zLjEuMC50Z3pcIixcbiAgXCJfd2hlcmVcIjogXCIvVXNlcnMvbmhvbmcvbmlja2hvbmcuaW8vbm9kZV9tb2R1bGVzL25vZGVtYWlsZXJcIixcbiAgXCJhdXRob3JcIjoge1xuICAgIFwibmFtZVwiOiBcIkFuZHJpcyBSZWlubWFuXCJcbiAgfSxcbiAgXCJidWdzXCI6IHtcbiAgICBcInVybFwiOiBcImh0dHBzOi8vZ2l0aHViLmNvbS9hbmRyaXM5L25vZGVtYWlsZXItZGlyZWN0LXRyYW5zcG9ydC9pc3N1ZXNcIlxuICB9LFxuICBcImRlcGVuZGVuY2llc1wiOiB7XG4gICAgXCJub2RlbWFpbGVyLXNoYXJlZFwiOiBcIjEuMC41XCIsXG4gICAgXCJzbXRwLWNvbm5lY3Rpb25cIjogXCIyLjUuMFwiXG4gIH0sXG4gIFwiZGVzY3JpcHRpb25cIjogXCJEaXJlY3QgdHJhbnNwb3J0IGZvciBOb2RlbWFpbGVyXCIsXG4gIFwiZGV2RGVwZW5kZW5jaWVzXCI6IHtcbiAgICBcImNoYWlcIjogXCJeMy41LjBcIixcbiAgICBcImdydW50XCI6IFwiXjEuMC4xXCIsXG4gICAgXCJncnVudC1lc2xpbnRcIjogXCJeMTguMS4wXCIsXG4gICAgXCJncnVudC1tb2NoYS10ZXN0XCI6IFwiXjAuMTIuN1wiLFxuICAgIFwibW9jaGFcIjogXCJeMi40LjVcIixcbiAgICBcInNtdHAtc2VydmVyXCI6IFwiXjEuOS4xXCJcbiAgfSxcbiAgXCJob21lcGFnZVwiOiBcImh0dHA6Ly9naXRodWIuY29tL2FuZHJpczkvbm9kZW1haWxlci1kaXJlY3QtdHJhbnNwb3J0XCIsXG4gIFwia2V5d29yZHNcIjogW1xuICAgIFwiU01UUFwiLFxuICAgIFwiTm9kZW1haWxlclwiXG4gIF0sXG4gIFwibGljZW5zZVwiOiBcIk1JVFwiLFxuICBcIm1haW5cIjogXCJsaWIvZGlyZWN0LXRyYW5zcG9ydC5qc1wiLFxuICBcIm5hbWVcIjogXCJub2RlbWFpbGVyLWRpcmVjdC10cmFuc3BvcnRcIixcbiAgXCJvcHRpb25hbERlcGVuZGVuY2llc1wiOiB7fSxcbiAgXCJyZWFkbWVcIjogXCIjIERpcmVjdCBTTVRQIHRyYW5zcG9ydCBtb2R1bGUgZm9yIE5vZGVtYWlsZXJcXG5cXG5BcHBsaWVzIGZvciBOb2RlbWFpbGVyIHYxLnggYW5kIG5vdCBmb3IgdjAueCB3aGVyZSB0cmFuc3BvcnRzIGFyZSBidWlsdC1pbi5cXG5cXG4jIyBVc2FnZVxcblxcbkluc3RhbGwgd2l0aCBucG1cXG5cXG4gICAgbnBtIGluc3RhbGwgbm9kZW1haWxlci1kaXJlY3QtdHJhbnNwb3J0XFxuXFxuUmVxdWlyZSB0byB5b3VyIHNjcmlwdFxcblxcbmBgYGphdmFzY3JpcHRcXG52YXIgbm9kZW1haWxlciA9IHJlcXVpcmUoJ25vZGVtYWlsZXInKTtcXG52YXIgZGlyZWN0VHJhbnNwb3J0ID0gcmVxdWlyZSgnbm9kZW1haWxlci1kaXJlY3QtdHJhbnNwb3J0Jyk7XFxuYGBgXFxuXFxuQ3JlYXRlIGEgTm9kZW1haWxlciB0cmFuc3BvcnQgb2JqZWN0XFxuXFxuYGBgamF2YXNjcmlwdFxcbnZhciB0cmFuc3BvcnRlciA9IG5vZGVtYWlsZXIuY3JlYXRlVHJhbnNwb3J0KGRpcmVjdFRyYW5zcG9ydChvcHRpb25zKSlcXG5gYGBcXG5cXG5XaGVyZVxcblxcbiAgKiAqKm9wdGlvbnMqKiBkZWZpbmVzIGNvbm5lY3Rpb24gZGF0YVxcbiAgICAqICoqb3B0aW9ucy5uYW1lKiogaG9zdG5hbWUgdG8gYmUgdXNlZCB3aGVuIGludHJvZHVjaW5nIHRoZSBjbGllbnQgdG8gdGhlIE1YIHNlcnZlclxcbiAgICAqICoqb3B0aW9ucy5sb2dnZXIqKiBvcHRpb25hbCBbYnVueWFuXShodHRwczovL2dpdGh1Yi5jb20vdHJlbnRtL25vZGUtYnVueWFuKSBjb21wYXRpYmxlIGxvZ2dlciBpbnN0YW5jZS4gSWYgc2V0IHRvIGB0cnVlYCB0aGVuIGxvZ3MgdG8gY29uc29sZS4gSWYgdmFsdWUgaXMgbm90IHNldCBvciBpcyBgZmFsc2VgIHRoZW4gbm90aGluZyBpcyBsb2dnZWRcXG4gICAgKiAqKm9wdGlvbnMuZGVidWcqKiBpZiBzZXQgdG8gdHJ1ZSwgdGhlbiBsb2dzIFNNVFAgdHJhZmZpYywgb3RoZXJ3aXNlIGxvZ3Mgb25seSB0cmFuc2FjdGlvbiBldmVudHNcXG4gICAgKiAqKm9wdGlvbnMucG9ydCoqIG9wdGlvbmFsIHBvcnQgdG8gdXNlIGZvciBjb25uZWN0aW5nIHRvIE1YIHNlcnZlcnMgKGRlZmF1bHRzIHRvIE1UQSBzdGFuZGFyZCAyNSlcXG4gICAgKiAqKm9wdGlvbnMucmV0cnlEZWxheSoqIG9wdGlvbmFsIHRpbWVvdXQgaW4gbXMgZm9yIHJldHJ5aW5nIGZhaWxlZCBtZXNzYWdlcyAoZGVmYXVsdHMgdG8gMTUgbWludXRlcylcXG4gICAgKiAqKmdldFNvY2tldCoqIG9wdGlvbmFsIG1ldGhvZCB0aGF0IGlzIGNhbGxlZCBldmVyeSB0aW1lIGEgbmV3IGNvbm5lY3Rpb24gaXMgbWFkZSBhZ2FpbnN0IHRoZSBTTVRQIHNlcnZlci4gVGhpcyBtZXRob2QgY2FuIHByb3ZpZGUgYW4gZXhpc3Rpbmcgc29ja2V0IHRvIGJlIHVzZWQgaW5zdGVhZCBvZiBjcmVhdGluZyBhIG5ldyBvbmVcXG5cXG4qKkV4YW1wbGUqKlxcblxcbmBgYGphdmFzY3JpcHRcXG52YXIgdHJhbnNwb3J0ID0gbm9kZW1haWxlci5jcmVhdGVUcmFuc3BvcnQoZGlyZWN0VHJhbnNwb3J0KHtcXG4gICAgbmFtZTogJ3NtdHAuZXhhbXBsZS5jb20nIC8vIHNob3VsZCBiZSB0aGUgaG9zdG5hbWUgbWFjaGluZSBJUCBhZGRyZXNzIHJlc29sdmVzIHRvXFxufSkpO1xcbmBgYFxcblxcbiMjIHNlbmQgY2FsbGJhY2tcXG5cXG5TZW5kIGNhbGxiYWNrIGluY2x1ZGVzIHRoZSBmb2xsb3dpbmcgYXJndW1lbnRzXFxuXFxuICAqICoqZXJyb3IqKiBpZiB0aGUgbWFpbCB3YXMgbm90IHNlbnRcXG4gICAgKiAqKmVycm9yLmVycm9ycyoqIGlzIGFuIGFycmF5IG9mIGVycm9yIHJlc3BvbnNlcyAob25lIHJlc3BvbnNlIGZvciBvbmUgTVggZXhjaGFuZ2UpXFxuICAgICAgKiAqKmVycm9yLmVycm9yc1tdLnJlY2lwaWVudHMqKiBhbiBhcnJheSBvZiBmYWlsZWQgcmVjaXBpZW50c1xcbiAgICAgICogKiplcnJvci5lcnJvcnNbXS5yZXNwb25zZSoqIEVycm9yIHJlc3BvbnNlIGZyb20gdGhlIFNNVFAgc2VydmVyXFxuICAqICoqaW5mbyoqIGlmIGF0IGxlYXN0IG9uZSBtYWlsIHdhcyBzZW50IG9yIGlzIHBlbmRpbmdcXG4gICAgKiAqKmluZm8uYWNjZXB0ZWQqKiBhbiBhcnJheSBvZiByZWNpcGllbnRzIHRoYXQgd2VyZSBhY2NlcHRlZFxcbiAgICAqICoqaW5mby5yZWplY3RlZCoqIGFuIGFycmF5IG9mIHJlY2lwaWVudHMgdGhhdCB3ZXJlIHJlamVjdGVkXFxuICAgICogKippbmZvLnBlbmRpbmcqKiBhbiBhcnJheSBvZiBwZW5kaW5nIHJlY2lwaWVudCBvYmplY3RzIChtZXNzYWdlcyB0aGF0IHdlcmUgbm90IHJlamVjdGVkIHBlcm1hbmVudGx5IGFuZCBhcmUgcmV0cmllZCBsYXRlcilcXG4gICAgICAqICoqaW5mby5wZW5kaW5nW10ucmVjaXBpZW50cyoqIGFuIGFycmF5IG9mIHJlY2lwaWVudCBhZGRyZXNzZXMgdGhhdCBhcmUgc3RpbGwgcGVuZGluZ1xcbiAgICAgICogKippbmZvLnBlbmRpbmdbXS5yZXNwb25zZSoqIFJlc3BvbnNlIGZyb20gdGhlIFNNVFAgc2VydmVyXFxuICAgICogKippbmZvLmVycm9ycyoqIEFuIGFycmF5IG9mIGVycm9ycyAoZm9yIHRoZXNlIGV4aGFuZ2VzIHRoYXQgcmVqZWN0ZWQgbWFpbClcXG5cXG4jIyBJc3N1ZXNcXG5cXG5EaXJlY3QgdHJhbnNwb3J0IGlzIHZlcnkgaW5lZmZpY2llbnQgYXMgaXQgcXVldWVzIGFsbCBlLW1haWxzIHRvIGJlIHNlbnQgaW50byBtZW1vcnkuIEFkZGl0aW9uYWxseSwgaWYgYSBtZXNzYWdlIGlzIG5vdCB5ZXQgc2VudCBhbmQgdGhlIHByb2Nlc3MgaXMgY2xvc2VkLCBhbGwgZGF0YSBhYm91dCBxdWV1ZWQgbWVzc2FnZXMgaXMgbG9zdC4gVGh1cyBkaXJlY3QgdHJhbnNwb3J0IGlzIG9ubHkgc3VpdGFibGUgZm9yIGxvdyB0aHJvdWdocHV0IHN5c3RlbXMsIHdoZXJlIHRoZSBtZXNzYWdlIGNhbiBiZSBwcm9jZXNzZWQgaW1tZWRpYXRlbHkuXFxuXFxuV2hpbGUgbm90IGJlaW5nIDEwMCUgcmVsaWFibGUgKHJlbWVtYmVyIC0gaWYgcHJvY2VzcyBleGl0cywgZW50aXJlIHF1ZXVlIGlzIGxvc3QpLCBkaXJlY3QgdHJhbnNwb3J0IGNhbiBzdGlsbCBoYW5kbGUgc2VuZGluZyBlcnJvcnMsIGdyYXlsaXN0aW5nIGFuZCBzdWNoLiBJZiBhIG1lc3NhZ2UgY2FuIG5vdCBiZSBzZW50LCBpdCBpcyByZS1xdWV1ZWQgYW5kIHJldHJpZWQgbGF0ZXIuXFxuXFxuIyMgTGljZW5zZVxcblxcbioqTUlUKipcXG5cIixcbiAgXCJyZWFkbWVGaWxlbmFtZVwiOiBcIlJFQURNRS5tZFwiLFxuICBcInJlcG9zaXRvcnlcIjoge1xuICAgIFwidHlwZVwiOiBcImdpdFwiLFxuICAgIFwidXJsXCI6IFwiZ2l0Oi8vZ2l0aHViLmNvbS9hbmRyaXM5L25vZGVtYWlsZXItZGlyZWN0LXRyYW5zcG9ydC5naXRcIlxuICB9LFxuICBcInNjcmlwdHNcIjoge1xuICAgIFwidGVzdFwiOiBcImdydW50XCJcbiAgfSxcbiAgXCJ2ZXJzaW9uXCI6IFwiMy4xLjBcIlxufVxuIiwiJ3VzZSBzdHJpY3QnO1xuXG4vLyBtb2R1bGUgdG8gaGFuZGxlIGNvb2tpZXNcblxudmFyIHVybGxpYiA9IHJlcXVpcmUoJ3VybCcpO1xuXG52YXIgU0VTU0lPTl9USU1FT1VUID0gMTgwMDsgLy8gMzAgbWluXG5cbm1vZHVsZS5leHBvcnRzID0gQ29va2llcztcblxuLyoqXG4gKiBDcmVhdGVzIGEgYmlza3ZpaXQgY29va2llIGphciBmb3IgbWFuYWdpbmcgY29va2llIHZhbHVlcyBpbiBtZW1vcnlcbiAqXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gT3B0aW9uYWwgb3B0aW9ucyBvYmplY3RcbiAqL1xuZnVuY3Rpb24gQ29va2llcyhvcHRpb25zKSB7XG4gICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgICB0aGlzLmNvb2tpZXMgPSBbXTtcbn1cblxuLyoqXG4gKiBTdG9yZXMgYSBjb29raWUgc3RyaW5nIHRvIHRoZSBjb29raWUgc3RvcmFnZVxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBjb29raWVTdHIgVmFsdWUgZnJvbSB0aGUgJ1NldC1Db29raWU6JyBoZWFkZXJcbiAqIEBwYXJhbSB7U3RyaW5nfSB1cmwgQ3VycmVudCBVUkxcbiAqL1xuQ29va2llcy5wcm90b3R5cGUuc2V0ID0gZnVuY3Rpb24gKGNvb2tpZVN0ciwgdXJsKSB7XG4gICAgdmFyIHVybHBhcnRzID0gdXJsbGliLnBhcnNlKHVybCB8fCAnJyk7XG4gICAgdmFyIGNvb2tpZSA9IHRoaXMucGFyc2UoY29va2llU3RyKTtcbiAgICB2YXIgZG9tYWluO1xuXG4gICAgaWYgKGNvb2tpZS5kb21haW4pIHtcbiAgICAgICAgZG9tYWluID0gY29va2llLmRvbWFpbi5yZXBsYWNlKC9eXFwuLywgJycpO1xuXG4gICAgICAgIC8vIGRvIG5vdCBhbGxvdyBjcm9zcyBvcmlnaW4gY29va2llc1xuICAgICAgICBpZiAoXG4gICAgICAgICAgICAvLyBjYW4ndCBiZSB2YWxpZCBpZiB0aGUgcmVxdWVzdGVkIGRvbWFpbiBpcyBzaG9ydGVyIHRoYW4gY3VycmVudCBob3N0bmFtZVxuICAgICAgICAgICAgdXJscGFydHMuaG9zdG5hbWUubGVuZ3RoIDwgZG9tYWluLmxlbmd0aCB8fFxuXG4gICAgICAgICAgICAvLyBwcmVmaXggZG9tYWlucyB3aXRoIGRvdCB0byBiZSBzdXJlIHRoYXQgcGFydGlhbCBtYXRjaGVzIGFyZSBub3QgdXNlZFxuICAgICAgICAgICAgKCcuJyArIHVybHBhcnRzLmhvc3RuYW1lKS5zdWJzdHIoLWRvbWFpbi5sZW5ndGggKyAxKSAhPT0gKCcuJyArIGRvbWFpbikpIHtcbiAgICAgICAgICAgIGNvb2tpZS5kb21haW4gPSB1cmxwYXJ0cy5ob3N0bmFtZTtcbiAgICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAgIGNvb2tpZS5kb21haW4gPSB1cmxwYXJ0cy5ob3N0bmFtZTtcbiAgICB9XG5cbiAgICBpZiAoIWNvb2tpZS5wYXRoKSB7XG4gICAgICAgIGNvb2tpZS5wYXRoID0gdGhpcy5nZXRQYXRoKHVybHBhcnRzLnBhdGhuYW1lKTtcbiAgICB9XG5cbiAgICAvLyBpZiBubyBleHBpcmUgZGF0ZSwgdGhlbiB1c2Ugc2Vzc2lvblRpbWVvdXQgdmFsdWVcbiAgICBpZiAoIWNvb2tpZS5leHBpcmVzKSB7XG4gICAgICAgIGNvb2tpZS5leHBpcmVzID0gbmV3IERhdGUoRGF0ZS5ub3coKSArIChOdW1iZXIodGhpcy5vcHRpb25zLnNlc3Npb25UaW1lb3V0IHx8IFNFU1NJT05fVElNRU9VVCkgfHwgU0VTU0lPTl9USU1FT1VUKSAqIDEwMDApO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLmFkZChjb29raWUpO1xufTtcblxuLyoqXG4gKiBSZXR1cm5zIGNvb2tpZSBzdHJpbmcgZm9yIHRoZSAnQ29va2llOicgaGVhZGVyLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSB1cmwgVVJMIHRvIGNoZWNrIGZvclxuICogQHJldHVybnMge1N0cmluZ30gQ29va2llIGhlYWRlciBvciBlbXB0eSBzdHJpbmcgaWYgbm8gbWF0Y2hlcyB3ZXJlIGZvdW5kXG4gKi9cbkNvb2tpZXMucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uICh1cmwpIHtcbiAgICByZXR1cm4gdGhpcy5saXN0KHVybCkubWFwKGZ1bmN0aW9uIChjb29raWUpIHtcbiAgICAgICAgcmV0dXJuIGNvb2tpZS5uYW1lICsgJz0nICsgY29va2llLnZhbHVlO1xuICAgIH0pLmpvaW4oJzsgJyk7XG59O1xuXG4vKipcbiAqIExpc3RzIGFsbCB2YWxpZWQgY29va2llIG9iamVjdHMgZm9yIHRoZSBzcGVjaWZpZWQgVVJMXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHVybCBVUkwgdG8gY2hlY2sgZm9yXG4gKiBAcmV0dXJucyB7QXJyYXl9IEFuIGFycmF5IG9mIGNvb2tpZSBvYmplY3RzXG4gKi9cbkNvb2tpZXMucHJvdG90eXBlLmxpc3QgPSBmdW5jdGlvbiAodXJsKSB7XG4gICAgdmFyIHJlc3VsdCA9IFtdO1xuICAgIHZhciBpO1xuICAgIHZhciBjb29raWU7XG5cbiAgICBmb3IgKGkgPSB0aGlzLmNvb2tpZXMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgY29va2llID0gdGhpcy5jb29raWVzW2ldO1xuXG4gICAgICAgIGlmICh0aGlzLmlzRXhwaXJlZChjb29raWUpKSB7XG4gICAgICAgICAgICB0aGlzLmNvb2tpZXMuc3BsaWNlKGksIGkpO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5tYXRjaChjb29raWUsIHVybCkpIHtcbiAgICAgICAgICAgIHJlc3VsdC51bnNoaWZ0KGNvb2tpZSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gcmVzdWx0O1xufTtcblxuLyoqXG4gKiBQYXJzZXMgY29va2llIHN0cmluZyBmcm9tIHRoZSAnU2V0LUNvb2tpZTonIGhlYWRlclxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBjb29raWVTdHIgU3RyaW5nIGZyb20gdGhlICdTZXQtQ29va2llOicgaGVhZGVyXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBDb29raWUgb2JqZWN0XG4gKi9cbkNvb2tpZXMucHJvdG90eXBlLnBhcnNlID0gZnVuY3Rpb24gKGNvb2tpZVN0cikge1xuICAgIHZhciBjb29raWUgPSB7fTtcblxuICAgIChjb29raWVTdHIgfHwgJycpLnRvU3RyaW5nKCkuc3BsaXQoJzsnKS5mb3JFYWNoKGZ1bmN0aW9uIChjb29raWVQYXJ0KSB7XG4gICAgICAgIHZhciB2YWx1ZVBhcnRzID0gY29va2llUGFydC5zcGxpdCgnPScpO1xuICAgICAgICB2YXIga2V5ID0gdmFsdWVQYXJ0cy5zaGlmdCgpLnRyaW0oKS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICB2YXIgdmFsdWUgPSB2YWx1ZVBhcnRzLmpvaW4oJz0nKS50cmltKCk7XG4gICAgICAgIHZhciBkb21haW47XG5cbiAgICAgICAgaWYgKCFrZXkpIHtcbiAgICAgICAgICAgIC8vIHNraXAgZW1wdHkgcGFydHNcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHN3aXRjaCAoa2V5KSB7XG5cbiAgICAgICAgICAgIGNhc2UgJ2V4cGlyZXMnOlxuICAgICAgICAgICAgICAgIHZhbHVlID0gbmV3IERhdGUodmFsdWUpO1xuICAgICAgICAgICAgICAgIC8vIGlnbm9yZSBkYXRlIGlmIGNhbiBub3QgcGFyc2UgaXRcbiAgICAgICAgICAgICAgICBpZiAodmFsdWUudG9TdHJpbmcoKSAhPT0gJ0ludmFsaWQgRGF0ZScpIHtcbiAgICAgICAgICAgICAgICAgICAgY29va2llLmV4cGlyZXMgPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgIGNhc2UgJ3BhdGgnOlxuICAgICAgICAgICAgICAgIGNvb2tpZS5wYXRoID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgIGNhc2UgJ2RvbWFpbic6XG4gICAgICAgICAgICAgICAgZG9tYWluID0gdmFsdWUudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgICAgICAgICBpZiAoZG9tYWluLmxlbmd0aCAmJiBkb21haW4uY2hhckF0KDApICE9PSAnLicpIHtcbiAgICAgICAgICAgICAgICAgICAgZG9tYWluID0gJy4nICsgZG9tYWluOyAvLyBlbnN1cmUgcHJlY2VlZGluZyBkb3QgZm9yIHVzZXIgc2V0IGRvbWFpbnNcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29va2llLmRvbWFpbiA9IGRvbWFpbjtcbiAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgY2FzZSAnbWF4LWFnZSc6XG4gICAgICAgICAgICAgICAgY29va2llLmV4cGlyZXMgPSBuZXcgRGF0ZShEYXRlLm5vdygpICsgKE51bWJlcih2YWx1ZSkgfHwgMCkgKiAxMDAwKTtcbiAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgY2FzZSAnc2VjdXJlJzpcbiAgICAgICAgICAgICAgICBjb29raWUuc2VjdXJlID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgY2FzZSAnaHR0cG9ubHknOlxuICAgICAgICAgICAgICAgIGNvb2tpZS5odHRwb25seSA9IHRydWU7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgaWYgKCFjb29raWUubmFtZSkge1xuICAgICAgICAgICAgICAgICAgICBjb29raWUubmFtZSA9IGtleTtcbiAgICAgICAgICAgICAgICAgICAgY29va2llLnZhbHVlID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSk7XG5cbiAgICByZXR1cm4gY29va2llO1xufTtcblxuLyoqXG4gKiBDaGVja3MgaWYgYSBjb29raWUgb2JqZWN0IGlzIHZhbGlkIGZvciBhIHNwZWNpZmllZCBVUkxcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gY29va2llIENvb2tpZSBvYmplY3RcbiAqIEBwYXJhbSB7U3RyaW5nfSB1cmwgVVJMIHRvIGNoZWNrIGZvclxuICogQHJldHVybnMge0Jvb2xlYW59IHRydWUgaWYgY29va2llIGlzIHZhbGlkIGZvciBzcGVjaWZpZWMgVVJMXG4gKi9cbkNvb2tpZXMucHJvdG90eXBlLm1hdGNoID0gZnVuY3Rpb24gKGNvb2tpZSwgdXJsKSB7XG4gICAgdmFyIHVybHBhcnRzID0gdXJsbGliLnBhcnNlKHVybCB8fCAnJyk7XG5cbiAgICAvLyBjaGVjayBpZiBob3N0bmFtZSBtYXRjaGVzXG4gICAgLy8gLmZvby5jb20gYWxzbyBtYXRjaGVzIHN1YmRvbWFpbnMsIGZvby5jb20gZG9lcyBub3RcbiAgICBpZiAodXJscGFydHMuaG9zdG5hbWUgIT09IGNvb2tpZS5kb21haW4gJiYgKGNvb2tpZS5kb21haW4uY2hhckF0KDApICE9PSAnLicgfHwgKCcuJyArIHVybHBhcnRzLmhvc3RuYW1lKS5zdWJzdHIoLWNvb2tpZS5kb21haW4ubGVuZ3RoKSAhPT0gY29va2llLmRvbWFpbikpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIC8vIGNoZWNrIGlmIHBhdGggbWF0Y2hlc1xuICAgIHZhciBwYXRoID0gdGhpcy5nZXRQYXRoKHVybHBhcnRzLnBhdGhuYW1lKTtcbiAgICBpZiAocGF0aC5zdWJzdHIoMCwgY29va2llLnBhdGgubGVuZ3RoKSAhPT0gY29va2llLnBhdGgpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIC8vIGNoZWNrIHNlY3VyZSBhcmd1bWVudFxuICAgIGlmIChjb29raWUuc2VjdXJlICYmIHVybHBhcnRzLnByb3RvY29sICE9PSAnaHR0cHM6Jykge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRydWU7XG59O1xuXG4vKipcbiAqIEFkZHMgKG9yIHVwZGF0ZXMvcmVtb3ZlcyBpZiBuZWVkZWQpIGEgY29va2llIG9iamVjdCB0byB0aGUgY29va2llIHN0b3JhZ2VcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gY29va2llIENvb2tpZSB2YWx1ZSB0byBiZSBzdG9yZWRcbiAqL1xuQ29va2llcy5wcm90b3R5cGUuYWRkID0gZnVuY3Rpb24gKGNvb2tpZSkge1xuICAgIHZhciBpO1xuICAgIHZhciBsZW47XG5cbiAgICAvLyBub3RoaW5nIHRvIGRvIGhlcmVcbiAgICBpZiAoIWNvb2tpZSB8fCAhY29va2llLm5hbWUpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIC8vIG92ZXJ3cml0ZSBpZiBoYXMgc2FtZSBwYXJhbXNcbiAgICBmb3IgKGkgPSAwLCBsZW4gPSB0aGlzLmNvb2tpZXMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgaWYgKHRoaXMuY29tcGFyZSh0aGlzLmNvb2tpZXNbaV0sIGNvb2tpZSkpIHtcblxuICAgICAgICAgICAgLy8gY2hlY2sgaWYgdGhlIGNvb2tpZSBuZWVkcyB0byBiZSByZW1vdmVkIGluc3RlYWRcbiAgICAgICAgICAgIGlmICh0aGlzLmlzRXhwaXJlZChjb29raWUpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5jb29raWVzLnNwbGljZShpLCAxKTsgLy8gcmVtb3ZlIGV4cGlyZWQvdW5zZXQgY29va2llXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aGlzLmNvb2tpZXNbaV0gPSBjb29raWU7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIGFkZCBhcyBuZXcgaWYgbm90IGFscmVhZHkgZXhwaXJlZFxuICAgIGlmICghdGhpcy5pc0V4cGlyZWQoY29va2llKSkge1xuICAgICAgICB0aGlzLmNvb2tpZXMucHVzaChjb29raWUpO1xuICAgIH1cblxuICAgIHJldHVybiB0cnVlO1xufTtcblxuLyoqXG4gKiBDaGVja3MgaWYgdHdvIGNvb2tpZSBvYmplY3RzIGFyZSB0aGUgc2FtZVxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBhIENvb2tpZSB0byBjaGVjayBhZ2FpbnN0XG4gKiBAcGFyYW0ge09iamVjdH0gYiBDb29raWUgdG8gY2hlY2sgYWdhaW5zdFxuICogQHJldHVybnMge0Jvb2xlYW59IFRydWUsIGlmIHRoZSBjb29raWVzIGFyZSB0aGUgc2FtZVxuICovXG5Db29raWVzLnByb3RvdHlwZS5jb21wYXJlID0gZnVuY3Rpb24gKGEsIGIpIHtcbiAgICByZXR1cm4gYS5uYW1lID09PSBiLm5hbWUgJiYgYS5wYXRoID09PSBiLnBhdGggJiYgYS5kb21haW4gPT09IGIuZG9tYWluICYmIGEuc2VjdXJlID09PSBiLnNlY3VyZSAmJiBhLmh0dHBvbmx5ID09PSBhLmh0dHBvbmx5O1xufTtcblxuLyoqXG4gKiBDaGVja3MgaWYgYSBjb29raWUgaXMgZXhwaXJlZFxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBjb29raWUgQ29va2llIG9iamVjdCB0byBjaGVjayBhZ2FpbnN0XG4gKiBAcmV0dXJucyB7Qm9vbGVhbn0gVHJ1ZSwgaWYgdGhlIGNvb2tpZSBpcyBleHBpcmVkXG4gKi9cbkNvb2tpZXMucHJvdG90eXBlLmlzRXhwaXJlZCA9IGZ1bmN0aW9uIChjb29raWUpIHtcbiAgICByZXR1cm4gKGNvb2tpZS5leHBpcmVzICYmIGNvb2tpZS5leHBpcmVzIDwgbmV3IERhdGUoKSkgfHwgIWNvb2tpZS52YWx1ZTtcbn07XG5cbi8qKlxuICogUmV0dXJucyBub3JtYWxpemVkIGNvb2tpZSBwYXRoIGZvciBhbiBVUkwgcGF0aCBhcmd1bWVudFxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBwYXRobmFtZVxuICogQHJldHVybnMge1N0cmluZ30gTm9ybWFsaXplZCBwYXRoXG4gKi9cbkNvb2tpZXMucHJvdG90eXBlLmdldFBhdGggPSBmdW5jdGlvbiAocGF0aG5hbWUpIHtcbiAgICB2YXIgcGF0aCA9IChwYXRobmFtZSB8fCAnLycpLnNwbGl0KCcvJyk7XG4gICAgcGF0aC5wb3AoKTsgLy8gcmVtb3ZlIGZpbGVuYW1lIHBhcnRcbiAgICBwYXRoID0gcGF0aC5qb2luKCcvJykudHJpbSgpO1xuXG4gICAgLy8gZW5zdXJlIHBhdGggcHJlZml4IC9cbiAgICBpZiAocGF0aC5jaGFyQXQoMCkgIT09ICcvJykge1xuICAgICAgICBwYXRoID0gJy8nICsgcGF0aDtcbiAgICB9XG5cbiAgICAvLyBlbnN1cmUgcGF0aCBzdWZmaXggL1xuICAgIGlmIChwYXRoLnN1YnN0cigtMSkgIT09ICcvJykge1xuICAgICAgICBwYXRoICs9ICcvJztcbiAgICB9XG5cbiAgICByZXR1cm4gcGF0aDtcbn07XG4iLCIoZnVuY3Rpb24gKEJ1ZmZlcil7XG4ndXNlIHN0cmljdCc7XG5cbnZhciBodHRwID0gcmVxdWlyZSgnaHR0cCcpO1xudmFyIGh0dHBzID0gcmVxdWlyZSgnaHR0cHMnKTtcbnZhciB1cmxsaWIgPSByZXF1aXJlKCd1cmwnKTtcbnZhciB6bGliID0gcmVxdWlyZSgnemxpYicpO1xudmFyIFBhc3NUaHJvdWdoID0gcmVxdWlyZSgnc3RyZWFtJykuUGFzc1Rocm91Z2g7XG52YXIgQ29va2llcyA9IHJlcXVpcmUoJy4vY29va2llcycpO1xuXG52YXIgTUFYX1JFRElSRUNUUyA9IDU7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKHVybCwgb3B0aW9ucykge1xuICAgIHJldHVybiBmZXRjaCh1cmwsIG9wdGlvbnMpO1xufTtcblxubW9kdWxlLmV4cG9ydHMuQ29va2llcyA9IENvb2tpZXM7XG5cbmZ1bmN0aW9uIGZldGNoKHVybCwgb3B0aW9ucykge1xuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG4gICAgb3B0aW9ucy5mZXRjaFJlcyA9IG9wdGlvbnMuZmV0Y2hSZXMgfHwgbmV3IFBhc3NUaHJvdWdoKCk7XG4gICAgb3B0aW9ucy5jb29raWVzID0gb3B0aW9ucy5jb29raWVzIHx8IG5ldyBDb29raWVzKCk7XG4gICAgb3B0aW9ucy5yZWRpcmVjdHMgPSBvcHRpb25zLnJlZGlyZWN0cyB8fCAwO1xuICAgIG9wdGlvbnMubWF4UmVkaXJlY3RzID0gaXNOYU4ob3B0aW9ucy5tYXhSZWRpcmVjdHMpID8gTUFYX1JFRElSRUNUUyA6IG9wdGlvbnMubWF4UmVkaXJlY3RzO1xuXG4gICAgaWYgKG9wdGlvbnMuY29va2llKSB7XG4gICAgICAgIFtdLmNvbmNhdChvcHRpb25zLmNvb2tpZSB8fCBbXSkuZm9yRWFjaChmdW5jdGlvbiAoY29va2llKSB7XG4gICAgICAgICAgICBvcHRpb25zLmNvb2tpZXMuc2V0KGNvb2tpZSwgdXJsKTtcbiAgICAgICAgfSk7XG4gICAgICAgIG9wdGlvbnMuY29va2llID0gZmFsc2U7XG4gICAgfVxuXG4gICAgdmFyIGZldGNoUmVzID0gb3B0aW9ucy5mZXRjaFJlcztcbiAgICB2YXIgcGFyc2VkID0gdXJsbGliLnBhcnNlKHVybCk7XG4gICAgdmFyIG1ldGhvZCA9IChvcHRpb25zLm1ldGhvZCB8fCAnJykudG9TdHJpbmcoKS50cmltKCkudG9VcHBlckNhc2UoKSB8fCAnR0VUJztcbiAgICB2YXIgZmluaXNoZWQgPSBmYWxzZTtcbiAgICB2YXIgY29va2llcztcbiAgICB2YXIgYm9keTtcblxuICAgIHZhciBoYW5kbGVyID0gcGFyc2VkLnByb3RvY29sID09PSAnaHR0cHM6JyA/IGh0dHBzIDogaHR0cDtcblxuICAgIHZhciBoZWFkZXJzID0ge1xuICAgICAgICAnYWNjZXB0LWVuY29kaW5nJzogJ2d6aXAsZGVmbGF0ZSdcbiAgICB9O1xuXG4gICAgaWYgKG9wdGlvbnMudXNlckFnZW50KSB7XG4gICAgICAgIGhlYWRlcnNbJ1VzZXItQWdlbnQnXSA9IG9wdGlvbnMudXNlckFnZW50O1xuICAgIH1cblxuICAgIGlmIChwYXJzZWQuYXV0aCkge1xuICAgICAgICBoZWFkZXJzLkF1dGhvcml6YXRpb24gPSAnQmFzaWMgJyArIG5ldyBCdWZmZXIocGFyc2VkLmF1dGgpLnRvU3RyaW5nKCdiYXNlNjQnKTtcbiAgICB9XG5cbiAgICBpZiAoKGNvb2tpZXMgPSBvcHRpb25zLmNvb2tpZXMuZ2V0KHVybCkpKSB7XG4gICAgICAgIGhlYWRlcnMuY29va2llID0gY29va2llcztcbiAgICB9XG5cbiAgICBpZiAob3B0aW9ucy5ib2R5KSB7XG4gICAgICAgIGlmIChvcHRpb25zLmJvZHkgaW5zdGFuY2VvZiBCdWZmZXIpIHtcbiAgICAgICAgICAgIGJvZHkgPSBvcHRpb25zLmJvZHk7XG4gICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIG9wdGlvbnMuYm9keSA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgIGJvZHkgPSBuZXcgQnVmZmVyKE9iamVjdC5rZXlzKG9wdGlvbnMuYm9keSkubWFwKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgICAgICAgICB2YXIgdmFsdWUgPSBvcHRpb25zLmJvZHlba2V5XS50b1N0cmluZygpLnRyaW0oKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gZW5jb2RlVVJJQ29tcG9uZW50KGtleSkgKyAnPScgKyBlbmNvZGVVUklDb21wb25lbnQodmFsdWUpO1xuICAgICAgICAgICAgfSkuam9pbignJicpKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGJvZHkgPSBuZXcgQnVmZmVyKG9wdGlvbnMuYm9keS50b1N0cmluZygpLnRyaW0oKSk7XG4gICAgICAgIH1cblxuICAgICAgICBoZWFkZXJzWydDb250ZW50LVR5cGUnXSA9IG9wdGlvbnMuY29udGVudFR5cGUgfHwgJ2FwcGxpY2F0aW9uL3gtd3d3LWZvcm0tdXJsZW5jb2RlZCc7XG4gICAgICAgIGhlYWRlcnNbJ0NvbnRlbnQtTGVuZ3RoJ10gPSBib2R5Lmxlbmd0aDtcblxuICAgICAgICAvLyBpZiBtZXRob2QgaXMgbm90IHByb3ZpZGVkLCB1c2UgUE9TVCBpbnN0ZWFkIG9mIEdFVFxuICAgICAgICBtZXRob2QgPSAob3B0aW9ucy5tZXRob2QgfHwgJycpLnRvU3RyaW5nKCkudHJpbSgpLnRvVXBwZXJDYXNlKCkgfHwgJ1BPU1QnO1xuICAgIH1cblxuICAgIHZhciByZXE7XG4gICAgdmFyIHJlcU9wdGlvbnMgPSB7XG4gICAgICAgIG1ldGhvZDogbWV0aG9kLFxuICAgICAgICBob3N0OiBwYXJzZWQuaG9zdG5hbWUsXG4gICAgICAgIHBhdGg6IHBhcnNlZC5wYXRoLFxuICAgICAgICBwb3J0OiBwYXJzZWQucG9ydCA/IHBhcnNlZC5wb3J0IDogKHBhcnNlZC5wcm90b2NvbCA9PT0gJ2h0dHBzOicgPyA0NDMgOiA4MCksXG4gICAgICAgIGhlYWRlcnM6IGhlYWRlcnMsXG4gICAgICAgIHJlamVjdFVuYXV0aG9yaXplZDogZmFsc2UsXG4gICAgICAgIGFnZW50OiBmYWxzZVxuICAgIH07XG5cbiAgICBpZiAob3B0aW9ucy50bHMpIHtcbiAgICAgICAgT2JqZWN0LmtleXMob3B0aW9ucy50bHMpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgICAgICAgICAgcmVxT3B0aW9uc1trZXldID0gb3B0aW9ucy50bHNba2V5XTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgdHJ5IHtcbiAgICAgICAgcmVxID0gaGFuZGxlci5yZXF1ZXN0KHJlcU9wdGlvbnMpO1xuICAgIH0gY2F0Y2ggKEUpIHtcbiAgICAgICAgZmluaXNoZWQgPSB0cnVlO1xuICAgICAgICBzZXRJbW1lZGlhdGUoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgZmV0Y2hSZXMuZW1pdCgnZXJyb3InLCBFKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBmZXRjaFJlcztcbiAgICB9XG5cbiAgICBpZiAob3B0aW9ucy50aW1lb3V0KSB7XG4gICAgICAgIHJlcS5zZXRUaW1lb3V0KG9wdGlvbnMudGltZW91dCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKGZpbmlzaGVkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZmluaXNoZWQgPSB0cnVlO1xuICAgICAgICAgICAgcmVxLmFib3J0KCk7XG4gICAgICAgICAgICBmZXRjaFJlcy5lbWl0KCdlcnJvcicsIG5ldyBFcnJvcignUmVxdWVzdCBUaWVtb3V0JykpO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICByZXEub24oJ2Vycm9yJywgZnVuY3Rpb24gKGVycikge1xuICAgICAgICBpZiAoZmluaXNoZWQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBmaW5pc2hlZCA9IHRydWU7XG4gICAgICAgIGZldGNoUmVzLmVtaXQoJ2Vycm9yJywgZXJyKTtcbiAgICB9KTtcblxuICAgIHJlcS5vbigncmVzcG9uc2UnLCBmdW5jdGlvbiAocmVzKSB7XG4gICAgICAgIHZhciBpbmZsYXRlO1xuXG4gICAgICAgIGlmIChmaW5pc2hlZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgc3dpdGNoIChyZXMuaGVhZGVyc1snY29udGVudC1lbmNvZGluZyddKSB7XG4gICAgICAgICAgICBjYXNlICdnemlwJzpcbiAgICAgICAgICAgIGNhc2UgJ2RlZmxhdGUnOlxuICAgICAgICAgICAgICAgIGluZmxhdGUgPSB6bGliLmNyZWF0ZVVuemlwKCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAocmVzLmhlYWRlcnNbJ3NldC1jb29raWUnXSkge1xuICAgICAgICAgICAgW10uY29uY2F0KHJlcy5oZWFkZXJzWydzZXQtY29va2llJ10gfHwgW10pLmZvckVhY2goZnVuY3Rpb24gKGNvb2tpZSkge1xuICAgICAgICAgICAgICAgIG9wdGlvbnMuY29va2llcy5zZXQoY29va2llLCB1cmwpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoWzMwMSwgMzAyLCAzMDMsIDMwNywgMzA4XS5pbmRleE9mKHJlcy5zdGF0dXNDb2RlKSA+PSAwICYmIHJlcy5oZWFkZXJzLmxvY2F0aW9uKSB7XG4gICAgICAgICAgICAvLyByZWRpcmVjdFxuICAgICAgICAgICAgb3B0aW9ucy5yZWRpcmVjdHMrKztcbiAgICAgICAgICAgIGlmIChvcHRpb25zLnJlZGlyZWN0cyA+IG9wdGlvbnMubWF4UmVkaXJlY3RzKSB7XG4gICAgICAgICAgICAgICAgZmluaXNoZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGZldGNoUmVzLmVtaXQoJ2Vycm9yJywgbmV3IEVycm9yKCdNYXhpbXVtIHJlZGlyZWN0IGNvdW50IGV4Y2VlZGVkJykpO1xuICAgICAgICAgICAgICAgIHJlcS5hYm9ydCgpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBmZXRjaCh1cmxsaWIucmVzb2x2ZSh1cmwsIHJlcy5oZWFkZXJzLmxvY2F0aW9uKSwgb3B0aW9ucyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAocmVzLnN0YXR1c0NvZGUgPj0gMzAwKSB7XG4gICAgICAgICAgICBmaW5pc2hlZCA9IHRydWU7XG4gICAgICAgICAgICBmZXRjaFJlcy5lbWl0KCdlcnJvcicsIG5ldyBFcnJvcignSW52YWxpZCBzdGF0dXMgY29kZSAnICsgcmVzLnN0YXR1c0NvZGUpKTtcbiAgICAgICAgICAgIHJlcS5hYm9ydCgpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgcmVzLm9uKCdlcnJvcicsIGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgICAgIGlmIChmaW5pc2hlZCkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZpbmlzaGVkID0gdHJ1ZTtcbiAgICAgICAgICAgIGZldGNoUmVzLmVtaXQoJ2Vycm9yJywgZXJyKTtcbiAgICAgICAgICAgIHJlcS5hYm9ydCgpO1xuICAgICAgICB9KTtcblxuICAgICAgICBpZiAoaW5mbGF0ZSkge1xuICAgICAgICAgICAgcmVzLnBpcGUoaW5mbGF0ZSkucGlwZShmZXRjaFJlcyk7XG4gICAgICAgICAgICBpbmZsYXRlLm9uKCdlcnJvcicsIGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgICAgICAgICBpZiAoZmluaXNoZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBmaW5pc2hlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgZmV0Y2hSZXMuZW1pdCgnZXJyb3InLCBlcnIpO1xuICAgICAgICAgICAgICAgIHJlcS5hYm9ydCgpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXMucGlwZShmZXRjaFJlcyk7XG4gICAgICAgIH1cbiAgICB9KTtcblxuICAgIHNldEltbWVkaWF0ZShmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmIChib2R5KSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHJlcS53cml0ZShib2R5KTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgICAgIGZpbmlzaGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBmZXRjaFJlcy5lbWl0KCdlcnJvcicsIGVycik7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJlcS5lbmQoKTtcbiAgICB9KTtcblxuICAgIHJldHVybiBmZXRjaFJlcztcbn1cblxufSkuY2FsbCh0aGlzLHJlcXVpcmUoXCJidWZmZXJcIikuQnVmZmVyKSIsIihmdW5jdGlvbiAoQnVmZmVyKXtcbid1c2Ugc3RyaWN0JztcblxudmFyIHVybGxpYiA9IHJlcXVpcmUoJ3VybCcpO1xudmFyIHV0aWwgPSByZXF1aXJlKCd1dGlsJyk7XG52YXIgZnMgPSByZXF1aXJlKCdmcycpO1xudmFyIGZldGNoID0gcmVxdWlyZSgnbm9kZW1haWxlci1mZXRjaCcpO1xuXG4vKipcbiAqIFBhcnNlcyBjb25uZWN0aW9uIHVybCB0byBhIHN0cnVjdHVyZWQgY29uZmlndXJhdGlvbiBvYmplY3RcbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gc3RyIENvbm5lY3Rpb24gdXJsXG4gKiBAcmV0dXJuIHtPYmplY3R9IENvbmZpZ3VyYXRpb24gb2JqZWN0XG4gKi9cbm1vZHVsZS5leHBvcnRzLnBhcnNlQ29ubmVjdGlvblVybCA9IGZ1bmN0aW9uIChzdHIpIHtcbiAgICBzdHIgPSBzdHIgfHwgJyc7XG4gICAgdmFyIG9wdGlvbnMgPSB7fTtcblxuICAgIFt1cmxsaWIucGFyc2Uoc3RyLCB0cnVlKV0uZm9yRWFjaChmdW5jdGlvbiAodXJsKSB7XG4gICAgICAgIHZhciBhdXRoO1xuXG4gICAgICAgIHN3aXRjaCAodXJsLnByb3RvY29sKSB7XG4gICAgICAgICAgICBjYXNlICdzbXRwOic6XG4gICAgICAgICAgICAgICAgb3B0aW9ucy5zZWN1cmUgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ3NtdHBzOic6XG4gICAgICAgICAgICAgICAgb3B0aW9ucy5zZWN1cmUgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnZGlyZWN0Oic6XG4gICAgICAgICAgICAgICAgb3B0aW9ucy5kaXJlY3QgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFpc05hTih1cmwucG9ydCkgJiYgTnVtYmVyKHVybC5wb3J0KSkge1xuICAgICAgICAgICAgb3B0aW9ucy5wb3J0ID0gTnVtYmVyKHVybC5wb3J0KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh1cmwuaG9zdG5hbWUpIHtcbiAgICAgICAgICAgIG9wdGlvbnMuaG9zdCA9IHVybC5ob3N0bmFtZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh1cmwuYXV0aCkge1xuICAgICAgICAgICAgYXV0aCA9IHVybC5hdXRoLnNwbGl0KCc6Jyk7XG5cbiAgICAgICAgICAgIGlmICghb3B0aW9ucy5hdXRoKSB7XG4gICAgICAgICAgICAgICAgb3B0aW9ucy5hdXRoID0ge307XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIG9wdGlvbnMuYXV0aC51c2VyID0gYXV0aC5zaGlmdCgpO1xuICAgICAgICAgICAgb3B0aW9ucy5hdXRoLnBhc3MgPSBhdXRoLmpvaW4oJzonKTtcbiAgICAgICAgfVxuXG4gICAgICAgIE9iamVjdC5rZXlzKHVybC5xdWVyeSB8fCB7fSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgICAgICB2YXIgb2JqID0gb3B0aW9ucztcbiAgICAgICAgICAgIHZhciBsS2V5ID0ga2V5O1xuICAgICAgICAgICAgdmFyIHZhbHVlID0gdXJsLnF1ZXJ5W2tleV07XG5cbiAgICAgICAgICAgIGlmICghaXNOYU4odmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgdmFsdWUgPSBOdW1iZXIodmFsdWUpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBzd2l0Y2ggKHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAndHJ1ZSc6XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAnZmFsc2UnOlxuICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gdGxzIGlzIG5lc3RlZCBvYmplY3RcbiAgICAgICAgICAgIGlmIChrZXkuaW5kZXhPZigndGxzLicpID09PSAwKSB7XG4gICAgICAgICAgICAgICAgbEtleSA9IGtleS5zdWJzdHIoNCk7XG4gICAgICAgICAgICAgICAgaWYgKCFvcHRpb25zLnRscykge1xuICAgICAgICAgICAgICAgICAgICBvcHRpb25zLnRscyA9IHt9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBvYmogPSBvcHRpb25zLnRscztcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoa2V5LmluZGV4T2YoJy4nKSA+PSAwKSB7XG4gICAgICAgICAgICAgICAgLy8gaWdub3JlIG5lc3RlZCBwcm9wZXJ0aWVzIGJlc2lkZXMgdGxzXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoIShsS2V5IGluIG9iaikpIHtcbiAgICAgICAgICAgICAgICBvYmpbbEtleV0gPSB2YWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfSk7XG5cbiAgICByZXR1cm4gb3B0aW9ucztcbn07XG5cbi8qKlxuICogUmV0dXJucyBhIGJ1bnlhbi1jb21wYXRpYmxlIGxvZ2dlciBpbnRlcmZhY2UuIFVzZXMgZWl0aGVyIHByb3ZpZGVkIGxvZ2dlciBvclxuICogY3JlYXRlcyBhIGRlZmF1bHQgY29uc29sZSBsb2dnZXJcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIE9wdGlvbnMgb2JqZWN0IHRoYXQgbWlnaHQgaW5jbHVkZSAnbG9nZ2VyJyB2YWx1ZVxuICogQHJldHVybiB7T2JqZWN0fSBidW55YW4gY29tcGF0aWJsZSBsb2dnZXJcbiAqL1xubW9kdWxlLmV4cG9ydHMuZ2V0TG9nZ2VyID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuICAgIGlmICghb3B0aW9ucy5sb2dnZXIpIHtcbiAgICAgICAgLy8gdXNlIHZhbml0eSBsb2dnZXJcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGluZm86IGZ1bmN0aW9uICgpIHt9LFxuICAgICAgICAgICAgZGVidWc6IGZ1bmN0aW9uICgpIHt9LFxuICAgICAgICAgICAgZXJyb3I6IGZ1bmN0aW9uICgpIHt9XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgaWYgKG9wdGlvbnMubG9nZ2VyID09PSB0cnVlKSB7XG4gICAgICAgIC8vIGNyZWF0ZSBjb25zb2xlIGxvZ2dlclxuICAgICAgICByZXR1cm4gY3JlYXRlRGVmYXVsdExvZ2dlcigpO1xuICAgIH1cblxuICAgIC8vIHJldHVybiB3aGF0ZXZlciB3YXMgcGFzc2VkXG4gICAgcmV0dXJuIG9wdGlvbnMubG9nZ2VyO1xufTtcblxuLyoqXG4gKiBXcmFwcGVyIGZvciBjcmVhdGluZyBhIGNhbGxiYWNrIHRoYW4gZWl0aGVyIHJlc29sdmVzIG9yIHJlamVjdHMgYSBwcm9taXNlXG4gKiBiYXNlZCBvbiBpbnB1dFxuICpcbiAqIEBwYXJhbSB7RnVuY3Rpb259IHJlc29sdmUgRnVuY3Rpb24gdG8gcnVuIGlmIGNhbGxiYWNrIGlzIGNhbGxlZFxuICogQHBhcmFtIHtGdW5jdGlvbn0gcmVqZWN0IEZ1bmN0aW9uIHRvIHJ1biBpZiBjYWxsYmFjayBlbmRzIHdpdGggYW4gZXJyb3JcbiAqL1xubW9kdWxlLmV4cG9ydHMuY2FsbGJhY2tQcm9taXNlID0gZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzKTtcbiAgICAgICAgdmFyIGVyciA9IGFyZ3Muc2hpZnQoKTtcbiAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgcmVqZWN0KGVycik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXNvbHZlLmFwcGx5KG51bGwsIGFyZ3MpO1xuICAgICAgICB9XG4gICAgfTtcbn07XG5cbi8qKlxuICogUmVzb2x2ZXMgYSBTdHJpbmcgb3IgYSBCdWZmZXIgdmFsdWUgZm9yIGNvbnRlbnQgdmFsdWUuIFVzZWZ1bCBpZiB0aGUgdmFsdWVcbiAqIGlzIGEgU3RyZWFtIG9yIGEgZmlsZSBvciBhbiBVUkwuIElmIHRoZSB2YWx1ZSBpcyBhIFN0cmVhbSwgb3ZlcndyaXRlc1xuICogdGhlIHN0cmVhbSBvYmplY3Qgd2l0aCB0aGUgcmVzb2x2ZWQgdmFsdWUgKHlvdSBjYW4ndCBzdHJlYW0gYSB2YWx1ZSB0d2ljZSkuXG4gKlxuICogVGhpcyBpcyB1c2VmdWwgd2hlbiB5b3Ugd2FudCB0byBjcmVhdGUgYSBwbHVnaW4gdGhhdCBuZWVkcyBhIGNvbnRlbnQgdmFsdWUsXG4gKiBmb3IgZXhhbXBsZSB0aGUgYGh0bWxgIG9yIGB0ZXh0YCB2YWx1ZSBhcyBhIFN0cmluZyBvciBhIEJ1ZmZlciBidXQgbm90IGFzXG4gKiBhIGZpbGUgcGF0aCBvciBhbiBVUkwuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IGRhdGEgQW4gb2JqZWN0IG9yIGFuIEFycmF5IHlvdSB3YW50IHRvIHJlc29sdmUgYW4gZWxlbWVudCBmb3JcbiAqIEBwYXJhbSB7U3RyaW5nfE51bWJlcn0ga2V5IFByb3BlcnR5IG5hbWUgb3IgYW4gQXJyYXkgaW5kZXhcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIENhbGxiYWNrIGZ1bmN0aW9uIHdpdGggKGVyciwgdmFsdWUpXG4gKi9cbm1vZHVsZS5leHBvcnRzLnJlc29sdmVDb250ZW50ID0gZnVuY3Rpb24gKGRhdGEsIGtleSwgY2FsbGJhY2spIHtcbiAgICB2YXIgcHJvbWlzZTtcblxuICAgIGlmICghY2FsbGJhY2sgJiYgdHlwZW9mIFByb21pc2UgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgcHJvbWlzZSA9IG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgICAgIGNhbGxiYWNrID0gbW9kdWxlLmV4cG9ydHMuY2FsbGJhY2tQcm9taXNlKHJlc29sdmUsIHJlamVjdCk7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIHZhciBjb250ZW50ID0gZGF0YSAmJiBkYXRhW2tleV0gJiYgZGF0YVtrZXldLmNvbnRlbnQgfHwgZGF0YVtrZXldO1xuICAgIHZhciBjb250ZW50U3RyZWFtO1xuICAgIHZhciBlbmNvZGluZyA9ICh0eXBlb2YgZGF0YVtrZXldID09PSAnb2JqZWN0JyAmJiBkYXRhW2tleV0uZW5jb2RpbmcgfHwgJ3V0ZjgnKVxuICAgICAgICAudG9TdHJpbmcoKVxuICAgICAgICAudG9Mb3dlckNhc2UoKVxuICAgICAgICAucmVwbGFjZSgvWy1fXFxzXS9nLCAnJyk7XG5cbiAgICBpZiAoIWNvbnRlbnQpIHtcbiAgICAgICAgcmV0dXJuIGNhbGxiYWNrKG51bGwsIGNvbnRlbnQpO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2YgY29udGVudCA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBjb250ZW50LnBpcGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIHJldHVybiByZXNvbHZlU3RyZWFtKGNvbnRlbnQsIGZ1bmN0aW9uIChlcnIsIHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gY2FsbGJhY2soZXJyKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gd2UgY2FuJ3Qgc3RyZWFtIHR3aWNlIHRoZSBzYW1lIGNvbnRlbnQsIHNvIHdlIG5lZWRcbiAgICAgICAgICAgICAgICAvLyB0byByZXBsYWNlIHRoZSBzdHJlYW0gb2JqZWN0IHdpdGggdGhlIHN0cmVhbWluZyByZXN1bHRcbiAgICAgICAgICAgICAgICBkYXRhW2tleV0gPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICBjYWxsYmFjayhudWxsLCB2YWx1ZSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIGlmICgvXmh0dHBzPzpcXC9cXC8vaS50ZXN0KGNvbnRlbnQucGF0aCB8fCBjb250ZW50LmhyZWYpKSB7XG4gICAgICAgICAgICBjb250ZW50U3RyZWFtID0gZmV0Y2goY29udGVudC5wYXRoIHx8IGNvbnRlbnQuaHJlZik7XG4gICAgICAgICAgICByZXR1cm4gcmVzb2x2ZVN0cmVhbShjb250ZW50U3RyZWFtLCBjYWxsYmFjayk7XG4gICAgICAgIH0gZWxzZSBpZiAoL15kYXRhOi9pLnRlc3QoY29udGVudC5wYXRoIHx8IGNvbnRlbnQuaHJlZikpIHtcbiAgICAgICAgICAgIHZhciBwYXJ0cyA9IChjb250ZW50LnBhdGggfHwgY29udGVudC5ocmVmKS5tYXRjaCgvXmRhdGE6KCg/OlteO10qOykqKD86W14sXSopKSwoLiopJC9pKTtcbiAgICAgICAgICAgIGlmICghcGFydHMpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gY2FsbGJhY2sobnVsbCwgbmV3IEJ1ZmZlcigwKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gY2FsbGJhY2sobnVsbCwgL1xcYmJhc2U2NCQvaS50ZXN0KHBhcnRzWzFdKSA/IG5ldyBCdWZmZXIocGFydHNbMl0sICdiYXNlNjQnKSA6IG5ldyBCdWZmZXIoZGVjb2RlVVJJQ29tcG9uZW50KHBhcnRzWzJdKSkpO1xuICAgICAgICB9IGVsc2UgaWYgKGNvbnRlbnQucGF0aCkge1xuICAgICAgICAgICAgcmV0dXJuIHJlc29sdmVTdHJlYW0oZnMuY3JlYXRlUmVhZFN0cmVhbShjb250ZW50LnBhdGgpLCBjYWxsYmFjayk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIGRhdGFba2V5XS5jb250ZW50ID09PSAnc3RyaW5nJyAmJiBbJ3V0ZjgnLCAndXNhc2NpaScsICdhc2NpaSddLmluZGV4T2YoZW5jb2RpbmcpIDwgMCkge1xuICAgICAgICBjb250ZW50ID0gbmV3IEJ1ZmZlcihkYXRhW2tleV0uY29udGVudCwgZW5jb2RpbmcpO1xuICAgIH1cblxuICAgIC8vIGRlZmF1bHQgYWN0aW9uLCByZXR1cm4gYXMgaXNcbiAgICBzZXRJbW1lZGlhdGUoY2FsbGJhY2suYmluZChudWxsLCBudWxsLCBjb250ZW50KSk7XG5cbiAgICByZXR1cm4gcHJvbWlzZTtcbn07XG5cbi8qKlxuICogU3RyZWFtcyBhIHN0cmVhbSB2YWx1ZSBpbnRvIGEgQnVmZmVyXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHN0cmVhbSBSZWFkYWJsZSBzdHJlYW1cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIENhbGxiYWNrIGZ1bmN0aW9uIHdpdGggKGVyciwgdmFsdWUpXG4gKi9cbmZ1bmN0aW9uIHJlc29sdmVTdHJlYW0oc3RyZWFtLCBjYWxsYmFjaykge1xuICAgIHZhciByZXNwb25kZWQgPSBmYWxzZTtcbiAgICB2YXIgY2h1bmtzID0gW107XG4gICAgdmFyIGNodW5rbGVuID0gMDtcblxuICAgIHN0cmVhbS5vbignZXJyb3InLCBmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgIGlmIChyZXNwb25kZWQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHJlc3BvbmRlZCA9IHRydWU7XG4gICAgICAgIGNhbGxiYWNrKGVycik7XG4gICAgfSk7XG5cbiAgICBzdHJlYW0ub24oJ3JlYWRhYmxlJywgZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgY2h1bms7XG4gICAgICAgIHdoaWxlICgoY2h1bmsgPSBzdHJlYW0ucmVhZCgpKSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgY2h1bmtzLnB1c2goY2h1bmspO1xuICAgICAgICAgICAgY2h1bmtsZW4gKz0gY2h1bmsubGVuZ3RoO1xuICAgICAgICB9XG4gICAgfSk7XG5cbiAgICBzdHJlYW0ub24oJ2VuZCcsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHJlc3BvbmRlZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHJlc3BvbmRlZCA9IHRydWU7XG5cbiAgICAgICAgdmFyIHZhbHVlO1xuXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICB2YWx1ZSA9IEJ1ZmZlci5jb25jYXQoY2h1bmtzLCBjaHVua2xlbik7XG4gICAgICAgIH0gY2F0Y2ggKEUpIHtcbiAgICAgICAgICAgIHJldHVybiBjYWxsYmFjayhFKTtcbiAgICAgICAgfVxuICAgICAgICBjYWxsYmFjayhudWxsLCB2YWx1ZSk7XG4gICAgfSk7XG59XG5cbi8qKlxuICogR2VuZXJhdGVzIGEgYnVueWFuLWxpa2UgbG9nZ2VyIHRoYXQgcHJpbnRzIHRvIGNvbnNvbGVcbiAqXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBCdW55YW4gbG9nZ2VyIGluc3RhbmNlXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZURlZmF1bHRMb2dnZXIoKSB7XG5cbiAgICB2YXIgbG9nZ2VyID0ge1xuICAgICAgICBfcHJpbnQ6IGZ1bmN0aW9uICggLyogbGV2ZWwsIG1lc3NhZ2UgKi8gKSB7XG4gICAgICAgICAgICB2YXIgYXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cyk7XG4gICAgICAgICAgICB2YXIgbGV2ZWwgPSBhcmdzLnNoaWZ0KCk7XG4gICAgICAgICAgICB2YXIgbWVzc2FnZTtcblxuICAgICAgICAgICAgaWYgKGFyZ3MubGVuZ3RoID4gMSkge1xuICAgICAgICAgICAgICAgIG1lc3NhZ2UgPSB1dGlsLmZvcm1hdC5hcHBseSh1dGlsLCBhcmdzKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgbWVzc2FnZSA9IGFyZ3Muc2hpZnQoKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY29uc29sZS5sb2coJ1slc10gJXM6ICVzJyxcbiAgICAgICAgICAgICAgICBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCkuc3Vic3RyKDAsIDE5KS5yZXBsYWNlKC9ULywgJyAnKSxcbiAgICAgICAgICAgICAgICBsZXZlbC50b1VwcGVyQ2FzZSgpLFxuICAgICAgICAgICAgICAgIG1lc3NhZ2UpO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIGxvZ2dlci5pbmZvID0gbG9nZ2VyLl9wcmludC5iaW5kKG51bGwsICdpbmZvJyk7XG4gICAgbG9nZ2VyLmRlYnVnID0gbG9nZ2VyLl9wcmludC5iaW5kKG51bGwsICdkZWJ1ZycpO1xuICAgIGxvZ2dlci5lcnJvciA9IGxvZ2dlci5fcHJpbnQuYmluZChudWxsLCAnZXJyb3InKTtcblxuICAgIHJldHVybiBsb2dnZXI7XG59XG5cbn0pLmNhbGwodGhpcyxyZXF1aXJlKFwiYnVmZmVyXCIpLkJ1ZmZlcikiLCIndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0gYXNzaWduO1xuXG4vKipcbiAqIENvcGllcyBwcm9wZXJ0aWVzIGZyb20gc291cmNlIG9iamVjdHMgdG8gdGFyZ2V0IG9iamVjdHNcbiAqL1xuZnVuY3Rpb24gYXNzaWduKCAvKiB0YXJnZXQsIC4uLiBzb3VyY2VzICovICkge1xuICAgIHZhciBhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzKTtcbiAgICB2YXIgdGFyZ2V0ID0gYXJncy5zaGlmdCgpIHx8IHt9O1xuXG4gICAgYXJncy5mb3JFYWNoKGZ1bmN0aW9uIChzb3VyY2UpIHtcbiAgICAgICAgT2JqZWN0LmtleXMoc291cmNlIHx8IHt9KS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgICAgIGlmIChbJ3RscycsICdhdXRoJ10uaW5kZXhPZihrZXkpID49IDAgJiYgc291cmNlW2tleV0gJiYgdHlwZW9mIHNvdXJjZVtrZXldID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgICAgIC8vIHRscyBhbmQgYXV0aCBhcmUgc3BlY2lhbCBrZXlzIHRoYXQgbmVlZCB0byBiZSBlbnVtZXJhdGVkIHNlcGFyYXRlbHlcbiAgICAgICAgICAgICAgICAvLyBvdGhlciBvYmplY3RzIGFyZSBwYXNzZWQgYXMgaXNcbiAgICAgICAgICAgICAgICBpZiAoIXRhcmdldFtrZXldKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGVzbnVyZSB0aGF0IHRhcmdldCBoYXMgdGhpcyBrZXlcbiAgICAgICAgICAgICAgICAgICAgdGFyZ2V0W2tleV0gPSB7fTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgT2JqZWN0LmtleXMoc291cmNlW2tleV0pLmZvckVhY2goZnVuY3Rpb24gKHN1YktleSkge1xuICAgICAgICAgICAgICAgICAgICB0YXJnZXRba2V5XVtzdWJLZXldID0gc291cmNlW2tleV1bc3ViS2V5XTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfSk7XG4gICAgcmV0dXJuIHRhcmdldDtcbn1cbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIFNNVFBDb25uZWN0aW9uID0gcmVxdWlyZSgnc210cC1jb25uZWN0aW9uJyk7XG52YXIgYXNzaWduID0gcmVxdWlyZSgnLi9hc3NpZ24nKTtcbnZhciBFdmVudEVtaXR0ZXIgPSByZXF1aXJlKCdldmVudHMnKS5FdmVudEVtaXR0ZXI7XG52YXIgdXRpbCA9IHJlcXVpcmUoJ3V0aWwnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBQb29sUmVzb3VyY2U7XG5cbi8qKlxuICogQ3JlYXRlcyBhbiBlbGVtZW50IGZvciB0aGUgcG9vbFxuICpcbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgU01UUFBvb2wgaW5zdGFuY2VcbiAqL1xuZnVuY3Rpb24gUG9vbFJlc291cmNlKHBvb2wpIHtcbiAgICBFdmVudEVtaXR0ZXIuY2FsbCh0aGlzKTtcbiAgICB0aGlzLnBvb2wgPSBwb29sO1xuICAgIHRoaXMub3B0aW9ucyA9IHBvb2wub3B0aW9ucztcblxuICAgIHRoaXMubG9nZ2VyID0gdGhpcy5vcHRpb25zLmxvZ2dlcjtcblxuICAgIHRoaXMuX2Nvbm5lY3Rpb24gPSBmYWxzZTtcbiAgICB0aGlzLl9jb25uZWN0ZWQgPSBmYWxzZTtcblxuICAgIHRoaXMubWVzc2FnZXMgPSAwO1xuICAgIHRoaXMuYXZhaWxhYmxlID0gdHJ1ZTtcbn1cbnV0aWwuaW5oZXJpdHMoUG9vbFJlc291cmNlLCBFdmVudEVtaXR0ZXIpO1xuXG4vKipcbiAqIEluaXRpYXRlcyBhIGNvbm5lY3Rpb24gdG8gdGhlIFNNVFAgc2VydmVyXG4gKlxuICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgQ2FsbGJhY2sgZnVuY3Rpb24gdG8gcnVuIG9uY2UgdGhlIGNvbm5lY3Rpb24gaXMgZXN0YWJsaXNoZWQgb3IgZmFpbGVkXG4gKi9cblBvb2xSZXNvdXJjZS5wcm90b3R5cGUuY29ubmVjdCA9IGZ1bmN0aW9uIChjYWxsYmFjaykge1xuICAgIHRoaXMucG9vbC5nZXRTb2NrZXQodGhpcy5vcHRpb25zLCBmdW5jdGlvbiAoZXJyLCBzb2NrZXRPcHRpb25zKSB7XG4gICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgIHJldHVybiBjYWxsYmFjayhlcnIpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHJldHVybmVkID0gZmFsc2U7XG4gICAgICAgIHZhciBvcHRpb25zID0gdGhpcy5vcHRpb25zO1xuICAgICAgICBpZiAoc29ja2V0T3B0aW9ucyAmJiBzb2NrZXRPcHRpb25zLmNvbm5lY3Rpb24pIHtcbiAgICAgICAgICAgIHRoaXMubG9nZ2VyLmluZm8oJ1VzaW5nIHByb3hpZWQgc29ja2V0IGZyb20gJXM6JXMgdG8gJXM6JXMnLCBzb2NrZXRPcHRpb25zLmNvbm5lY3Rpb24ucmVtb3RlQWRkcmVzcywgc29ja2V0T3B0aW9ucy5jb25uZWN0aW9uLnJlbW90ZVBvcnQsIG9wdGlvbnMuaG9zdCB8fCAnJywgb3B0aW9ucy5wb3J0IHx8ICcnKTtcbiAgICAgICAgICAgIG9wdGlvbnMgPSBhc3NpZ24oZmFsc2UsIG9wdGlvbnMpO1xuICAgICAgICAgICAgT2JqZWN0LmtleXMoc29ja2V0T3B0aW9ucykuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgICAgICAgICAgb3B0aW9uc1trZXldID0gc29ja2V0T3B0aW9uc1trZXldO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmNvbm5lY3Rpb24gPSBuZXcgU01UUENvbm5lY3Rpb24ob3B0aW9ucyk7XG5cbiAgICAgICAgdGhpcy5jb25uZWN0aW9uLm9uY2UoJ2Vycm9yJywgZnVuY3Rpb24gKGVycikge1xuICAgICAgICAgICAgdGhpcy5lbWl0KCdlcnJvcicsIGVycik7XG4gICAgICAgICAgICBpZiAocmV0dXJuZWQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm5lZCA9IHRydWU7XG4gICAgICAgICAgICByZXR1cm4gY2FsbGJhY2soZXJyKTtcbiAgICAgICAgfS5iaW5kKHRoaXMpKTtcblxuICAgICAgICB0aGlzLmNvbm5lY3Rpb24ub25jZSgnZW5kJywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdGhpcy5jbG9zZSgpO1xuICAgICAgICAgICAgaWYgKHJldHVybmVkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuZWQgPSB0cnVlO1xuICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKCk7XG4gICAgICAgIH0uYmluZCh0aGlzKSk7XG5cbiAgICAgICAgdGhpcy5jb25uZWN0aW9uLmNvbm5lY3QoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKHJldHVybmVkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAodGhpcy5vcHRpb25zLmF1dGgpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmNvbm5lY3Rpb24ubG9naW4odGhpcy5vcHRpb25zLmF1dGgsIGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJldHVybmVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuZWQgPSB0cnVlO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuY29ubmVjdGlvbi5jbG9zZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5lbWl0KCdlcnJvcicsIGVycik7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gY2FsbGJhY2soZXJyKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2Nvbm5lY3RlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrKG51bGwsIHRydWUpO1xuICAgICAgICAgICAgICAgIH0uYmluZCh0aGlzKSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybmVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB0aGlzLl9jb25uZWN0ZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIHJldHVybiBjYWxsYmFjayhudWxsLCB0cnVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfS5iaW5kKHRoaXMpKTtcbiAgICB9LmJpbmQodGhpcykpO1xufTtcblxuLyoqXG4gKiBTZW5kcyBhbiBlLW1haWwgdG8gYmUgc2VudCB1c2luZyB0aGUgc2VsZWN0ZWQgc2V0dGluZ3NcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gbWFpbCBNYWlsIG9iamVjdFxuICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgQ2FsbGJhY2sgZnVuY3Rpb25cbiAqL1xuUG9vbFJlc291cmNlLnByb3RvdHlwZS5zZW5kID0gZnVuY3Rpb24gKG1haWwsIGNhbGxiYWNrKSB7XG4gICAgaWYgKCF0aGlzLl9jb25uZWN0ZWQpIHtcbiAgICAgICAgdGhpcy5jb25uZWN0KGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gY2FsbGJhY2soZXJyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuc2VuZChtYWlsLCBjYWxsYmFjayk7XG4gICAgICAgIH0uYmluZCh0aGlzKSk7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgZW52ZWxvcGUgPSBtYWlsLmRhdGEuZW52ZWxvcGUgfHwgbWFpbC5tZXNzYWdlLmdldEVudmVsb3BlKCk7XG4gICAgdmFyIG1lc3NhZ2VJZCA9IChtYWlsLm1lc3NhZ2UuZ2V0SGVhZGVyKCdtZXNzYWdlLWlkJykgfHwgJycpLnJlcGxhY2UoL1s8Plxcc10vZywgJycpO1xuICAgIHZhciByZWNpcGllbnRzID0gW10uY29uY2F0KGVudmVsb3BlLnRvIHx8IFtdKTtcbiAgICBpZiAocmVjaXBpZW50cy5sZW5ndGggPiAzKSB7XG4gICAgICAgIHJlY2lwaWVudHMucHVzaCgnLi4uYW5kICcgKyByZWNpcGllbnRzLnNwbGljZSgyKS5sZW5ndGggKyAnIG1vcmUnKTtcbiAgICB9XG5cbiAgICB0aGlzLmxvZ2dlci5pbmZvKCdTZW5kaW5nIG1lc3NhZ2UgPCVzPiB1c2luZyAjJXMgdG8gPCVzPicsIG1lc3NhZ2VJZCwgdGhpcy5pZCwgcmVjaXBpZW50cy5qb2luKCcsICcpKTtcblxuICAgIHRoaXMuY29ubmVjdGlvbi5zZW5kKGVudmVsb3BlLCBtYWlsLm1lc3NhZ2UuY3JlYXRlUmVhZFN0cmVhbSgpLCBmdW5jdGlvbiAoZXJyLCBpbmZvKSB7XG4gICAgICAgIHRoaXMubWVzc2FnZXMrKztcblxuICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICB0aGlzLmNvbm5lY3Rpb24uY2xvc2UoKTtcbiAgICAgICAgICAgIHRoaXMuZW1pdCgnZXJyb3InLCBlcnIpO1xuICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKGVycik7XG4gICAgICAgIH1cblxuICAgICAgICBpbmZvLmVudmVsb3BlID0ge1xuICAgICAgICAgICAgZnJvbTogZW52ZWxvcGUuZnJvbSxcbiAgICAgICAgICAgIHRvOiBlbnZlbG9wZS50b1xuICAgICAgICB9O1xuICAgICAgICBpbmZvLm1lc3NhZ2VJZCA9IG1lc3NhZ2VJZDtcblxuICAgICAgICBzZXRJbW1lZGlhdGUoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIGVycjtcbiAgICAgICAgICAgIGlmICh0aGlzLm1lc3NhZ2VzID49IHRoaXMub3B0aW9ucy5tYXhNZXNzYWdlcykge1xuICAgICAgICAgICAgICAgIGVyciA9IG5ldyBFcnJvcignUmVzb3VyY2UgZXhoYXVzdGVkJyk7XG4gICAgICAgICAgICAgICAgZXJyLmNvZGUgPSAnRU1BWExJTUlUJztcbiAgICAgICAgICAgICAgICB0aGlzLmNvbm5lY3Rpb24uY2xvc2UoKTtcbiAgICAgICAgICAgICAgICB0aGlzLmVtaXQoJ2Vycm9yJywgZXJyKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5wb29sLl9jaGVja1JhdGVMaW1pdChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYXZhaWxhYmxlID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5lbWl0KCdhdmFpbGFibGUnKTtcbiAgICAgICAgICAgICAgICB9LmJpbmQodGhpcykpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LmJpbmQodGhpcykpO1xuXG4gICAgICAgIGNhbGxiYWNrKG51bGwsIGluZm8pO1xuICAgIH0uYmluZCh0aGlzKSk7XG59O1xuXG4vKipcbiAqIENsb3NlcyB0aGUgY29ubmVjdGlvblxuICovXG5Qb29sUmVzb3VyY2UucHJvdG90eXBlLmNsb3NlID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuX2Nvbm5lY3RlZCA9IGZhbHNlO1xuICAgIGlmICh0aGlzLmNvbm5lY3Rpb24pIHtcbiAgICAgICAgdGhpcy5jb25uZWN0aW9uLmNsb3NlKCk7XG4gICAgfVxuICAgIHRoaXMuZW1pdCgnY2xvc2UnKTtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBTTVRQQ29ubmVjdGlvbiA9IHJlcXVpcmUoJ3NtdHAtY29ubmVjdGlvbicpO1xudmFyIHBhY2thZ2VEYXRhID0gcmVxdWlyZSgnLi4vcGFja2FnZS5qc29uJyk7XG52YXIgd2VsbGtub3duID0gcmVxdWlyZSgnbm9kZW1haWxlci13ZWxsa25vd24nKTtcbnZhciBhc3NpZ24gPSByZXF1aXJlKCcuL2Fzc2lnbicpO1xudmFyIFBvb2xSZXNvdXJjZSA9IHJlcXVpcmUoJy4vcG9vbC1yZXNvdXJjZScpO1xudmFyIEV2ZW50RW1pdHRlciA9IHJlcXVpcmUoJ2V2ZW50cycpLkV2ZW50RW1pdHRlcjtcbnZhciB1dGlsID0gcmVxdWlyZSgndXRpbCcpO1xudmFyIHNoYXJlZCA9IHJlcXVpcmUoJ25vZGVtYWlsZXItc2hhcmVkJyk7XG5cbi8vIGV4cG9zZSB0byB0aGUgd29ybGRcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICByZXR1cm4gbmV3IFNNVFBQb29sKG9wdGlvbnMpO1xufTtcblxuLyoqXG4gKiBDcmVhdGVzIGEgU01UUCBwb29sIHRyYW5zcG9ydCBvYmplY3QgZm9yIE5vZGVtYWlsZXJcbiAqXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIFNNVFAgQ29ubmVjdGlvbiBvcHRpb25zXG4gKi9cbmZ1bmN0aW9uIFNNVFBQb29sKG9wdGlvbnMpIHtcbiAgICBFdmVudEVtaXR0ZXIuY2FsbCh0aGlzKTtcblxuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICAgIGlmICh0eXBlb2Ygb3B0aW9ucyA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgb3B0aW9ucyA9IHtcbiAgICAgICAgICAgIHVybDogb3B0aW9uc1xuICAgICAgICB9O1xuICAgIH1cblxuICAgIHZhciB1cmxEYXRhO1xuICAgIHZhciBzZXJ2aWNlID0gb3B0aW9ucy5zZXJ2aWNlO1xuXG4gICAgaWYgKHR5cGVvZiBvcHRpb25zLmdldFNvY2tldCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICB0aGlzLmdldFNvY2tldCA9IG9wdGlvbnMuZ2V0U29ja2V0O1xuICAgIH1cblxuICAgIGlmIChvcHRpb25zLnVybCkge1xuICAgICAgICB1cmxEYXRhID0gc2hhcmVkLnBhcnNlQ29ubmVjdGlvblVybChvcHRpb25zLnVybCk7XG4gICAgICAgIHNlcnZpY2UgPSBzZXJ2aWNlIHx8IHVybERhdGEuc2VydmljZTtcbiAgICB9XG5cbiAgICB0aGlzLm9wdGlvbnMgPSBhc3NpZ24oXG4gICAgICAgIGZhbHNlLCAvLyBjcmVhdGUgbmV3IG9iamVjdFxuICAgICAgICBvcHRpb25zLCAvLyByZWd1bGFyIG9wdGlvbnNcbiAgICAgICAgdXJsRGF0YSwgLy8gdXJsIG9wdGlvbnNcbiAgICAgICAgc2VydmljZSAmJiB3ZWxsa25vd24oc2VydmljZSkgLy8gd2VsbGtub3duIG9wdGlvbnNcbiAgICApO1xuXG4gICAgdGhpcy5vcHRpb25zLm1heENvbm5lY3Rpb25zID0gdGhpcy5vcHRpb25zLm1heENvbm5lY3Rpb25zIHx8IDU7XG4gICAgdGhpcy5vcHRpb25zLm1heE1lc3NhZ2VzID0gdGhpcy5vcHRpb25zLm1heE1lc3NhZ2VzIHx8IDEwMDtcblxuICAgIHRoaXMubG9nZ2VyID0gdGhpcy5vcHRpb25zLmxvZ2dlciA9IHNoYXJlZC5nZXRMb2dnZXIodGhpcy5vcHRpb25zKTtcblxuICAgIC8vIHRlbXBvcmFyeSBvYmplY3RcbiAgICB2YXIgY29ubmVjdGlvbiA9IG5ldyBTTVRQQ29ubmVjdGlvbih0aGlzLm9wdGlvbnMpO1xuXG4gICAgdGhpcy5uYW1lID0gJ1NNVFAgKHBvb2wpJztcbiAgICB0aGlzLnZlcnNpb24gPSBwYWNrYWdlRGF0YS52ZXJzaW9uICsgJ1tjbGllbnQ6JyArIGNvbm5lY3Rpb24udmVyc2lvbiArICddJztcblxuICAgIHRoaXMuX3JhdGVMaW1pdCA9IHtcbiAgICAgICAgY291bnRlcjogMCxcbiAgICAgICAgdGltZW91dDogbnVsbCxcbiAgICAgICAgd2FpdGluZzogW10sXG4gICAgICAgIGNoZWNrcG9pbnQ6IGZhbHNlXG4gICAgfTtcbiAgICB0aGlzLl9jbG9zZWQgPSBmYWxzZTtcbiAgICB0aGlzLl9xdWV1ZSA9IFtdO1xuICAgIHRoaXMuX2Nvbm5lY3Rpb25zID0gW107XG4gICAgdGhpcy5fY29ubmVjdGlvbkNvdW50ZXIgPSAwO1xuXG4gICAgdGhpcy5pZGxpbmcgPSB0cnVlO1xuXG4gICAgc2V0SW1tZWRpYXRlKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMuaWRsaW5nKSB7XG4gICAgICAgICAgICB0aGlzLmVtaXQoJ2lkbGUnKTtcbiAgICAgICAgfVxuICAgIH0uYmluZCh0aGlzKSk7XG59XG51dGlsLmluaGVyaXRzKFNNVFBQb29sLCBFdmVudEVtaXR0ZXIpO1xuXG4vKipcbiAqIFBsYWNlaG9sZGVyIGZ1bmN0aW9uIGZvciBjcmVhdGluZyBwcm94eSBzb2NrZXRzLiBUaGlzIG1ldGhvZCBpbW1lZGlhdGVsbHkgcmV0dXJuc1xuICogd2l0aG91dCBhIHNvY2tldFxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIENvbm5lY3Rpb24gb3B0aW9uc1xuICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgQ2FsbGJhY2sgZnVuY3Rpb24gdG8gcnVuIHdpdGggdGhlIHNvY2tldCBrZXlzXG4gKi9cblNNVFBQb29sLnByb3RvdHlwZS5nZXRTb2NrZXQgPSBmdW5jdGlvbiAob3B0aW9ucywgY2FsbGJhY2spIHtcbiAgICAvLyByZXR1cm4gaW1tZWRpYXRlbGx5XG4gICAgcmV0dXJuIGNhbGxiYWNrKG51bGwsIGZhbHNlKTtcbn07XG5cbi8qKlxuICogUXVldWVzIGFuIGUtbWFpbCB0byBiZSBzZW50IHVzaW5nIHRoZSBzZWxlY3RlZCBzZXR0aW5nc1xuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBtYWlsIE1haWwgb2JqZWN0XG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayBDYWxsYmFjayBmdW5jdGlvblxuICovXG5TTVRQUG9vbC5wcm90b3R5cGUuc2VuZCA9IGZ1bmN0aW9uIChtYWlsLCBjYWxsYmFjaykge1xuICAgIGlmICh0aGlzLl9jbG9zZWQpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHRoaXMuX3F1ZXVlLnB1c2goe1xuICAgICAgICBtYWlsOiBtYWlsLFxuICAgICAgICBjYWxsYmFjazogY2FsbGJhY2tcbiAgICB9KTtcblxuICAgIGlmICh0aGlzLmlkbGluZyAmJiB0aGlzLl9xdWV1ZS5sZW5ndGggPj0gdGhpcy5vcHRpb25zLm1heENvbm5lY3Rpb25zKSB7XG4gICAgICAgIHRoaXMuaWRsaW5nID0gZmFsc2U7XG4gICAgfVxuXG4gICAgc2V0SW1tZWRpYXRlKHRoaXMuX3Byb2Nlc3NNZXNzYWdlcy5iaW5kKHRoaXMpKTtcblxuICAgIHJldHVybiB0cnVlO1xufTtcblxuLyoqXG4gKiBDbG9zZXMgYWxsIGNvbm5lY3Rpb25zIGluIHRoZSBwb29sLiBJZiB0aGVyZSBpcyBhIG1lc3NhZ2UgYmVpbmcgc2VudCwgdGhlIGNvbm5lY3Rpb25cbiAqIGlzIGNsb3NlZCBsYXRlclxuICovXG5TTVRQUG9vbC5wcm90b3R5cGUuY2xvc2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGNvbm5lY3Rpb247XG4gICAgdmFyIGxlbiA9IHRoaXMuX2Nvbm5lY3Rpb25zLmxlbmd0aDtcbiAgICB0aGlzLl9jbG9zZWQgPSB0cnVlO1xuXG4gICAgLy8gY2xlYXIgcmF0ZSBsaW1pdCB0aW1lciBpZiBpdCBleGlzdHNcbiAgICBjbGVhclRpbWVvdXQodGhpcy5fcmF0ZUxpbWl0LnRpbWVvdXQpO1xuXG4gICAgLy8gcmVtb3ZlIGFsbCBhdmFpbGFibGUgY29ubmVjdGlvbnNcbiAgICBmb3IgKHZhciBpID0gbGVuIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgaWYgKHRoaXMuX2Nvbm5lY3Rpb25zW2ldICYmIHRoaXMuX2Nvbm5lY3Rpb25zW2ldLmF2YWlsYWJsZSkge1xuICAgICAgICAgICAgY29ubmVjdGlvbiA9IHRoaXMuX2Nvbm5lY3Rpb25zW2ldO1xuICAgICAgICAgICAgY29ubmVjdGlvbi5jbG9zZSgpO1xuICAgICAgICAgICAgdGhpcy5sb2dnZXIuaW5mbygnQ29ubmVjdGlvbiAjJXMgcmVtb3ZlZCcsIGNvbm5lY3Rpb24uaWQpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGxlbiAmJiAhdGhpcy5fY29ubmVjdGlvbnMubGVuZ3RoKSB7XG4gICAgICAgIHRoaXMubG9nZ2VyLmRlYnVnKCdBbGwgY29ubmVjdGlvbnMgcmVtb3ZlZCcpO1xuICAgIH1cblxuICAgIC8vIG1ha2Ugc3VyZSB0aGF0IGVudGlyZSBxdWV1ZSB3b3VsZCBiZSBjbGVhbmVkXG4gICAgdmFyIGludm9rZUNhbGxiYWNrcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKCF0aGlzLl9xdWV1ZS5sZW5ndGgpIHtcbiAgICAgICAgICAgIHRoaXMubG9nZ2VyLmRlYnVnKCdQZW5kaW5nIHF1ZXVlIGVsZW1lbnRzIGNsZWFyZWQnKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgZWxlbWVudCA9IHRoaXMuX3F1ZXVlLnNoaWZ0KCk7XG4gICAgICAgIGlmIChlbGVtZW50ICYmIHR5cGVvZiBlbGVtZW50LmNhbGxiYWNrID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGVsZW1lbnQuY2FsbGJhY2sobmV3IEVycm9yKCdDb25uZWN0aW9uIHBvb2wgd2FzIGNsb3NlZCcpKTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKEUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmxvZ2dlci5lcnJvcignQ2FsbGJhY2sgZXJyb3IgZm9yICMlczogJXMnLCBjb25uZWN0aW9uLmlkLCBFLm1lc3NhZ2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHNldEltbWVkaWF0ZShpbnZva2VDYWxsYmFja3MpO1xuICAgIH0uYmluZCh0aGlzKTtcbiAgICBzZXRJbW1lZGlhdGUoaW52b2tlQ2FsbGJhY2tzKTtcbn07XG5cbi8qKlxuICogQ2hlY2sgdGhlIHF1ZXVlIGFuZCBhdmFpbGFibGUgY29ubmVjdGlvbnMuIElmIHRoZXJlIGlzIGEgbWVzc2FnZSB0byBiZSBzZW50IGFuZCB0aGVyZSBpc1xuICogYW4gYXZhaWxhYmxlIGNvbm5lY3Rpb24sIHRoZW4gdXNlIHRoaXMgY29ubmVjdGlvbiB0byBzZW5kIHRoZSBtYWlsXG4gKi9cblNNVFBQb29sLnByb3RvdHlwZS5fcHJvY2Vzc01lc3NhZ2VzID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBjb25uZWN0aW9uO1xuICAgIHZhciBpLCBsZW47XG5cbiAgICAvLyBkbyBub3RoaW5nIGlmIGFscmVhZHkgY2xvc2VkXG4gICAgaWYgKHRoaXMuX2Nsb3NlZCkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gZG8gbm90aGluZyBpZiBxdWV1ZSBpcyBlbXB0eVxuICAgIGlmICghdGhpcy5fcXVldWUubGVuZ3RoKSB7XG4gICAgICAgIGlmICghdGhpcy5pZGxpbmcpIHtcbiAgICAgICAgICAgIC8vIG5vIHBlbmRpbmcgam9ic1xuICAgICAgICAgICAgdGhpcy5pZGxpbmcgPSB0cnVlO1xuICAgICAgICAgICAgdGhpcy5lbWl0KCdpZGxlJyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIGZpbmQgZmlyc3QgYXZhaWxhYmxlIGNvbm5lY3Rpb25cbiAgICBmb3IgKGkgPSAwLCBsZW4gPSB0aGlzLl9jb25uZWN0aW9ucy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICBpZiAodGhpcy5fY29ubmVjdGlvbnNbaV0uYXZhaWxhYmxlKSB7XG4gICAgICAgICAgICBjb25uZWN0aW9uID0gdGhpcy5fY29ubmVjdGlvbnNbaV07XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGlmICghY29ubmVjdGlvbiAmJiB0aGlzLl9jb25uZWN0aW9ucy5sZW5ndGggPCB0aGlzLm9wdGlvbnMubWF4Q29ubmVjdGlvbnMpIHtcbiAgICAgICAgY29ubmVjdGlvbiA9IHRoaXMuX2NyZWF0ZUNvbm5lY3Rpb24oKTtcbiAgICB9XG5cbiAgICBpZiAoIWNvbm5lY3Rpb24pIHtcbiAgICAgICAgLy8gbm8gbW9yZSBmcmVlIGNvbm5lY3Rpb24gc2xvdHMgYXZhaWxhYmxlXG4gICAgICAgIHRoaXMuaWRsaW5nID0gZmFsc2U7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBjaGVjayBpZiB0aGVyZSBpcyBmcmVlIHNwYWNlIGluIHRoZSBwcm9jZXNzaW5nIHF1ZXVlXG4gICAgaWYgKCF0aGlzLmlkbGluZyAmJiB0aGlzLl9xdWV1ZS5sZW5ndGggPCB0aGlzLm9wdGlvbnMubWF4Q29ubmVjdGlvbnMpIHtcbiAgICAgICAgdGhpcy5pZGxpbmcgPSB0cnVlO1xuICAgICAgICB0aGlzLmVtaXQoJ2lkbGUnKTtcbiAgICB9XG5cbiAgICB2YXIgZWxlbWVudCA9IGNvbm5lY3Rpb24ucXVldWVFbGVtZW50ID0gdGhpcy5fcXVldWUuc2hpZnQoKTtcbiAgICBlbGVtZW50Lm1lc3NhZ2VJZCA9IChjb25uZWN0aW9uLnF1ZXVlRWxlbWVudC5tYWlsLm1lc3NhZ2UuZ2V0SGVhZGVyKCdtZXNzYWdlLWlkJykgfHwgJycpLnJlcGxhY2UoL1s8Plxcc10vZywgJycpO1xuXG4gICAgY29ubmVjdGlvbi5hdmFpbGFibGUgPSBmYWxzZTtcblxuICAgIHRoaXMubG9nZ2VyLmRlYnVnKCdBc3NpZ25lZCBtZXNzYWdlIDwlcz4gdG8gIyVzICglcyknLCBlbGVtZW50Lm1lc3NhZ2VJZCwgY29ubmVjdGlvbi5pZCwgY29ubmVjdGlvbi5tZXNzYWdlcyArIDEpO1xuXG4gICAgaWYgKHRoaXMub3B0aW9ucy5yYXRlTGltaXQpIHtcbiAgICAgICAgdGhpcy5fcmF0ZUxpbWl0LmNvdW50ZXIrKztcbiAgICAgICAgaWYgKCF0aGlzLl9yYXRlTGltaXQuY2hlY2twb2ludCkge1xuICAgICAgICAgICAgdGhpcy5fcmF0ZUxpbWl0LmNoZWNrcG9pbnQgPSBEYXRlLm5vdygpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgY29ubmVjdGlvbi5zZW5kKGVsZW1lbnQubWFpbCwgZnVuY3Rpb24gKGVyciwgaW5mbykge1xuICAgICAgICAvLyBvbmx5IHByb2Nlc3MgY2FsbGJhY2sgaWYgY3VycmVudCBoYW5kbGVyIGlzIG5vdCBjaGFuZ2VkXG4gICAgICAgIGlmIChlbGVtZW50ID09PSBjb25uZWN0aW9uLnF1ZXVlRWxlbWVudCkge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBlbGVtZW50LmNhbGxiYWNrKGVyciwgaW5mbyk7XG4gICAgICAgICAgICB9IGNhdGNoIChFKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5sb2dnZXIuZXJyb3IoJ0NhbGxiYWNrIGVycm9yIGZvciAjJXM6ICVzJywgY29ubmVjdGlvbi5pZCwgRS5tZXNzYWdlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbm5lY3Rpb24ucXVldWVFbGVtZW50ID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9LmJpbmQodGhpcykpO1xufTtcblxuLyoqXG4gKiBDcmVhdGVzIGEgbmV3IHBvb2wgcmVzb3VyY2VcbiAqL1xuU01UUFBvb2wucHJvdG90eXBlLl9jcmVhdGVDb25uZWN0aW9uID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBjb25uZWN0aW9uID0gbmV3IFBvb2xSZXNvdXJjZSh0aGlzKTtcblxuICAgIGNvbm5lY3Rpb24uaWQgPSArK3RoaXMuX2Nvbm5lY3Rpb25Db3VudGVyO1xuXG4gICAgdGhpcy5sb2dnZXIuaW5mbygnQ3JlYXRlZCBuZXcgcG9vbCByZXNvdXJjZSAjJXMnLCBjb25uZWN0aW9uLmlkKTtcblxuICAgIC8vIHJlc291cmNlIGNvbWVzIGF2YWlsYWJsZVxuICAgIGNvbm5lY3Rpb24ub24oJ2F2YWlsYWJsZScsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5sb2dnZXIuZGVidWcoJ0Nvbm5lY3Rpb24gIyVzIGJlY2FtZSBhdmFpbGFibGUnLCBjb25uZWN0aW9uLmlkKTtcblxuICAgICAgICBpZiAodGhpcy5fY2xvc2VkKSB7XG4gICAgICAgICAgICAvLyBpZiBhbHJlYWR5IGNsb3NlZCBydW4gY2xvc2UoKSB0aGF0IHdpbGwgcmVtb3ZlIHRoaXMgY29ubmVjdGlvbnMgZnJvbSBjb25uZWN0aW9ucyBsaXN0XG4gICAgICAgICAgICB0aGlzLmNsb3NlKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBjaGVjayBpZiB0aGVyZSdzIGFueXRoaW5nIGVsc2UgdG8gc2VuZFxuICAgICAgICAgICAgdGhpcy5fcHJvY2Vzc01lc3NhZ2VzKCk7XG4gICAgICAgIH1cbiAgICB9LmJpbmQodGhpcykpO1xuXG4gICAgLy8gcmVzb3VyY2UgaXMgdGVybWluYXRlZCB3aXRoIGFuIGVycm9yXG4gICAgY29ubmVjdGlvbi5vbmNlKCdlcnJvcicsIGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgaWYgKGVyci5jb2RlICE9PSAnRU1BWExJTUlUJykge1xuICAgICAgICAgICAgdGhpcy5sb2dnZXIuZXJyb3IoJ1Bvb2wgRXJyb3IgZm9yICMlczogJXMnLCBjb25uZWN0aW9uLmlkLCBlcnIubWVzc2FnZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmxvZ2dlci5kZWJ1ZygnTWF4IG1lc3NhZ2VzIGxpbWl0IGV4Y2hhdXN0ZWQgZm9yICMlcycsIGNvbm5lY3Rpb24uaWQpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGNvbm5lY3Rpb24ucXVldWVFbGVtZW50KSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGNvbm5lY3Rpb24ucXVldWVFbGVtZW50LmNhbGxiYWNrKGVycik7XG4gICAgICAgICAgICB9IGNhdGNoIChFKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5sb2dnZXIuZXJyb3IoJ0NhbGxiYWNrIGVycm9yIGZvciAjJXM6ICVzJywgY29ubmVjdGlvbi5pZCwgRS5tZXNzYWdlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbm5lY3Rpb24ucXVldWVFbGVtZW50ID0gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICAvLyByZW1vdmUgdGhlIGVycm9uZXVzIGNvbm5lY3Rpb24gZnJvbSBjb25uZWN0aW9ucyBsaXN0XG4gICAgICAgIHRoaXMuX3JlbW92ZUNvbm5lY3Rpb24oY29ubmVjdGlvbik7XG5cbiAgICAgICAgdGhpcy5fY29udGludWVQcm9jZXNzaW5nKCk7XG4gICAgfS5iaW5kKHRoaXMpKTtcblxuICAgIGNvbm5lY3Rpb24ub25jZSgnY2xvc2UnLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMubG9nZ2VyLmluZm8oJ0Nvbm5lY3Rpb24gIyVzIHdhcyBjbG9zZWQnLCBjb25uZWN0aW9uLmlkKTtcblxuICAgICAgICB0aGlzLl9yZW1vdmVDb25uZWN0aW9uKGNvbm5lY3Rpb24pO1xuXG4gICAgICAgIGlmIChjb25uZWN0aW9uLnF1ZXVlRWxlbWVudCkge1xuICAgICAgICAgICAgLy8gSWYgdGhlIGNvbm5lY3Rpb24gY2xvc2VkIHdoZW4gc2VuZGluZywgYWRkIHRoZSBtZXNzYWdlIHRvIHRoZSBxdWV1ZSBhZ2FpblxuICAgICAgICAgICAgLy8gTm90ZSB0aGF0IHdlIG11c3Qgd2FpdCBhIGJpdC4uIGJlY2F1c2UgdGhlIGNhbGxiYWNrIG9mIHRoZSAnZXJyb3InIGhhbmRsZXIgbWlnaHQgYmUgY2FsbGVkXG4gICAgICAgICAgICAvLyBpbiB0aGUgbmV4dCBldmVudCBsb29wXG4gICAgICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBpZiAoY29ubmVjdGlvbi5xdWV1ZUVsZW1lbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5sb2dnZXIuZGVidWcoJ1JlLXF1ZXVlZCBtZXNzYWdlIDwlcz4gZm9yICMlcycsIGNvbm5lY3Rpb24ucXVldWVFbGVtZW50Lm1lc3NhZ2VJZCwgY29ubmVjdGlvbi5pZCk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3F1ZXVlLnVuc2hpZnQoY29ubmVjdGlvbi5xdWV1ZUVsZW1lbnQpO1xuICAgICAgICAgICAgICAgICAgICBjb25uZWN0aW9uLnF1ZXVlRWxlbWVudCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLl9jb250aW51ZVByb2Nlc3NpbmcoKTtcbiAgICAgICAgICAgIH0uYmluZCh0aGlzKSwgNTApO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5fY29udGludWVQcm9jZXNzaW5nKCk7XG4gICAgICAgIH1cbiAgICB9LmJpbmQodGhpcykpO1xuXG4gICAgdGhpcy5fY29ubmVjdGlvbnMucHVzaChjb25uZWN0aW9uKTtcblxuICAgIHJldHVybiBjb25uZWN0aW9uO1xufTtcblxuLyoqXG4gKiBDb250aW51ZSB0byBwcm9jZXNzIG1lc3NhZ2UgaWYgdGhlIHBvb2wgaGFzbid0IGNsb3NlZFxuICovXG5TTVRQUG9vbC5wcm90b3R5cGUuX2NvbnRpbnVlUHJvY2Vzc2luZyA9IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAodGhpcy5fY2xvc2VkKSB7XG4gICAgICAgIHRoaXMuY2xvc2UoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBzZXRUaW1lb3V0KHRoaXMuX3Byb2Nlc3NNZXNzYWdlcy5iaW5kKHRoaXMpLCAxMDApO1xuICAgIH1cbn07XG5cbi8qKlxuICogUmVtb3ZlIHJlc291cmNlIGZyb20gcG9vbFxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBjb25uZWN0aW9uIFRoZSBQb29sUmVzb3VyY2UgdG8gcmVtb3ZlXG4gKi9cblNNVFBQb29sLnByb3RvdHlwZS5fcmVtb3ZlQ29ubmVjdGlvbiA9IGZ1bmN0aW9uIChjb25uZWN0aW9uKSB7XG4gICAgdmFyIGluZGV4ID0gdGhpcy5fY29ubmVjdGlvbnMuaW5kZXhPZihjb25uZWN0aW9uKTtcblxuICAgIGlmIChpbmRleCAhPT0gLTEpIHtcbiAgICAgICAgdGhpcy5fY29ubmVjdGlvbnMuc3BsaWNlKGluZGV4LCAxKTtcbiAgICB9XG59O1xuXG4vKipcbiAqIENoZWNrcyBpZiBjb25uZWN0aW9ucyBoYXZlIGhpdCBjdXJyZW50IHJhdGUgbGltaXQgYW5kIGlmIHNvLCBxdWV1ZXMgdGhlIGF2YWlsYWJpbGl0eSBjYWxsYmFja1xuICpcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIENhbGxiYWNrIGZ1bmN0aW9uIHRvIHJ1biBvbmNlIHJhdGUgbGltaXRlciBoYXMgYmVlbiBjbGVhcmVkXG4gKi9cblNNVFBQb29sLnByb3RvdHlwZS5fY2hlY2tSYXRlTGltaXQgPSBmdW5jdGlvbiAoY2FsbGJhY2spIHtcbiAgICBpZiAoIXRoaXMub3B0aW9ucy5yYXRlTGltaXQpIHtcbiAgICAgICAgcmV0dXJuIGNhbGxiYWNrKCk7XG4gICAgfVxuXG4gICAgdmFyIG5vdyA9IERhdGUubm93KCk7XG5cbiAgICBpZiAodGhpcy5fcmF0ZUxpbWl0LmNvdW50ZXIgPCB0aGlzLm9wdGlvbnMucmF0ZUxpbWl0KSB7XG4gICAgICAgIHJldHVybiBjYWxsYmFjaygpO1xuICAgIH1cblxuICAgIHRoaXMuX3JhdGVMaW1pdC53YWl0aW5nLnB1c2goY2FsbGJhY2spO1xuXG4gICAgaWYgKHRoaXMuX3JhdGVMaW1pdC5jaGVja3BvaW50IDw9IG5vdyAtIDEwMDApIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2NsZWFyUmF0ZUxpbWl0KCk7XG4gICAgfSBlbHNlIGlmICghdGhpcy5fcmF0ZUxpbWl0LnRpbWVvdXQpIHtcbiAgICAgICAgdGhpcy5fcmF0ZUxpbWl0LnRpbWVvdXQgPSBzZXRUaW1lb3V0KHRoaXMuX2NsZWFyUmF0ZUxpbWl0LmJpbmQodGhpcyksIDEwMDAgLSAobm93IC0gdGhpcy5fcmF0ZUxpbWl0LmNoZWNrcG9pbnQpKTtcbiAgICAgICAgdGhpcy5fcmF0ZUxpbWl0LmNoZWNrcG9pbnQgPSBub3c7XG4gICAgfVxufTtcblxuLyoqXG4gKiBDbGVhcnMgY3VycmVudCByYXRlIGxpbWl0IGxpbWl0YXRpb24gYW5kIHJ1bnMgcGF1c2VkIGNhbGxiYWNrXG4gKi9cblNNVFBQb29sLnByb3RvdHlwZS5fY2xlYXJSYXRlTGltaXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgY2xlYXJUaW1lb3V0KHRoaXMuX3JhdGVMaW1pdC50aW1lb3V0KTtcbiAgICB0aGlzLl9yYXRlTGltaXQudGltZW91dCA9IG51bGw7XG4gICAgdGhpcy5fcmF0ZUxpbWl0LmNvdW50ZXIgPSAwO1xuICAgIHRoaXMuX3JhdGVMaW1pdC5jaGVja3BvaW50ID0gZmFsc2U7XG5cbiAgICAvLyByZXN1bWUgYWxsIHBhdXNlZCBjb25uZWN0aW9uc1xuICAgIHdoaWxlICh0aGlzLl9yYXRlTGltaXQud2FpdGluZy5sZW5ndGgpIHtcbiAgICAgICAgdmFyIGNiID0gdGhpcy5fcmF0ZUxpbWl0LndhaXRpbmcuc2hpZnQoKTtcbiAgICAgICAgc2V0SW1tZWRpYXRlKGNiKTtcbiAgICB9XG59O1xuXG4vKipcbiAqIFJldHVybnMgdHJ1ZSBpZiB0aGVyZSBhcmUgZnJlZSBzbG90cyBpbiB0aGUgcXVldWVcbiAqL1xuU01UUFBvb2wucHJvdG90eXBlLmlzSWRsZSA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5pZGxpbmc7XG59O1xuXG4vKipcbiAqIFZlcmlmaWVzIFNNVFAgY29uZmlndXJhdGlvblxuICpcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIENhbGxiYWNrIGZ1bmN0aW9uXG4gKi9cblNNVFBQb29sLnByb3RvdHlwZS52ZXJpZnkgPSBmdW5jdGlvbiAoY2FsbGJhY2spIHtcbiAgICB2YXIgcHJvbWlzZTtcblxuICAgIGlmICghY2FsbGJhY2sgJiYgdHlwZW9mIFByb21pc2UgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgcHJvbWlzZSA9IG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgICAgIGNhbGxiYWNrID0gc2hhcmVkLmNhbGxiYWNrUHJvbWlzZShyZXNvbHZlLCByZWplY3QpO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICB0aGlzLmdldFNvY2tldCh0aGlzLm9wdGlvbnMsIGZ1bmN0aW9uIChlcnIsIHNvY2tldE9wdGlvbnMpIHtcbiAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKGVycik7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgb3B0aW9ucyA9IHRoaXMub3B0aW9ucztcbiAgICAgICAgaWYgKHNvY2tldE9wdGlvbnMgJiYgc29ja2V0T3B0aW9ucy5jb25uZWN0aW9uKSB7XG4gICAgICAgICAgICB0aGlzLmxvZ2dlci5pbmZvKCdVc2luZyBwcm94aWVkIHNvY2tldCBmcm9tICVzOiVzIHRvICVzOiVzJywgc29ja2V0T3B0aW9ucy5jb25uZWN0aW9uLnJlbW90ZUFkZHJlc3MsIHNvY2tldE9wdGlvbnMuY29ubmVjdGlvbi5yZW1vdGVQb3J0LCBvcHRpb25zLmhvc3QgfHwgJycsIG9wdGlvbnMucG9ydCB8fCAnJyk7XG4gICAgICAgICAgICBvcHRpb25zID0gYXNzaWduKGZhbHNlLCBvcHRpb25zKTtcbiAgICAgICAgICAgIE9iamVjdC5rZXlzKHNvY2tldE9wdGlvbnMpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgICAgICAgICAgICAgIG9wdGlvbnNba2V5XSA9IHNvY2tldE9wdGlvbnNba2V5XTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGNvbm5lY3Rpb24gPSBuZXcgU01UUENvbm5lY3Rpb24ob3B0aW9ucyk7XG4gICAgICAgIHZhciByZXR1cm5lZCA9IGZhbHNlO1xuXG4gICAgICAgIGNvbm5lY3Rpb24ub25jZSgnZXJyb3InLCBmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgICAgICBpZiAocmV0dXJuZWQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm5lZCA9IHRydWU7XG4gICAgICAgICAgICBjb25uZWN0aW9uLmNsb3NlKCk7XG4gICAgICAgICAgICByZXR1cm4gY2FsbGJhY2soZXJyKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgY29ubmVjdGlvbi5vbmNlKCdlbmQnLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAocmV0dXJuZWQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm5lZCA9IHRydWU7XG4gICAgICAgICAgICByZXR1cm4gY2FsbGJhY2sobmV3IEVycm9yKCdDb25uZWN0aW9uIGNsb3NlZCcpKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgdmFyIGZpbmFsaXplID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKHJldHVybmVkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuZWQgPSB0cnVlO1xuICAgICAgICAgICAgY29ubmVjdGlvbi5xdWl0KCk7XG4gICAgICAgICAgICByZXR1cm4gY2FsbGJhY2sobnVsbCwgdHJ1ZSk7XG4gICAgICAgIH07XG5cbiAgICAgICAgY29ubmVjdGlvbi5jb25uZWN0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmIChyZXR1cm5lZCkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5hdXRoKSB7XG4gICAgICAgICAgICAgICAgY29ubmVjdGlvbi5sb2dpbih0aGlzLm9wdGlvbnMuYXV0aCwgZnVuY3Rpb24gKGVycikge1xuICAgICAgICAgICAgICAgICAgICBpZiAocmV0dXJuZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybmVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbm5lY3Rpb24uY2xvc2UoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBjYWxsYmFjayhlcnIpO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgZmluYWxpemUoKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgZmluYWxpemUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfS5iaW5kKHRoaXMpKTtcbiAgICB9LmJpbmQodGhpcykpO1xuXG4gICAgcmV0dXJuIHByb21pc2U7XG59O1xuIiwibW9kdWxlLmV4cG9ydHM9e1xuICBcIl9hcmdzXCI6IFtcbiAgICBbXG4gICAgICBcIm5vZGVtYWlsZXItc210cC1wb29sQGh0dHBzOi8vcmVnaXN0cnkubnBtanMub3JnL25vZGVtYWlsZXItc210cC1wb29sLy0vbm9kZW1haWxlci1zbXRwLXBvb2wtMi42LjAudGd6XCIsXG4gICAgICBcIi9Vc2Vycy9uaG9uZy9uaWNraG9uZy5pby9ub2RlX21vZHVsZXMvbm9kZW1haWxlclwiXG4gICAgXVxuICBdLFxuICBcIl9mcm9tXCI6IFwibm9kZW1haWxlci1zbXRwLXBvb2xAMi42LjBcIixcbiAgXCJfaWRcIjogXCJub2RlbWFpbGVyLXNtdHAtcG9vbEAyLjYuMFwiLFxuICBcIl9pbkNhY2hlXCI6IHRydWUsXG4gIFwiX2xvY2F0aW9uXCI6IFwiL25vZGVtYWlsZXIvbm9kZW1haWxlci1zbXRwLXBvb2xcIixcbiAgXCJfcGhhbnRvbUNoaWxkcmVuXCI6IHt9LFxuICBcIl9yZXF1ZXN0ZWRcIjoge1xuICAgIFwibmFtZVwiOiBcIm5vZGVtYWlsZXItc210cC1wb29sXCIsXG4gICAgXCJyYXdcIjogXCJub2RlbWFpbGVyLXNtdHAtcG9vbEBodHRwczovL3JlZ2lzdHJ5Lm5wbWpzLm9yZy9ub2RlbWFpbGVyLXNtdHAtcG9vbC8tL25vZGVtYWlsZXItc210cC1wb29sLTIuNi4wLnRnelwiLFxuICAgIFwicmF3U3BlY1wiOiBcImh0dHBzOi8vcmVnaXN0cnkubnBtanMub3JnL25vZGVtYWlsZXItc210cC1wb29sLy0vbm9kZW1haWxlci1zbXRwLXBvb2wtMi42LjAudGd6XCIsXG4gICAgXCJzY29wZVwiOiBudWxsLFxuICAgIFwic3BlY1wiOiBcImh0dHBzOi8vcmVnaXN0cnkubnBtanMub3JnL25vZGVtYWlsZXItc210cC1wb29sLy0vbm9kZW1haWxlci1zbXRwLXBvb2wtMi42LjAudGd6XCIsXG4gICAgXCJ0eXBlXCI6IFwicmVtb3RlXCJcbiAgfSxcbiAgXCJfcmVxdWlyZWRCeVwiOiBbXG4gICAgXCIvbm9kZW1haWxlclwiXG4gIF0sXG4gIFwiX3Jlc29sdmVkXCI6IFwiaHR0cHM6Ly9yZWdpc3RyeS5ucG1qcy5vcmcvbm9kZW1haWxlci1zbXRwLXBvb2wvLS9ub2RlbWFpbGVyLXNtdHAtcG9vbC0yLjYuMC50Z3pcIixcbiAgXCJfc2hhc3VtXCI6IFwiYzQwNzE0MGRiMTJiMmIwYjcwNTA4OWIwMjU3M2RiMzg2OGE5MTlhY1wiLFxuICBcIl9zaHJpbmt3cmFwXCI6IG51bGwsXG4gIFwiX3NwZWNcIjogXCJub2RlbWFpbGVyLXNtdHAtcG9vbEBodHRwczovL3JlZ2lzdHJ5Lm5wbWpzLm9yZy9ub2RlbWFpbGVyLXNtdHAtcG9vbC8tL25vZGVtYWlsZXItc210cC1wb29sLTIuNi4wLnRnelwiLFxuICBcIl93aGVyZVwiOiBcIi9Vc2Vycy9uaG9uZy9uaWNraG9uZy5pby9ub2RlX21vZHVsZXMvbm9kZW1haWxlclwiLFxuICBcImF1dGhvclwiOiB7XG4gICAgXCJuYW1lXCI6IFwiQW5kcmlzIFJlaW5tYW5cIlxuICB9LFxuICBcImJ1Z3NcIjoge1xuICAgIFwidXJsXCI6IFwiaHR0cHM6Ly9naXRodWIuY29tL2FuZHJpczkvbm9kZW1haWxlci1zbXRwLXBvb2wvaXNzdWVzXCJcbiAgfSxcbiAgXCJkZXBlbmRlbmNpZXNcIjoge1xuICAgIFwibm9kZW1haWxlci1zaGFyZWRcIjogXCIxLjAuNVwiLFxuICAgIFwibm9kZW1haWxlci13ZWxsa25vd25cIjogXCIwLjEuOVwiLFxuICAgIFwic210cC1jb25uZWN0aW9uXCI6IFwiMi41LjBcIlxuICB9LFxuICBcImRlc2NyaXB0aW9uXCI6IFwiU01UUCB0cmFuc3BvcnQgZm9yIE5vZGVtYWlsZXJcIixcbiAgXCJkZXZEZXBlbmRlbmNpZXNcIjoge1xuICAgIFwiY2hhaVwiOiBcIl4zLjUuMFwiLFxuICAgIFwiZ3J1bnRcIjogXCJeMS4wLjFcIixcbiAgICBcImdydW50LWVzbGludFwiOiBcIl4xOC4xLjBcIixcbiAgICBcImdydW50LW1vY2hhLXRlc3RcIjogXCJeMC4xMi43XCIsXG4gICAgXCJtb2NoYVwiOiBcIl4yLjQuNVwiLFxuICAgIFwic210cC1zZXJ2ZXJcIjogXCJeMS45LjFcIlxuICB9LFxuICBcImhvbWVwYWdlXCI6IFwiaHR0cDovL2dpdGh1Yi5jb20vYW5kcmlzOS9ub2RlbWFpbGVyLXNtdHAtcG9vbFwiLFxuICBcImtleXdvcmRzXCI6IFtcbiAgICBcIlNNVFBcIixcbiAgICBcIk5vZGVtYWlsZXJcIlxuICBdLFxuICBcImxpY2Vuc2VcIjogXCJNSVRcIixcbiAgXCJtYWluXCI6IFwibGliL3NtdHAtcG9vbC5qc1wiLFxuICBcIm5hbWVcIjogXCJub2RlbWFpbGVyLXNtdHAtcG9vbFwiLFxuICBcIm9wdGlvbmFsRGVwZW5kZW5jaWVzXCI6IHt9LFxuICBcInJlYWRtZVwiOiBcIiMgU01UUCB0cmFuc3BvcnQgbW9kdWxlIGZvciBOb2RlbWFpbGVyXFxuXFxuQXBwbGllcyBmb3IgTm9kZW1haWxlciB2MS54IGFuZCBub3QgZm9yIHYwLnggd2hlcmUgdHJhbnNwb3J0cyBhcmUgYnVpbHQtaW4uXFxuXFxuIyMgVXNhZ2VcXG5cXG5JbnN0YWxsIHdpdGggbnBtXFxuXFxuICAgIG5wbSBpbnN0YWxsIG5vZGVtYWlsZXItc210cC1wb29sXFxuXFxuUmVxdWlyZSB0byB5b3VyIHNjcmlwdFxcblxcbmBgYGphdmFzY3JpcHRcXG52YXIgbm9kZW1haWxlciA9IHJlcXVpcmUoJ25vZGVtYWlsZXInKTtcXG52YXIgc210cFBvb2wgPSByZXF1aXJlKCdub2RlbWFpbGVyLXNtdHAtcG9vbCcpO1xcbmBgYFxcblxcbkNyZWF0ZSBhIE5vZGVtYWlsZXIgdHJhbnNwb3J0IG9iamVjdFxcblxcbmBgYGphdmFzY3JpcHRcXG52YXIgdHJhbnNwb3J0ZXIgPSBub2RlbWFpbGVyLmNyZWF0ZVRyYW5zcG9ydChzbXRwUG9vbChvcHRpb25zKSlcXG5gYGBcXG5cXG5XaGVyZVxcblxcbiAgKiAqKm9wdGlvbnMqKiBkZWZpbmVzIGNvbm5lY3Rpb24gZGF0YVxcbiAgICAqICoqb3B0aW9ucy5wb3J0KiogaXMgdGhlIHBvcnQgdG8gY29ubmVjdCB0byAoZGVmYXVsdHMgdG8gMjUgb3IgNDY1KVxcbiAgICAqICoqb3B0aW9ucy5ob3N0KiogaXMgdGhlIGhvc3RuYW1lIG9yIElQIGFkZHJlc3MgdG8gY29ubmVjdCB0byAoZGVmYXVsdHMgdG8gJ2xvY2FsaG9zdCcpXFxuICAgICogKipvcHRpb25zLnNlY3VyZSoqIGRlZmluZXMgaWYgdGhlIGNvbm5lY3Rpb24gc2hvdWxkIHVzZSBTU0wgKGlmIGB0cnVlYCkgb3Igbm90IChpZiBgZmFsc2VgKVxcbiAgICAqICoqb3B0aW9ucy5hdXRoKiogZGVmaW5lcyBhdXRoZW50aWNhdGlvbiBkYXRhIChzZWUgW2F1dGhlbnRpY2F0aW9uXSgjYXV0aGVudGljYXRpb24pIHNlY3Rpb24gYmVsb3cpXFxuICAgICogKipvcHRpb25zLmlnbm9yZVRMUyoqIHR1cm5zIG9mZiBTVEFSVFRMUyBzdXBwb3J0IGlmIHRydWVcXG4gICAgKiAqKm9wdGlvbnMubmFtZSoqIG9wdGlvbmFsIGhvc3RuYW1lIG9mIHRoZSBjbGllbnQsIHVzZWQgZm9yIGlkZW50aWZ5aW5nIHRvIHRoZSBzZXJ2ZXJcXG4gICAgKiAqKm9wdGlvbnMubG9jYWxBZGRyZXNzKiogaXMgdGhlIGxvY2FsIGludGVyZmFjZSB0byBiaW5kIHRvIGZvciBuZXR3b3JrIGNvbm5lY3Rpb25zXFxuICAgICogKipvcHRpb25zLmNvbm5lY3Rpb25UaW1lb3V0KiogaG93IG1hbnkgbWlsbGlzZWNvbmRzIHRvIHdhaXQgZm9yIHRoZSBjb25uZWN0aW9uIHRvIGVzdGFibGlzaFxcbiAgICAqICoqb3B0aW9ucy5ncmVldGluZ1RpbWVvdXQqKiBob3cgbWFueSBtaWxsaXNlY29uZHMgdG8gd2FpdCBmb3IgdGhlIGdyZWV0aW5nIGFmdGVyIGNvbm5lY3Rpb24gaXMgZXN0YWJsaXNoZWRcXG4gICAgKiAqKm9wdGlvbnMuc29ja2V0VGltZW91dCoqIGhvdyBtYW55IG1pbGxpc2Vjb25kcyBvZiBpbmFjdGl2aXR5IHRvIGFsbG93XFxuICAgICogKipvcHRpb25zLmxvZ2dlcioqIG9wdGlvbmFsIFtidW55YW5dKGh0dHBzOi8vZ2l0aHViLmNvbS90cmVudG0vbm9kZS1idW55YW4pIGNvbXBhdGlibGUgbG9nZ2VyIGluc3RhbmNlLiBJZiBzZXQgdG8gYHRydWVgIHRoZW4gbG9ncyB0byBjb25zb2xlLiBJZiB2YWx1ZSBpcyBub3Qgc2V0IG9yIGlzIGBmYWxzZWAgdGhlbiBub3RoaW5nIGlzIGxvZ2dlZFxcbiAgICAqICoqb3B0aW9ucy5kZWJ1ZyoqIGlmIHNldCB0byB0cnVlLCB0aGVuIGxvZ3MgU01UUCB0cmFmZmljLCBvdGhlcndpc2UgbG9ncyBvbmx5IHRyYW5zYWN0aW9uIGV2ZW50c1xcbiAgICAqICoqb3B0aW9ucy5hdXRoTWV0aG9kKiogZGVmaW5lcyBwcmVmZXJyZWQgYXV0aGVudGljYXRpb24gbWV0aG9kLCBlZy4gJ1BMQUlOJ1xcbiAgICAqICoqb3B0aW9ucy50bHMqKiBkZWZpbmVzIGFkZGl0aW9uYWwgb3B0aW9ucyB0byBiZSBwYXNzZWQgdG8gdGhlIHNvY2tldCBjb25zdHJ1Y3RvciwgZWcuICp7cmVqZWN0VW5hdXRob3JpemVkOiB0cnVlfSpcXG4gICAgKiAqKm1heENvbm5lY3Rpb25zKiogKGRlZmF1bHRzIHRvIDUpIGlzIHRoZSBjb3VudCBvZiBtYXhpbXVtIHNpbXVsdGFuZW91cyBjb25uZWN0aW9ucyB0byBtYWtlIGFnYWluc3QgdGhlIFNNVFAgc2VydmVyXFxuICAgICogKiptYXhNZXNzYWdlcyoqIChkZWZhdWx0cyB0byAxMDApIGxpbWl0cyB0aGUgbWVzc2FnZSBjb3VudCB0byBiZSBzZW50IHVzaW5nIGEgc2luZ2xlIGNvbm5lY3Rpb24uIEFmdGVyIG1heE1lc3NhZ2VzIG1lc3NhZ2VzIHRoZSBjb25uZWN0aW9uIGlzIGRyb3BwZWQgYW5kIGEgbmV3IG9uZSBpcyBjcmVhdGVkIGZvciB0aGUgZm9sbG93aW5nIG1lc3NhZ2VzXFxuICAgICogKipyYXRlTGltaXQqKiAoZGVmYXVsdHMgdG8gYGZhbHNlYCkgbGltaXRzIHRoZSBtZXNzYWdlIGNvdW50IHRvIGJlIHNlbnQgaW4gYSBzZWNvbmQuIE9uY2UgcmF0ZUxpbWl0IGlzIHJlYWNoZWQsIHNlbmRpbmcgaXMgcGF1c2VkIHVudGlsIHRoZSBlbmQgb2YgdGhlIHNlY29uZC4gVGhpcyBsaW1pdCBpcyBzaGFyZWQgYmV0d2VlbiBjb25uZWN0aW9ucywgc28gaWYgb25lIGNvbm5lY3Rpb24gdXNlcyB1cCB0aGUgbGltaXQsIHRoZW4gb3RoZXIgY29ubmVjdGlvbnMgYXJlIHBhdXNlZCBhcyB3ZWxsXFxuICAgICogKipnZXRTb2NrZXQqKiBvcHRpb25hbCBtZXRob2QgdGhhdCBpcyBjYWxsZWQgZXZlcnkgdGltZSBhIG5ldyBjb25uZWN0aW9uIGlzIG1hZGUgYWdhaW5zdCB0aGUgU01UUCBzZXJ2ZXIuIFRoaXMgbWV0aG9kIGNhbiBwcm92aWRlIGFuIGV4aXN0aW5nIHNvY2tldCB0byBiZSB1c2VkIGluc3RlYWQgb2YgY3JlYXRpbmcgYSBuZXcgb25lXFxuXFxuQWx0ZXJuYXRpdmVseSB5b3UgY2FuIHVzZSBjb25uZWN0aW9uIHVybCB3aXRoIHByb3RvY29sICdzbXRwOicgb3IgJ3NtdHBzOicuIFVzZSBxdWVyeSBhcmd1bWVudHMgZm9yIGFkZGl0aW9uYWwgY29uZmlndXJhdGlvbiB2YWx1ZXMuXFxuXFxuUG9vbGVkIFNNVFAgdHJhbnNwb3J0IHVzZXMgdGhlIHNhbWUgb3B0aW9ucyBhcyBbU01UUCB0cmFuc3BvcnRdKGh0dHBzOi8vZ2l0aHViLmNvbS9hbmRyaXM5L25vZGVtYWlsZXItc210cC10cmFuc3BvcnQpIHdpdGggdGhlIGFkZGl0aW9uIG9mICoqbWF4Q29ubmVjdGlvbnMqKiBhbmQgKiptYXhNZXNzYWdlcyoqLlxcblxcbioqRXhhbXBsZSoqXFxuXFxuYGBgamF2YXNjcmlwdFxcbnZhciB0cmFuc3BvcnQgPSBub2RlbWFpbGVyLmNyZWF0ZVRyYW5zcG9ydChzbXRwUG9vbCh7XFxuICAgIGhvc3Q6ICdsb2NhbGhvc3QnLFxcbiAgICBwb3J0OiAyNSxcXG4gICAgYXV0aDoge1xcbiAgICAgICAgdXNlcjogJ3VzZXJuYW1lJyxcXG4gICAgICAgIHBhc3M6ICdwYXNzd29yZCdcXG4gICAgfSxcXG4gICAgLy8gdXNlIHVwIHRvIDUgcGFyYWxsZWwgY29ubmVjdGlvbnNcXG4gICAgbWF4Q29ubmVjdGlvbnM6IDUsXFxuICAgIC8vIGRvIG5vdCBzZW5kIG1vcmUgdGhhbiAxMCBtZXNzYWdlcyBwZXIgY29ubmVjdGlvblxcbiAgICBtYXhNZXNzYWdlczogMTAsXFxuICAgIC8vIG5vIG5vdCBzZW5kIG1vcmUgdGhhbiA1IG1lc3NhZ2VzIGluIGEgc2Vjb25kXFxuICAgIHJhdGVMaW1pdDogNVxcbn0pKTtcXG5gYGBcXG5cXG5PciB3aXRoIGNvbm5lY3Rpb24gdXJsIChnbWFpbClcXG5cXG5gYGBqYXZhc2NyaXB0XFxudmFyIHRyYW5zcG9ydGVyID0gbm9kZW1haWxlci5jcmVhdGVUcmFuc3BvcnQoXFxuICAgIHNtdHBUcmFuc3BvcnQoJ3NtdHBzOi8vdXNlcm5hbWUlNDBnbWFpbC5jb206cGFzc3dvcmRAc210cC5nbWFpbC5jb20nKVxcbik7XFxuYGBgXFxuXFxuIyMgRXZlbnRzXFxuXFxuVGhlIGZvbGxvd2luZyBldmVudHMgYXJlIGVtaXR0ZWQgYnkgdGhpcyB0cmFuc3BvcnRcXG5cXG4jIyMgRXZlbnQ6ICdpZGxlJ1xcblxcbkVtaXR0ZWQgaWYgdGhlcmUgYXJlIGZyZWUgc2xvdHMgaW4gdGhlIGNvbm5lY3Rpb24gcG9vbC5cXG5DaGVjayB3aXRoIGAuaXNJZGxlKClgIG1ldGhvZCBpZiB0aGVzZSBmcmVlIHNsb3RzIGFyZSBzdGlsbCBhdmFpbGFibGUuXFxuVXNpbmcgdGhpcyBtZXRob2QgbWFrZXMgc2Vuc2UgaWYgeW91IG1haW50YWluIHlvdXIgb3duIHF1ZXVlIChmb3IgZXhhbXBsZSBwdWxsIGZyb20gc29tZSBxdWV1ZSBzZXJ2aWNlKS5cXG5cXG5gYGBqYXZhc2NyaXB0XFxudmFyIG1lc3NhZ2VzID0gWy4uLidsaXN0IG9mIG1lc3NhZ2VzJ107XFxudHJhbnNwb3J0ZXIub24oJ2lkbGUnLCBmdW5jdGlvbigpe1xcbiAgICAvLyBzZW5kIG5leHQgbWVzc2FnZXMgZnJvbSB0aGUgcGVuZGluZyBxdWV1ZVxcbiAgICB3aGlsZSh0cmFuc3BvcnRlci5pc0lkbGUoKSAmJiBtZXNzYWdlcy5sZW5ndGgpe1xcbiAgICAgICAgdHJhbnNwb3J0ZXIuc2VuZChtZXNzYWdlcy5zaGlmdCgpKTtcXG4gICAgfVxcbn0pO1xcbmBgYFxcblxcbiMjIEF1dGhlbnRpY2F0aW9uXFxuXFxuSWYgYXV0aGVudGljYXRpb24gZGF0YSBpcyBub3QgcHJlc2VudCwgdGhlIGNvbm5lY3Rpb24gaXMgY29uc2lkZXJlZCBhdXRoZW50aWNhdGVkIGZyb20gdGhlIHN0YXJ0LlxcblxcblNldCBhdXRoZW50Y2F0aW9uIGRhdGEgd2l0aCBgb3B0aW9ucy5hdXRoYFxcblxcbldoZXJlXFxuXFxuICAqICoqYXV0aCoqIGlzIHRoZSBhdXRoZW50aWNhdGlvbiBvYmplY3RcXG4gICAgKiAqKmF1dGgudXNlcioqIGlzIHRoZSB1c2VybmFtZVxcbiAgICAqICoqYXV0aC5wYXNzKiogaXMgdGhlIHBhc3N3b3JkIGZvciB0aGUgdXNlclxcbiAgICAqICoqYXV0aC54b2F1dGgyKiogaXMgdGhlIE9BdXRoMiBhY2Nlc3MgdG9rZW4gKHByZWZlcnJlZCBpZiBib3RoIGBwYXNzYCBhbmQgYHhvYXV0aDJgIHZhbHVlcyBhcmUgc2V0KSBvciBhbiBbWE9BdXRoMl0oaHR0cHM6Ly9naXRodWIuY29tL2FuZHJpczkveG9hdXRoMikgdG9rZW4gZ2VuZXJhdG9yIG9iamVjdC5cXG5cXG5JZiBhIFtYT0F1dGgyXShodHRwczovL2dpdGh1Yi5jb20vYW5kcmlzOS94b2F1dGgyKSB0b2tlbiBnZW5lcmF0b3IgaXMgdXNlZCBhcyB0aGUgdmFsdWUgZm9yIGBhdXRoLnhvYXV0aDJgIHRoZW4geW91IGRvIG5vdCBuZWVkIHRvIHNldCB0aGUgdmFsdWUgZm9yIGBhdXRoLnVzZXJgLiBYT0F1dGgyIGdlbmVyYXRvciBnZW5lcmF0ZXMgcmVxdWlyZWQgYGFjY2Vzc1Rva2VuYCBpdHNlbGYgaWYgaXQgaXMgbWlzc2luZyBvciBleHBpcmVkLiBJbiB0aGlzIGNhc2UgaWYgdGhlIGF1dGhlbnRpY2F0aW9uIGZhaWxzLCBhIG5ldyB0b2tlbiBpcyByZXF1ZXN0ZWQgYW5kIHRoZSBhdXRoZW50aWNhdGlvbiBpcyByZXRyaWVkIG9uY2UuIElmIGl0IHN0aWxsIGZhaWxzLCBhbiBlcnJvciBpcyByZXR1cm5lZC5cXG5cXG5JbnN0YWxsIHhvYXV0aDIgbW9kdWxlIHRvIHVzZSBYT2F1dGgyIHRva2VuIGdlbmVyYXRvcnMgKG5vdCBpbmNsdWRlZCBieSBkZWZhdWx0KVxcblxcbiAgICBucG0gaW5zdGFsbCB4b2F1dGgyIC0tc2F2ZVxcblxcbioqWE9BdXRoMiBFeGFtcGxlKipcXG5cXG4+ICoqTkIhKiogVGhlIGNvcnJlY3QgT0F1dGgyIHNjb3BlIGZvciBHbWFpbCBpcyBgaHR0cHM6Ly9tYWlsLmdvb2dsZS5jb20vYFxcblxcbmBgYGphdmFzY3JpcHRcXG52YXIgZ2VuZXJhdG9yID0gcmVxdWlyZSgneG9hdXRoMicpLmNyZWF0ZVhPQXV0aDJHZW5lcmF0b3Ioe1xcbiAgICB1c2VyOiAne3VzZXJuYW1lfScsXFxuICAgIGNsaWVudElkOiAne0NsaWVudCBJRH0nLFxcbiAgICBjbGllbnRTZWNyZXQ6ICd7Q2xpZW50IFNlY3JldH0nLFxcbiAgICByZWZyZXNoVG9rZW46ICd7cmVmcmVzaC10b2tlbn0nLFxcbiAgICBhY2Nlc3NUb2tlbjogJ3tjYWNoZWQgYWNjZXNzIHRva2VufScgLy8gb3B0aW9uYWxcXG59KTtcXG5cXG4vLyBsaXN0ZW4gZm9yIHRva2VuIHVwZGF0ZXNcXG4vLyB5b3UgcHJvYmFibHkgd2FudCB0byBzdG9yZSB0aGVzZSB0byBhIGRiXFxuZ2VuZXJhdG9yLm9uKCd0b2tlbicsIGZ1bmN0aW9uKHRva2VuKXtcXG4gICAgY29uc29sZS5sb2coJ05ldyB0b2tlbiBmb3IgJXM6ICVzJywgdG9rZW4udXNlciwgdG9rZW4uYWNjZXNzVG9rZW4pO1xcbn0pO1xcblxcbi8vIGxvZ2luXFxudmFyIHRyYW5zcG9ydCA9IG5vZGVtYWlsZXIuY3JlYXRlVHJhbnNwb3J0KHNtdHBQb29sKHtcXG4gICAgc2VydmljZTogJ2dtYWlsJyxcXG4gICAgYXV0aDoge1xcbiAgICAgICAgeG9hdXRoMjogZ2VuZXJhdG9yXFxuICAgIH0sXFxuICAgIG1heENvbm5lY3Rpb25zOiA1LFxcbiAgICBtYXhNZXNzYWdlczogMTBcXG59KSk7XFxuYGBgXFxuXFxuIyMgVXNpbmcgd2VsbC1rbm93biBzZXJ2aWNlc1xcblxcbklmIHlvdSBkbyBub3Qgd2FudCB0byBzcGVjaWZ5IHRoZSBob3N0bmFtZSwgcG9ydCBhbmQgc2VjdXJpdHkgc2V0dGluZ3MgZm9yIGEgd2VsbCBrbm93biBzZXJ2aWNlLCB5b3UgY2FuIHVzZSBpdCBieSBpdHMgbmFtZSAoY2FzZSBpbnNlbnNpdGl2ZSkuXFxuXFxuYGBgamF2YXNjcmlwdFxcbnNtdHBQb29sKHtcXG4gICAgc2VydmljZTogJ2dtYWlsJyxcXG4gICAgYXV0aDogLi5cXG59KTtcXG5gYGBcXG5cXG5TZWUgdGhlIGxpc3Qgb2YgYWxsIHN1cHBvcnRlZCBzZXJ2aWNlcyBbaGVyZV0oaHR0cHM6Ly9naXRodWIuY29tL2FuZHJpczkvbm9kZW1haWxlci13ZWxsa25vd24jc3VwcG9ydGVkLXNlcnZpY2VzKS5cXG5cXG4jIyBDbG9zZSB0aGUgcG9vbFxcblxcbkNsb3NlIGFsbCBjb25uZWN0aW9ucyB3aXRoIGBjbG9zZSgpYFxcblxcbmBgYGphdmFzY3JpcHRcXG50cmFuc3BvcnQuY2xvc2UoKTtcXG5gYGBcXG5cXG4jIyBWZXJpZnkgY29ubmVjdGlvbiBjb25maWd1cmF0aW9uXFxuXFxuWW91IGNhbiB2ZXJpZnkgeW91ciBjb25maWd1cmF0aW9uIHdpdGggYHZlcmlmeShjYWxsYmFjaylgIGNhbGwuIElmIGl0IHJldHVybnMgYW4gZXJyb3IsIHRoZW4gc29tZXRoaW5nIGlzIG5vdCBjb3JyZWN0LCBvdGhlcndpc2UgdGhlIHNlcnZlciBpcyByZWFkeSB0byBhY2NlcHQgbWVzc2FnZXMuXFxuXFxuYGBgamF2YXNjcmlwdFxcbi8vIHZlcmlmeSBjb25uZWN0aW9uIGNvbmZpZ3VyYXRpb25cXG50cmFuc3BvcnRlci52ZXJpZnkoZnVuY3Rpb24oZXJyb3IsIHN1Y2Nlc3MpIHtcXG4gICBpZiAoZXJyb3IpIHtcXG4gICAgICAgIGNvbnNvbGUubG9nKGVycm9yKTtcXG4gICB9IGVsc2Uge1xcbiAgICAgICAgY29uc29sZS5sb2coJ1NlcnZlciBpcyByZWFkeSB0byB0YWtlIG91ciBtZXNzYWdlcycpO1xcbiAgIH1cXG59KTtcXG5gYGBcXG5cXG4jIyBMaWNlbnNlXFxuXFxuKipNSVQqKlxcblwiLFxuICBcInJlYWRtZUZpbGVuYW1lXCI6IFwiUkVBRE1FLm1kXCIsXG4gIFwicmVwb3NpdG9yeVwiOiB7XG4gICAgXCJ0eXBlXCI6IFwiZ2l0XCIsXG4gICAgXCJ1cmxcIjogXCJnaXQ6Ly9naXRodWIuY29tL2FuZHJpczkvbm9kZW1haWxlci1zbXRwLXBvb2wuZ2l0XCJcbiAgfSxcbiAgXCJzY3JpcHRzXCI6IHtcbiAgICBcInRlc3RcIjogXCJncnVudFwiXG4gIH0sXG4gIFwidmVyc2lvblwiOiBcIjIuNi4wXCJcbn1cbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIFNNVFBDb25uZWN0aW9uID0gcmVxdWlyZSgnc210cC1jb25uZWN0aW9uJyk7XG52YXIgcGFja2FnZURhdGEgPSByZXF1aXJlKCcuLi9wYWNrYWdlLmpzb24nKTtcbnZhciB3ZWxsa25vd24gPSByZXF1aXJlKCdub2RlbWFpbGVyLXdlbGxrbm93bicpO1xudmFyIHNoYXJlZCA9IHJlcXVpcmUoJ25vZGVtYWlsZXItc2hhcmVkJyk7XG5cbnZhciBFdmVudEVtaXR0ZXIgPSByZXF1aXJlKCdldmVudHMnKS5FdmVudEVtaXR0ZXI7XG52YXIgdXRpbCA9IHJlcXVpcmUoJ3V0aWwnKTtcblxuLy8gZXhwb3NlIHRvIHRoZSB3b3JsZFxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgIHJldHVybiBuZXcgU01UUFRyYW5zcG9ydChvcHRpb25zKTtcbn07XG5cbi8qKlxuICogQ3JlYXRlcyBhIFNNVFAgdHJhbnNwb3J0IG9iamVjdCBmb3IgTm9kZW1haWxlclxuICpcbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgQ29ubmVjdGlvbiBvcHRpb25zXG4gKi9cbmZ1bmN0aW9uIFNNVFBUcmFuc3BvcnQob3B0aW9ucykge1xuICAgIEV2ZW50RW1pdHRlci5jYWxsKHRoaXMpO1xuXG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gICAgaWYgKHR5cGVvZiBvcHRpb25zID09PSAnc3RyaW5nJykge1xuICAgICAgICBvcHRpb25zID0ge1xuICAgICAgICAgICAgdXJsOiBvcHRpb25zXG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgdmFyIHVybERhdGE7XG4gICAgdmFyIHNlcnZpY2UgPSBvcHRpb25zLnNlcnZpY2U7XG5cbiAgICBpZiAodHlwZW9mIG9wdGlvbnMuZ2V0U29ja2V0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHRoaXMuZ2V0U29ja2V0ID0gb3B0aW9ucy5nZXRTb2NrZXQ7XG4gICAgfVxuXG4gICAgaWYgKG9wdGlvbnMudXJsKSB7XG4gICAgICAgIHVybERhdGEgPSBzaGFyZWQucGFyc2VDb25uZWN0aW9uVXJsKG9wdGlvbnMudXJsKTtcbiAgICAgICAgc2VydmljZSA9IHNlcnZpY2UgfHwgdXJsRGF0YS5zZXJ2aWNlO1xuICAgIH1cblxuICAgIHRoaXMub3B0aW9ucyA9IGFzc2lnbihcbiAgICAgICAgZmFsc2UsIC8vIGNyZWF0ZSBuZXcgb2JqZWN0XG4gICAgICAgIG9wdGlvbnMsIC8vIHJlZ3VsYXIgb3B0aW9uc1xuICAgICAgICB1cmxEYXRhLCAvLyB1cmwgb3B0aW9uc1xuICAgICAgICBzZXJ2aWNlICYmIHdlbGxrbm93bihzZXJ2aWNlKSAvLyB3ZWxsa25vd24gb3B0aW9uc1xuICAgICk7XG5cbiAgICB0aGlzLmxvZ2dlciA9IHNoYXJlZC5nZXRMb2dnZXIodGhpcy5vcHRpb25zKTtcblxuICAgIC8vIHRlbXBvcmFyeSBvYmplY3RcbiAgICB2YXIgY29ubmVjdGlvbiA9IG5ldyBTTVRQQ29ubmVjdGlvbih0aGlzLm9wdGlvbnMpO1xuXG4gICAgdGhpcy5uYW1lID0gJ1NNVFAnO1xuICAgIHRoaXMudmVyc2lvbiA9IHBhY2thZ2VEYXRhLnZlcnNpb24gKyAnW2NsaWVudDonICsgY29ubmVjdGlvbi52ZXJzaW9uICsgJ10nO1xufVxudXRpbC5pbmhlcml0cyhTTVRQVHJhbnNwb3J0LCBFdmVudEVtaXR0ZXIpO1xuXG4vKipcbiAqIFBsYWNlaG9sZGVyIGZ1bmN0aW9uIGZvciBjcmVhdGluZyBwcm94eSBzb2NrZXRzLiBUaGlzIG1ldGhvZCBpbW1lZGlhdGVsbHkgcmV0dXJuc1xuICogd2l0aG91dCBhIHNvY2tldFxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIENvbm5lY3Rpb24gb3B0aW9uc1xuICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgQ2FsbGJhY2sgZnVuY3Rpb24gdG8gcnVuIHdpdGggdGhlIHNvY2tldCBrZXlzXG4gKi9cblNNVFBUcmFuc3BvcnQucHJvdG90eXBlLmdldFNvY2tldCA9IGZ1bmN0aW9uIChvcHRpb25zLCBjYWxsYmFjaykge1xuICAgIC8vIHJldHVybiBpbW1lZGlhdGVsbHlcbiAgICByZXR1cm4gY2FsbGJhY2sobnVsbCwgZmFsc2UpO1xufTtcblxuLyoqXG4gKiBTZW5kcyBhbiBlLW1haWwgdXNpbmcgdGhlIHNlbGVjdGVkIHNldHRpbmdzXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IG1haWwgTWFpbCBvYmplY3RcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIENhbGxiYWNrIGZ1bmN0aW9uXG4gKi9cblNNVFBUcmFuc3BvcnQucHJvdG90eXBlLnNlbmQgPSBmdW5jdGlvbiAobWFpbCwgY2FsbGJhY2spIHtcblxuICAgIHRoaXMuZ2V0U29ja2V0KHRoaXMub3B0aW9ucywgZnVuY3Rpb24gKGVyciwgc29ja2V0T3B0aW9ucykge1xuICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICByZXR1cm4gY2FsbGJhY2soZXJyKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBvcHRpb25zID0gdGhpcy5vcHRpb25zO1xuICAgICAgICBpZiAoc29ja2V0T3B0aW9ucyAmJiBzb2NrZXRPcHRpb25zLmNvbm5lY3Rpb24pIHtcbiAgICAgICAgICAgIHRoaXMubG9nZ2VyLmluZm8oJ1VzaW5nIHByb3hpZWQgc29ja2V0IGZyb20gJXM6JXMgdG8gJXM6JXMnLCBzb2NrZXRPcHRpb25zLmNvbm5lY3Rpb24ucmVtb3RlQWRkcmVzcywgc29ja2V0T3B0aW9ucy5jb25uZWN0aW9uLnJlbW90ZVBvcnQsIG9wdGlvbnMuaG9zdCB8fCAnJywgb3B0aW9ucy5wb3J0IHx8ICcnKTtcbiAgICAgICAgICAgIC8vIG9ubHkgY29weSBvcHRpb25zIGlmIHdlIG5lZWQgdG8gbW9kaWZ5IGl0XG4gICAgICAgICAgICBvcHRpb25zID0gYXNzaWduKGZhbHNlLCBvcHRpb25zKTtcbiAgICAgICAgICAgIE9iamVjdC5rZXlzKHNvY2tldE9wdGlvbnMpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgICAgICAgICAgICAgIG9wdGlvbnNba2V5XSA9IHNvY2tldE9wdGlvbnNba2V5XTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGNvbm5lY3Rpb24gPSBuZXcgU01UUENvbm5lY3Rpb24ob3B0aW9ucyk7XG4gICAgICAgIHZhciByZXR1cm5lZCA9IGZhbHNlO1xuXG4gICAgICAgIGNvbm5lY3Rpb24ub25jZSgnZXJyb3InLCBmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgICAgICBpZiAocmV0dXJuZWQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm5lZCA9IHRydWU7XG4gICAgICAgICAgICBjb25uZWN0aW9uLmNsb3NlKCk7XG4gICAgICAgICAgICByZXR1cm4gY2FsbGJhY2soZXJyKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgY29ubmVjdGlvbi5vbmNlKCdlbmQnLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAocmV0dXJuZWQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm5lZCA9IHRydWU7XG4gICAgICAgICAgICByZXR1cm4gY2FsbGJhY2sobmV3IEVycm9yKCdDb25uZWN0aW9uIGNsb3NlZCcpKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgdmFyIHNlbmRNZXNzYWdlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIGVudmVsb3BlID0gbWFpbC5kYXRhLmVudmVsb3BlIHx8IG1haWwubWVzc2FnZS5nZXRFbnZlbG9wZSgpO1xuICAgICAgICAgICAgdmFyIG1lc3NhZ2VJZCA9IChtYWlsLm1lc3NhZ2UuZ2V0SGVhZGVyKCdtZXNzYWdlLWlkJykgfHwgJycpLnJlcGxhY2UoL1s8Plxcc10vZywgJycpO1xuICAgICAgICAgICAgdmFyIHJlY2lwaWVudHMgPSBbXS5jb25jYXQoZW52ZWxvcGUudG8gfHwgW10pO1xuICAgICAgICAgICAgaWYgKHJlY2lwaWVudHMubGVuZ3RoID4gMykge1xuICAgICAgICAgICAgICAgIHJlY2lwaWVudHMucHVzaCgnLi4uYW5kICcgKyByZWNpcGllbnRzLnNwbGljZSgyKS5sZW5ndGggKyAnIG1vcmUnKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGhpcy5sb2dnZXIuaW5mbygnU2VuZGluZyBtZXNzYWdlIDwlcz4gdG8gPCVzPicsIG1lc3NhZ2VJZCwgcmVjaXBpZW50cy5qb2luKCcsICcpKTtcblxuICAgICAgICAgICAgY29ubmVjdGlvbi5zZW5kKGVudmVsb3BlLCBtYWlsLm1lc3NhZ2UuY3JlYXRlUmVhZFN0cmVhbSgpLCBmdW5jdGlvbiAoZXJyLCBpbmZvKSB7XG4gICAgICAgICAgICAgICAgaWYgKHJldHVybmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuZWQgPSB0cnVlO1xuXG4gICAgICAgICAgICAgICAgY29ubmVjdGlvbi5jbG9zZSgpO1xuICAgICAgICAgICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKGVycik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGluZm8uZW52ZWxvcGUgPSB7XG4gICAgICAgICAgICAgICAgICAgIGZyb206IGVudmVsb3BlLmZyb20sXG4gICAgICAgICAgICAgICAgICAgIHRvOiBlbnZlbG9wZS50b1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgaW5mby5tZXNzYWdlSWQgPSBtZXNzYWdlSWQ7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKG51bGwsIGluZm8pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0uYmluZCh0aGlzKTtcblxuICAgICAgICBjb25uZWN0aW9uLmNvbm5lY3QoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKHJldHVybmVkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAodGhpcy5vcHRpb25zLmF1dGgpIHtcbiAgICAgICAgICAgICAgICBjb25uZWN0aW9uLmxvZ2luKHRoaXMub3B0aW9ucy5hdXRoLCBmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChyZXR1cm5lZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29ubmVjdGlvbi5jbG9zZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKGVycik7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBzZW5kTWVzc2FnZSgpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBzZW5kTWVzc2FnZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LmJpbmQodGhpcykpO1xuICAgIH0uYmluZCh0aGlzKSk7XG59O1xuXG4vKipcbiAqIFZlcmlmaWVzIFNNVFAgY29uZmlndXJhdGlvblxuICpcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIENhbGxiYWNrIGZ1bmN0aW9uXG4gKi9cblNNVFBUcmFuc3BvcnQucHJvdG90eXBlLnZlcmlmeSA9IGZ1bmN0aW9uIChjYWxsYmFjaykge1xuICAgIHZhciBwcm9taXNlO1xuXG4gICAgaWYgKCFjYWxsYmFjayAmJiB0eXBlb2YgUHJvbWlzZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBwcm9taXNlID0gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICAgICAgY2FsbGJhY2sgPSBzaGFyZWQuY2FsbGJhY2tQcm9taXNlKHJlc29sdmUsIHJlamVjdCk7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIHRoaXMuZ2V0U29ja2V0KHRoaXMub3B0aW9ucywgZnVuY3Rpb24gKGVyciwgc29ja2V0T3B0aW9ucykge1xuICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICByZXR1cm4gY2FsbGJhY2soZXJyKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBvcHRpb25zID0gdGhpcy5vcHRpb25zO1xuICAgICAgICBpZiAoc29ja2V0T3B0aW9ucyAmJiBzb2NrZXRPcHRpb25zLmNvbm5lY3Rpb24pIHtcbiAgICAgICAgICAgIHRoaXMubG9nZ2VyLmluZm8oJ1VzaW5nIHByb3hpZWQgc29ja2V0IGZyb20gJXM6JXMnLCBzb2NrZXRPcHRpb25zLmNvbm5lY3Rpb24ucmVtb3RlQWRkcmVzcywgc29ja2V0T3B0aW9ucy5jb25uZWN0aW9uLnJlbW90ZVBvcnQpO1xuICAgICAgICAgICAgb3B0aW9ucyA9IGFzc2lnbihmYWxzZSwgb3B0aW9ucyk7XG4gICAgICAgICAgICBPYmplY3Qua2V5cyhzb2NrZXRPcHRpb25zKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgICAgICAgICBvcHRpb25zW2tleV0gPSBzb2NrZXRPcHRpb25zW2tleV07XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBjb25uZWN0aW9uID0gbmV3IFNNVFBDb25uZWN0aW9uKG9wdGlvbnMpO1xuICAgICAgICB2YXIgcmV0dXJuZWQgPSBmYWxzZTtcblxuICAgICAgICBjb25uZWN0aW9uLm9uY2UoJ2Vycm9yJywgZnVuY3Rpb24gKGVycikge1xuICAgICAgICAgICAgaWYgKHJldHVybmVkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuZWQgPSB0cnVlO1xuICAgICAgICAgICAgY29ubmVjdGlvbi5jbG9zZSgpO1xuICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKGVycik7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGNvbm5lY3Rpb24ub25jZSgnZW5kJywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKHJldHVybmVkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuZWQgPSB0cnVlO1xuICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKG5ldyBFcnJvcignQ29ubmVjdGlvbiBjbG9zZWQnKSk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHZhciBmaW5hbGl6ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmIChyZXR1cm5lZCkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybmVkID0gdHJ1ZTtcbiAgICAgICAgICAgIGNvbm5lY3Rpb24ucXVpdCgpO1xuICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKG51bGwsIHRydWUpO1xuICAgICAgICB9O1xuXG4gICAgICAgIGNvbm5lY3Rpb24uY29ubmVjdChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAocmV0dXJuZWQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICh0aGlzLm9wdGlvbnMuYXV0aCkge1xuICAgICAgICAgICAgICAgIGNvbm5lY3Rpb24ubG9naW4odGhpcy5vcHRpb25zLmF1dGgsIGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJldHVybmVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm5lZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25uZWN0aW9uLmNsb3NlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gY2FsbGJhY2soZXJyKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGZpbmFsaXplKCk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGZpbmFsaXplKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0uYmluZCh0aGlzKSk7XG4gICAgfS5iaW5kKHRoaXMpKTtcblxuICAgIHJldHVybiBwcm9taXNlO1xufTtcblxuLyoqXG4gKiBDb3BpZXMgcHJvcGVydGllcyBmcm9tIHNvdXJjZSBvYmplY3RzIHRvIHRhcmdldCBvYmplY3RzXG4gKi9cbmZ1bmN0aW9uIGFzc2lnbiggLyogdGFyZ2V0LCAuLi4gc291cmNlcyAqLyApIHtcbiAgICB2YXIgYXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cyk7XG4gICAgdmFyIHRhcmdldCA9IGFyZ3Muc2hpZnQoKSB8fCB7fTtcblxuICAgIGFyZ3MuZm9yRWFjaChmdW5jdGlvbiAoc291cmNlKSB7XG4gICAgICAgIE9iamVjdC5rZXlzKHNvdXJjZSB8fCB7fSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgICAgICBpZiAoWyd0bHMnLCAnYXV0aCddLmluZGV4T2Yoa2V5KSA+PSAwICYmIHNvdXJjZVtrZXldICYmIHR5cGVvZiBzb3VyY2Vba2V5XSA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgICAgICAvLyB0bHMgYW5kIGF1dGggYXJlIHNwZWNpYWwga2V5cyB0aGF0IG5lZWQgdG8gYmUgZW51bWVyYXRlZCBzZXBhcmF0ZWx5XG4gICAgICAgICAgICAgICAgLy8gb3RoZXIgb2JqZWN0cyBhcmUgcGFzc2VkIGFzIGlzXG4gICAgICAgICAgICAgICAgaWYgKCF0YXJnZXRba2V5XSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBlc251cmUgdGhhdCB0YXJnZXQgaGFzIHRoaXMga2V5XG4gICAgICAgICAgICAgICAgICAgIHRhcmdldFtrZXldID0ge307XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIE9iamVjdC5rZXlzKHNvdXJjZVtrZXldKS5mb3JFYWNoKGZ1bmN0aW9uIChzdWJLZXkpIHtcbiAgICAgICAgICAgICAgICAgICAgdGFyZ2V0W2tleV1bc3ViS2V5XSA9IHNvdXJjZVtrZXldW3N1YktleV07XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRhcmdldFtrZXldID0gc291cmNlW2tleV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH0pO1xuICAgIHJldHVybiB0YXJnZXQ7XG59XG4iLCJtb2R1bGUuZXhwb3J0cz17XG4gIFwiX2FyZ3NcIjogW1xuICAgIFtcbiAgICAgIFwibm9kZW1haWxlci1zbXRwLXRyYW5zcG9ydEBodHRwczovL3JlZ2lzdHJ5Lm5wbWpzLm9yZy9ub2RlbWFpbGVyLXNtdHAtdHJhbnNwb3J0Ly0vbm9kZW1haWxlci1zbXRwLXRyYW5zcG9ydC0yLjUuMC50Z3pcIixcbiAgICAgIFwiL1VzZXJzL25ob25nL25pY2tob25nLmlvL25vZGVfbW9kdWxlcy9ub2RlbWFpbGVyXCJcbiAgICBdXG4gIF0sXG4gIFwiX2Zyb21cIjogXCJub2RlbWFpbGVyLXNtdHAtdHJhbnNwb3J0QDIuNS4wXCIsXG4gIFwiX2lkXCI6IFwibm9kZW1haWxlci1zbXRwLXRyYW5zcG9ydEAyLjUuMFwiLFxuICBcIl9pbkNhY2hlXCI6IHRydWUsXG4gIFwiX2xvY2F0aW9uXCI6IFwiL25vZGVtYWlsZXIvbm9kZW1haWxlci1zbXRwLXRyYW5zcG9ydFwiLFxuICBcIl9waGFudG9tQ2hpbGRyZW5cIjoge30sXG4gIFwiX3JlcXVlc3RlZFwiOiB7XG4gICAgXCJuYW1lXCI6IFwibm9kZW1haWxlci1zbXRwLXRyYW5zcG9ydFwiLFxuICAgIFwicmF3XCI6IFwibm9kZW1haWxlci1zbXRwLXRyYW5zcG9ydEBodHRwczovL3JlZ2lzdHJ5Lm5wbWpzLm9yZy9ub2RlbWFpbGVyLXNtdHAtdHJhbnNwb3J0Ly0vbm9kZW1haWxlci1zbXRwLXRyYW5zcG9ydC0yLjUuMC50Z3pcIixcbiAgICBcInJhd1NwZWNcIjogXCJodHRwczovL3JlZ2lzdHJ5Lm5wbWpzLm9yZy9ub2RlbWFpbGVyLXNtdHAtdHJhbnNwb3J0Ly0vbm9kZW1haWxlci1zbXRwLXRyYW5zcG9ydC0yLjUuMC50Z3pcIixcbiAgICBcInNjb3BlXCI6IG51bGwsXG4gICAgXCJzcGVjXCI6IFwiaHR0cHM6Ly9yZWdpc3RyeS5ucG1qcy5vcmcvbm9kZW1haWxlci1zbXRwLXRyYW5zcG9ydC8tL25vZGVtYWlsZXItc210cC10cmFuc3BvcnQtMi41LjAudGd6XCIsXG4gICAgXCJ0eXBlXCI6IFwicmVtb3RlXCJcbiAgfSxcbiAgXCJfcmVxdWlyZWRCeVwiOiBbXG4gICAgXCIvbm9kZW1haWxlclwiXG4gIF0sXG4gIFwiX3Jlc29sdmVkXCI6IFwiaHR0cHM6Ly9yZWdpc3RyeS5ucG1qcy5vcmcvbm9kZW1haWxlci1zbXRwLXRyYW5zcG9ydC8tL25vZGVtYWlsZXItc210cC10cmFuc3BvcnQtMi41LjAudGd6XCIsXG4gIFwiX3NoYXN1bVwiOiBcIjZmNWZmN2E5OTQwMWEzYmEzZDMyNDA4MWE1YjdlNDFhZTU0ZTg1ZmFcIixcbiAgXCJfc2hyaW5rd3JhcFwiOiBudWxsLFxuICBcIl9zcGVjXCI6IFwibm9kZW1haWxlci1zbXRwLXRyYW5zcG9ydEBodHRwczovL3JlZ2lzdHJ5Lm5wbWpzLm9yZy9ub2RlbWFpbGVyLXNtdHAtdHJhbnNwb3J0Ly0vbm9kZW1haWxlci1zbXRwLXRyYW5zcG9ydC0yLjUuMC50Z3pcIixcbiAgXCJfd2hlcmVcIjogXCIvVXNlcnMvbmhvbmcvbmlja2hvbmcuaW8vbm9kZV9tb2R1bGVzL25vZGVtYWlsZXJcIixcbiAgXCJhdXRob3JcIjoge1xuICAgIFwibmFtZVwiOiBcIkFuZHJpcyBSZWlubWFuXCJcbiAgfSxcbiAgXCJidWdzXCI6IHtcbiAgICBcInVybFwiOiBcImh0dHBzOi8vZ2l0aHViLmNvbS9hbmRyaXM5L25vZGVtYWlsZXItc210cC10cmFuc3BvcnQvaXNzdWVzXCJcbiAgfSxcbiAgXCJkZXBlbmRlbmNpZXNcIjoge1xuICAgIFwibm9kZW1haWxlci1zaGFyZWRcIjogXCIxLjAuNVwiLFxuICAgIFwibm9kZW1haWxlci13ZWxsa25vd25cIjogXCIwLjEuOVwiLFxuICAgIFwic210cC1jb25uZWN0aW9uXCI6IFwiMi41LjBcIlxuICB9LFxuICBcImRlc2NyaXB0aW9uXCI6IFwiU01UUCB0cmFuc3BvcnQgZm9yIE5vZGVtYWlsZXJcIixcbiAgXCJkZXZEZXBlbmRlbmNpZXNcIjoge1xuICAgIFwiY2hhaVwiOiBcIl4zLjUuMFwiLFxuICAgIFwiZ3J1bnRcIjogXCJeMS4wLjFcIixcbiAgICBcImdydW50LWVzbGludFwiOiBcIl4xOC4xLjBcIixcbiAgICBcImdydW50LW1vY2hhLXRlc3RcIjogXCJeMC4xMi43XCIsXG4gICAgXCJtb2NoYVwiOiBcIl4yLjQuNVwiLFxuICAgIFwic210cC1zZXJ2ZXJcIjogXCJeMS45LjFcIlxuICB9LFxuICBcImhvbWVwYWdlXCI6IFwiaHR0cDovL2dpdGh1Yi5jb20vYW5kcmlzOS9ub2RlbWFpbGVyLXNtdHAtdHJhbnNwb3J0XCIsXG4gIFwia2V5d29yZHNcIjogW1xuICAgIFwiU01UUFwiLFxuICAgIFwiTm9kZW1haWxlclwiXG4gIF0sXG4gIFwibGljZW5zZVwiOiBcIk1JVFwiLFxuICBcIm1haW5cIjogXCJsaWIvc210cC10cmFuc3BvcnQuanNcIixcbiAgXCJuYW1lXCI6IFwibm9kZW1haWxlci1zbXRwLXRyYW5zcG9ydFwiLFxuICBcIm9wdGlvbmFsRGVwZW5kZW5jaWVzXCI6IHt9LFxuICBcInJlYWRtZVwiOiBcIiMgU01UUCB0cmFuc3BvcnQgbW9kdWxlIGZvciBOb2RlbWFpbGVyXFxuXFxuWyFbQnVpbGQgU3RhdHVzXShodHRwczovL3RyYXZpcy1jaS5vcmcvYW5kcmlzOS9ub2RlbWFpbGVyLXNtdHAtdHJhbnNwb3J0LnN2ZyldKGh0dHBzOi8vdHJhdmlzLWNpLm9yZy9hbmRyaXM5L25vZGVtYWlsZXItc210cC10cmFuc3BvcnQpXFxuWyFbTlBNIHZlcnNpb25dKGh0dHBzOi8vYmFkZ2UuZnVyeS5pby9qcy9ub2RlbWFpbGVyLXNtdHAtdHJhbnNwb3J0LnBuZyldKGh0dHA6Ly9iYWRnZS5mdXJ5LmlvL2pzL25vZGVtYWlsZXItc210cC10cmFuc3BvcnQpXFxuXFxuQXBwbGllcyBmb3IgTm9kZW1haWxlciB2MS54IGFuZCBub3QgZm9yIHYwLnggd2hlcmUgdHJhbnNwb3J0cyBhcmUgYnVpbHQtaW4uXFxuXFxuIyMgU2V0dXBcXG5cXG5JbnN0YWxsIHdpdGggbnBtXFxuXFxuICAgIG5wbSBpbnN0YWxsIG5vZGVtYWlsZXItc210cC10cmFuc3BvcnRcXG5cXG5SZXF1aXJlIHRvIHlvdXIgc2NyaXB0XFxuXFxuYGBgamF2YXNjcmlwdFxcbnZhciBub2RlbWFpbGVyID0gcmVxdWlyZSgnbm9kZW1haWxlcicpO1xcbnZhciBzbXRwVHJhbnNwb3J0ID0gcmVxdWlyZSgnbm9kZW1haWxlci1zbXRwLXRyYW5zcG9ydCcpO1xcbmBgYFxcblxcbiMjIFVzYWdlXFxuXFxuQ3JlYXRlIGEgTm9kZW1haWxlciB0cmFuc3BvcnQgb2JqZWN0XFxuXFxuYGBgamF2YXNjcmlwdFxcbnZhciB0cmFuc3BvcnRlciA9IG5vZGVtYWlsZXIuY3JlYXRlVHJhbnNwb3J0KHNtdHBUcmFuc3BvcnQob3B0aW9ucykpXFxuYGBgXFxuXFxub3IgKGJ5IHVzaW5nIHNtdHBUcmFuc3BvcnQgYXMgZGVmYXVsdClcXG5cXG5gYGBqYXZhc2NyaXB0XFxudmFyIHRyYW5zcG9ydGVyID0gbm9kZW1haWxlci5jcmVhdGVUcmFuc3BvcnQob3B0aW9ucylcXG5gYGBcXG5cXG5XaGVyZVxcblxcbiAgKiAqKm9wdGlvbnMqKiBkZWZpbmVzIGNvbm5lY3Rpb24gZGF0YVxcbiAgICAqICoqb3B0aW9ucy5wb3J0KiogaXMgdGhlIHBvcnQgdG8gY29ubmVjdCB0byAoZGVmYXVsdHMgdG8gMjUgb3IgNDY1KVxcbiAgICAqICoqb3B0aW9ucy5ob3N0KiogaXMgdGhlIGhvc3RuYW1lIG9yIElQIGFkZHJlc3MgdG8gY29ubmVjdCB0byAoZGVmYXVsdHMgdG8gJ2xvY2FsaG9zdCcpXFxuICAgICogKipvcHRpb25zLnNlY3VyZSoqIGRlZmluZXMgaWYgdGhlIGNvbm5lY3Rpb24gc2hvdWxkIHVzZSBTU0wgKGlmIGB0cnVlYCkgb3Igbm90IChpZiBgZmFsc2VgKVxcbiAgICAqICoqb3B0aW9ucy5hdXRoKiogZGVmaW5lcyBhdXRoZW50aWNhdGlvbiBkYXRhIChzZWUgW2F1dGhlbnRpY2F0aW9uXSgjYXV0aGVudGljYXRpb24pIHNlY3Rpb24gYmVsb3cpXFxuICAgICogKipvcHRpb25zLmlnbm9yZVRMUyoqIHR1cm5zIG9mZiBTVEFSVFRMUyBzdXBwb3J0IGlmIHRydWVcXG4gICAgKiAqKm9wdGlvbnMubmFtZSoqIG9wdGlvbmFsIGhvc3RuYW1lIG9mIHRoZSBjbGllbnQsIHVzZWQgZm9yIGlkZW50aWZ5aW5nIHRvIHRoZSBzZXJ2ZXJcXG4gICAgKiAqKm9wdGlvbnMubG9jYWxBZGRyZXNzKiogaXMgdGhlIGxvY2FsIGludGVyZmFjZSB0byBiaW5kIHRvIGZvciBuZXR3b3JrIGNvbm5lY3Rpb25zXFxuICAgICogKipvcHRpb25zLmNvbm5lY3Rpb25UaW1lb3V0KiogaG93IG1hbnkgbWlsbGlzZWNvbmRzIHRvIHdhaXQgZm9yIHRoZSBjb25uZWN0aW9uIHRvIGVzdGFibGlzaFxcbiAgICAqICoqb3B0aW9ucy5ncmVldGluZ1RpbWVvdXQqKiBob3cgbWFueSBtaWxsaXNlY29uZHMgdG8gd2FpdCBmb3IgdGhlIGdyZWV0aW5nIGFmdGVyIGNvbm5lY3Rpb24gaXMgZXN0YWJsaXNoZWRcXG4gICAgKiAqKm9wdGlvbnMuc29ja2V0VGltZW91dCoqIGhvdyBtYW55IG1pbGxpc2Vjb25kcyBvZiBpbmFjdGl2aXR5IHRvIGFsbG93XFxuICAgICogKipvcHRpb25zLmxvZ2dlcioqIG9wdGlvbmFsIFtidW55YW5dKGh0dHBzOi8vZ2l0aHViLmNvbS90cmVudG0vbm9kZS1idW55YW4pIGNvbXBhdGlibGUgbG9nZ2VyIGluc3RhbmNlLiBJZiBzZXQgdG8gYHRydWVgIHRoZW4gbG9ncyB0byBjb25zb2xlLiBJZiB2YWx1ZSBpcyBub3Qgc2V0IG9yIGlzIGBmYWxzZWAgdGhlbiBub3RoaW5nIGlzIGxvZ2dlZFxcbiAgICAqICoqb3B0aW9ucy5kZWJ1ZyoqIGlmIHNldCB0byB0cnVlLCB0aGVuIGxvZ3MgU01UUCB0cmFmZmljLCBvdGhlcndpc2UgbG9ncyBvbmx5IHRyYW5zYWN0aW9uIGV2ZW50c1xcbiAgICAqICoqb3B0aW9ucy5hdXRoTWV0aG9kKiogZGVmaW5lcyBwcmVmZXJyZWQgYXV0aGVudGljYXRpb24gbWV0aG9kLCBlZy4gJ1BMQUlOJ1xcbiAgICAqICoqb3B0aW9ucy50bHMqKiBkZWZpbmVzIGFkZGl0aW9uYWwgb3B0aW9ucyB0byBiZSBwYXNzZWQgdG8gdGhlIHNvY2tldCBjb25zdHJ1Y3RvciwgZWcuICp7cmVqZWN0VW5hdXRob3JpemVkOiB0cnVlfSpcXG4gICAgKiAqKmdldFNvY2tldCoqIG9wdGlvbmFsIG1ldGhvZCB0aGF0IGlzIGNhbGxlZCBldmVyeSB0aW1lIGEgbmV3IGNvbm5lY3Rpb24gaXMgbWFkZSBhZ2FpbnN0IHRoZSBTTVRQIHNlcnZlci4gVGhpcyBtZXRob2QgY2FuIHByb3ZpZGUgYW4gZXhpc3Rpbmcgc29ja2V0IHRvIGJlIHVzZWQgaW5zdGVhZCBvZiBjcmVhdGluZyBhIG5ldyBvbmVcXG5cXG5BbHRlcm5hdGl2ZWx5IHlvdSBjYW4gdXNlIGNvbm5lY3Rpb24gdXJsIHdpdGggcHJvdG9jb2wgJ3NtdHA6JyBvciAnc210cHM6Jy4gVXNlIHF1ZXJ5IGFyZ3VtZW50cyBmb3IgYWRkaXRpb25hbCBjb25maWd1cmF0aW9uIHZhbHVlcy5cXG5cXG4qKkV4YW1wbGUqKlxcblxcbmBgYGphdmFzY3JpcHRcXG52YXIgdHJhbnNwb3J0ZXIgPSBub2RlbWFpbGVyLmNyZWF0ZVRyYW5zcG9ydChzbXRwVHJhbnNwb3J0KHtcXG4gICAgaG9zdDogJ2xvY2FsaG9zdCcsXFxuICAgIHBvcnQ6IDI1LFxcbiAgICBhdXRoOiB7XFxuICAgICAgICB1c2VyOiAndXNlcm5hbWUnLFxcbiAgICAgICAgcGFzczogJ3Bhc3N3b3JkJ1xcbiAgICB9XFxufSkpO1xcbmBgYFxcblxcbk9yIHdpdGggY29ubmVjdGlvbiB1cmwgKGdtYWlsKVxcblxcbmBgYGphdmFzY3JpcHRcXG52YXIgdHJhbnNwb3J0ZXIgPSBub2RlbWFpbGVyLmNyZWF0ZVRyYW5zcG9ydChcXG4gICAgc210cFRyYW5zcG9ydCgnc210cHM6Ly91c2VybmFtZSU0MGdtYWlsLmNvbTpwYXNzd29yZEBzbXRwLmdtYWlsLmNvbScpXFxuKTtcXG5gYGBcXG5cXG4jIyBBdXRoZW50aWNhdGlvblxcblxcbklmIGF1dGhlbnRpY2F0aW9uIGRhdGEgaXMgbm90IHByZXNlbnQsIHRoZSBjb25uZWN0aW9uIGlzIGNvbnNpZGVyZWQgYXV0aGVudGljYXRlZCBmcm9tIHRoZSBzdGFydC5cXG5cXG5TZXQgYXV0aGVudGNhdGlvbiBkYXRhIHdpdGggYG9wdGlvbnMuYXV0aGBcXG5cXG5XaGVyZVxcblxcbiAgKiAqKmF1dGgqKiBpcyB0aGUgYXV0aGVudGljYXRpb24gb2JqZWN0XFxuICAgICogKiphdXRoLnVzZXIqKiBpcyB0aGUgdXNlcm5hbWVcXG4gICAgKiAqKmF1dGgucGFzcyoqIGlzIHRoZSBwYXNzd29yZCBmb3IgdGhlIHVzZXJcXG4gICAgKiAqKmF1dGgueG9hdXRoMioqIGlzIHRoZSBPQXV0aDIgYWNjZXNzIHRva2VuIChwcmVmZXJyZWQgaWYgYm90aCBgcGFzc2AgYW5kIGB4b2F1dGgyYCB2YWx1ZXMgYXJlIHNldCkgb3IgYW4gW1hPQXV0aDJdKGh0dHBzOi8vZ2l0aHViLmNvbS9hbmRyaXM5L3hvYXV0aDIpIHRva2VuIGdlbmVyYXRvciBvYmplY3QuXFxuXFxuSWYgYSBbWE9BdXRoMl0oaHR0cHM6Ly9naXRodWIuY29tL2FuZHJpczkveG9hdXRoMikgdG9rZW4gZ2VuZXJhdG9yIGlzIHVzZWQgYXMgdGhlIHZhbHVlIGZvciBgYXV0aC54b2F1dGgyYCB0aGVuIHlvdSBkbyBub3QgbmVlZCB0byBzZXQgdGhlIHZhbHVlIGZvciBgYXV0aC51c2VyYC4gWE9BdXRoMiBnZW5lcmF0b3IgZ2VuZXJhdGVzIHJlcXVpcmVkIGBhY2Nlc3NUb2tlbmAgaXRzZWxmIGlmIGl0IGlzIG1pc3Npbmcgb3IgZXhwaXJlZC4gSW4gdGhpcyBjYXNlIGlmIHRoZSBhdXRoZW50aWNhdGlvbiBmYWlscywgYSBuZXcgdG9rZW4gaXMgcmVxdWVzdGVkIGFuZCB0aGUgYXV0aGVudGljYXRpb24gaXMgcmV0cmllZCBvbmNlLiBJZiBpdCBzdGlsbCBmYWlscywgYW4gZXJyb3IgaXMgcmV0dXJuZWQuXFxuXFxuSW5zdGFsbCB4b2F1dGgyIG1vZHVsZSB0byB1c2UgWE9hdXRoMiB0b2tlbiBnZW5lcmF0b3JzIChub3QgaW5jbHVkZWQgYnkgZGVmYXVsdClcXG5cXG4gICAgbnBtIGluc3RhbGwgeG9hdXRoMiAtLXNhdmVcXG5cXG4qKlhPQXV0aDIgRXhhbXBsZSoqXFxuXFxuPiAqKk5CISoqIFRoZSBjb3JyZWN0IE9BdXRoMiBzY29wZSBmb3IgR21haWwgaXMgYGh0dHBzOi8vbWFpbC5nb29nbGUuY29tL2BcXG5cXG5gYGBqYXZhc2NyaXB0XFxudmFyIG5vZGVtYWlsZXIgPSByZXF1aXJlKCdub2RlbWFpbGVyJyk7XFxudmFyIGdlbmVyYXRvciA9IHJlcXVpcmUoJ3hvYXV0aDInKS5jcmVhdGVYT0F1dGgyR2VuZXJhdG9yKHtcXG4gICAgdXNlcjogJ3t1c2VybmFtZX0nLFxcbiAgICBjbGllbnRJZDogJ3tDbGllbnQgSUR9JyxcXG4gICAgY2xpZW50U2VjcmV0OiAne0NsaWVudCBTZWNyZXR9JyxcXG4gICAgcmVmcmVzaFRva2VuOiAne3JlZnJlc2gtdG9rZW59JyxcXG4gICAgYWNjZXNzVG9rZW46ICd7Y2FjaGVkIGFjY2VzcyB0b2tlbn0nIC8vIG9wdGlvbmFsXFxufSk7XFxuXFxuLy8gbGlzdGVuIGZvciB0b2tlbiB1cGRhdGVzXFxuLy8geW91IHByb2JhYmx5IHdhbnQgdG8gc3RvcmUgdGhlc2UgdG8gYSBkYlxcbmdlbmVyYXRvci5vbigndG9rZW4nLCBmdW5jdGlvbih0b2tlbil7XFxuICAgIGNvbnNvbGUubG9nKCdOZXcgdG9rZW4gZm9yICVzOiAlcycsIHRva2VuLnVzZXIsIHRva2VuLmFjY2Vzc1Rva2VuKTtcXG59KTtcXG5cXG4vLyBsb2dpblxcbnZhciB0cmFuc3BvcnRlciA9IG5vZGVtYWlsZXIuY3JlYXRlVHJhbnNwb3J0KCh7XFxuICAgIHNlcnZpY2U6ICdnbWFpbCcsXFxuICAgIGF1dGg6IHtcXG4gICAgICAgIHhvYXV0aDI6IGdlbmVyYXRvclxcbiAgICB9XFxufSkpO1xcblxcbi8vIHNlbmQgbWFpbFxcbnRyYW5zcG9ydGVyLnNlbmRNYWlsKHtcXG4gICAgZnJvbTogJ3NlbmRlckBleGFtcGxlLmNvbScsXFxuICAgIHRvOiAncmVjZWl2ZXJAZXhhbXBsZS5jb20nLFxcbiAgICBzdWJqZWN0OiAnaGVsbG8gd29ybGQhJyxcXG4gICAgdGV4dDogJ0F1dGhlbnRpY2F0ZWQgd2l0aCBPQXV0aDInXFxufSwgZnVuY3Rpb24oZXJyb3IsIHJlc3BvbnNlKSB7XFxuICAgaWYgKGVycm9yKSB7XFxuICAgICAgICBjb25zb2xlLmxvZyhlcnJvcik7XFxuICAgfSBlbHNlIHtcXG4gICAgICAgIGNvbnNvbGUubG9nKCdNZXNzYWdlIHNlbnQnKTtcXG4gICB9XFxufSk7XFxuYGBgXFxuXFxuIyMgVXNpbmcgd2VsbC1rbm93biBzZXJ2aWNlc1xcblxcbklmIHlvdSBkbyBub3Qgd2FudCB0byBzcGVjaWZ5IHRoZSBob3N0bmFtZSwgcG9ydCBhbmQgc2VjdXJpdHkgc2V0dGluZ3MgZm9yIGEgd2VsbCBrbm93biBzZXJ2aWNlLCB5b3UgY2FuIHVzZSBpdCBieSBpdHMgbmFtZSAoY2FzZSBpbnNlbnNpdGl2ZSlcXG5cXG5gYGBqYXZhc2NyaXB0XFxuc210cFRyYW5zcG9ydCh7XFxuICAgIHNlcnZpY2U6ICdnbWFpbCcsXFxuICAgIGF1dGg6IC4uXFxufSk7XFxuYGBgXFxuXFxuU2VlIHRoZSBsaXN0IG9mIGFsbCBzdXBwb3J0ZWQgc2VydmljZXMgW2hlcmVdKGh0dHBzOi8vZ2l0aHViLmNvbS9hbmRyaXM5L25vZGVtYWlsZXItd2VsbGtub3duI3N1cHBvcnRlZC1zZXJ2aWNlcykuXFxuXFxuIyMgVmVyaWZ5IGNvbm5lY3Rpb24gY29uZmlndXJhdGlvblxcblxcbllvdSBjYW4gdmVyaWZ5IHlvdXIgY29uZmlndXJhdGlvbiB3aXRoIGB2ZXJpZnkoY2FsbGJhY2spYCBjYWxsLiBJZiBpdCByZXR1cm5zIGFuIGVycm9yLCB0aGVuIHNvbWV0aGluZyBpcyBub3QgY29ycmVjdCwgb3RoZXJ3aXNlIHRoZSBzZXJ2ZXIgaXMgcmVhZHkgdG8gYWNjZXB0IG1lc3NhZ2VzLlxcblxcbmBgYGphdmFzY3JpcHRcXG4vLyB2ZXJpZnkgY29ubmVjdGlvbiBjb25maWd1cmF0aW9uXFxudHJhbnNwb3J0ZXIudmVyaWZ5KGZ1bmN0aW9uKGVycm9yLCBzdWNjZXNzKSB7XFxuICAgaWYgKGVycm9yKSB7XFxuICAgICAgICBjb25zb2xlLmxvZyhlcnJvcik7XFxuICAgfSBlbHNlIHtcXG4gICAgICAgIGNvbnNvbGUubG9nKCdTZXJ2ZXIgaXMgcmVhZHkgdG8gdGFrZSBvdXIgbWVzc2FnZXMnKTtcXG4gICB9XFxufSk7XFxuYGBgXFxuXFxuIyMgTGljZW5zZVxcblxcbioqTUlUKipcXG5cIixcbiAgXCJyZWFkbWVGaWxlbmFtZVwiOiBcIlJFQURNRS5tZFwiLFxuICBcInJlcG9zaXRvcnlcIjoge1xuICAgIFwidHlwZVwiOiBcImdpdFwiLFxuICAgIFwidXJsXCI6IFwiZ2l0Oi8vZ2l0aHViLmNvbS9hbmRyaXM5L25vZGVtYWlsZXItc210cC10cmFuc3BvcnQuZ2l0XCJcbiAgfSxcbiAgXCJzY3JpcHRzXCI6IHtcbiAgICBcInRlc3RcIjogXCJncnVudFwiXG4gIH0sXG4gIFwidmVyc2lvblwiOiBcIjIuNS4wXCJcbn1cbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIHNlcnZpY2VzID0gcmVxdWlyZSgnLi9zZXJ2aWNlcy5qc29uJyk7XG52YXIgbm9ybWFsaXplZCA9IHt9O1xuXG5PYmplY3Qua2V5cyhzZXJ2aWNlcykuZm9yRWFjaChmdW5jdGlvbihrZXkpIHtcbiAgICB2YXIgc2VydmljZSA9IHNlcnZpY2VzW2tleV07XG5cbiAgICBub3JtYWxpemVkW25vcm1hbGl6ZUtleShrZXkpXSA9IG5vcm1hbGl6ZVNlcnZpY2Uoc2VydmljZSk7XG5cbiAgICBbXS5jb25jYXQoc2VydmljZS5hbGlhc2VzIHx8IFtdKS5mb3JFYWNoKGZ1bmN0aW9uKGFsaWFzKSB7XG4gICAgICAgIG5vcm1hbGl6ZWRbbm9ybWFsaXplS2V5KGFsaWFzKV0gPSBub3JtYWxpemVTZXJ2aWNlKHNlcnZpY2UpO1xuICAgIH0pO1xuXG4gICAgW10uY29uY2F0KHNlcnZpY2UuZG9tYWlucyB8fCBbXSkuZm9yRWFjaChmdW5jdGlvbihkb21haW4pIHtcbiAgICAgICAgbm9ybWFsaXplZFtub3JtYWxpemVLZXkoZG9tYWluKV0gPSBub3JtYWxpemVTZXJ2aWNlKHNlcnZpY2UpO1xuICAgIH0pO1xufSk7XG5cbmZ1bmN0aW9uIG5vcm1hbGl6ZUtleShrZXkpIHtcbiAgICByZXR1cm4ga2V5LnJlcGxhY2UoL1teYS16QS1aMC05LlxcLV0vZywgJycpLnRvTG93ZXJDYXNlKCk7XG59XG5cbmZ1bmN0aW9uIG5vcm1hbGl6ZVNlcnZpY2Uoc2VydmljZSkge1xuICAgIHZhciBmaWx0ZXIgPSBbJ2RvbWFpbnMnLCAnYWxpYXNlcyddO1xuICAgIHZhciByZXNwb25zZSA9IHt9O1xuXG4gICAgT2JqZWN0LmtleXMoc2VydmljZSkuZm9yRWFjaChmdW5jdGlvbihrZXkpIHtcbiAgICAgICAgaWYgKGZpbHRlci5pbmRleE9mKGtleSkgPCAwKSB7XG4gICAgICAgICAgICByZXNwb25zZVtrZXldID0gc2VydmljZVtrZXldO1xuICAgICAgICB9XG4gICAgfSk7XG5cbiAgICByZXR1cm4gcmVzcG9uc2U7XG59XG5cbi8qKlxuICogUmVzb2x2ZXMgU01UUCBjb25maWcgZm9yIGdpdmVuIGtleS4gS2V5IGNhbiBiZSBhIG5hbWUgKGxpa2UgJ0dtYWlsJyksIGFsaWFzIChsaWtlICdHb29nbGUgTWFpbCcpIG9yXG4gKiBhbiBlbWFpbCBhZGRyZXNzIChsaWtlICd0ZXN0QGdvb2dsZW1haWwuY29tJykuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IGtleSBbZGVzY3JpcHRpb25dXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBTTVRQIGNvbmZpZyBvciBmYWxzZSBpZiBub3QgZm91bmRcbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihrZXkpIHtcbiAgICBrZXkgPSBub3JtYWxpemVLZXkoa2V5LnNwbGl0KCdAJykucG9wKCkpO1xuICAgIHJldHVybiBub3JtYWxpemVkW2tleV0gfHwgZmFsc2U7XG59OyIsIm1vZHVsZS5leHBvcnRzPXtcbiAgICBcIjF1bmQxXCI6IHtcbiAgICAgICAgXCJob3N0XCI6IFwic210cC4xdW5kMS5kZVwiLFxuICAgICAgICBcInBvcnRcIjogNDY1LFxuICAgICAgICBcInNlY3VyZVwiOiB0cnVlLFxuICAgICAgICBcImF1dGhNZXRob2RcIjogXCJMT0dJTlwiXG4gICAgfSxcblxuICAgIFwiQU9MXCI6IHtcbiAgICAgICAgXCJkb21haW5zXCI6IFtcbiAgICAgICAgICAgIFwiYW9sLmNvbVwiXG4gICAgICAgIF0sXG4gICAgICAgIFwiaG9zdFwiOiBcInNtdHAuYW9sLmNvbVwiLFxuICAgICAgICBcInBvcnRcIjogNTg3XG4gICAgfSxcblxuICAgIFwiRGVidWdNYWlsXCI6IHtcbiAgICAgICAgXCJob3N0XCI6IFwiZGVidWdtYWlsLmlvXCIsXG4gICAgICAgIFwicG9ydFwiOiAyNVxuICAgIH0sXG5cbiAgICBcIkR5bmVjdEVtYWlsXCI6IHtcbiAgICAgICAgXCJhbGlhc2VzXCI6IFtcIkR5bmVjdFwiXSxcbiAgICAgICAgXCJob3N0XCI6IFwic210cC5keW5lY3QubmV0XCIsXG4gICAgICAgIFwicG9ydFwiOiAyNVxuICAgIH0sXG5cbiAgICBcIkZhc3RNYWlsXCI6IHtcbiAgICAgICAgXCJkb21haW5zXCI6IFtcbiAgICAgICAgICAgIFwiZmFzdG1haWwuZm1cIlxuICAgICAgICBdLFxuICAgICAgICBcImhvc3RcIjogXCJtYWlsLm1lc3NhZ2luZ2VuZ2luZS5jb21cIixcbiAgICAgICAgXCJwb3J0XCI6IDQ2NSxcbiAgICAgICAgXCJzZWN1cmVcIjogdHJ1ZVxuICAgIH0sXG5cbiAgICBcIkdhbmRpTWFpbFwiOiB7XG4gICAgICAgIFwiYWxpYXNlc1wiOiBbXG4gICAgICAgICAgICBcIkdhbmRpXCIsXG4gICAgICAgICAgICBcIkdhbmRpIE1haWxcIlxuICAgICAgICBdLFxuICAgICAgICBcImhvc3RcIjogXCJtYWlsLmdhbmRpLm5ldFwiLFxuICAgICAgICBcInBvcnRcIjogNTg3XG4gICAgfSxcblxuICAgIFwiR21haWxcIjoge1xuICAgICAgICBcImFsaWFzZXNcIjogW1xuICAgICAgICAgICAgXCJHb29nbGUgTWFpbFwiXG4gICAgICAgIF0sXG4gICAgICAgIFwiZG9tYWluc1wiOiBbXG4gICAgICAgICAgICBcImdtYWlsLmNvbVwiLFxuICAgICAgICAgICAgXCJnb29nbGVtYWlsLmNvbVwiXG4gICAgICAgIF0sXG4gICAgICAgIFwiaG9zdFwiOiBcInNtdHAuZ21haWwuY29tXCIsXG4gICAgICAgIFwicG9ydFwiOiA0NjUsXG4gICAgICAgIFwic2VjdXJlXCI6IHRydWVcbiAgICB9LFxuXG4gICAgXCJHb2RhZGR5XCI6IHtcbiAgICAgICAgXCJob3N0XCI6IFwic210cG91dC5zZWN1cmVzZXJ2ZXIubmV0XCIsXG4gICAgICAgIFwicG9ydFwiOiAyNVxuICAgIH0sXG5cbiAgICBcIkdvZGFkZHlBc2lhXCI6IHtcbiAgICAgICAgXCJob3N0XCI6IFwic210cC5hc2lhLnNlY3VyZXNlcnZlci5uZXRcIixcbiAgICAgICAgXCJwb3J0XCI6IDI1XG4gICAgfSxcblxuICAgIFwiR29kYWRkeUV1cm9wZVwiOiB7XG4gICAgICAgIFwiaG9zdFwiOiBcInNtdHAuZXVyb3BlLnNlY3VyZXNlcnZlci5uZXRcIixcbiAgICAgICAgXCJwb3J0XCI6IDI1XG4gICAgfSxcblxuICAgIFwiaG90LmVlXCI6IHtcbiAgICAgICAgXCJob3N0XCI6IFwibWFpbC5ob3QuZWVcIlxuICAgIH0sXG5cbiAgICBcIkhvdG1haWxcIjoge1xuICAgICAgICBcImFsaWFzZXNcIjogW1xuICAgICAgICAgICAgXCJPdXRsb29rXCIsXG4gICAgICAgICAgICBcIk91dGxvb2suY29tXCIsXG4gICAgICAgICAgICBcIkhvdG1haWwuY29tXCJcbiAgICAgICAgXSxcbiAgICAgICAgXCJkb21haW5zXCI6IFtcbiAgICAgICAgICAgIFwiaG90bWFpbC5jb21cIixcbiAgICAgICAgICAgIFwib3V0bG9vay5jb21cIlxuICAgICAgICBdLFxuICAgICAgICBcImhvc3RcIjogXCJzbXRwLmxpdmUuY29tXCIsXG4gICAgICAgIFwicG9ydFwiOiA1ODcsXG4gICAgICAgIFwidGxzXCI6IHtcbiAgICAgICAgICAgIFwiY2lwaGVyc1wiOiBcIlNTTHYzXCJcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBcImlDbG91ZFwiOiB7XG4gICAgICAgIFwiYWxpYXNlc1wiOiBbXCJNZVwiLCBcIk1hY1wiXSxcbiAgICAgICAgXCJkb21haW5zXCI6IFtcbiAgICAgICAgICAgIFwibWUuY29tXCIsXG4gICAgICAgICAgICBcIm1hYy5jb21cIlxuICAgICAgICBdLFxuICAgICAgICBcImhvc3RcIjogXCJzbXRwLm1haWwubWUuY29tXCIsXG4gICAgICAgIFwicG9ydFwiOiA1ODdcbiAgICB9LFxuXG4gICAgXCJtYWlsLmVlXCI6IHtcbiAgICAgICAgXCJob3N0XCI6IFwic210cC5tYWlsLmVlXCJcbiAgICB9LFxuXG4gICAgXCJNYWlsLnJ1XCI6IHtcbiAgICAgICAgXCJob3N0XCI6IFwic210cC5tYWlsLnJ1XCIsXG4gICAgICAgIFwicG9ydFwiOiA0NjUsXG4gICAgICAgIFwic2VjdXJlXCI6IHRydWVcbiAgICB9LFxuXG4gICAgXCJNYWlsZGV2XCI6IHtcbiAgICAgICAgXCJwb3J0XCI6IDEwMjUsXG4gICAgICAgIFwiaWdub3JlVExTXCI6IHRydWVcbiAgICB9LFxuXG4gICAgXCJNYWlsZ3VuXCI6IHtcbiAgICAgICAgXCJob3N0XCI6IFwic210cC5tYWlsZ3VuLm9yZ1wiLFxuICAgICAgICBcInBvcnRcIjogNTg3XG4gICAgfSxcblxuICAgIFwiTWFpbGpldFwiOiB7XG4gICAgICAgIFwiaG9zdFwiOiBcImluLm1haWxqZXQuY29tXCIsXG4gICAgICAgIFwicG9ydFwiOiA1ODdcbiAgICB9LFxuXG4gICAgXCJNYW5kcmlsbFwiOiB7XG4gICAgICAgIFwiaG9zdFwiOiBcInNtdHAubWFuZHJpbGxhcHAuY29tXCIsXG4gICAgICAgIFwicG9ydFwiOiA1ODdcbiAgICB9LFxuXG4gICAgXCJOYXZlclwiOiB7XG4gICAgICAgIFwiaG9zdFwiOiBcInNtdHAubmF2ZXIuY29tXCIsXG4gICAgICAgIFwicG9ydFwiOiA1ODdcbiAgICB9LFxuXG4gICAgXCJPcGVuTWFpbEJveFwiOiB7XG4gICAgICAgIFwiYWxpYXNlc1wiOiBbXG4gICAgICAgICAgICBcIk9NQlwiLFxuICAgICAgICAgICAgXCJvcGVubWFpbGJveC5vcmdcIlxuICAgICAgICBdLFxuICAgICAgICBcImhvc3RcIjogXCJzbXRwLm9wZW5tYWlsYm94Lm9yZ1wiLFxuICAgICAgICBcInBvcnRcIjogNDY1LFxuICAgICAgICBcInNlY3VyZVwiOiB0cnVlXG4gICAgfSxcblxuICAgIFwiUG9zdG1hcmtcIjoge1xuICAgICAgICBcImFsaWFzZXNcIjogW1wiUG9zdG1hcmtBcHBcIl0sXG4gICAgICAgIFwiaG9zdFwiOiBcInNtdHAucG9zdG1hcmthcHAuY29tXCIsXG4gICAgICAgIFwicG9ydFwiOiAyNTI1XG4gICAgfSxcblxuICAgIFwiUVFcIjoge1xuICAgICAgICBcImRvbWFpbnNcIjogW1xuICAgICAgICAgICAgXCJxcS5jb21cIlxuICAgICAgICBdLFxuICAgICAgICBcImhvc3RcIjogXCJzbXRwLnFxLmNvbVwiLFxuICAgICAgICBcInBvcnRcIjogNDY1LFxuICAgICAgICBcInNlY3VyZVwiOiB0cnVlXG4gICAgfSxcblxuICAgIFwiUVFleFwiOiB7XG4gICAgICAgIFwiYWxpYXNlc1wiOiBbXCJRUSBFbnRlcnByaXNlXCJdLFxuICAgICAgICBcImRvbWFpbnNcIjogW1xuICAgICAgICAgICAgXCJleG1haWwucXEuY29tXCJcbiAgICAgICAgXSxcbiAgICAgICAgXCJob3N0XCI6IFwic210cC5leG1haWwucXEuY29tXCIsXG4gICAgICAgIFwicG9ydFwiOiA0NjUsXG4gICAgICAgIFwic2VjdXJlXCI6IHRydWVcbiAgICB9LFxuXG4gICAgXCJTZW5kQ2xvdWRcIjoge1xuICAgICAgICBcImhvc3RcIjogXCJzbXRwY2xvdWQuc29odS5jb21cIixcbiAgICAgICAgXCJwb3J0XCI6IDI1XG4gICAgfSxcblxuICAgIFwiU2VuZEdyaWRcIjoge1xuICAgICAgICBcImhvc3RcIjogXCJzbXRwLnNlbmRncmlkLm5ldFwiLFxuICAgICAgICBcInBvcnRcIjogNTg3XG4gICAgfSxcblxuICAgIFwiU0VTXCI6IHtcbiAgICAgICAgXCJob3N0XCI6IFwiZW1haWwtc210cC51cy1lYXN0LTEuYW1hem9uYXdzLmNvbVwiLFxuICAgICAgICBcInBvcnRcIjogNDY1LFxuICAgICAgICBcInNlY3VyZVwiOiB0cnVlXG4gICAgfSxcbiAgICBcIlNFUy1VUy1FQVNULTFcIjoge1xuICAgICAgICBcImhvc3RcIjogXCJlbWFpbC1zbXRwLnVzLWVhc3QtMS5hbWF6b25hd3MuY29tXCIsXG4gICAgICAgIFwicG9ydFwiOiA0NjUsXG4gICAgICAgIFwic2VjdXJlXCI6IHRydWVcbiAgICB9LFxuICAgIFwiU0VTLVVTLVdFU1QtMVwiOiB7XG4gICAgICAgIFwiaG9zdFwiOiBcImVtYWlsLXNtdHAudXMtd2VzdC0xLmFtYXpvbmF3cy5jb21cIixcbiAgICAgICAgXCJwb3J0XCI6IDQ2NSxcbiAgICAgICAgXCJzZWN1cmVcIjogdHJ1ZVxuICAgIH0sXG4gICAgXCJTRVMtRVUtV0VTVC0xXCI6IHtcbiAgICAgICAgXCJob3N0XCI6IFwiZW1haWwtc210cC5ldS13ZXN0LTEuYW1hem9uYXdzLmNvbVwiLFxuICAgICAgICBcInBvcnRcIjogNDY1LFxuICAgICAgICBcInNlY3VyZVwiOiB0cnVlXG4gICAgfSxcbiAgICBcblxuICAgIFwiU3Bhcmtwb3N0XCI6IHtcbiAgICAgICAgXCJhbGlhc2VzXCI6IFtcbiAgICAgICAgICAgIFwiU3BhcmtQb3N0XCIsXG4gICAgICAgICAgICBcIlNwYXJrUG9zdCBNYWlsXCJcbiAgICAgICAgXSxcbiAgICAgICAgXCJkb21haW5zXCI6IFtcbiAgICAgICAgICAgIFwic3Bhcmtwb3N0LmNvbVwiXG4gICAgICAgIF0sXG4gICAgICAgIFwiaG9zdFwiOiBcInNtdHAuc3Bhcmtwb3N0bWFpbC5jb21cIixcbiAgICAgICAgXCJwb3J0XCI6IDU4NyxcbiAgICAgICAgXCJzZWN1cmVcIjogZmFsc2VcbiAgICB9LFxuXG4gICAgXCJZYWhvb1wiOiB7XG4gICAgICAgIFwiZG9tYWluc1wiOiBbXG4gICAgICAgICAgICBcInlhaG9vLmNvbVwiXG4gICAgICAgIF0sXG4gICAgICAgIFwiaG9zdFwiOiBcInNtdHAubWFpbC55YWhvby5jb21cIixcbiAgICAgICAgXCJwb3J0XCI6IDQ2NSxcbiAgICAgICAgXCJzZWN1cmVcIjogdHJ1ZVxuICAgIH0sXG5cbiAgICBcIllhbmRleFwiOiB7XG4gICAgICAgIFwiZG9tYWluc1wiOiBbXG4gICAgICAgICAgICBcInlhbmRleC5ydVwiXG4gICAgICAgIF0sXG4gICAgICAgIFwiaG9zdFwiOiBcInNtdHAueWFuZGV4LnJ1XCIsXG4gICAgICAgIFwicG9ydFwiOiA0NjUsXG4gICAgICAgIFwic2VjdXJlXCI6IHRydWVcbiAgICB9LFxuXG4gICAgXCJab2hvXCI6IHtcbiAgICAgICAgXCJob3N0XCI6IFwic210cC56b2hvLmNvbVwiLFxuICAgICAgICBcInBvcnRcIjogNDY1LFxuICAgICAgICBcInNlY3VyZVwiOiB0cnVlLFxuICAgICAgICBcImF1dGhNZXRob2RcIjogXCJMT0dJTlwiXG4gICAgfSxcbiAgICBcIjEyNlwiOiB7XG4gICAgICAgIFwiaG9zdFwiOiBcInNtdHAuMTI2LmNvbVwiLFxuICAgICAgICBcInBvcnRcIjogNDY1LFxuICAgICAgICBcInNlY3VyZVwiOiB0cnVlXG4gICAgfSxcbiAgICBcIjE2M1wiOiB7XG4gICAgICAgIFwiaG9zdFwiOiBcInNtdHAuMTYzLmNvbVwiLFxuICAgICAgICBcInBvcnRcIjogNDY1LFxuICAgICAgICBcInNlY3VyZVwiOiB0cnVlXG4gICAgfVxuXG59XG4iLCIoZnVuY3Rpb24gKEJ1ZmZlcil7XG52YXIgU21hcnRCdWZmZXIgPSAoZnVuY3Rpb24gKCkge1xuXG4gICAgLyoqXG4gICAgICogQ29uc3RydWN0b3IgZm9yIFNtYXJ0QnVmZmVyLlxuICAgICAqIEBwYXJhbSBhcmcxIHtCdWZmZXIgfHwgTnVtYmVyIHx8IFN0cmluZ30gQnVmZmVyIHRvIHJlYWQgZnJvbSwgb3IgZXhwZWN0ZWQgc2l6ZSB0byB3cml0ZSB0bywgb3IgZW5jb2RpbmcgdG8gdXNlLlxuICAgICAqIEBwYXJhbSBhcmcyIHtTdHJpbmd9IEVuY29kaW5nIHRvIHVzZSBmb3Igd3JpdGluZyBhbmQgcmVhZGluZyBzdHJpbmdzLiBEZWZhdWx0cyB0byB1dGY4LiBJZiBlbmNvZGluZyBpcyBnaXZlbiBpbiBhcmcxLCB0aGlzIGlzIGlnbm9yZWQuXG4gICAgICogQGNvbnN0cnVjdG9yXG4gICAgICpcbiAgICAgKiBUaGVyZSBhcmUgYSBmZXcgd2F5cyB0byBjb25zdHJ1Y3QgYSBTbWFydEJ1ZmZlcjpcbiAgICAgKlxuICAgICAqIFNtYXJ0QnVmZmVyKCkgLSBEZWZhdWx0cyB0byB1dGY4LCA0MDk2IHByZS1zZXQgaW50ZXJuYWwgQnVmZmVyIGxlbmd0aC5cbiAgICAgKiBTbWFydEJ1ZmZlcihzaXplKSAtIERlZmF1bHRzIHRvIHV0ZjgsIHNldHMgaW50ZXJuYWwgQnVmZmVyIGxlbmd0aCB0byB0aGUgc2l6ZSBnaXZlbi5cbiAgICAgKiBTbWFydEJ1ZmZlcihlbmNvZGluZykgLSBTZXRzIHRoZSBnaXZlbiBlbmNvZGluZywgZGVmYXVsdHMgdG8gNDA5NiBwcmUtc2V0IGludGVybmFsIEJ1ZmZlciBsZW5ndGguXG4gICAgICogU21hcnRCdWZmZXIoQnVmZmVyKSAtIERlZmF1bHRzIHRvIHV0ZjgsIHNldHMgdGhlIGludGVybmFsIEJ1ZmZlciB0byB0aGUgZ2l2ZW4gYnVmZmVyIChzYW1lIG1lbW9yeSkuXG4gICAgICogU21hcnRCdWZmZXIoQnVmZmVyLCBlbmNvZGluZykgLSBTZXRzIHRoZSBnaXZlbiBlbmNvZGluZywgc2V0cyB0aGUgaW50ZXJuYWwgQnVmZmVyIHRvIHRoZSBnaXZlbiBidWZmZXIgKHNhbWUgbWVtb3J5KS5cbiAgICAgKlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIFNtYXJ0QnVmZmVyKGFyZzEsIGFyZzIpIHtcbiAgICAgICAgdmFyIHR5cGU7XG4gICAgICAgIHN3aXRjaCAodHlwZSA9IHR5cGVvZiBhcmcxKSB7XG4gICAgICAgICAgICBjYXNlICdudW1iZXInOlxuICAgICAgICAgICAgICAgIGlmIChpc0Zpbml0ZShhcmcxKSAmJiBhcmcxID4gMCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmJ1ZmYgPSBuZXcgQnVmZmVyKE1hdGguY2VpbChhcmcxKSk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMubGVuZ3RoID0gMDtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1doZW4gc3BlY2lmeWluZyBhIHNpemUsIGl0IG11c3QgYmUgYSB2YWxpZCBudW1iZXIgYWJvdmUgemVyby4nKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgIGNhc2UgJ3N0cmluZyc6XG4gICAgICAgICAgICAgICAgaWYgKEJ1ZmZlci5pc0VuY29kaW5nKGFyZzEpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYnVmZiA9IG5ldyBCdWZmZXIoNDA5Nik7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMubGVuZ3RoID0gMDtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5lbmNvZGluZyA9IGFyZzE7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIEVuY29kaW5nJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICBjYXNlICdvYmplY3QnOlxuICAgICAgICAgICAgICAgIGlmIChCdWZmZXIuaXNCdWZmZXIoYXJnMSkpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5idWZmID0gYXJnMTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5sZW5ndGggPSBhcmcxLmxlbmd0aDtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdGaXJzdCBhcmd1bWVudCBtdXN0IGJlIGEgQnVmZmVyLCBOdW1iZXIgcmVwcmVzZW50aW5nIHRoZSBzaXplLCBvciBhIFN0cmluZyByZXByZXNlbnRpbmcgdGhlIGVuY29kaW5nLicpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICB0aGlzLmJ1ZmYgPSBuZXcgQnVmZmVyKDQwOTYpO1xuICAgICAgICAgICAgICAgIHRoaXMubGVuZ3RoID0gMDtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2YgdGhpcy5lbmNvZGluZyA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgYXJnMiA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICBpZiAoQnVmZmVyLmlzRW5jb2RpbmcoYXJnMikpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5lbmNvZGluZyA9IGFyZzI7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIEVuY29kaW5nJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5fcmVhZE9mZnNldCA9IDA7XG4gICAgICAgIHRoaXMuX3dyaXRlT2Zmc2V0ID0gMDtcbiAgICB9XG5cblxuICAgIFNtYXJ0QnVmZmVyLnByb3RvdHlwZS5fZW5zdXJlV3JpdGFibGUgPSBmdW5jdGlvbiAobGVuLCBvZmZzZXQpIHtcbiAgICAgICAgdGhpcy5fZW5zdXJlQ2FwYWNpdHkodGhpcy5sZW5ndGggKyBsZW4gKyAob2Zmc2V0IHx8IDApKTtcblxuICAgICAgICBpZiAodHlwZW9mIG9mZnNldCA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgIHRoaXMuYnVmZi5jb3B5KHRoaXMuYnVmZiwgb2Zmc2V0ICsgbGVuLCBvZmZzZXQsIHRoaXMuYnVmZi5sZW5ndGgpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMubGVuZ3RoID0gTWF0aC5tYXgodGhpcy5sZW5ndGggKyBsZW4sIChvZmZzZXQgfHwgMCkgKyBsZW4pO1xuICAgIH07XG5cbiAgICBTbWFydEJ1ZmZlci5wcm90b3R5cGUuX2Vuc3VyZUNhcGFjaXR5ID0gZnVuY3Rpb24gKG1pbmxlbikge1xuICAgICAgICB2YXIgb2xkbGVuID0gdGhpcy5idWZmLmxlbmd0aDtcblxuICAgICAgICBpZiAobWlubGVuID4gb2xkbGVuKSB7XG4gICAgICAgICAgICB2YXIgZGF0YSA9IHRoaXMuYnVmZjtcbiAgICAgICAgICAgIHZhciBuZXdsZW4gPSAob2xkbGVuICogMykgLyAyICsgMTtcbiAgICAgICAgICAgIGlmIChuZXdsZW4gPCBtaW5sZW4pXG4gICAgICAgICAgICAgICAgbmV3bGVuID0gbWlubGVuO1xuICAgICAgICAgICAgdGhpcy5idWZmID0gbmV3IEJ1ZmZlcihuZXdsZW4pO1xuICAgICAgICAgICAgZGF0YS5jb3B5KHRoaXMuYnVmZiwgMCwgMCwgb2xkbGVuKTtcbiAgICAgICAgfVxuICAgIH07XG5cblxuICAgIHZhciBtYWtlUmVhZGVyID0gZnVuY3Rpb24gKGZ1bmMsIHNpemUpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciByZXQgPSBmdW5jLmNhbGwodGhpcy5idWZmLCB0aGlzLl9yZWFkT2Zmc2V0KTtcbiAgICAgICAgICAgIHRoaXMuX3JlYWRPZmZzZXQgKz0gc2l6ZTtcbiAgICAgICAgICAgIHJldHVybiByZXQ7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgdmFyIG1ha2VXcml0ZXIgPSBmdW5jdGlvbiAoZnVuYywgc2l6ZSkge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKHZhbHVlLCBvZmZzZXQpIHtcbiAgICAgICAgICAgIHRoaXMuX2Vuc3VyZVdyaXRhYmxlKHNpemUsIG9mZnNldCk7XG4gICAgICAgICAgICBmdW5jLmNhbGwodGhpcy5idWZmLCB2YWx1ZSwgdHlwZW9mIG9mZnNldCA9PT0gJ251bWJlcicgPyBvZmZzZXQgOiB0aGlzLl93cml0ZU9mZnNldCk7XG4gICAgICAgICAgICB0aGlzLl93cml0ZU9mZnNldCArPSBzaXplO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cbiAgICB9O1xuXG5cbiAgICAvKlxuICAgICBSZWFkIE9wZXJhdGlvbnNcbiAgICAgKi9cblxuICAgIFNtYXJ0QnVmZmVyLnByb3RvdHlwZS5yZWFkSW50OCA9IG1ha2VSZWFkZXIoQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50OCwgMSk7XG4gICAgU21hcnRCdWZmZXIucHJvdG90eXBlLnJlYWRJbnQxNkJFID0gbWFrZVJlYWRlcihCdWZmZXIucHJvdG90eXBlLnJlYWRJbnQxNkJFLCAyKTtcbiAgICBTbWFydEJ1ZmZlci5wcm90b3R5cGUucmVhZEludDE2TEUgPSBtYWtlUmVhZGVyKEJ1ZmZlci5wcm90b3R5cGUucmVhZEludDE2TEUsIDIpO1xuICAgIFNtYXJ0QnVmZmVyLnByb3RvdHlwZS5yZWFkSW50MzJCRSA9IG1ha2VSZWFkZXIoQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50MzJCRSwgNCk7XG4gICAgU21hcnRCdWZmZXIucHJvdG90eXBlLnJlYWRJbnQzMkxFID0gbWFrZVJlYWRlcihCdWZmZXIucHJvdG90eXBlLnJlYWRJbnQzMkxFLCA0KTtcblxuICAgIFNtYXJ0QnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDggPSBtYWtlUmVhZGVyKEJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQ4LCAxKTtcbiAgICBTbWFydEJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQxNkJFID0gbWFrZVJlYWRlcihCdWZmZXIucHJvdG90eXBlLnJlYWRVSW50MTZCRSwgMik7XG4gICAgU21hcnRCdWZmZXIucHJvdG90eXBlLnJlYWRVSW50MTZMRSA9IG1ha2VSZWFkZXIoQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDE2TEUsIDIpO1xuICAgIFNtYXJ0QnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDMyQkUgPSBtYWtlUmVhZGVyKEJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQzMkJFLCA0KTtcbiAgICBTbWFydEJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQzMkxFID0gbWFrZVJlYWRlcihCdWZmZXIucHJvdG90eXBlLnJlYWRVSW50MzJMRSwgNCk7XG5cbiAgICBTbWFydEJ1ZmZlci5wcm90b3R5cGUucmVhZEZsb2F0QkUgPSBtYWtlUmVhZGVyKEJ1ZmZlci5wcm90b3R5cGUucmVhZEZsb2F0QkUsIDQpO1xuICAgIFNtYXJ0QnVmZmVyLnByb3RvdHlwZS5yZWFkRmxvYXRMRSA9IG1ha2VSZWFkZXIoQnVmZmVyLnByb3RvdHlwZS5yZWFkRmxvYXRMRSwgNCk7XG5cbiAgICBTbWFydEJ1ZmZlci5wcm90b3R5cGUucmVhZERvdWJsZUJFID0gbWFrZVJlYWRlcihCdWZmZXIucHJvdG90eXBlLnJlYWREb3VibGVCRSwgOCk7XG4gICAgU21hcnRCdWZmZXIucHJvdG90eXBlLnJlYWREb3VibGVMRSA9IG1ha2VSZWFkZXIoQnVmZmVyLnByb3RvdHlwZS5yZWFkRG91YmxlTEUsIDgpO1xuXG5cbiAgICAvKipcbiAgICAgKiBSZWFkcyBhIHN0cmluZyBvZiB0aGUgZ2l2ZW4gbGVuZ3RoLlxuICAgICAqIEBwYXJhbSBsZW5ndGgge051bWJlcn0gVGhlIGxlbmd0aCBvZiB0aGUgc3RyaW5nIHRvIHJlYWQuIChEZWZhdWx0cyB0byB0aGUgbGVuZ3RoIG9mIHRoZSByZW1haW5pbmcgZGF0YSlcbiAgICAgKiBAcGFyYW0gZW5jb2Rpbmcge1N0cmluZ30gVGhlIGVuY29kaW5nIHRvIHVzZS4gKERlZmF1bHRzIHRvIGVuY29kaW5nIHNldCBpbiBjb25zdHJ1Y3Rvciwgb3IgdXRmOClcbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSBUaGUgc3RyaW5nLlxuICAgICAqL1xuICAgIFNtYXJ0QnVmZmVyLnByb3RvdHlwZS5yZWFkU3RyaW5nID0gZnVuY3Rpb24gKGxlbmd0aCwgZW5jb2RpbmcpIHtcbiAgICAgICAgdmFyIGxlbiA9IE1hdGgubWluKGxlbmd0aCwgdGhpcy5sZW5ndGggLSB0aGlzLl9yZWFkT2Zmc2V0KSB8fCAodGhpcy5sZW5ndGggLSB0aGlzLl9yZWFkT2Zmc2V0KTtcbiAgICAgICAgdmFyIHJldCA9IHRoaXMuYnVmZi5zbGljZSh0aGlzLl9yZWFkT2Zmc2V0LCB0aGlzLl9yZWFkT2Zmc2V0ICsgbGVuKS50b1N0cmluZyhlbmNvZGluZyB8fCB0aGlzLmVuY29kaW5nKTtcbiAgICAgICAgdGhpcy5fcmVhZE9mZnNldCArPSBsZW47XG4gICAgICAgIHJldHVybiByZXQ7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFJlYWRzIGEgbnVsbCB0ZXJtaW5hdGVkIHN0cmluZyBmcm9tIHRoZSB1bmRlcmx5aW5nIGJ1ZmZlci5cbiAgICAgKiBAcGFyYW0gZW5jb2Rpbmcge1N0cmluZ30gRW5jb2RpbmcgdG8gdXNlLiBEZWZhdWx0cyB0byBlbmNvZGluZyBzZXQgaW4gY29uc3RydWN0b3IsIG9yIHV0ZjguXG4gICAgICogQHJldHVybnMge3N0cmluZ31cbiAgICAgKi9cbiAgICBTbWFydEJ1ZmZlci5wcm90b3R5cGUucmVhZFN0cmluZ05UID0gZnVuY3Rpb24gKGVuY29kaW5nKSB7XG4gICAgICAgIHZhciBudWxscG9zID0gdGhpcy5sZW5ndGg7XG4gICAgICAgIGZvciAodmFyIGkgPSB0aGlzLl9yZWFkT2Zmc2V0OyBpIDwgdGhpcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgaWYgKHRoaXMuYnVmZltpXSA9PSAweDAwKSB7XG4gICAgICAgICAgICAgICAgbnVsbHBvcyA9IGk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgcmVzdWx0ID0gdGhpcy5idWZmLnNsaWNlKHRoaXMuX3JlYWRPZmZzZXQsIG51bGxwb3MpO1xuICAgICAgICB0aGlzLl9yZWFkT2Zmc2V0ID0gbnVsbHBvcyArIDE7XG5cbiAgICAgICAgcmV0dXJuIHJlc3VsdC50b1N0cmluZyhlbmNvZGluZyB8fCB0aGlzLmVuY29kaW5nKTtcbiAgICB9O1xuXG5cbiAgICAvKipcbiAgICAgKiBSZWFkcyBhIHNwZWNpZmllZCBudW1iZXIgb2YgYnl0ZXMuXG4gICAgICogQHBhcmFtIGxlbiB7TnVtYmVyfSBOdW1iZXJzIG9mIGJ5dGVzIHRvIHJlYWQuIChEZWZhdWx0cyB0byB0aGUgcmVtYWluaW5nIGRhdGEgbGVuZ3RoKVxuICAgICAqIEByZXR1cm5zIHtCdWZmZXJ9IEJ1ZmZlciBjb250YWluaW5nIHRoZSByZWFkIGJ5dGVzLlxuICAgICAqL1xuICAgIFNtYXJ0QnVmZmVyLnByb3RvdHlwZS5yZWFkQnVmZmVyID0gZnVuY3Rpb24gKGxlbikge1xuICAgICAgICB2YXIgZW5kcG9pbnQgPSBNYXRoLm1pbih0aGlzLmxlbmd0aCwgdGhpcy5fcmVhZE9mZnNldCArIChsZW4gfHwgdGhpcy5sZW5ndGgpKTtcbiAgICAgICAgdmFyIHJldCA9IHRoaXMuYnVmZi5zbGljZSh0aGlzLl9yZWFkT2Zmc2V0LCBlbmRwb2ludCk7XG4gICAgICAgIHRoaXMuX3JlYWRPZmZzZXQgPSBlbmRwb2ludDtcbiAgICAgICAgcmV0dXJuIHJldDtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogUmVhZHMgYSBudWxsIHRlcm1pbmF0ZWQgc2VxdWVuY2Ugb2YgYnl0ZXMgZnJvbSB0aGUgdW5kZXJseWluZyBidWZmZXIuXG4gICAgICogQHJldHVybnMge0J1ZmZlcn0gQnVmZmVyIGNvbnRhaW5pbmcgdGhlIHJlYWQgYnl0ZXMuXG4gICAgICovXG4gICAgU21hcnRCdWZmZXIucHJvdG90eXBlLnJlYWRCdWZmZXJOVCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIG51bGxwb3MgPSB0aGlzLmxlbmd0aDtcbiAgICAgICAgZm9yICh2YXIgaSA9IHRoaXMuX3JlYWRPZmZzZXQ7IGkgPCB0aGlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5idWZmW2ldID09IDB4MDApIHtcbiAgICAgICAgICAgICAgICBudWxscG9zID0gaTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHZhciByZXQgPSB0aGlzLmJ1ZmYuc2xpY2UodGhpcy5fcmVhZE9mZnNldCwgbnVsbHBvcyk7XG4gICAgICAgIHRoaXMuX3JlYWRPZmZzZXQgPSBudWxscG9zICsgMTtcblxuICAgICAgICByZXR1cm4gcmV0O1xuICAgIH07XG5cblxuICAgIC8qXG4gICAgIFdyaXRlIE9wZXJhdGlvbnNcbiAgICAgKi9cblxuXG4gICAgU21hcnRCdWZmZXIucHJvdG90eXBlLndyaXRlSW50OCA9IG1ha2VXcml0ZXIoQnVmZmVyLnByb3RvdHlwZS53cml0ZUludDgsIDEpO1xuICAgIFNtYXJ0QnVmZmVyLnByb3RvdHlwZS53cml0ZUludDE2QkUgPSBtYWtlV3JpdGVyKEJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQxNkJFLCAyKTtcbiAgICBTbWFydEJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQxNkxFID0gbWFrZVdyaXRlcihCdWZmZXIucHJvdG90eXBlLndyaXRlSW50MTZMRSwgMik7XG4gICAgU21hcnRCdWZmZXIucHJvdG90eXBlLndyaXRlSW50MzJCRSA9IG1ha2VXcml0ZXIoQnVmZmVyLnByb3RvdHlwZS53cml0ZUludDMyQkUsIDQpO1xuICAgIFNtYXJ0QnVmZmVyLnByb3RvdHlwZS53cml0ZUludDMyTEUgPSBtYWtlV3JpdGVyKEJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQzMkxFLCA0KTtcblxuICAgIFNtYXJ0QnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQ4ID0gbWFrZVdyaXRlcihCdWZmZXIucHJvdG90eXBlLndyaXRlVUludDgsIDEpO1xuICAgIFNtYXJ0QnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQxNkJFID0gbWFrZVdyaXRlcihCdWZmZXIucHJvdG90eXBlLndyaXRlVUludDE2QkUsIDIpO1xuICAgIFNtYXJ0QnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQxNkxFID0gbWFrZVdyaXRlcihCdWZmZXIucHJvdG90eXBlLndyaXRlVUludDE2TEUsIDIpO1xuICAgIFNtYXJ0QnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQzMkJFID0gbWFrZVdyaXRlcihCdWZmZXIucHJvdG90eXBlLndyaXRlVUludDMyQkUsIDQpO1xuICAgIFNtYXJ0QnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQzMkxFID0gbWFrZVdyaXRlcihCdWZmZXIucHJvdG90eXBlLndyaXRlVUludDMyTEUsIDQpO1xuXG4gICAgU21hcnRCdWZmZXIucHJvdG90eXBlLndyaXRlRmxvYXRCRSA9IG1ha2VXcml0ZXIoQnVmZmVyLnByb3RvdHlwZS53cml0ZUZsb2F0QkUsIDQpO1xuICAgIFNtYXJ0QnVmZmVyLnByb3RvdHlwZS53cml0ZUZsb2F0TEUgPSBtYWtlV3JpdGVyKEJ1ZmZlci5wcm90b3R5cGUud3JpdGVGbG9hdExFLCA0KTtcblxuICAgIFNtYXJ0QnVmZmVyLnByb3RvdHlwZS53cml0ZURvdWJsZUJFID0gbWFrZVdyaXRlcihCdWZmZXIucHJvdG90eXBlLndyaXRlRG91YmxlQkUsIDgpO1xuICAgIFNtYXJ0QnVmZmVyLnByb3RvdHlwZS53cml0ZURvdWJsZUxFID0gbWFrZVdyaXRlcihCdWZmZXIucHJvdG90eXBlLndyaXRlRG91YmxlTEUsIDgpO1xuXG5cbiAgICAvKipcbiAgICAgKiBXcml0ZXMgYSBzdHJpbmcgdG8gdGhlIHVuZGVybHlpbmcgYnVmZmVyLlxuICAgICAqIEBwYXJhbSB2YWx1ZSB7U3RyaW5nfSBUaGUgc3RyaW5nIHRvIHdyaXRlLlxuICAgICAqIEBwYXJhbSBvZmZzZXQge051bWJlcn0gVGhlIG9mZnNldCB0byB3cml0ZSB0aGUgc3RyaW5nIHRvLiAoRW5jb2RpbmcgY2FuIGFsc28gYmUgc2V0IGhlcmUgaW4gcGxhY2Ugb2Ygb2Zmc2V0KVxuICAgICAqIEBwYXJhbSBlbmNvZGluZyB7U3RyaW5nfSBUaGUgZW5jb2RpbmcgdG8gdXNlLiAoRGVmYXVsdHMgdG8gZW5jb2Rpbmcgc2V0IGluIGNvbnN0cnVjdG9yLCBvciB0byB1dGY4KVxuICAgICAqIEByZXR1cm5zIHsqfVxuICAgICAqL1xuICAgIFNtYXJ0QnVmZmVyLnByb3RvdHlwZS53cml0ZVN0cmluZyA9IGZ1bmN0aW9uICh2YWx1ZSwgb2Zmc2V0LCBlbmNvZGluZykge1xuICAgICAgICB2YXIgbGVuLCBfb2Zmc2V0LCB0eXBlID0gdHlwZW9mIG9mZnNldDtcblxuICAgICAgICBpZiAodHlwZSA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgIF9vZmZzZXQgPSBvZmZzZXQ7XG4gICAgICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIGVuY29kaW5nID0gb2Zmc2V0O1xuICAgICAgICAgICAgb2Zmc2V0ID0gdGhpcy5fd3JpdGVPZmZzZXQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBlbmNvZGluZyA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIG9mZnNldCA9IHRoaXMuX3dyaXRlT2Zmc2V0O1xuICAgICAgICB9XG5cbiAgICAgICAgbGVuID0gQnVmZmVyLmJ5dGVMZW5ndGgodmFsdWUsIGVuY29kaW5nIHx8IHRoaXMuZW5jb2RpbmcpO1xuICAgICAgICB0aGlzLl9lbnN1cmVXcml0YWJsZShsZW4sIF9vZmZzZXQpO1xuXG4gICAgICAgIHRoaXMuYnVmZi53cml0ZSh2YWx1ZSwgb2Zmc2V0LCBsZW4sIGVuY29kaW5nIHx8IHRoaXMuZW5jb2RpbmcpO1xuICAgICAgICB0aGlzLl93cml0ZU9mZnNldCArPSBsZW47XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBXcml0ZXMgYSBudWxsIHRlcm1pbmF0ZWQgc3RyaW5nIHRvIHRoZSB1bmRlcmx5aW5nIGJ1ZmZlci5cbiAgICAgKiBAcGFyYW0gdmFsdWUge1N0cmluZ30gVGhlIHN0cmluZyB0byB3cml0ZS5cbiAgICAgKiBAcGFyYW0gb2Zmc2V0IHtOdW1iZXJ9IFRoZSBvZmZzZXQgdG8gd3JpdGUgdGhlIHN0cmluZyB0by4gKEVuY29kaW5nIGNhbiBhbHNvIGJlIHNldCBoZXJlIGluIHBsYWNlIG9mIG9mZnNldClcbiAgICAgKiBAcGFyYW0gZW5jb2Rpbmcge1N0cmluZ30gVGhlIGVuY29kaW5nIHRvIHVzZS4gKERlZmF1bHRzIHRvIGVuY29kaW5nIHNldCBpbiBjb25zdHJ1Y3Rvciwgb3IgdG8gdXRmOClcbiAgICAgKiBAcmV0dXJucyB7Kn1cbiAgICAgKi9cbiAgICBTbWFydEJ1ZmZlci5wcm90b3R5cGUud3JpdGVTdHJpbmdOVCA9IGZ1bmN0aW9uICh2YWx1ZSwgb2Zmc2V0LCBlbmNvZGluZykge1xuICAgICAgICB0aGlzLndyaXRlU3RyaW5nKHZhbHVlLCBvZmZzZXQsIGVuY29kaW5nKTtcbiAgICAgICAgdGhpcy53cml0ZVVJbnQ4KDB4MDApO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogV3JpdGVzIGEgQnVmZmVyIHRvIHRoZSB1bmRlcmx5aW5nIGJ1ZmZlci5cbiAgICAgKiBAcGFyYW0gdmFsdWUge0J1ZmZlcn0gVGhlIGJ1ZmZlciB0byB3cml0ZS5cbiAgICAgKiBAcGFyYW0gb2Zmc2V0IHtOdW1iZXJ9IFRoZSBvZmZzZXQgdG8gd3JpdGUgdGhlIEJ1ZmZlciB0by5cbiAgICAgKiBAcmV0dXJucyB7Kn1cbiAgICAgKi9cbiAgICBTbWFydEJ1ZmZlci5wcm90b3R5cGUud3JpdGVCdWZmZXIgPSBmdW5jdGlvbiAodmFsdWUsIG9mZnNldCkge1xuICAgICAgICB2YXIgbGVuID0gdmFsdWUubGVuZ3RoO1xuICAgICAgICB0aGlzLl9lbnN1cmVXcml0YWJsZShsZW4sIG9mZnNldCk7XG4gICAgICAgIHZhbHVlLmNvcHkodGhpcy5idWZmLCBvZmZzZXQgfHwgdGhpcy5fd3JpdGVPZmZzZXQpO1xuICAgICAgICB0aGlzLl93cml0ZU9mZnNldCArPSBsZW47XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBXcml0ZXMgYSBudWxsIHRlcm1pbmF0ZWQgQnVmZmVyIHRvIHRoZSB1bmRlcmx5aW5nIGJ1ZmZlci5cbiAgICAgKiBAcGFyYW0gdmFsdWUge0J1ZmZlcn0gVGhlIGJ1ZmZlciB0byB3cml0ZS5cbiAgICAgKiBAcGFyYW0gb2Zmc2V0IHtOdW1iZXJ9IFRoZSBvZmZzZXQgdG8gd3JpdGUgdGhlIEJ1ZmZlciB0by5cbiAgICAgKiBAcmV0dXJucyB7Kn1cbiAgICAgKi9cbiAgICBTbWFydEJ1ZmZlci5wcm90b3R5cGUud3JpdGVCdWZmZXJOVCA9IGZ1bmN0aW9uICh2YWx1ZSwgb2Zmc2V0KSB7XG4gICAgICAgIHZhciBsZW4gPSB2YWx1ZS5sZW5ndGg7XG4gICAgICAgIHRoaXMuX2Vuc3VyZVdyaXRhYmxlKGxlbiwgb2Zmc2V0KTtcbiAgICAgICAgdmFsdWUuY29weSh0aGlzLmJ1ZmYsIG9mZnNldCB8fCB0aGlzLl93cml0ZU9mZnNldCk7XG4gICAgICAgIHRoaXMuYnVmZlt0aGlzLl93cml0ZU9mZnNldCArIGxlbl0gPSAweDAwO1xuICAgICAgICB0aGlzLl93cml0ZU9mZnNldCArPSBsZW4gKyAxO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuXG5cbiAgICAvKipcbiAgICAgKiBSZXNldHMgdGhlIEVuZGxlc3MgQnVmZmVyLlxuICAgICAqL1xuICAgIFNtYXJ0QnVmZmVyLnByb3RvdHlwZS5jbGVhciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5fd3JpdGVPZmZzZXQgPSAwO1xuICAgICAgICB0aGlzLl9yZWFkT2Zmc2V0ID0gMDtcbiAgICAgICAgdGhpcy5sZW5ndGggPSAwO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSByZW1haW5pbmcgbnVtYmVyIG9mIGJ5dGVzIHRvIGJlIHJlYWQgZnJvbSB0aGUgZXhpc3RpbmcgQnVmZmVyLlxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IFRoZSBudW1iZXIgb2YgYnl0ZXMgcmVtYWluaW5nLlxuICAgICAqL1xuICAgIFNtYXJ0QnVmZmVyLnByb3RvdHlwZS5yZW1haW5pbmcgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmxlbmd0aCAtIHRoaXMuX3JlYWRPZmZzZXQ7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFNraXBzIHRoZSByZWFkIHBvc2l0aW9uIGZvcndhcmQgYnkgdGhlIGFtb3VudCBvZiBnaXZlbi5cbiAgICAgKiBAcGFyYW0gYW1vdW50IHtOdW1iZXJ9IFRoZSBhbW91bnQgb2YgYnl0ZXMgdG8gc2tpcCBmb3J3YXJkLlxuICAgICAqL1xuICAgIFNtYXJ0QnVmZmVyLnByb3RvdHlwZS5za2lwID0gZnVuY3Rpb24gKGFtb3VudCkge1xuICAgICAgICBpZiAodGhpcy5fcmVhZE9mZnNldCArIGFtb3VudCA+IHRoaXMubGVuZ3RoKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdUYXJnZXQgcG9zaXRpb24gaXMgYmV5b25kIHRoZSBib3VuZHMgb2YgdGhlIGRhdGEuJyk7XG5cbiAgICAgICAgdGhpcy5fcmVhZE9mZnNldCArPSBhbW91bnQ7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFJld2luZHMgdGhlIHJlYWQgcG9zaXRpb24gYmFja3dhcmQgYnkgdGhlIGFtb3VudCBnaXZlbi5cbiAgICAgKiBAcGFyYW0gYW1vdW50IHtOdW1iZXJ9IFRoZSBhbW91bnQgb2YgYnl0ZXMgdG8gcmV2ZXJzZSBiYWNrd2FyZC5cbiAgICAgKi9cbiAgICBTbWFydEJ1ZmZlci5wcm90b3R5cGUucmV3aW5kID0gZnVuY3Rpb24gKGFtb3VudCkge1xuICAgICAgICBpZiAodGhpcy5fcmVhZE9mZnNldCAtIGFtb3VudCA8IDApXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RhcmdldCBwb3NpdGlvbiBpcyBiZXlvbmQgdGhlIGJvdW5kcyBvZiB0aGUgZGF0YS4nKTtcblxuICAgICAgICB0aGlzLl9yZWFkT2Zmc2V0IC09IGFtb3VudDtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogU2tpcHMgdGhlIHJlYWQgcG9zaXRpb24gdG8gdGhlIGdpdmVuIHBvc2l0aW9uLlxuICAgICAqIEBwYXJhbSBwb3NpdGlvbiB7TnVtYmVyfSBUaGUgcG9zaXRpb24gdG8gc2tpcCB0by5cbiAgICAgKi9cbiAgICBTbWFydEJ1ZmZlci5wcm90b3R5cGUuc2tpcFRvID0gZnVuY3Rpb24gKHBvc2l0aW9uKSB7XG4gICAgICAgIGlmIChwb3NpdGlvbiA8IDAgfHwgcG9zaXRpb24gPiB0aGlzLmxlbmd0aClcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVGFyZ2V0IHBvc2l0aW9uIGlzIGJleW9uZCB0aGUgYm91bmRzIG9mIHRoZSBkYXRhLicpO1xuXG4gICAgICAgIHRoaXMuX3JlYWRPZmZzZXQgPSBwb3NpdGlvbjtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgdW5kZXJseWluZyBCdWZmZXIuXG4gICAgICogQHJldHVybnMgeyp9XG4gICAgICovXG4gICAgU21hcnRCdWZmZXIucHJvdG90eXBlLnRvQnVmZmVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5idWZmLnNsaWNlKDAsIHRoaXMubGVuZ3RoKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogR2V0cyBhIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGUgdW5kZXJseWluZyBCdWZmZXIuXG4gICAgICogQHBhcmFtIGVuY29kaW5nIHtTdHJpbmd9IEVuY29kaW5nIHRvIHVzZS4gKERlZmF1bHRzIHRvIGVuY29kaW5nIHNldCBpbiBjb25zdHJ1Y3Rvciwgb3IgdXRmOC4pXG4gICAgICogQHJldHVybnMgeyp9XG4gICAgICovXG4gICAgU21hcnRCdWZmZXIucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gKGVuY29kaW5nKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmJ1ZmYudG9TdHJpbmcoZW5jb2RpbmcgfHwgdGhpcy5lbmNvZGluZywgMCwgdGhpcy5sZW5ndGgpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBEZXN0cm95cyB0aGUgdW5kZXJseWluZyBCdWZmZXIsIGFuZCByZXNldHMgdGhlIFNtYXJ0QnVmZmVyLlxuICAgICAqL1xuICAgIFNtYXJ0QnVmZmVyLnByb3RvdHlwZS5kZXN0cm95ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBkZWxldGUgdGhpcy5idWZmO1xuICAgICAgICB0aGlzLmNsZWFyKCk7XG4gICAgfTtcblxuICAgIHJldHVybiBTbWFydEJ1ZmZlcjtcbn0pKCk7XG5cbm1vZHVsZS5leHBvcnRzID0gU21hcnRCdWZmZXI7XG59KS5jYWxsKHRoaXMscmVxdWlyZShcImJ1ZmZlclwiKS5CdWZmZXIpIiwiKGZ1bmN0aW9uIChCdWZmZXIpe1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgc3RyZWFtID0gcmVxdWlyZSgnc3RyZWFtJyk7XG52YXIgVHJhbnNmb3JtID0gc3RyZWFtLlRyYW5zZm9ybTtcbnZhciB1dGlsID0gcmVxdWlyZSgndXRpbCcpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IERhdGFTdHJlYW07XG5cbi8qKlxuICogRXNjYXBlcyBkb3RzIGluIHRoZSBiZWdpbm5pbmcgb2YgbGluZXMuIEVuZHMgdGhlIHN0cmVhbSB3aXRoIDxDUj48TEY+LjxDUj48TEY+XG4gKiBBbHNvIG1ha2VzIHN1cmUgdGhhdCBvbmx5IDxDUj48TEY+IHNlcXVlbmNlcyBhcmUgdXNlZCBmb3IgbGluZWJyZWFrc1xuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIFN0cmVhbSBvcHRpb25zXG4gKi9cbmZ1bmN0aW9uIERhdGFTdHJlYW0ob3B0aW9ucykge1xuICAgIC8vIGluaXQgVHJhbnNmb3JtXG4gICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgICB0aGlzLl9jdXJMaW5lID0gJyc7XG5cbiAgICB0aGlzLmluQnl0ZUNvdW50ID0gMDtcbiAgICB0aGlzLm91dEJ5dGVDb3VudCA9IDA7XG4gICAgdGhpcy5sYXN0Qnl0ZSA9IGZhbHNlO1xuXG4gICAgVHJhbnNmb3JtLmNhbGwodGhpcywgdGhpcy5vcHRpb25zKTtcbn1cbnV0aWwuaW5oZXJpdHMoRGF0YVN0cmVhbSwgVHJhbnNmb3JtKTtcblxuLyoqXG4gKiBFc2NhcGVzIGRvdHNcbiAqL1xuRGF0YVN0cmVhbS5wcm90b3R5cGUuX3RyYW5zZm9ybSA9IGZ1bmN0aW9uIChjaHVuaywgZW5jb2RpbmcsIGRvbmUpIHtcbiAgICB2YXIgY2h1bmtzID0gW107XG4gICAgdmFyIGNodW5rbGVuID0gMDtcbiAgICB2YXIgaSwgbGVuLCBsYXN0UG9zID0gMDtcbiAgICB2YXIgYnVmO1xuXG4gICAgaWYgKCFjaHVuayB8fCAhY2h1bmsubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiBkb25lKCk7XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBjaHVuayA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgY2h1bmsgPSBuZXcgQnVmZmVyKGNodW5rKTtcbiAgICB9XG5cbiAgICB0aGlzLmluQnl0ZUNvdW50ICs9IGNodW5rLmxlbmd0aDtcblxuICAgIGZvciAoaSA9IDAsIGxlbiA9IGNodW5rLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgIGlmIChjaHVua1tpXSA9PT0gMHgyRSkgeyAvLyAuXG4gICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICAgKGkgJiYgY2h1bmtbaSAtIDFdID09PSAweDBBKSB8fFxuICAgICAgICAgICAgICAgICghaSAmJiAoIXRoaXMubGFzdEJ5dGUgfHwgdGhpcy5sYXN0Qnl0ZSA9PT0gMHgwQSkpXG4gICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICBidWYgPSBjaHVuay5zbGljZShsYXN0UG9zLCBpICsgMSk7XG4gICAgICAgICAgICAgICAgY2h1bmtzLnB1c2goYnVmKTtcbiAgICAgICAgICAgICAgICBjaHVua3MucHVzaChuZXcgQnVmZmVyKCcuJykpO1xuICAgICAgICAgICAgICAgIGNodW5rbGVuICs9IGJ1Zi5sZW5ndGggKyAxO1xuICAgICAgICAgICAgICAgIGxhc3RQb3MgPSBpICsgMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmIChjaHVua1tpXSA9PT0gMHgwQSkgeyAvLyAuXG4gICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICAgKGkgJiYgY2h1bmtbaSAtIDFdICE9PSAweDBEKSB8fFxuICAgICAgICAgICAgICAgICghaSAmJiB0aGlzLmxhc3RCeXRlICE9PSAweDBEKVxuICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgaWYgKGkgPiBsYXN0UG9zKSB7XG4gICAgICAgICAgICAgICAgICAgIGJ1ZiA9IGNodW5rLnNsaWNlKGxhc3RQb3MsIGkpO1xuICAgICAgICAgICAgICAgICAgICBjaHVua3MucHVzaChidWYpO1xuICAgICAgICAgICAgICAgICAgICBjaHVua2xlbiArPSBidWYubGVuZ3RoICsgMjtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBjaHVua2xlbiArPSAyO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjaHVua3MucHVzaChuZXcgQnVmZmVyKCdcXHJcXG4nKSk7XG4gICAgICAgICAgICAgICAgbGFzdFBvcyA9IGkgKyAxO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGNodW5rbGVuKSB7XG4gICAgICAgIC8vIGFkZCBsYXN0IHBpZWNlXG4gICAgICAgIGlmIChsYXN0UG9zIDwgY2h1bmsubGVuZ3RoKSB7XG4gICAgICAgICAgICBidWYgPSBjaHVuay5zbGljZShsYXN0UG9zKTtcbiAgICAgICAgICAgIGNodW5rcy5wdXNoKGJ1Zik7XG4gICAgICAgICAgICBjaHVua2xlbiArPSBidWYubGVuZ3RoO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5vdXRCeXRlQ291bnQgKz0gY2h1bmtsZW47XG4gICAgICAgIHRoaXMucHVzaChCdWZmZXIuY29uY2F0KGNodW5rcywgY2h1bmtsZW4pKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLm91dEJ5dGVDb3VudCArPSBjaHVuay5sZW5ndGg7XG4gICAgICAgIHRoaXMucHVzaChjaHVuayk7XG4gICAgfVxuXG4gICAgdGhpcy5sYXN0Qnl0ZSA9IGNodW5rW2NodW5rLmxlbmd0aCAtIDFdO1xuICAgIGRvbmUoKTtcbn07XG5cbi8qKlxuICogRmluYWxpemVzIHRoZSBzdHJlYW0gd2l0aCBhIGRvdCBvbiBhIHNpbmdsZSBsaW5lXG4gKi9cbkRhdGFTdHJlYW0ucHJvdG90eXBlLl9mbHVzaCA9IGZ1bmN0aW9uIChkb25lKSB7XG4gICAgdmFyIGJ1ZjtcbiAgICBpZiAodGhpcy5sYXN0Qnl0ZSA9PT0gMHgwQSkge1xuICAgICAgICBidWYgPSBuZXcgQnVmZmVyKCcuXFxyXFxuJyk7XG4gICAgfSBlbHNlIGlmICh0aGlzLmxhc3RCeXRlID09PSAweDBEKSB7XG4gICAgICAgIGJ1ZiA9IG5ldyBCdWZmZXIoJ1xcbi5cXHJcXG4nKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBidWYgPSBuZXcgQnVmZmVyKCdcXHJcXG4uXFxyXFxuJyk7XG4gICAgfVxuICAgIHRoaXMub3V0Qnl0ZUNvdW50ICs9IGJ1Zi5sZW5ndGg7XG4gICAgdGhpcy5wdXNoKGJ1Zik7XG4gICAgZG9uZSgpO1xufTtcblxufSkuY2FsbCh0aGlzLHJlcXVpcmUoXCJidWZmZXJcIikuQnVmZmVyKSIsIihmdW5jdGlvbiAoQnVmZmVyKXtcbid1c2Ugc3RyaWN0JztcblxudmFyIHBhY2thZ2VJbmZvID0gcmVxdWlyZSgnLi4vcGFja2FnZS5qc29uJyk7XG52YXIgRXZlbnRFbWl0dGVyID0gcmVxdWlyZSgnZXZlbnRzJykuRXZlbnRFbWl0dGVyO1xudmFyIHV0aWwgPSByZXF1aXJlKCd1dGlsJyk7XG52YXIgbmV0ID0gcmVxdWlyZSgnbmV0Jyk7XG52YXIgdGxzID0gcmVxdWlyZSgndGxzJyk7XG52YXIgb3MgPSByZXF1aXJlKCdvcycpO1xudmFyIGNyeXB0byA9IHJlcXVpcmUoJ2NyeXB0bycpO1xudmFyIERhdGFTdHJlYW0gPSByZXF1aXJlKCcuL2RhdGEtc3RyZWFtJyk7XG52YXIgUGFzc1Rocm91Z2ggPSByZXF1aXJlKCdzdHJlYW0nKS5QYXNzVGhyb3VnaDtcbnZhciBzaGFyZWQgPSByZXF1aXJlKCdub2RlbWFpbGVyLXNoYXJlZCcpO1xudmFyIG50bG0gPSByZXF1aXJlKCdodHRwbnRsbS9udGxtJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gU01UUENvbm5lY3Rpb247XG5cbi8qKlxuICogR2VuZXJhdGVzIGEgU01UUCBjb25uZWN0aW9uIG9iamVjdFxuICpcbiAqIE9wdGlvbmFsIG9wdGlvbnMgb2JqZWN0IHRha2VzIHRoZSBmb2xsb3dpbmcgcG9zc2libGUgcHJvcGVydGllczpcbiAqXG4gKiAgKiAqKnBvcnQqKiAtIGlzIHRoZSBwb3J0IHRvIGNvbm5lY3QgdG8gKGRlZmF1bHRzIHRvIDI1IG9yIDQ2NSlcbiAqICAqICoqaG9zdCoqIC0gaXMgdGhlIGhvc3RuYW1lIG9yIElQIGFkZHJlc3MgdG8gY29ubmVjdCB0byAoZGVmYXVsdHMgdG8gJ2xvY2FsaG9zdCcpXG4gKiAgKiAqKnNlY3VyZSoqIC0gdXNlIFNTTFxuICogICogKippZ25vcmVUTFMqKiAtIGlnbm9yZSBzZXJ2ZXIgc3VwcG9ydCBmb3IgU1RBUlRUTFNcbiAqICAqICoqcmVxdWlyZVRMUyoqIC0gZm9yY2VzIHRoZSBjbGllbnQgdG8gdXNlIFNUQVJUVExTXG4gKiAgKiAqKm5hbWUqKiAtIHRoZSBuYW1lIG9mIHRoZSBjbGllbnQgc2VydmVyXG4gKiAgKiAqKmxvY2FsQWRkcmVzcyoqIC0gb3V0Ym91bmQgYWRkcmVzcyB0byBiaW5kIHRvIChzZWU6IGh0dHA6Ly9ub2RlanMub3JnL2FwaS9uZXQuaHRtbCNuZXRfbmV0X2Nvbm5lY3Rfb3B0aW9uc19jb25uZWN0aW9ubGlzdGVuZXIpXG4gKiAgKiAqKmdyZWV0aW5nVGltZW91dCoqIC0gVGltZSB0byB3YWl0IGluIG1zIHVudGlsIGdyZWV0aW5nIG1lc3NhZ2UgaXMgcmVjZWl2ZWQgZnJvbSB0aGUgc2VydmVyIChkZWZhdWx0cyB0byAxMDAwMClcbiAqICAqICoqY29ubmVjdGlvblRpbWVvdXQqKiAtIGhvdyBtYW55IG1pbGxpc2Vjb25kcyB0byB3YWl0IGZvciB0aGUgY29ubmVjdGlvbiB0byBlc3RhYmxpc2hcbiAqICAqICoqc29ja2V0VGltZW91dCoqIC0gVGltZSBvZiBpbmFjdGl2aXR5IHVudGlsIHRoZSBjb25uZWN0aW9uIGlzIGNsb3NlZCAoZGVmYXVsdHMgdG8gMSBob3VyKVxuICogICogKipsbXRwKiogLSBpZiB0cnVlLCB1c2VzIExNVFAgaW5zdGVhZCBvZiBTTVRQIHByb3RvY29sXG4gKiAgKiAqKmxvZ2dlcioqIC0gYnVueWFuIGNvbXBhdGlibGUgbG9nZ2VyIGludGVyZmFjZVxuICogICogKipkZWJ1ZyoqIC0gaWYgdHJ1ZSBwYXNzIFNNVFAgdHJhZmZpYyB0byB0aGUgbG9nZ2VyXG4gKiAgKiAqKnRscyoqIC0gb3B0aW9ucyBmb3IgY3JlYXRlQ3JlZGVudGlhbHNcbiAqICAqICoqc29ja2V0KiogLSBleGlzdGluZyBzb2NrZXQgdG8gdXNlIGluc3RlYWQgb2YgY3JlYXRpbmcgYSBuZXcgb25lIChzZWU6IGh0dHA6Ly9ub2RlanMub3JnL2FwaS9uZXQuaHRtbCNuZXRfY2xhc3NfbmV0X3NvY2tldClcbiAqICAqICoqc2VjdXJlZCoqIC0gYm9vbGVhbiBpbmRpY2F0ZXMgdGhhdCB0aGUgcHJvdmlkZWQgc29ja2V0IGhhcyBhbHJlYWR5IGJlZW4gdXBncmFkZWQgdG8gdGxzXG4gKlxuICogQGNvbnN0cnVjdG9yXG4gKiBAbmFtZXNwYWNlIFNNVFAgQ2xpZW50IG1vZHVsZVxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSBPcHRpb24gcHJvcGVydGllc1xuICovXG5mdW5jdGlvbiBTTVRQQ29ubmVjdGlvbihvcHRpb25zKSB7XG4gICAgRXZlbnRFbWl0dGVyLmNhbGwodGhpcyk7XG5cbiAgICB0aGlzLmlkID0gY3J5cHRvLnJhbmRvbUJ5dGVzKDgpLnRvU3RyaW5nKCdiYXNlNjQnKS5yZXBsYWNlKC9cXFcvZywgJycpO1xuICAgIHRoaXMuc3RhZ2UgPSAnaW5pdCc7XG5cbiAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG4gICAgdGhpcy5zZWN1cmVDb25uZWN0aW9uID0gISF0aGlzLm9wdGlvbnMuc2VjdXJlO1xuICAgIHRoaXMuYWxyZWFkeVNlY3VyZWQgPSAhIXRoaXMub3B0aW9ucy5zZWN1cmVkO1xuXG4gICAgdGhpcy5wb3J0ID0gdGhpcy5vcHRpb25zLnBvcnQgfHwgKHRoaXMuc2VjdXJlQ29ubmVjdGlvbiA/IDQ2NSA6IDI1KTtcbiAgICB0aGlzLmhvc3QgPSB0aGlzLm9wdGlvbnMuaG9zdCB8fCAnbG9jYWxob3N0JztcblxuICAgIGlmICh0eXBlb2YgdGhpcy5vcHRpb25zLnNlY3VyZSA9PT0gJ3VuZGVmaW5lZCcgJiYgdGhpcy5wb3J0ID09PSA0NjUpIHtcbiAgICAgICAgLy8gaWYgc2VjdXJlIG9wdGlvbiBpcyBub3Qgc2V0IGJ1dCBwb3J0IGlzIDQ2NSwgdGhlbiBkZWZhdWx0IHRvIHNlY3VyZVxuICAgICAgICB0aGlzLnNlY3VyZUNvbm5lY3Rpb24gPSB0cnVlO1xuICAgIH1cblxuICAgIHRoaXMubmFtZSA9IHRoaXMub3B0aW9ucy5uYW1lIHx8IHRoaXMuX2dldEhvc3RuYW1lKCk7XG5cbiAgICB0aGlzLmxvZ2dlciA9IHNoYXJlZC5nZXRMb2dnZXIodGhpcy5vcHRpb25zKTtcblxuICAgIC8qKlxuICAgICAqIEV4cG9zZSB2ZXJzaW9uIG5yLCBqdXN0IGZvciB0aGUgcmVmZXJlbmNlXG4gICAgICogQHR5cGUge1N0cmluZ31cbiAgICAgKi9cbiAgICB0aGlzLnZlcnNpb24gPSBwYWNrYWdlSW5mby52ZXJzaW9uO1xuXG4gICAgLyoqXG4gICAgICogSWYgdHJ1ZSwgdGhlbiB0aGUgdXNlciBpcyBhdXRoZW50aWNhdGVkXG4gICAgICogQHR5cGUge0Jvb2xlYW59XG4gICAgICovXG4gICAgdGhpcy5hdXRoZW50aWNhdGVkID0gZmFsc2U7XG5cbiAgICAvKipcbiAgICAgKiBJZiBzZXQgdG8gdHJ1ZSwgdGhpcyBpbnN0YW5jZSBpcyBubyBsb25nZXIgYWN0aXZlXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICB0aGlzLmRlc3Ryb3llZCA9IGZhbHNlO1xuXG4gICAgLyoqXG4gICAgICogRGVmaW5lcyBpZiB0aGUgY3VycmVudCBjb25uZWN0aW9uIGlzIHNlY3VyZSBvciBub3QuIElmIG5vdCxcbiAgICAgKiBTVEFSVFRMUyBjYW4gYmUgdXNlZCBpZiBhdmFpbGFibGVcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHRoaXMuc2VjdXJlID0gISF0aGlzLnNlY3VyZUNvbm5lY3Rpb247XG5cbiAgICAvKipcbiAgICAgKiBTdG9yZSBpbmNvbXBsZXRlIG1lc3NhZ2VzIGNvbWluZyBmcm9tIHRoZSBzZXJ2ZXJcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHRoaXMuX3JlbWFpbmRlciA9ICcnO1xuXG4gICAgLyoqXG4gICAgICogVW5wcm9jZXNzZWQgcmVzcG9uc2VzIGZyb20gdGhlIHNlcnZlclxuICAgICAqIEB0eXBlIHtBcnJheX1cbiAgICAgKi9cbiAgICB0aGlzLl9yZXNwb25zZVF1ZXVlID0gW107XG5cbiAgICAvKipcbiAgICAgKiBUaGUgc29ja2V0IGNvbm5lY3RpbmcgdG8gdGhlIHNlcnZlclxuICAgICAqIEBwdWJsaWNrXG4gICAgICovXG4gICAgdGhpcy5fc29ja2V0ID0gZmFsc2U7XG5cbiAgICAvKipcbiAgICAgKiBMaXN0cyBzdXBwb3J0ZWQgYXV0aCBtZWNoYW5pc21zXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICB0aGlzLl9zdXBwb3J0ZWRBdXRoID0gW107XG5cbiAgICAvKipcbiAgICAgKiBMaXN0cyBzdXBwb3J0ZWQgZXh0ZW5zaW9uc1xuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgdGhpcy5fc3VwcG9ydGVkRXh0ZW5zaW9ucyA9IFtdO1xuXG4gICAgLyoqXG4gICAgICogRnVuY3Rpb24gdG8gcnVuIGlmIGEgZGF0YSBjaHVuayBjb21lcyBmcm9tIHRoZSBzZXJ2ZXJcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHRoaXMuX2N1cnJlbnRBY3Rpb24gPSBmYWxzZTtcblxuICAgIC8qKlxuICAgICAqIFRpbWVvdXQgdmFyaWFibGUgZm9yIHdhaXRpbmcgdGhlIGdyZWV0aW5nXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICB0aGlzLl9ncmVldGluZ1RpbWVvdXQgPSBmYWxzZTtcblxuICAgIC8qKlxuICAgICAqIFRpbWVvdXQgdmFyaWFibGUgZm9yIHdhaXRpbmcgdGhlIGNvbm5lY3Rpb24gdG8gc3RhcnRcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHRoaXMuX2Nvbm5lY3Rpb25UaW1lb3V0ID0gZmFsc2U7XG5cbiAgICAvKipcbiAgICAgKiBJZiB0aGUgc29ja2V0IGlzIGRlZW1lZCBhbHJlYWR5IGNsb3NlZFxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgdGhpcy5fZGVzdHJveWVkID0gZmFsc2U7XG5cbiAgICAvKipcbiAgICAgKiBJZiB0aGUgc29ja2V0IGlzIGFscmVhZHkgYmVpbmcgY2xvc2VkXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICB0aGlzLl9jbG9zaW5nID0gZmFsc2U7XG59XG51dGlsLmluaGVyaXRzKFNNVFBDb25uZWN0aW9uLCBFdmVudEVtaXR0ZXIpO1xuXG4vKipcbiAqIENyZWF0ZXMgYSBjb25uZWN0aW9uIHRvIGEgU01UUCBzZXJ2ZXIgYW5kIHNldHMgdXAgY29ubmVjdGlvblxuICogbGlzdGVuZXJcbiAqL1xuU01UUENvbm5lY3Rpb24ucHJvdG90eXBlLmNvbm5lY3QgPSBmdW5jdGlvbiAoY29ubmVjdENhbGxiYWNrKSB7XG4gICAgaWYgKHR5cGVvZiBjb25uZWN0Q2FsbGJhY2sgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgdGhpcy5vbmNlKCdjb25uZWN0JywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdGhpcy5sb2dnZXIuZGVidWcoJ1slc10gU01UUCBoYW5kc2hha2UgZmluaXNoZWQnLCB0aGlzLmlkKTtcbiAgICAgICAgICAgIGNvbm5lY3RDYWxsYmFjaygpO1xuICAgICAgICB9LmJpbmQodGhpcykpO1xuICAgIH1cblxuICAgIHZhciBvcHRzID0ge1xuICAgICAgICBwb3J0OiB0aGlzLnBvcnQsXG4gICAgICAgIGhvc3Q6IHRoaXMuaG9zdFxuICAgIH07XG5cbiAgICBpZiAodGhpcy5vcHRpb25zLmxvY2FsQWRkcmVzcykge1xuICAgICAgICBvcHRzLmxvY2FsQWRkcmVzcyA9IHRoaXMub3B0aW9ucy5sb2NhbEFkZHJlc3M7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMub3B0aW9ucy5jb25uZWN0aW9uKSB7XG4gICAgICAgIC8vIGNvbm5lY3Rpb24gaXMgYWxyZWFkeSBvcGVuZWRcbiAgICAgICAgdGhpcy5fc29ja2V0ID0gdGhpcy5vcHRpb25zLmNvbm5lY3Rpb247XG4gICAgICAgIGlmICh0aGlzLnNlY3VyZUNvbm5lY3Rpb24gJiYgIXRoaXMuYWxyZWFkeVNlY3VyZWQpIHtcbiAgICAgICAgICAgIHNldEltbWVkaWF0ZSh0aGlzLl91cGdyYWRlQ29ubmVjdGlvbi5iaW5kKHRoaXMsIGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX29uRXJyb3IobmV3IEVycm9yKCdFcnJvciBpbml0aWF0aW5nIFRMUyAtICcgKyAoZXJyLm1lc3NhZ2UgfHwgZXJyKSksICdFVExTJyk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5fb25Db25uZWN0KCk7XG4gICAgICAgICAgICB9LmJpbmQodGhpcykpKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHNldEltbWVkaWF0ZSh0aGlzLl9vbkNvbm5lY3QuYmluZCh0aGlzKSk7XG4gICAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHRoaXMub3B0aW9ucy5zb2NrZXQpIHtcbiAgICAgICAgLy8gc29ja2V0IG9iamVjdCBpcyBzZXQgdXAgYnV0IG5vdCB5ZXQgY29ubmVjdGVkXG4gICAgICAgIHRoaXMuX3NvY2tldCA9IHRoaXMub3B0aW9ucy5zb2NrZXQ7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICB0aGlzLl9zb2NrZXQuY29ubmVjdCh0aGlzLnBvcnQsIHRoaXMuaG9zdCwgdGhpcy5fb25Db25uZWN0LmJpbmQodGhpcykpO1xuICAgICAgICB9IGNhdGNoIChFKSB7XG4gICAgICAgICAgICByZXR1cm4gc2V0SW1tZWRpYXRlKHRoaXMuX29uRXJyb3IuYmluZCh0aGlzLCBFLCAnRUNPTk5FQ1RJT04nKSk7XG4gICAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHRoaXMuc2VjdXJlQ29ubmVjdGlvbikge1xuICAgICAgICAvLyBjb25uZWN0IHVzaW5nIHRsc1xuICAgICAgICBpZiAodGhpcy5vcHRpb25zLnRscykge1xuICAgICAgICAgICAgT2JqZWN0LmtleXModGhpcy5vcHRpb25zLnRscykuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgICAgICAgICAgb3B0c1trZXldID0gdGhpcy5vcHRpb25zLnRsc1trZXldO1xuICAgICAgICAgICAgfS5iaW5kKHRoaXMpKTtcbiAgICAgICAgfVxuICAgICAgICB0cnkge1xuICAgICAgICAgICAgdGhpcy5fc29ja2V0ID0gdGxzLmNvbm5lY3QodGhpcy5wb3J0LCB0aGlzLmhvc3QsIG9wdHMsIHRoaXMuX29uQ29ubmVjdC5iaW5kKHRoaXMpKTtcbiAgICAgICAgfSBjYXRjaCAoRSkge1xuICAgICAgICAgICAgcmV0dXJuIHNldEltbWVkaWF0ZSh0aGlzLl9vbkVycm9yLmJpbmQodGhpcywgRSwgJ0VDT05ORUNUSU9OJykpO1xuICAgICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgICAgLy8gY29ubmVjdCB1c2luZyBwbGFpbnRleHRcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHRoaXMuX3NvY2tldCA9IG5ldC5jb25uZWN0KG9wdHMsIHRoaXMuX29uQ29ubmVjdC5iaW5kKHRoaXMpKTtcbiAgICAgICAgfSBjYXRjaCAoRSkge1xuICAgICAgICAgICAgcmV0dXJuIHNldEltbWVkaWF0ZSh0aGlzLl9vbkVycm9yLmJpbmQodGhpcywgRSwgJ0VDT05ORUNUSU9OJykpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgdGhpcy5fY29ubmVjdGlvblRpbWVvdXQgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5fb25FcnJvcignQ29ubmVjdGlvbiB0aW1lb3V0JywgJ0VUSU1FRE9VVCcpO1xuICAgIH0uYmluZCh0aGlzKSwgdGhpcy5vcHRpb25zLmNvbm5lY3Rpb25UaW1lb3V0IHx8IDYwICogMTAwMCk7XG5cbiAgICB0aGlzLl9zb2NrZXQub24oJ2Vycm9yJywgdGhpcy5fb25FcnJvci5iaW5kKHRoaXMpKTtcbn07XG5cbi8qKlxuICogU2VuZHMgUVVJVFxuICovXG5TTVRQQ29ubmVjdGlvbi5wcm90b3R5cGUucXVpdCA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLl9zZW5kQ29tbWFuZCgnUVVJVCcpO1xuICAgIHRoaXMuX2N1cnJlbnRBY3Rpb24gPSB0aGlzLmNsb3NlO1xufTtcblxuLyoqXG4gKiBDbG9zZXMgdGhlIGNvbm5lY3Rpb24gdG8gdGhlIHNlcnZlclxuICovXG5TTVRQQ29ubmVjdGlvbi5wcm90b3R5cGUuY2xvc2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgY2xlYXJUaW1lb3V0KHRoaXMuX2Nvbm5lY3Rpb25UaW1lb3V0KTtcbiAgICBjbGVhclRpbWVvdXQodGhpcy5fZ3JlZXRpbmdUaW1lb3V0KTtcblxuICAgIC8vIGFsbG93IHRvIHJ1biB0aGlzIGZ1bmN0aW9uIG9ubHkgb25jZVxuICAgIGlmICh0aGlzLl9jbG9zaW5nKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5fY2xvc2luZyA9IHRydWU7XG5cbiAgICB2YXIgY2xvc2VNZXRob2QgPSAnZW5kJztcblxuICAgIGlmICh0aGlzLnN0YWdlID09PSAnaW5pdCcpIHtcbiAgICAgICAgLy8gQ2xvc2UgdGhlIHNvY2tldCBpbW1lZGlhdGVseSB3aGVuIGNvbm5lY3Rpb24gdGltZWQgb3V0XG4gICAgICAgIGNsb3NlTWV0aG9kID0gJ2Rlc3Ryb3knO1xuICAgIH1cblxuICAgIHRoaXMubG9nZ2VyLmRlYnVnKCdbJXNdIENsb3NpbmcgY29ubmVjdGlvbiB0byB0aGUgc2VydmVyIHVzaW5nIFwiJXNcIicsIHRoaXMuaWQsIGNsb3NlTWV0aG9kKTtcblxuICAgIHZhciBzb2NrZXQgPSB0aGlzLl9zb2NrZXQgJiYgdGhpcy5fc29ja2V0LnNvY2tldCB8fCB0aGlzLl9zb2NrZXQ7XG5cbiAgICBpZiAoc29ja2V0ICYmICFzb2NrZXQuZGVzdHJveWVkKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICB0aGlzLl9zb2NrZXRbY2xvc2VNZXRob2RdKCk7XG4gICAgICAgIH0gY2F0Y2ggKEUpIHtcbiAgICAgICAgICAgIC8vIGp1c3QgaWdub3JlXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICB0aGlzLl9kZXN0cm95KCk7XG59O1xuXG4vKipcbiAqIEF1dGhlbnRpY2F0ZSB1c2VyXG4gKi9cblNNVFBDb25uZWN0aW9uLnByb3RvdHlwZS5sb2dpbiA9IGZ1bmN0aW9uIChhdXRoRGF0YSwgY2FsbGJhY2spIHtcbiAgICB0aGlzLl9hdXRoID0gYXV0aERhdGEgfHwge307XG4gICAgdGhpcy5fdXNlciA9IHRoaXMuX2F1dGgueG9hdXRoMiAmJiB0aGlzLl9hdXRoLnhvYXV0aDIub3B0aW9ucyAmJiB0aGlzLl9hdXRoLnhvYXV0aDIub3B0aW9ucy51c2VyIHx8IHRoaXMuX2F1dGgudXNlciB8fCAnJztcblxuICAgIHZhciBhdXRoTWV0aG9kO1xuICAgIGlmICh0aGlzLm9wdGlvbnMuYXV0aE1ldGhvZCkge1xuICAgICAgICBhdXRoTWV0aG9kID0gdGhpcy5vcHRpb25zLmF1dGhNZXRob2QudG9VcHBlckNhc2UoKS50cmltKCk7XG4gICAgfSBlbHNlIGlmICh0aGlzLl9hdXRoLnhvYXV0aDIgJiYgdGhpcy5fc3VwcG9ydGVkQXV0aC5pbmRleE9mKCdYT0FVVEgyJykgPj0gMCkge1xuICAgICAgICBhdXRoTWV0aG9kID0gJ1hPQVVUSDInO1xuICAgIH0gZWxzZSBpZiAodGhpcy5fYXV0aC5kb21haW4gJiYgdGhpcy5fc3VwcG9ydGVkQXV0aC5pbmRleE9mKCdOVExNJykgPj0gMCkge1xuICAgICAgICBhdXRoTWV0aG9kID0gJ05UTE0nO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIHVzZSBmaXJzdCBzdXBwb3J0ZWRcbiAgICAgICAgYXV0aE1ldGhvZCA9ICh0aGlzLl9zdXBwb3J0ZWRBdXRoWzBdIHx8ICdQTEFJTicpLnRvVXBwZXJDYXNlKCkudHJpbSgpO1xuICAgIH1cblxuICAgIHN3aXRjaCAoYXV0aE1ldGhvZCkge1xuICAgICAgICBjYXNlICdYT0FVVEgyJzpcbiAgICAgICAgICAgIHRoaXMuX2hhbmRsZVhPYXV0aDJUb2tlbihmYWxzZSwgY2FsbGJhY2spO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBjYXNlICdMT0dJTic6XG4gICAgICAgICAgICB0aGlzLl9jdXJyZW50QWN0aW9uID0gZnVuY3Rpb24gKHN0cikge1xuICAgICAgICAgICAgICAgIHRoaXMuX2FjdGlvbkFVVEhfTE9HSU5fVVNFUihzdHIsIGNhbGxiYWNrKTtcbiAgICAgICAgICAgIH0uYmluZCh0aGlzKTtcbiAgICAgICAgICAgIHRoaXMuX3NlbmRDb21tYW5kKCdBVVRIIExPR0lOJyk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGNhc2UgJ1BMQUlOJzpcbiAgICAgICAgICAgIHRoaXMuX2N1cnJlbnRBY3Rpb24gPSBmdW5jdGlvbiAoc3RyKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fYWN0aW9uQVVUSENvbXBsZXRlKHN0ciwgY2FsbGJhY2spO1xuICAgICAgICAgICAgfS5iaW5kKHRoaXMpO1xuICAgICAgICAgICAgdGhpcy5fc2VuZENvbW1hbmQoJ0FVVEggUExBSU4gJyArIG5ldyBCdWZmZXIoXG4gICAgICAgICAgICAgICAgLy90aGlzLl9hdXRoLnVzZXIrJ1xcdTAwMDAnK1xuICAgICAgICAgICAgICAgICdcXHUwMDAwJyArIC8vIHNraXAgYXV0aG9yaXphdGlvbiBpZGVudGl0eSBhcyBpdCBjYXVzZXMgcHJvYmxlbXMgd2l0aCBzb21lIHNlcnZlcnNcbiAgICAgICAgICAgICAgICB0aGlzLl9hdXRoLnVzZXIgKyAnXFx1MDAwMCcgK1xuICAgICAgICAgICAgICAgIHRoaXMuX2F1dGgucGFzcywgJ3V0Zi04JykudG9TdHJpbmcoJ2Jhc2U2NCcpKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgY2FzZSAnQ1JBTS1NRDUnOlxuICAgICAgICAgICAgdGhpcy5fY3VycmVudEFjdGlvbiA9IGZ1bmN0aW9uIChzdHIpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9hY3Rpb25BVVRIX0NSQU1fTUQ1KHN0ciwgY2FsbGJhY2spO1xuICAgICAgICAgICAgfS5iaW5kKHRoaXMpO1xuICAgICAgICAgICAgdGhpcy5fc2VuZENvbW1hbmQoJ0FVVEggQ1JBTS1NRDUnKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgY2FzZSAnTlRMTSc6XG4gICAgICAgICAgICB0aGlzLl9jdXJyZW50QWN0aW9uID0gZnVuY3Rpb24gKHN0cikge1xuICAgICAgICAgICAgICAgIHRoaXMuX2FjdGlvbkFVVEhfTlRMTV9UWVBFMShzdHIsIGNhbGxiYWNrKTtcbiAgICAgICAgICAgIH0uYmluZCh0aGlzKTtcbiAgICAgICAgICAgIHRoaXMuX3NlbmRDb21tYW5kKCdBVVRIICcgKyBudGxtLmNyZWF0ZVR5cGUxTWVzc2FnZSh7XG4gICAgICAgICAgICAgICAgZG9tYWluOiB0aGlzLl9hdXRoLmRvbWFpbiB8fCAnJyxcbiAgICAgICAgICAgICAgICB3b3Jrc3RhdGlvbjogdGhpcy5fYXV0aC53b3Jrc3RhdGlvbiB8fCAnJ1xuICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHJldHVybiBjYWxsYmFjayh0aGlzLl9mb3JtYXRFcnJvcignVW5rbm93biBhdXRoZW50aWNhdGlvbiBtZXRob2QgXCInICsgYXV0aE1ldGhvZCArICdcIicsICdFQVVUSCcpKTtcbn07XG5cbi8qKlxuICogU2VuZHMgYSBtZXNzYWdlXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IGVudmVsb3BlIEVudmVsb3BlIG9iamVjdCwge2Zyb206IGFkZHIsIHRvOiBbYWRkcl19XG4gKiBAcGFyYW0ge09iamVjdH0gbWVzc2FnZSBTdHJpbmcsIEJ1ZmZlciBvciBhIFN0cmVhbVxuICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgQ2FsbGJhY2sgdG8gcmV0dXJuIG9uY2Ugc2VuZGluZyBpcyBjb21wbGV0ZWRcbiAqL1xuU01UUENvbm5lY3Rpb24ucHJvdG90eXBlLnNlbmQgPSBmdW5jdGlvbiAoZW52ZWxvcGUsIG1lc3NhZ2UsIGRvbmUpIHtcbiAgICBpZiAoIW1lc3NhZ2UpIHtcbiAgICAgICAgcmV0dXJuIGRvbmUodGhpcy5fZm9ybWF0RXJyb3IoJ0VtcHR5IG1lc3NhZ2UnLCAnRU1FU1NBR0UnKSk7XG4gICAgfVxuXG4gICAgLy8gZW5zdXJlIHRoYXQgY2FsbGJhY2sgaXMgb25seSBjYWxsZWQgb25jZVxuICAgIHZhciByZXR1cm5lZCA9IGZhbHNlO1xuICAgIHZhciBjYWxsYmFjayA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHJldHVybmVkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuZWQgPSB0cnVlO1xuXG4gICAgICAgIGRvbmUuYXBwbHkobnVsbCwgQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzKSk7XG4gICAgfTtcblxuICAgIGlmICh0eXBlb2YgbWVzc2FnZS5vbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBtZXNzYWdlLm9uKCdlcnJvcicsIGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgICAgIHJldHVybiBjYWxsYmFjayh0aGlzLl9mb3JtYXRFcnJvcihlcnIsICdFU1RSRUFNJykpO1xuICAgICAgICB9LmJpbmQodGhpcykpO1xuICAgIH1cblxuICAgIHRoaXMuX3NldEVudmVsb3BlKGVudmVsb3BlLCBmdW5jdGlvbiAoZXJyLCBpbmZvKSB7XG4gICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgIHJldHVybiBjYWxsYmFjayhlcnIpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBzdHJlYW0gPSB0aGlzLl9jcmVhdGVTZW5kU3RyZWFtKGZ1bmN0aW9uIChlcnIsIHN0cikge1xuICAgICAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgICAgIHJldHVybiBjYWxsYmFjayhlcnIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaW5mby5yZXNwb25zZSA9IHN0cjtcbiAgICAgICAgICAgIHJldHVybiBjYWxsYmFjayhudWxsLCBpbmZvKTtcbiAgICAgICAgfSk7XG4gICAgICAgIGlmICh0eXBlb2YgbWVzc2FnZS5waXBlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBtZXNzYWdlLnBpcGUoc3RyZWFtKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHN0cmVhbS53cml0ZShtZXNzYWdlKTtcbiAgICAgICAgICAgIHN0cmVhbS5lbmQoKTtcbiAgICAgICAgfVxuXG4gICAgfS5iaW5kKHRoaXMpKTtcbn07XG5cbi8qKlxuICogQ29ubmVjdGlvbiBsaXN0ZW5lciB0aGF0IGlzIHJ1biB3aGVuIHRoZSBjb25uZWN0aW9uIHRvXG4gKiB0aGUgc2VydmVyIGlzIG9wZW5lZFxuICpcbiAqIEBldmVudFxuICovXG5TTVRQQ29ubmVjdGlvbi5wcm90b3R5cGUuX29uQ29ubmVjdCA9IGZ1bmN0aW9uICgpIHtcbiAgICBjbGVhclRpbWVvdXQodGhpcy5fY29ubmVjdGlvblRpbWVvdXQpO1xuXG4gICAgdGhpcy5sb2dnZXIuaW5mbygnWyVzXSAlcyBlc3RhYmxpc2hlZCB0byAlczolcycsIHRoaXMuaWQsIHRoaXMuc2VjdXJlID8gJ1NlY3VyZSBjb25uZWN0aW9uJyA6ICdDb25uZWN0aW9uJywgdGhpcy5fc29ja2V0LnJlbW90ZUFkZHJlc3MsIHRoaXMuX3NvY2tldC5yZW1vdGVQb3J0KTtcblxuICAgIGlmICh0aGlzLl9kZXN0cm95ZWQpIHtcbiAgICAgICAgLy8gQ29ubmVjdGlvbiB3YXMgZXN0YWJsaXNoZWQgYWZ0ZXIgd2UgYWxyZWFkeSBoYWQgY2FuY2VsZWQgaXRcbiAgICAgICAgdGhpcy5jbG9zZSgpO1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdGhpcy5zdGFnZSA9ICdjb25uZWN0ZWQnO1xuXG4gICAgLy8gY2xlYXIgZXhpc3RpbmcgbGlzdGVuZXJzIGZvciB0aGUgc29ja2V0XG4gICAgdGhpcy5fc29ja2V0LnJlbW92ZUFsbExpc3RlbmVycygnZGF0YScpO1xuICAgIHRoaXMuX3NvY2tldC5yZW1vdmVBbGxMaXN0ZW5lcnMoJ3RpbWVvdXQnKTtcbiAgICB0aGlzLl9zb2NrZXQucmVtb3ZlQWxsTGlzdGVuZXJzKCdjbG9zZScpO1xuICAgIHRoaXMuX3NvY2tldC5yZW1vdmVBbGxMaXN0ZW5lcnMoJ2VuZCcpO1xuXG4gICAgdGhpcy5fc29ja2V0Lm9uKCdkYXRhJywgdGhpcy5fb25EYXRhLmJpbmQodGhpcykpO1xuICAgIHRoaXMuX3NvY2tldC5vbmNlKCdjbG9zZScsIHRoaXMuX29uQ2xvc2UuYmluZCh0aGlzKSk7XG4gICAgdGhpcy5fc29ja2V0Lm9uY2UoJ2VuZCcsIHRoaXMuX29uRW5kLmJpbmQodGhpcykpO1xuXG4gICAgdGhpcy5fc29ja2V0LnNldFRpbWVvdXQodGhpcy5vcHRpb25zLnNvY2tldFRpbWVvdXQgfHwgKDEwICogNjAgKiAxMDAwKSk7IC8vIDEwIG1pbi5cbiAgICB0aGlzLl9zb2NrZXQub24oJ3RpbWVvdXQnLCB0aGlzLl9vblRpbWVvdXQuYmluZCh0aGlzKSk7XG5cbiAgICB0aGlzLl9ncmVldGluZ1RpbWVvdXQgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgLy8gaWYgc3RpbGwgd2FpdGluZyBmb3IgZ3JlZXRpbmcsIGdpdmUgdXBcbiAgICAgICAgaWYgKHRoaXMuX3NvY2tldCAmJiAhdGhpcy5fZGVzdHJveWVkICYmIHRoaXMuX2N1cnJlbnRBY3Rpb24gPT09IHRoaXMuX2FjdGlvbkdyZWV0aW5nKSB7XG4gICAgICAgICAgICB0aGlzLl9vbkVycm9yKCdHcmVldGluZyBuZXZlciByZWNlaXZlZCcsICdFVElNRURPVVQnKTtcbiAgICAgICAgfVxuICAgIH0uYmluZCh0aGlzKSwgdGhpcy5vcHRpb25zLmdyZWV0aW5nVGltZW91dCB8fCAxMDAwMCk7XG5cbiAgICB0aGlzLl9jdXJyZW50QWN0aW9uID0gdGhpcy5fYWN0aW9uR3JlZXRpbmc7XG5cbiAgICAvLyB3ZSBoYXZlIGEgJ2RhdGEnIGxpc3RlbmVyIHNldCB1cCBzbyByZXN1bWUgc29ja2V0IGlmIGl0IHdhcyBwYXVzZWRcbiAgICB0aGlzLl9zb2NrZXQucmVzdW1lKCk7XG59O1xuXG4vKipcbiAqICdkYXRhJyBsaXN0ZW5lciBmb3IgZGF0YSBjb21pbmcgZnJvbSB0aGUgc2VydmVyXG4gKlxuICogQGV2ZW50XG4gKiBAcGFyYW0ge0J1ZmZlcn0gY2h1bmsgRGF0YSBjaHVuayBjb21pbmcgZnJvbSB0aGUgc2VydmVyXG4gKi9cblNNVFBDb25uZWN0aW9uLnByb3RvdHlwZS5fb25EYXRhID0gZnVuY3Rpb24gKGNodW5rKSB7XG4gICAgaWYgKHRoaXMuX2Rlc3Ryb3llZCB8fCAhY2h1bmsgfHwgIWNodW5rLmxlbmd0aCkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIGRhdGEgPSAoY2h1bmsgfHwgJycpLnRvU3RyaW5nKCdiaW5hcnknKTtcbiAgICB2YXIgbGluZXMgPSAodGhpcy5fcmVtYWluZGVyICsgZGF0YSkuc3BsaXQoL1xccj9cXG4vKTtcbiAgICB2YXIgbGFzdGxpbmU7XG5cbiAgICB0aGlzLl9yZW1haW5kZXIgPSBsaW5lcy5wb3AoKTtcblxuICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBsaW5lcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICBpZiAodGhpcy5fcmVzcG9uc2VRdWV1ZS5sZW5ndGgpIHtcbiAgICAgICAgICAgIGxhc3RsaW5lID0gdGhpcy5fcmVzcG9uc2VRdWV1ZVt0aGlzLl9yZXNwb25zZVF1ZXVlLmxlbmd0aCAtIDFdO1xuICAgICAgICAgICAgaWYgKC9eXFxkK1xcLS8udGVzdChsYXN0bGluZS5zcGxpdCgnXFxuJykucG9wKCkpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fcmVzcG9uc2VRdWV1ZVt0aGlzLl9yZXNwb25zZVF1ZXVlLmxlbmd0aCAtIDFdICs9ICdcXG4nICsgbGluZXNbaV07XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fcmVzcG9uc2VRdWV1ZS5wdXNoKGxpbmVzW2ldKTtcbiAgICB9XG5cbiAgICB0aGlzLl9wcm9jZXNzUmVzcG9uc2UoKTtcbn07XG5cbi8qKlxuICogJ2Vycm9yJyBsaXN0ZW5lciBmb3IgdGhlIHNvY2tldFxuICpcbiAqIEBldmVudFxuICogQHBhcmFtIHtFcnJvcn0gZXJyIEVycm9yIG9iamVjdFxuICogQHBhcmFtIHtTdHJpbmd9IHR5cGUgRXJyb3IgbmFtZVxuICovXG5TTVRQQ29ubmVjdGlvbi5wcm90b3R5cGUuX29uRXJyb3IgPSBmdW5jdGlvbiAoZXJyLCB0eXBlLCBkYXRhKSB7XG4gICAgY2xlYXJUaW1lb3V0KHRoaXMuX2Nvbm5lY3Rpb25UaW1lb3V0KTtcbiAgICBjbGVhclRpbWVvdXQodGhpcy5fZ3JlZXRpbmdUaW1lb3V0KTtcblxuICAgIGlmICh0aGlzLl9kZXN0cm95ZWQpIHtcbiAgICAgICAgLy8ganVzdCBpZ25vcmUsIGFscmVhZHkgY2xvc2VkXG4gICAgICAgIC8vIHRoaXMgbWlnaHQgaGFwcGVuIHdoZW4gYSBzb2NrZXQgaXMgY2FuY2VsZWQgYmVjYXVzZSBvZiByZWFjaGVkIHRpbWVvdXRcbiAgICAgICAgLy8gYnV0IHRoZSBzb2NrZXQgdGltZW91dCBlcnJvciBpdHNlbGYgcmVjZWl2ZXMgb25seSBhZnRlclxuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgZXJyID0gdGhpcy5fZm9ybWF0RXJyb3IoZXJyLCB0eXBlLCBkYXRhKTtcblxuICAgIHRoaXMubG9nZ2VyLmVycm9yKCdbJXNdICVzJywgdGhpcy5pZCwgZXJyLm1lc3NhZ2UpO1xuXG4gICAgdGhpcy5lbWl0KCdlcnJvcicsIGVycik7XG4gICAgdGhpcy5jbG9zZSgpO1xufTtcblxuU01UUENvbm5lY3Rpb24ucHJvdG90eXBlLl9mb3JtYXRFcnJvciA9IGZ1bmN0aW9uIChtZXNzYWdlLCB0eXBlLCByZXNwb25zZSkge1xuICAgIHZhciBlcnI7XG5cbiAgICBpZiAoL0Vycm9yXFxdJC9pLnRlc3QoT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG1lc3NhZ2UpKSkge1xuICAgICAgICBlcnIgPSBtZXNzYWdlO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIGVyciA9IG5ldyBFcnJvcihtZXNzYWdlKTtcbiAgICB9XG5cbiAgICBpZiAodHlwZSAmJiB0eXBlICE9PSAnRXJyb3InKSB7XG4gICAgICAgIGVyci5jb2RlID0gdHlwZTtcbiAgICB9XG5cbiAgICBpZiAocmVzcG9uc2UpIHtcbiAgICAgICAgZXJyLnJlc3BvbnNlID0gcmVzcG9uc2U7XG4gICAgICAgIGVyci5tZXNzYWdlICs9ICc6ICcgKyByZXNwb25zZTtcbiAgICB9XG5cbiAgICB2YXIgcmVzcG9uc2VDb2RlID0gdHlwZW9mIHJlc3BvbnNlID09PSAnc3RyaW5nJyAmJiBOdW1iZXIoKHJlc3BvbnNlLm1hdGNoKC9eXFxkKy8pIHx8IFtdKVswXSkgfHwgZmFsc2U7XG4gICAgaWYgKHJlc3BvbnNlQ29kZSkge1xuICAgICAgICBlcnIucmVzcG9uc2VDb2RlID0gcmVzcG9uc2VDb2RlO1xuICAgIH1cblxuICAgIHJldHVybiBlcnI7XG59O1xuXG4vKipcbiAqICdjbG9zZScgbGlzdGVuZXIgZm9yIHRoZSBzb2NrZXRcbiAqXG4gKiBAZXZlbnRcbiAqL1xuU01UUENvbm5lY3Rpb24ucHJvdG90eXBlLl9vbkNsb3NlID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMubG9nZ2VyLmluZm8oJ1slc10gQ29ubmVjdGlvbiBjbG9zZWQnLCB0aGlzLmlkKTtcblxuICAgIGlmIChbdGhpcy5fYWN0aW9uR3JlZXRpbmcsIHRoaXMuY2xvc2VdLmluZGV4T2YodGhpcy5fY3VycmVudEFjdGlvbikgPCAwICYmICF0aGlzLl9kZXN0cm95ZWQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX29uRXJyb3IobmV3IEVycm9yKCdDb25uZWN0aW9uIGNsb3NlZCB1bmV4cGVjdGVkbHknKSwgJ0VDT05ORUNUSU9OJyk7XG4gICAgfVxuXG4gICAgdGhpcy5fZGVzdHJveSgpO1xufTtcblxuLyoqXG4gKiAnZW5kJyBsaXN0ZW5lciBmb3IgdGhlIHNvY2tldFxuICpcbiAqIEBldmVudFxuICovXG5TTVRQQ29ubmVjdGlvbi5wcm90b3R5cGUuX29uRW5kID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuX2Rlc3Ryb3koKTtcbn07XG5cbi8qKlxuICogJ3RpbWVvdXQnIGxpc3RlbmVyIGZvciB0aGUgc29ja2V0XG4gKlxuICogQGV2ZW50XG4gKi9cblNNVFBDb25uZWN0aW9uLnByb3RvdHlwZS5fb25UaW1lb3V0ID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLl9vbkVycm9yKG5ldyBFcnJvcignVGltZW91dCcpLCAnRVRJTUVET1VUJyk7XG59O1xuXG4vKipcbiAqIERlc3Ryb3lzIHRoZSBjbGllbnQsIGVtaXRzICdlbmQnXG4gKi9cblNNVFBDb25uZWN0aW9uLnByb3RvdHlwZS5fZGVzdHJveSA9IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAodGhpcy5fZGVzdHJveWVkKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5fZGVzdHJveWVkID0gdHJ1ZTtcbiAgICB0aGlzLmVtaXQoJ2VuZCcpO1xufTtcblxuLyoqXG4gKiBVcGdyYWRlcyB0aGUgY29ubmVjdGlvbiB0byBUTFNcbiAqXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayBDYWxsYmFjayBmdW5jdGlvbiB0byBydW4gd2hlbiB0aGUgY29ubmVjdGlvblxuICogICAgICAgIGhhcyBiZWVuIHNlY3VyZWRcbiAqL1xuU01UUENvbm5lY3Rpb24ucHJvdG90eXBlLl91cGdyYWRlQ29ubmVjdGlvbiA9IGZ1bmN0aW9uIChjYWxsYmFjaykge1xuICAgIC8vIGRvIG5vdCByZW1vdmUgYWxsIGxpc3RlbmVycyBvciBpdCBicmVha3Mgbm9kZSB2MC4xMCBhcyB0aGVyZSdzXG4gICAgLy8gYXBwYXJlbnRseSBhICdmaW5pc2gnIGV2ZW50IHNldCB0aGF0IHdvdWxkIGJlIGNsZWFyZWQgYXMgd2VsbFxuXG4gICAgLy8gd2UgY2FuIHNhZmVseSBrZWVwICdlcnJvcicsICdlbmQnLCAnY2xvc2UnIGV0Yy4gZXZlbnRzXG4gICAgdGhpcy5fc29ja2V0LnJlbW92ZUFsbExpc3RlbmVycygnZGF0YScpOyAvLyBpbmNvbWluZyBkYXRhIGlzIGdvaW5nIHRvIGJlIGdpYmJlcmlzaCBmcm9tIHRoaXMgcG9pbnQgb253YXJkc1xuICAgIHRoaXMuX3NvY2tldC5yZW1vdmVBbGxMaXN0ZW5lcnMoJ3RpbWVvdXQnKTsgLy8gdGltZW91dCB3aWxsIGJlIHJlLXNldCBmb3IgdGhlIG5ldyBzb2NrZXQgb2JqZWN0XG5cbiAgICB2YXIgc29ja2V0UGxhaW4gPSB0aGlzLl9zb2NrZXQ7XG4gICAgdmFyIG9wdHMgPSB7XG4gICAgICAgIHNvY2tldDogdGhpcy5fc29ja2V0LFxuICAgICAgICBob3N0OiB0aGlzLmhvc3RcbiAgICB9O1xuXG4gICAgT2JqZWN0LmtleXModGhpcy5vcHRpb25zLnRscyB8fCB7fSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgIG9wdHNba2V5XSA9IHRoaXMub3B0aW9ucy50bHNba2V5XTtcbiAgICB9LmJpbmQodGhpcykpO1xuXG4gICAgdGhpcy5fc29ja2V0ID0gdGxzLmNvbm5lY3Qob3B0cywgZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLnNlY3VyZSA9IHRydWU7XG4gICAgICAgIHRoaXMuX3NvY2tldC5vbignZGF0YScsIHRoaXMuX29uRGF0YS5iaW5kKHRoaXMpKTtcblxuICAgICAgICBzb2NrZXRQbGFpbi5yZW1vdmVBbGxMaXN0ZW5lcnMoJ2Nsb3NlJyk7XG4gICAgICAgIHNvY2tldFBsYWluLnJlbW92ZUFsbExpc3RlbmVycygnZW5kJyk7XG5cbiAgICAgICAgcmV0dXJuIGNhbGxiYWNrKG51bGwsIHRydWUpO1xuICAgIH0uYmluZCh0aGlzKSk7XG5cbiAgICB0aGlzLl9zb2NrZXQub24oJ2Vycm9yJywgdGhpcy5fb25FcnJvci5iaW5kKHRoaXMpKTtcbiAgICB0aGlzLl9zb2NrZXQub25jZSgnY2xvc2UnLCB0aGlzLl9vbkNsb3NlLmJpbmQodGhpcykpO1xuICAgIHRoaXMuX3NvY2tldC5vbmNlKCdlbmQnLCB0aGlzLl9vbkVuZC5iaW5kKHRoaXMpKTtcblxuICAgIHRoaXMuX3NvY2tldC5zZXRUaW1lb3V0KHRoaXMub3B0aW9ucy5zb2NrZXRUaW1lb3V0IHx8ICgxMCAqIDYwICogMTAwMCkpOyAvLyAxMCBtaW4uXG4gICAgdGhpcy5fc29ja2V0Lm9uKCd0aW1lb3V0JywgdGhpcy5fb25UaW1lb3V0LmJpbmQodGhpcykpO1xuXG4gICAgLy8gcmVzdW1lIGluIGNhc2UgdGhlIHNvY2tldCB3YXMgcGF1c2VkXG4gICAgc29ja2V0UGxhaW4ucmVzdW1lKCk7XG59O1xuXG4vKipcbiAqIFByb2Nlc3NlcyBxdWV1ZWQgcmVzcG9uc2VzIGZyb20gdGhlIHNlcnZlclxuICpcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gZm9yY2UgSWYgdHJ1ZSwgaWdub3JlcyBfcHJvY2Vzc2luZyBmbGFnXG4gKi9cblNNVFBDb25uZWN0aW9uLnByb3RvdHlwZS5fcHJvY2Vzc1Jlc3BvbnNlID0gZnVuY3Rpb24gKCkge1xuICAgIGlmICghdGhpcy5fcmVzcG9uc2VRdWV1ZS5sZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHZhciBzdHIgPSAodGhpcy5fcmVzcG9uc2VRdWV1ZS5zaGlmdCgpIHx8ICcnKS50b1N0cmluZygpO1xuXG4gICAgaWYgKC9eXFxkK1xcLS8udGVzdChzdHIuc3BsaXQoJ1xcbicpLnBvcCgpKSkge1xuICAgICAgICAvLyBrZWVwIHdhaXRpbmcgZm9yIHRoZSBmaW5hbCBwYXJ0IG9mIG11bHRpbGluZSByZXNwb25zZVxuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKHRoaXMub3B0aW9ucy5kZWJ1Zykge1xuICAgICAgICB0aGlzLmxvZ2dlci5kZWJ1ZygnWyVzXSBTOiAlcycsIHRoaXMuaWQsIHN0ci5yZXBsYWNlKC9cXHI/XFxuJC8sICcnKSk7XG4gICAgfVxuXG4gICAgaWYgKCFzdHIudHJpbSgpKSB7IC8vIHNraXAgdW5leHBlY3RlZCBlbXB0eSBsaW5lc1xuICAgICAgICBzZXRJbW1lZGlhdGUodGhpcy5fcHJvY2Vzc1Jlc3BvbnNlLmJpbmQodGhpcywgdHJ1ZSkpO1xuICAgIH1cblxuICAgIHZhciBhY3Rpb24gPSB0aGlzLl9jdXJyZW50QWN0aW9uO1xuICAgIHRoaXMuX2N1cnJlbnRBY3Rpb24gPSBudWxsO1xuXG4gICAgaWYgKHR5cGVvZiBhY3Rpb24gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgYWN0aW9uLmNhbGwodGhpcywgc3RyKTtcbiAgICAgICAgc2V0SW1tZWRpYXRlKHRoaXMuX3Byb2Nlc3NSZXNwb25zZS5iaW5kKHRoaXMsIHRydWUpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gdGhpcy5fb25FcnJvcihuZXcgRXJyb3IoJ1VuZXhwZWN0ZWQgUmVzcG9uc2UnKSwgJ0VQUk9UT0NPTCcsIHN0cik7XG4gICAgfVxufTtcblxuLyoqXG4gKiBTZW5kIGEgY29tbWFuZCB0byB0aGUgc2VydmVyLCBhcHBlbmQgXFxyXFxuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHN0ciBTdHJpbmcgdG8gYmUgc2VudCB0byB0aGUgc2VydmVyXG4gKi9cblNNVFBDb25uZWN0aW9uLnByb3RvdHlwZS5fc2VuZENvbW1hbmQgPSBmdW5jdGlvbiAoc3RyKSB7XG4gICAgaWYgKHRoaXMuX2Rlc3Ryb3llZCkge1xuICAgICAgICAvLyBDb25uZWN0aW9uIGFscmVhZHkgY2xvc2VkLCBjYW4ndCBzZW5kIGFueSBtb3JlIGRhdGFcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmICh0aGlzLl9zb2NrZXQuZGVzdHJveWVkKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNsb3NlKCk7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMub3B0aW9ucy5kZWJ1Zykge1xuICAgICAgICB0aGlzLmxvZ2dlci5kZWJ1ZygnWyVzXSBDOiAlcycsIHRoaXMuaWQsIChzdHIgfHwgJycpLnRvU3RyaW5nKCkucmVwbGFjZSgvXFxyP1xcbiQvLCAnJykpO1xuICAgIH1cblxuICAgIHRoaXMuX3NvY2tldC53cml0ZShuZXcgQnVmZmVyKHN0ciArICdcXHJcXG4nLCAndXRmLTgnKSk7XG59O1xuXG4vKipcbiAqIEluaXRpYXRlcyBhIG5ldyBtZXNzYWdlIGJ5IHN1Ym1pdHRpbmcgZW52ZWxvcGUgZGF0YSwgc3RhcnRpbmcgd2l0aFxuICogTUFJTCBGUk9NOiBjb21tYW5kXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IGVudmVsb3BlIEVudmVsb3BlIG9iamVjdCBpbiB0aGUgZm9ybSBvZlxuICogICAgICAgIHtmcm9tOicuLi4nLCB0bzpbJy4uLiddfVxuICogICAgICAgIG9yXG4gKiAgICAgICAge2Zyb206e2FkZHJlc3M6Jy4uLicsbmFtZTonLi4uJ30sIHRvOlthZGRyZXNzOicuLi4nLG5hbWU6Jy4uLiddfVxuICovXG5TTVRQQ29ubmVjdGlvbi5wcm90b3R5cGUuX3NldEVudmVsb3BlID0gZnVuY3Rpb24gKGVudmVsb3BlLCBjYWxsYmFjaykge1xuICAgIHZhciBhcmdzID0gW107XG4gICAgdmFyIHVzZVNtdHBVdGY4ID0gZmFsc2U7XG5cbiAgICB0aGlzLl9lbnZlbG9wZSA9IGVudmVsb3BlIHx8IHt9O1xuICAgIHRoaXMuX2VudmVsb3BlLmZyb20gPSAodGhpcy5fZW52ZWxvcGUuZnJvbSAmJiB0aGlzLl9lbnZlbG9wZS5mcm9tLmFkZHJlc3MgfHwgdGhpcy5fZW52ZWxvcGUuZnJvbSB8fCAnJykudG9TdHJpbmcoKS50cmltKCk7XG5cbiAgICB0aGlzLl9lbnZlbG9wZS50byA9IFtdLmNvbmNhdCh0aGlzLl9lbnZlbG9wZS50byB8fCBbXSkubWFwKGZ1bmN0aW9uICh0bykge1xuICAgICAgICByZXR1cm4gKHRvICYmIHRvLmFkZHJlc3MgfHwgdG8gfHwgJycpLnRvU3RyaW5nKCkudHJpbSgpO1xuICAgIH0pO1xuXG4gICAgaWYgKCF0aGlzLl9lbnZlbG9wZS50by5sZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIGNhbGxiYWNrKHRoaXMuX2Zvcm1hdEVycm9yKCdObyByZWNpcGllbnRzIGRlZmluZWQnLCAnRUVOVkVMT1BFJykpO1xuICAgIH1cblxuICAgIGlmICh0aGlzLl9lbnZlbG9wZS5mcm9tICYmIC9bXFxyXFxuPD5dLy50ZXN0KHRoaXMuX2VudmVsb3BlLmZyb20pKSB7XG4gICAgICAgIHJldHVybiBjYWxsYmFjayh0aGlzLl9mb3JtYXRFcnJvcignSW52YWxpZCBzZW5kZXIgJyArIEpTT04uc3RyaW5naWZ5KHRoaXMuX2VudmVsb3BlLmZyb20pLCAnRUVOVkVMT1BFJykpO1xuICAgIH1cblxuICAgIC8vIGNoZWNrIGlmIHRoZSBzZW5kZXIgYWRkcmVzcyB1c2VzIG9ubHkgQVNDSUkgY2hhcmFjdGVycyxcbiAgICAvLyBvdGhlcndpc2UgcmVxdWlyZSB1c2FnZSBvZiBTTVRQVVRGOCBleHRlbnNpb25cbiAgICBpZiAoL1tcXHg4MC1cXHVGRkZGXS8udGVzdCh0aGlzLl9lbnZlbG9wZS5mcm9tKSkge1xuICAgICAgICB1c2VTbXRwVXRmOCA9IHRydWU7XG4gICAgfVxuXG4gICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IHRoaXMuX2VudmVsb3BlLnRvLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgIGlmICghdGhpcy5fZW52ZWxvcGUudG9baV0gfHwgL1tcXHJcXG48Pl0vLnRlc3QodGhpcy5fZW52ZWxvcGUudG9baV0pKSB7XG4gICAgICAgICAgICByZXR1cm4gY2FsbGJhY2sodGhpcy5fZm9ybWF0RXJyb3IoJ0ludmFsaWQgcmVjaXBpZW50ICcgKyBKU09OLnN0cmluZ2lmeSh0aGlzLl9lbnZlbG9wZS50b1tpXSksICdFRU5WRUxPUEUnKSk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBjaGVjayBpZiB0aGUgcmVjaXBpZW50cyBhZGRyZXNzZXMgdXNlIG9ubHkgQVNDSUkgY2hhcmFjdGVycyxcbiAgICAgICAgLy8gb3RoZXJ3aXNlIHJlcXVpcmUgdXNhZ2Ugb2YgU01UUFVURjggZXh0ZW5zaW9uXG4gICAgICAgIGlmICgvW1xceDgwLVxcdUZGRkZdLy50ZXN0KHRoaXMuX2VudmVsb3BlLnRvW2ldKSkge1xuICAgICAgICAgICAgdXNlU210cFV0ZjggPSB0cnVlO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gY2xvbmUgdGhlIHJlY2lwaWVudHMgYXJyYXkgZm9yIGxhdHRlciBtYW5pcHVsYXRpb25cbiAgICB0aGlzLl9lbnZlbG9wZS5yY3B0UXVldWUgPSBKU09OLnBhcnNlKEpTT04uc3RyaW5naWZ5KHRoaXMuX2VudmVsb3BlLnRvIHx8IFtdKSk7XG4gICAgdGhpcy5fZW52ZWxvcGUucmVqZWN0ZWQgPSBbXTtcbiAgICB0aGlzLl9lbnZlbG9wZS5hY2NlcHRlZCA9IFtdO1xuXG4gICAgdGhpcy5fY3VycmVudEFjdGlvbiA9IGZ1bmN0aW9uIChzdHIpIHtcbiAgICAgICAgdGhpcy5fYWN0aW9uTUFJTChzdHIsIGNhbGxiYWNrKTtcbiAgICB9LmJpbmQodGhpcyk7XG5cbiAgICAvLyBJZiB0aGUgc2VydmVyIHN1cHBvcnRzIFNNVFBVVEY4IGFuZCB0aGUgZW52ZWxvcGUgaW5jbHVkZXMgYW4gaW50ZXJuYXRpb25hbGl6ZWRcbiAgICAvLyBlbWFpbCBhZGRyZXNzIHRoZW4gYXBwZW5kIFNNVFBVVEY4IGtleXdvcmQgdG8gdGhlIE1BSUwgRlJPTSBjb21tYW5kXG4gICAgaWYgKHVzZVNtdHBVdGY4ICYmIHRoaXMuX3N1cHBvcnRlZEV4dGVuc2lvbnMuaW5kZXhPZignU01UUFVURjgnKSA+PSAwKSB7XG4gICAgICAgIGFyZ3MucHVzaCgnU01UUFVURjgnKTtcbiAgICB9XG5cbiAgICB0aGlzLl9zZW5kQ29tbWFuZCgnTUFJTCBGUk9NOjwnICsgKHRoaXMuX2VudmVsb3BlLmZyb20pICsgJz4nICsgKGFyZ3MubGVuZ3RoID8gJyAnICsgYXJncy5qb2luKCcgJykgOiAnJykpO1xufTtcblxuU01UUENvbm5lY3Rpb24ucHJvdG90eXBlLl9jcmVhdGVTZW5kU3RyZWFtID0gZnVuY3Rpb24gKGNhbGxiYWNrKSB7XG4gICAgdmFyIGRhdGFTdHJlYW0gPSBuZXcgRGF0YVN0cmVhbSgpO1xuICAgIHZhciBsb2dTdHJlYW07XG5cbiAgICB0aGlzLl9jdXJyZW50QWN0aW9uID0gZnVuY3Rpb24gKHN0cikge1xuICAgICAgICB0aGlzLl9hY3Rpb25TdHJlYW0oc3RyLCBjYWxsYmFjayk7XG4gICAgfS5iaW5kKHRoaXMpO1xuXG4gICAgZGF0YVN0cmVhbS5waXBlKHRoaXMuX3NvY2tldCwge1xuICAgICAgICBlbmQ6IGZhbHNlXG4gICAgfSk7XG5cbiAgICBpZiAodGhpcy5vcHRpb25zLmRlYnVnKSB7XG4gICAgICAgIGxvZ1N0cmVhbSA9IG5ldyBQYXNzVGhyb3VnaCgpO1xuICAgICAgICBsb2dTdHJlYW0ub24oJ3JlYWRhYmxlJywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIGNodW5rO1xuICAgICAgICAgICAgd2hpbGUgKChjaHVuayA9IGxvZ1N0cmVhbS5yZWFkKCkpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5sb2dnZXIuZGVidWcoJ1slc10gQzogJXMnLCB0aGlzLmlkLCBjaHVuay50b1N0cmluZygnYmluYXJ5JykucmVwbGFjZSgvXFxyP1xcbiQvLCAnJykpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LmJpbmQodGhpcykpO1xuICAgICAgICBkYXRhU3RyZWFtLnBpcGUobG9nU3RyZWFtKTtcbiAgICB9XG5cbiAgICBkYXRhU3RyZWFtLm9uY2UoJ2VuZCcsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5sb2dnZXIuaW5mbygnWyVzXSBDOiA8JXMgYnl0ZXMgZW5jb2RlZCBtaW1lIG1lc3NhZ2UgKHNvdXJjZSBzaXplICVzIGJ5dGVzKT4nLCB0aGlzLmlkLCBkYXRhU3RyZWFtLm91dEJ5dGVDb3VudCwgZGF0YVN0cmVhbS5pbkJ5dGVDb3VudCk7XG4gICAgfS5iaW5kKHRoaXMpKTtcblxuICAgIHJldHVybiBkYXRhU3RyZWFtO1xufTtcblxuLyoqIEFDVElPTlMgKiovXG5cbi8qKlxuICogV2lsbCBiZSBydW4gYWZ0ZXIgdGhlIGNvbm5lY3Rpb24gaXMgY3JlYXRlZCBhbmQgdGhlIHNlcnZlciBzZW5kc1xuICogYSBncmVldGluZy4gSWYgdGhlIGluY29taW5nIG1lc3NhZ2Ugc3RhcnRzIHdpdGggMjIwIGluaXRpYXRlXG4gKiBTTVRQIHNlc3Npb24gYnkgc2VuZGluZyBFSExPIGNvbW1hbmRcbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gc3RyIE1lc3NhZ2UgZnJvbSB0aGUgc2VydmVyXG4gKi9cblNNVFBDb25uZWN0aW9uLnByb3RvdHlwZS5fYWN0aW9uR3JlZXRpbmcgPSBmdW5jdGlvbiAoc3RyKSB7XG4gICAgY2xlYXJUaW1lb3V0KHRoaXMuX2dyZWV0aW5nVGltZW91dCk7XG5cbiAgICBpZiAoc3RyLnN1YnN0cigwLCAzKSAhPT0gJzIyMCcpIHtcbiAgICAgICAgdGhpcy5fb25FcnJvcihuZXcgRXJyb3IoJ0ludmFsaWQgZ3JlZXRpbmcgZnJvbSBzZXJ2ZXI6XFxuJyArIHN0ciksICdFUFJPVE9DT0wnLCBzdHIpO1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKHRoaXMub3B0aW9ucy5sbXRwKSB7XG4gICAgICAgIHRoaXMuX2N1cnJlbnRBY3Rpb24gPSB0aGlzLl9hY3Rpb25MSExPO1xuICAgICAgICB0aGlzLl9zZW5kQ29tbWFuZCgnTEhMTyAnICsgdGhpcy5uYW1lKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLl9jdXJyZW50QWN0aW9uID0gdGhpcy5fYWN0aW9uRUhMTztcbiAgICAgICAgdGhpcy5fc2VuZENvbW1hbmQoJ0VITE8gJyArIHRoaXMubmFtZSk7XG4gICAgfVxufTtcblxuLyoqXG4gKiBIYW5kbGVzIHNlcnZlciByZXNwb25zZSBmb3IgTEhMTyBjb21tYW5kLiBJZiBpdCB5aWVsZGVkIGluXG4gKiBlcnJvciwgZW1pdCAnZXJyb3InLCBvdGhlcndpc2UgdHJlYXQgdGhpcyBhcyBhbiBFSExPIHJlc3BvbnNlXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHN0ciBNZXNzYWdlIGZyb20gdGhlIHNlcnZlclxuICovXG5TTVRQQ29ubmVjdGlvbi5wcm90b3R5cGUuX2FjdGlvbkxITE8gPSBmdW5jdGlvbiAoc3RyKSB7XG4gICAgaWYgKHN0ci5jaGFyQXQoMCkgIT09ICcyJykge1xuICAgICAgICB0aGlzLl9vbkVycm9yKG5ldyBFcnJvcignSW52YWxpZCByZXNwb25zZSBmb3IgTEhMTzpcXG4nICsgc3RyKSwgJ0VQUk9UT0NPTCcsIHN0cik7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB0aGlzLl9hY3Rpb25FSExPKHN0cik7XG59O1xuXG4vKipcbiAqIEhhbmRsZXMgc2VydmVyIHJlc3BvbnNlIGZvciBFSExPIGNvbW1hbmQuIElmIGl0IHlpZWxkZWQgaW5cbiAqIGVycm9yLCB0cnkgSEVMTyBpbnN0ZWFkLCBvdGhlcndpc2UgaW5pdGlhdGUgVExTIG5lZ290aWF0aW9uXG4gKiBpZiBTVEFSVFRMUyBpcyBzdXBwb3J0ZWQgYnkgdGhlIHNlcnZlciBvciBtb3ZlIGludG8gdGhlXG4gKiBhdXRoZW50aWNhdGlvbiBwaGFzZS5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gc3RyIE1lc3NhZ2UgZnJvbSB0aGUgc2VydmVyXG4gKi9cblNNVFBDb25uZWN0aW9uLnByb3RvdHlwZS5fYWN0aW9uRUhMTyA9IGZ1bmN0aW9uIChzdHIpIHtcbiAgICBpZiAoc3RyLnN1YnN0cigwLCAzKSA9PT0gJzQyMScpIHtcbiAgICAgICAgdGhpcy5fb25FcnJvcihuZXcgRXJyb3IoJ1NlcnZlciB0ZXJtaW5hdGVzIGNvbm5lY3Rpb246XFxuJyArIHN0ciksICdFQ09OTkVDVElPTicsIHN0cik7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAoc3RyLmNoYXJBdCgwKSAhPT0gJzInKSB7XG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMucmVxdWlyZVRMUykge1xuICAgICAgICAgICAgdGhpcy5fb25FcnJvcihuZXcgRXJyb3IoJ0VITE8gZmFpbGVkIGJ1dCBIRUxPIGRvZXMgbm90IHN1cHBvcnQgcmVxdWlyZWQgU1RBUlRUTFM6XFxuJyArIHN0ciksICdFQ09OTkVDVElPTicsIHN0cik7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICAvLyBUcnkgSEVMTyBpbnN0ZWFkXG4gICAgICAgIHRoaXMuX2N1cnJlbnRBY3Rpb24gPSB0aGlzLl9hY3Rpb25IRUxPO1xuICAgICAgICB0aGlzLl9zZW5kQ29tbWFuZCgnSEVMTyAnICsgdGhpcy5uYW1lKTtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIERldGVjdCBpZiB0aGUgc2VydmVyIHN1cHBvcnRzIFNUQVJUVExTXG4gICAgaWYgKCF0aGlzLnNlY3VyZSAmJiAhdGhpcy5vcHRpb25zLmlnbm9yZVRMUyAmJiAoL1sgXFwtXVNUQVJUVExTXFxiL21pLnRlc3Qoc3RyKSB8fCB0aGlzLm9wdGlvbnMucmVxdWlyZVRMUykpIHtcbiAgICAgICAgdGhpcy5fc2VuZENvbW1hbmQoJ1NUQVJUVExTJyk7XG4gICAgICAgIHRoaXMuX2N1cnJlbnRBY3Rpb24gPSB0aGlzLl9hY3Rpb25TVEFSVFRMUztcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIERldGVjdCBpZiB0aGUgc2VydmVyIHN1cHBvcnRzIFNNVFBVVEY4XG4gICAgaWYgKC9bIFxcLV1TTVRQVVRGOFxcYi9taS50ZXN0KHN0cikpIHtcbiAgICAgICAgdGhpcy5fc3VwcG9ydGVkRXh0ZW5zaW9ucy5wdXNoKCdTTVRQVVRGOCcpO1xuICAgIH1cblxuICAgIC8vIERldGVjdCBpZiB0aGUgc2VydmVyIHN1cHBvcnRzIFBMQUlOIGF1dGhcbiAgICBpZiAoc3RyLm1hdGNoKC9BVVRIKD86KFxccyt8PSlbXlxcbl0qXFxzK3xcXHMrfD0pUExBSU4vaSkpIHtcbiAgICAgICAgdGhpcy5fc3VwcG9ydGVkQXV0aC5wdXNoKCdQTEFJTicpO1xuICAgIH1cblxuICAgIC8vIERldGVjdCBpZiB0aGUgc2VydmVyIHN1cHBvcnRzIExPR0lOIGF1dGhcbiAgICBpZiAoc3RyLm1hdGNoKC9BVVRIKD86KFxccyt8PSlbXlxcbl0qXFxzK3xcXHMrfD0pTE9HSU4vaSkpIHtcbiAgICAgICAgdGhpcy5fc3VwcG9ydGVkQXV0aC5wdXNoKCdMT0dJTicpO1xuICAgIH1cblxuICAgIC8vIERldGVjdCBpZiB0aGUgc2VydmVyIHN1cHBvcnRzIENSQU0tTUQ1IGF1dGhcbiAgICBpZiAoc3RyLm1hdGNoKC9BVVRIKD86KFxccyt8PSlbXlxcbl0qXFxzK3xcXHMrfD0pQ1JBTS1NRDUvaSkpIHtcbiAgICAgICAgdGhpcy5fc3VwcG9ydGVkQXV0aC5wdXNoKCdDUkFNLU1ENScpO1xuICAgIH1cblxuICAgIC8vIERldGVjdCBpZiB0aGUgc2VydmVyIHN1cHBvcnRzIFhPQVVUSDIgYXV0aFxuICAgIGlmIChzdHIubWF0Y2goL0FVVEgoPzooXFxzK3w9KVteXFxuXSpcXHMrfFxccyt8PSlYT0FVVEgyL2kpKSB7XG4gICAgICAgIHRoaXMuX3N1cHBvcnRlZEF1dGgucHVzaCgnWE9BVVRIMicpO1xuICAgIH1cblxuICAgIHRoaXMuZW1pdCgnY29ubmVjdCcpO1xufTtcblxuLyoqXG4gKiBIYW5kbGVzIHNlcnZlciByZXNwb25zZSBmb3IgSEVMTyBjb21tYW5kLiBJZiBpdCB5aWVsZGVkIGluXG4gKiBlcnJvciwgZW1pdCAnZXJyb3InLCBvdGhlcndpc2UgbW92ZSBpbnRvIHRoZSBhdXRoZW50aWNhdGlvbiBwaGFzZS5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gc3RyIE1lc3NhZ2UgZnJvbSB0aGUgc2VydmVyXG4gKi9cblNNVFBDb25uZWN0aW9uLnByb3RvdHlwZS5fYWN0aW9uSEVMTyA9IGZ1bmN0aW9uIChzdHIpIHtcbiAgICBpZiAoc3RyLmNoYXJBdCgwKSAhPT0gJzInKSB7XG4gICAgICAgIHRoaXMuX29uRXJyb3IobmV3IEVycm9yKCdJbnZhbGlkIHJlc3BvbnNlIGZvciBFSExPL0hFTE86XFxuJyArIHN0ciksICdFUFJPVE9DT0wnLCBzdHIpO1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdGhpcy5lbWl0KCdjb25uZWN0Jyk7XG59O1xuXG4vKipcbiAqIEhhbmRsZXMgc2VydmVyIHJlc3BvbnNlIGZvciBTVEFSVFRMUyBjb21tYW5kLiBJZiB0aGVyZSdzIGFuIGVycm9yXG4gKiB0cnkgSEVMTyBpbnN0ZWFkLCBvdGhlcndpc2UgaW5pdGlhdGUgVExTIHVwZ3JhZGUuIElmIHRoZSB1cGdyYWRlXG4gKiBzdWNjZWVkZXMgcmVzdGFydCB0aGUgRUhMT1xuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBzdHIgTWVzc2FnZSBmcm9tIHRoZSBzZXJ2ZXJcbiAqL1xuU01UUENvbm5lY3Rpb24ucHJvdG90eXBlLl9hY3Rpb25TVEFSVFRMUyA9IGZ1bmN0aW9uIChzdHIpIHtcbiAgICBpZiAoc3RyLmNoYXJBdCgwKSAhPT0gJzInKSB7XG4gICAgICAgIHRoaXMuX29uRXJyb3IobmV3IEVycm9yKCdFcnJvciB1cGdyYWRpbmcgY29ubmVjdGlvbiB3aXRoIFNUQVJUVExTJyksICdFVExTJywgc3RyKTtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHRoaXMuX3VwZ3JhZGVDb25uZWN0aW9uKGZ1bmN0aW9uIChlcnIsIHNlY3VyZWQpIHtcbiAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgdGhpcy5fb25FcnJvcihuZXcgRXJyb3IoJ0Vycm9yIGluaXRpYXRpbmcgVExTIC0gJyArIChlcnIubWVzc2FnZSB8fCBlcnIpKSwgJ0VUTFMnKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMubG9nZ2VyLmluZm8oJ1slc10gQ29ubmVjdGlvbiB1cGdyYWRlZCB3aXRoIFNUQVJUVExTJywgdGhpcy5pZCk7XG5cbiAgICAgICAgaWYgKHNlY3VyZWQpIHtcbiAgICAgICAgICAgIC8vIHJlc3RhcnQgc2Vzc2lvblxuICAgICAgICAgICAgdGhpcy5fY3VycmVudEFjdGlvbiA9IHRoaXMuX2FjdGlvbkVITE87XG4gICAgICAgICAgICB0aGlzLl9zZW5kQ29tbWFuZCgnRUhMTyAnICsgdGhpcy5uYW1lKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuZW1pdCgnY29ubmVjdCcpO1xuICAgICAgICB9XG4gICAgfS5iaW5kKHRoaXMpKTtcbn07XG5cbi8qKlxuICogSGFuZGxlIHRoZSByZXNwb25zZSBmb3IgQVVUSCBMT0dJTiBjb21tYW5kLiBXZSBhcmUgZXhwZWN0aW5nXG4gKiAnMzM0IFZYTmxjbTVoYldVNicgKGJhc2U2NCBmb3IgJ1VzZXJuYW1lOicpLiBEYXRhIHRvIGJlIHNlbnQgYXNcbiAqIHJlc3BvbnNlIG5lZWRzIHRvIGJlIGJhc2U2NCBlbmNvZGVkIHVzZXJuYW1lLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBzdHIgTWVzc2FnZSBmcm9tIHRoZSBzZXJ2ZXJcbiAqL1xuU01UUENvbm5lY3Rpb24ucHJvdG90eXBlLl9hY3Rpb25BVVRIX0xPR0lOX1VTRVIgPSBmdW5jdGlvbiAoc3RyLCBjYWxsYmFjaykge1xuICAgIGlmIChzdHIgIT09ICczMzQgVlhObGNtNWhiV1U2Jykge1xuICAgICAgICBjYWxsYmFjayh0aGlzLl9mb3JtYXRFcnJvcignSW52YWxpZCBsb2dpbiBzZXF1ZW5jZSB3aGlsZSB3YWl0aW5nIGZvciBcIjMzNCBWWE5sY201aGJXVTZcIicsICdFQVVUSCcsIHN0cikpO1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdGhpcy5fY3VycmVudEFjdGlvbiA9IGZ1bmN0aW9uIChzdHIpIHtcbiAgICAgICAgdGhpcy5fYWN0aW9uQVVUSF9MT0dJTl9QQVNTKHN0ciwgY2FsbGJhY2spO1xuICAgIH0uYmluZCh0aGlzKTtcblxuICAgIHRoaXMuX3NlbmRDb21tYW5kKG5ldyBCdWZmZXIodGhpcy5fYXV0aC51c2VyICsgJycsICd1dGYtOCcpLnRvU3RyaW5nKCdiYXNlNjQnKSk7XG59O1xuXG4vKipcbiAqIEhhbmRsZSB0aGUgcmVzcG9uc2UgZm9yIEFVVEggTlRMTSwgd2hpY2ggc2hvdWxkIGJlIGFcbiAqICczMzQgPGNoYWxsZW5nZSBzdHJpbmc+Jy4gU2VlIGh0dHA6Ly9kYXZlbnBvcnQuc291cmNlZm9yZ2UubmV0L250bG0uaHRtbFxuICogV2UgYWxyZWFkeSBzZW50IHRoZSBUeXBlMSBtZXNzYWdlLCB0aGUgY2hhbGxlbmdlIGlzIGEgVHlwZTIgbWVzc2FnZSwgd2VcbiAqIG5lZWQgdG8gcmVzcG9uZCB3aXRoIGEgVHlwZTMgbWVzc2FnZS5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gc3RyIE1lc3NhZ2UgZnJvbSB0aGUgc2VydmVyXG4gKi9cblNNVFBDb25uZWN0aW9uLnByb3RvdHlwZS5fYWN0aW9uQVVUSF9OVExNX1RZUEUxID0gZnVuY3Rpb24gKHN0ciwgY2FsbGJhY2spIHtcbiAgICB2YXIgY2hhbGxlbmdlTWF0Y2ggPSBzdHIubWF0Y2goL14zMzRcXHMrKC4rKSQvKTtcbiAgICB2YXIgY2hhbGxlbmdlU3RyaW5nID0gJyc7XG5cbiAgICBpZiAoIWNoYWxsZW5nZU1hdGNoKSB7XG4gICAgICAgIHJldHVybiBjYWxsYmFjayh0aGlzLl9mb3JtYXRFcnJvcignSW52YWxpZCBsb2dpbiBzZXF1ZW5jZSB3aGlsZSB3YWl0aW5nIGZvciBzZXJ2ZXIgY2hhbGxlbmdlIHN0cmluZycsICdFQVVUSCcsIHN0cikpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIGNoYWxsZW5nZVN0cmluZyA9IGNoYWxsZW5nZU1hdGNoWzFdO1xuICAgIH1cblxuICAgIGlmICghL15OVExNL2kudGVzdChjaGFsbGVuZ2VTdHJpbmcpKSB7XG4gICAgICAgIGNoYWxsZW5nZVN0cmluZyA9ICdOVExNICcgKyBjaGFsbGVuZ2VTdHJpbmc7XG4gICAgfVxuXG4gICAgdmFyIHR5cGUyTWVzc2FnZSA9IG50bG0ucGFyc2VUeXBlMk1lc3NhZ2UoY2hhbGxlbmdlU3RyaW5nLCBjYWxsYmFjayk7XG4gICAgaWYgKCF0eXBlMk1lc3NhZ2UpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciB0eXBlM01lc3NhZ2UgPSBudGxtLmNyZWF0ZVR5cGUzTWVzc2FnZSh0eXBlMk1lc3NhZ2UsIHtcbiAgICAgICAgZG9tYWluOiB0aGlzLl9hdXRoLmRvbWFpbiB8fCAnJyxcbiAgICAgICAgd29ya3N0YXRpb246IHRoaXMuX2F1dGgud29ya3N0YXRpb24gfHwgJycsXG4gICAgICAgIHVzZXJuYW1lOiB0aGlzLl9hdXRoLnVzZXIsXG4gICAgICAgIHBhc3N3b3JkOiB0aGlzLl9hdXRoLnBhc3NcbiAgICB9KTtcblxuICAgIHR5cGUzTWVzc2FnZSA9IHR5cGUzTWVzc2FnZS5zdWJzdHJpbmcoNSk7IC8vIHJlbW92ZSB0aGUgXCJOVExNIFwiIHByZWZpeFxuXG4gICAgdGhpcy5fY3VycmVudEFjdGlvbiA9IGZ1bmN0aW9uIChzdHIpIHtcbiAgICAgICAgdGhpcy5fYWN0aW9uQVVUSF9OVExNX1RZUEUzKHN0ciwgY2FsbGJhY2spO1xuICAgIH0uYmluZCh0aGlzKTtcblxuICAgIHRoaXMuX3NlbmRDb21tYW5kKHR5cGUzTWVzc2FnZSk7XG59O1xuXG4vKipcbiAqIEhhbmRsZSB0aGUgcmVzcG9uc2UgZm9yIEFVVEggQ1JBTS1NRDUgY29tbWFuZC4gV2UgYXJlIGV4cGVjdGluZ1xuICogJzMzNCA8Y2hhbGxlbmdlIHN0cmluZz4nLiBEYXRhIHRvIGJlIHNlbnQgYXMgcmVzcG9uc2UgbmVlZHMgdG8gYmVcbiAqIGJhc2U2NCBkZWNvZGVkIGNoYWxsZW5nZSBzdHJpbmcsIE1ENSBoYXNoZWQgdXNpbmcgdGhlIHBhc3N3b3JkIGFzXG4gKiBhIEhNQUMga2V5LCBwcmVmaXhlZCBieSB0aGUgdXNlcm5hbWUgYW5kIGEgc3BhY2UsIGFuZCBmaW5hbGx5IGFsbFxuICogYmFzZTY0IGVuY29kZWQgYWdhaW4uXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHN0ciBNZXNzYWdlIGZyb20gdGhlIHNlcnZlclxuICovXG5TTVRQQ29ubmVjdGlvbi5wcm90b3R5cGUuX2FjdGlvbkFVVEhfQ1JBTV9NRDUgPSBmdW5jdGlvbiAoc3RyLCBjYWxsYmFjaykge1xuICAgIHZhciBjaGFsbGVuZ2VNYXRjaCA9IHN0ci5tYXRjaCgvXjMzNFxccysoLispJC8pO1xuICAgIHZhciBjaGFsbGVuZ2VTdHJpbmcgPSAnJztcblxuICAgIGlmICghY2hhbGxlbmdlTWF0Y2gpIHtcbiAgICAgICAgcmV0dXJuIGNhbGxiYWNrKHRoaXMuX2Zvcm1hdEVycm9yKCdJbnZhbGlkIGxvZ2luIHNlcXVlbmNlIHdoaWxlIHdhaXRpbmcgZm9yIHNlcnZlciBjaGFsbGVuZ2Ugc3RyaW5nJywgJ0VBVVRIJywgc3RyKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgY2hhbGxlbmdlU3RyaW5nID0gY2hhbGxlbmdlTWF0Y2hbMV07XG4gICAgfVxuXG4gICAgLy8gRGVjb2RlIGZyb20gYmFzZTY0XG4gICAgdmFyIGJhc2U2NGRlY29kZWQgPSBuZXcgQnVmZmVyKGNoYWxsZW5nZVN0cmluZywgJ2Jhc2U2NCcpLnRvU3RyaW5nKCdhc2NpaScpLFxuICAgICAgICBobWFjX21kNSA9IGNyeXB0by5jcmVhdGVIbWFjKCdtZDUnLCB0aGlzLl9hdXRoLnBhc3MpO1xuXG4gICAgaG1hY19tZDUudXBkYXRlKGJhc2U2NGRlY29kZWQpO1xuXG4gICAgdmFyIGhleF9obWFjID0gaG1hY19tZDUuZGlnZXN0KCdoZXgnKSxcbiAgICAgICAgcHJlcGVuZGVkID0gdGhpcy5fYXV0aC51c2VyICsgJyAnICsgaGV4X2htYWM7XG5cbiAgICB0aGlzLl9jdXJyZW50QWN0aW9uID0gZnVuY3Rpb24gKHN0cikge1xuICAgICAgICB0aGlzLl9hY3Rpb25BVVRIX0NSQU1fTUQ1X1BBU1Moc3RyLCBjYWxsYmFjayk7XG4gICAgfS5iaW5kKHRoaXMpO1xuXG5cbiAgICB0aGlzLl9zZW5kQ29tbWFuZChuZXcgQnVmZmVyKHByZXBlbmRlZCkudG9TdHJpbmcoJ2Jhc2U2NCcpKTtcbn07XG5cbi8qKlxuICogSGFuZGxlcyB0aGUgcmVzcG9uc2UgdG8gQ1JBTS1NRDUgYXV0aGVudGljYXRpb24sIGlmIHRoZXJlJ3Mgbm8gZXJyb3IsXG4gKiB0aGUgdXNlciBjYW4gYmUgY29uc2lkZXJlZCBsb2dnZWQgaW4uIFN0YXJ0IHdhaXRpbmcgZm9yIGEgbWVzc2FnZSB0byBzZW5kXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHN0ciBNZXNzYWdlIGZyb20gdGhlIHNlcnZlclxuICovXG5TTVRQQ29ubmVjdGlvbi5wcm90b3R5cGUuX2FjdGlvbkFVVEhfQ1JBTV9NRDVfUEFTUyA9IGZ1bmN0aW9uIChzdHIsIGNhbGxiYWNrKSB7XG4gICAgaWYgKCFzdHIubWF0Y2goL14yMzVcXHMrLykpIHtcbiAgICAgICAgcmV0dXJuIGNhbGxiYWNrKHRoaXMuX2Zvcm1hdEVycm9yKCdJbnZhbGlkIGxvZ2luIHNlcXVlbmNlIHdoaWxlIHdhaXRpbmcgZm9yIFwiMjM1XCInLCAnRUFVVEgnLCBzdHIpKTtcbiAgICB9XG5cbiAgICB0aGlzLmxvZ2dlci5pbmZvKCdbJXNdIFVzZXIgJXMgYXV0aGVudGljYXRlZCcsIHRoaXMuaWQsIEpTT04uc3RyaW5naWZ5KHRoaXMuX3VzZXIpKTtcbiAgICB0aGlzLmF1dGhlbnRpY2F0ZWQgPSB0cnVlO1xuICAgIGNhbGxiYWNrKG51bGwsIHRydWUpO1xufTtcblxuLyoqXG4gKiBIYW5kbGVzIHRoZSBUWVBFMyByZXNwb25zZSBmb3IgTlRMTSBhdXRoZW50aWNhdGlvbiwgaWYgdGhlcmUncyBubyBlcnJvcixcbiAqIHRoZSB1c2VyIGNhbiBiZSBjb25zaWRlcmVkIGxvZ2dlZCBpbi4gU3RhcnQgd2FpdGluZyBmb3IgYSBtZXNzYWdlIHRvIHNlbmRcbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gc3RyIE1lc3NhZ2UgZnJvbSB0aGUgc2VydmVyXG4gKi9cblNNVFBDb25uZWN0aW9uLnByb3RvdHlwZS5fYWN0aW9uQVVUSF9OVExNX1RZUEUzID0gZnVuY3Rpb24gKHN0ciwgY2FsbGJhY2spIHtcbiAgICBpZiAoIXN0ci5tYXRjaCgvXjIzNVxccysvKSkge1xuICAgICAgICByZXR1cm4gY2FsbGJhY2sodGhpcy5fZm9ybWF0RXJyb3IoJ0ludmFsaWQgbG9naW4gc2VxdWVuY2Ugd2hpbGUgd2FpdGluZyBmb3IgXCIyMzVcIicsICdFQVVUSCcsIHN0cikpO1xuICAgIH1cblxuICAgIHRoaXMubG9nZ2VyLmluZm8oJ1slc10gVXNlciAlcyBhdXRoZW50aWNhdGVkJywgdGhpcy5pZCwgSlNPTi5zdHJpbmdpZnkodGhpcy5fdXNlcikpO1xuICAgIHRoaXMuYXV0aGVudGljYXRlZCA9IHRydWU7XG4gICAgY2FsbGJhY2sobnVsbCwgdHJ1ZSk7XG59O1xuXG4vKipcbiAqIEhhbmRsZSB0aGUgcmVzcG9uc2UgZm9yIEFVVEggTE9HSU4gY29tbWFuZC4gV2UgYXJlIGV4cGVjdGluZ1xuICogJzMzNCBVR0Z6YzNkdmNtUTYnIChiYXNlNjQgZm9yICdQYXNzd29yZDonKS4gRGF0YSB0byBiZSBzZW50IGFzXG4gKiByZXNwb25zZSBuZWVkcyB0byBiZSBiYXNlNjQgZW5jb2RlZCBwYXNzd29yZC5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gc3RyIE1lc3NhZ2UgZnJvbSB0aGUgc2VydmVyXG4gKi9cblNNVFBDb25uZWN0aW9uLnByb3RvdHlwZS5fYWN0aW9uQVVUSF9MT0dJTl9QQVNTID0gZnVuY3Rpb24gKHN0ciwgY2FsbGJhY2spIHtcbiAgICBpZiAoc3RyICE9PSAnMzM0IFVHRnpjM2R2Y21RNicpIHtcbiAgICAgICAgcmV0dXJuIGNhbGxiYWNrKHRoaXMuX2Zvcm1hdEVycm9yKCdJbnZhbGlkIGxvZ2luIHNlcXVlbmNlIHdoaWxlIHdhaXRpbmcgZm9yIFwiMzM0IFVHRnpjM2R2Y21RNlwiJywgJ0VBVVRIJywgc3RyKSk7XG4gICAgfVxuXG4gICAgdGhpcy5fY3VycmVudEFjdGlvbiA9IGZ1bmN0aW9uIChzdHIpIHtcbiAgICAgICAgdGhpcy5fYWN0aW9uQVVUSENvbXBsZXRlKHN0ciwgY2FsbGJhY2spO1xuICAgIH0uYmluZCh0aGlzKTtcblxuICAgIHRoaXMuX3NlbmRDb21tYW5kKG5ldyBCdWZmZXIodGhpcy5fYXV0aC5wYXNzICsgJycsICd1dGYtOCcpLnRvU3RyaW5nKCdiYXNlNjQnKSk7XG59O1xuXG4vKipcbiAqIEhhbmRsZXMgdGhlIHJlc3BvbnNlIGZvciBhdXRoZW50aWNhdGlvbiwgaWYgdGhlcmUncyBubyBlcnJvcixcbiAqIHRoZSB1c2VyIGNhbiBiZSBjb25zaWRlcmVkIGxvZ2dlZCBpbi4gU3RhcnQgd2FpdGluZyBmb3IgYSBtZXNzYWdlIHRvIHNlbmRcbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gc3RyIE1lc3NhZ2UgZnJvbSB0aGUgc2VydmVyXG4gKi9cblNNVFBDb25uZWN0aW9uLnByb3RvdHlwZS5fYWN0aW9uQVVUSENvbXBsZXRlID0gZnVuY3Rpb24gKHN0ciwgaXNSZXRyeSwgY2FsbGJhY2spIHtcbiAgICBpZiAoIWNhbGxiYWNrICYmIHR5cGVvZiBpc1JldHJ5ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIGNhbGxiYWNrID0gaXNSZXRyeTtcbiAgICAgICAgaXNSZXRyeSA9IHVuZGVmaW5lZDtcbiAgICB9XG5cbiAgICBpZiAoc3RyLnN1YnN0cigwLCAzKSA9PT0gJzMzNCcpIHtcbiAgICAgICAgdGhpcy5fY3VycmVudEFjdGlvbiA9IGZ1bmN0aW9uIChzdHIpIHtcbiAgICAgICAgICAgIGlmIChpc1JldHJ5IHx8ICF0aGlzLl9hdXRoLnhvYXV0aDIgfHwgdHlwZW9mIHRoaXMuX2F1dGgueG9hdXRoMiAhPT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9hY3Rpb25BVVRIQ29tcGxldGUoc3RyLCB0cnVlLCBjYWxsYmFjayk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHNldFRpbWVvdXQodGhpcy5faGFuZGxlWE9hdXRoMlRva2VuLmJpbmQodGhpcywgdHJ1ZSwgY2FsbGJhY2spLCBNYXRoLnJhbmRvbSgpICogNDAwMCArIDEwMDApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMuX3NlbmRDb21tYW5kKCcnKTtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmIChzdHIuY2hhckF0KDApICE9PSAnMicpIHtcbiAgICAgICAgdGhpcy5sb2dnZXIuaW5mbygnWyVzXSBVc2VyICVzIGZhaWxlZCB0byBhdXRoZW50aWNhdGUnLCB0aGlzLmlkLCBKU09OLnN0cmluZ2lmeSh0aGlzLl91c2VyKSk7XG4gICAgICAgIHJldHVybiBjYWxsYmFjayh0aGlzLl9mb3JtYXRFcnJvcignSW52YWxpZCBsb2dpbicsICdFQVVUSCcsIHN0cikpO1xuICAgIH1cblxuICAgIHRoaXMubG9nZ2VyLmluZm8oJ1slc10gVXNlciAlcyBhdXRoZW50aWNhdGVkJywgdGhpcy5pZCwgSlNPTi5zdHJpbmdpZnkodGhpcy5fdXNlcikpO1xuICAgIHRoaXMuYXV0aGVudGljYXRlZCA9IHRydWU7XG4gICAgY2FsbGJhY2sobnVsbCwgdHJ1ZSk7XG59O1xuXG4vKipcbiAqIEhhbmRsZSByZXNwb25zZSBmb3IgYSBNQUlMIEZST006IGNvbW1hbmRcbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gc3RyIE1lc3NhZ2UgZnJvbSB0aGUgc2VydmVyXG4gKi9cblNNVFBDb25uZWN0aW9uLnByb3RvdHlwZS5fYWN0aW9uTUFJTCA9IGZ1bmN0aW9uIChzdHIsIGNhbGxiYWNrKSB7XG4gICAgaWYgKE51bWJlcihzdHIuY2hhckF0KDApKSAhPT0gMikge1xuICAgICAgICByZXR1cm4gY2FsbGJhY2sodGhpcy5fZm9ybWF0RXJyb3IoJ01haWwgY29tbWFuZCBmYWlsZWQnLCAnRUVOVkVMT1BFJywgc3RyKSk7XG4gICAgfVxuXG4gICAgaWYgKCF0aGlzLl9lbnZlbG9wZS5yY3B0UXVldWUubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiBjYWxsYmFjayh0aGlzLl9mb3JtYXRFcnJvcignQ2FuXFwndCBzZW5kIG1haWwgLSBubyByZWNpcGllbnRzIGRlZmluZWQnLCAnRUVOVkVMT1BFJykpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuX2VudmVsb3BlLmN1clJlY2lwaWVudCA9IHRoaXMuX2VudmVsb3BlLnJjcHRRdWV1ZS5zaGlmdCgpO1xuICAgICAgICB0aGlzLl9jdXJyZW50QWN0aW9uID0gZnVuY3Rpb24gKHN0cikge1xuICAgICAgICAgICAgdGhpcy5fYWN0aW9uUkNQVChzdHIsIGNhbGxiYWNrKTtcbiAgICAgICAgfS5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLl9zZW5kQ29tbWFuZCgnUkNQVCBUTzo8JyArIHRoaXMuX2VudmVsb3BlLmN1clJlY2lwaWVudCArICc+Jyk7XG4gICAgfVxufTtcblxuLyoqXG4gKiBIYW5kbGUgcmVzcG9uc2UgZm9yIGEgUkNQVCBUTzogY29tbWFuZFxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBzdHIgTWVzc2FnZSBmcm9tIHRoZSBzZXJ2ZXJcbiAqL1xuU01UUENvbm5lY3Rpb24ucHJvdG90eXBlLl9hY3Rpb25SQ1BUID0gZnVuY3Rpb24gKHN0ciwgY2FsbGJhY2spIHtcbiAgICBpZiAoTnVtYmVyKHN0ci5jaGFyQXQoMCkpICE9PSAyKSB7XG4gICAgICAgIC8vIHRoaXMgaXMgYSBzb2Z0IGVycm9yXG4gICAgICAgIHRoaXMuX2VudmVsb3BlLnJlamVjdGVkLnB1c2godGhpcy5fZW52ZWxvcGUuY3VyUmVjaXBpZW50KTtcbiAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLl9lbnZlbG9wZS5hY2NlcHRlZC5wdXNoKHRoaXMuX2VudmVsb3BlLmN1clJlY2lwaWVudCk7XG4gICAgfVxuXG4gICAgaWYgKCF0aGlzLl9lbnZlbG9wZS5yY3B0UXVldWUubGVuZ3RoKSB7XG4gICAgICAgIGlmICh0aGlzLl9lbnZlbG9wZS5yZWplY3RlZC5sZW5ndGggPCB0aGlzLl9lbnZlbG9wZS50by5sZW5ndGgpIHtcbiAgICAgICAgICAgIHRoaXMuX2N1cnJlbnRBY3Rpb24gPSBmdW5jdGlvbiAoc3RyKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fYWN0aW9uREFUQShzdHIsIGNhbGxiYWNrKTtcbiAgICAgICAgICAgIH0uYmluZCh0aGlzKTtcbiAgICAgICAgICAgIHRoaXMuX3NlbmRDb21tYW5kKCdEQVRBJyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gY2FsbGJhY2sodGhpcy5fZm9ybWF0RXJyb3IoJ0NhblxcJ3Qgc2VuZCBtYWlsIC0gYWxsIHJlY2lwaWVudHMgd2VyZSByZWplY3RlZCcsICdFRU5WRUxPUEUnLCBzdHIpKTtcbiAgICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuX2VudmVsb3BlLmN1clJlY2lwaWVudCA9IHRoaXMuX2VudmVsb3BlLnJjcHRRdWV1ZS5zaGlmdCgpO1xuICAgICAgICB0aGlzLl9jdXJyZW50QWN0aW9uID0gZnVuY3Rpb24gKHN0cikge1xuICAgICAgICAgICAgdGhpcy5fYWN0aW9uUkNQVChzdHIsIGNhbGxiYWNrKTtcbiAgICAgICAgfS5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLl9zZW5kQ29tbWFuZCgnUkNQVCBUTzo8JyArIHRoaXMuX2VudmVsb3BlLmN1clJlY2lwaWVudCArICc+Jyk7XG4gICAgfVxufTtcblxuLyoqXG4gKiBIYW5kbGUgcmVzcG9uc2UgZm9yIGEgREFUQSBjb21tYW5kXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHN0ciBNZXNzYWdlIGZyb20gdGhlIHNlcnZlclxuICovXG5TTVRQQ29ubmVjdGlvbi5wcm90b3R5cGUuX2FjdGlvbkRBVEEgPSBmdW5jdGlvbiAoc3RyLCBjYWxsYmFjaykge1xuICAgIC8vIHJlc3BvbnNlIHNob3VsZCBiZSAzNTQgYnV0IGFjY29yZGluZyB0byB0aGlzIGlzc3VlIGh0dHBzOi8vZ2l0aHViLmNvbS9lbGVpdGgvZW1haWxqcy9pc3N1ZXMvMjRcbiAgICAvLyBzb21lIHNlcnZlcnMgbWlnaHQgdXNlIDI1MCBpbnN0ZWFkLCBzbyBsZXRzIGNoZWNrIGZvciAyIG9yIDMgYXMgdGhlIGZpcnN0IGRpZ2l0XG4gICAgaWYgKFsyLCAzXS5pbmRleE9mKE51bWJlcihzdHIuY2hhckF0KDApKSkgPCAwKSB7XG4gICAgICAgIHJldHVybiBjYWxsYmFjayh0aGlzLl9mb3JtYXRFcnJvcignRGF0YSBjb21tYW5kIGZhaWxlZCcsICdFRU5WRUxPUEUnLCBzdHIpKTtcbiAgICB9XG5cbiAgICBjYWxsYmFjayhudWxsLCB7XG4gICAgICAgIGFjY2VwdGVkOiB0aGlzLl9lbnZlbG9wZS5hY2NlcHRlZCxcbiAgICAgICAgcmVqZWN0ZWQ6IHRoaXMuX2VudmVsb3BlLnJlamVjdGVkXG4gICAgfSk7XG59O1xuXG4vKipcbiAqIEhhbmRsZSByZXNwb25zZSBmb3IgYSBEQVRBIHN0cmVhbVxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBzdHIgTWVzc2FnZSBmcm9tIHRoZSBzZXJ2ZXJcbiAqL1xuU01UUENvbm5lY3Rpb24ucHJvdG90eXBlLl9hY3Rpb25TdHJlYW0gPSBmdW5jdGlvbiAoc3RyLCBjYWxsYmFjaykge1xuICAgIGlmIChOdW1iZXIoc3RyLmNoYXJBdCgwKSkgIT09IDIpIHtcbiAgICAgICAgLy8gTWVzc2FnZSBmYWlsZWRcbiAgICAgICAgcmV0dXJuIGNhbGxiYWNrKHRoaXMuX2Zvcm1hdEVycm9yKCdNZXNzYWdlIGZhaWxlZCcsICdFTUVTU0FHRScsIHN0cikpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIE1lc3NhZ2Ugc2VudCBzdWNjZXNmdWxseVxuICAgICAgICByZXR1cm4gY2FsbGJhY2sobnVsbCwgc3RyKTtcbiAgICB9XG59O1xuXG5TTVRQQ29ubmVjdGlvbi5wcm90b3R5cGUuX2hhbmRsZVhPYXV0aDJUb2tlbiA9IGZ1bmN0aW9uIChpc1JldHJ5LCBjYWxsYmFjaykge1xuICAgIHRoaXMuX2N1cnJlbnRBY3Rpb24gPSBmdW5jdGlvbiAoc3RyKSB7XG4gICAgICAgIHRoaXMuX2FjdGlvbkFVVEhDb21wbGV0ZShzdHIsIGlzUmV0cnksIGNhbGxiYWNrKTtcbiAgICB9LmJpbmQodGhpcyk7XG5cbiAgICBpZiAodGhpcy5fYXV0aC54b2F1dGgyICYmIHR5cGVvZiB0aGlzLl9hdXRoLnhvYXV0aDIgPT09ICdvYmplY3QnKSB7XG4gICAgICAgIHRoaXMuX2F1dGgueG9hdXRoMltpc1JldHJ5ID8gJ2dlbmVyYXRlVG9rZW4nIDogJ2dldFRva2VuJ10oZnVuY3Rpb24gKGVyciwgdG9rZW4pIHtcbiAgICAgICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmxvZ2dlci5pbmZvKCdbJXNdIFVzZXIgJXMgZmFpbGVkIHRvIGF1dGhlbnRpY2F0ZScsIHRoaXMuaWQsIEpTT04uc3RyaW5naWZ5KHRoaXMuX3VzZXIpKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gY2FsbGJhY2sodGhpcy5fZm9ybWF0RXJyb3IoZXJyLCAnRUFVVEgnKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLl9zZW5kQ29tbWFuZCgnQVVUSCBYT0FVVEgyICcgKyB0b2tlbik7XG4gICAgICAgIH0uYmluZCh0aGlzKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5fc2VuZENvbW1hbmQoJ0FVVEggWE9BVVRIMiAnICsgdGhpcy5fYnVpbGRYT0F1dGgyVG9rZW4odGhpcy5fYXV0aC51c2VyLCB0aGlzLl9hdXRoLnhvYXV0aDIpKTtcbiAgICB9XG59O1xuXG4vKipcbiAqIEJ1aWxkcyBhIGxvZ2luIHRva2VuIGZvciBYT0FVVEgyIGF1dGhlbnRpY2F0aW9uIGNvbW1hbmRcbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gdXNlciBFLW1haWwgYWRkcmVzcyBvZiB0aGUgdXNlclxuICogQHBhcmFtIHtTdHJpbmd9IHRva2VuIFZhbGlkIGFjY2VzcyB0b2tlbiBmb3IgdGhlIHVzZXJcbiAqIEByZXR1cm4ge1N0cmluZ30gQmFzZTY0IGZvcm1hdHRlZCBsb2dpbiB0b2tlblxuICovXG5TTVRQQ29ubmVjdGlvbi5wcm90b3R5cGUuX2J1aWxkWE9BdXRoMlRva2VuID0gZnVuY3Rpb24gKHVzZXIsIHRva2VuKSB7XG4gICAgdmFyIGF1dGhEYXRhID0gW1xuICAgICAgICAndXNlcj0nICsgKHVzZXIgfHwgJycpLFxuICAgICAgICAnYXV0aD1CZWFyZXIgJyArIHRva2VuLFxuICAgICAgICAnJyxcbiAgICAgICAgJydcbiAgICBdO1xuICAgIHJldHVybiBuZXcgQnVmZmVyKGF1dGhEYXRhLmpvaW4oJ1xceDAxJykpLnRvU3RyaW5nKCdiYXNlNjQnKTtcbn07XG5cblNNVFBDb25uZWN0aW9uLnByb3RvdHlwZS5fZ2V0SG9zdG5hbWUgPSBmdW5jdGlvbiAoKSB7XG4gICAgLy8gZGVmYXVsIGhvc3RuYW1lIGlzIG1hY2hpbmUgaG9zdG5hbWUgb3IgW0lQXVxuICAgIHZhciBkZWZhdWx0SG9zdG5hbWUgPSBvcy5ob3N0bmFtZSgpIHx8ICcnO1xuXG4gICAgLy8gaWdub3JlIGlmIG5vdCBGUUROXG4gICAgaWYgKGRlZmF1bHRIb3N0bmFtZS5pbmRleE9mKCcuJykgPCAwKSB7XG4gICAgICAgIGRlZmF1bHRIb3N0bmFtZSA9ICdbMTI3LjAuMC4xXSc7XG4gICAgfVxuXG4gICAgLy8gSVAgc2hvdWxkIGJlIGVuY2xvc2VkIGluIFtdXG4gICAgaWYgKGRlZmF1bHRIb3N0bmFtZS5tYXRjaCgvXlxcZHsxLDN9XFwuXFxkezEsM31cXC5cXGR7MSwzfVxcLlxcZHsxLDN9JC8pKSB7XG4gICAgICAgIGRlZmF1bHRIb3N0bmFtZSA9ICdbJyArIGRlZmF1bHRIb3N0bmFtZSArICddJztcbiAgICB9XG5cbiAgICByZXR1cm4gZGVmYXVsdEhvc3RuYW1lO1xufTtcblxufSkuY2FsbCh0aGlzLHJlcXVpcmUoXCJidWZmZXJcIikuQnVmZmVyKSIsIm1vZHVsZS5leHBvcnRzPXtcbiAgXCJfYXJnc1wiOiBbXG4gICAgW1xuICAgICAgXCJzbXRwLWNvbm5lY3Rpb25AaHR0cHM6Ly9yZWdpc3RyeS5ucG1qcy5vcmcvc210cC1jb25uZWN0aW9uLy0vc210cC1jb25uZWN0aW9uLTIuNS4wLnRnelwiLFxuICAgICAgXCIvVXNlcnMvbmhvbmcvbmlja2hvbmcuaW8vbm9kZV9tb2R1bGVzL25vZGVtYWlsZXJcIlxuICAgIF1cbiAgXSxcbiAgXCJfZnJvbVwiOiBcInNtdHAtY29ubmVjdGlvbkAyLjUuMFwiLFxuICBcIl9pZFwiOiBcInNtdHAtY29ubmVjdGlvbkAyLjUuMFwiLFxuICBcIl9pbkNhY2hlXCI6IHRydWUsXG4gIFwiX2xvY2F0aW9uXCI6IFwiL25vZGVtYWlsZXIvc210cC1jb25uZWN0aW9uXCIsXG4gIFwiX3BoYW50b21DaGlsZHJlblwiOiB7fSxcbiAgXCJfcmVxdWVzdGVkXCI6IHtcbiAgICBcIm5hbWVcIjogXCJzbXRwLWNvbm5lY3Rpb25cIixcbiAgICBcInJhd1wiOiBcInNtdHAtY29ubmVjdGlvbkBodHRwczovL3JlZ2lzdHJ5Lm5wbWpzLm9yZy9zbXRwLWNvbm5lY3Rpb24vLS9zbXRwLWNvbm5lY3Rpb24tMi41LjAudGd6XCIsXG4gICAgXCJyYXdTcGVjXCI6IFwiaHR0cHM6Ly9yZWdpc3RyeS5ucG1qcy5vcmcvc210cC1jb25uZWN0aW9uLy0vc210cC1jb25uZWN0aW9uLTIuNS4wLnRnelwiLFxuICAgIFwic2NvcGVcIjogbnVsbCxcbiAgICBcInNwZWNcIjogXCJodHRwczovL3JlZ2lzdHJ5Lm5wbWpzLm9yZy9zbXRwLWNvbm5lY3Rpb24vLS9zbXRwLWNvbm5lY3Rpb24tMi41LjAudGd6XCIsXG4gICAgXCJ0eXBlXCI6IFwicmVtb3RlXCJcbiAgfSxcbiAgXCJfcmVxdWlyZWRCeVwiOiBbXG4gICAgXCIvbm9kZW1haWxlci9ub2RlbWFpbGVyLWRpcmVjdC10cmFuc3BvcnRcIixcbiAgICBcIi9ub2RlbWFpbGVyL25vZGVtYWlsZXItc210cC1wb29sXCIsXG4gICAgXCIvbm9kZW1haWxlci9ub2RlbWFpbGVyLXNtdHAtdHJhbnNwb3J0XCJcbiAgXSxcbiAgXCJfcmVzb2x2ZWRcIjogXCJodHRwczovL3JlZ2lzdHJ5Lm5wbWpzLm9yZy9zbXRwLWNvbm5lY3Rpb24vLS9zbXRwLWNvbm5lY3Rpb24tMi41LjAudGd6XCIsXG4gIFwiX3NoYXN1bVwiOiBcIjA1OTk4ZjA5MzdhYTI3NTU0Y2UxYWEzYjBiZGZkYmZiNGNmYjM1YTdcIixcbiAgXCJfc2hyaW5rd3JhcFwiOiBudWxsLFxuICBcIl9zcGVjXCI6IFwic210cC1jb25uZWN0aW9uQGh0dHBzOi8vcmVnaXN0cnkubnBtanMub3JnL3NtdHAtY29ubmVjdGlvbi8tL3NtdHAtY29ubmVjdGlvbi0yLjUuMC50Z3pcIixcbiAgXCJfd2hlcmVcIjogXCIvVXNlcnMvbmhvbmcvbmlja2hvbmcuaW8vbm9kZV9tb2R1bGVzL25vZGVtYWlsZXJcIixcbiAgXCJhdXRob3JcIjoge1xuICAgIFwibmFtZVwiOiBcIkFuZHJpcyBSZWlubWFuXCJcbiAgfSxcbiAgXCJidWdzXCI6IHtcbiAgICBcInVybFwiOiBcImh0dHBzOi8vZ2l0aHViLmNvbS9hbmRyaXM5L3NtdHAtY29ubmVjdGlvbi9pc3N1ZXNcIlxuICB9LFxuICBcImRlcGVuZGVuY2llc1wiOiB7XG4gICAgXCJodHRwbnRsbVwiOiBcIjEuNi4xXCIsXG4gICAgXCJub2RlbWFpbGVyLXNoYXJlZFwiOiBcIjEuMC41XCJcbiAgfSxcbiAgXCJkZXNjcmlwdGlvblwiOiBcIkNvbm5lY3QgdG8gU01UUCBzZXJ2ZXJzXCIsXG4gIFwiZGV2RGVwZW5kZW5jaWVzXCI6IHtcbiAgICBcImNoYWlcIjogXCJeMy41LjBcIixcbiAgICBcImdydW50XCI6IFwiXjEuMC4xXCIsXG4gICAgXCJncnVudC1jbGlcIjogXCJeMS4yLjBcIixcbiAgICBcImdydW50LWVzbGludFwiOiBcIl4xOC4xLjBcIixcbiAgICBcImdydW50LW1vY2hhLXRlc3RcIjogXCJeMC4xMi43XCIsXG4gICAgXCJtb2NoYVwiOiBcIl4yLjQuNVwiLFxuICAgIFwicHJveHktdGVzdC1zZXJ2ZXJcIjogXCJeMS4wLjBcIixcbiAgICBcInNpbm9uXCI6IFwiXjEuMTcuNFwiLFxuICAgIFwic210cC1zZXJ2ZXJcIjogXCJeMS45LjFcIixcbiAgICBcInhvYXV0aDJcIjogXCJeMS4xLjBcIlxuICB9LFxuICBcImRpcmVjdG9yaWVzXCI6IHtcbiAgICBcInRlc3RcIjogXCJ0ZXN0XCJcbiAgfSxcbiAgXCJob21lcGFnZVwiOiBcImh0dHBzOi8vZ2l0aHViLmNvbS9hbmRyaXM5L3NtdHAtY29ubmVjdGlvblwiLFxuICBcImtleXdvcmRzXCI6IFtcbiAgICBcIlNNVFBcIlxuICBdLFxuICBcImxpY2Vuc2VcIjogXCJNSVRcIixcbiAgXCJtYWluXCI6IFwibGliL3NtdHAtY29ubmVjdGlvbi5qc1wiLFxuICBcIm5hbWVcIjogXCJzbXRwLWNvbm5lY3Rpb25cIixcbiAgXCJvcHRpb25hbERlcGVuZGVuY2llc1wiOiB7fSxcbiAgXCJyZWFkbWVcIjogXCIjIHNtdHAtY29ubmVjdGlvblxcblxcblNNVFAgY2xpZW50IG1vZHVsZS4gQ29ubmVjdCB0byBTTVRQIHNlcnZlcnMgYW5kIHNlbmQgbWFpbCB3aXRoIGl0LlxcblxcblRoaXMgbW9kdWxlIGlzIHRoZSBzdWNjZXNzb3IgZm9yIHRoZSBjbGllbnQgcGFydCBvZiB0aGUgKG5vdyBkZXByZWNhdGVkKSBTTVRQIG1vZHVsZSBbc2ltcGxlc210cF0oaHR0cHM6Ly93d3cubnBtanMuY29tL3BhY2thZ2Uvc2ltcGxlc210cCkuIEZvciBtYXRjaGluZyBTTVRQIHNlcnZlciBzZWUgW3NtdHAtc2VydmVyXShodHRwczovL3d3dy5ucG1qcy5jb20vcGFja2FnZS9zbXRwLXNlcnZlcikuXFxuXFxuWyFbQnVpbGQgU3RhdHVzXShodHRwczovL3NlY3VyZS50cmF2aXMtY2kub3JnL25vZGVtYWlsZXIvc210cC1jb25uZWN0aW9uLnN2ZyldKGh0dHA6Ly90cmF2aXMtY2kub3JnL25vZGVtYWlsZXIvc210cC1jb25uZWN0aW9uKVxcblshW25wbSB2ZXJzaW9uXShodHRwczovL2JhZGdlLmZ1cnkuaW8vanMvc210cC1jb25uZWN0aW9uLnN2ZyldKGh0dHA6Ly9iYWRnZS5mdXJ5LmlvL2pzL3NtdHAtY29ubmVjdGlvbilcXG5cXG4jIyBVc2FnZVxcblxcbkluc3RhbGwgd2l0aCBucG1cXG5cXG4gICAgbnBtIGluc3RhbGwgc210cC1jb25uZWN0aW9uXFxuXFxuUmVxdWlyZSBpbiB5b3VyIHNjcmlwdFxcblxcbiAgICB2YXIgU01UUENvbm5lY3Rpb24gPSByZXF1aXJlKCdzbXRwLWNvbm5lY3Rpb24nKTtcXG5cXG4jIyMgQ3JlYXRlIFNNVFBDb25uZWN0aW9uIGluc3RhbmNlXFxuXFxuYGBgamF2YXNjcmlwdFxcbnZhciBjb25uZWN0aW9uID0gbmV3IFNNVFBDb25uZWN0aW9uKG9wdGlvbnMpO1xcbmBgYFxcblxcbldoZXJlXFxuXFxuICAqICoqb3B0aW9ucyoqIGRlZmluZXMgY29ubmVjdGlvbiBkYXRhXFxuICAgICogKipvcHRpb25zLnBvcnQqKiBpcyB0aGUgcG9ydCB0byBjb25uZWN0IHRvIChkZWZhdWx0cyB0byAyNSBvciA0NjUpXFxuICAgICogKipvcHRpb25zLmhvc3QqKiBpcyB0aGUgaG9zdG5hbWUgb3IgSVAgYWRkcmVzcyB0byBjb25uZWN0IHRvIChkZWZhdWx0cyB0byAnbG9jYWxob3N0JylcXG4gICAgKiAqKm9wdGlvbnMuc2VjdXJlKiogZGVmaW5lcyBpZiB0aGUgY29ubmVjdGlvbiBzaG91bGQgdXNlIFNTTCAoaWYgYHRydWVgKSBvciBub3QgKGlmIGBmYWxzZWApXFxuICAgICogKipvcHRpb25zLmlnbm9yZVRMUyoqIHR1cm5zIG9mZiBTVEFSVFRMUyBzdXBwb3J0IGlmIHRydWVcXG4gICAgKiAqKm9wdGlvbnMucmVxdWlyZVRMUyoqIGZvcmNlcyB0aGUgY2xpZW50IHRvIHVzZSBTVEFSVFRMUy4gUmV0dXJucyBhbiBlcnJvciBpZiB1cGdyYWRpbmcgdGhlIGNvbm5lY3Rpb24gaXMgbm90IHBvc3NpYmxlIG9yIGZhaWxzLlxcbiAgICAqICoqb3B0aW9ucy5uYW1lKiogb3B0aW9uYWwgaG9zdG5hbWUgb2YgdGhlIGNsaWVudCwgdXNlZCBmb3IgaWRlbnRpZnlpbmcgdG8gdGhlIHNlcnZlclxcbiAgICAqICoqb3B0aW9ucy5sb2NhbEFkZHJlc3MqKiBpcyB0aGUgbG9jYWwgaW50ZXJmYWNlIHRvIGJpbmQgdG8gZm9yIG5ldHdvcmsgY29ubmVjdGlvbnNcXG4gICAgKiAqKm9wdGlvbnMuY29ubmVjdGlvblRpbWVvdXQqKiBob3cgbWFueSBtaWxsaXNlY29uZHMgdG8gd2FpdCBmb3IgdGhlIGNvbm5lY3Rpb24gdG8gZXN0YWJsaXNoXFxuICAgICogKipvcHRpb25zLmdyZWV0aW5nVGltZW91dCoqIGhvdyBtYW55IG1pbGxpc2Vjb25kcyB0byB3YWl0IGZvciB0aGUgZ3JlZXRpbmcgYWZ0ZXIgY29ubmVjdGlvbiBpcyBlc3RhYmxpc2hlZFxcbiAgICAqICoqb3B0aW9ucy5zb2NrZXRUaW1lb3V0KiogaG93IG1hbnkgbWlsbGlzZWNvbmRzIG9mIGluYWN0aXZpdHkgdG8gYWxsb3dcXG4gICAgKiAqKm9wdGlvbnMubG9nZ2VyKiogb3B0aW9uYWwgW2J1bnlhbl0oaHR0cHM6Ly9naXRodWIuY29tL3RyZW50bS9ub2RlLWJ1bnlhbikgY29tcGF0aWJsZSBsb2dnZXIgaW5zdGFuY2UuIElmIHNldCB0byBgdHJ1ZWAgdGhlbiBsb2dzIHRvIGNvbnNvbGUuIElmIHZhbHVlIGlzIG5vdCBzZXQgb3IgaXMgYGZhbHNlYCB0aGVuIG5vdGhpbmcgaXMgbG9nZ2VkXFxuICAgICogKipvcHRpb25zLmRlYnVnKiogaWYgc2V0IHRvIHRydWUsIHRoZW4gbG9ncyBTTVRQIHRyYWZmaWMsIG90aGVyd2lzZSBsb2dzIG9ubHkgdHJhbnNhY3Rpb24gZXZlbnRzXFxuICAgICogKipvcHRpb25zLmxtdHAqKiBpZiB0cnVlLCB1c2VzIExNVFAgaW5zdGVhZCBvZiBTTVRQIHRvIHRhbGsgdG8gdGhlIHNlcnZlci4gUGFydGlhbCBzdXBwb3J0LCBkb2VzIG5vdCB3b3JrIHdlbGwgd2l0aCBtdWx0aXBsZSByZWNpcGllbnRzXFxuICAgICogKipvcHRpb25zLmF1dGhNZXRob2QqKiBkZWZpbmVzIHByZWZlcnJlZCBhdXRoZW50aWNhdGlvbiBtZXRob2QsIGUuZy4gJ1BMQUlOJ1xcbiAgICAqICoqb3B0aW9ucy50bHMqKiBkZWZpbmVzIGFkZGl0aW9uYWwgb3B0aW9ucyB0byBiZSBwYXNzZWQgdG8gdGhlIHNvY2tldCBjb25zdHJ1Y3RvciwgZS5nLiAqe3JlamVjdFVuYXV0aG9yaXplZDogdHJ1ZX0qXFxuICAgICogKipvcHRpb25zLnNvY2tldCoqIC0gaW5pdGlhbGl6ZWQgc29ja2V0IHRvIHVzZSBpbnN0ZWFkIG9mIGNyZWF0aW5nIGEgbmV3IG9uZVxcbiAgICAqICoqb3B0aW9ucy5jb25uZWN0aW9uKiogLSBjb25uZWN0ZWQgc29ja2V0IHRvIHVzZSBpbnN0ZWFkIG9mIGNyZWF0aW5nIGFuZCBjb25uZWN0aW5nIGEgbmV3IG9uZS4gSWYgYHNlY3VyZWAgb3B0aW9uIGlzIHRydWUsIHRoZW4gc29ja2V0IGlzIHVwZ3JhZGVkIGZyb20gcGxhaW50ZXh0IHRvIGNpcGhlcnRleHRcXG5cXG4jIyMgRXZlbnRzXFxuXFxuU01UUENvbm5lY3Rpb24gaW5zdGFuY2VzIGFyZSBldmVudCBlbWl0dGVycyB3aXRoIHRoZSBmb2xsb3dpbmcgZXZlbnRzXFxuXFxuICAqICoqJ2Vycm9yJyoqICooZXJyKSogZW1pdHRlZCB3aGVuIGFuIGVycm9yIG9jY3Vycy4gQ29ubmVjdGlvbiBpcyBjbG9zZWQgYXV0b21hdGljYWxseSBpbiB0aGlzIGNhc2UuXFxuICAqICoqJ2Nvbm5lY3QnKiogZW1pdHRlZCB3aGVuIHRoZSBjb25uZWN0aW9uIGlzIGVzdGFibGlzaGVkXFxuICAqICoqJ2VuZCcqKiB3aGVuIHRoZSBpbnN0YW5jZSBpcyBkZXN0cm95ZWRcXG5cXG4jIyMgY29ubmVjdFxcblxcbkVzdGFibGlzaCB0aGUgY29ubmVjdGlvblxcblxcbmBgYGphdmFzY3JpcHRcXG5jb25uZWN0aW9uLmNvbm5lY3QoY2FsbGJhY2spXFxuYGBgXFxuXFxuV2hlcmVcXG5cXG4gICogKipjYWxsYmFjayoqIGlzIHRoZSBmdW5jdGlvbiB0byBydW4gb25jZSB0aGUgY29ubmVjdGlvbiBpcyBlc3RhYmxpc2hlZC4gVGhlIGZ1bmN0aW9uIGlzIGFkZGVkIGFzIGEgbGlzdGVuZXIgdG8gdGhlICdjb25uZWN0JyBldmVudC5cXG5cXG5BZnRlciB0aGUgY29ubmVjdCBldmVudCB0aGUgYGNvbm5lY3Rpb25gIGhhcyB0aGUgZm9sbG93aW5nIHByb3BlcnRpZXM6XFxuXFxuICAqICoqY29ubmVjdGlvbi5zZWN1cmUqKiAtIGlmIGB0cnVlYCB0aGVuIHRoZSBjb25uZWN0aW9uIHVzZXMgYSBUTFMgc29ja2V0LCBvdGhlcndpc2UgaXQgaXMgdXNpbmcgYSBjbGVhcnRleHQgc29ja2V0LiBDb25uZWN0aW9uIGNhbiBzdGFydCBvdXQgYXMgY2xlYXJ0ZXh0IGJ1dCBpZiBhdmFpbGFibGUgKG9yIGByZXF1aXJlVExTYCBpcyBzZXQgdG8gdHJ1ZSkgY29ubmVjdGlvbiB1cGdyYWRlIGlzIHRyaWVkXFxuXFxuIyMjIGxvZ2luXFxuXFxuSWYgdGhlIHNlcnZlciByZXF1aXJlcyBhdXRoZW50aWNhdGlvbiB5b3UgY2FuIGxvZ2luIHdpdGhcXG5cXG5gYGBqYXZhc2NyaXB0XFxuY29ubmVjdGlvbi5sb2dpbihhdXRoLCBjYWxsYmFjaylcXG5gYGBcXG5cXG5XaGVyZVxcblxcbiAgKiAqKmF1dGgqKiBpcyB0aGUgYXV0aGVudGljYXRpb24gb2JqZWN0XFxuICAgICogKiphdXRoLnVzZXIqKiBpcyB0aGUgdXNlcm5hbWVcXG4gICAgKiAqKmF1dGgucGFzcyoqIGlzIHRoZSBwYXNzd29yZCBmb3IgdGhlIHVzZXJcXG4gICAgKiAqKmF1dGgueG9hdXRoMioqIGlzIHRoZSBPQXV0aDIgYWNjZXNzIHRva2VuIChwcmVmZXJyZWQgaWYgYm90aCBgcGFzc2AgYW5kIGB4b2F1dGgyYCB2YWx1ZXMgYXJlIHNldCkgb3IgYW4gW1hPQXV0aDJdKGh0dHBzOi8vZ2l0aHViLmNvbS9hbmRyaXM5L3hvYXV0aDIpIHRva2VuIGdlbmVyYXRvciBvYmplY3QuXFxuICAqICoqY2FsbGJhY2sqKiBpcyB0aGUgY2FsbGJhY2sgdG8gcnVuIG9uY2UgdGhlIGF1dGhlbnRpY2F0aW9uIGlzIGZpbmlzaGVkLiBDYWxsYmFjayBoYXMgdGhlIGZvbGxvd2luZyBhcmd1bWVudHNcXG4gICAgKiAqKmVycioqIGFuZCBlcnJvciBvYmplY3QgaWYgYXV0aGVudGljYXRpb24gZmFpbGVkXFxuXFxuSWYgYSBbWE9BdXRoMl0oaHR0cHM6Ly9naXRodWIuY29tL2FuZHJpczkveG9hdXRoMikgdG9rZW4gZ2VuZXJhdG9yIGlzIHVzZWQgYXMgdGhlIHZhbHVlIGZvciBgYXV0aC54b2F1dGgyYCB0aGVuIHlvdSBkbyBub3QgbmVlZCB0byBzZXQgYGF1dGgudXNlcmAuIFhPQXV0aDIgZ2VuZXJhdG9yIGdlbmVyYXRlcyByZXF1aXJlZCBhY2Nlc3NUb2tlbiBpdHNlbGYgaWYgaXQgaXMgbWlzc2luZyBvciBleHBpcmVkLiBJbiB0aGlzIGNhc2UgaWYgdGhlIGF1dGhlbnRpY2F0aW9uIGZhaWxzLCBhIG5ldyB0b2tlbiBpcyByZXF1ZWVzdGVkIGFuZCB0aGUgYXV0aGVudGljYXRpb24gaXMgcmV0cmllZC4gSWYgaXQgc3RpbGwgZmFpbHMsIGFuIGVycm9yIGlzIHJldHVybmVkLlxcblxcbioqWE9BdXRoMiBFeGFtcGxlKipcXG5cXG5gYGBqYXZhc2NyaXB0XFxudmFyIGdlbmVyYXRvciA9IHJlcXVpcmUoJ3hvYXV0aDInKS5jcmVhdGVYT0F1dGgyR2VuZXJhdG9yKHtcXG4gICAgdXNlcjogJ3t1c2VybmFtZX0nLFxcbiAgICBjbGllbnRJZDogJ3tDbGllbnQgSUR9JyxcXG4gICAgY2xpZW50U2VjcmV0OiAne0NsaWVudCBTZWNyZXR9JyxcXG4gICAgcmVmcmVzaFRva2VuOiAne3JlZnJlc2gtdG9rZW59J1xcbn0pO1xcblxcbi8vIGxpc3RlbiBmb3IgdG9rZW4gdXBkYXRlc1xcbi8vIHlvdSBwcm9iYWJseSB3YW50IHRvIHN0b3JlIHRoZXNlIHRvIGEgZGJcXG5nZW5lcmF0b3Iub24oJ3Rva2VuJywgZnVuY3Rpb24odG9rZW4pe1xcbiAgICBjb25zb2xlLmxvZygnTmV3IHRva2VuIGZvciAlczogJXMnLCB0b2tlbi51c2VyLCB0b2tlbi5hY2Nlc3NUb2tlbik7XFxufSk7XFxuXFxuLy8gbG9naW5cXG5jb25uZWN0aW9uLmxvZ2luKHtcXG4gICAgeG9hdXRoMjogZ2VuZXJhdG9yXFxufSwgY2FsbGJhY2spO1xcbmBgYFxcblxcbiMjIyBMb2dpbiB1c2luZyBOVExNXFxuXFxuYHNtdHAtY29ubmVjdGlvbmAgaGFzIGV4cGVyaW1lbnRhbCBzdXBwb3J0IGZvciBOVExNIGF1dGhlbnRpY2F0aW9uLiBZb3UgY2FuIHRyeSBpdCBvdXQgbGlrZSB0aGlzOlxcblxcbmBgYGphdmFzY3JpcHRcXG5jb25uZWN0aW9uLmxvZ2luKHtcXG4gICAgZG9tYWluOiAnd2luZG93cy1kb21haW4nLFxcbiAgICB3b3Jrc3RhdGlvbjogJ3dpbmRvd3Mtd29ya3N0YXRpb24nLFxcbiAgICB1c2VyOiAndXNlckBzb21lZG9tYWluLmNvbScsXFxuICAgIHBhc3M6ICdwYXNzJ1xcbn0sIGNhbGxiYWNrKTtcXG5gYGBcXG5cXG5JIGRvIG5vdCBoYXZlIGFjY2VzcyB0byBhbiBhY3R1YWwgc2VydmVyIHRoYXQgc3VwcG9ydHMgTlRMTSBhdXRoZW50aWNhdGlvblxcbnNvIHRoaXMgZmVhdHVyZSBpcyB1bnRlc3RlZCBhbmQgc2hvdWxkIGJlIHVzZWQgY2FyZWZ1bGx5LlxcblxcbiMjIyBzZW5kXFxuXFxuT25jZSB0aGUgY29ubmVjdGlvbiBpcyBhdXRoZW50aWNhdGVkIChvciBqdXN0IGFmdGVyIGNvbm5lY3Rpb24gaXMgZXN0YWJsaXNoZWQgaWYgYXV0aGVudGljYXRpb24gaXMgbm90IHJlcXVpcmVkKSwgeW91IGNhbiBzZW5kIG1haWwgd2l0aFxcblxcbmBgYGphdmFzY3JpcHRcXG5jb25uZWN0aW9uLnNlbmQoZW52ZWxvcGUsIG1lc3NhZ2UsIGNhbGxiYWNrKVxcbmBgYFxcblxcbldoZXJlXFxuXFxuICAqICoqZW52ZWxvcGUqKiBpcyB0aGUgZW52ZWxvcGUgb2JqZWN0IHRvIHVzZVxcbiAgICAqICoqZW52ZWxvcGUuZnJvbSoqIGlzIHRoZSBzZW5kZXIgYWRkcmVzc1xcbiAgICAqICoqZW52ZWxvcGUudG8qKiBpcyB0aGUgcmVjaXBpZW50IGFkZHJlc3Mgb3IgYW4gYXJyYXkgb2YgYWRkcmVzc2VzXFxuICAqICoqbWVzc2FnZSoqIGlzIGVpdGhlciBhIFN0cmluZywgQnVmZmVyIG9yIGEgU3RyZWFtLiBBbGwgbmV3bGluZXMgYXJlIGNvbnZlcnRlZCB0byBcXFxcclxcXFxuIGFuZCBhbGwgZG90cyBhcmUgZXNjYXBlZCBhdXRvbWF0aWNhbGx5LCBubyBuZWVkIHRvIGNvbnZlcnQgYW55dGhpbmcgYmVmb3JlLlxcbiAgKiAqKmNhbGxiYWNrKiogaXMgdGhlIGNhbGxiYWNrIHRvIHJ1biBvbmNlIHRoZSBzZW5kaW5nIGlzIGZpbmlzaGVkIG9yIGZhaWxlZC4gQ2FsbGJhY2sgaGFzIHRoZSBmb2xsb3dpbmcgYXJndW1lbnRzXFxuICAgICogKiplcnIqKiBhbmQgZXJyb3Igb2JqZWN0IGlmIHNlbmRpbmcgZmFpbGVkXFxuICAgICAgKiAqKmNvZGUqKiBzdHJpbmcgY29kZSBpZGVudGlmeWluZyB0aGUgZXJyb3IsIGZvciBleGFtcGxlICdFQVVUSCcgaXMgcmV0dXJuZWQgd2hlbiBhdXRoZW50aWNhdGlvbiBmYWlsc1xcbiAgICAgICogKipyZXNwb25zZSoqIGlzIHRoZSBsYXN0IHJlc3BvbnNlIHJlY2VpdmVkIGZyb20gdGhlIHNlcnZlciAoaWYgdGhlIGVycm9yIGlzIGNhdXNlZCBieSBhbiBlcnJvciByZXNwb25zZSBmcm9tIHRoZSBzZXJ2ZXIpXFxuICAgICAgKiAqKnJlc3BvbnNlQ29kZSoqIGlzIHRoZSBudW1lcmljIHJlc3BvbnNlIGNvZGUgb2YgdGhlIGByZXNwb25zZWAgc3RyaW5nIChpZiBhdmFpbGFibGUpXFxuICAgICogKippbmZvKiogaW5mb3JtYXRpb24gb2JqZWN0IGFib3V0IGFjY2VwdGVkIGFuZCByZWplY3RlZCByZWNpcGllbnRzXFxuICAgICAgKiAqKmFjY2VwdGVkKiogYW5kIGFycmF5IG9mIGFjY2VwdGVkIHJlY2lwaWVudCBhZGRyZXNzZXNcXG4gICAgICAqICoqcmVqZWN0ZWQqKiBhbmQgYXJyYXkgb2YgcmVqZWN0ZWQgcmVjaXBpZW50IGFkZHJlc3Nlc1xcbiAgICAgICogKipyZXNwb25zZSoqIGlzIHRoZSBsYXN0IHJlc3BvbnNlIHJlY2VpdmVkIGZyb20gdGhlIHNlcnZlclxcblxcbiMjIyBxdWl0XFxuXFxuVXNlIGl0IGZvciBncmFjZWZ1bCBkaXNjb25uZWN0XFxuXFxuYGBgamF2YXNjcmlwdFxcbmNvbm5lY3Rpb24ucXVpdCgpO1xcbmBgYFxcblxcbiMjIyBjbG9zZVxcblxcblVzZSBpdCBmb3IgbGVzcyBncmFjZWZ1bCBkaXNjb25uZWN0XFxuXFxuYGBgamF2YXNjcmlwdFxcbmNvbm5lY3Rpb24uY2xvc2UoKTtcXG5gYGBcXG5cXG4jIyBMaWNlbnNlXFxuXFxuKipNSVQqKlxcblwiLFxuICBcInJlYWRtZUZpbGVuYW1lXCI6IFwiUkVBRE1FLm1kXCIsXG4gIFwicmVwb3NpdG9yeVwiOiB7XG4gICAgXCJ0eXBlXCI6IFwiZ2l0XCIsXG4gICAgXCJ1cmxcIjogXCJnaXQ6Ly9naXRodWIuY29tL2FuZHJpczkvc210cC1jb25uZWN0aW9uLmdpdFwiXG4gIH0sXG4gIFwic2NyaXB0c1wiOiB7XG4gICAgXCJ0ZXN0XCI6IFwiZ3J1bnRcIlxuICB9LFxuICBcInZlcnNpb25cIjogXCIyLjUuMFwiXG59XG4iLCJ2YXIgU29ja3NDbGllbnQgPSByZXF1aXJlKCcuL2xpYi9zb2Nrcy1jbGllbnQuanMnKTtcbnZhciBTb2Nrc0FnZW50ID0gcmVxdWlyZSgnLi9saWIvc29ja3MtYWdlbnQuanMnKTtcblxuZXhwb3J0cy5jcmVhdGVDb25uZWN0aW9uID0gU29ja3NDbGllbnQuY3JlYXRlQ29ubmVjdGlvbjtcbmV4cG9ydHMuY3JlYXRlVURQRnJhbWUgPSBTb2Nrc0NsaWVudC5jcmVhdGVVRFBGcmFtZTtcbmV4cG9ydHMuQWdlbnQgPSBTb2Nrc0FnZW50LkFnZW50O1xuIiwiKGZ1bmN0aW9uIChwcm9jZXNzKXtcbnZhciB0bHMgPSByZXF1aXJlKCd0bHMnKTtcbnZhciBpbmhlcml0cyA9IHJlcXVpcmUoJ3V0aWwnKS5pbmhlcml0cztcbnZhciBFdmVudEVtaXR0ZXIgPSByZXF1aXJlKCdldmVudHMnKS5FdmVudEVtaXR0ZXI7XG52YXIgU29ja3NDbGllbnQgPSByZXF1aXJlKCcuL3NvY2tzLWNsaWVudC5qcycpO1xuXG5mdW5jdGlvbiBTb2Nrc0FnZW50KG9wdGlvbnMsIHNlY3VyZSwgcmVqZWN0VW5hdXRob3JpemVkKSB7XG4gICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcbiAgICB0aGlzLnNlY3VyZSA9IHNlY3VyZSB8fCBmYWxzZTtcbiAgICB0aGlzLnJlamVjdFVuYXV0aG9yaXplZCA9IHJlamVjdFVuYXV0aG9yaXplZDtcblxuICAgIGlmICh0aGlzLnJlamVjdFVuYXV0aG9yaXplZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRoaXMucmVqZWN0VW5hdXRob3JpemVkID0gdHJ1ZTtcbiAgICB9XG59XG5cbmluaGVyaXRzKFNvY2tzQWdlbnQsIEV2ZW50RW1pdHRlcik7XG5cblNvY2tzQWdlbnQucHJvdG90eXBlLmNyZWF0ZUNvbm5lY3Rpb24gPSBmdW5jdGlvbihyZXEsIG9wdHMsIGZuKSB7XG4gICAgdmFyIGhhbmRsZXIgPSBmbiwgaG9zdCwgc2VsZiA9IHRoaXM7XG5cbiAgICB0aGlzLm9wdGlvbnMudGFyZ2V0ID0gdGhpcy5vcHRpb25zLnRhcmdldCB8fCB7fTtcblxuICAgIGlmICghdGhpcy5vcHRpb25zLnRhcmdldC5ob3N0KSB7XG4gICAgICAgIHRoaXMub3B0aW9ucy50YXJnZXQuaG9zdCA9IG9wdHMuaG9zdDtcbiAgICB9XG5cbiAgICBpZiAoIXRoaXMub3B0aW9ucy50YXJnZXQucG9ydCkge1xuICAgICAgICB0aGlzLm9wdGlvbnMudGFyZ2V0LnBvcnQgPSBvcHRzLnBvcnQ7XG4gICAgfVxuXG4gICAgaG9zdCA9IHRoaXMub3B0aW9ucy50YXJnZXQuaG9zdDtcblxuICAgIGlmICh0aGlzLnNlY3VyZSkge1xuICAgICAgICBoYW5kbGVyID0gZnVuY3Rpb24oZXJyLCBzb2NrZXQsIGluZm8pIHtcbiAgICAgICAgICAgIHZhciBvcHRpb25zLCBjbGVhcnRleHQ7XG5cbiAgICAgICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZm4oZXJyKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gc2F2ZSBlbmNyeXB0ZWQgc29ja2V0XG4gICAgICAgICAgICBzZWxmLmVuY3J5cHRlZFNvY2tldCA9IHNvY2tldDtcblxuICAgICAgICAgICAgb3B0aW9ucyA9IHtcbiAgICAgICAgICAgICAgICBzb2NrZXQ6IHNvY2tldCxcbiAgICAgICAgICAgICAgICBzZXJ2ZXJuYW1lOiBob3N0LFxuICAgICAgICAgICAgICAgIHJlamVjdFVuYXV0aG9yaXplZDogc2VsZi5yZWplY3RVbmF1dGhvcml6ZWRcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIGNsZWFydGV4dCA9IHRscy5jb25uZWN0KG9wdGlvbnMsIGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZm4oZXJyLCB0aGlzKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgY2xlYXJ0ZXh0Lm9uKCdlcnJvcicsIGZuKTtcblxuICAgICAgICAgICAgc29ja2V0LnJlc3VtZSgpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgU29ja3NDbGllbnQuY3JlYXRlQ29ubmVjdGlvbih0aGlzLm9wdGlvbnMsIGhhbmRsZXIpO1xufTtcblxuLyoqXG4gKiBAc2VlIGh0dHBzOi8vd3d3Lm5wbWpzLmNvbS9wYWNrYWdlL2FnZW50LWJhc2VcbiAqL1xuU29ja3NBZ2VudC5wcm90b3R5cGUuYWRkUmVxdWVzdCA9IGZ1bmN0aW9uKHJlcSwgaG9zdCwgcG9ydCwgbG9jYWxBZGRyZXNzKSB7XG4gICAgdmFyIG9wdHM7XG4gICAgaWYgKCdvYmplY3QnID09PSB0eXBlb2YgaG9zdCkge1xuICAgICAgICAvLyA+PSB2MC4xMS54IEFQSVxuICAgICAgICBvcHRzID0gaG9zdDtcbiAgICAgICAgaWYgKG9wdHMuaG9zdCAmJiBvcHRzLnBhdGgpIHtcbiAgICAgICAgICAgIC8vIGlmIGJvdGggYSBgaG9zdGAgYW5kIGBwYXRoYCBhcmUgc3BlY2lmaWVkIHRoZW4gaXQncyBtb3N0IGxpa2VseSB0aGVcbiAgICAgICAgICAgIC8vIHJlc3VsdCBvZiBhIGB1cmwucGFyc2UoKWAgY2FsbC4uLiB3ZSBuZWVkIHRvIHJlbW92ZSB0aGUgYHBhdGhgIHBvcnRpb24gc29cbiAgICAgICAgICAgIC8vIHRoYXQgYG5ldC5jb25uZWN0KClgIGRvZXNuJ3QgYXR0ZW1wdCB0byBvcGVuIHRoYXQgYXMgYSB1bml4IHNvY2tldCBmaWxlLlxuICAgICAgICAgICAgZGVsZXRlIG9wdHMucGF0aDtcbiAgICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIDw9IHYwLjEwLnggQVBJXG4gICAgICAgIG9wdHMgPSB7IGhvc3Q6IGhvc3QsIHBvcnQ6IHBvcnQgfTtcbiAgICAgICAgaWYgKG51bGwgIT09IGxvY2FsQWRkcmVzcykge1xuICAgICAgICAgICAgb3B0cy5sb2NhbEFkZHJlc3MgPSBsb2NhbEFkZHJlc3M7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgc3luYyA9IHRydWU7XG5cbiAgICB0aGlzLmNyZWF0ZUNvbm5lY3Rpb24ocmVxLCBvcHRzLCBmdW5jdGlvbiAoZXJyLCBzb2NrZXQpIHtcbiAgICAgICAgZnVuY3Rpb24gZW1pdEVyciAoKSB7XG4gICAgICAgICAgICByZXEuZW1pdCgnZXJyb3InLCBlcnIpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgIGlmIChzeW5jKSB7XG4gICAgICAgICAgICAgICAgLy8gbmVlZCB0byBkZWZlciB0aGUgXCJlcnJvclwiIGV2ZW50LCB3aGVuIHN5bmMsIGJlY2F1c2UgYnkgbm93IHRoZSBgcmVxYFxuICAgICAgICAgICAgICAgIC8vIGluc3RhbmNlIGhhc24ndCBldmVudCBiZWVuIHBhc3NlZCBiYWNrIHRvIHRoZSB1c2VyIHlldC4uLlxuICAgICAgICAgICAgICAgIHByb2Nlc3MubmV4dFRpY2soZW1pdEVycik7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGVtaXRFcnIoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJlcS5vblNvY2tldChzb2NrZXQpO1xuICAgICAgICAgICAgLy9oYXZlIHRvIHJlc3VtZSB0aGlzIHNvY2tldCB3aGVuIG5vZGUgMTJcbiAgICAgICAgICAgIHNvY2tldC5yZXN1bWUoKTtcbiAgICAgICAgfVxuICAgIH0pO1xuXG4gICAgc3luYyA9IGZhbHNlO1xufTtcblxuZXhwb3J0cy5BZ2VudCA9IFNvY2tzQWdlbnQ7XG5cbn0pLmNhbGwodGhpcyxyZXF1aXJlKFwiN1lLSVBlXCIpKSIsIihmdW5jdGlvbiAoQnVmZmVyKXtcbnZhciBuZXQgPSByZXF1aXJlKCduZXQnKTtcbnZhciBpcCA9IHJlcXVpcmUoJ2lwJyk7XG52YXIgU21hcnRCdWZmZXIgPSByZXF1aXJlKCdzbWFydC1idWZmZXInKTtcblxuKGZ1bmN0aW9uICgpIHtcblxuICAgIHZhciBDT01NQU5EID0ge1xuICAgICAgICBDb25uZWN0OiAweDAxLFxuICAgICAgICBCaW5kOiAweDAyLFxuICAgICAgICBBc3NvY2lhdGU6IDB4MDNcbiAgICB9O1xuXG4gICAgdmFyIFNPQ0tTNF9SRVNQT05TRSA9IHtcbiAgICAgICAgR3JhbnRlZDogMHg1QSxcbiAgICAgICAgRmFpbGVkOiAweDVCLFxuICAgICAgICBSZWplY3RlZDogMHg1QyxcbiAgICAgICAgUmVqZWN0ZWRJZGVudDogMHg1RFxuICAgIH07XG5cbiAgICB2YXIgU09DS1M1X0FVVEggPSB7XG4gICAgICAgIE5vQXV0aDogMHgwMCxcbiAgICAgICAgR1NTQXBpOiAweDAxLFxuICAgICAgICBVc2VyUGFzczogMHgwMlxuICAgIH07XG5cbiAgICB2YXIgU09DS1M1X1JFU1BPTlNFID0ge1xuICAgICAgICBHcmFudGVkOiAweDAwLFxuICAgICAgICBGYWlsdXJlOiAweDAxLFxuICAgICAgICBOb3RBbGxvd2VkOiAweDAyLFxuICAgICAgICBOZXR3b3JrVW5yZWFjaGFibGU6IDB4MDMsXG4gICAgICAgIEhvc3RVbnJlYWNoYWJsZTogMHgwNCxcbiAgICAgICAgQ29ubmVjdGlvblJlZnVzZWQ6IDB4MDUsXG4gICAgICAgIFRUTEV4cGlyZWQ6IDB4MDYsXG4gICAgICAgIENvbW1hbmROb3RTdXBwb3J0ZWQ6IDB4MDcsXG4gICAgICAgIEFkZHJlc3NOb3RTdXBwb3J0ZWQ6IDB4MDhcbiAgICB9O1xuXG5cbiAgICBleHBvcnRzLmNyZWF0ZUNvbm5lY3Rpb24gPSBmdW5jdGlvbiAob3B0aW9ucywgY2FsbGJhY2spIHtcbiAgICAgICAgdmFyIHNvY2tldCA9IG5ldyBuZXQuU29ja2V0KCksIGZpbmlzaGVkID0gZmFsc2UsIGJ1ZmYgPSBuZXcgU21hcnRCdWZmZXIoKTtcblxuICAgICAgICAvLyBEZWZhdWx0c1xuICAgICAgICBvcHRpb25zLnRpbWVvdXQgPSBvcHRpb25zLnRpbWVvdXQgfHwgMTAwMDA7XG4gICAgICAgIG9wdGlvbnMucHJveHkuY29tbWFuZCA9IGNvbW1hbmRGcm9tU3RyaW5nKG9wdGlvbnMucHJveHkuY29tbWFuZCk7XG4gICAgICAgIG9wdGlvbnMucHJveHkudXNlcmlkID0gb3B0aW9ucy5wcm94eS51c2VyaWQgfHwgXCJcIjtcblxuICAgICAgICB2YXIgYXV0aCA9IG9wdGlvbnMucHJveHkuYXV0aGVudGljYXRpb24gfHwge307XG4gICAgICAgIGF1dGgudXNlcm5hbWUgPSBhdXRoLnVzZXJuYW1lIHx8IFwiXCI7XG4gICAgICAgIGF1dGgucGFzc3dvcmQgPSBhdXRoLnBhc3N3b3JkIHx8IFwiXCI7XG5cbiAgICAgICAgb3B0aW9ucy5wcm94eS5hdXRoZW50aWNhdGlvbiA9IGF1dGg7XG5cbiAgICAgICAgLy8gQ29ubmVjdCAmIG5lZ290aWF0aW9uIHRpbWVvdXRcbiAgICAgICAgZnVuY3Rpb24gb25UaW1lb3V0KCkge1xuICAgICAgICAgICAgZmluaXNoKG5ldyBFcnJvcihcIkNvbm5lY3Rpb24gVGltZWQgT3V0XCIpLCBzb2NrZXQsIG51bGwsIGNhbGxiYWNrKTtcbiAgICAgICAgfVxuICAgICAgICBzb2NrZXQuc2V0VGltZW91dChvcHRpb25zLnRpbWVvdXQsIG9uVGltZW91dCk7XG5cbiAgICAgICAgLy8gU29ja2V0IGV2ZW50c1xuICAgICAgICBzb2NrZXQub25jZSgnY2xvc2UnLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBmaW5pc2gobmV3IEVycm9yKFwiU29ja2V0IENsb3NlZFwiKSwgc29ja2V0LCBudWxsLCBjYWxsYmFjayk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHNvY2tldC5vbmNlKCdlcnJvcicsIGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgc29ja2V0Lm9uY2UoJ2Nvbm5lY3QnLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAob3B0aW9ucy5wcm94eS50eXBlID09PSA0KSB7XG4gICAgICAgICAgICAgICAgbmVnb3RpYXRlU29ja3M0KG9wdGlvbnMsIHNvY2tldCwgY2FsbGJhY2spO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChvcHRpb25zLnByb3h5LnR5cGUgPT09IDUpIHtcbiAgICAgICAgICAgICAgICBuZWdvdGlhdGVTb2NrczUob3B0aW9ucywgc29ja2V0LCBjYWxsYmFjayk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlBsZWFzZSBzcGVjaWZ5IGEgcHJveHkgdHlwZSBpbiBvcHRpb25zLnByb3h5LnR5cGVcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHNvY2tldC5jb25uZWN0KG9wdGlvbnMucHJveHkucG9ydCwgb3B0aW9ucy5wcm94eS5pcGFkZHJlc3MpO1xuXG5cbiAgICAgICAgLy8gNC80YSAgKGNvbm5lY3QsIGJpbmQpIC0gU3VwcG9ydHMgZG9tYWlucyAmIGlwYWRkcmVzc1xuICAgICAgICBmdW5jdGlvbiBuZWdvdGlhdGVTb2NrczQob3B0aW9ucywgc29ja2V0LCBjYWxsYmFjaykge1xuICAgICAgICAgICAgYnVmZi53cml0ZVVJbnQ4KDB4MDQpO1xuICAgICAgICAgICAgYnVmZi53cml0ZVVJbnQ4KG9wdGlvbnMucHJveHkuY29tbWFuZCk7XG4gICAgICAgICAgICBidWZmLndyaXRlVUludDE2QkUob3B0aW9ucy50YXJnZXQucG9ydCk7XG5cbiAgICAgICAgICAgIC8vIGlwdjQgb3IgZG9tYWluP1xuICAgICAgICAgICAgaWYgKG5ldC5pc0lQdjQob3B0aW9ucy50YXJnZXQuaG9zdCkpIHtcbiAgICAgICAgICAgICAgICBidWZmLndyaXRlQnVmZmVyKGlwLnRvQnVmZmVyKG9wdGlvbnMudGFyZ2V0Lmhvc3QpKTtcbiAgICAgICAgICAgICAgICBidWZmLndyaXRlU3RyaW5nTlQob3B0aW9ucy5wcm94eS51c2VyaWQpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBidWZmLndyaXRlVUludDgoMHgwMCk7XG4gICAgICAgICAgICAgICAgYnVmZi53cml0ZVVJbnQ4KDB4MDApO1xuICAgICAgICAgICAgICAgIGJ1ZmYud3JpdGVVSW50OCgweDAwKTtcbiAgICAgICAgICAgICAgICBidWZmLndyaXRlVUludDgoMHgwMSk7XG4gICAgICAgICAgICAgICAgYnVmZi53cml0ZVN0cmluZ05UKG9wdGlvbnMucHJveHkudXNlcmlkKTtcbiAgICAgICAgICAgICAgICBidWZmLndyaXRlU3RyaW5nTlQob3B0aW9ucy50YXJnZXQuaG9zdCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHNvY2tldC5vbmNlKCdkYXRhJywgcmVjZWl2ZWRSZXNwb25zZSk7XG4gICAgICAgICAgICBzb2NrZXQud3JpdGUoYnVmZi50b0J1ZmZlcigpKTtcblxuICAgICAgICAgICAgZnVuY3Rpb24gcmVjZWl2ZWRSZXNwb25zZShkYXRhKSB7XG4gICAgICAgICAgICAgICAgc29ja2V0LnBhdXNlKCk7XG4gICAgICAgICAgICAgICAgaWYgKGRhdGEubGVuZ3RoID09PSA4ICYmIGRhdGFbMV0gPT09IFNPQ0tTNF9SRVNQT05TRS5HcmFudGVkKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKG9wdGlvbnMucHJveHkuY29tbWFuZCA9PT0gQ09NTUFORC5CaW5kKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBidWZmLmNsZWFyKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBidWZmLndyaXRlQnVmZmVyKGRhdGEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnVmZi5za2lwKDIpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgaW5mbyA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwb3J0OiBidWZmLnJlYWRVSW50MTZCRSgpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhvc3Q6IGJ1ZmYucmVhZFVJbnQzMkJFKClcbiAgICAgICAgICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpbmZvLmhvc3QgPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbmZvLmhvc3QgPSBvcHRpb25zLnByb3h5LmlwYWRkcmVzcztcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5mby5ob3N0ID0gaXAuZnJvbUxvbmcoaW5mby5ob3N0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgZmluaXNoKG51bGwsIHNvY2tldCwgaW5mbywgY2FsbGJhY2spO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgZmluaXNoKG51bGwsIHNvY2tldCwgbnVsbCwgY2FsbGJhY2spO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBmaW5pc2gobmV3IEVycm9yKFwiUmVqZWN0ZWQgKFwiICsgZGF0YVsxXSArIFwiKVwiKSwgc29ja2V0LCBudWxsLCBjYWxsYmFjayk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gU29ja3MgNSAoY29ubmVjdCwgYmluZCwgYXNzb2NpYXRlKSAtIFN1cHBvcnRzIGRvbWFpbnMgYW5kIGlwdjQsIGlwdjYuXG4gICAgICAgIGZ1bmN0aW9uIG5lZ290aWF0ZVNvY2tzNShvcHRpb25zLCBzb2NrZXQsIGNhbGxiYWNrKSB7XG4gICAgICAgICAgICBidWZmLndyaXRlVUludDgoMHgwNSk7XG4gICAgICAgICAgICBidWZmLndyaXRlVUludDgoMik7XG4gICAgICAgICAgICBidWZmLndyaXRlVUludDgoU09DS1M1X0FVVEguTm9BdXRoKTtcbiAgICAgICAgICAgIGJ1ZmYud3JpdGVVSW50OChTT0NLUzVfQVVUSC5Vc2VyUGFzcyk7XG5cbiAgICAgICAgICAgIHNvY2tldC5vbmNlKCdkYXRhJywgaGFuZHNoYWtlKTtcbiAgICAgICAgICAgIHNvY2tldC53cml0ZShidWZmLnRvQnVmZmVyKCkpO1xuXG4gICAgICAgICAgICBmdW5jdGlvbiBoYW5kc2hha2UoZGF0YSkge1xuICAgICAgICAgICAgICAgIGlmIChkYXRhLmxlbmd0aCAhPT0gMikge1xuICAgICAgICAgICAgICAgICAgICBmaW5pc2gobmV3IEVycm9yKFwiTmVnb3RpYXRpb24gRXJyb3JcIiksIHNvY2tldCwgbnVsbCwgY2FsbGJhY2spO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoZGF0YVswXSAhPT0gMHgwNSkge1xuICAgICAgICAgICAgICAgICAgICBmaW5pc2gobmV3IEVycm9yKFwiTmVnb3RpYXRpb24gRXJyb3IgKGludmFsaWQgdmVyc2lvbilcIiksIHNvY2tldCwgbnVsbCwgY2FsbGJhY2spO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoZGF0YVsxXSA9PT0gMHhGRikge1xuICAgICAgICAgICAgICAgICAgICBmaW5pc2gobmV3IEVycm9yKFwiTmVnb3RpYXRpb24gRXJyb3IgKHVuYWNjZXB0YWJsZSBhdXRoZW50aWNhdGlvbilcIiksIHNvY2tldCwgbnVsbCwgY2FsbGJhY2spO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChkYXRhWzFdID09PSBTT0NLUzVfQVVUSC5Ob0F1dGgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbmRSZXF1ZXN0KCk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoZGF0YVsxXSA9PT0gU09DS1M1X0FVVEguVXNlclBhc3MpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbmRBdXRoZW50aWNhdGlvbihvcHRpb25zLnByb3h5LmF1dGhlbnRpY2F0aW9uKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZpbmlzaChuZXcgRXJyb3IoXCJOZWdvdGlhdGlvbiBFcnJvciAodW5rbm93biBhdXRoZW50aWNhdGlvbiB0eXBlKVwiKSwgc29ja2V0LCBudWxsLCBjYWxsYmFjayk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGZ1bmN0aW9uIHNlbmRBdXRoZW50aWNhdGlvbihhdXRoaW5mbykge1xuICAgICAgICAgICAgICAgIGJ1ZmYuY2xlYXIoKTtcbiAgICAgICAgICAgICAgICBidWZmLndyaXRlVUludDgoMHgwMSk7XG4gICAgICAgICAgICAgICAgYnVmZi53cml0ZVVJbnQ4KEJ1ZmZlci5ieXRlTGVuZ3RoKGF1dGhpbmZvLnVzZXJuYW1lKSk7XG4gICAgICAgICAgICAgICAgYnVmZi53cml0ZVN0cmluZyhhdXRoaW5mby51c2VybmFtZSk7XG4gICAgICAgICAgICAgICAgYnVmZi53cml0ZVVJbnQ4KEJ1ZmZlci5ieXRlTGVuZ3RoKGF1dGhpbmZvLnBhc3N3b3JkKSk7XG4gICAgICAgICAgICAgICAgYnVmZi53cml0ZVN0cmluZyhhdXRoaW5mby5wYXNzd29yZCk7XG5cbiAgICAgICAgICAgICAgICBzb2NrZXQub25jZSgnZGF0YScsIGF1dGhlbnRpY2F0aW9uUmVzcG9uc2UpO1xuICAgICAgICAgICAgICAgIHNvY2tldC53cml0ZShidWZmLnRvQnVmZmVyKCkpO1xuXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gYXV0aGVudGljYXRpb25SZXNwb25zZShkYXRhKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChkYXRhLmxlbmd0aCA9PT0gMiAmJiBkYXRhWzFdID09PSAweDAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZW5kUmVxdWVzdCgpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgZmluaXNoKG5ldyBFcnJvcihcIk5lZ290aWF0aW9uIEVycm9yIChhdXRoZW50aWNhdGlvbiBmYWlsZWQpXCIpLCBzb2NrZXQsIG51bGwsIGNhbGxiYWNrKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZnVuY3Rpb24gc2VuZFJlcXVlc3QoKSB7XG4gICAgICAgICAgICAgICAgYnVmZi5jbGVhcigpO1xuICAgICAgICAgICAgICAgIGJ1ZmYud3JpdGVVSW50OCgweDA1KTtcbiAgICAgICAgICAgICAgICBidWZmLndyaXRlVUludDgob3B0aW9ucy5wcm94eS5jb21tYW5kKTtcbiAgICAgICAgICAgICAgICBidWZmLndyaXRlVUludDgoMHgwMCk7XG5cbiAgICAgICAgICAgICAgICAvLyBpcHY0LCBpcHY2LCBkb21haW4/XG4gICAgICAgICAgICAgICAgaWYgKG5ldC5pc0lQdjQob3B0aW9ucy50YXJnZXQuaG9zdCkpIHtcbiAgICAgICAgICAgICAgICAgICAgYnVmZi53cml0ZVVJbnQ4KDB4MDEpO1xuICAgICAgICAgICAgICAgICAgICBidWZmLndyaXRlQnVmZmVyKGlwLnRvQnVmZmVyKG9wdGlvbnMudGFyZ2V0Lmhvc3QpKTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKG5ldC5pc0lQdjYob3B0aW9ucy50YXJnZXQuaG9zdCkpIHtcbiAgICAgICAgICAgICAgICAgICAgYnVmZi53cml0ZVVJbnQ4KDB4MDQpO1xuICAgICAgICAgICAgICAgICAgICBidWZmLndyaXRlQnVmZmVyKGlwLnRvQnVmZmVyKG9wdGlvbnMudGFyZ2V0Lmhvc3QpKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBidWZmLndyaXRlVUludDgoMHgwMyk7XG4gICAgICAgICAgICAgICAgICAgIGJ1ZmYud3JpdGVVSW50OChvcHRpb25zLnRhcmdldC5ob3N0Lmxlbmd0aCk7XG4gICAgICAgICAgICAgICAgICAgIGJ1ZmYud3JpdGVTdHJpbmcob3B0aW9ucy50YXJnZXQuaG9zdCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJ1ZmYud3JpdGVVSW50MTZCRShvcHRpb25zLnRhcmdldC5wb3J0KTtcblxuICAgICAgICAgICAgICAgIHNvY2tldC5vbmNlKCdkYXRhJywgcmVjZWl2ZWRSZXNwb25zZSk7XG4gICAgICAgICAgICAgICAgc29ja2V0LndyaXRlKGJ1ZmYudG9CdWZmZXIoKSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGZ1bmN0aW9uIHJlY2VpdmVkUmVzcG9uc2UoZGF0YSkge1xuICAgICAgICAgICAgICAgIHNvY2tldC5wYXVzZSgpO1xuICAgICAgICAgICAgICAgIGlmIChkYXRhLmxlbmd0aCA8IDQpIHtcbiAgICAgICAgICAgICAgICAgICAgZmluaXNoKG5ldyBFcnJvcihcIk5lZ290aWF0aW9uIEVycm9yXCIpLCBzb2NrZXQsIG51bGwsIGNhbGxiYWNrKTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGRhdGFbMF0gPT09IDB4MDUgJiYgZGF0YVsxXSA9PT0gU09DS1M1X1JFU1BPTlNFLkdyYW50ZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG9wdGlvbnMucHJveHkuY29tbWFuZCA9PT0gQ09NTUFORC5Db25uZWN0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBmaW5pc2gobnVsbCwgc29ja2V0LCBudWxsLCBjYWxsYmFjayk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAob3B0aW9ucy5wcm94eS5jb21tYW5kID09PSBDT01NQU5ELkJpbmQgfHwgb3B0aW9ucy5wcm94eS5jb21tYW5kID09PSBDT01NQU5ELkFzc29jaWF0ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYnVmZi5jbGVhcigpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnVmZi53cml0ZUJ1ZmZlcihkYXRhKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJ1ZmYuc2tpcCgzKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGluZm8gPSB7fTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBhZGRydHlwZSA9IGJ1ZmYucmVhZFVJbnQ4KCk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIHRyeSB7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoYWRkcnR5cGUgPT09IDB4MDEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5mby5ob3N0ID0gYnVmZi5yZWFkVUludDMyQkUoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGluZm8uaG9zdCA9PT0gMClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGluZm8uaG9zdCA9IG9wdGlvbnMucHJveHkuaXBhZGRyZXNzO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbmZvLmhvc3QgPSBpcC5mcm9tTG9uZyhpbmZvLmhvc3QpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoYWRkcnR5cGUgPT09IDB4MDMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGxlbiA9IGJ1ZmYucmVhZFVJbnQ4KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGluZm8uaG9zdCA9IGJ1ZmYucmVhZFN0cmluZyhsZW4pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoYWRkcnR5cGUgPT09IDB4MDQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5mby5ob3N0ID0gYnVmZi5yZWFkQnVmZmVyKDE2KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmaW5pc2gobmV3IEVycm9yKFwiTmVnb3RpYXRpb24gRXJyb3IgKGludmFsaWQgaG9zdCBhZGRyZXNzKVwiKSwgc29ja2V0LCBudWxsLCBjYWxsYmFjayk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGluZm8ucG9ydCA9IGJ1ZmYucmVhZFVJbnQxNkJFKCk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmaW5pc2gobnVsbCwgc29ja2V0LCBpbmZvLCBjYWxsYmFjayk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGNhdGNoIChleCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZpbmlzaChuZXcgRXJyb3IoXCJOZWdvdGlhdGlvbiBFcnJvciAobWlzc2luZyBkYXRhKVwiKSwgc29ja2V0LCBudWxsLCBjYWxsYmFjayk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBmaW5pc2gobmV3IEVycm9yKFwiTmVnb3RpYXRpb24gRXJyb3IgKFwiICsgZGF0YVsxXSArIFwiKVwiKSwgc29ja2V0LCBudWxsLCBjYWxsYmFjayk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gZmluaXNoKGVyciwgc29ja2V0LCBpbmZvLCBjYWxsYmFjaykge1xuICAgICAgICAgICAgc29ja2V0LnNldFRpbWVvdXQoMCwgb25UaW1lb3V0KTtcbiAgICAgICAgICAgIGlmICghZmluaXNoZWQpIHtcbiAgICAgICAgICAgICAgICBmaW5pc2hlZCA9IHRydWU7XG5cbiAgICAgICAgICAgICAgICBpZiAoYnVmZiBpbnN0YW5jZW9mIFNtYXJ0QnVmZmVyKVxuICAgICAgICAgICAgICAgICAgICBidWZmLmRlc3Ryb3koKTtcblxuICAgICAgICAgICAgICAgIGlmIChlcnIgJiYgc29ja2V0IGluc3RhbmNlb2YgbmV0LlNvY2tldCkge1xuICAgICAgICAgICAgICAgICAgICBzb2NrZXQucmVtb3ZlQWxsTGlzdGVuZXJzKCdjbG9zZScpO1xuICAgICAgICAgICAgICAgICAgICBzb2NrZXQucmVtb3ZlQWxsTGlzdGVuZXJzKCd0aW1lb3V0Jyk7XG4gICAgICAgICAgICAgICAgICAgIHNvY2tldC5yZW1vdmVBbGxMaXN0ZW5lcnMoJ2RhdGEnKTtcbiAgICAgICAgICAgICAgICAgICAgc29ja2V0LmRlc3Ryb3koKTtcbiAgICAgICAgICAgICAgICAgICAgc29ja2V0ID0gbnVsbDtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBjYWxsYmFjayhlcnIsIHNvY2tldCwgaW5mbyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiBjb21tYW5kRnJvbVN0cmluZyhzdHIpIHtcbiAgICAgICAgICAgIHZhciByZXN1bHQgPSBDT01NQU5ELkNvbm5lY3Q7XG5cbiAgICAgICAgICAgIGlmIChzdHIgPT09IFwiY29ubmVjdFwiKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gQ09NTUFORC5Db25uZWN0O1xuICAgICAgICAgICAgfSBlbHNlIGlmIChzdHIgPT09ICdhc3NvY2lhdGUnKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gQ09NTUFORC5Bc3NvY2lhdGU7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHN0ciA9PT0gJ2JpbmQnKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gQ09NTUFORC5CaW5kO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9XG4gICAgfTtcblxuXG4gICAgZXhwb3J0cy5jcmVhdGVVRFBGcmFtZSA9IGZ1bmN0aW9uICh0YXJnZXQsIGRhdGEsIGZyYW1lKSB7XG4gICAgICAgIHZhciBidWZmID0gbmV3IFNtYXJ0QnVmZmVyKCk7XG4gICAgICAgIGJ1ZmYud3JpdGVVSW50MTZCRSgwKTtcbiAgICAgICAgYnVmZi53cml0ZVVJbnQ4KGZyYW1lIHx8IDB4MDApO1xuXG4gICAgICAgIGlmIChuZXQuaXNJUHY0KHRhcmdldC5ob3N0KSkge1xuICAgICAgICAgICAgYnVmZi53cml0ZVVJbnQ4KDB4MDEpO1xuICAgICAgICAgICAgYnVmZi53cml0ZVVJbnQzMkJFKGlwLnRvTG9uZyh0YXJnZXQuaG9zdCkpO1xuICAgICAgICB9IGVsc2UgaWYgKG5ldC5pc0lQdjYodGFyZ2V0Lmhvc3QpKSB7XG4gICAgICAgICAgICBidWZmLndyaXRlVUludDgoMHgwNCk7XG4gICAgICAgICAgICBidWZmLndyaXRlQnVmZmVyKGlwLnRvQnVmZmVyKHRhcmdldC5ob3N0KSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBidWZmLndyaXRlVUludDgoMHgwMyk7XG4gICAgICAgICAgICBidWZmLndyaXRlVUludDgoQnVmZmVyLmJ5dGVMZW5ndGgodGFyZ2V0Lmhvc3QpKTtcbiAgICAgICAgICAgIGJ1ZmYud3JpdGVTdHJpbmcodGFyZ2V0Lmhvc3QpO1xuICAgICAgICB9XG5cbiAgICAgICAgYnVmZi53cml0ZVVJbnQxNkJFKHRhcmdldC5wb3J0KTtcbiAgICAgICAgYnVmZi53cml0ZUJ1ZmZlcihkYXRhKTtcbiAgICAgICAgcmV0dXJuIGJ1ZmYudG9CdWZmZXIoKTtcbiAgICB9O1xufSkoKTtcblxufSkuY2FsbCh0aGlzLHJlcXVpcmUoXCJidWZmZXJcIikuQnVmZmVyKSIsIm1vZHVsZS5leHBvcnRzPXtcbiAgXCJfYXJnc1wiOiBbXG4gICAgW1xuICAgICAgXCJub2RlbWFpbGVyXCIsXG4gICAgICBcIi9Vc2Vycy9uaG9uZy9uaWNraG9uZy5pb1wiXG4gICAgXVxuICBdLFxuICBcIl9mcm9tXCI6IFwibm9kZW1haWxlckBsYXRlc3RcIixcbiAgXCJfaWRcIjogXCJub2RlbWFpbGVyQDIuNC4xXCIsXG4gIFwiX2luQ2FjaGVcIjogdHJ1ZSxcbiAgXCJfaW5zdGFsbGFibGVcIjogdHJ1ZSxcbiAgXCJfbG9jYXRpb25cIjogXCIvbm9kZW1haWxlclwiLFxuICBcIl9ub2RlVmVyc2lvblwiOiBcIjYuMC4wXCIsXG4gIFwiX25wbU9wZXJhdGlvbmFsSW50ZXJuYWxcIjoge1xuICAgIFwiaG9zdFwiOiBcInBhY2thZ2VzLTEyLXdlc3QuaW50ZXJuYWwubnBtanMuY29tXCIsXG4gICAgXCJ0bXBcIjogXCJ0bXAvbm9kZW1haWxlci0yLjQuMS50Z3pfMTQ2MzA2NDk1Njc0OF8wLjM4MDgxMDk1OTczMDI5NzNcIlxuICB9LFxuICBcIl9ucG1Vc2VyXCI6IHtcbiAgICBcImVtYWlsXCI6IFwiYW5kcmlzQGtyZWF0YS5lZVwiLFxuICAgIFwibmFtZVwiOiBcImFuZHJpc1wiXG4gIH0sXG4gIFwiX25wbVZlcnNpb25cIjogXCIzLjguNlwiLFxuICBcIl9waGFudG9tQ2hpbGRyZW5cIjoge30sXG4gIFwiX3JlcXVlc3RlZFwiOiB7XG4gICAgXCJuYW1lXCI6IFwibm9kZW1haWxlclwiLFxuICAgIFwicmF3XCI6IFwibm9kZW1haWxlclwiLFxuICAgIFwicmF3U3BlY1wiOiBcIlwiLFxuICAgIFwic2NvcGVcIjogbnVsbCxcbiAgICBcInNwZWNcIjogXCJsYXRlc3RcIixcbiAgICBcInR5cGVcIjogXCJ0YWdcIlxuICB9LFxuICBcIl9yZXF1aXJlZEJ5XCI6IFtcbiAgICBcIi9cIlxuICBdLFxuICBcIl9yZXNvbHZlZFwiOiBcImh0dHBzOi8vcmVnaXN0cnkubnBtanMub3JnL25vZGVtYWlsZXIvLS9ub2RlbWFpbGVyLTIuNC4xLnRnelwiLFxuICBcIl9zaGFzdW1cIjogXCJkNWUzNzU5NzZmODc3MmRjYWE1YzQzZjA2NjkwMTFkNjJhZWFiOWUwXCIsXG4gIFwiX3Nocmlua3dyYXBcIjoge1xuICAgIFwiZGVwZW5kZW5jaWVzXCI6IHtcbiAgICAgIFwiYWRkcmVzc3BhcnNlclwiOiB7XG4gICAgICAgIFwiZnJvbVwiOiBcImFkZHJlc3NwYXJzZXJAMS4wLjFcIixcbiAgICAgICAgXCJyZXNvbHZlZFwiOiBcImh0dHBzOi8vcmVnaXN0cnkubnBtanMub3JnL2FkZHJlc3NwYXJzZXIvLS9hZGRyZXNzcGFyc2VyLTEuMC4xLnRnelwiLFxuICAgICAgICBcInZlcnNpb25cIjogXCIxLjAuMVwiXG4gICAgICB9LFxuICAgICAgXCJidWlsZG1haWxcIjoge1xuICAgICAgICBcImZyb21cIjogXCJidWlsZG1haWxAMy43LjBcIixcbiAgICAgICAgXCJyZXNvbHZlZFwiOiBcImh0dHBzOi8vcmVnaXN0cnkubnBtanMub3JnL2J1aWxkbWFpbC8tL2J1aWxkbWFpbC0zLjcuMC50Z3pcIixcbiAgICAgICAgXCJ2ZXJzaW9uXCI6IFwiMy43LjBcIlxuICAgICAgfSxcbiAgICAgIFwiaHR0cG50bG1cIjoge1xuICAgICAgICBcImZyb21cIjogXCJodHRwbnRsbUAxLjYuMVwiLFxuICAgICAgICBcInJlc29sdmVkXCI6IFwiaHR0cHM6Ly9yZWdpc3RyeS5ucG1qcy5vcmcvaHR0cG50bG0vLS9odHRwbnRsbS0xLjYuMS50Z3pcIixcbiAgICAgICAgXCJ2ZXJzaW9uXCI6IFwiMS42LjFcIlxuICAgICAgfSxcbiAgICAgIFwiaHR0cHJlcVwiOiB7XG4gICAgICAgIFwiZnJvbVwiOiBcImh0dHByZXFAPj0wLjQuMjJcIixcbiAgICAgICAgXCJyZXNvbHZlZFwiOiBcImh0dHBzOi8vcmVnaXN0cnkubnBtanMub3JnL2h0dHByZXEvLS9odHRwcmVxLTAuNC4yMi50Z3pcIixcbiAgICAgICAgXCJ2ZXJzaW9uXCI6IFwiMC40LjIyXCJcbiAgICAgIH0sXG4gICAgICBcImljb252LWxpdGVcIjoge1xuICAgICAgICBcImZyb21cIjogXCJpY29udi1saXRlQDAuNC4xM1wiLFxuICAgICAgICBcInJlc29sdmVkXCI6IFwiaHR0cHM6Ly9yZWdpc3RyeS5ucG1qcy5vcmcvaWNvbnYtbGl0ZS8tL2ljb252LWxpdGUtMC40LjEzLnRnelwiLFxuICAgICAgICBcInZlcnNpb25cIjogXCIwLjQuMTNcIlxuICAgICAgfSxcbiAgICAgIFwiaXBcIjoge1xuICAgICAgICBcImZyb21cIjogXCJpcEA+PTEuMS4yIDwyLjAuMFwiLFxuICAgICAgICBcInJlc29sdmVkXCI6IFwiaHR0cHM6Ly9yZWdpc3RyeS5ucG1qcy5vcmcvaXAvLS9pcC0xLjEuMy50Z3pcIixcbiAgICAgICAgXCJ2ZXJzaW9uXCI6IFwiMS4xLjNcIlxuICAgICAgfSxcbiAgICAgIFwibGliYmFzZTY0XCI6IHtcbiAgICAgICAgXCJmcm9tXCI6IFwibGliYmFzZTY0QDAuMS4wXCIsXG4gICAgICAgIFwicmVzb2x2ZWRcIjogXCJodHRwczovL3JlZ2lzdHJ5Lm5wbWpzLm9yZy9saWJiYXNlNjQvLS9saWJiYXNlNjQtMC4xLjAudGd6XCIsXG4gICAgICAgIFwidmVyc2lvblwiOiBcIjAuMS4wXCJcbiAgICAgIH0sXG4gICAgICBcImxpYm1pbWVcIjoge1xuICAgICAgICBcImZyb21cIjogXCJsaWJtaW1lQDIuMC4zXCIsXG4gICAgICAgIFwicmVzb2x2ZWRcIjogXCJodHRwczovL3JlZ2lzdHJ5Lm5wbWpzLm9yZy9saWJtaW1lLy0vbGlibWltZS0yLjAuMy50Z3pcIixcbiAgICAgICAgXCJ2ZXJzaW9uXCI6IFwiMi4wLjNcIlxuICAgICAgfSxcbiAgICAgIFwibGlicXBcIjoge1xuICAgICAgICBcImZyb21cIjogXCJsaWJxcEAxLjEuMFwiLFxuICAgICAgICBcInJlc29sdmVkXCI6IFwiaHR0cHM6Ly9yZWdpc3RyeS5ucG1qcy5vcmcvbGlicXAvLS9saWJxcC0xLjEuMC50Z3pcIixcbiAgICAgICAgXCJ2ZXJzaW9uXCI6IFwiMS4xLjBcIlxuICAgICAgfSxcbiAgICAgIFwibWFpbGNvbXBvc2VyXCI6IHtcbiAgICAgICAgXCJmcm9tXCI6IFwibWFpbGNvbXBvc2VyQDMuOS4wXCIsXG4gICAgICAgIFwicmVzb2x2ZWRcIjogXCJodHRwczovL3JlZ2lzdHJ5Lm5wbWpzLm9yZy9tYWlsY29tcG9zZXIvLS9tYWlsY29tcG9zZXItMy45LjAudGd6XCIsXG4gICAgICAgIFwidmVyc2lvblwiOiBcIjMuOS4wXCJcbiAgICAgIH0sXG4gICAgICBcIm5vZGVtYWlsZXItZGlyZWN0LXRyYW5zcG9ydFwiOiB7XG4gICAgICAgIFwiZnJvbVwiOiBcIm5vZGVtYWlsZXItZGlyZWN0LXRyYW5zcG9ydEAzLjEuMFwiLFxuICAgICAgICBcInJlc29sdmVkXCI6IFwiaHR0cHM6Ly9yZWdpc3RyeS5ucG1qcy5vcmcvbm9kZW1haWxlci1kaXJlY3QtdHJhbnNwb3J0Ly0vbm9kZW1haWxlci1kaXJlY3QtdHJhbnNwb3J0LTMuMS4wLnRnelwiLFxuICAgICAgICBcInZlcnNpb25cIjogXCIzLjEuMFwiXG4gICAgICB9LFxuICAgICAgXCJub2RlbWFpbGVyLWZldGNoXCI6IHtcbiAgICAgICAgXCJmcm9tXCI6IFwibm9kZW1haWxlci1mZXRjaEAxLjQuMFwiLFxuICAgICAgICBcInZlcnNpb25cIjogXCIxLjQuMFwiXG4gICAgICB9LFxuICAgICAgXCJub2RlbWFpbGVyLXNoYXJlZFwiOiB7XG4gICAgICAgIFwiZnJvbVwiOiBcIm5vZGVtYWlsZXItc2hhcmVkQDEuMC41XCIsXG4gICAgICAgIFwicmVzb2x2ZWRcIjogXCJodHRwczovL3JlZ2lzdHJ5Lm5wbWpzLm9yZy9ub2RlbWFpbGVyLXNoYXJlZC8tL25vZGVtYWlsZXItc2hhcmVkLTEuMC41LnRnelwiLFxuICAgICAgICBcInZlcnNpb25cIjogXCIxLjAuNVwiXG4gICAgICB9LFxuICAgICAgXCJub2RlbWFpbGVyLXNtdHAtcG9vbFwiOiB7XG4gICAgICAgIFwiZnJvbVwiOiBcIm5vZGVtYWlsZXItc210cC1wb29sQDIuNi4wXCIsXG4gICAgICAgIFwicmVzb2x2ZWRcIjogXCJodHRwczovL3JlZ2lzdHJ5Lm5wbWpzLm9yZy9ub2RlbWFpbGVyLXNtdHAtcG9vbC8tL25vZGVtYWlsZXItc210cC1wb29sLTIuNi4wLnRnelwiLFxuICAgICAgICBcInZlcnNpb25cIjogXCIyLjYuMFwiXG4gICAgICB9LFxuICAgICAgXCJub2RlbWFpbGVyLXNtdHAtdHJhbnNwb3J0XCI6IHtcbiAgICAgICAgXCJmcm9tXCI6IFwibm9kZW1haWxlci1zbXRwLXRyYW5zcG9ydEAyLjUuMFwiLFxuICAgICAgICBcInJlc29sdmVkXCI6IFwiaHR0cHM6Ly9yZWdpc3RyeS5ucG1qcy5vcmcvbm9kZW1haWxlci1zbXRwLXRyYW5zcG9ydC8tL25vZGVtYWlsZXItc210cC10cmFuc3BvcnQtMi41LjAudGd6XCIsXG4gICAgICAgIFwidmVyc2lvblwiOiBcIjIuNS4wXCJcbiAgICAgIH0sXG4gICAgICBcIm5vZGVtYWlsZXItd2VsbGtub3duXCI6IHtcbiAgICAgICAgXCJmcm9tXCI6IFwibm9kZW1haWxlci13ZWxsa25vd25AMC4xLjlcIixcbiAgICAgICAgXCJyZXNvbHZlZFwiOiBcImh0dHBzOi8vcmVnaXN0cnkubnBtanMub3JnL25vZGVtYWlsZXItd2VsbGtub3duLy0vbm9kZW1haWxlci13ZWxsa25vd24tMC4xLjkudGd6XCIsXG4gICAgICAgIFwidmVyc2lvblwiOiBcIjAuMS45XCJcbiAgICAgIH0sXG4gICAgICBcInNtYXJ0LWJ1ZmZlclwiOiB7XG4gICAgICAgIFwiZnJvbVwiOiBcInNtYXJ0LWJ1ZmZlckA+PTEuMC40IDwyLjAuMFwiLFxuICAgICAgICBcInJlc29sdmVkXCI6IFwiaHR0cHM6Ly9yZWdpc3RyeS5ucG1qcy5vcmcvc21hcnQtYnVmZmVyLy0vc21hcnQtYnVmZmVyLTEuMC45LnRnelwiLFxuICAgICAgICBcInZlcnNpb25cIjogXCIxLjAuOVwiXG4gICAgICB9LFxuICAgICAgXCJzbXRwLWNvbm5lY3Rpb25cIjoge1xuICAgICAgICBcImZyb21cIjogXCJzbXRwLWNvbm5lY3Rpb25AMi41LjBcIixcbiAgICAgICAgXCJyZXNvbHZlZFwiOiBcImh0dHBzOi8vcmVnaXN0cnkubnBtanMub3JnL3NtdHAtY29ubmVjdGlvbi8tL3NtdHAtY29ubmVjdGlvbi0yLjUuMC50Z3pcIixcbiAgICAgICAgXCJ2ZXJzaW9uXCI6IFwiMi41LjBcIlxuICAgICAgfSxcbiAgICAgIFwic29ja3NcIjoge1xuICAgICAgICBcImZyb21cIjogXCJzb2Nrc0AxLjEuOVwiLFxuICAgICAgICBcInJlc29sdmVkXCI6IFwiaHR0cHM6Ly9yZWdpc3RyeS5ucG1qcy5vcmcvc29ja3MvLS9zb2Nrcy0xLjEuOS50Z3pcIixcbiAgICAgICAgXCJ2ZXJzaW9uXCI6IFwiMS4xLjlcIlxuICAgICAgfSxcbiAgICAgIFwidW5kZXJzY29yZVwiOiB7XG4gICAgICAgIFwiZnJvbVwiOiBcInVuZGVyc2NvcmVAPj0xLjcuMCA8MS44LjBcIixcbiAgICAgICAgXCJyZXNvbHZlZFwiOiBcImh0dHBzOi8vcmVnaXN0cnkubnBtanMub3JnL3VuZGVyc2NvcmUvLS91bmRlcnNjb3JlLTEuNy4wLnRnelwiLFxuICAgICAgICBcInZlcnNpb25cIjogXCIxLjcuMFwiXG4gICAgICB9XG4gICAgfSxcbiAgICBcIm5hbWVcIjogXCJub2RlbWFpbGVyXCIsXG4gICAgXCJ2ZXJzaW9uXCI6IFwiMi40LjBcIlxuICB9LFxuICBcIl9zcGVjXCI6IFwibm9kZW1haWxlclwiLFxuICBcIl93aGVyZVwiOiBcIi9Vc2Vycy9uaG9uZy9uaWNraG9uZy5pb1wiLFxuICBcImF1dGhvclwiOiB7XG4gICAgXCJuYW1lXCI6IFwiQW5kcmlzIFJlaW5tYW5cIlxuICB9LFxuICBcImJ1Z3NcIjoge1xuICAgIFwidXJsXCI6IFwiaHR0cHM6Ly9naXRodWIuY29tL25vZGVtYWlsZXIvbm9kZW1haWxlci9pc3N1ZXNcIlxuICB9LFxuICBcImRlcGVuZGVuY2llc1wiOiB7XG4gICAgXCJsaWJtaW1lXCI6IFwiMi4wLjNcIixcbiAgICBcIm1haWxjb21wb3NlclwiOiBcIjMuOS4wXCIsXG4gICAgXCJub2RlbWFpbGVyLWRpcmVjdC10cmFuc3BvcnRcIjogXCIzLjEuMFwiLFxuICAgIFwibm9kZW1haWxlci1zaGFyZWRcIjogXCIxLjAuNVwiLFxuICAgIFwibm9kZW1haWxlci1zbXRwLXBvb2xcIjogXCIyLjYuMFwiLFxuICAgIFwibm9kZW1haWxlci1zbXRwLXRyYW5zcG9ydFwiOiBcIjIuNS4wXCIsXG4gICAgXCJzb2Nrc1wiOiBcIjEuMS45XCJcbiAgfSxcbiAgXCJkZXNjcmlwdGlvblwiOiBcIkVhc3kgYXMgY2FrZSBlLW1haWwgc2VuZGluZyBmcm9tIHlvdXIgTm9kZS5qcyBhcHBsaWNhdGlvbnNcIixcbiAgXCJkZXZEZXBlbmRlbmNpZXNcIjoge1xuICAgIFwiYW1xcFwiOiBcIl4wLjIuNFwiLFxuICAgIFwiY2hhaVwiOiBcIl4zLjUuMFwiLFxuICAgIFwiZW1haWwtdGVtcGxhdGVzXCI6IFwiXjIuMy4wXCIsXG4gICAgXCJncnVudFwiOiBcIl4xLjAuMVwiLFxuICAgIFwiZ3J1bnQtY2xpXCI6IFwiXjEuMi4wXCIsXG4gICAgXCJncnVudC1lc2xpbnRcIjogXCJeMTguMS4wXCIsXG4gICAgXCJncnVudC1tb2NoYS10ZXN0XCI6IFwiXjAuMTIuN1wiLFxuICAgIFwiaGFuZGxlYmFyc1wiOiBcIl40LjAuNVwiLFxuICAgIFwibW9jaGFcIjogXCJeMi40LjVcIixcbiAgICBcIm5vZGVtYWlsZXItZGtpbVwiOiBcIl4xLjAuNFwiLFxuICAgIFwibm9kZW1haWxlci1tYXJrZG93blwiOiBcIl4xLjAuMFwiLFxuICAgIFwibm9kZW1haWxlci1zdHViLXRyYW5zcG9ydFwiOiBcIl4xLjAuMFwiLFxuICAgIFwicHJveHktdGVzdC1zZXJ2ZXJcIjogXCJeMS4wLjBcIixcbiAgICBcInNpbm9uXCI6IFwiXjEuMTcuNFwiLFxuICAgIFwic210cC1zZXJ2ZXJcIjogXCJeMS45LjFcIixcbiAgICBcInN3aWctZW1haWwtdGVtcGxhdGVzXCI6IFwiXjIuMS4wXCJcbiAgfSxcbiAgXCJkaXJlY3Rvcmllc1wiOiB7fSxcbiAgXCJkaXN0XCI6IHtcbiAgICBcInNoYXN1bVwiOiBcImQ1ZTM3NTk3NmY4NzcyZGNhYTVjNDNmMDY2OTAxMWQ2MmFlYWI5ZTBcIixcbiAgICBcInRhcmJhbGxcIjogXCJodHRwczovL3JlZ2lzdHJ5Lm5wbWpzLm9yZy9ub2RlbWFpbGVyLy0vbm9kZW1haWxlci0yLjQuMS50Z3pcIlxuICB9LFxuICBcImVuZ2luZXNcIjoge1xuICAgIFwibm9kZVwiOiBcIj49MC4xMC4wXCJcbiAgfSxcbiAgXCJnaXRIZWFkXCI6IFwiZjQ5YzVjN2YyZGNjNzc1YTA3MmQxZTRiYWZlNTk3YWQzYmQ3M2Y4YVwiLFxuICBcImhvbWVwYWdlXCI6IFwiaHR0cDovL25vZGVtYWlsZXIuY29tL1wiLFxuICBcImtleXdvcmRzXCI6IFtcbiAgICBcImUtbWFpbFwiLFxuICAgIFwibWltZVwiLFxuICAgIFwiZW1haWxcIixcbiAgICBcIm1haWxcIixcbiAgICBcInNlbmRtYWlsXCIsXG4gICAgXCJzZXNcIixcbiAgICBcInNtdHBcIlxuICBdLFxuICBcImxpY2Vuc2VcIjogXCJNSVRcIixcbiAgXCJtYWluXCI6IFwibGliL25vZGVtYWlsZXIuanNcIixcbiAgXCJtYWludGFpbmVyc1wiOiBbXG4gICAge1xuICAgICAgXCJlbWFpbFwiOiBcImFuZHJpc0Bub2RlLmVlXCIsXG4gICAgICBcIm5hbWVcIjogXCJhbmRyaXNcIlxuICAgIH1cbiAgXSxcbiAgXCJuYW1lXCI6IFwibm9kZW1haWxlclwiLFxuICBcIm9wdGlvbmFsRGVwZW5kZW5jaWVzXCI6IHt9LFxuICBcInJlYWRtZVwiOiBcIkVSUk9SOiBObyBSRUFETUUgZGF0YSBmb3VuZCFcIixcbiAgXCJyZXBvc2l0b3J5XCI6IHtcbiAgICBcInR5cGVcIjogXCJnaXRcIixcbiAgICBcInVybFwiOiBcImdpdDovL2dpdGh1Yi5jb20vbm9kZW1haWxlci9ub2RlbWFpbGVyLmdpdFwiXG4gIH0sXG4gIFwic2NyaXB0c1wiOiB7XG4gICAgXCJ0ZXN0XCI6IFwiZ3J1bnRcIlxuICB9LFxuICBcInZlcnNpb25cIjogXCIyLjQuMVwiXG59XG4iLCJleHBvcnRzLmVuZGlhbm5lc3MgPSBmdW5jdGlvbiAoKSB7IHJldHVybiAnTEUnIH07XG5cbmV4cG9ydHMuaG9zdG5hbWUgPSBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKHR5cGVvZiBsb2NhdGlvbiAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgcmV0dXJuIGxvY2F0aW9uLmhvc3RuYW1lXG4gICAgfVxuICAgIGVsc2UgcmV0dXJuICcnO1xufTtcblxuZXhwb3J0cy5sb2FkYXZnID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gW10gfTtcblxuZXhwb3J0cy51cHRpbWUgPSBmdW5jdGlvbiAoKSB7IHJldHVybiAwIH07XG5cbmV4cG9ydHMuZnJlZW1lbSA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gTnVtYmVyLk1BWF9WQUxVRTtcbn07XG5cbmV4cG9ydHMudG90YWxtZW0gPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIE51bWJlci5NQVhfVkFMVUU7XG59O1xuXG5leHBvcnRzLmNwdXMgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBbXSB9O1xuXG5leHBvcnRzLnR5cGUgPSBmdW5jdGlvbiAoKSB7IHJldHVybiAnQnJvd3NlcicgfTtcblxuZXhwb3J0cy5yZWxlYXNlID0gZnVuY3Rpb24gKCkge1xuICAgIGlmICh0eXBlb2YgbmF2aWdhdG9yICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICByZXR1cm4gbmF2aWdhdG9yLmFwcFZlcnNpb247XG4gICAgfVxuICAgIHJldHVybiAnJztcbn07XG5cbmV4cG9ydHMubmV0d29ya0ludGVyZmFjZXNcbj0gZXhwb3J0cy5nZXROZXR3b3JrSW50ZXJmYWNlc1xuPSBmdW5jdGlvbiAoKSB7IHJldHVybiB7fSB9O1xuXG5leHBvcnRzLmFyY2ggPSBmdW5jdGlvbiAoKSB7IHJldHVybiAnamF2YXNjcmlwdCcgfTtcblxuZXhwb3J0cy5wbGF0Zm9ybSA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuICdicm93c2VyJyB9O1xuXG5leHBvcnRzLnRtcGRpciA9IGV4cG9ydHMudG1wRGlyID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiAnL3RtcCc7XG59O1xuXG5leHBvcnRzLkVPTCA9ICdcXG4nO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5cbnZhciBUWVBFRF9PSyA9ICAodHlwZW9mIFVpbnQ4QXJyYXkgIT09ICd1bmRlZmluZWQnKSAmJlxuICAgICAgICAgICAgICAgICh0eXBlb2YgVWludDE2QXJyYXkgIT09ICd1bmRlZmluZWQnKSAmJlxuICAgICAgICAgICAgICAgICh0eXBlb2YgSW50MzJBcnJheSAhPT0gJ3VuZGVmaW5lZCcpO1xuXG5cbmV4cG9ydHMuYXNzaWduID0gZnVuY3Rpb24gKG9iaiAvKmZyb20xLCBmcm9tMiwgZnJvbTMsIC4uLiovKSB7XG4gIHZhciBzb3VyY2VzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKTtcbiAgd2hpbGUgKHNvdXJjZXMubGVuZ3RoKSB7XG4gICAgdmFyIHNvdXJjZSA9IHNvdXJjZXMuc2hpZnQoKTtcbiAgICBpZiAoIXNvdXJjZSkgeyBjb250aW51ZTsgfVxuXG4gICAgaWYgKHR5cGVvZiBzb3VyY2UgIT09ICdvYmplY3QnKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKHNvdXJjZSArICdtdXN0IGJlIG5vbi1vYmplY3QnKTtcbiAgICB9XG5cbiAgICBmb3IgKHZhciBwIGluIHNvdXJjZSkge1xuICAgICAgaWYgKHNvdXJjZS5oYXNPd25Qcm9wZXJ0eShwKSkge1xuICAgICAgICBvYmpbcF0gPSBzb3VyY2VbcF07XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG9iajtcbn07XG5cblxuLy8gcmVkdWNlIGJ1ZmZlciBzaXplLCBhdm9pZGluZyBtZW0gY29weVxuZXhwb3J0cy5zaHJpbmtCdWYgPSBmdW5jdGlvbiAoYnVmLCBzaXplKSB7XG4gIGlmIChidWYubGVuZ3RoID09PSBzaXplKSB7IHJldHVybiBidWY7IH1cbiAgaWYgKGJ1Zi5zdWJhcnJheSkgeyByZXR1cm4gYnVmLnN1YmFycmF5KDAsIHNpemUpOyB9XG4gIGJ1Zi5sZW5ndGggPSBzaXplO1xuICByZXR1cm4gYnVmO1xufTtcblxuXG52YXIgZm5UeXBlZCA9IHtcbiAgYXJyYXlTZXQ6IGZ1bmN0aW9uIChkZXN0LCBzcmMsIHNyY19vZmZzLCBsZW4sIGRlc3Rfb2Zmcykge1xuICAgIGlmIChzcmMuc3ViYXJyYXkgJiYgZGVzdC5zdWJhcnJheSkge1xuICAgICAgZGVzdC5zZXQoc3JjLnN1YmFycmF5KHNyY19vZmZzLCBzcmNfb2ZmcytsZW4pLCBkZXN0X29mZnMpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICAvLyBGYWxsYmFjayB0byBvcmRpbmFyeSBhcnJheVxuICAgIGZvciAodmFyIGk9MDsgaTxsZW47IGkrKykge1xuICAgICAgZGVzdFtkZXN0X29mZnMgKyBpXSA9IHNyY1tzcmNfb2ZmcyArIGldO1xuICAgIH1cbiAgfSxcbiAgLy8gSm9pbiBhcnJheSBvZiBjaHVua3MgdG8gc2luZ2xlIGFycmF5LlxuICBmbGF0dGVuQ2h1bmtzOiBmdW5jdGlvbihjaHVua3MpIHtcbiAgICB2YXIgaSwgbCwgbGVuLCBwb3MsIGNodW5rLCByZXN1bHQ7XG5cbiAgICAvLyBjYWxjdWxhdGUgZGF0YSBsZW5ndGhcbiAgICBsZW4gPSAwO1xuICAgIGZvciAoaT0wLCBsPWNodW5rcy5sZW5ndGg7IGk8bDsgaSsrKSB7XG4gICAgICBsZW4gKz0gY2h1bmtzW2ldLmxlbmd0aDtcbiAgICB9XG5cbiAgICAvLyBqb2luIGNodW5rc1xuICAgIHJlc3VsdCA9IG5ldyBVaW50OEFycmF5KGxlbik7XG4gICAgcG9zID0gMDtcbiAgICBmb3IgKGk9MCwgbD1jaHVua3MubGVuZ3RoOyBpPGw7IGkrKykge1xuICAgICAgY2h1bmsgPSBjaHVua3NbaV07XG4gICAgICByZXN1bHQuc2V0KGNodW5rLCBwb3MpO1xuICAgICAgcG9zICs9IGNodW5rLmxlbmd0aDtcbiAgICB9XG5cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG59O1xuXG52YXIgZm5VbnR5cGVkID0ge1xuICBhcnJheVNldDogZnVuY3Rpb24gKGRlc3QsIHNyYywgc3JjX29mZnMsIGxlbiwgZGVzdF9vZmZzKSB7XG4gICAgZm9yICh2YXIgaT0wOyBpPGxlbjsgaSsrKSB7XG4gICAgICBkZXN0W2Rlc3Rfb2ZmcyArIGldID0gc3JjW3NyY19vZmZzICsgaV07XG4gICAgfVxuICB9LFxuICAvLyBKb2luIGFycmF5IG9mIGNodW5rcyB0byBzaW5nbGUgYXJyYXkuXG4gIGZsYXR0ZW5DaHVua3M6IGZ1bmN0aW9uKGNodW5rcykge1xuICAgIHJldHVybiBbXS5jb25jYXQuYXBwbHkoW10sIGNodW5rcyk7XG4gIH1cbn07XG5cblxuLy8gRW5hYmxlL0Rpc2FibGUgdHlwZWQgYXJyYXlzIHVzZSwgZm9yIHRlc3Rpbmdcbi8vXG5leHBvcnRzLnNldFR5cGVkID0gZnVuY3Rpb24gKG9uKSB7XG4gIGlmIChvbikge1xuICAgIGV4cG9ydHMuQnVmOCAgPSBVaW50OEFycmF5O1xuICAgIGV4cG9ydHMuQnVmMTYgPSBVaW50MTZBcnJheTtcbiAgICBleHBvcnRzLkJ1ZjMyID0gSW50MzJBcnJheTtcbiAgICBleHBvcnRzLmFzc2lnbihleHBvcnRzLCBmblR5cGVkKTtcbiAgfSBlbHNlIHtcbiAgICBleHBvcnRzLkJ1ZjggID0gQXJyYXk7XG4gICAgZXhwb3J0cy5CdWYxNiA9IEFycmF5O1xuICAgIGV4cG9ydHMuQnVmMzIgPSBBcnJheTtcbiAgICBleHBvcnRzLmFzc2lnbihleHBvcnRzLCBmblVudHlwZWQpO1xuICB9XG59O1xuXG5leHBvcnRzLnNldFR5cGVkKFRZUEVEX09LKTtcbiIsIid1c2Ugc3RyaWN0JztcblxuLy8gTm90ZTogYWRsZXIzMiB0YWtlcyAxMiUgZm9yIGxldmVsIDAgYW5kIDIlIGZvciBsZXZlbCA2LlxuLy8gSXQgZG9lc24ndCB3b3J0aCB0byBtYWtlIGFkZGl0aW9uYWwgb3B0aW1pemF0aW9uYSBhcyBpbiBvcmlnaW5hbC5cbi8vIFNtYWxsIHNpemUgaXMgcHJlZmVyYWJsZS5cblxuZnVuY3Rpb24gYWRsZXIzMihhZGxlciwgYnVmLCBsZW4sIHBvcykge1xuICB2YXIgczEgPSAoYWRsZXIgJiAweGZmZmYpIHwwLFxuICAgICAgczIgPSAoKGFkbGVyID4+PiAxNikgJiAweGZmZmYpIHwwLFxuICAgICAgbiA9IDA7XG5cbiAgd2hpbGUgKGxlbiAhPT0gMCkge1xuICAgIC8vIFNldCBsaW1pdCB+IHR3aWNlIGxlc3MgdGhhbiA1NTUyLCB0byBrZWVwXG4gICAgLy8gczIgaW4gMzEtYml0cywgYmVjYXVzZSB3ZSBmb3JjZSBzaWduZWQgaW50cy5cbiAgICAvLyBpbiBvdGhlciBjYXNlICU9IHdpbGwgZmFpbC5cbiAgICBuID0gbGVuID4gMjAwMCA/IDIwMDAgOiBsZW47XG4gICAgbGVuIC09IG47XG5cbiAgICBkbyB7XG4gICAgICBzMSA9IChzMSArIGJ1Zltwb3MrK10pIHwwO1xuICAgICAgczIgPSAoczIgKyBzMSkgfDA7XG4gICAgfSB3aGlsZSAoLS1uKTtcblxuICAgIHMxICU9IDY1NTIxO1xuICAgIHMyICU9IDY1NTIxO1xuICB9XG5cbiAgcmV0dXJuIChzMSB8IChzMiA8PCAxNikpIHwwO1xufVxuXG5cbm1vZHVsZS5leHBvcnRzID0gYWRsZXIzMjtcbiIsIm1vZHVsZS5leHBvcnRzID0ge1xuXG4gIC8qIEFsbG93ZWQgZmx1c2ggdmFsdWVzOyBzZWUgZGVmbGF0ZSgpIGFuZCBpbmZsYXRlKCkgYmVsb3cgZm9yIGRldGFpbHMgKi9cbiAgWl9OT19GTFVTSDogICAgICAgICAwLFxuICBaX1BBUlRJQUxfRkxVU0g6ICAgIDEsXG4gIFpfU1lOQ19GTFVTSDogICAgICAgMixcbiAgWl9GVUxMX0ZMVVNIOiAgICAgICAzLFxuICBaX0ZJTklTSDogICAgICAgICAgIDQsXG4gIFpfQkxPQ0s6ICAgICAgICAgICAgNSxcbiAgWl9UUkVFUzogICAgICAgICAgICA2LFxuXG4gIC8qIFJldHVybiBjb2RlcyBmb3IgdGhlIGNvbXByZXNzaW9uL2RlY29tcHJlc3Npb24gZnVuY3Rpb25zLiBOZWdhdGl2ZSB2YWx1ZXNcbiAgKiBhcmUgZXJyb3JzLCBwb3NpdGl2ZSB2YWx1ZXMgYXJlIHVzZWQgZm9yIHNwZWNpYWwgYnV0IG5vcm1hbCBldmVudHMuXG4gICovXG4gIFpfT0s6ICAgICAgICAgICAgICAgMCxcbiAgWl9TVFJFQU1fRU5EOiAgICAgICAxLFxuICBaX05FRURfRElDVDogICAgICAgIDIsXG4gIFpfRVJSTk86ICAgICAgICAgICAtMSxcbiAgWl9TVFJFQU1fRVJST1I6ICAgIC0yLFxuICBaX0RBVEFfRVJST1I6ICAgICAgLTMsXG4gIC8vWl9NRU1fRVJST1I6ICAgICAtNCxcbiAgWl9CVUZfRVJST1I6ICAgICAgIC01LFxuICAvL1pfVkVSU0lPTl9FUlJPUjogLTYsXG5cbiAgLyogY29tcHJlc3Npb24gbGV2ZWxzICovXG4gIFpfTk9fQ09NUFJFU1NJT046ICAgICAgICAgMCxcbiAgWl9CRVNUX1NQRUVEOiAgICAgICAgICAgICAxLFxuICBaX0JFU1RfQ09NUFJFU1NJT046ICAgICAgIDksXG4gIFpfREVGQVVMVF9DT01QUkVTU0lPTjogICAtMSxcblxuXG4gIFpfRklMVEVSRUQ6ICAgICAgICAgICAgICAgMSxcbiAgWl9IVUZGTUFOX09OTFk6ICAgICAgICAgICAyLFxuICBaX1JMRTogICAgICAgICAgICAgICAgICAgIDMsXG4gIFpfRklYRUQ6ICAgICAgICAgICAgICAgICAgNCxcbiAgWl9ERUZBVUxUX1NUUkFURUdZOiAgICAgICAwLFxuXG4gIC8qIFBvc3NpYmxlIHZhbHVlcyBvZiB0aGUgZGF0YV90eXBlIGZpZWxkICh0aG91Z2ggc2VlIGluZmxhdGUoKSkgKi9cbiAgWl9CSU5BUlk6ICAgICAgICAgICAgICAgICAwLFxuICBaX1RFWFQ6ICAgICAgICAgICAgICAgICAgIDEsXG4gIC8vWl9BU0NJSTogICAgICAgICAgICAgICAgMSwgLy8gPSBaX1RFWFQgKGRlcHJlY2F0ZWQpXG4gIFpfVU5LTk9XTjogICAgICAgICAgICAgICAgMixcblxuICAvKiBUaGUgZGVmbGF0ZSBjb21wcmVzc2lvbiBtZXRob2QgKi9cbiAgWl9ERUZMQVRFRDogICAgICAgICAgICAgICA4XG4gIC8vWl9OVUxMOiAgICAgICAgICAgICAgICAgbnVsbCAvLyBVc2UgLTEgb3IgbnVsbCBpbmxpbmUsIGRlcGVuZGluZyBvbiB2YXIgdHlwZVxufTtcbiIsIid1c2Ugc3RyaWN0JztcblxuLy8gTm90ZTogd2UgY2FuJ3QgZ2V0IHNpZ25pZmljYW50IHNwZWVkIGJvb3N0IGhlcmUuXG4vLyBTbyB3cml0ZSBjb2RlIHRvIG1pbmltaXplIHNpemUgLSBubyBwcmVnZW5lcmF0ZWQgdGFibGVzXG4vLyBhbmQgYXJyYXkgdG9vbHMgZGVwZW5kZW5jaWVzLlxuXG5cbi8vIFVzZSBvcmRpbmFyeSBhcnJheSwgc2luY2UgdW50eXBlZCBtYWtlcyBubyBib29zdCBoZXJlXG5mdW5jdGlvbiBtYWtlVGFibGUoKSB7XG4gIHZhciBjLCB0YWJsZSA9IFtdO1xuXG4gIGZvciAodmFyIG4gPTA7IG4gPCAyNTY7IG4rKykge1xuICAgIGMgPSBuO1xuICAgIGZvciAodmFyIGsgPTA7IGsgPCA4OyBrKyspIHtcbiAgICAgIGMgPSAoKGMmMSkgPyAoMHhFREI4ODMyMCBeIChjID4+PiAxKSkgOiAoYyA+Pj4gMSkpO1xuICAgIH1cbiAgICB0YWJsZVtuXSA9IGM7XG4gIH1cblxuICByZXR1cm4gdGFibGU7XG59XG5cbi8vIENyZWF0ZSB0YWJsZSBvbiBsb2FkLiBKdXN0IDI1NSBzaWduZWQgbG9uZ3MuIE5vdCBhIHByb2JsZW0uXG52YXIgY3JjVGFibGUgPSBtYWtlVGFibGUoKTtcblxuXG5mdW5jdGlvbiBjcmMzMihjcmMsIGJ1ZiwgbGVuLCBwb3MpIHtcbiAgdmFyIHQgPSBjcmNUYWJsZSxcbiAgICAgIGVuZCA9IHBvcyArIGxlbjtcblxuICBjcmMgPSBjcmMgXiAoLTEpO1xuXG4gIGZvciAodmFyIGkgPSBwb3M7IGkgPCBlbmQ7IGkrKykge1xuICAgIGNyYyA9IChjcmMgPj4+IDgpIF4gdFsoY3JjIF4gYnVmW2ldKSAmIDB4RkZdO1xuICB9XG5cbiAgcmV0dXJuIChjcmMgXiAoLTEpKTsgLy8gPj4+IDA7XG59XG5cblxubW9kdWxlLmV4cG9ydHMgPSBjcmMzMjtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIHV0aWxzICAgPSByZXF1aXJlKCcuLi91dGlscy9jb21tb24nKTtcbnZhciB0cmVlcyAgID0gcmVxdWlyZSgnLi90cmVlcycpO1xudmFyIGFkbGVyMzIgPSByZXF1aXJlKCcuL2FkbGVyMzInKTtcbnZhciBjcmMzMiAgID0gcmVxdWlyZSgnLi9jcmMzMicpO1xudmFyIG1zZyAgID0gcmVxdWlyZSgnLi9tZXNzYWdlcycpO1xuXG4vKiBQdWJsaWMgY29uc3RhbnRzID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0qL1xuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09Ki9cblxuXG4vKiBBbGxvd2VkIGZsdXNoIHZhbHVlczsgc2VlIGRlZmxhdGUoKSBhbmQgaW5mbGF0ZSgpIGJlbG93IGZvciBkZXRhaWxzICovXG52YXIgWl9OT19GTFVTSCAgICAgID0gMDtcbnZhciBaX1BBUlRJQUxfRkxVU0ggPSAxO1xuLy92YXIgWl9TWU5DX0ZMVVNIICAgID0gMjtcbnZhciBaX0ZVTExfRkxVU0ggICAgPSAzO1xudmFyIFpfRklOSVNIICAgICAgICA9IDQ7XG52YXIgWl9CTE9DSyAgICAgICAgID0gNTtcbi8vdmFyIFpfVFJFRVMgICAgICAgICA9IDY7XG5cblxuLyogUmV0dXJuIGNvZGVzIGZvciB0aGUgY29tcHJlc3Npb24vZGVjb21wcmVzc2lvbiBmdW5jdGlvbnMuIE5lZ2F0aXZlIHZhbHVlc1xuICogYXJlIGVycm9ycywgcG9zaXRpdmUgdmFsdWVzIGFyZSB1c2VkIGZvciBzcGVjaWFsIGJ1dCBub3JtYWwgZXZlbnRzLlxuICovXG52YXIgWl9PSyAgICAgICAgICAgID0gMDtcbnZhciBaX1NUUkVBTV9FTkQgICAgPSAxO1xuLy92YXIgWl9ORUVEX0RJQ1QgICAgID0gMjtcbi8vdmFyIFpfRVJSTk8gICAgICAgICA9IC0xO1xudmFyIFpfU1RSRUFNX0VSUk9SICA9IC0yO1xudmFyIFpfREFUQV9FUlJPUiAgICA9IC0zO1xuLy92YXIgWl9NRU1fRVJST1IgICAgID0gLTQ7XG52YXIgWl9CVUZfRVJST1IgICAgID0gLTU7XG4vL3ZhciBaX1ZFUlNJT05fRVJST1IgPSAtNjtcblxuXG4vKiBjb21wcmVzc2lvbiBsZXZlbHMgKi9cbi8vdmFyIFpfTk9fQ09NUFJFU1NJT04gICAgICA9IDA7XG4vL3ZhciBaX0JFU1RfU1BFRUQgICAgICAgICAgPSAxO1xuLy92YXIgWl9CRVNUX0NPTVBSRVNTSU9OICAgID0gOTtcbnZhciBaX0RFRkFVTFRfQ09NUFJFU1NJT04gPSAtMTtcblxuXG52YXIgWl9GSUxURVJFRCAgICAgICAgICAgID0gMTtcbnZhciBaX0hVRkZNQU5fT05MWSAgICAgICAgPSAyO1xudmFyIFpfUkxFICAgICAgICAgICAgICAgICA9IDM7XG52YXIgWl9GSVhFRCAgICAgICAgICAgICAgID0gNDtcbnZhciBaX0RFRkFVTFRfU1RSQVRFR1kgICAgPSAwO1xuXG4vKiBQb3NzaWJsZSB2YWx1ZXMgb2YgdGhlIGRhdGFfdHlwZSBmaWVsZCAodGhvdWdoIHNlZSBpbmZsYXRlKCkpICovXG4vL3ZhciBaX0JJTkFSWSAgICAgICAgICAgICAgPSAwO1xuLy92YXIgWl9URVhUICAgICAgICAgICAgICAgID0gMTtcbi8vdmFyIFpfQVNDSUkgICAgICAgICAgICAgICA9IDE7IC8vID0gWl9URVhUXG52YXIgWl9VTktOT1dOICAgICAgICAgICAgID0gMjtcblxuXG4vKiBUaGUgZGVmbGF0ZSBjb21wcmVzc2lvbiBtZXRob2QgKi9cbnZhciBaX0RFRkxBVEVEICA9IDg7XG5cbi8qPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PSovXG5cblxudmFyIE1BWF9NRU1fTEVWRUwgPSA5O1xuLyogTWF4aW11bSB2YWx1ZSBmb3IgbWVtTGV2ZWwgaW4gZGVmbGF0ZUluaXQyICovXG52YXIgTUFYX1dCSVRTID0gMTU7XG4vKiAzMksgTFo3NyB3aW5kb3cgKi9cbnZhciBERUZfTUVNX0xFVkVMID0gODtcblxuXG52YXIgTEVOR1RIX0NPREVTICA9IDI5O1xuLyogbnVtYmVyIG9mIGxlbmd0aCBjb2Rlcywgbm90IGNvdW50aW5nIHRoZSBzcGVjaWFsIEVORF9CTE9DSyBjb2RlICovXG52YXIgTElURVJBTFMgICAgICA9IDI1Njtcbi8qIG51bWJlciBvZiBsaXRlcmFsIGJ5dGVzIDAuLjI1NSAqL1xudmFyIExfQ09ERVMgICAgICAgPSBMSVRFUkFMUyArIDEgKyBMRU5HVEhfQ09ERVM7XG4vKiBudW1iZXIgb2YgTGl0ZXJhbCBvciBMZW5ndGggY29kZXMsIGluY2x1ZGluZyB0aGUgRU5EX0JMT0NLIGNvZGUgKi9cbnZhciBEX0NPREVTICAgICAgID0gMzA7XG4vKiBudW1iZXIgb2YgZGlzdGFuY2UgY29kZXMgKi9cbnZhciBCTF9DT0RFUyAgICAgID0gMTk7XG4vKiBudW1iZXIgb2YgY29kZXMgdXNlZCB0byB0cmFuc2ZlciB0aGUgYml0IGxlbmd0aHMgKi9cbnZhciBIRUFQX1NJWkUgICAgID0gMipMX0NPREVTICsgMTtcbi8qIG1heGltdW0gaGVhcCBzaXplICovXG52YXIgTUFYX0JJVFMgID0gMTU7XG4vKiBBbGwgY29kZXMgbXVzdCBub3QgZXhjZWVkIE1BWF9CSVRTIGJpdHMgKi9cblxudmFyIE1JTl9NQVRDSCA9IDM7XG52YXIgTUFYX01BVENIID0gMjU4O1xudmFyIE1JTl9MT09LQUhFQUQgPSAoTUFYX01BVENIICsgTUlOX01BVENIICsgMSk7XG5cbnZhciBQUkVTRVRfRElDVCA9IDB4MjA7XG5cbnZhciBJTklUX1NUQVRFID0gNDI7XG52YXIgRVhUUkFfU1RBVEUgPSA2OTtcbnZhciBOQU1FX1NUQVRFID0gNzM7XG52YXIgQ09NTUVOVF9TVEFURSA9IDkxO1xudmFyIEhDUkNfU1RBVEUgPSAxMDM7XG52YXIgQlVTWV9TVEFURSA9IDExMztcbnZhciBGSU5JU0hfU1RBVEUgPSA2NjY7XG5cbnZhciBCU19ORUVEX01PUkUgICAgICA9IDE7IC8qIGJsb2NrIG5vdCBjb21wbGV0ZWQsIG5lZWQgbW9yZSBpbnB1dCBvciBtb3JlIG91dHB1dCAqL1xudmFyIEJTX0JMT0NLX0RPTkUgICAgID0gMjsgLyogYmxvY2sgZmx1c2ggcGVyZm9ybWVkICovXG52YXIgQlNfRklOSVNIX1NUQVJURUQgPSAzOyAvKiBmaW5pc2ggc3RhcnRlZCwgbmVlZCBvbmx5IG1vcmUgb3V0cHV0IGF0IG5leHQgZGVmbGF0ZSAqL1xudmFyIEJTX0ZJTklTSF9ET05FICAgID0gNDsgLyogZmluaXNoIGRvbmUsIGFjY2VwdCBubyBtb3JlIGlucHV0IG9yIG91dHB1dCAqL1xuXG52YXIgT1NfQ09ERSA9IDB4MDM7IC8vIFVuaXggOikgLiBEb24ndCBkZXRlY3QsIHVzZSB0aGlzIGRlZmF1bHQuXG5cbmZ1bmN0aW9uIGVycihzdHJtLCBlcnJvckNvZGUpIHtcbiAgc3RybS5tc2cgPSBtc2dbZXJyb3JDb2RlXTtcbiAgcmV0dXJuIGVycm9yQ29kZTtcbn1cblxuZnVuY3Rpb24gcmFuayhmKSB7XG4gIHJldHVybiAoKGYpIDw8IDEpIC0gKChmKSA+IDQgPyA5IDogMCk7XG59XG5cbmZ1bmN0aW9uIHplcm8oYnVmKSB7IHZhciBsZW4gPSBidWYubGVuZ3RoOyB3aGlsZSAoLS1sZW4gPj0gMCkgeyBidWZbbGVuXSA9IDA7IH0gfVxuXG5cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIEZsdXNoIGFzIG11Y2ggcGVuZGluZyBvdXRwdXQgYXMgcG9zc2libGUuIEFsbCBkZWZsYXRlKCkgb3V0cHV0IGdvZXNcbiAqIHRocm91Z2ggdGhpcyBmdW5jdGlvbiBzbyBzb21lIGFwcGxpY2F0aW9ucyBtYXkgd2lzaCB0byBtb2RpZnkgaXRcbiAqIHRvIGF2b2lkIGFsbG9jYXRpbmcgYSBsYXJnZSBzdHJtLT5vdXRwdXQgYnVmZmVyIGFuZCBjb3B5aW5nIGludG8gaXQuXG4gKiAoU2VlIGFsc28gcmVhZF9idWYoKSkuXG4gKi9cbmZ1bmN0aW9uIGZsdXNoX3BlbmRpbmcoc3RybSkge1xuICB2YXIgcyA9IHN0cm0uc3RhdGU7XG5cbiAgLy9fdHJfZmx1c2hfYml0cyhzKTtcbiAgdmFyIGxlbiA9IHMucGVuZGluZztcbiAgaWYgKGxlbiA+IHN0cm0uYXZhaWxfb3V0KSB7XG4gICAgbGVuID0gc3RybS5hdmFpbF9vdXQ7XG4gIH1cbiAgaWYgKGxlbiA9PT0gMCkgeyByZXR1cm47IH1cblxuICB1dGlscy5hcnJheVNldChzdHJtLm91dHB1dCwgcy5wZW5kaW5nX2J1Ziwgcy5wZW5kaW5nX291dCwgbGVuLCBzdHJtLm5leHRfb3V0KTtcbiAgc3RybS5uZXh0X291dCArPSBsZW47XG4gIHMucGVuZGluZ19vdXQgKz0gbGVuO1xuICBzdHJtLnRvdGFsX291dCArPSBsZW47XG4gIHN0cm0uYXZhaWxfb3V0IC09IGxlbjtcbiAgcy5wZW5kaW5nIC09IGxlbjtcbiAgaWYgKHMucGVuZGluZyA9PT0gMCkge1xuICAgIHMucGVuZGluZ19vdXQgPSAwO1xuICB9XG59XG5cblxuZnVuY3Rpb24gZmx1c2hfYmxvY2tfb25seSAocywgbGFzdCkge1xuICB0cmVlcy5fdHJfZmx1c2hfYmxvY2socywgKHMuYmxvY2tfc3RhcnQgPj0gMCA/IHMuYmxvY2tfc3RhcnQgOiAtMSksIHMuc3Ryc3RhcnQgLSBzLmJsb2NrX3N0YXJ0LCBsYXN0KTtcbiAgcy5ibG9ja19zdGFydCA9IHMuc3Ryc3RhcnQ7XG4gIGZsdXNoX3BlbmRpbmcocy5zdHJtKTtcbn1cblxuXG5mdW5jdGlvbiBwdXRfYnl0ZShzLCBiKSB7XG4gIHMucGVuZGluZ19idWZbcy5wZW5kaW5nKytdID0gYjtcbn1cblxuXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBQdXQgYSBzaG9ydCBpbiB0aGUgcGVuZGluZyBidWZmZXIuIFRoZSAxNi1iaXQgdmFsdWUgaXMgcHV0IGluIE1TQiBvcmRlci5cbiAqIElOIGFzc2VydGlvbjogdGhlIHN0cmVhbSBzdGF0ZSBpcyBjb3JyZWN0IGFuZCB0aGVyZSBpcyBlbm91Z2ggcm9vbSBpblxuICogcGVuZGluZ19idWYuXG4gKi9cbmZ1bmN0aW9uIHB1dFNob3J0TVNCKHMsIGIpIHtcbi8vICBwdXRfYnl0ZShzLCAoQnl0ZSkoYiA+PiA4KSk7XG4vLyAgcHV0X2J5dGUocywgKEJ5dGUpKGIgJiAweGZmKSk7XG4gIHMucGVuZGluZ19idWZbcy5wZW5kaW5nKytdID0gKGIgPj4+IDgpICYgMHhmZjtcbiAgcy5wZW5kaW5nX2J1ZltzLnBlbmRpbmcrK10gPSBiICYgMHhmZjtcbn1cblxuXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIFJlYWQgYSBuZXcgYnVmZmVyIGZyb20gdGhlIGN1cnJlbnQgaW5wdXQgc3RyZWFtLCB1cGRhdGUgdGhlIGFkbGVyMzJcbiAqIGFuZCB0b3RhbCBudW1iZXIgb2YgYnl0ZXMgcmVhZC4gIEFsbCBkZWZsYXRlKCkgaW5wdXQgZ29lcyB0aHJvdWdoXG4gKiB0aGlzIGZ1bmN0aW9uIHNvIHNvbWUgYXBwbGljYXRpb25zIG1heSB3aXNoIHRvIG1vZGlmeSBpdCB0byBhdm9pZFxuICogYWxsb2NhdGluZyBhIGxhcmdlIHN0cm0tPmlucHV0IGJ1ZmZlciBhbmQgY29weWluZyBmcm9tIGl0LlxuICogKFNlZSBhbHNvIGZsdXNoX3BlbmRpbmcoKSkuXG4gKi9cbmZ1bmN0aW9uIHJlYWRfYnVmKHN0cm0sIGJ1Ziwgc3RhcnQsIHNpemUpIHtcbiAgdmFyIGxlbiA9IHN0cm0uYXZhaWxfaW47XG5cbiAgaWYgKGxlbiA+IHNpemUpIHsgbGVuID0gc2l6ZTsgfVxuICBpZiAobGVuID09PSAwKSB7IHJldHVybiAwOyB9XG5cbiAgc3RybS5hdmFpbF9pbiAtPSBsZW47XG5cbiAgdXRpbHMuYXJyYXlTZXQoYnVmLCBzdHJtLmlucHV0LCBzdHJtLm5leHRfaW4sIGxlbiwgc3RhcnQpO1xuICBpZiAoc3RybS5zdGF0ZS53cmFwID09PSAxKSB7XG4gICAgc3RybS5hZGxlciA9IGFkbGVyMzIoc3RybS5hZGxlciwgYnVmLCBsZW4sIHN0YXJ0KTtcbiAgfVxuXG4gIGVsc2UgaWYgKHN0cm0uc3RhdGUud3JhcCA9PT0gMikge1xuICAgIHN0cm0uYWRsZXIgPSBjcmMzMihzdHJtLmFkbGVyLCBidWYsIGxlbiwgc3RhcnQpO1xuICB9XG5cbiAgc3RybS5uZXh0X2luICs9IGxlbjtcbiAgc3RybS50b3RhbF9pbiArPSBsZW47XG5cbiAgcmV0dXJuIGxlbjtcbn1cblxuXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIFNldCBtYXRjaF9zdGFydCB0byB0aGUgbG9uZ2VzdCBtYXRjaCBzdGFydGluZyBhdCB0aGUgZ2l2ZW4gc3RyaW5nIGFuZFxuICogcmV0dXJuIGl0cyBsZW5ndGguIE1hdGNoZXMgc2hvcnRlciBvciBlcXVhbCB0byBwcmV2X2xlbmd0aCBhcmUgZGlzY2FyZGVkLFxuICogaW4gd2hpY2ggY2FzZSB0aGUgcmVzdWx0IGlzIGVxdWFsIHRvIHByZXZfbGVuZ3RoIGFuZCBtYXRjaF9zdGFydCBpc1xuICogZ2FyYmFnZS5cbiAqIElOIGFzc2VydGlvbnM6IGN1cl9tYXRjaCBpcyB0aGUgaGVhZCBvZiB0aGUgaGFzaCBjaGFpbiBmb3IgdGhlIGN1cnJlbnRcbiAqICAgc3RyaW5nIChzdHJzdGFydCkgYW5kIGl0cyBkaXN0YW5jZSBpcyA8PSBNQVhfRElTVCwgYW5kIHByZXZfbGVuZ3RoID49IDFcbiAqIE9VVCBhc3NlcnRpb246IHRoZSBtYXRjaCBsZW5ndGggaXMgbm90IGdyZWF0ZXIgdGhhbiBzLT5sb29rYWhlYWQuXG4gKi9cbmZ1bmN0aW9uIGxvbmdlc3RfbWF0Y2gocywgY3VyX21hdGNoKSB7XG4gIHZhciBjaGFpbl9sZW5ndGggPSBzLm1heF9jaGFpbl9sZW5ndGg7ICAgICAgLyogbWF4IGhhc2ggY2hhaW4gbGVuZ3RoICovXG4gIHZhciBzY2FuID0gcy5zdHJzdGFydDsgLyogY3VycmVudCBzdHJpbmcgKi9cbiAgdmFyIG1hdGNoOyAgICAgICAgICAgICAgICAgICAgICAgLyogbWF0Y2hlZCBzdHJpbmcgKi9cbiAgdmFyIGxlbjsgICAgICAgICAgICAgICAgICAgICAgICAgICAvKiBsZW5ndGggb2YgY3VycmVudCBtYXRjaCAqL1xuICB2YXIgYmVzdF9sZW4gPSBzLnByZXZfbGVuZ3RoOyAgICAgICAgICAgICAgLyogYmVzdCBtYXRjaCBsZW5ndGggc28gZmFyICovXG4gIHZhciBuaWNlX21hdGNoID0gcy5uaWNlX21hdGNoOyAgICAgICAgICAgICAvKiBzdG9wIGlmIG1hdGNoIGxvbmcgZW5vdWdoICovXG4gIHZhciBsaW1pdCA9IChzLnN0cnN0YXJ0ID4gKHMud19zaXplIC0gTUlOX0xPT0tBSEVBRCkpID9cbiAgICAgIHMuc3Ryc3RhcnQgLSAocy53X3NpemUgLSBNSU5fTE9PS0FIRUFEKSA6IDAvKk5JTCovO1xuXG4gIHZhciBfd2luID0gcy53aW5kb3c7IC8vIHNob3J0Y3V0XG5cbiAgdmFyIHdtYXNrID0gcy53X21hc2s7XG4gIHZhciBwcmV2ICA9IHMucHJldjtcblxuICAvKiBTdG9wIHdoZW4gY3VyX21hdGNoIGJlY29tZXMgPD0gbGltaXQuIFRvIHNpbXBsaWZ5IHRoZSBjb2RlLFxuICAgKiB3ZSBwcmV2ZW50IG1hdGNoZXMgd2l0aCB0aGUgc3RyaW5nIG9mIHdpbmRvdyBpbmRleCAwLlxuICAgKi9cblxuICB2YXIgc3RyZW5kID0gcy5zdHJzdGFydCArIE1BWF9NQVRDSDtcbiAgdmFyIHNjYW5fZW5kMSAgPSBfd2luW3NjYW4gKyBiZXN0X2xlbiAtIDFdO1xuICB2YXIgc2Nhbl9lbmQgICA9IF93aW5bc2NhbiArIGJlc3RfbGVuXTtcblxuICAvKiBUaGUgY29kZSBpcyBvcHRpbWl6ZWQgZm9yIEhBU0hfQklUUyA+PSA4IGFuZCBNQVhfTUFUQ0gtMiBtdWx0aXBsZSBvZiAxNi5cbiAgICogSXQgaXMgZWFzeSB0byBnZXQgcmlkIG9mIHRoaXMgb3B0aW1pemF0aW9uIGlmIG5lY2Vzc2FyeS5cbiAgICovXG4gIC8vIEFzc2VydChzLT5oYXNoX2JpdHMgPj0gOCAmJiBNQVhfTUFUQ0ggPT0gMjU4LCBcIkNvZGUgdG9vIGNsZXZlclwiKTtcblxuICAvKiBEbyBub3Qgd2FzdGUgdG9vIG11Y2ggdGltZSBpZiB3ZSBhbHJlYWR5IGhhdmUgYSBnb29kIG1hdGNoOiAqL1xuICBpZiAocy5wcmV2X2xlbmd0aCA+PSBzLmdvb2RfbWF0Y2gpIHtcbiAgICBjaGFpbl9sZW5ndGggPj49IDI7XG4gIH1cbiAgLyogRG8gbm90IGxvb2sgZm9yIG1hdGNoZXMgYmV5b25kIHRoZSBlbmQgb2YgdGhlIGlucHV0LiBUaGlzIGlzIG5lY2Vzc2FyeVxuICAgKiB0byBtYWtlIGRlZmxhdGUgZGV0ZXJtaW5pc3RpYy5cbiAgICovXG4gIGlmIChuaWNlX21hdGNoID4gcy5sb29rYWhlYWQpIHsgbmljZV9tYXRjaCA9IHMubG9va2FoZWFkOyB9XG5cbiAgLy8gQXNzZXJ0KCh1bGcpcy0+c3Ryc3RhcnQgPD0gcy0+d2luZG93X3NpemUtTUlOX0xPT0tBSEVBRCwgXCJuZWVkIGxvb2thaGVhZFwiKTtcblxuICBkbyB7XG4gICAgLy8gQXNzZXJ0KGN1cl9tYXRjaCA8IHMtPnN0cnN0YXJ0LCBcIm5vIGZ1dHVyZVwiKTtcbiAgICBtYXRjaCA9IGN1cl9tYXRjaDtcblxuICAgIC8qIFNraXAgdG8gbmV4dCBtYXRjaCBpZiB0aGUgbWF0Y2ggbGVuZ3RoIGNhbm5vdCBpbmNyZWFzZVxuICAgICAqIG9yIGlmIHRoZSBtYXRjaCBsZW5ndGggaXMgbGVzcyB0aGFuIDIuICBOb3RlIHRoYXQgdGhlIGNoZWNrcyBiZWxvd1xuICAgICAqIGZvciBpbnN1ZmZpY2llbnQgbG9va2FoZWFkIG9ubHkgb2NjdXIgb2NjYXNpb25hbGx5IGZvciBwZXJmb3JtYW5jZVxuICAgICAqIHJlYXNvbnMuICBUaGVyZWZvcmUgdW5pbml0aWFsaXplZCBtZW1vcnkgd2lsbCBiZSBhY2Nlc3NlZCwgYW5kXG4gICAgICogY29uZGl0aW9uYWwganVtcHMgd2lsbCBiZSBtYWRlIHRoYXQgZGVwZW5kIG9uIHRob3NlIHZhbHVlcy5cbiAgICAgKiBIb3dldmVyIHRoZSBsZW5ndGggb2YgdGhlIG1hdGNoIGlzIGxpbWl0ZWQgdG8gdGhlIGxvb2thaGVhZCwgc29cbiAgICAgKiB0aGUgb3V0cHV0IG9mIGRlZmxhdGUgaXMgbm90IGFmZmVjdGVkIGJ5IHRoZSB1bmluaXRpYWxpemVkIHZhbHVlcy5cbiAgICAgKi9cblxuICAgIGlmIChfd2luW21hdGNoICsgYmVzdF9sZW5dICAgICAhPT0gc2Nhbl9lbmQgIHx8XG4gICAgICAgIF93aW5bbWF0Y2ggKyBiZXN0X2xlbiAtIDFdICE9PSBzY2FuX2VuZDEgfHxcbiAgICAgICAgX3dpblttYXRjaF0gICAgICAgICAgICAgICAgIT09IF93aW5bc2Nhbl0gfHxcbiAgICAgICAgX3dpblsrK21hdGNoXSAgICAgICAgICAgICAgIT09IF93aW5bc2NhbiArIDFdKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICAvKiBUaGUgY2hlY2sgYXQgYmVzdF9sZW4tMSBjYW4gYmUgcmVtb3ZlZCBiZWNhdXNlIGl0IHdpbGwgYmUgbWFkZVxuICAgICAqIGFnYWluIGxhdGVyLiAoVGhpcyBoZXVyaXN0aWMgaXMgbm90IGFsd2F5cyBhIHdpbi4pXG4gICAgICogSXQgaXMgbm90IG5lY2Vzc2FyeSB0byBjb21wYXJlIHNjYW5bMl0gYW5kIG1hdGNoWzJdIHNpbmNlIHRoZXlcbiAgICAgKiBhcmUgYWx3YXlzIGVxdWFsIHdoZW4gdGhlIG90aGVyIGJ5dGVzIG1hdGNoLCBnaXZlbiB0aGF0XG4gICAgICogdGhlIGhhc2gga2V5cyBhcmUgZXF1YWwgYW5kIHRoYXQgSEFTSF9CSVRTID49IDguXG4gICAgICovXG4gICAgc2NhbiArPSAyO1xuICAgIG1hdGNoKys7XG4gICAgLy8gQXNzZXJ0KCpzY2FuID09ICptYXRjaCwgXCJtYXRjaFsyXT9cIik7XG5cbiAgICAvKiBXZSBjaGVjayBmb3IgaW5zdWZmaWNpZW50IGxvb2thaGVhZCBvbmx5IGV2ZXJ5IDh0aCBjb21wYXJpc29uO1xuICAgICAqIHRoZSAyNTZ0aCBjaGVjayB3aWxsIGJlIG1hZGUgYXQgc3Ryc3RhcnQrMjU4LlxuICAgICAqL1xuICAgIGRvIHtcbiAgICAgIC8qanNoaW50IG5vZW1wdHk6ZmFsc2UqL1xuICAgIH0gd2hpbGUgKF93aW5bKytzY2FuXSA9PT0gX3dpblsrK21hdGNoXSAmJiBfd2luWysrc2Nhbl0gPT09IF93aW5bKyttYXRjaF0gJiZcbiAgICAgICAgICAgICBfd2luWysrc2Nhbl0gPT09IF93aW5bKyttYXRjaF0gJiYgX3dpblsrK3NjYW5dID09PSBfd2luWysrbWF0Y2hdICYmXG4gICAgICAgICAgICAgX3dpblsrK3NjYW5dID09PSBfd2luWysrbWF0Y2hdICYmIF93aW5bKytzY2FuXSA9PT0gX3dpblsrK21hdGNoXSAmJlxuICAgICAgICAgICAgIF93aW5bKytzY2FuXSA9PT0gX3dpblsrK21hdGNoXSAmJiBfd2luWysrc2Nhbl0gPT09IF93aW5bKyttYXRjaF0gJiZcbiAgICAgICAgICAgICBzY2FuIDwgc3RyZW5kKTtcblxuICAgIC8vIEFzc2VydChzY2FuIDw9IHMtPndpbmRvdysodW5zaWduZWQpKHMtPndpbmRvd19zaXplLTEpLCBcIndpbGQgc2NhblwiKTtcblxuICAgIGxlbiA9IE1BWF9NQVRDSCAtIChzdHJlbmQgLSBzY2FuKTtcbiAgICBzY2FuID0gc3RyZW5kIC0gTUFYX01BVENIO1xuXG4gICAgaWYgKGxlbiA+IGJlc3RfbGVuKSB7XG4gICAgICBzLm1hdGNoX3N0YXJ0ID0gY3VyX21hdGNoO1xuICAgICAgYmVzdF9sZW4gPSBsZW47XG4gICAgICBpZiAobGVuID49IG5pY2VfbWF0Y2gpIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBzY2FuX2VuZDEgID0gX3dpbltzY2FuICsgYmVzdF9sZW4gLSAxXTtcbiAgICAgIHNjYW5fZW5kICAgPSBfd2luW3NjYW4gKyBiZXN0X2xlbl07XG4gICAgfVxuICB9IHdoaWxlICgoY3VyX21hdGNoID0gcHJldltjdXJfbWF0Y2ggJiB3bWFza10pID4gbGltaXQgJiYgLS1jaGFpbl9sZW5ndGggIT09IDApO1xuXG4gIGlmIChiZXN0X2xlbiA8PSBzLmxvb2thaGVhZCkge1xuICAgIHJldHVybiBiZXN0X2xlbjtcbiAgfVxuICByZXR1cm4gcy5sb29rYWhlYWQ7XG59XG5cblxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBGaWxsIHRoZSB3aW5kb3cgd2hlbiB0aGUgbG9va2FoZWFkIGJlY29tZXMgaW5zdWZmaWNpZW50LlxuICogVXBkYXRlcyBzdHJzdGFydCBhbmQgbG9va2FoZWFkLlxuICpcbiAqIElOIGFzc2VydGlvbjogbG9va2FoZWFkIDwgTUlOX0xPT0tBSEVBRFxuICogT1VUIGFzc2VydGlvbnM6IHN0cnN0YXJ0IDw9IHdpbmRvd19zaXplLU1JTl9MT09LQUhFQURcbiAqICAgIEF0IGxlYXN0IG9uZSBieXRlIGhhcyBiZWVuIHJlYWQsIG9yIGF2YWlsX2luID09IDA7IHJlYWRzIGFyZVxuICogICAgcGVyZm9ybWVkIGZvciBhdCBsZWFzdCB0d28gYnl0ZXMgKHJlcXVpcmVkIGZvciB0aGUgemlwIHRyYW5zbGF0ZV9lb2xcbiAqICAgIG9wdGlvbiAtLSBub3Qgc3VwcG9ydGVkIGhlcmUpLlxuICovXG5mdW5jdGlvbiBmaWxsX3dpbmRvdyhzKSB7XG4gIHZhciBfd19zaXplID0gcy53X3NpemU7XG4gIHZhciBwLCBuLCBtLCBtb3JlLCBzdHI7XG5cbiAgLy9Bc3NlcnQocy0+bG9va2FoZWFkIDwgTUlOX0xPT0tBSEVBRCwgXCJhbHJlYWR5IGVub3VnaCBsb29rYWhlYWRcIik7XG5cbiAgZG8ge1xuICAgIG1vcmUgPSBzLndpbmRvd19zaXplIC0gcy5sb29rYWhlYWQgLSBzLnN0cnN0YXJ0O1xuXG4gICAgLy8gSlMgaW50cyBoYXZlIDMyIGJpdCwgYmxvY2sgYmVsb3cgbm90IG5lZWRlZFxuICAgIC8qIERlYWwgd2l0aCAhQCMkJSA2NEsgbGltaXQ6ICovXG4gICAgLy9pZiAoc2l6ZW9mKGludCkgPD0gMikge1xuICAgIC8vICAgIGlmIChtb3JlID09IDAgJiYgcy0+c3Ryc3RhcnQgPT0gMCAmJiBzLT5sb29rYWhlYWQgPT0gMCkge1xuICAgIC8vICAgICAgICBtb3JlID0gd3NpemU7XG4gICAgLy9cbiAgICAvLyAgfSBlbHNlIGlmIChtb3JlID09ICh1bnNpZ25lZCkoLTEpKSB7XG4gICAgLy8gICAgICAgIC8qIFZlcnkgdW5saWtlbHksIGJ1dCBwb3NzaWJsZSBvbiAxNiBiaXQgbWFjaGluZSBpZlxuICAgIC8vICAgICAgICAgKiBzdHJzdGFydCA9PSAwICYmIGxvb2thaGVhZCA9PSAxIChpbnB1dCBkb25lIGEgYnl0ZSBhdCB0aW1lKVxuICAgIC8vICAgICAgICAgKi9cbiAgICAvLyAgICAgICAgbW9yZS0tO1xuICAgIC8vICAgIH1cbiAgICAvL31cblxuXG4gICAgLyogSWYgdGhlIHdpbmRvdyBpcyBhbG1vc3QgZnVsbCBhbmQgdGhlcmUgaXMgaW5zdWZmaWNpZW50IGxvb2thaGVhZCxcbiAgICAgKiBtb3ZlIHRoZSB1cHBlciBoYWxmIHRvIHRoZSBsb3dlciBvbmUgdG8gbWFrZSByb29tIGluIHRoZSB1cHBlciBoYWxmLlxuICAgICAqL1xuICAgIGlmIChzLnN0cnN0YXJ0ID49IF93X3NpemUgKyAoX3dfc2l6ZSAtIE1JTl9MT09LQUhFQUQpKSB7XG5cbiAgICAgIHV0aWxzLmFycmF5U2V0KHMud2luZG93LCBzLndpbmRvdywgX3dfc2l6ZSwgX3dfc2l6ZSwgMCk7XG4gICAgICBzLm1hdGNoX3N0YXJ0IC09IF93X3NpemU7XG4gICAgICBzLnN0cnN0YXJ0IC09IF93X3NpemU7XG4gICAgICAvKiB3ZSBub3cgaGF2ZSBzdHJzdGFydCA+PSBNQVhfRElTVCAqL1xuICAgICAgcy5ibG9ja19zdGFydCAtPSBfd19zaXplO1xuXG4gICAgICAvKiBTbGlkZSB0aGUgaGFzaCB0YWJsZSAoY291bGQgYmUgYXZvaWRlZCB3aXRoIDMyIGJpdCB2YWx1ZXNcbiAgICAgICBhdCB0aGUgZXhwZW5zZSBvZiBtZW1vcnkgdXNhZ2UpLiBXZSBzbGlkZSBldmVuIHdoZW4gbGV2ZWwgPT0gMFxuICAgICAgIHRvIGtlZXAgdGhlIGhhc2ggdGFibGUgY29uc2lzdGVudCBpZiB3ZSBzd2l0Y2ggYmFjayB0byBsZXZlbCA+IDBcbiAgICAgICBsYXRlci4gKFVzaW5nIGxldmVsIDAgcGVybWFuZW50bHkgaXMgbm90IGFuIG9wdGltYWwgdXNhZ2Ugb2ZcbiAgICAgICB6bGliLCBzbyB3ZSBkb24ndCBjYXJlIGFib3V0IHRoaXMgcGF0aG9sb2dpY2FsIGNhc2UuKVxuICAgICAgICovXG5cbiAgICAgIG4gPSBzLmhhc2hfc2l6ZTtcbiAgICAgIHAgPSBuO1xuICAgICAgZG8ge1xuICAgICAgICBtID0gcy5oZWFkWy0tcF07XG4gICAgICAgIHMuaGVhZFtwXSA9IChtID49IF93X3NpemUgPyBtIC0gX3dfc2l6ZSA6IDApO1xuICAgICAgfSB3aGlsZSAoLS1uKTtcblxuICAgICAgbiA9IF93X3NpemU7XG4gICAgICBwID0gbjtcbiAgICAgIGRvIHtcbiAgICAgICAgbSA9IHMucHJldlstLXBdO1xuICAgICAgICBzLnByZXZbcF0gPSAobSA+PSBfd19zaXplID8gbSAtIF93X3NpemUgOiAwKTtcbiAgICAgICAgLyogSWYgbiBpcyBub3Qgb24gYW55IGhhc2ggY2hhaW4sIHByZXZbbl0gaXMgZ2FyYmFnZSBidXRcbiAgICAgICAgICogaXRzIHZhbHVlIHdpbGwgbmV2ZXIgYmUgdXNlZC5cbiAgICAgICAgICovXG4gICAgICB9IHdoaWxlICgtLW4pO1xuXG4gICAgICBtb3JlICs9IF93X3NpemU7XG4gICAgfVxuICAgIGlmIChzLnN0cm0uYXZhaWxfaW4gPT09IDApIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cblxuICAgIC8qIElmIHRoZXJlIHdhcyBubyBzbGlkaW5nOlxuICAgICAqICAgIHN0cnN0YXJ0IDw9IFdTSVpFK01BWF9ESVNULTEgJiYgbG9va2FoZWFkIDw9IE1JTl9MT09LQUhFQUQgLSAxICYmXG4gICAgICogICAgbW9yZSA9PSB3aW5kb3dfc2l6ZSAtIGxvb2thaGVhZCAtIHN0cnN0YXJ0XG4gICAgICogPT4gbW9yZSA+PSB3aW5kb3dfc2l6ZSAtIChNSU5fTE9PS0FIRUFELTEgKyBXU0laRSArIE1BWF9ESVNULTEpXG4gICAgICogPT4gbW9yZSA+PSB3aW5kb3dfc2l6ZSAtIDIqV1NJWkUgKyAyXG4gICAgICogSW4gdGhlIEJJR19NRU0gb3IgTU1BUCBjYXNlIChub3QgeWV0IHN1cHBvcnRlZCksXG4gICAgICogICB3aW5kb3dfc2l6ZSA9PSBpbnB1dF9zaXplICsgTUlOX0xPT0tBSEVBRCAgJiZcbiAgICAgKiAgIHN0cnN0YXJ0ICsgcy0+bG9va2FoZWFkIDw9IGlucHV0X3NpemUgPT4gbW9yZSA+PSBNSU5fTE9PS0FIRUFELlxuICAgICAqIE90aGVyd2lzZSwgd2luZG93X3NpemUgPT0gMipXU0laRSBzbyBtb3JlID49IDIuXG4gICAgICogSWYgdGhlcmUgd2FzIHNsaWRpbmcsIG1vcmUgPj0gV1NJWkUuIFNvIGluIGFsbCBjYXNlcywgbW9yZSA+PSAyLlxuICAgICAqL1xuICAgIC8vQXNzZXJ0KG1vcmUgPj0gMiwgXCJtb3JlIDwgMlwiKTtcbiAgICBuID0gcmVhZF9idWYocy5zdHJtLCBzLndpbmRvdywgcy5zdHJzdGFydCArIHMubG9va2FoZWFkLCBtb3JlKTtcbiAgICBzLmxvb2thaGVhZCArPSBuO1xuXG4gICAgLyogSW5pdGlhbGl6ZSB0aGUgaGFzaCB2YWx1ZSBub3cgdGhhdCB3ZSBoYXZlIHNvbWUgaW5wdXQ6ICovXG4gICAgaWYgKHMubG9va2FoZWFkICsgcy5pbnNlcnQgPj0gTUlOX01BVENIKSB7XG4gICAgICBzdHIgPSBzLnN0cnN0YXJ0IC0gcy5pbnNlcnQ7XG4gICAgICBzLmluc19oID0gcy53aW5kb3dbc3RyXTtcblxuICAgICAgLyogVVBEQVRFX0hBU0gocywgcy0+aW5zX2gsIHMtPndpbmRvd1tzdHIgKyAxXSk7ICovXG4gICAgICBzLmluc19oID0gKChzLmluc19oIDw8IHMuaGFzaF9zaGlmdCkgXiBzLndpbmRvd1tzdHIgKyAxXSkgJiBzLmhhc2hfbWFzaztcbi8vI2lmIE1JTl9NQVRDSCAhPSAzXG4vLyAgICAgICAgQ2FsbCB1cGRhdGVfaGFzaCgpIE1JTl9NQVRDSC0zIG1vcmUgdGltZXNcbi8vI2VuZGlmXG4gICAgICB3aGlsZSAocy5pbnNlcnQpIHtcbiAgICAgICAgLyogVVBEQVRFX0hBU0gocywgcy0+aW5zX2gsIHMtPndpbmRvd1tzdHIgKyBNSU5fTUFUQ0gtMV0pOyAqL1xuICAgICAgICBzLmluc19oID0gKChzLmluc19oIDw8IHMuaGFzaF9zaGlmdCkgXiBzLndpbmRvd1tzdHIgKyBNSU5fTUFUQ0gtMV0pICYgcy5oYXNoX21hc2s7XG5cbiAgICAgICAgcy5wcmV2W3N0ciAmIHMud19tYXNrXSA9IHMuaGVhZFtzLmluc19oXTtcbiAgICAgICAgcy5oZWFkW3MuaW5zX2hdID0gc3RyO1xuICAgICAgICBzdHIrKztcbiAgICAgICAgcy5pbnNlcnQtLTtcbiAgICAgICAgaWYgKHMubG9va2FoZWFkICsgcy5pbnNlcnQgPCBNSU5fTUFUQ0gpIHtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICAvKiBJZiB0aGUgd2hvbGUgaW5wdXQgaGFzIGxlc3MgdGhhbiBNSU5fTUFUQ0ggYnl0ZXMsIGluc19oIGlzIGdhcmJhZ2UsXG4gICAgICogYnV0IHRoaXMgaXMgbm90IGltcG9ydGFudCBzaW5jZSBvbmx5IGxpdGVyYWwgYnl0ZXMgd2lsbCBiZSBlbWl0dGVkLlxuICAgICAqL1xuXG4gIH0gd2hpbGUgKHMubG9va2FoZWFkIDwgTUlOX0xPT0tBSEVBRCAmJiBzLnN0cm0uYXZhaWxfaW4gIT09IDApO1xuXG4gIC8qIElmIHRoZSBXSU5fSU5JVCBieXRlcyBhZnRlciB0aGUgZW5kIG9mIHRoZSBjdXJyZW50IGRhdGEgaGF2ZSBuZXZlciBiZWVuXG4gICAqIHdyaXR0ZW4sIHRoZW4gemVybyB0aG9zZSBieXRlcyBpbiBvcmRlciB0byBhdm9pZCBtZW1vcnkgY2hlY2sgcmVwb3J0cyBvZlxuICAgKiB0aGUgdXNlIG9mIHVuaW5pdGlhbGl6ZWQgKG9yIHVuaW5pdGlhbGlzZWQgYXMgSnVsaWFuIHdyaXRlcykgYnl0ZXMgYnlcbiAgICogdGhlIGxvbmdlc3QgbWF0Y2ggcm91dGluZXMuICBVcGRhdGUgdGhlIGhpZ2ggd2F0ZXIgbWFyayBmb3IgdGhlIG5leHRcbiAgICogdGltZSB0aHJvdWdoIGhlcmUuICBXSU5fSU5JVCBpcyBzZXQgdG8gTUFYX01BVENIIHNpbmNlIHRoZSBsb25nZXN0IG1hdGNoXG4gICAqIHJvdXRpbmVzIGFsbG93IHNjYW5uaW5nIHRvIHN0cnN0YXJ0ICsgTUFYX01BVENILCBpZ25vcmluZyBsb29rYWhlYWQuXG4gICAqL1xuLy8gIGlmIChzLmhpZ2hfd2F0ZXIgPCBzLndpbmRvd19zaXplKSB7XG4vLyAgICB2YXIgY3VyciA9IHMuc3Ryc3RhcnQgKyBzLmxvb2thaGVhZDtcbi8vICAgIHZhciBpbml0ID0gMDtcbi8vXG4vLyAgICBpZiAocy5oaWdoX3dhdGVyIDwgY3Vycikge1xuLy8gICAgICAvKiBQcmV2aW91cyBoaWdoIHdhdGVyIG1hcmsgYmVsb3cgY3VycmVudCBkYXRhIC0tIHplcm8gV0lOX0lOSVRcbi8vICAgICAgICogYnl0ZXMgb3IgdXAgdG8gZW5kIG9mIHdpbmRvdywgd2hpY2hldmVyIGlzIGxlc3MuXG4vLyAgICAgICAqL1xuLy8gICAgICBpbml0ID0gcy53aW5kb3dfc2l6ZSAtIGN1cnI7XG4vLyAgICAgIGlmIChpbml0ID4gV0lOX0lOSVQpXG4vLyAgICAgICAgaW5pdCA9IFdJTl9JTklUO1xuLy8gICAgICB6bWVtemVybyhzLT53aW5kb3cgKyBjdXJyLCAodW5zaWduZWQpaW5pdCk7XG4vLyAgICAgIHMtPmhpZ2hfd2F0ZXIgPSBjdXJyICsgaW5pdDtcbi8vICAgIH1cbi8vICAgIGVsc2UgaWYgKHMtPmhpZ2hfd2F0ZXIgPCAodWxnKWN1cnIgKyBXSU5fSU5JVCkge1xuLy8gICAgICAvKiBIaWdoIHdhdGVyIG1hcmsgYXQgb3IgYWJvdmUgY3VycmVudCBkYXRhLCBidXQgYmVsb3cgY3VycmVudCBkYXRhXG4vLyAgICAgICAqIHBsdXMgV0lOX0lOSVQgLS0gemVybyBvdXQgdG8gY3VycmVudCBkYXRhIHBsdXMgV0lOX0lOSVQsIG9yIHVwXG4vLyAgICAgICAqIHRvIGVuZCBvZiB3aW5kb3csIHdoaWNoZXZlciBpcyBsZXNzLlxuLy8gICAgICAgKi9cbi8vICAgICAgaW5pdCA9ICh1bGcpY3VyciArIFdJTl9JTklUIC0gcy0+aGlnaF93YXRlcjtcbi8vICAgICAgaWYgKGluaXQgPiBzLT53aW5kb3dfc2l6ZSAtIHMtPmhpZ2hfd2F0ZXIpXG4vLyAgICAgICAgaW5pdCA9IHMtPndpbmRvd19zaXplIC0gcy0+aGlnaF93YXRlcjtcbi8vICAgICAgem1lbXplcm8ocy0+d2luZG93ICsgcy0+aGlnaF93YXRlciwgKHVuc2lnbmVkKWluaXQpO1xuLy8gICAgICBzLT5oaWdoX3dhdGVyICs9IGluaXQ7XG4vLyAgICB9XG4vLyAgfVxuLy9cbi8vICBBc3NlcnQoKHVsZylzLT5zdHJzdGFydCA8PSBzLT53aW5kb3dfc2l6ZSAtIE1JTl9MT09LQUhFQUQsXG4vLyAgICBcIm5vdCBlbm91Z2ggcm9vbSBmb3Igc2VhcmNoXCIpO1xufVxuXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIENvcHkgd2l0aG91dCBjb21wcmVzc2lvbiBhcyBtdWNoIGFzIHBvc3NpYmxlIGZyb20gdGhlIGlucHV0IHN0cmVhbSwgcmV0dXJuXG4gKiB0aGUgY3VycmVudCBibG9jayBzdGF0ZS5cbiAqIFRoaXMgZnVuY3Rpb24gZG9lcyBub3QgaW5zZXJ0IG5ldyBzdHJpbmdzIGluIHRoZSBkaWN0aW9uYXJ5IHNpbmNlXG4gKiB1bmNvbXByZXNzaWJsZSBkYXRhIGlzIHByb2JhYmx5IG5vdCB1c2VmdWwuIFRoaXMgZnVuY3Rpb24gaXMgdXNlZFxuICogb25seSBmb3IgdGhlIGxldmVsPTAgY29tcHJlc3Npb24gb3B0aW9uLlxuICogTk9URTogdGhpcyBmdW5jdGlvbiBzaG91bGQgYmUgb3B0aW1pemVkIHRvIGF2b2lkIGV4dHJhIGNvcHlpbmcgZnJvbVxuICogd2luZG93IHRvIHBlbmRpbmdfYnVmLlxuICovXG5mdW5jdGlvbiBkZWZsYXRlX3N0b3JlZChzLCBmbHVzaCkge1xuICAvKiBTdG9yZWQgYmxvY2tzIGFyZSBsaW1pdGVkIHRvIDB4ZmZmZiBieXRlcywgcGVuZGluZ19idWYgaXMgbGltaXRlZFxuICAgKiB0byBwZW5kaW5nX2J1Zl9zaXplLCBhbmQgZWFjaCBzdG9yZWQgYmxvY2sgaGFzIGEgNSBieXRlIGhlYWRlcjpcbiAgICovXG4gIHZhciBtYXhfYmxvY2tfc2l6ZSA9IDB4ZmZmZjtcblxuICBpZiAobWF4X2Jsb2NrX3NpemUgPiBzLnBlbmRpbmdfYnVmX3NpemUgLSA1KSB7XG4gICAgbWF4X2Jsb2NrX3NpemUgPSBzLnBlbmRpbmdfYnVmX3NpemUgLSA1O1xuICB9XG5cbiAgLyogQ29weSBhcyBtdWNoIGFzIHBvc3NpYmxlIGZyb20gaW5wdXQgdG8gb3V0cHV0OiAqL1xuICBmb3IgKDs7KSB7XG4gICAgLyogRmlsbCB0aGUgd2luZG93IGFzIG11Y2ggYXMgcG9zc2libGU6ICovXG4gICAgaWYgKHMubG9va2FoZWFkIDw9IDEpIHtcblxuICAgICAgLy9Bc3NlcnQocy0+c3Ryc3RhcnQgPCBzLT53X3NpemUrTUFYX0RJU1QocykgfHxcbiAgICAgIC8vICBzLT5ibG9ja19zdGFydCA+PSAobG9uZylzLT53X3NpemUsIFwic2xpZGUgdG9vIGxhdGVcIik7XG4vLyAgICAgIGlmICghKHMuc3Ryc3RhcnQgPCBzLndfc2l6ZSArIChzLndfc2l6ZSAtIE1JTl9MT09LQUhFQUQpIHx8XG4vLyAgICAgICAgcy5ibG9ja19zdGFydCA+PSBzLndfc2l6ZSkpIHtcbi8vICAgICAgICB0aHJvdyAgbmV3IEVycm9yKFwic2xpZGUgdG9vIGxhdGVcIik7XG4vLyAgICAgIH1cblxuICAgICAgZmlsbF93aW5kb3cocyk7XG4gICAgICBpZiAocy5sb29rYWhlYWQgPT09IDAgJiYgZmx1c2ggPT09IFpfTk9fRkxVU0gpIHtcbiAgICAgICAgcmV0dXJuIEJTX05FRURfTU9SRTtcbiAgICAgIH1cblxuICAgICAgaWYgKHMubG9va2FoZWFkID09PSAwKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgLyogZmx1c2ggdGhlIGN1cnJlbnQgYmxvY2sgKi9cbiAgICB9XG4gICAgLy9Bc3NlcnQocy0+YmxvY2tfc3RhcnQgPj0gMEwsIFwiYmxvY2sgZ29uZVwiKTtcbi8vICAgIGlmIChzLmJsb2NrX3N0YXJ0IDwgMCkgdGhyb3cgbmV3IEVycm9yKFwiYmxvY2sgZ29uZVwiKTtcblxuICAgIHMuc3Ryc3RhcnQgKz0gcy5sb29rYWhlYWQ7XG4gICAgcy5sb29rYWhlYWQgPSAwO1xuXG4gICAgLyogRW1pdCBhIHN0b3JlZCBibG9jayBpZiBwZW5kaW5nX2J1ZiB3aWxsIGJlIGZ1bGw6ICovXG4gICAgdmFyIG1heF9zdGFydCA9IHMuYmxvY2tfc3RhcnQgKyBtYXhfYmxvY2tfc2l6ZTtcblxuICAgIGlmIChzLnN0cnN0YXJ0ID09PSAwIHx8IHMuc3Ryc3RhcnQgPj0gbWF4X3N0YXJ0KSB7XG4gICAgICAvKiBzdHJzdGFydCA9PSAwIGlzIHBvc3NpYmxlIHdoZW4gd3JhcGFyb3VuZCBvbiAxNi1iaXQgbWFjaGluZSAqL1xuICAgICAgcy5sb29rYWhlYWQgPSBzLnN0cnN0YXJ0IC0gbWF4X3N0YXJ0O1xuICAgICAgcy5zdHJzdGFydCA9IG1heF9zdGFydDtcbiAgICAgIC8qKiogRkxVU0hfQkxPQ0socywgMCk7ICoqKi9cbiAgICAgIGZsdXNoX2Jsb2NrX29ubHkocywgZmFsc2UpO1xuICAgICAgaWYgKHMuc3RybS5hdmFpbF9vdXQgPT09IDApIHtcbiAgICAgICAgcmV0dXJuIEJTX05FRURfTU9SRTtcbiAgICAgIH1cbiAgICAgIC8qKiovXG5cblxuICAgIH1cbiAgICAvKiBGbHVzaCBpZiB3ZSBtYXkgaGF2ZSB0byBzbGlkZSwgb3RoZXJ3aXNlIGJsb2NrX3N0YXJ0IG1heSBiZWNvbWVcbiAgICAgKiBuZWdhdGl2ZSBhbmQgdGhlIGRhdGEgd2lsbCBiZSBnb25lOlxuICAgICAqL1xuICAgIGlmIChzLnN0cnN0YXJ0IC0gcy5ibG9ja19zdGFydCA+PSAocy53X3NpemUgLSBNSU5fTE9PS0FIRUFEKSkge1xuICAgICAgLyoqKiBGTFVTSF9CTE9DSyhzLCAwKTsgKioqL1xuICAgICAgZmx1c2hfYmxvY2tfb25seShzLCBmYWxzZSk7XG4gICAgICBpZiAocy5zdHJtLmF2YWlsX291dCA9PT0gMCkge1xuICAgICAgICByZXR1cm4gQlNfTkVFRF9NT1JFO1xuICAgICAgfVxuICAgICAgLyoqKi9cbiAgICB9XG4gIH1cblxuICBzLmluc2VydCA9IDA7XG5cbiAgaWYgKGZsdXNoID09PSBaX0ZJTklTSCkge1xuICAgIC8qKiogRkxVU0hfQkxPQ0socywgMSk7ICoqKi9cbiAgICBmbHVzaF9ibG9ja19vbmx5KHMsIHRydWUpO1xuICAgIGlmIChzLnN0cm0uYXZhaWxfb3V0ID09PSAwKSB7XG4gICAgICByZXR1cm4gQlNfRklOSVNIX1NUQVJURUQ7XG4gICAgfVxuICAgIC8qKiovXG4gICAgcmV0dXJuIEJTX0ZJTklTSF9ET05FO1xuICB9XG5cbiAgaWYgKHMuc3Ryc3RhcnQgPiBzLmJsb2NrX3N0YXJ0KSB7XG4gICAgLyoqKiBGTFVTSF9CTE9DSyhzLCAwKTsgKioqL1xuICAgIGZsdXNoX2Jsb2NrX29ubHkocywgZmFsc2UpO1xuICAgIGlmIChzLnN0cm0uYXZhaWxfb3V0ID09PSAwKSB7XG4gICAgICByZXR1cm4gQlNfTkVFRF9NT1JFO1xuICAgIH1cbiAgICAvKioqL1xuICB9XG5cbiAgcmV0dXJuIEJTX05FRURfTU9SRTtcbn1cblxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBDb21wcmVzcyBhcyBtdWNoIGFzIHBvc3NpYmxlIGZyb20gdGhlIGlucHV0IHN0cmVhbSwgcmV0dXJuIHRoZSBjdXJyZW50XG4gKiBibG9jayBzdGF0ZS5cbiAqIFRoaXMgZnVuY3Rpb24gZG9lcyBub3QgcGVyZm9ybSBsYXp5IGV2YWx1YXRpb24gb2YgbWF0Y2hlcyBhbmQgaW5zZXJ0c1xuICogbmV3IHN0cmluZ3MgaW4gdGhlIGRpY3Rpb25hcnkgb25seSBmb3IgdW5tYXRjaGVkIHN0cmluZ3Mgb3IgZm9yIHNob3J0XG4gKiBtYXRjaGVzLiBJdCBpcyB1c2VkIG9ubHkgZm9yIHRoZSBmYXN0IGNvbXByZXNzaW9uIG9wdGlvbnMuXG4gKi9cbmZ1bmN0aW9uIGRlZmxhdGVfZmFzdChzLCBmbHVzaCkge1xuICB2YXIgaGFzaF9oZWFkOyAgICAgICAgLyogaGVhZCBvZiB0aGUgaGFzaCBjaGFpbiAqL1xuICB2YXIgYmZsdXNoOyAgICAgICAgICAgLyogc2V0IGlmIGN1cnJlbnQgYmxvY2sgbXVzdCBiZSBmbHVzaGVkICovXG5cbiAgZm9yICg7Oykge1xuICAgIC8qIE1ha2Ugc3VyZSB0aGF0IHdlIGFsd2F5cyBoYXZlIGVub3VnaCBsb29rYWhlYWQsIGV4Y2VwdFxuICAgICAqIGF0IHRoZSBlbmQgb2YgdGhlIGlucHV0IGZpbGUuIFdlIG5lZWQgTUFYX01BVENIIGJ5dGVzXG4gICAgICogZm9yIHRoZSBuZXh0IG1hdGNoLCBwbHVzIE1JTl9NQVRDSCBieXRlcyB0byBpbnNlcnQgdGhlXG4gICAgICogc3RyaW5nIGZvbGxvd2luZyB0aGUgbmV4dCBtYXRjaC5cbiAgICAgKi9cbiAgICBpZiAocy5sb29rYWhlYWQgPCBNSU5fTE9PS0FIRUFEKSB7XG4gICAgICBmaWxsX3dpbmRvdyhzKTtcbiAgICAgIGlmIChzLmxvb2thaGVhZCA8IE1JTl9MT09LQUhFQUQgJiYgZmx1c2ggPT09IFpfTk9fRkxVU0gpIHtcbiAgICAgICAgcmV0dXJuIEJTX05FRURfTU9SRTtcbiAgICAgIH1cbiAgICAgIGlmIChzLmxvb2thaGVhZCA9PT0gMCkge1xuICAgICAgICBicmVhazsgLyogZmx1c2ggdGhlIGN1cnJlbnQgYmxvY2sgKi9cbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKiBJbnNlcnQgdGhlIHN0cmluZyB3aW5kb3dbc3Ryc3RhcnQgLi4gc3Ryc3RhcnQrMl0gaW4gdGhlXG4gICAgICogZGljdGlvbmFyeSwgYW5kIHNldCBoYXNoX2hlYWQgdG8gdGhlIGhlYWQgb2YgdGhlIGhhc2ggY2hhaW46XG4gICAgICovXG4gICAgaGFzaF9oZWFkID0gMC8qTklMKi87XG4gICAgaWYgKHMubG9va2FoZWFkID49IE1JTl9NQVRDSCkge1xuICAgICAgLyoqKiBJTlNFUlRfU1RSSU5HKHMsIHMuc3Ryc3RhcnQsIGhhc2hfaGVhZCk7ICoqKi9cbiAgICAgIHMuaW5zX2ggPSAoKHMuaW5zX2ggPDwgcy5oYXNoX3NoaWZ0KSBeIHMud2luZG93W3Muc3Ryc3RhcnQgKyBNSU5fTUFUQ0ggLSAxXSkgJiBzLmhhc2hfbWFzaztcbiAgICAgIGhhc2hfaGVhZCA9IHMucHJldltzLnN0cnN0YXJ0ICYgcy53X21hc2tdID0gcy5oZWFkW3MuaW5zX2hdO1xuICAgICAgcy5oZWFkW3MuaW5zX2hdID0gcy5zdHJzdGFydDtcbiAgICAgIC8qKiovXG4gICAgfVxuXG4gICAgLyogRmluZCB0aGUgbG9uZ2VzdCBtYXRjaCwgZGlzY2FyZGluZyB0aG9zZSA8PSBwcmV2X2xlbmd0aC5cbiAgICAgKiBBdCB0aGlzIHBvaW50IHdlIGhhdmUgYWx3YXlzIG1hdGNoX2xlbmd0aCA8IE1JTl9NQVRDSFxuICAgICAqL1xuICAgIGlmIChoYXNoX2hlYWQgIT09IDAvKk5JTCovICYmICgocy5zdHJzdGFydCAtIGhhc2hfaGVhZCkgPD0gKHMud19zaXplIC0gTUlOX0xPT0tBSEVBRCkpKSB7XG4gICAgICAvKiBUbyBzaW1wbGlmeSB0aGUgY29kZSwgd2UgcHJldmVudCBtYXRjaGVzIHdpdGggdGhlIHN0cmluZ1xuICAgICAgICogb2Ygd2luZG93IGluZGV4IDAgKGluIHBhcnRpY3VsYXIgd2UgaGF2ZSB0byBhdm9pZCBhIG1hdGNoXG4gICAgICAgKiBvZiB0aGUgc3RyaW5nIHdpdGggaXRzZWxmIGF0IHRoZSBzdGFydCBvZiB0aGUgaW5wdXQgZmlsZSkuXG4gICAgICAgKi9cbiAgICAgIHMubWF0Y2hfbGVuZ3RoID0gbG9uZ2VzdF9tYXRjaChzLCBoYXNoX2hlYWQpO1xuICAgICAgLyogbG9uZ2VzdF9tYXRjaCgpIHNldHMgbWF0Y2hfc3RhcnQgKi9cbiAgICB9XG4gICAgaWYgKHMubWF0Y2hfbGVuZ3RoID49IE1JTl9NQVRDSCkge1xuICAgICAgLy8gY2hlY2tfbWF0Y2gocywgcy5zdHJzdGFydCwgcy5tYXRjaF9zdGFydCwgcy5tYXRjaF9sZW5ndGgpOyAvLyBmb3IgZGVidWcgb25seVxuXG4gICAgICAvKioqIF90cl90YWxseV9kaXN0KHMsIHMuc3Ryc3RhcnQgLSBzLm1hdGNoX3N0YXJ0LFxuICAgICAgICAgICAgICAgICAgICAgcy5tYXRjaF9sZW5ndGggLSBNSU5fTUFUQ0gsIGJmbHVzaCk7ICoqKi9cbiAgICAgIGJmbHVzaCA9IHRyZWVzLl90cl90YWxseShzLCBzLnN0cnN0YXJ0IC0gcy5tYXRjaF9zdGFydCwgcy5tYXRjaF9sZW5ndGggLSBNSU5fTUFUQ0gpO1xuXG4gICAgICBzLmxvb2thaGVhZCAtPSBzLm1hdGNoX2xlbmd0aDtcblxuICAgICAgLyogSW5zZXJ0IG5ldyBzdHJpbmdzIGluIHRoZSBoYXNoIHRhYmxlIG9ubHkgaWYgdGhlIG1hdGNoIGxlbmd0aFxuICAgICAgICogaXMgbm90IHRvbyBsYXJnZS4gVGhpcyBzYXZlcyB0aW1lIGJ1dCBkZWdyYWRlcyBjb21wcmVzc2lvbi5cbiAgICAgICAqL1xuICAgICAgaWYgKHMubWF0Y2hfbGVuZ3RoIDw9IHMubWF4X2xhenlfbWF0Y2gvKm1heF9pbnNlcnRfbGVuZ3RoKi8gJiYgcy5sb29rYWhlYWQgPj0gTUlOX01BVENIKSB7XG4gICAgICAgIHMubWF0Y2hfbGVuZ3RoLS07IC8qIHN0cmluZyBhdCBzdHJzdGFydCBhbHJlYWR5IGluIHRhYmxlICovXG4gICAgICAgIGRvIHtcbiAgICAgICAgICBzLnN0cnN0YXJ0Kys7XG4gICAgICAgICAgLyoqKiBJTlNFUlRfU1RSSU5HKHMsIHMuc3Ryc3RhcnQsIGhhc2hfaGVhZCk7ICoqKi9cbiAgICAgICAgICBzLmluc19oID0gKChzLmluc19oIDw8IHMuaGFzaF9zaGlmdCkgXiBzLndpbmRvd1tzLnN0cnN0YXJ0ICsgTUlOX01BVENIIC0gMV0pICYgcy5oYXNoX21hc2s7XG4gICAgICAgICAgaGFzaF9oZWFkID0gcy5wcmV2W3Muc3Ryc3RhcnQgJiBzLndfbWFza10gPSBzLmhlYWRbcy5pbnNfaF07XG4gICAgICAgICAgcy5oZWFkW3MuaW5zX2hdID0gcy5zdHJzdGFydDtcbiAgICAgICAgICAvKioqL1xuICAgICAgICAgIC8qIHN0cnN0YXJ0IG5ldmVyIGV4Y2VlZHMgV1NJWkUtTUFYX01BVENILCBzbyB0aGVyZSBhcmVcbiAgICAgICAgICAgKiBhbHdheXMgTUlOX01BVENIIGJ5dGVzIGFoZWFkLlxuICAgICAgICAgICAqL1xuICAgICAgICB9IHdoaWxlICgtLXMubWF0Y2hfbGVuZ3RoICE9PSAwKTtcbiAgICAgICAgcy5zdHJzdGFydCsrO1xuICAgICAgfSBlbHNlXG4gICAgICB7XG4gICAgICAgIHMuc3Ryc3RhcnQgKz0gcy5tYXRjaF9sZW5ndGg7XG4gICAgICAgIHMubWF0Y2hfbGVuZ3RoID0gMDtcbiAgICAgICAgcy5pbnNfaCA9IHMud2luZG93W3Muc3Ryc3RhcnRdO1xuICAgICAgICAvKiBVUERBVEVfSEFTSChzLCBzLmluc19oLCBzLndpbmRvd1tzLnN0cnN0YXJ0KzFdKTsgKi9cbiAgICAgICAgcy5pbnNfaCA9ICgocy5pbnNfaCA8PCBzLmhhc2hfc2hpZnQpIF4gcy53aW5kb3dbcy5zdHJzdGFydCArIDFdKSAmIHMuaGFzaF9tYXNrO1xuXG4vLyNpZiBNSU5fTUFUQ0ggIT0gM1xuLy8gICAgICAgICAgICAgICAgQ2FsbCBVUERBVEVfSEFTSCgpIE1JTl9NQVRDSC0zIG1vcmUgdGltZXNcbi8vI2VuZGlmXG4gICAgICAgIC8qIElmIGxvb2thaGVhZCA8IE1JTl9NQVRDSCwgaW5zX2ggaXMgZ2FyYmFnZSwgYnV0IGl0IGRvZXMgbm90XG4gICAgICAgICAqIG1hdHRlciBzaW5jZSBpdCB3aWxsIGJlIHJlY29tcHV0ZWQgYXQgbmV4dCBkZWZsYXRlIGNhbGwuXG4gICAgICAgICAqL1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAvKiBObyBtYXRjaCwgb3V0cHV0IGEgbGl0ZXJhbCBieXRlICovXG4gICAgICAvL1RyYWNldnYoKHN0ZGVycixcIiVjXCIsIHMud2luZG93W3Muc3Ryc3RhcnRdKSk7XG4gICAgICAvKioqIF90cl90YWxseV9saXQocywgcy53aW5kb3dbcy5zdHJzdGFydF0sIGJmbHVzaCk7ICoqKi9cbiAgICAgIGJmbHVzaCA9IHRyZWVzLl90cl90YWxseShzLCAwLCBzLndpbmRvd1tzLnN0cnN0YXJ0XSk7XG5cbiAgICAgIHMubG9va2FoZWFkLS07XG4gICAgICBzLnN0cnN0YXJ0Kys7XG4gICAgfVxuICAgIGlmIChiZmx1c2gpIHtcbiAgICAgIC8qKiogRkxVU0hfQkxPQ0socywgMCk7ICoqKi9cbiAgICAgIGZsdXNoX2Jsb2NrX29ubHkocywgZmFsc2UpO1xuICAgICAgaWYgKHMuc3RybS5hdmFpbF9vdXQgPT09IDApIHtcbiAgICAgICAgcmV0dXJuIEJTX05FRURfTU9SRTtcbiAgICAgIH1cbiAgICAgIC8qKiovXG4gICAgfVxuICB9XG4gIHMuaW5zZXJ0ID0gKChzLnN0cnN0YXJ0IDwgKE1JTl9NQVRDSC0xKSkgPyBzLnN0cnN0YXJ0IDogTUlOX01BVENILTEpO1xuICBpZiAoZmx1c2ggPT09IFpfRklOSVNIKSB7XG4gICAgLyoqKiBGTFVTSF9CTE9DSyhzLCAxKTsgKioqL1xuICAgIGZsdXNoX2Jsb2NrX29ubHkocywgdHJ1ZSk7XG4gICAgaWYgKHMuc3RybS5hdmFpbF9vdXQgPT09IDApIHtcbiAgICAgIHJldHVybiBCU19GSU5JU0hfU1RBUlRFRDtcbiAgICB9XG4gICAgLyoqKi9cbiAgICByZXR1cm4gQlNfRklOSVNIX0RPTkU7XG4gIH1cbiAgaWYgKHMubGFzdF9saXQpIHtcbiAgICAvKioqIEZMVVNIX0JMT0NLKHMsIDApOyAqKiovXG4gICAgZmx1c2hfYmxvY2tfb25seShzLCBmYWxzZSk7XG4gICAgaWYgKHMuc3RybS5hdmFpbF9vdXQgPT09IDApIHtcbiAgICAgIHJldHVybiBCU19ORUVEX01PUkU7XG4gICAgfVxuICAgIC8qKiovXG4gIH1cbiAgcmV0dXJuIEJTX0JMT0NLX0RPTkU7XG59XG5cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogU2FtZSBhcyBhYm92ZSwgYnV0IGFjaGlldmVzIGJldHRlciBjb21wcmVzc2lvbi4gV2UgdXNlIGEgbGF6eVxuICogZXZhbHVhdGlvbiBmb3IgbWF0Y2hlczogYSBtYXRjaCBpcyBmaW5hbGx5IGFkb3B0ZWQgb25seSBpZiB0aGVyZSBpc1xuICogbm8gYmV0dGVyIG1hdGNoIGF0IHRoZSBuZXh0IHdpbmRvdyBwb3NpdGlvbi5cbiAqL1xuZnVuY3Rpb24gZGVmbGF0ZV9zbG93KHMsIGZsdXNoKSB7XG4gIHZhciBoYXNoX2hlYWQ7ICAgICAgICAgIC8qIGhlYWQgb2YgaGFzaCBjaGFpbiAqL1xuICB2YXIgYmZsdXNoOyAgICAgICAgICAgICAgLyogc2V0IGlmIGN1cnJlbnQgYmxvY2sgbXVzdCBiZSBmbHVzaGVkICovXG5cbiAgdmFyIG1heF9pbnNlcnQ7XG5cbiAgLyogUHJvY2VzcyB0aGUgaW5wdXQgYmxvY2suICovXG4gIGZvciAoOzspIHtcbiAgICAvKiBNYWtlIHN1cmUgdGhhdCB3ZSBhbHdheXMgaGF2ZSBlbm91Z2ggbG9va2FoZWFkLCBleGNlcHRcbiAgICAgKiBhdCB0aGUgZW5kIG9mIHRoZSBpbnB1dCBmaWxlLiBXZSBuZWVkIE1BWF9NQVRDSCBieXRlc1xuICAgICAqIGZvciB0aGUgbmV4dCBtYXRjaCwgcGx1cyBNSU5fTUFUQ0ggYnl0ZXMgdG8gaW5zZXJ0IHRoZVxuICAgICAqIHN0cmluZyBmb2xsb3dpbmcgdGhlIG5leHQgbWF0Y2guXG4gICAgICovXG4gICAgaWYgKHMubG9va2FoZWFkIDwgTUlOX0xPT0tBSEVBRCkge1xuICAgICAgZmlsbF93aW5kb3cocyk7XG4gICAgICBpZiAocy5sb29rYWhlYWQgPCBNSU5fTE9PS0FIRUFEICYmIGZsdXNoID09PSBaX05PX0ZMVVNIKSB7XG4gICAgICAgIHJldHVybiBCU19ORUVEX01PUkU7XG4gICAgICB9XG4gICAgICBpZiAocy5sb29rYWhlYWQgPT09IDApIHsgYnJlYWs7IH0gLyogZmx1c2ggdGhlIGN1cnJlbnQgYmxvY2sgKi9cbiAgICB9XG5cbiAgICAvKiBJbnNlcnQgdGhlIHN0cmluZyB3aW5kb3dbc3Ryc3RhcnQgLi4gc3Ryc3RhcnQrMl0gaW4gdGhlXG4gICAgICogZGljdGlvbmFyeSwgYW5kIHNldCBoYXNoX2hlYWQgdG8gdGhlIGhlYWQgb2YgdGhlIGhhc2ggY2hhaW46XG4gICAgICovXG4gICAgaGFzaF9oZWFkID0gMC8qTklMKi87XG4gICAgaWYgKHMubG9va2FoZWFkID49IE1JTl9NQVRDSCkge1xuICAgICAgLyoqKiBJTlNFUlRfU1RSSU5HKHMsIHMuc3Ryc3RhcnQsIGhhc2hfaGVhZCk7ICoqKi9cbiAgICAgIHMuaW5zX2ggPSAoKHMuaW5zX2ggPDwgcy5oYXNoX3NoaWZ0KSBeIHMud2luZG93W3Muc3Ryc3RhcnQgKyBNSU5fTUFUQ0ggLSAxXSkgJiBzLmhhc2hfbWFzaztcbiAgICAgIGhhc2hfaGVhZCA9IHMucHJldltzLnN0cnN0YXJ0ICYgcy53X21hc2tdID0gcy5oZWFkW3MuaW5zX2hdO1xuICAgICAgcy5oZWFkW3MuaW5zX2hdID0gcy5zdHJzdGFydDtcbiAgICAgIC8qKiovXG4gICAgfVxuXG4gICAgLyogRmluZCB0aGUgbG9uZ2VzdCBtYXRjaCwgZGlzY2FyZGluZyB0aG9zZSA8PSBwcmV2X2xlbmd0aC5cbiAgICAgKi9cbiAgICBzLnByZXZfbGVuZ3RoID0gcy5tYXRjaF9sZW5ndGg7XG4gICAgcy5wcmV2X21hdGNoID0gcy5tYXRjaF9zdGFydDtcbiAgICBzLm1hdGNoX2xlbmd0aCA9IE1JTl9NQVRDSC0xO1xuXG4gICAgaWYgKGhhc2hfaGVhZCAhPT0gMC8qTklMKi8gJiYgcy5wcmV2X2xlbmd0aCA8IHMubWF4X2xhenlfbWF0Y2ggJiZcbiAgICAgICAgcy5zdHJzdGFydCAtIGhhc2hfaGVhZCA8PSAocy53X3NpemUtTUlOX0xPT0tBSEVBRCkvKk1BWF9ESVNUKHMpKi8pIHtcbiAgICAgIC8qIFRvIHNpbXBsaWZ5IHRoZSBjb2RlLCB3ZSBwcmV2ZW50IG1hdGNoZXMgd2l0aCB0aGUgc3RyaW5nXG4gICAgICAgKiBvZiB3aW5kb3cgaW5kZXggMCAoaW4gcGFydGljdWxhciB3ZSBoYXZlIHRvIGF2b2lkIGEgbWF0Y2hcbiAgICAgICAqIG9mIHRoZSBzdHJpbmcgd2l0aCBpdHNlbGYgYXQgdGhlIHN0YXJ0IG9mIHRoZSBpbnB1dCBmaWxlKS5cbiAgICAgICAqL1xuICAgICAgcy5tYXRjaF9sZW5ndGggPSBsb25nZXN0X21hdGNoKHMsIGhhc2hfaGVhZCk7XG4gICAgICAvKiBsb25nZXN0X21hdGNoKCkgc2V0cyBtYXRjaF9zdGFydCAqL1xuXG4gICAgICBpZiAocy5tYXRjaF9sZW5ndGggPD0gNSAmJlxuICAgICAgICAgKHMuc3RyYXRlZ3kgPT09IFpfRklMVEVSRUQgfHwgKHMubWF0Y2hfbGVuZ3RoID09PSBNSU5fTUFUQ0ggJiYgcy5zdHJzdGFydCAtIHMubWF0Y2hfc3RhcnQgPiA0MDk2LypUT09fRkFSKi8pKSkge1xuXG4gICAgICAgIC8qIElmIHByZXZfbWF0Y2ggaXMgYWxzbyBNSU5fTUFUQ0gsIG1hdGNoX3N0YXJ0IGlzIGdhcmJhZ2VcbiAgICAgICAgICogYnV0IHdlIHdpbGwgaWdub3JlIHRoZSBjdXJyZW50IG1hdGNoIGFueXdheS5cbiAgICAgICAgICovXG4gICAgICAgIHMubWF0Y2hfbGVuZ3RoID0gTUlOX01BVENILTE7XG4gICAgICB9XG4gICAgfVxuICAgIC8qIElmIHRoZXJlIHdhcyBhIG1hdGNoIGF0IHRoZSBwcmV2aW91cyBzdGVwIGFuZCB0aGUgY3VycmVudFxuICAgICAqIG1hdGNoIGlzIG5vdCBiZXR0ZXIsIG91dHB1dCB0aGUgcHJldmlvdXMgbWF0Y2g6XG4gICAgICovXG4gICAgaWYgKHMucHJldl9sZW5ndGggPj0gTUlOX01BVENIICYmIHMubWF0Y2hfbGVuZ3RoIDw9IHMucHJldl9sZW5ndGgpIHtcbiAgICAgIG1heF9pbnNlcnQgPSBzLnN0cnN0YXJ0ICsgcy5sb29rYWhlYWQgLSBNSU5fTUFUQ0g7XG4gICAgICAvKiBEbyBub3QgaW5zZXJ0IHN0cmluZ3MgaW4gaGFzaCB0YWJsZSBiZXlvbmQgdGhpcy4gKi9cblxuICAgICAgLy9jaGVja19tYXRjaChzLCBzLnN0cnN0YXJ0LTEsIHMucHJldl9tYXRjaCwgcy5wcmV2X2xlbmd0aCk7XG5cbiAgICAgIC8qKipfdHJfdGFsbHlfZGlzdChzLCBzLnN0cnN0YXJ0IC0gMSAtIHMucHJldl9tYXRjaCxcbiAgICAgICAgICAgICAgICAgICAgIHMucHJldl9sZW5ndGggLSBNSU5fTUFUQ0gsIGJmbHVzaCk7KioqL1xuICAgICAgYmZsdXNoID0gdHJlZXMuX3RyX3RhbGx5KHMsIHMuc3Ryc3RhcnQgLSAxLSBzLnByZXZfbWF0Y2gsIHMucHJldl9sZW5ndGggLSBNSU5fTUFUQ0gpO1xuICAgICAgLyogSW5zZXJ0IGluIGhhc2ggdGFibGUgYWxsIHN0cmluZ3MgdXAgdG8gdGhlIGVuZCBvZiB0aGUgbWF0Y2guXG4gICAgICAgKiBzdHJzdGFydC0xIGFuZCBzdHJzdGFydCBhcmUgYWxyZWFkeSBpbnNlcnRlZC4gSWYgdGhlcmUgaXMgbm90XG4gICAgICAgKiBlbm91Z2ggbG9va2FoZWFkLCB0aGUgbGFzdCB0d28gc3RyaW5ncyBhcmUgbm90IGluc2VydGVkIGluXG4gICAgICAgKiB0aGUgaGFzaCB0YWJsZS5cbiAgICAgICAqL1xuICAgICAgcy5sb29rYWhlYWQgLT0gcy5wcmV2X2xlbmd0aC0xO1xuICAgICAgcy5wcmV2X2xlbmd0aCAtPSAyO1xuICAgICAgZG8ge1xuICAgICAgICBpZiAoKytzLnN0cnN0YXJ0IDw9IG1heF9pbnNlcnQpIHtcbiAgICAgICAgICAvKioqIElOU0VSVF9TVFJJTkcocywgcy5zdHJzdGFydCwgaGFzaF9oZWFkKTsgKioqL1xuICAgICAgICAgIHMuaW5zX2ggPSAoKHMuaW5zX2ggPDwgcy5oYXNoX3NoaWZ0KSBeIHMud2luZG93W3Muc3Ryc3RhcnQgKyBNSU5fTUFUQ0ggLSAxXSkgJiBzLmhhc2hfbWFzaztcbiAgICAgICAgICBoYXNoX2hlYWQgPSBzLnByZXZbcy5zdHJzdGFydCAmIHMud19tYXNrXSA9IHMuaGVhZFtzLmluc19oXTtcbiAgICAgICAgICBzLmhlYWRbcy5pbnNfaF0gPSBzLnN0cnN0YXJ0O1xuICAgICAgICAgIC8qKiovXG4gICAgICAgIH1cbiAgICAgIH0gd2hpbGUgKC0tcy5wcmV2X2xlbmd0aCAhPT0gMCk7XG4gICAgICBzLm1hdGNoX2F2YWlsYWJsZSA9IDA7XG4gICAgICBzLm1hdGNoX2xlbmd0aCA9IE1JTl9NQVRDSC0xO1xuICAgICAgcy5zdHJzdGFydCsrO1xuXG4gICAgICBpZiAoYmZsdXNoKSB7XG4gICAgICAgIC8qKiogRkxVU0hfQkxPQ0socywgMCk7ICoqKi9cbiAgICAgICAgZmx1c2hfYmxvY2tfb25seShzLCBmYWxzZSk7XG4gICAgICAgIGlmIChzLnN0cm0uYXZhaWxfb3V0ID09PSAwKSB7XG4gICAgICAgICAgcmV0dXJuIEJTX05FRURfTU9SRTtcbiAgICAgICAgfVxuICAgICAgICAvKioqL1xuICAgICAgfVxuXG4gICAgfSBlbHNlIGlmIChzLm1hdGNoX2F2YWlsYWJsZSkge1xuICAgICAgLyogSWYgdGhlcmUgd2FzIG5vIG1hdGNoIGF0IHRoZSBwcmV2aW91cyBwb3NpdGlvbiwgb3V0cHV0IGFcbiAgICAgICAqIHNpbmdsZSBsaXRlcmFsLiBJZiB0aGVyZSB3YXMgYSBtYXRjaCBidXQgdGhlIGN1cnJlbnQgbWF0Y2hcbiAgICAgICAqIGlzIGxvbmdlciwgdHJ1bmNhdGUgdGhlIHByZXZpb3VzIG1hdGNoIHRvIGEgc2luZ2xlIGxpdGVyYWwuXG4gICAgICAgKi9cbiAgICAgIC8vVHJhY2V2digoc3RkZXJyLFwiJWNcIiwgcy0+d2luZG93W3MtPnN0cnN0YXJ0LTFdKSk7XG4gICAgICAvKioqIF90cl90YWxseV9saXQocywgcy53aW5kb3dbcy5zdHJzdGFydC0xXSwgYmZsdXNoKTsgKioqL1xuICAgICAgYmZsdXNoID0gdHJlZXMuX3RyX3RhbGx5KHMsIDAsIHMud2luZG93W3Muc3Ryc3RhcnQtMV0pO1xuXG4gICAgICBpZiAoYmZsdXNoKSB7XG4gICAgICAgIC8qKiogRkxVU0hfQkxPQ0tfT05MWShzLCAwKSAqKiovXG4gICAgICAgIGZsdXNoX2Jsb2NrX29ubHkocywgZmFsc2UpO1xuICAgICAgICAvKioqL1xuICAgICAgfVxuICAgICAgcy5zdHJzdGFydCsrO1xuICAgICAgcy5sb29rYWhlYWQtLTtcbiAgICAgIGlmIChzLnN0cm0uYXZhaWxfb3V0ID09PSAwKSB7XG4gICAgICAgIHJldHVybiBCU19ORUVEX01PUkU7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8qIFRoZXJlIGlzIG5vIHByZXZpb3VzIG1hdGNoIHRvIGNvbXBhcmUgd2l0aCwgd2FpdCBmb3JcbiAgICAgICAqIHRoZSBuZXh0IHN0ZXAgdG8gZGVjaWRlLlxuICAgICAgICovXG4gICAgICBzLm1hdGNoX2F2YWlsYWJsZSA9IDE7XG4gICAgICBzLnN0cnN0YXJ0Kys7XG4gICAgICBzLmxvb2thaGVhZC0tO1xuICAgIH1cbiAgfVxuICAvL0Fzc2VydCAoZmx1c2ggIT0gWl9OT19GTFVTSCwgXCJubyBmbHVzaD9cIik7XG4gIGlmIChzLm1hdGNoX2F2YWlsYWJsZSkge1xuICAgIC8vVHJhY2V2digoc3RkZXJyLFwiJWNcIiwgcy0+d2luZG93W3MtPnN0cnN0YXJ0LTFdKSk7XG4gICAgLyoqKiBfdHJfdGFsbHlfbGl0KHMsIHMud2luZG93W3Muc3Ryc3RhcnQtMV0sIGJmbHVzaCk7ICoqKi9cbiAgICBiZmx1c2ggPSB0cmVlcy5fdHJfdGFsbHkocywgMCwgcy53aW5kb3dbcy5zdHJzdGFydC0xXSk7XG5cbiAgICBzLm1hdGNoX2F2YWlsYWJsZSA9IDA7XG4gIH1cbiAgcy5pbnNlcnQgPSBzLnN0cnN0YXJ0IDwgTUlOX01BVENILTEgPyBzLnN0cnN0YXJ0IDogTUlOX01BVENILTE7XG4gIGlmIChmbHVzaCA9PT0gWl9GSU5JU0gpIHtcbiAgICAvKioqIEZMVVNIX0JMT0NLKHMsIDEpOyAqKiovXG4gICAgZmx1c2hfYmxvY2tfb25seShzLCB0cnVlKTtcbiAgICBpZiAocy5zdHJtLmF2YWlsX291dCA9PT0gMCkge1xuICAgICAgcmV0dXJuIEJTX0ZJTklTSF9TVEFSVEVEO1xuICAgIH1cbiAgICAvKioqL1xuICAgIHJldHVybiBCU19GSU5JU0hfRE9ORTtcbiAgfVxuICBpZiAocy5sYXN0X2xpdCkge1xuICAgIC8qKiogRkxVU0hfQkxPQ0socywgMCk7ICoqKi9cbiAgICBmbHVzaF9ibG9ja19vbmx5KHMsIGZhbHNlKTtcbiAgICBpZiAocy5zdHJtLmF2YWlsX291dCA9PT0gMCkge1xuICAgICAgcmV0dXJuIEJTX05FRURfTU9SRTtcbiAgICB9XG4gICAgLyoqKi9cbiAgfVxuXG4gIHJldHVybiBCU19CTE9DS19ET05FO1xufVxuXG5cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogRm9yIFpfUkxFLCBzaW1wbHkgbG9vayBmb3IgcnVucyBvZiBieXRlcywgZ2VuZXJhdGUgbWF0Y2hlcyBvbmx5IG9mIGRpc3RhbmNlXG4gKiBvbmUuICBEbyBub3QgbWFpbnRhaW4gYSBoYXNoIHRhYmxlLiAgKEl0IHdpbGwgYmUgcmVnZW5lcmF0ZWQgaWYgdGhpcyBydW4gb2ZcbiAqIGRlZmxhdGUgc3dpdGNoZXMgYXdheSBmcm9tIFpfUkxFLilcbiAqL1xuZnVuY3Rpb24gZGVmbGF0ZV9ybGUocywgZmx1c2gpIHtcbiAgdmFyIGJmbHVzaDsgICAgICAgICAgICAvKiBzZXQgaWYgY3VycmVudCBibG9jayBtdXN0IGJlIGZsdXNoZWQgKi9cbiAgdmFyIHByZXY7ICAgICAgICAgICAgICAvKiBieXRlIGF0IGRpc3RhbmNlIG9uZSB0byBtYXRjaCAqL1xuICB2YXIgc2Nhbiwgc3RyZW5kOyAgICAgIC8qIHNjYW4gZ29lcyB1cCB0byBzdHJlbmQgZm9yIGxlbmd0aCBvZiBydW4gKi9cblxuICB2YXIgX3dpbiA9IHMud2luZG93O1xuXG4gIGZvciAoOzspIHtcbiAgICAvKiBNYWtlIHN1cmUgdGhhdCB3ZSBhbHdheXMgaGF2ZSBlbm91Z2ggbG9va2FoZWFkLCBleGNlcHRcbiAgICAgKiBhdCB0aGUgZW5kIG9mIHRoZSBpbnB1dCBmaWxlLiBXZSBuZWVkIE1BWF9NQVRDSCBieXRlc1xuICAgICAqIGZvciB0aGUgbG9uZ2VzdCBydW4sIHBsdXMgb25lIGZvciB0aGUgdW5yb2xsZWQgbG9vcC5cbiAgICAgKi9cbiAgICBpZiAocy5sb29rYWhlYWQgPD0gTUFYX01BVENIKSB7XG4gICAgICBmaWxsX3dpbmRvdyhzKTtcbiAgICAgIGlmIChzLmxvb2thaGVhZCA8PSBNQVhfTUFUQ0ggJiYgZmx1c2ggPT09IFpfTk9fRkxVU0gpIHtcbiAgICAgICAgcmV0dXJuIEJTX05FRURfTU9SRTtcbiAgICAgIH1cbiAgICAgIGlmIChzLmxvb2thaGVhZCA9PT0gMCkgeyBicmVhazsgfSAvKiBmbHVzaCB0aGUgY3VycmVudCBibG9jayAqL1xuICAgIH1cblxuICAgIC8qIFNlZSBob3cgbWFueSB0aW1lcyB0aGUgcHJldmlvdXMgYnl0ZSByZXBlYXRzICovXG4gICAgcy5tYXRjaF9sZW5ndGggPSAwO1xuICAgIGlmIChzLmxvb2thaGVhZCA+PSBNSU5fTUFUQ0ggJiYgcy5zdHJzdGFydCA+IDApIHtcbiAgICAgIHNjYW4gPSBzLnN0cnN0YXJ0IC0gMTtcbiAgICAgIHByZXYgPSBfd2luW3NjYW5dO1xuICAgICAgaWYgKHByZXYgPT09IF93aW5bKytzY2FuXSAmJiBwcmV2ID09PSBfd2luWysrc2Nhbl0gJiYgcHJldiA9PT0gX3dpblsrK3NjYW5dKSB7XG4gICAgICAgIHN0cmVuZCA9IHMuc3Ryc3RhcnQgKyBNQVhfTUFUQ0g7XG4gICAgICAgIGRvIHtcbiAgICAgICAgICAvKmpzaGludCBub2VtcHR5OmZhbHNlKi9cbiAgICAgICAgfSB3aGlsZSAocHJldiA9PT0gX3dpblsrK3NjYW5dICYmIHByZXYgPT09IF93aW5bKytzY2FuXSAmJlxuICAgICAgICAgICAgICAgICBwcmV2ID09PSBfd2luWysrc2Nhbl0gJiYgcHJldiA9PT0gX3dpblsrK3NjYW5dICYmXG4gICAgICAgICAgICAgICAgIHByZXYgPT09IF93aW5bKytzY2FuXSAmJiBwcmV2ID09PSBfd2luWysrc2Nhbl0gJiZcbiAgICAgICAgICAgICAgICAgcHJldiA9PT0gX3dpblsrK3NjYW5dICYmIHByZXYgPT09IF93aW5bKytzY2FuXSAmJlxuICAgICAgICAgICAgICAgICBzY2FuIDwgc3RyZW5kKTtcbiAgICAgICAgcy5tYXRjaF9sZW5ndGggPSBNQVhfTUFUQ0ggLSAoc3RyZW5kIC0gc2Nhbik7XG4gICAgICAgIGlmIChzLm1hdGNoX2xlbmd0aCA+IHMubG9va2FoZWFkKSB7XG4gICAgICAgICAgcy5tYXRjaF9sZW5ndGggPSBzLmxvb2thaGVhZDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgLy9Bc3NlcnQoc2NhbiA8PSBzLT53aW5kb3crKHVJbnQpKHMtPndpbmRvd19zaXplLTEpLCBcIndpbGQgc2NhblwiKTtcbiAgICB9XG5cbiAgICAvKiBFbWl0IG1hdGNoIGlmIGhhdmUgcnVuIG9mIE1JTl9NQVRDSCBvciBsb25nZXIsIGVsc2UgZW1pdCBsaXRlcmFsICovXG4gICAgaWYgKHMubWF0Y2hfbGVuZ3RoID49IE1JTl9NQVRDSCkge1xuICAgICAgLy9jaGVja19tYXRjaChzLCBzLnN0cnN0YXJ0LCBzLnN0cnN0YXJ0IC0gMSwgcy5tYXRjaF9sZW5ndGgpO1xuXG4gICAgICAvKioqIF90cl90YWxseV9kaXN0KHMsIDEsIHMubWF0Y2hfbGVuZ3RoIC0gTUlOX01BVENILCBiZmx1c2gpOyAqKiovXG4gICAgICBiZmx1c2ggPSB0cmVlcy5fdHJfdGFsbHkocywgMSwgcy5tYXRjaF9sZW5ndGggLSBNSU5fTUFUQ0gpO1xuXG4gICAgICBzLmxvb2thaGVhZCAtPSBzLm1hdGNoX2xlbmd0aDtcbiAgICAgIHMuc3Ryc3RhcnQgKz0gcy5tYXRjaF9sZW5ndGg7XG4gICAgICBzLm1hdGNoX2xlbmd0aCA9IDA7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8qIE5vIG1hdGNoLCBvdXRwdXQgYSBsaXRlcmFsIGJ5dGUgKi9cbiAgICAgIC8vVHJhY2V2digoc3RkZXJyLFwiJWNcIiwgcy0+d2luZG93W3MtPnN0cnN0YXJ0XSkpO1xuICAgICAgLyoqKiBfdHJfdGFsbHlfbGl0KHMsIHMud2luZG93W3Muc3Ryc3RhcnRdLCBiZmx1c2gpOyAqKiovXG4gICAgICBiZmx1c2ggPSB0cmVlcy5fdHJfdGFsbHkocywgMCwgcy53aW5kb3dbcy5zdHJzdGFydF0pO1xuXG4gICAgICBzLmxvb2thaGVhZC0tO1xuICAgICAgcy5zdHJzdGFydCsrO1xuICAgIH1cbiAgICBpZiAoYmZsdXNoKSB7XG4gICAgICAvKioqIEZMVVNIX0JMT0NLKHMsIDApOyAqKiovXG4gICAgICBmbHVzaF9ibG9ja19vbmx5KHMsIGZhbHNlKTtcbiAgICAgIGlmIChzLnN0cm0uYXZhaWxfb3V0ID09PSAwKSB7XG4gICAgICAgIHJldHVybiBCU19ORUVEX01PUkU7XG4gICAgICB9XG4gICAgICAvKioqL1xuICAgIH1cbiAgfVxuICBzLmluc2VydCA9IDA7XG4gIGlmIChmbHVzaCA9PT0gWl9GSU5JU0gpIHtcbiAgICAvKioqIEZMVVNIX0JMT0NLKHMsIDEpOyAqKiovXG4gICAgZmx1c2hfYmxvY2tfb25seShzLCB0cnVlKTtcbiAgICBpZiAocy5zdHJtLmF2YWlsX291dCA9PT0gMCkge1xuICAgICAgcmV0dXJuIEJTX0ZJTklTSF9TVEFSVEVEO1xuICAgIH1cbiAgICAvKioqL1xuICAgIHJldHVybiBCU19GSU5JU0hfRE9ORTtcbiAgfVxuICBpZiAocy5sYXN0X2xpdCkge1xuICAgIC8qKiogRkxVU0hfQkxPQ0socywgMCk7ICoqKi9cbiAgICBmbHVzaF9ibG9ja19vbmx5KHMsIGZhbHNlKTtcbiAgICBpZiAocy5zdHJtLmF2YWlsX291dCA9PT0gMCkge1xuICAgICAgcmV0dXJuIEJTX05FRURfTU9SRTtcbiAgICB9XG4gICAgLyoqKi9cbiAgfVxuICByZXR1cm4gQlNfQkxPQ0tfRE9ORTtcbn1cblxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBGb3IgWl9IVUZGTUFOX09OTFksIGRvIG5vdCBsb29rIGZvciBtYXRjaGVzLiAgRG8gbm90IG1haW50YWluIGEgaGFzaCB0YWJsZS5cbiAqIChJdCB3aWxsIGJlIHJlZ2VuZXJhdGVkIGlmIHRoaXMgcnVuIG9mIGRlZmxhdGUgc3dpdGNoZXMgYXdheSBmcm9tIEh1ZmZtYW4uKVxuICovXG5mdW5jdGlvbiBkZWZsYXRlX2h1ZmYocywgZmx1c2gpIHtcbiAgdmFyIGJmbHVzaDsgICAgICAgICAgICAgLyogc2V0IGlmIGN1cnJlbnQgYmxvY2sgbXVzdCBiZSBmbHVzaGVkICovXG5cbiAgZm9yICg7Oykge1xuICAgIC8qIE1ha2Ugc3VyZSB0aGF0IHdlIGhhdmUgYSBsaXRlcmFsIHRvIHdyaXRlLiAqL1xuICAgIGlmIChzLmxvb2thaGVhZCA9PT0gMCkge1xuICAgICAgZmlsbF93aW5kb3cocyk7XG4gICAgICBpZiAocy5sb29rYWhlYWQgPT09IDApIHtcbiAgICAgICAgaWYgKGZsdXNoID09PSBaX05PX0ZMVVNIKSB7XG4gICAgICAgICAgcmV0dXJuIEJTX05FRURfTU9SRTtcbiAgICAgICAgfVxuICAgICAgICBicmVhazsgICAgICAvKiBmbHVzaCB0aGUgY3VycmVudCBibG9jayAqL1xuICAgICAgfVxuICAgIH1cblxuICAgIC8qIE91dHB1dCBhIGxpdGVyYWwgYnl0ZSAqL1xuICAgIHMubWF0Y2hfbGVuZ3RoID0gMDtcbiAgICAvL1RyYWNldnYoKHN0ZGVycixcIiVjXCIsIHMtPndpbmRvd1tzLT5zdHJzdGFydF0pKTtcbiAgICAvKioqIF90cl90YWxseV9saXQocywgcy53aW5kb3dbcy5zdHJzdGFydF0sIGJmbHVzaCk7ICoqKi9cbiAgICBiZmx1c2ggPSB0cmVlcy5fdHJfdGFsbHkocywgMCwgcy53aW5kb3dbcy5zdHJzdGFydF0pO1xuICAgIHMubG9va2FoZWFkLS07XG4gICAgcy5zdHJzdGFydCsrO1xuICAgIGlmIChiZmx1c2gpIHtcbiAgICAgIC8qKiogRkxVU0hfQkxPQ0socywgMCk7ICoqKi9cbiAgICAgIGZsdXNoX2Jsb2NrX29ubHkocywgZmFsc2UpO1xuICAgICAgaWYgKHMuc3RybS5hdmFpbF9vdXQgPT09IDApIHtcbiAgICAgICAgcmV0dXJuIEJTX05FRURfTU9SRTtcbiAgICAgIH1cbiAgICAgIC8qKiovXG4gICAgfVxuICB9XG4gIHMuaW5zZXJ0ID0gMDtcbiAgaWYgKGZsdXNoID09PSBaX0ZJTklTSCkge1xuICAgIC8qKiogRkxVU0hfQkxPQ0socywgMSk7ICoqKi9cbiAgICBmbHVzaF9ibG9ja19vbmx5KHMsIHRydWUpO1xuICAgIGlmIChzLnN0cm0uYXZhaWxfb3V0ID09PSAwKSB7XG4gICAgICByZXR1cm4gQlNfRklOSVNIX1NUQVJURUQ7XG4gICAgfVxuICAgIC8qKiovXG4gICAgcmV0dXJuIEJTX0ZJTklTSF9ET05FO1xuICB9XG4gIGlmIChzLmxhc3RfbGl0KSB7XG4gICAgLyoqKiBGTFVTSF9CTE9DSyhzLCAwKTsgKioqL1xuICAgIGZsdXNoX2Jsb2NrX29ubHkocywgZmFsc2UpO1xuICAgIGlmIChzLnN0cm0uYXZhaWxfb3V0ID09PSAwKSB7XG4gICAgICByZXR1cm4gQlNfTkVFRF9NT1JFO1xuICAgIH1cbiAgICAvKioqL1xuICB9XG4gIHJldHVybiBCU19CTE9DS19ET05FO1xufVxuXG4vKiBWYWx1ZXMgZm9yIG1heF9sYXp5X21hdGNoLCBnb29kX21hdGNoIGFuZCBtYXhfY2hhaW5fbGVuZ3RoLCBkZXBlbmRpbmcgb25cbiAqIHRoZSBkZXNpcmVkIHBhY2sgbGV2ZWwgKDAuLjkpLiBUaGUgdmFsdWVzIGdpdmVuIGJlbG93IGhhdmUgYmVlbiB0dW5lZCB0b1xuICogZXhjbHVkZSB3b3JzdCBjYXNlIHBlcmZvcm1hbmNlIGZvciBwYXRob2xvZ2ljYWwgZmlsZXMuIEJldHRlciB2YWx1ZXMgbWF5IGJlXG4gKiBmb3VuZCBmb3Igc3BlY2lmaWMgZmlsZXMuXG4gKi9cbnZhciBDb25maWcgPSBmdW5jdGlvbiAoZ29vZF9sZW5ndGgsIG1heF9sYXp5LCBuaWNlX2xlbmd0aCwgbWF4X2NoYWluLCBmdW5jKSB7XG4gIHRoaXMuZ29vZF9sZW5ndGggPSBnb29kX2xlbmd0aDtcbiAgdGhpcy5tYXhfbGF6eSA9IG1heF9sYXp5O1xuICB0aGlzLm5pY2VfbGVuZ3RoID0gbmljZV9sZW5ndGg7XG4gIHRoaXMubWF4X2NoYWluID0gbWF4X2NoYWluO1xuICB0aGlzLmZ1bmMgPSBmdW5jO1xufTtcblxudmFyIGNvbmZpZ3VyYXRpb25fdGFibGU7XG5cbmNvbmZpZ3VyYXRpb25fdGFibGUgPSBbXG4gIC8qICAgICAgZ29vZCBsYXp5IG5pY2UgY2hhaW4gKi9cbiAgbmV3IENvbmZpZygwLCAwLCAwLCAwLCBkZWZsYXRlX3N0b3JlZCksICAgICAgICAgIC8qIDAgc3RvcmUgb25seSAqL1xuICBuZXcgQ29uZmlnKDQsIDQsIDgsIDQsIGRlZmxhdGVfZmFzdCksICAgICAgICAgICAgLyogMSBtYXggc3BlZWQsIG5vIGxhenkgbWF0Y2hlcyAqL1xuICBuZXcgQ29uZmlnKDQsIDUsIDE2LCA4LCBkZWZsYXRlX2Zhc3QpLCAgICAgICAgICAgLyogMiAqL1xuICBuZXcgQ29uZmlnKDQsIDYsIDMyLCAzMiwgZGVmbGF0ZV9mYXN0KSwgICAgICAgICAgLyogMyAqL1xuXG4gIG5ldyBDb25maWcoNCwgNCwgMTYsIDE2LCBkZWZsYXRlX3Nsb3cpLCAgICAgICAgICAvKiA0IGxhenkgbWF0Y2hlcyAqL1xuICBuZXcgQ29uZmlnKDgsIDE2LCAzMiwgMzIsIGRlZmxhdGVfc2xvdyksICAgICAgICAgLyogNSAqL1xuICBuZXcgQ29uZmlnKDgsIDE2LCAxMjgsIDEyOCwgZGVmbGF0ZV9zbG93KSwgICAgICAgLyogNiAqL1xuICBuZXcgQ29uZmlnKDgsIDMyLCAxMjgsIDI1NiwgZGVmbGF0ZV9zbG93KSwgICAgICAgLyogNyAqL1xuICBuZXcgQ29uZmlnKDMyLCAxMjgsIDI1OCwgMTAyNCwgZGVmbGF0ZV9zbG93KSwgICAgLyogOCAqL1xuICBuZXcgQ29uZmlnKDMyLCAyNTgsIDI1OCwgNDA5NiwgZGVmbGF0ZV9zbG93KSAgICAgLyogOSBtYXggY29tcHJlc3Npb24gKi9cbl07XG5cblxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBJbml0aWFsaXplIHRoZSBcImxvbmdlc3QgbWF0Y2hcIiByb3V0aW5lcyBmb3IgYSBuZXcgemxpYiBzdHJlYW1cbiAqL1xuZnVuY3Rpb24gbG1faW5pdChzKSB7XG4gIHMud2luZG93X3NpemUgPSAyICogcy53X3NpemU7XG5cbiAgLyoqKiBDTEVBUl9IQVNIKHMpOyAqKiovXG4gIHplcm8ocy5oZWFkKTsgLy8gRmlsbCB3aXRoIE5JTCAoPSAwKTtcblxuICAvKiBTZXQgdGhlIGRlZmF1bHQgY29uZmlndXJhdGlvbiBwYXJhbWV0ZXJzOlxuICAgKi9cbiAgcy5tYXhfbGF6eV9tYXRjaCA9IGNvbmZpZ3VyYXRpb25fdGFibGVbcy5sZXZlbF0ubWF4X2xhenk7XG4gIHMuZ29vZF9tYXRjaCA9IGNvbmZpZ3VyYXRpb25fdGFibGVbcy5sZXZlbF0uZ29vZF9sZW5ndGg7XG4gIHMubmljZV9tYXRjaCA9IGNvbmZpZ3VyYXRpb25fdGFibGVbcy5sZXZlbF0ubmljZV9sZW5ndGg7XG4gIHMubWF4X2NoYWluX2xlbmd0aCA9IGNvbmZpZ3VyYXRpb25fdGFibGVbcy5sZXZlbF0ubWF4X2NoYWluO1xuXG4gIHMuc3Ryc3RhcnQgPSAwO1xuICBzLmJsb2NrX3N0YXJ0ID0gMDtcbiAgcy5sb29rYWhlYWQgPSAwO1xuICBzLmluc2VydCA9IDA7XG4gIHMubWF0Y2hfbGVuZ3RoID0gcy5wcmV2X2xlbmd0aCA9IE1JTl9NQVRDSCAtIDE7XG4gIHMubWF0Y2hfYXZhaWxhYmxlID0gMDtcbiAgcy5pbnNfaCA9IDA7XG59XG5cblxuZnVuY3Rpb24gRGVmbGF0ZVN0YXRlKCkge1xuICB0aGlzLnN0cm0gPSBudWxsOyAgICAgICAgICAgIC8qIHBvaW50ZXIgYmFjayB0byB0aGlzIHpsaWIgc3RyZWFtICovXG4gIHRoaXMuc3RhdHVzID0gMDsgICAgICAgICAgICAvKiBhcyB0aGUgbmFtZSBpbXBsaWVzICovXG4gIHRoaXMucGVuZGluZ19idWYgPSBudWxsOyAgICAgIC8qIG91dHB1dCBzdGlsbCBwZW5kaW5nICovXG4gIHRoaXMucGVuZGluZ19idWZfc2l6ZSA9IDA7ICAvKiBzaXplIG9mIHBlbmRpbmdfYnVmICovXG4gIHRoaXMucGVuZGluZ19vdXQgPSAwOyAgICAgICAvKiBuZXh0IHBlbmRpbmcgYnl0ZSB0byBvdXRwdXQgdG8gdGhlIHN0cmVhbSAqL1xuICB0aGlzLnBlbmRpbmcgPSAwOyAgICAgICAgICAgLyogbmIgb2YgYnl0ZXMgaW4gdGhlIHBlbmRpbmcgYnVmZmVyICovXG4gIHRoaXMud3JhcCA9IDA7ICAgICAgICAgICAgICAvKiBiaXQgMCB0cnVlIGZvciB6bGliLCBiaXQgMSB0cnVlIGZvciBnemlwICovXG4gIHRoaXMuZ3poZWFkID0gbnVsbDsgICAgICAgICAvKiBnemlwIGhlYWRlciBpbmZvcm1hdGlvbiB0byB3cml0ZSAqL1xuICB0aGlzLmd6aW5kZXggPSAwOyAgICAgICAgICAgLyogd2hlcmUgaW4gZXh0cmEsIG5hbWUsIG9yIGNvbW1lbnQgKi9cbiAgdGhpcy5tZXRob2QgPSBaX0RFRkxBVEVEOyAvKiBjYW4gb25seSBiZSBERUZMQVRFRCAqL1xuICB0aGlzLmxhc3RfZmx1c2ggPSAtMTsgICAvKiB2YWx1ZSBvZiBmbHVzaCBwYXJhbSBmb3IgcHJldmlvdXMgZGVmbGF0ZSBjYWxsICovXG5cbiAgdGhpcy53X3NpemUgPSAwOyAgLyogTFo3NyB3aW5kb3cgc2l6ZSAoMzJLIGJ5IGRlZmF1bHQpICovXG4gIHRoaXMud19iaXRzID0gMDsgIC8qIGxvZzIod19zaXplKSAgKDguLjE2KSAqL1xuICB0aGlzLndfbWFzayA9IDA7ICAvKiB3X3NpemUgLSAxICovXG5cbiAgdGhpcy53aW5kb3cgPSBudWxsO1xuICAvKiBTbGlkaW5nIHdpbmRvdy4gSW5wdXQgYnl0ZXMgYXJlIHJlYWQgaW50byB0aGUgc2Vjb25kIGhhbGYgb2YgdGhlIHdpbmRvdyxcbiAgICogYW5kIG1vdmUgdG8gdGhlIGZpcnN0IGhhbGYgbGF0ZXIgdG8ga2VlcCBhIGRpY3Rpb25hcnkgb2YgYXQgbGVhc3Qgd1NpemVcbiAgICogYnl0ZXMuIFdpdGggdGhpcyBvcmdhbml6YXRpb24sIG1hdGNoZXMgYXJlIGxpbWl0ZWQgdG8gYSBkaXN0YW5jZSBvZlxuICAgKiB3U2l6ZS1NQVhfTUFUQ0ggYnl0ZXMsIGJ1dCB0aGlzIGVuc3VyZXMgdGhhdCBJTyBpcyBhbHdheXNcbiAgICogcGVyZm9ybWVkIHdpdGggYSBsZW5ndGggbXVsdGlwbGUgb2YgdGhlIGJsb2NrIHNpemUuXG4gICAqL1xuXG4gIHRoaXMud2luZG93X3NpemUgPSAwO1xuICAvKiBBY3R1YWwgc2l6ZSBvZiB3aW5kb3c6IDIqd1NpemUsIGV4Y2VwdCB3aGVuIHRoZSB1c2VyIGlucHV0IGJ1ZmZlclxuICAgKiBpcyBkaXJlY3RseSB1c2VkIGFzIHNsaWRpbmcgd2luZG93LlxuICAgKi9cblxuICB0aGlzLnByZXYgPSBudWxsO1xuICAvKiBMaW5rIHRvIG9sZGVyIHN0cmluZyB3aXRoIHNhbWUgaGFzaCBpbmRleC4gVG8gbGltaXQgdGhlIHNpemUgb2YgdGhpc1xuICAgKiBhcnJheSB0byA2NEssIHRoaXMgbGluayBpcyBtYWludGFpbmVkIG9ubHkgZm9yIHRoZSBsYXN0IDMySyBzdHJpbmdzLlxuICAgKiBBbiBpbmRleCBpbiB0aGlzIGFycmF5IGlzIHRodXMgYSB3aW5kb3cgaW5kZXggbW9kdWxvIDMySy5cbiAgICovXG5cbiAgdGhpcy5oZWFkID0gbnVsbDsgICAvKiBIZWFkcyBvZiB0aGUgaGFzaCBjaGFpbnMgb3IgTklMLiAqL1xuXG4gIHRoaXMuaW5zX2ggPSAwOyAgICAgICAvKiBoYXNoIGluZGV4IG9mIHN0cmluZyB0byBiZSBpbnNlcnRlZCAqL1xuICB0aGlzLmhhc2hfc2l6ZSA9IDA7ICAgLyogbnVtYmVyIG9mIGVsZW1lbnRzIGluIGhhc2ggdGFibGUgKi9cbiAgdGhpcy5oYXNoX2JpdHMgPSAwOyAgIC8qIGxvZzIoaGFzaF9zaXplKSAqL1xuICB0aGlzLmhhc2hfbWFzayA9IDA7ICAgLyogaGFzaF9zaXplLTEgKi9cblxuICB0aGlzLmhhc2hfc2hpZnQgPSAwO1xuICAvKiBOdW1iZXIgb2YgYml0cyBieSB3aGljaCBpbnNfaCBtdXN0IGJlIHNoaWZ0ZWQgYXQgZWFjaCBpbnB1dFxuICAgKiBzdGVwLiBJdCBtdXN0IGJlIHN1Y2ggdGhhdCBhZnRlciBNSU5fTUFUQ0ggc3RlcHMsIHRoZSBvbGRlc3RcbiAgICogYnl0ZSBubyBsb25nZXIgdGFrZXMgcGFydCBpbiB0aGUgaGFzaCBrZXksIHRoYXQgaXM6XG4gICAqICAgaGFzaF9zaGlmdCAqIE1JTl9NQVRDSCA+PSBoYXNoX2JpdHNcbiAgICovXG5cbiAgdGhpcy5ibG9ja19zdGFydCA9IDA7XG4gIC8qIFdpbmRvdyBwb3NpdGlvbiBhdCB0aGUgYmVnaW5uaW5nIG9mIHRoZSBjdXJyZW50IG91dHB1dCBibG9jay4gR2V0c1xuICAgKiBuZWdhdGl2ZSB3aGVuIHRoZSB3aW5kb3cgaXMgbW92ZWQgYmFja3dhcmRzLlxuICAgKi9cblxuICB0aGlzLm1hdGNoX2xlbmd0aCA9IDA7ICAgICAgLyogbGVuZ3RoIG9mIGJlc3QgbWF0Y2ggKi9cbiAgdGhpcy5wcmV2X21hdGNoID0gMDsgICAgICAgIC8qIHByZXZpb3VzIG1hdGNoICovXG4gIHRoaXMubWF0Y2hfYXZhaWxhYmxlID0gMDsgICAvKiBzZXQgaWYgcHJldmlvdXMgbWF0Y2ggZXhpc3RzICovXG4gIHRoaXMuc3Ryc3RhcnQgPSAwOyAgICAgICAgICAvKiBzdGFydCBvZiBzdHJpbmcgdG8gaW5zZXJ0ICovXG4gIHRoaXMubWF0Y2hfc3RhcnQgPSAwOyAgICAgICAvKiBzdGFydCBvZiBtYXRjaGluZyBzdHJpbmcgKi9cbiAgdGhpcy5sb29rYWhlYWQgPSAwOyAgICAgICAgIC8qIG51bWJlciBvZiB2YWxpZCBieXRlcyBhaGVhZCBpbiB3aW5kb3cgKi9cblxuICB0aGlzLnByZXZfbGVuZ3RoID0gMDtcbiAgLyogTGVuZ3RoIG9mIHRoZSBiZXN0IG1hdGNoIGF0IHByZXZpb3VzIHN0ZXAuIE1hdGNoZXMgbm90IGdyZWF0ZXIgdGhhbiB0aGlzXG4gICAqIGFyZSBkaXNjYXJkZWQuIFRoaXMgaXMgdXNlZCBpbiB0aGUgbGF6eSBtYXRjaCBldmFsdWF0aW9uLlxuICAgKi9cblxuICB0aGlzLm1heF9jaGFpbl9sZW5ndGggPSAwO1xuICAvKiBUbyBzcGVlZCB1cCBkZWZsYXRpb24sIGhhc2ggY2hhaW5zIGFyZSBuZXZlciBzZWFyY2hlZCBiZXlvbmQgdGhpc1xuICAgKiBsZW5ndGguICBBIGhpZ2hlciBsaW1pdCBpbXByb3ZlcyBjb21wcmVzc2lvbiByYXRpbyBidXQgZGVncmFkZXMgdGhlXG4gICAqIHNwZWVkLlxuICAgKi9cblxuICB0aGlzLm1heF9sYXp5X21hdGNoID0gMDtcbiAgLyogQXR0ZW1wdCB0byBmaW5kIGEgYmV0dGVyIG1hdGNoIG9ubHkgd2hlbiB0aGUgY3VycmVudCBtYXRjaCBpcyBzdHJpY3RseVxuICAgKiBzbWFsbGVyIHRoYW4gdGhpcyB2YWx1ZS4gVGhpcyBtZWNoYW5pc20gaXMgdXNlZCBvbmx5IGZvciBjb21wcmVzc2lvblxuICAgKiBsZXZlbHMgPj0gNC5cbiAgICovXG4gIC8vIFRoYXQncyBhbGlhcyB0byBtYXhfbGF6eV9tYXRjaCwgZG9uJ3QgdXNlIGRpcmVjdGx5XG4gIC8vdGhpcy5tYXhfaW5zZXJ0X2xlbmd0aCA9IDA7XG4gIC8qIEluc2VydCBuZXcgc3RyaW5ncyBpbiB0aGUgaGFzaCB0YWJsZSBvbmx5IGlmIHRoZSBtYXRjaCBsZW5ndGggaXMgbm90XG4gICAqIGdyZWF0ZXIgdGhhbiB0aGlzIGxlbmd0aC4gVGhpcyBzYXZlcyB0aW1lIGJ1dCBkZWdyYWRlcyBjb21wcmVzc2lvbi5cbiAgICogbWF4X2luc2VydF9sZW5ndGggaXMgdXNlZCBvbmx5IGZvciBjb21wcmVzc2lvbiBsZXZlbHMgPD0gMy5cbiAgICovXG5cbiAgdGhpcy5sZXZlbCA9IDA7ICAgICAvKiBjb21wcmVzc2lvbiBsZXZlbCAoMS4uOSkgKi9cbiAgdGhpcy5zdHJhdGVneSA9IDA7ICAvKiBmYXZvciBvciBmb3JjZSBIdWZmbWFuIGNvZGluZyovXG5cbiAgdGhpcy5nb29kX21hdGNoID0gMDtcbiAgLyogVXNlIGEgZmFzdGVyIHNlYXJjaCB3aGVuIHRoZSBwcmV2aW91cyBtYXRjaCBpcyBsb25nZXIgdGhhbiB0aGlzICovXG5cbiAgdGhpcy5uaWNlX21hdGNoID0gMDsgLyogU3RvcCBzZWFyY2hpbmcgd2hlbiBjdXJyZW50IG1hdGNoIGV4Y2VlZHMgdGhpcyAqL1xuXG4gICAgICAgICAgICAgIC8qIHVzZWQgYnkgdHJlZXMuYzogKi9cblxuICAvKiBEaWRuJ3QgdXNlIGN0X2RhdGEgdHlwZWRlZiBiZWxvdyB0byBzdXBwcmVzcyBjb21waWxlciB3YXJuaW5nICovXG5cbiAgLy8gc3RydWN0IGN0X2RhdGFfcyBkeW5fbHRyZWVbSEVBUF9TSVpFXTsgICAvKiBsaXRlcmFsIGFuZCBsZW5ndGggdHJlZSAqL1xuICAvLyBzdHJ1Y3QgY3RfZGF0YV9zIGR5bl9kdHJlZVsyKkRfQ09ERVMrMV07IC8qIGRpc3RhbmNlIHRyZWUgKi9cbiAgLy8gc3RydWN0IGN0X2RhdGFfcyBibF90cmVlWzIqQkxfQ09ERVMrMV07ICAvKiBIdWZmbWFuIHRyZWUgZm9yIGJpdCBsZW5ndGhzICovXG5cbiAgLy8gVXNlIGZsYXQgYXJyYXkgb2YgRE9VQkxFIHNpemUsIHdpdGggaW50ZXJsZWF2ZWQgZmF0YSxcbiAgLy8gYmVjYXVzZSBKUyBkb2VzIG5vdCBzdXBwb3J0IGVmZmVjdGl2ZVxuICB0aGlzLmR5bl9sdHJlZSAgPSBuZXcgdXRpbHMuQnVmMTYoSEVBUF9TSVpFICogMik7XG4gIHRoaXMuZHluX2R0cmVlICA9IG5ldyB1dGlscy5CdWYxNigoMipEX0NPREVTKzEpICogMik7XG4gIHRoaXMuYmxfdHJlZSAgICA9IG5ldyB1dGlscy5CdWYxNigoMipCTF9DT0RFUysxKSAqIDIpO1xuICB6ZXJvKHRoaXMuZHluX2x0cmVlKTtcbiAgemVybyh0aGlzLmR5bl9kdHJlZSk7XG4gIHplcm8odGhpcy5ibF90cmVlKTtcblxuICB0aGlzLmxfZGVzYyAgID0gbnVsbDsgICAgICAgICAvKiBkZXNjLiBmb3IgbGl0ZXJhbCB0cmVlICovXG4gIHRoaXMuZF9kZXNjICAgPSBudWxsOyAgICAgICAgIC8qIGRlc2MuIGZvciBkaXN0YW5jZSB0cmVlICovXG4gIHRoaXMuYmxfZGVzYyAgPSBudWxsOyAgICAgICAgIC8qIGRlc2MuIGZvciBiaXQgbGVuZ3RoIHRyZWUgKi9cblxuICAvL3VzaCBibF9jb3VudFtNQVhfQklUUysxXTtcbiAgdGhpcy5ibF9jb3VudCA9IG5ldyB1dGlscy5CdWYxNihNQVhfQklUUysxKTtcbiAgLyogbnVtYmVyIG9mIGNvZGVzIGF0IGVhY2ggYml0IGxlbmd0aCBmb3IgYW4gb3B0aW1hbCB0cmVlICovXG5cbiAgLy9pbnQgaGVhcFsyKkxfQ09ERVMrMV07ICAgICAgLyogaGVhcCB1c2VkIHRvIGJ1aWxkIHRoZSBIdWZmbWFuIHRyZWVzICovXG4gIHRoaXMuaGVhcCA9IG5ldyB1dGlscy5CdWYxNigyKkxfQ09ERVMrMSk7ICAvKiBoZWFwIHVzZWQgdG8gYnVpbGQgdGhlIEh1ZmZtYW4gdHJlZXMgKi9cbiAgemVybyh0aGlzLmhlYXApO1xuXG4gIHRoaXMuaGVhcF9sZW4gPSAwOyAgICAgICAgICAgICAgIC8qIG51bWJlciBvZiBlbGVtZW50cyBpbiB0aGUgaGVhcCAqL1xuICB0aGlzLmhlYXBfbWF4ID0gMDsgICAgICAgICAgICAgICAvKiBlbGVtZW50IG9mIGxhcmdlc3QgZnJlcXVlbmN5ICovXG4gIC8qIFRoZSBzb25zIG9mIGhlYXBbbl0gYXJlIGhlYXBbMipuXSBhbmQgaGVhcFsyKm4rMV0uIGhlYXBbMF0gaXMgbm90IHVzZWQuXG4gICAqIFRoZSBzYW1lIGhlYXAgYXJyYXkgaXMgdXNlZCB0byBidWlsZCBhbGwgdHJlZXMuXG4gICAqL1xuXG4gIHRoaXMuZGVwdGggPSBuZXcgdXRpbHMuQnVmMTYoMipMX0NPREVTKzEpOyAvL3VjaCBkZXB0aFsyKkxfQ09ERVMrMV07XG4gIHplcm8odGhpcy5kZXB0aCk7XG4gIC8qIERlcHRoIG9mIGVhY2ggc3VidHJlZSB1c2VkIGFzIHRpZSBicmVha2VyIGZvciB0cmVlcyBvZiBlcXVhbCBmcmVxdWVuY3lcbiAgICovXG5cbiAgdGhpcy5sX2J1ZiA9IDA7ICAgICAgICAgIC8qIGJ1ZmZlciBpbmRleCBmb3IgbGl0ZXJhbHMgb3IgbGVuZ3RocyAqL1xuXG4gIHRoaXMubGl0X2J1ZnNpemUgPSAwO1xuICAvKiBTaXplIG9mIG1hdGNoIGJ1ZmZlciBmb3IgbGl0ZXJhbHMvbGVuZ3Rocy4gIFRoZXJlIGFyZSA0IHJlYXNvbnMgZm9yXG4gICAqIGxpbWl0aW5nIGxpdF9idWZzaXplIHRvIDY0SzpcbiAgICogICAtIGZyZXF1ZW5jaWVzIGNhbiBiZSBrZXB0IGluIDE2IGJpdCBjb3VudGVyc1xuICAgKiAgIC0gaWYgY29tcHJlc3Npb24gaXMgbm90IHN1Y2Nlc3NmdWwgZm9yIHRoZSBmaXJzdCBibG9jaywgYWxsIGlucHV0XG4gICAqICAgICBkYXRhIGlzIHN0aWxsIGluIHRoZSB3aW5kb3cgc28gd2UgY2FuIHN0aWxsIGVtaXQgYSBzdG9yZWQgYmxvY2sgZXZlblxuICAgKiAgICAgd2hlbiBpbnB1dCBjb21lcyBmcm9tIHN0YW5kYXJkIGlucHV0LiAgKFRoaXMgY2FuIGFsc28gYmUgZG9uZSBmb3JcbiAgICogICAgIGFsbCBibG9ja3MgaWYgbGl0X2J1ZnNpemUgaXMgbm90IGdyZWF0ZXIgdGhhbiAzMksuKVxuICAgKiAgIC0gaWYgY29tcHJlc3Npb24gaXMgbm90IHN1Y2Nlc3NmdWwgZm9yIGEgZmlsZSBzbWFsbGVyIHRoYW4gNjRLLCB3ZSBjYW5cbiAgICogICAgIGV2ZW4gZW1pdCBhIHN0b3JlZCBmaWxlIGluc3RlYWQgb2YgYSBzdG9yZWQgYmxvY2sgKHNhdmluZyA1IGJ5dGVzKS5cbiAgICogICAgIFRoaXMgaXMgYXBwbGljYWJsZSBvbmx5IGZvciB6aXAgKG5vdCBnemlwIG9yIHpsaWIpLlxuICAgKiAgIC0gY3JlYXRpbmcgbmV3IEh1ZmZtYW4gdHJlZXMgbGVzcyBmcmVxdWVudGx5IG1heSBub3QgcHJvdmlkZSBmYXN0XG4gICAqICAgICBhZGFwdGF0aW9uIHRvIGNoYW5nZXMgaW4gdGhlIGlucHV0IGRhdGEgc3RhdGlzdGljcy4gKFRha2UgZm9yXG4gICAqICAgICBleGFtcGxlIGEgYmluYXJ5IGZpbGUgd2l0aCBwb29ybHkgY29tcHJlc3NpYmxlIGNvZGUgZm9sbG93ZWQgYnlcbiAgICogICAgIGEgaGlnaGx5IGNvbXByZXNzaWJsZSBzdHJpbmcgdGFibGUuKSBTbWFsbGVyIGJ1ZmZlciBzaXplcyBnaXZlXG4gICAqICAgICBmYXN0IGFkYXB0YXRpb24gYnV0IGhhdmUgb2YgY291cnNlIHRoZSBvdmVyaGVhZCBvZiB0cmFuc21pdHRpbmdcbiAgICogICAgIHRyZWVzIG1vcmUgZnJlcXVlbnRseS5cbiAgICogICAtIEkgY2FuJ3QgY291bnQgYWJvdmUgNFxuICAgKi9cblxuICB0aGlzLmxhc3RfbGl0ID0gMDsgICAgICAvKiBydW5uaW5nIGluZGV4IGluIGxfYnVmICovXG5cbiAgdGhpcy5kX2J1ZiA9IDA7XG4gIC8qIEJ1ZmZlciBpbmRleCBmb3IgZGlzdGFuY2VzLiBUbyBzaW1wbGlmeSB0aGUgY29kZSwgZF9idWYgYW5kIGxfYnVmIGhhdmVcbiAgICogdGhlIHNhbWUgbnVtYmVyIG9mIGVsZW1lbnRzLiBUbyB1c2UgZGlmZmVyZW50IGxlbmd0aHMsIGFuIGV4dHJhIGZsYWdcbiAgICogYXJyYXkgd291bGQgYmUgbmVjZXNzYXJ5LlxuICAgKi9cblxuICB0aGlzLm9wdF9sZW4gPSAwOyAgICAgICAvKiBiaXQgbGVuZ3RoIG9mIGN1cnJlbnQgYmxvY2sgd2l0aCBvcHRpbWFsIHRyZWVzICovXG4gIHRoaXMuc3RhdGljX2xlbiA9IDA7ICAgIC8qIGJpdCBsZW5ndGggb2YgY3VycmVudCBibG9jayB3aXRoIHN0YXRpYyB0cmVlcyAqL1xuICB0aGlzLm1hdGNoZXMgPSAwOyAgICAgICAvKiBudW1iZXIgb2Ygc3RyaW5nIG1hdGNoZXMgaW4gY3VycmVudCBibG9jayAqL1xuICB0aGlzLmluc2VydCA9IDA7ICAgICAgICAvKiBieXRlcyBhdCBlbmQgb2Ygd2luZG93IGxlZnQgdG8gaW5zZXJ0ICovXG5cblxuICB0aGlzLmJpX2J1ZiA9IDA7XG4gIC8qIE91dHB1dCBidWZmZXIuIGJpdHMgYXJlIGluc2VydGVkIHN0YXJ0aW5nIGF0IHRoZSBib3R0b20gKGxlYXN0XG4gICAqIHNpZ25pZmljYW50IGJpdHMpLlxuICAgKi9cbiAgdGhpcy5iaV92YWxpZCA9IDA7XG4gIC8qIE51bWJlciBvZiB2YWxpZCBiaXRzIGluIGJpX2J1Zi4gIEFsbCBiaXRzIGFib3ZlIHRoZSBsYXN0IHZhbGlkIGJpdFxuICAgKiBhcmUgYWx3YXlzIHplcm8uXG4gICAqL1xuXG4gIC8vIFVzZWQgZm9yIHdpbmRvdyBtZW1vcnkgaW5pdC4gV2Ugc2FmZWx5IGlnbm9yZSBpdCBmb3IgSlMuIFRoYXQgbWFrZXNcbiAgLy8gc2Vuc2Ugb25seSBmb3IgcG9pbnRlcnMgYW5kIG1lbW9yeSBjaGVjayB0b29scy5cbiAgLy90aGlzLmhpZ2hfd2F0ZXIgPSAwO1xuICAvKiBIaWdoIHdhdGVyIG1hcmsgb2Zmc2V0IGluIHdpbmRvdyBmb3IgaW5pdGlhbGl6ZWQgYnl0ZXMgLS0gYnl0ZXMgYWJvdmVcbiAgICogdGhpcyBhcmUgc2V0IHRvIHplcm8gaW4gb3JkZXIgdG8gYXZvaWQgbWVtb3J5IGNoZWNrIHdhcm5pbmdzIHdoZW5cbiAgICogbG9uZ2VzdCBtYXRjaCByb3V0aW5lcyBhY2Nlc3MgYnl0ZXMgcGFzdCB0aGUgaW5wdXQuICBUaGlzIGlzIHRoZW5cbiAgICogdXBkYXRlZCB0byB0aGUgbmV3IGhpZ2ggd2F0ZXIgbWFyay5cbiAgICovXG59XG5cblxuZnVuY3Rpb24gZGVmbGF0ZVJlc2V0S2VlcChzdHJtKSB7XG4gIHZhciBzO1xuXG4gIGlmICghc3RybSB8fCAhc3RybS5zdGF0ZSkge1xuICAgIHJldHVybiBlcnIoc3RybSwgWl9TVFJFQU1fRVJST1IpO1xuICB9XG5cbiAgc3RybS50b3RhbF9pbiA9IHN0cm0udG90YWxfb3V0ID0gMDtcbiAgc3RybS5kYXRhX3R5cGUgPSBaX1VOS05PV047XG5cbiAgcyA9IHN0cm0uc3RhdGU7XG4gIHMucGVuZGluZyA9IDA7XG4gIHMucGVuZGluZ19vdXQgPSAwO1xuXG4gIGlmIChzLndyYXAgPCAwKSB7XG4gICAgcy53cmFwID0gLXMud3JhcDtcbiAgICAvKiB3YXMgbWFkZSBuZWdhdGl2ZSBieSBkZWZsYXRlKC4uLiwgWl9GSU5JU0gpOyAqL1xuICB9XG4gIHMuc3RhdHVzID0gKHMud3JhcCA/IElOSVRfU1RBVEUgOiBCVVNZX1NUQVRFKTtcbiAgc3RybS5hZGxlciA9IChzLndyYXAgPT09IDIpID9cbiAgICAwICAvLyBjcmMzMigwLCBaX05VTEwsIDApXG4gIDpcbiAgICAxOyAvLyBhZGxlcjMyKDAsIFpfTlVMTCwgMClcbiAgcy5sYXN0X2ZsdXNoID0gWl9OT19GTFVTSDtcbiAgdHJlZXMuX3RyX2luaXQocyk7XG4gIHJldHVybiBaX09LO1xufVxuXG5cbmZ1bmN0aW9uIGRlZmxhdGVSZXNldChzdHJtKSB7XG4gIHZhciByZXQgPSBkZWZsYXRlUmVzZXRLZWVwKHN0cm0pO1xuICBpZiAocmV0ID09PSBaX09LKSB7XG4gICAgbG1faW5pdChzdHJtLnN0YXRlKTtcbiAgfVxuICByZXR1cm4gcmV0O1xufVxuXG5cbmZ1bmN0aW9uIGRlZmxhdGVTZXRIZWFkZXIoc3RybSwgaGVhZCkge1xuICBpZiAoIXN0cm0gfHwgIXN0cm0uc3RhdGUpIHsgcmV0dXJuIFpfU1RSRUFNX0VSUk9SOyB9XG4gIGlmIChzdHJtLnN0YXRlLndyYXAgIT09IDIpIHsgcmV0dXJuIFpfU1RSRUFNX0VSUk9SOyB9XG4gIHN0cm0uc3RhdGUuZ3poZWFkID0gaGVhZDtcbiAgcmV0dXJuIFpfT0s7XG59XG5cblxuZnVuY3Rpb24gZGVmbGF0ZUluaXQyKHN0cm0sIGxldmVsLCBtZXRob2QsIHdpbmRvd0JpdHMsIG1lbUxldmVsLCBzdHJhdGVneSkge1xuICBpZiAoIXN0cm0pIHsgLy8gPT09IFpfTlVMTFxuICAgIHJldHVybiBaX1NUUkVBTV9FUlJPUjtcbiAgfVxuICB2YXIgd3JhcCA9IDE7XG5cbiAgaWYgKGxldmVsID09PSBaX0RFRkFVTFRfQ09NUFJFU1NJT04pIHtcbiAgICBsZXZlbCA9IDY7XG4gIH1cblxuICBpZiAod2luZG93Qml0cyA8IDApIHsgLyogc3VwcHJlc3MgemxpYiB3cmFwcGVyICovXG4gICAgd3JhcCA9IDA7XG4gICAgd2luZG93Qml0cyA9IC13aW5kb3dCaXRzO1xuICB9XG5cbiAgZWxzZSBpZiAod2luZG93Qml0cyA+IDE1KSB7XG4gICAgd3JhcCA9IDI7ICAgICAgICAgICAvKiB3cml0ZSBnemlwIHdyYXBwZXIgaW5zdGVhZCAqL1xuICAgIHdpbmRvd0JpdHMgLT0gMTY7XG4gIH1cblxuXG4gIGlmIChtZW1MZXZlbCA8IDEgfHwgbWVtTGV2ZWwgPiBNQVhfTUVNX0xFVkVMIHx8IG1ldGhvZCAhPT0gWl9ERUZMQVRFRCB8fFxuICAgIHdpbmRvd0JpdHMgPCA4IHx8IHdpbmRvd0JpdHMgPiAxNSB8fCBsZXZlbCA8IDAgfHwgbGV2ZWwgPiA5IHx8XG4gICAgc3RyYXRlZ3kgPCAwIHx8IHN0cmF0ZWd5ID4gWl9GSVhFRCkge1xuICAgIHJldHVybiBlcnIoc3RybSwgWl9TVFJFQU1fRVJST1IpO1xuICB9XG5cblxuICBpZiAod2luZG93Qml0cyA9PT0gOCkge1xuICAgIHdpbmRvd0JpdHMgPSA5O1xuICB9XG4gIC8qIHVudGlsIDI1Ni1ieXRlIHdpbmRvdyBidWcgZml4ZWQgKi9cblxuICB2YXIgcyA9IG5ldyBEZWZsYXRlU3RhdGUoKTtcblxuICBzdHJtLnN0YXRlID0gcztcbiAgcy5zdHJtID0gc3RybTtcblxuICBzLndyYXAgPSB3cmFwO1xuICBzLmd6aGVhZCA9IG51bGw7XG4gIHMud19iaXRzID0gd2luZG93Qml0cztcbiAgcy53X3NpemUgPSAxIDw8IHMud19iaXRzO1xuICBzLndfbWFzayA9IHMud19zaXplIC0gMTtcblxuICBzLmhhc2hfYml0cyA9IG1lbUxldmVsICsgNztcbiAgcy5oYXNoX3NpemUgPSAxIDw8IHMuaGFzaF9iaXRzO1xuICBzLmhhc2hfbWFzayA9IHMuaGFzaF9zaXplIC0gMTtcbiAgcy5oYXNoX3NoaWZ0ID0gfn4oKHMuaGFzaF9iaXRzICsgTUlOX01BVENIIC0gMSkgLyBNSU5fTUFUQ0gpO1xuXG4gIHMud2luZG93ID0gbmV3IHV0aWxzLkJ1Zjgocy53X3NpemUgKiAyKTtcbiAgcy5oZWFkID0gbmV3IHV0aWxzLkJ1ZjE2KHMuaGFzaF9zaXplKTtcbiAgcy5wcmV2ID0gbmV3IHV0aWxzLkJ1ZjE2KHMud19zaXplKTtcblxuICAvLyBEb24ndCBuZWVkIG1lbSBpbml0IG1hZ2ljIGZvciBKUy5cbiAgLy9zLmhpZ2hfd2F0ZXIgPSAwOyAgLyogbm90aGluZyB3cml0dGVuIHRvIHMtPndpbmRvdyB5ZXQgKi9cblxuICBzLmxpdF9idWZzaXplID0gMSA8PCAobWVtTGV2ZWwgKyA2KTsgLyogMTZLIGVsZW1lbnRzIGJ5IGRlZmF1bHQgKi9cblxuICBzLnBlbmRpbmdfYnVmX3NpemUgPSBzLmxpdF9idWZzaXplICogNDtcbiAgcy5wZW5kaW5nX2J1ZiA9IG5ldyB1dGlscy5CdWY4KHMucGVuZGluZ19idWZfc2l6ZSk7XG5cbiAgcy5kX2J1ZiA9IHMubGl0X2J1ZnNpemUgPj4gMTtcbiAgcy5sX2J1ZiA9ICgxICsgMikgKiBzLmxpdF9idWZzaXplO1xuXG4gIHMubGV2ZWwgPSBsZXZlbDtcbiAgcy5zdHJhdGVneSA9IHN0cmF0ZWd5O1xuICBzLm1ldGhvZCA9IG1ldGhvZDtcblxuICByZXR1cm4gZGVmbGF0ZVJlc2V0KHN0cm0pO1xufVxuXG5mdW5jdGlvbiBkZWZsYXRlSW5pdChzdHJtLCBsZXZlbCkge1xuICByZXR1cm4gZGVmbGF0ZUluaXQyKHN0cm0sIGxldmVsLCBaX0RFRkxBVEVELCBNQVhfV0JJVFMsIERFRl9NRU1fTEVWRUwsIFpfREVGQVVMVF9TVFJBVEVHWSk7XG59XG5cblxuZnVuY3Rpb24gZGVmbGF0ZShzdHJtLCBmbHVzaCkge1xuICB2YXIgb2xkX2ZsdXNoLCBzO1xuICB2YXIgYmVnLCB2YWw7IC8vIGZvciBnemlwIGhlYWRlciB3cml0ZSBvbmx5XG5cbiAgaWYgKCFzdHJtIHx8ICFzdHJtLnN0YXRlIHx8XG4gICAgZmx1c2ggPiBaX0JMT0NLIHx8IGZsdXNoIDwgMCkge1xuICAgIHJldHVybiBzdHJtID8gZXJyKHN0cm0sIFpfU1RSRUFNX0VSUk9SKSA6IFpfU1RSRUFNX0VSUk9SO1xuICB9XG5cbiAgcyA9IHN0cm0uc3RhdGU7XG5cbiAgaWYgKCFzdHJtLm91dHB1dCB8fFxuICAgICAgKCFzdHJtLmlucHV0ICYmIHN0cm0uYXZhaWxfaW4gIT09IDApIHx8XG4gICAgICAocy5zdGF0dXMgPT09IEZJTklTSF9TVEFURSAmJiBmbHVzaCAhPT0gWl9GSU5JU0gpKSB7XG4gICAgcmV0dXJuIGVycihzdHJtLCAoc3RybS5hdmFpbF9vdXQgPT09IDApID8gWl9CVUZfRVJST1IgOiBaX1NUUkVBTV9FUlJPUik7XG4gIH1cblxuICBzLnN0cm0gPSBzdHJtOyAvKiBqdXN0IGluIGNhc2UgKi9cbiAgb2xkX2ZsdXNoID0gcy5sYXN0X2ZsdXNoO1xuICBzLmxhc3RfZmx1c2ggPSBmbHVzaDtcblxuICAvKiBXcml0ZSB0aGUgaGVhZGVyICovXG4gIGlmIChzLnN0YXR1cyA9PT0gSU5JVF9TVEFURSkge1xuXG4gICAgaWYgKHMud3JhcCA9PT0gMikgeyAvLyBHWklQIGhlYWRlclxuICAgICAgc3RybS5hZGxlciA9IDA7ICAvL2NyYzMyKDBMLCBaX05VTEwsIDApO1xuICAgICAgcHV0X2J5dGUocywgMzEpO1xuICAgICAgcHV0X2J5dGUocywgMTM5KTtcbiAgICAgIHB1dF9ieXRlKHMsIDgpO1xuICAgICAgaWYgKCFzLmd6aGVhZCkgeyAvLyBzLT5nemhlYWQgPT0gWl9OVUxMXG4gICAgICAgIHB1dF9ieXRlKHMsIDApO1xuICAgICAgICBwdXRfYnl0ZShzLCAwKTtcbiAgICAgICAgcHV0X2J5dGUocywgMCk7XG4gICAgICAgIHB1dF9ieXRlKHMsIDApO1xuICAgICAgICBwdXRfYnl0ZShzLCAwKTtcbiAgICAgICAgcHV0X2J5dGUocywgcy5sZXZlbCA9PT0gOSA/IDIgOlxuICAgICAgICAgICAgICAgICAgICAocy5zdHJhdGVneSA+PSBaX0hVRkZNQU5fT05MWSB8fCBzLmxldmVsIDwgMiA/XG4gICAgICAgICAgICAgICAgICAgICA0IDogMCkpO1xuICAgICAgICBwdXRfYnl0ZShzLCBPU19DT0RFKTtcbiAgICAgICAgcy5zdGF0dXMgPSBCVVNZX1NUQVRFO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIHB1dF9ieXRlKHMsIChzLmd6aGVhZC50ZXh0ID8gMSA6IDApICtcbiAgICAgICAgICAgICAgICAgICAgKHMuZ3poZWFkLmhjcmMgPyAyIDogMCkgK1xuICAgICAgICAgICAgICAgICAgICAoIXMuZ3poZWFkLmV4dHJhID8gMCA6IDQpICtcbiAgICAgICAgICAgICAgICAgICAgKCFzLmd6aGVhZC5uYW1lID8gMCA6IDgpICtcbiAgICAgICAgICAgICAgICAgICAgKCFzLmd6aGVhZC5jb21tZW50ID8gMCA6IDE2KVxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgIHB1dF9ieXRlKHMsIHMuZ3poZWFkLnRpbWUgJiAweGZmKTtcbiAgICAgICAgcHV0X2J5dGUocywgKHMuZ3poZWFkLnRpbWUgPj4gOCkgJiAweGZmKTtcbiAgICAgICAgcHV0X2J5dGUocywgKHMuZ3poZWFkLnRpbWUgPj4gMTYpICYgMHhmZik7XG4gICAgICAgIHB1dF9ieXRlKHMsIChzLmd6aGVhZC50aW1lID4+IDI0KSAmIDB4ZmYpO1xuICAgICAgICBwdXRfYnl0ZShzLCBzLmxldmVsID09PSA5ID8gMiA6XG4gICAgICAgICAgICAgICAgICAgIChzLnN0cmF0ZWd5ID49IFpfSFVGRk1BTl9PTkxZIHx8IHMubGV2ZWwgPCAyID9cbiAgICAgICAgICAgICAgICAgICAgIDQgOiAwKSk7XG4gICAgICAgIHB1dF9ieXRlKHMsIHMuZ3poZWFkLm9zICYgMHhmZik7XG4gICAgICAgIGlmIChzLmd6aGVhZC5leHRyYSAmJiBzLmd6aGVhZC5leHRyYS5sZW5ndGgpIHtcbiAgICAgICAgICBwdXRfYnl0ZShzLCBzLmd6aGVhZC5leHRyYS5sZW5ndGggJiAweGZmKTtcbiAgICAgICAgICBwdXRfYnl0ZShzLCAocy5nemhlYWQuZXh0cmEubGVuZ3RoID4+IDgpICYgMHhmZik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHMuZ3poZWFkLmhjcmMpIHtcbiAgICAgICAgICBzdHJtLmFkbGVyID0gY3JjMzIoc3RybS5hZGxlciwgcy5wZW5kaW5nX2J1Ziwgcy5wZW5kaW5nLCAwKTtcbiAgICAgICAgfVxuICAgICAgICBzLmd6aW5kZXggPSAwO1xuICAgICAgICBzLnN0YXR1cyA9IEVYVFJBX1NUQVRFO1xuICAgICAgfVxuICAgIH1cbiAgICBlbHNlIC8vIERFRkxBVEUgaGVhZGVyXG4gICAge1xuICAgICAgdmFyIGhlYWRlciA9IChaX0RFRkxBVEVEICsgKChzLndfYml0cyAtIDgpIDw8IDQpKSA8PCA4O1xuICAgICAgdmFyIGxldmVsX2ZsYWdzID0gLTE7XG5cbiAgICAgIGlmIChzLnN0cmF0ZWd5ID49IFpfSFVGRk1BTl9PTkxZIHx8IHMubGV2ZWwgPCAyKSB7XG4gICAgICAgIGxldmVsX2ZsYWdzID0gMDtcbiAgICAgIH0gZWxzZSBpZiAocy5sZXZlbCA8IDYpIHtcbiAgICAgICAgbGV2ZWxfZmxhZ3MgPSAxO1xuICAgICAgfSBlbHNlIGlmIChzLmxldmVsID09PSA2KSB7XG4gICAgICAgIGxldmVsX2ZsYWdzID0gMjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGxldmVsX2ZsYWdzID0gMztcbiAgICAgIH1cbiAgICAgIGhlYWRlciB8PSAobGV2ZWxfZmxhZ3MgPDwgNik7XG4gICAgICBpZiAocy5zdHJzdGFydCAhPT0gMCkgeyBoZWFkZXIgfD0gUFJFU0VUX0RJQ1Q7IH1cbiAgICAgIGhlYWRlciArPSAzMSAtIChoZWFkZXIgJSAzMSk7XG5cbiAgICAgIHMuc3RhdHVzID0gQlVTWV9TVEFURTtcbiAgICAgIHB1dFNob3J0TVNCKHMsIGhlYWRlcik7XG5cbiAgICAgIC8qIFNhdmUgdGhlIGFkbGVyMzIgb2YgdGhlIHByZXNldCBkaWN0aW9uYXJ5OiAqL1xuICAgICAgaWYgKHMuc3Ryc3RhcnQgIT09IDApIHtcbiAgICAgICAgcHV0U2hvcnRNU0Iocywgc3RybS5hZGxlciA+Pj4gMTYpO1xuICAgICAgICBwdXRTaG9ydE1TQihzLCBzdHJtLmFkbGVyICYgMHhmZmZmKTtcbiAgICAgIH1cbiAgICAgIHN0cm0uYWRsZXIgPSAxOyAvLyBhZGxlcjMyKDBMLCBaX05VTEwsIDApO1xuICAgIH1cbiAgfVxuXG4vLyNpZmRlZiBHWklQXG4gIGlmIChzLnN0YXR1cyA9PT0gRVhUUkFfU1RBVEUpIHtcbiAgICBpZiAocy5nemhlYWQuZXh0cmEvKiAhPSBaX05VTEwqLykge1xuICAgICAgYmVnID0gcy5wZW5kaW5nOyAgLyogc3RhcnQgb2YgYnl0ZXMgdG8gdXBkYXRlIGNyYyAqL1xuXG4gICAgICB3aGlsZSAocy5nemluZGV4IDwgKHMuZ3poZWFkLmV4dHJhLmxlbmd0aCAmIDB4ZmZmZikpIHtcbiAgICAgICAgaWYgKHMucGVuZGluZyA9PT0gcy5wZW5kaW5nX2J1Zl9zaXplKSB7XG4gICAgICAgICAgaWYgKHMuZ3poZWFkLmhjcmMgJiYgcy5wZW5kaW5nID4gYmVnKSB7XG4gICAgICAgICAgICBzdHJtLmFkbGVyID0gY3JjMzIoc3RybS5hZGxlciwgcy5wZW5kaW5nX2J1Ziwgcy5wZW5kaW5nIC0gYmVnLCBiZWcpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBmbHVzaF9wZW5kaW5nKHN0cm0pO1xuICAgICAgICAgIGJlZyA9IHMucGVuZGluZztcbiAgICAgICAgICBpZiAocy5wZW5kaW5nID09PSBzLnBlbmRpbmdfYnVmX3NpemUpIHtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBwdXRfYnl0ZShzLCBzLmd6aGVhZC5leHRyYVtzLmd6aW5kZXhdICYgMHhmZik7XG4gICAgICAgIHMuZ3ppbmRleCsrO1xuICAgICAgfVxuICAgICAgaWYgKHMuZ3poZWFkLmhjcmMgJiYgcy5wZW5kaW5nID4gYmVnKSB7XG4gICAgICAgIHN0cm0uYWRsZXIgPSBjcmMzMihzdHJtLmFkbGVyLCBzLnBlbmRpbmdfYnVmLCBzLnBlbmRpbmcgLSBiZWcsIGJlZyk7XG4gICAgICB9XG4gICAgICBpZiAocy5nemluZGV4ID09PSBzLmd6aGVhZC5leHRyYS5sZW5ndGgpIHtcbiAgICAgICAgcy5nemluZGV4ID0gMDtcbiAgICAgICAgcy5zdGF0dXMgPSBOQU1FX1NUQVRFO1xuICAgICAgfVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIHMuc3RhdHVzID0gTkFNRV9TVEFURTtcbiAgICB9XG4gIH1cbiAgaWYgKHMuc3RhdHVzID09PSBOQU1FX1NUQVRFKSB7XG4gICAgaWYgKHMuZ3poZWFkLm5hbWUvKiAhPSBaX05VTEwqLykge1xuICAgICAgYmVnID0gcy5wZW5kaW5nOyAgLyogc3RhcnQgb2YgYnl0ZXMgdG8gdXBkYXRlIGNyYyAqL1xuICAgICAgLy9pbnQgdmFsO1xuXG4gICAgICBkbyB7XG4gICAgICAgIGlmIChzLnBlbmRpbmcgPT09IHMucGVuZGluZ19idWZfc2l6ZSkge1xuICAgICAgICAgIGlmIChzLmd6aGVhZC5oY3JjICYmIHMucGVuZGluZyA+IGJlZykge1xuICAgICAgICAgICAgc3RybS5hZGxlciA9IGNyYzMyKHN0cm0uYWRsZXIsIHMucGVuZGluZ19idWYsIHMucGVuZGluZyAtIGJlZywgYmVnKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZmx1c2hfcGVuZGluZyhzdHJtKTtcbiAgICAgICAgICBiZWcgPSBzLnBlbmRpbmc7XG4gICAgICAgICAgaWYgKHMucGVuZGluZyA9PT0gcy5wZW5kaW5nX2J1Zl9zaXplKSB7XG4gICAgICAgICAgICB2YWwgPSAxO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIEpTIHNwZWNpZmljOiBsaXR0bGUgbWFnaWMgdG8gYWRkIHplcm8gdGVybWluYXRvciB0byBlbmQgb2Ygc3RyaW5nXG4gICAgICAgIGlmIChzLmd6aW5kZXggPCBzLmd6aGVhZC5uYW1lLmxlbmd0aCkge1xuICAgICAgICAgIHZhbCA9IHMuZ3poZWFkLm5hbWUuY2hhckNvZGVBdChzLmd6aW5kZXgrKykgJiAweGZmO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhbCA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgcHV0X2J5dGUocywgdmFsKTtcbiAgICAgIH0gd2hpbGUgKHZhbCAhPT0gMCk7XG5cbiAgICAgIGlmIChzLmd6aGVhZC5oY3JjICYmIHMucGVuZGluZyA+IGJlZykge1xuICAgICAgICBzdHJtLmFkbGVyID0gY3JjMzIoc3RybS5hZGxlciwgcy5wZW5kaW5nX2J1Ziwgcy5wZW5kaW5nIC0gYmVnLCBiZWcpO1xuICAgICAgfVxuICAgICAgaWYgKHZhbCA9PT0gMCkge1xuICAgICAgICBzLmd6aW5kZXggPSAwO1xuICAgICAgICBzLnN0YXR1cyA9IENPTU1FTlRfU1RBVEU7XG4gICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgcy5zdGF0dXMgPSBDT01NRU5UX1NUQVRFO1xuICAgIH1cbiAgfVxuICBpZiAocy5zdGF0dXMgPT09IENPTU1FTlRfU1RBVEUpIHtcbiAgICBpZiAocy5nemhlYWQuY29tbWVudC8qICE9IFpfTlVMTCovKSB7XG4gICAgICBiZWcgPSBzLnBlbmRpbmc7ICAvKiBzdGFydCBvZiBieXRlcyB0byB1cGRhdGUgY3JjICovXG4gICAgICAvL2ludCB2YWw7XG5cbiAgICAgIGRvIHtcbiAgICAgICAgaWYgKHMucGVuZGluZyA9PT0gcy5wZW5kaW5nX2J1Zl9zaXplKSB7XG4gICAgICAgICAgaWYgKHMuZ3poZWFkLmhjcmMgJiYgcy5wZW5kaW5nID4gYmVnKSB7XG4gICAgICAgICAgICBzdHJtLmFkbGVyID0gY3JjMzIoc3RybS5hZGxlciwgcy5wZW5kaW5nX2J1Ziwgcy5wZW5kaW5nIC0gYmVnLCBiZWcpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBmbHVzaF9wZW5kaW5nKHN0cm0pO1xuICAgICAgICAgIGJlZyA9IHMucGVuZGluZztcbiAgICAgICAgICBpZiAocy5wZW5kaW5nID09PSBzLnBlbmRpbmdfYnVmX3NpemUpIHtcbiAgICAgICAgICAgIHZhbCA9IDE7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gSlMgc3BlY2lmaWM6IGxpdHRsZSBtYWdpYyB0byBhZGQgemVybyB0ZXJtaW5hdG9yIHRvIGVuZCBvZiBzdHJpbmdcbiAgICAgICAgaWYgKHMuZ3ppbmRleCA8IHMuZ3poZWFkLmNvbW1lbnQubGVuZ3RoKSB7XG4gICAgICAgICAgdmFsID0gcy5nemhlYWQuY29tbWVudC5jaGFyQ29kZUF0KHMuZ3ppbmRleCsrKSAmIDB4ZmY7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFsID0gMDtcbiAgICAgICAgfVxuICAgICAgICBwdXRfYnl0ZShzLCB2YWwpO1xuICAgICAgfSB3aGlsZSAodmFsICE9PSAwKTtcblxuICAgICAgaWYgKHMuZ3poZWFkLmhjcmMgJiYgcy5wZW5kaW5nID4gYmVnKSB7XG4gICAgICAgIHN0cm0uYWRsZXIgPSBjcmMzMihzdHJtLmFkbGVyLCBzLnBlbmRpbmdfYnVmLCBzLnBlbmRpbmcgLSBiZWcsIGJlZyk7XG4gICAgICB9XG4gICAgICBpZiAodmFsID09PSAwKSB7XG4gICAgICAgIHMuc3RhdHVzID0gSENSQ19TVEFURTtcbiAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICBzLnN0YXR1cyA9IEhDUkNfU1RBVEU7XG4gICAgfVxuICB9XG4gIGlmIChzLnN0YXR1cyA9PT0gSENSQ19TVEFURSkge1xuICAgIGlmIChzLmd6aGVhZC5oY3JjKSB7XG4gICAgICBpZiAocy5wZW5kaW5nICsgMiA+IHMucGVuZGluZ19idWZfc2l6ZSkge1xuICAgICAgICBmbHVzaF9wZW5kaW5nKHN0cm0pO1xuICAgICAgfVxuICAgICAgaWYgKHMucGVuZGluZyArIDIgPD0gcy5wZW5kaW5nX2J1Zl9zaXplKSB7XG4gICAgICAgIHB1dF9ieXRlKHMsIHN0cm0uYWRsZXIgJiAweGZmKTtcbiAgICAgICAgcHV0X2J5dGUocywgKHN0cm0uYWRsZXIgPj4gOCkgJiAweGZmKTtcbiAgICAgICAgc3RybS5hZGxlciA9IDA7IC8vY3JjMzIoMEwsIFpfTlVMTCwgMCk7XG4gICAgICAgIHMuc3RhdHVzID0gQlVTWV9TVEFURTtcbiAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICBzLnN0YXR1cyA9IEJVU1lfU1RBVEU7XG4gICAgfVxuICB9XG4vLyNlbmRpZlxuXG4gIC8qIEZsdXNoIGFzIG11Y2ggcGVuZGluZyBvdXRwdXQgYXMgcG9zc2libGUgKi9cbiAgaWYgKHMucGVuZGluZyAhPT0gMCkge1xuICAgIGZsdXNoX3BlbmRpbmcoc3RybSk7XG4gICAgaWYgKHN0cm0uYXZhaWxfb3V0ID09PSAwKSB7XG4gICAgICAvKiBTaW5jZSBhdmFpbF9vdXQgaXMgMCwgZGVmbGF0ZSB3aWxsIGJlIGNhbGxlZCBhZ2FpbiB3aXRoXG4gICAgICAgKiBtb3JlIG91dHB1dCBzcGFjZSwgYnV0IHBvc3NpYmx5IHdpdGggYm90aCBwZW5kaW5nIGFuZFxuICAgICAgICogYXZhaWxfaW4gZXF1YWwgdG8gemVyby4gVGhlcmUgd29uJ3QgYmUgYW55dGhpbmcgdG8gZG8sXG4gICAgICAgKiBidXQgdGhpcyBpcyBub3QgYW4gZXJyb3Igc2l0dWF0aW9uIHNvIG1ha2Ugc3VyZSB3ZVxuICAgICAgICogcmV0dXJuIE9LIGluc3RlYWQgb2YgQlVGX0VSUk9SIGF0IG5leHQgY2FsbCBvZiBkZWZsYXRlOlxuICAgICAgICovXG4gICAgICBzLmxhc3RfZmx1c2ggPSAtMTtcbiAgICAgIHJldHVybiBaX09LO1xuICAgIH1cblxuICAgIC8qIE1ha2Ugc3VyZSB0aGVyZSBpcyBzb21ldGhpbmcgdG8gZG8gYW5kIGF2b2lkIGR1cGxpY2F0ZSBjb25zZWN1dGl2ZVxuICAgICAqIGZsdXNoZXMuIEZvciByZXBlYXRlZCBhbmQgdXNlbGVzcyBjYWxscyB3aXRoIFpfRklOSVNILCB3ZSBrZWVwXG4gICAgICogcmV0dXJuaW5nIFpfU1RSRUFNX0VORCBpbnN0ZWFkIG9mIFpfQlVGX0VSUk9SLlxuICAgICAqL1xuICB9IGVsc2UgaWYgKHN0cm0uYXZhaWxfaW4gPT09IDAgJiYgcmFuayhmbHVzaCkgPD0gcmFuayhvbGRfZmx1c2gpICYmXG4gICAgZmx1c2ggIT09IFpfRklOSVNIKSB7XG4gICAgcmV0dXJuIGVycihzdHJtLCBaX0JVRl9FUlJPUik7XG4gIH1cblxuICAvKiBVc2VyIG11c3Qgbm90IHByb3ZpZGUgbW9yZSBpbnB1dCBhZnRlciB0aGUgZmlyc3QgRklOSVNIOiAqL1xuICBpZiAocy5zdGF0dXMgPT09IEZJTklTSF9TVEFURSAmJiBzdHJtLmF2YWlsX2luICE9PSAwKSB7XG4gICAgcmV0dXJuIGVycihzdHJtLCBaX0JVRl9FUlJPUik7XG4gIH1cblxuICAvKiBTdGFydCBhIG5ldyBibG9jayBvciBjb250aW51ZSB0aGUgY3VycmVudCBvbmUuXG4gICAqL1xuICBpZiAoc3RybS5hdmFpbF9pbiAhPT0gMCB8fCBzLmxvb2thaGVhZCAhPT0gMCB8fFxuICAgIChmbHVzaCAhPT0gWl9OT19GTFVTSCAmJiBzLnN0YXR1cyAhPT0gRklOSVNIX1NUQVRFKSkge1xuICAgIHZhciBic3RhdGUgPSAocy5zdHJhdGVneSA9PT0gWl9IVUZGTUFOX09OTFkpID8gZGVmbGF0ZV9odWZmKHMsIGZsdXNoKSA6XG4gICAgICAocy5zdHJhdGVneSA9PT0gWl9STEUgPyBkZWZsYXRlX3JsZShzLCBmbHVzaCkgOlxuICAgICAgICBjb25maWd1cmF0aW9uX3RhYmxlW3MubGV2ZWxdLmZ1bmMocywgZmx1c2gpKTtcblxuICAgIGlmIChic3RhdGUgPT09IEJTX0ZJTklTSF9TVEFSVEVEIHx8IGJzdGF0ZSA9PT0gQlNfRklOSVNIX0RPTkUpIHtcbiAgICAgIHMuc3RhdHVzID0gRklOSVNIX1NUQVRFO1xuICAgIH1cbiAgICBpZiAoYnN0YXRlID09PSBCU19ORUVEX01PUkUgfHwgYnN0YXRlID09PSBCU19GSU5JU0hfU1RBUlRFRCkge1xuICAgICAgaWYgKHN0cm0uYXZhaWxfb3V0ID09PSAwKSB7XG4gICAgICAgIHMubGFzdF9mbHVzaCA9IC0xO1xuICAgICAgICAvKiBhdm9pZCBCVUZfRVJST1IgbmV4dCBjYWxsLCBzZWUgYWJvdmUgKi9cbiAgICAgIH1cbiAgICAgIHJldHVybiBaX09LO1xuICAgICAgLyogSWYgZmx1c2ggIT0gWl9OT19GTFVTSCAmJiBhdmFpbF9vdXQgPT0gMCwgdGhlIG5leHQgY2FsbFxuICAgICAgICogb2YgZGVmbGF0ZSBzaG91bGQgdXNlIHRoZSBzYW1lIGZsdXNoIHBhcmFtZXRlciB0byBtYWtlIHN1cmVcbiAgICAgICAqIHRoYXQgdGhlIGZsdXNoIGlzIGNvbXBsZXRlLiBTbyB3ZSBkb24ndCBoYXZlIHRvIG91dHB1dCBhblxuICAgICAgICogZW1wdHkgYmxvY2sgaGVyZSwgdGhpcyB3aWxsIGJlIGRvbmUgYXQgbmV4dCBjYWxsLiBUaGlzIGFsc29cbiAgICAgICAqIGVuc3VyZXMgdGhhdCBmb3IgYSB2ZXJ5IHNtYWxsIG91dHB1dCBidWZmZXIsIHdlIGVtaXQgYXQgbW9zdFxuICAgICAgICogb25lIGVtcHR5IGJsb2NrLlxuICAgICAgICovXG4gICAgfVxuICAgIGlmIChic3RhdGUgPT09IEJTX0JMT0NLX0RPTkUpIHtcbiAgICAgIGlmIChmbHVzaCA9PT0gWl9QQVJUSUFMX0ZMVVNIKSB7XG4gICAgICAgIHRyZWVzLl90cl9hbGlnbihzKTtcbiAgICAgIH1cbiAgICAgIGVsc2UgaWYgKGZsdXNoICE9PSBaX0JMT0NLKSB7IC8qIEZVTExfRkxVU0ggb3IgU1lOQ19GTFVTSCAqL1xuXG4gICAgICAgIHRyZWVzLl90cl9zdG9yZWRfYmxvY2socywgMCwgMCwgZmFsc2UpO1xuICAgICAgICAvKiBGb3IgYSBmdWxsIGZsdXNoLCB0aGlzIGVtcHR5IGJsb2NrIHdpbGwgYmUgcmVjb2duaXplZFxuICAgICAgICAgKiBhcyBhIHNwZWNpYWwgbWFya2VyIGJ5IGluZmxhdGVfc3luYygpLlxuICAgICAgICAgKi9cbiAgICAgICAgaWYgKGZsdXNoID09PSBaX0ZVTExfRkxVU0gpIHtcbiAgICAgICAgICAvKioqIENMRUFSX0hBU0gocyk7ICoqKi8gICAgICAgICAgICAgLyogZm9yZ2V0IGhpc3RvcnkgKi9cbiAgICAgICAgICB6ZXJvKHMuaGVhZCk7IC8vIEZpbGwgd2l0aCBOSUwgKD0gMCk7XG5cbiAgICAgICAgICBpZiAocy5sb29rYWhlYWQgPT09IDApIHtcbiAgICAgICAgICAgIHMuc3Ryc3RhcnQgPSAwO1xuICAgICAgICAgICAgcy5ibG9ja19zdGFydCA9IDA7XG4gICAgICAgICAgICBzLmluc2VydCA9IDA7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBmbHVzaF9wZW5kaW5nKHN0cm0pO1xuICAgICAgaWYgKHN0cm0uYXZhaWxfb3V0ID09PSAwKSB7XG4gICAgICAgIHMubGFzdF9mbHVzaCA9IC0xOyAvKiBhdm9pZCBCVUZfRVJST1IgYXQgbmV4dCBjYWxsLCBzZWUgYWJvdmUgKi9cbiAgICAgICAgcmV0dXJuIFpfT0s7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIC8vQXNzZXJ0KHN0cm0tPmF2YWlsX291dCA+IDAsIFwiYnVnMlwiKTtcbiAgLy9pZiAoc3RybS5hdmFpbF9vdXQgPD0gMCkgeyB0aHJvdyBuZXcgRXJyb3IoXCJidWcyXCIpO31cblxuICBpZiAoZmx1c2ggIT09IFpfRklOSVNIKSB7IHJldHVybiBaX09LOyB9XG4gIGlmIChzLndyYXAgPD0gMCkgeyByZXR1cm4gWl9TVFJFQU1fRU5EOyB9XG5cbiAgLyogV3JpdGUgdGhlIHRyYWlsZXIgKi9cbiAgaWYgKHMud3JhcCA9PT0gMikge1xuICAgIHB1dF9ieXRlKHMsIHN0cm0uYWRsZXIgJiAweGZmKTtcbiAgICBwdXRfYnl0ZShzLCAoc3RybS5hZGxlciA+PiA4KSAmIDB4ZmYpO1xuICAgIHB1dF9ieXRlKHMsIChzdHJtLmFkbGVyID4+IDE2KSAmIDB4ZmYpO1xuICAgIHB1dF9ieXRlKHMsIChzdHJtLmFkbGVyID4+IDI0KSAmIDB4ZmYpO1xuICAgIHB1dF9ieXRlKHMsIHN0cm0udG90YWxfaW4gJiAweGZmKTtcbiAgICBwdXRfYnl0ZShzLCAoc3RybS50b3RhbF9pbiA+PiA4KSAmIDB4ZmYpO1xuICAgIHB1dF9ieXRlKHMsIChzdHJtLnRvdGFsX2luID4+IDE2KSAmIDB4ZmYpO1xuICAgIHB1dF9ieXRlKHMsIChzdHJtLnRvdGFsX2luID4+IDI0KSAmIDB4ZmYpO1xuICB9XG4gIGVsc2VcbiAge1xuICAgIHB1dFNob3J0TVNCKHMsIHN0cm0uYWRsZXIgPj4+IDE2KTtcbiAgICBwdXRTaG9ydE1TQihzLCBzdHJtLmFkbGVyICYgMHhmZmZmKTtcbiAgfVxuXG4gIGZsdXNoX3BlbmRpbmcoc3RybSk7XG4gIC8qIElmIGF2YWlsX291dCBpcyB6ZXJvLCB0aGUgYXBwbGljYXRpb24gd2lsbCBjYWxsIGRlZmxhdGUgYWdhaW5cbiAgICogdG8gZmx1c2ggdGhlIHJlc3QuXG4gICAqL1xuICBpZiAocy53cmFwID4gMCkgeyBzLndyYXAgPSAtcy53cmFwOyB9XG4gIC8qIHdyaXRlIHRoZSB0cmFpbGVyIG9ubHkgb25jZSEgKi9cbiAgcmV0dXJuIHMucGVuZGluZyAhPT0gMCA/IFpfT0sgOiBaX1NUUkVBTV9FTkQ7XG59XG5cbmZ1bmN0aW9uIGRlZmxhdGVFbmQoc3RybSkge1xuICB2YXIgc3RhdHVzO1xuXG4gIGlmICghc3RybS8qPT0gWl9OVUxMKi8gfHwgIXN0cm0uc3RhdGUvKj09IFpfTlVMTCovKSB7XG4gICAgcmV0dXJuIFpfU1RSRUFNX0VSUk9SO1xuICB9XG5cbiAgc3RhdHVzID0gc3RybS5zdGF0ZS5zdGF0dXM7XG4gIGlmIChzdGF0dXMgIT09IElOSVRfU1RBVEUgJiZcbiAgICBzdGF0dXMgIT09IEVYVFJBX1NUQVRFICYmXG4gICAgc3RhdHVzICE9PSBOQU1FX1NUQVRFICYmXG4gICAgc3RhdHVzICE9PSBDT01NRU5UX1NUQVRFICYmXG4gICAgc3RhdHVzICE9PSBIQ1JDX1NUQVRFICYmXG4gICAgc3RhdHVzICE9PSBCVVNZX1NUQVRFICYmXG4gICAgc3RhdHVzICE9PSBGSU5JU0hfU1RBVEVcbiAgKSB7XG4gICAgcmV0dXJuIGVycihzdHJtLCBaX1NUUkVBTV9FUlJPUik7XG4gIH1cblxuICBzdHJtLnN0YXRlID0gbnVsbDtcblxuICByZXR1cm4gc3RhdHVzID09PSBCVVNZX1NUQVRFID8gZXJyKHN0cm0sIFpfREFUQV9FUlJPUikgOiBaX09LO1xufVxuXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBDb3B5IHRoZSBzb3VyY2Ugc3RhdGUgdG8gdGhlIGRlc3RpbmF0aW9uIHN0YXRlXG4gKi9cbi8vZnVuY3Rpb24gZGVmbGF0ZUNvcHkoZGVzdCwgc291cmNlKSB7XG4vL1xuLy99XG5cbmV4cG9ydHMuZGVmbGF0ZUluaXQgPSBkZWZsYXRlSW5pdDtcbmV4cG9ydHMuZGVmbGF0ZUluaXQyID0gZGVmbGF0ZUluaXQyO1xuZXhwb3J0cy5kZWZsYXRlUmVzZXQgPSBkZWZsYXRlUmVzZXQ7XG5leHBvcnRzLmRlZmxhdGVSZXNldEtlZXAgPSBkZWZsYXRlUmVzZXRLZWVwO1xuZXhwb3J0cy5kZWZsYXRlU2V0SGVhZGVyID0gZGVmbGF0ZVNldEhlYWRlcjtcbmV4cG9ydHMuZGVmbGF0ZSA9IGRlZmxhdGU7XG5leHBvcnRzLmRlZmxhdGVFbmQgPSBkZWZsYXRlRW5kO1xuZXhwb3J0cy5kZWZsYXRlSW5mbyA9ICdwYWtvIGRlZmxhdGUgKGZyb20gTm9kZWNhIHByb2plY3QpJztcblxuLyogTm90IGltcGxlbWVudGVkXG5leHBvcnRzLmRlZmxhdGVCb3VuZCA9IGRlZmxhdGVCb3VuZDtcbmV4cG9ydHMuZGVmbGF0ZUNvcHkgPSBkZWZsYXRlQ29weTtcbmV4cG9ydHMuZGVmbGF0ZVNldERpY3Rpb25hcnkgPSBkZWZsYXRlU2V0RGljdGlvbmFyeTtcbmV4cG9ydHMuZGVmbGF0ZVBhcmFtcyA9IGRlZmxhdGVQYXJhbXM7XG5leHBvcnRzLmRlZmxhdGVQZW5kaW5nID0gZGVmbGF0ZVBlbmRpbmc7XG5leHBvcnRzLmRlZmxhdGVQcmltZSA9IGRlZmxhdGVQcmltZTtcbmV4cG9ydHMuZGVmbGF0ZVR1bmUgPSBkZWZsYXRlVHVuZTtcbiovXG4iLCIndXNlIHN0cmljdCc7XG5cbi8vIFNlZSBzdGF0ZSBkZWZzIGZyb20gaW5mbGF0ZS5qc1xudmFyIEJBRCA9IDMwOyAgICAgICAvKiBnb3QgYSBkYXRhIGVycm9yIC0tIHJlbWFpbiBoZXJlIHVudGlsIHJlc2V0ICovXG52YXIgVFlQRSA9IDEyOyAgICAgIC8qIGk6IHdhaXRpbmcgZm9yIHR5cGUgYml0cywgaW5jbHVkaW5nIGxhc3QtZmxhZyBiaXQgKi9cblxuLypcbiAgIERlY29kZSBsaXRlcmFsLCBsZW5ndGgsIGFuZCBkaXN0YW5jZSBjb2RlcyBhbmQgd3JpdGUgb3V0IHRoZSByZXN1bHRpbmdcbiAgIGxpdGVyYWwgYW5kIG1hdGNoIGJ5dGVzIHVudGlsIGVpdGhlciBub3QgZW5vdWdoIGlucHV0IG9yIG91dHB1dCBpc1xuICAgYXZhaWxhYmxlLCBhbiBlbmQtb2YtYmxvY2sgaXMgZW5jb3VudGVyZWQsIG9yIGEgZGF0YSBlcnJvciBpcyBlbmNvdW50ZXJlZC5cbiAgIFdoZW4gbGFyZ2UgZW5vdWdoIGlucHV0IGFuZCBvdXRwdXQgYnVmZmVycyBhcmUgc3VwcGxpZWQgdG8gaW5mbGF0ZSgpLCBmb3JcbiAgIGV4YW1wbGUsIGEgMTZLIGlucHV0IGJ1ZmZlciBhbmQgYSA2NEsgb3V0cHV0IGJ1ZmZlciwgbW9yZSB0aGFuIDk1JSBvZiB0aGVcbiAgIGluZmxhdGUgZXhlY3V0aW9uIHRpbWUgaXMgc3BlbnQgaW4gdGhpcyByb3V0aW5lLlxuXG4gICBFbnRyeSBhc3N1bXB0aW9uczpcblxuICAgICAgICBzdGF0ZS5tb2RlID09PSBMRU5cbiAgICAgICAgc3RybS5hdmFpbF9pbiA+PSA2XG4gICAgICAgIHN0cm0uYXZhaWxfb3V0ID49IDI1OFxuICAgICAgICBzdGFydCA+PSBzdHJtLmF2YWlsX291dFxuICAgICAgICBzdGF0ZS5iaXRzIDwgOFxuXG4gICBPbiByZXR1cm4sIHN0YXRlLm1vZGUgaXMgb25lIG9mOlxuXG4gICAgICAgIExFTiAtLSByYW4gb3V0IG9mIGVub3VnaCBvdXRwdXQgc3BhY2Ugb3IgZW5vdWdoIGF2YWlsYWJsZSBpbnB1dFxuICAgICAgICBUWVBFIC0tIHJlYWNoZWQgZW5kIG9mIGJsb2NrIGNvZGUsIGluZmxhdGUoKSB0byBpbnRlcnByZXQgbmV4dCBibG9ja1xuICAgICAgICBCQUQgLS0gZXJyb3IgaW4gYmxvY2sgZGF0YVxuXG4gICBOb3RlczpcblxuICAgIC0gVGhlIG1heGltdW0gaW5wdXQgYml0cyB1c2VkIGJ5IGEgbGVuZ3RoL2Rpc3RhbmNlIHBhaXIgaXMgMTUgYml0cyBmb3IgdGhlXG4gICAgICBsZW5ndGggY29kZSwgNSBiaXRzIGZvciB0aGUgbGVuZ3RoIGV4dHJhLCAxNSBiaXRzIGZvciB0aGUgZGlzdGFuY2UgY29kZSxcbiAgICAgIGFuZCAxMyBiaXRzIGZvciB0aGUgZGlzdGFuY2UgZXh0cmEuICBUaGlzIHRvdGFscyA0OCBiaXRzLCBvciBzaXggYnl0ZXMuXG4gICAgICBUaGVyZWZvcmUgaWYgc3RybS5hdmFpbF9pbiA+PSA2LCB0aGVuIHRoZXJlIGlzIGVub3VnaCBpbnB1dCB0byBhdm9pZFxuICAgICAgY2hlY2tpbmcgZm9yIGF2YWlsYWJsZSBpbnB1dCB3aGlsZSBkZWNvZGluZy5cblxuICAgIC0gVGhlIG1heGltdW0gYnl0ZXMgdGhhdCBhIHNpbmdsZSBsZW5ndGgvZGlzdGFuY2UgcGFpciBjYW4gb3V0cHV0IGlzIDI1OFxuICAgICAgYnl0ZXMsIHdoaWNoIGlzIHRoZSBtYXhpbXVtIGxlbmd0aCB0aGF0IGNhbiBiZSBjb2RlZC4gIGluZmxhdGVfZmFzdCgpXG4gICAgICByZXF1aXJlcyBzdHJtLmF2YWlsX291dCA+PSAyNTggZm9yIGVhY2ggbG9vcCB0byBhdm9pZCBjaGVja2luZyBmb3JcbiAgICAgIG91dHB1dCBzcGFjZS5cbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBpbmZsYXRlX2Zhc3Qoc3RybSwgc3RhcnQpIHtcbiAgdmFyIHN0YXRlO1xuICB2YXIgX2luOyAgICAgICAgICAgICAgICAgICAgLyogbG9jYWwgc3RybS5pbnB1dCAqL1xuICB2YXIgbGFzdDsgICAgICAgICAgICAgICAgICAgLyogaGF2ZSBlbm91Z2ggaW5wdXQgd2hpbGUgaW4gPCBsYXN0ICovXG4gIHZhciBfb3V0OyAgICAgICAgICAgICAgICAgICAvKiBsb2NhbCBzdHJtLm91dHB1dCAqL1xuICB2YXIgYmVnOyAgICAgICAgICAgICAgICAgICAgLyogaW5mbGF0ZSgpJ3MgaW5pdGlhbCBzdHJtLm91dHB1dCAqL1xuICB2YXIgZW5kOyAgICAgICAgICAgICAgICAgICAgLyogd2hpbGUgb3V0IDwgZW5kLCBlbm91Z2ggc3BhY2UgYXZhaWxhYmxlICovXG4vLyNpZmRlZiBJTkZMQVRFX1NUUklDVFxuICB2YXIgZG1heDsgICAgICAgICAgICAgICAgICAgLyogbWF4aW11bSBkaXN0YW5jZSBmcm9tIHpsaWIgaGVhZGVyICovXG4vLyNlbmRpZlxuICB2YXIgd3NpemU7ICAgICAgICAgICAgICAgICAgLyogd2luZG93IHNpemUgb3IgemVybyBpZiBub3QgdXNpbmcgd2luZG93ICovXG4gIHZhciB3aGF2ZTsgICAgICAgICAgICAgICAgICAvKiB2YWxpZCBieXRlcyBpbiB0aGUgd2luZG93ICovXG4gIHZhciB3bmV4dDsgICAgICAgICAgICAgICAgICAvKiB3aW5kb3cgd3JpdGUgaW5kZXggKi9cbiAgLy8gVXNlIGBzX3dpbmRvd2AgaW5zdGVhZCBgd2luZG93YCwgYXZvaWQgY29uZmxpY3Qgd2l0aCBpbnN0cnVtZW50YXRpb24gdG9vbHNcbiAgdmFyIHNfd2luZG93OyAgICAgICAgICAgICAgIC8qIGFsbG9jYXRlZCBzbGlkaW5nIHdpbmRvdywgaWYgd3NpemUgIT0gMCAqL1xuICB2YXIgaG9sZDsgICAgICAgICAgICAgICAgICAgLyogbG9jYWwgc3RybS5ob2xkICovXG4gIHZhciBiaXRzOyAgICAgICAgICAgICAgICAgICAvKiBsb2NhbCBzdHJtLmJpdHMgKi9cbiAgdmFyIGxjb2RlOyAgICAgICAgICAgICAgICAgIC8qIGxvY2FsIHN0cm0ubGVuY29kZSAqL1xuICB2YXIgZGNvZGU7ICAgICAgICAgICAgICAgICAgLyogbG9jYWwgc3RybS5kaXN0Y29kZSAqL1xuICB2YXIgbG1hc2s7ICAgICAgICAgICAgICAgICAgLyogbWFzayBmb3IgZmlyc3QgbGV2ZWwgb2YgbGVuZ3RoIGNvZGVzICovXG4gIHZhciBkbWFzazsgICAgICAgICAgICAgICAgICAvKiBtYXNrIGZvciBmaXJzdCBsZXZlbCBvZiBkaXN0YW5jZSBjb2RlcyAqL1xuICB2YXIgaGVyZTsgICAgICAgICAgICAgICAgICAgLyogcmV0cmlldmVkIHRhYmxlIGVudHJ5ICovXG4gIHZhciBvcDsgICAgICAgICAgICAgICAgICAgICAvKiBjb2RlIGJpdHMsIG9wZXJhdGlvbiwgZXh0cmEgYml0cywgb3IgKi9cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8qICB3aW5kb3cgcG9zaXRpb24sIHdpbmRvdyBieXRlcyB0byBjb3B5ICovXG4gIHZhciBsZW47ICAgICAgICAgICAgICAgICAgICAvKiBtYXRjaCBsZW5ndGgsIHVudXNlZCBieXRlcyAqL1xuICB2YXIgZGlzdDsgICAgICAgICAgICAgICAgICAgLyogbWF0Y2ggZGlzdGFuY2UgKi9cbiAgdmFyIGZyb207ICAgICAgICAgICAgICAgICAgIC8qIHdoZXJlIHRvIGNvcHkgbWF0Y2ggZnJvbSAqL1xuICB2YXIgZnJvbV9zb3VyY2U7XG5cblxuICB2YXIgaW5wdXQsIG91dHB1dDsgLy8gSlMgc3BlY2lmaWMsIGJlY2F1c2Ugd2UgaGF2ZSBubyBwb2ludGVyc1xuXG4gIC8qIGNvcHkgc3RhdGUgdG8gbG9jYWwgdmFyaWFibGVzICovXG4gIHN0YXRlID0gc3RybS5zdGF0ZTtcbiAgLy9oZXJlID0gc3RhdGUuaGVyZTtcbiAgX2luID0gc3RybS5uZXh0X2luO1xuICBpbnB1dCA9IHN0cm0uaW5wdXQ7XG4gIGxhc3QgPSBfaW4gKyAoc3RybS5hdmFpbF9pbiAtIDUpO1xuICBfb3V0ID0gc3RybS5uZXh0X291dDtcbiAgb3V0cHV0ID0gc3RybS5vdXRwdXQ7XG4gIGJlZyA9IF9vdXQgLSAoc3RhcnQgLSBzdHJtLmF2YWlsX291dCk7XG4gIGVuZCA9IF9vdXQgKyAoc3RybS5hdmFpbF9vdXQgLSAyNTcpO1xuLy8jaWZkZWYgSU5GTEFURV9TVFJJQ1RcbiAgZG1heCA9IHN0YXRlLmRtYXg7XG4vLyNlbmRpZlxuICB3c2l6ZSA9IHN0YXRlLndzaXplO1xuICB3aGF2ZSA9IHN0YXRlLndoYXZlO1xuICB3bmV4dCA9IHN0YXRlLnduZXh0O1xuICBzX3dpbmRvdyA9IHN0YXRlLndpbmRvdztcbiAgaG9sZCA9IHN0YXRlLmhvbGQ7XG4gIGJpdHMgPSBzdGF0ZS5iaXRzO1xuICBsY29kZSA9IHN0YXRlLmxlbmNvZGU7XG4gIGRjb2RlID0gc3RhdGUuZGlzdGNvZGU7XG4gIGxtYXNrID0gKDEgPDwgc3RhdGUubGVuYml0cykgLSAxO1xuICBkbWFzayA9ICgxIDw8IHN0YXRlLmRpc3RiaXRzKSAtIDE7XG5cblxuICAvKiBkZWNvZGUgbGl0ZXJhbHMgYW5kIGxlbmd0aC9kaXN0YW5jZXMgdW50aWwgZW5kLW9mLWJsb2NrIG9yIG5vdCBlbm91Z2hcbiAgICAgaW5wdXQgZGF0YSBvciBvdXRwdXQgc3BhY2UgKi9cblxuICB0b3A6XG4gIGRvIHtcbiAgICBpZiAoYml0cyA8IDE1KSB7XG4gICAgICBob2xkICs9IGlucHV0W19pbisrXSA8PCBiaXRzO1xuICAgICAgYml0cyArPSA4O1xuICAgICAgaG9sZCArPSBpbnB1dFtfaW4rK10gPDwgYml0cztcbiAgICAgIGJpdHMgKz0gODtcbiAgICB9XG5cbiAgICBoZXJlID0gbGNvZGVbaG9sZCAmIGxtYXNrXTtcblxuICAgIGRvbGVuOlxuICAgIGZvciAoOzspIHsgLy8gR290byBlbXVsYXRpb25cbiAgICAgIG9wID0gaGVyZSA+Pj4gMjQvKmhlcmUuYml0cyovO1xuICAgICAgaG9sZCA+Pj49IG9wO1xuICAgICAgYml0cyAtPSBvcDtcbiAgICAgIG9wID0gKGhlcmUgPj4+IDE2KSAmIDB4ZmYvKmhlcmUub3AqLztcbiAgICAgIGlmIChvcCA9PT0gMCkgeyAgICAgICAgICAgICAgICAgICAgICAgICAgLyogbGl0ZXJhbCAqL1xuICAgICAgICAvL1RyYWNldnYoKHN0ZGVyciwgaGVyZS52YWwgPj0gMHgyMCAmJiBoZXJlLnZhbCA8IDB4N2YgP1xuICAgICAgICAvLyAgICAgICAgXCJpbmZsYXRlOiAgICAgICAgIGxpdGVyYWwgJyVjJ1xcblwiIDpcbiAgICAgICAgLy8gICAgICAgIFwiaW5mbGF0ZTogICAgICAgICBsaXRlcmFsIDB4JTAyeFxcblwiLCBoZXJlLnZhbCkpO1xuICAgICAgICBvdXRwdXRbX291dCsrXSA9IGhlcmUgJiAweGZmZmYvKmhlcmUudmFsKi87XG4gICAgICB9XG4gICAgICBlbHNlIGlmIChvcCAmIDE2KSB7ICAgICAgICAgICAgICAgICAgICAgLyogbGVuZ3RoIGJhc2UgKi9cbiAgICAgICAgbGVuID0gaGVyZSAmIDB4ZmZmZi8qaGVyZS52YWwqLztcbiAgICAgICAgb3AgJj0gMTU7ICAgICAgICAgICAgICAgICAgICAgICAgICAgLyogbnVtYmVyIG9mIGV4dHJhIGJpdHMgKi9cbiAgICAgICAgaWYgKG9wKSB7XG4gICAgICAgICAgaWYgKGJpdHMgPCBvcCkge1xuICAgICAgICAgICAgaG9sZCArPSBpbnB1dFtfaW4rK10gPDwgYml0cztcbiAgICAgICAgICAgIGJpdHMgKz0gODtcbiAgICAgICAgICB9XG4gICAgICAgICAgbGVuICs9IGhvbGQgJiAoKDEgPDwgb3ApIC0gMSk7XG4gICAgICAgICAgaG9sZCA+Pj49IG9wO1xuICAgICAgICAgIGJpdHMgLT0gb3A7XG4gICAgICAgIH1cbiAgICAgICAgLy9UcmFjZXZ2KChzdGRlcnIsIFwiaW5mbGF0ZTogICAgICAgICBsZW5ndGggJXVcXG5cIiwgbGVuKSk7XG4gICAgICAgIGlmIChiaXRzIDwgMTUpIHtcbiAgICAgICAgICBob2xkICs9IGlucHV0W19pbisrXSA8PCBiaXRzO1xuICAgICAgICAgIGJpdHMgKz0gODtcbiAgICAgICAgICBob2xkICs9IGlucHV0W19pbisrXSA8PCBiaXRzO1xuICAgICAgICAgIGJpdHMgKz0gODtcbiAgICAgICAgfVxuICAgICAgICBoZXJlID0gZGNvZGVbaG9sZCAmIGRtYXNrXTtcblxuICAgICAgICBkb2Rpc3Q6XG4gICAgICAgIGZvciAoOzspIHsgLy8gZ290byBlbXVsYXRpb25cbiAgICAgICAgICBvcCA9IGhlcmUgPj4+IDI0LypoZXJlLmJpdHMqLztcbiAgICAgICAgICBob2xkID4+Pj0gb3A7XG4gICAgICAgICAgYml0cyAtPSBvcDtcbiAgICAgICAgICBvcCA9IChoZXJlID4+PiAxNikgJiAweGZmLypoZXJlLm9wKi87XG5cbiAgICAgICAgICBpZiAob3AgJiAxNikgeyAgICAgICAgICAgICAgICAgICAgICAvKiBkaXN0YW5jZSBiYXNlICovXG4gICAgICAgICAgICBkaXN0ID0gaGVyZSAmIDB4ZmZmZi8qaGVyZS52YWwqLztcbiAgICAgICAgICAgIG9wICY9IDE1OyAgICAgICAgICAgICAgICAgICAgICAgLyogbnVtYmVyIG9mIGV4dHJhIGJpdHMgKi9cbiAgICAgICAgICAgIGlmIChiaXRzIDwgb3ApIHtcbiAgICAgICAgICAgICAgaG9sZCArPSBpbnB1dFtfaW4rK10gPDwgYml0cztcbiAgICAgICAgICAgICAgYml0cyArPSA4O1xuICAgICAgICAgICAgICBpZiAoYml0cyA8IG9wKSB7XG4gICAgICAgICAgICAgICAgaG9sZCArPSBpbnB1dFtfaW4rK10gPDwgYml0cztcbiAgICAgICAgICAgICAgICBiaXRzICs9IDg7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGRpc3QgKz0gaG9sZCAmICgoMSA8PCBvcCkgLSAxKTtcbi8vI2lmZGVmIElORkxBVEVfU1RSSUNUXG4gICAgICAgICAgICBpZiAoZGlzdCA+IGRtYXgpIHtcbiAgICAgICAgICAgICAgc3RybS5tc2cgPSAnaW52YWxpZCBkaXN0YW5jZSB0b28gZmFyIGJhY2snO1xuICAgICAgICAgICAgICBzdGF0ZS5tb2RlID0gQkFEO1xuICAgICAgICAgICAgICBicmVhayB0b3A7XG4gICAgICAgICAgICB9XG4vLyNlbmRpZlxuICAgICAgICAgICAgaG9sZCA+Pj49IG9wO1xuICAgICAgICAgICAgYml0cyAtPSBvcDtcbiAgICAgICAgICAgIC8vVHJhY2V2digoc3RkZXJyLCBcImluZmxhdGU6ICAgICAgICAgZGlzdGFuY2UgJXVcXG5cIiwgZGlzdCkpO1xuICAgICAgICAgICAgb3AgPSBfb3V0IC0gYmVnOyAgICAgICAgICAgICAgICAvKiBtYXggZGlzdGFuY2UgaW4gb3V0cHV0ICovXG4gICAgICAgICAgICBpZiAoZGlzdCA+IG9wKSB7ICAgICAgICAgICAgICAgIC8qIHNlZSBpZiBjb3B5IGZyb20gd2luZG93ICovXG4gICAgICAgICAgICAgIG9wID0gZGlzdCAtIG9wOyAgICAgICAgICAgICAgIC8qIGRpc3RhbmNlIGJhY2sgaW4gd2luZG93ICovXG4gICAgICAgICAgICAgIGlmIChvcCA+IHdoYXZlKSB7XG4gICAgICAgICAgICAgICAgaWYgKHN0YXRlLnNhbmUpIHtcbiAgICAgICAgICAgICAgICAgIHN0cm0ubXNnID0gJ2ludmFsaWQgZGlzdGFuY2UgdG9vIGZhciBiYWNrJztcbiAgICAgICAgICAgICAgICAgIHN0YXRlLm1vZGUgPSBCQUQ7XG4gICAgICAgICAgICAgICAgICBicmVhayB0b3A7XG4gICAgICAgICAgICAgICAgfVxuXG4vLyAoISkgVGhpcyBibG9jayBpcyBkaXNhYmxlZCBpbiB6bGliIGRlZmFpbHRzLFxuLy8gZG9uJ3QgZW5hYmxlIGl0IGZvciBiaW5hcnkgY29tcGF0aWJpbGl0eVxuLy8jaWZkZWYgSU5GTEFURV9BTExPV19JTlZBTElEX0RJU1RBTkNFX1RPT0ZBUl9BUlJSXG4vLyAgICAgICAgICAgICAgICBpZiAobGVuIDw9IG9wIC0gd2hhdmUpIHtcbi8vICAgICAgICAgICAgICAgICAgZG8ge1xuLy8gICAgICAgICAgICAgICAgICAgIG91dHB1dFtfb3V0KytdID0gMDtcbi8vICAgICAgICAgICAgICAgICAgfSB3aGlsZSAoLS1sZW4pO1xuLy8gICAgICAgICAgICAgICAgICBjb250aW51ZSB0b3A7XG4vLyAgICAgICAgICAgICAgICB9XG4vLyAgICAgICAgICAgICAgICBsZW4gLT0gb3AgLSB3aGF2ZTtcbi8vICAgICAgICAgICAgICAgIGRvIHtcbi8vICAgICAgICAgICAgICAgICAgb3V0cHV0W19vdXQrK10gPSAwO1xuLy8gICAgICAgICAgICAgICAgfSB3aGlsZSAoLS1vcCA+IHdoYXZlKTtcbi8vICAgICAgICAgICAgICAgIGlmIChvcCA9PT0gMCkge1xuLy8gICAgICAgICAgICAgICAgICBmcm9tID0gX291dCAtIGRpc3Q7XG4vLyAgICAgICAgICAgICAgICAgIGRvIHtcbi8vICAgICAgICAgICAgICAgICAgICBvdXRwdXRbX291dCsrXSA9IG91dHB1dFtmcm9tKytdO1xuLy8gICAgICAgICAgICAgICAgICB9IHdoaWxlICgtLWxlbik7XG4vLyAgICAgICAgICAgICAgICAgIGNvbnRpbnVlIHRvcDtcbi8vICAgICAgICAgICAgICAgIH1cbi8vI2VuZGlmXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgZnJvbSA9IDA7IC8vIHdpbmRvdyBpbmRleFxuICAgICAgICAgICAgICBmcm9tX3NvdXJjZSA9IHNfd2luZG93O1xuICAgICAgICAgICAgICBpZiAod25leHQgPT09IDApIHsgICAgICAgICAgIC8qIHZlcnkgY29tbW9uIGNhc2UgKi9cbiAgICAgICAgICAgICAgICBmcm9tICs9IHdzaXplIC0gb3A7XG4gICAgICAgICAgICAgICAgaWYgKG9wIDwgbGVuKSB7ICAgICAgICAgLyogc29tZSBmcm9tIHdpbmRvdyAqL1xuICAgICAgICAgICAgICAgICAgbGVuIC09IG9wO1xuICAgICAgICAgICAgICAgICAgZG8ge1xuICAgICAgICAgICAgICAgICAgICBvdXRwdXRbX291dCsrXSA9IHNfd2luZG93W2Zyb20rK107XG4gICAgICAgICAgICAgICAgICB9IHdoaWxlICgtLW9wKTtcbiAgICAgICAgICAgICAgICAgIGZyb20gPSBfb3V0IC0gZGlzdDsgIC8qIHJlc3QgZnJvbSBvdXRwdXQgKi9cbiAgICAgICAgICAgICAgICAgIGZyb21fc291cmNlID0gb3V0cHV0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBlbHNlIGlmICh3bmV4dCA8IG9wKSB7ICAgICAgLyogd3JhcCBhcm91bmQgd2luZG93ICovXG4gICAgICAgICAgICAgICAgZnJvbSArPSB3c2l6ZSArIHduZXh0IC0gb3A7XG4gICAgICAgICAgICAgICAgb3AgLT0gd25leHQ7XG4gICAgICAgICAgICAgICAgaWYgKG9wIDwgbGVuKSB7ICAgICAgICAgLyogc29tZSBmcm9tIGVuZCBvZiB3aW5kb3cgKi9cbiAgICAgICAgICAgICAgICAgIGxlbiAtPSBvcDtcbiAgICAgICAgICAgICAgICAgIGRvIHtcbiAgICAgICAgICAgICAgICAgICAgb3V0cHV0W19vdXQrK10gPSBzX3dpbmRvd1tmcm9tKytdO1xuICAgICAgICAgICAgICAgICAgfSB3aGlsZSAoLS1vcCk7XG4gICAgICAgICAgICAgICAgICBmcm9tID0gMDtcbiAgICAgICAgICAgICAgICAgIGlmICh3bmV4dCA8IGxlbikgeyAgLyogc29tZSBmcm9tIHN0YXJ0IG9mIHdpbmRvdyAqL1xuICAgICAgICAgICAgICAgICAgICBvcCA9IHduZXh0O1xuICAgICAgICAgICAgICAgICAgICBsZW4gLT0gb3A7XG4gICAgICAgICAgICAgICAgICAgIGRvIHtcbiAgICAgICAgICAgICAgICAgICAgICBvdXRwdXRbX291dCsrXSA9IHNfd2luZG93W2Zyb20rK107XG4gICAgICAgICAgICAgICAgICAgIH0gd2hpbGUgKC0tb3ApO1xuICAgICAgICAgICAgICAgICAgICBmcm9tID0gX291dCAtIGRpc3Q7ICAgICAgLyogcmVzdCBmcm9tIG91dHB1dCAqL1xuICAgICAgICAgICAgICAgICAgICBmcm9tX3NvdXJjZSA9IG91dHB1dDtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgZWxzZSB7ICAgICAgICAgICAgICAgICAgICAgIC8qIGNvbnRpZ3VvdXMgaW4gd2luZG93ICovXG4gICAgICAgICAgICAgICAgZnJvbSArPSB3bmV4dCAtIG9wO1xuICAgICAgICAgICAgICAgIGlmIChvcCA8IGxlbikgeyAgICAgICAgIC8qIHNvbWUgZnJvbSB3aW5kb3cgKi9cbiAgICAgICAgICAgICAgICAgIGxlbiAtPSBvcDtcbiAgICAgICAgICAgICAgICAgIGRvIHtcbiAgICAgICAgICAgICAgICAgICAgb3V0cHV0W19vdXQrK10gPSBzX3dpbmRvd1tmcm9tKytdO1xuICAgICAgICAgICAgICAgICAgfSB3aGlsZSAoLS1vcCk7XG4gICAgICAgICAgICAgICAgICBmcm9tID0gX291dCAtIGRpc3Q7ICAvKiByZXN0IGZyb20gb3V0cHV0ICovXG4gICAgICAgICAgICAgICAgICBmcm9tX3NvdXJjZSA9IG91dHB1dDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgd2hpbGUgKGxlbiA+IDIpIHtcbiAgICAgICAgICAgICAgICBvdXRwdXRbX291dCsrXSA9IGZyb21fc291cmNlW2Zyb20rK107XG4gICAgICAgICAgICAgICAgb3V0cHV0W19vdXQrK10gPSBmcm9tX3NvdXJjZVtmcm9tKytdO1xuICAgICAgICAgICAgICAgIG91dHB1dFtfb3V0KytdID0gZnJvbV9zb3VyY2VbZnJvbSsrXTtcbiAgICAgICAgICAgICAgICBsZW4gLT0gMztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpZiAobGVuKSB7XG4gICAgICAgICAgICAgICAgb3V0cHV0W19vdXQrK10gPSBmcm9tX3NvdXJjZVtmcm9tKytdO1xuICAgICAgICAgICAgICAgIGlmIChsZW4gPiAxKSB7XG4gICAgICAgICAgICAgICAgICBvdXRwdXRbX291dCsrXSA9IGZyb21fc291cmNlW2Zyb20rK107XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgZnJvbSA9IF9vdXQgLSBkaXN0OyAgICAgICAgICAvKiBjb3B5IGRpcmVjdCBmcm9tIG91dHB1dCAqL1xuICAgICAgICAgICAgICBkbyB7ICAgICAgICAgICAgICAgICAgICAgICAgLyogbWluaW11bSBsZW5ndGggaXMgdGhyZWUgKi9cbiAgICAgICAgICAgICAgICBvdXRwdXRbX291dCsrXSA9IG91dHB1dFtmcm9tKytdO1xuICAgICAgICAgICAgICAgIG91dHB1dFtfb3V0KytdID0gb3V0cHV0W2Zyb20rK107XG4gICAgICAgICAgICAgICAgb3V0cHV0W19vdXQrK10gPSBvdXRwdXRbZnJvbSsrXTtcbiAgICAgICAgICAgICAgICBsZW4gLT0gMztcbiAgICAgICAgICAgICAgfSB3aGlsZSAobGVuID4gMik7XG4gICAgICAgICAgICAgIGlmIChsZW4pIHtcbiAgICAgICAgICAgICAgICBvdXRwdXRbX291dCsrXSA9IG91dHB1dFtmcm9tKytdO1xuICAgICAgICAgICAgICAgIGlmIChsZW4gPiAxKSB7XG4gICAgICAgICAgICAgICAgICBvdXRwdXRbX291dCsrXSA9IG91dHB1dFtmcm9tKytdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBlbHNlIGlmICgob3AgJiA2NCkgPT09IDApIHsgICAgICAgICAgLyogMm5kIGxldmVsIGRpc3RhbmNlIGNvZGUgKi9cbiAgICAgICAgICAgIGhlcmUgPSBkY29kZVsoaGVyZSAmIDB4ZmZmZikvKmhlcmUudmFsKi8gKyAoaG9sZCAmICgoMSA8PCBvcCkgLSAxKSldO1xuICAgICAgICAgICAgY29udGludWUgZG9kaXN0O1xuICAgICAgICAgIH1cbiAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHN0cm0ubXNnID0gJ2ludmFsaWQgZGlzdGFuY2UgY29kZSc7XG4gICAgICAgICAgICBzdGF0ZS5tb2RlID0gQkFEO1xuICAgICAgICAgICAgYnJlYWsgdG9wO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGJyZWFrOyAvLyBuZWVkIHRvIGVtdWxhdGUgZ290byB2aWEgXCJjb250aW51ZVwiXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGVsc2UgaWYgKChvcCAmIDY0KSA9PT0gMCkgeyAgICAgICAgICAgICAgLyogMm5kIGxldmVsIGxlbmd0aCBjb2RlICovXG4gICAgICAgIGhlcmUgPSBsY29kZVsoaGVyZSAmIDB4ZmZmZikvKmhlcmUudmFsKi8gKyAoaG9sZCAmICgoMSA8PCBvcCkgLSAxKSldO1xuICAgICAgICBjb250aW51ZSBkb2xlbjtcbiAgICAgIH1cbiAgICAgIGVsc2UgaWYgKG9wICYgMzIpIHsgICAgICAgICAgICAgICAgICAgICAvKiBlbmQtb2YtYmxvY2sgKi9cbiAgICAgICAgLy9UcmFjZXZ2KChzdGRlcnIsIFwiaW5mbGF0ZTogICAgICAgICBlbmQgb2YgYmxvY2tcXG5cIikpO1xuICAgICAgICBzdGF0ZS5tb2RlID0gVFlQRTtcbiAgICAgICAgYnJlYWsgdG9wO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIHN0cm0ubXNnID0gJ2ludmFsaWQgbGl0ZXJhbC9sZW5ndGggY29kZSc7XG4gICAgICAgIHN0YXRlLm1vZGUgPSBCQUQ7XG4gICAgICAgIGJyZWFrIHRvcDtcbiAgICAgIH1cblxuICAgICAgYnJlYWs7IC8vIG5lZWQgdG8gZW11bGF0ZSBnb3RvIHZpYSBcImNvbnRpbnVlXCJcbiAgICB9XG4gIH0gd2hpbGUgKF9pbiA8IGxhc3QgJiYgX291dCA8IGVuZCk7XG5cbiAgLyogcmV0dXJuIHVudXNlZCBieXRlcyAob24gZW50cnksIGJpdHMgPCA4LCBzbyBpbiB3b24ndCBnbyB0b28gZmFyIGJhY2spICovXG4gIGxlbiA9IGJpdHMgPj4gMztcbiAgX2luIC09IGxlbjtcbiAgYml0cyAtPSBsZW4gPDwgMztcbiAgaG9sZCAmPSAoMSA8PCBiaXRzKSAtIDE7XG5cbiAgLyogdXBkYXRlIHN0YXRlIGFuZCByZXR1cm4gKi9cbiAgc3RybS5uZXh0X2luID0gX2luO1xuICBzdHJtLm5leHRfb3V0ID0gX291dDtcbiAgc3RybS5hdmFpbF9pbiA9IChfaW4gPCBsYXN0ID8gNSArIChsYXN0IC0gX2luKSA6IDUgLSAoX2luIC0gbGFzdCkpO1xuICBzdHJtLmF2YWlsX291dCA9IChfb3V0IDwgZW5kID8gMjU3ICsgKGVuZCAtIF9vdXQpIDogMjU3IC0gKF9vdXQgLSBlbmQpKTtcbiAgc3RhdGUuaG9sZCA9IGhvbGQ7XG4gIHN0YXRlLmJpdHMgPSBiaXRzO1xuICByZXR1cm47XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5cbnZhciB1dGlscyA9IHJlcXVpcmUoJy4uL3V0aWxzL2NvbW1vbicpO1xudmFyIGFkbGVyMzIgPSByZXF1aXJlKCcuL2FkbGVyMzInKTtcbnZhciBjcmMzMiAgID0gcmVxdWlyZSgnLi9jcmMzMicpO1xudmFyIGluZmxhdGVfZmFzdCA9IHJlcXVpcmUoJy4vaW5mZmFzdCcpO1xudmFyIGluZmxhdGVfdGFibGUgPSByZXF1aXJlKCcuL2luZnRyZWVzJyk7XG5cbnZhciBDT0RFUyA9IDA7XG52YXIgTEVOUyA9IDE7XG52YXIgRElTVFMgPSAyO1xuXG4vKiBQdWJsaWMgY29uc3RhbnRzID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0qL1xuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09Ki9cblxuXG4vKiBBbGxvd2VkIGZsdXNoIHZhbHVlczsgc2VlIGRlZmxhdGUoKSBhbmQgaW5mbGF0ZSgpIGJlbG93IGZvciBkZXRhaWxzICovXG4vL3ZhciBaX05PX0ZMVVNIICAgICAgPSAwO1xuLy92YXIgWl9QQVJUSUFMX0ZMVVNIID0gMTtcbi8vdmFyIFpfU1lOQ19GTFVTSCAgICA9IDI7XG4vL3ZhciBaX0ZVTExfRkxVU0ggICAgPSAzO1xudmFyIFpfRklOSVNIICAgICAgICA9IDQ7XG52YXIgWl9CTE9DSyAgICAgICAgID0gNTtcbnZhciBaX1RSRUVTICAgICAgICAgPSA2O1xuXG5cbi8qIFJldHVybiBjb2RlcyBmb3IgdGhlIGNvbXByZXNzaW9uL2RlY29tcHJlc3Npb24gZnVuY3Rpb25zLiBOZWdhdGl2ZSB2YWx1ZXNcbiAqIGFyZSBlcnJvcnMsIHBvc2l0aXZlIHZhbHVlcyBhcmUgdXNlZCBmb3Igc3BlY2lhbCBidXQgbm9ybWFsIGV2ZW50cy5cbiAqL1xudmFyIFpfT0sgICAgICAgICAgICA9IDA7XG52YXIgWl9TVFJFQU1fRU5EICAgID0gMTtcbnZhciBaX05FRURfRElDVCAgICAgPSAyO1xuLy92YXIgWl9FUlJOTyAgICAgICAgID0gLTE7XG52YXIgWl9TVFJFQU1fRVJST1IgID0gLTI7XG52YXIgWl9EQVRBX0VSUk9SICAgID0gLTM7XG52YXIgWl9NRU1fRVJST1IgICAgID0gLTQ7XG52YXIgWl9CVUZfRVJST1IgICAgID0gLTU7XG4vL3ZhciBaX1ZFUlNJT05fRVJST1IgPSAtNjtcblxuLyogVGhlIGRlZmxhdGUgY29tcHJlc3Npb24gbWV0aG9kICovXG52YXIgWl9ERUZMQVRFRCAgPSA4O1xuXG5cbi8qIFNUQVRFUyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PSovXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0qL1xuXG5cbnZhciAgICBIRUFEID0gMTsgICAgICAgLyogaTogd2FpdGluZyBmb3IgbWFnaWMgaGVhZGVyICovXG52YXIgICAgRkxBR1MgPSAyOyAgICAgIC8qIGk6IHdhaXRpbmcgZm9yIG1ldGhvZCBhbmQgZmxhZ3MgKGd6aXApICovXG52YXIgICAgVElNRSA9IDM7ICAgICAgIC8qIGk6IHdhaXRpbmcgZm9yIG1vZGlmaWNhdGlvbiB0aW1lIChnemlwKSAqL1xudmFyICAgIE9TID0gNDsgICAgICAgICAvKiBpOiB3YWl0aW5nIGZvciBleHRyYSBmbGFncyBhbmQgb3BlcmF0aW5nIHN5c3RlbSAoZ3ppcCkgKi9cbnZhciAgICBFWExFTiA9IDU7ICAgICAgLyogaTogd2FpdGluZyBmb3IgZXh0cmEgbGVuZ3RoIChnemlwKSAqL1xudmFyICAgIEVYVFJBID0gNjsgICAgICAvKiBpOiB3YWl0aW5nIGZvciBleHRyYSBieXRlcyAoZ3ppcCkgKi9cbnZhciAgICBOQU1FID0gNzsgICAgICAgLyogaTogd2FpdGluZyBmb3IgZW5kIG9mIGZpbGUgbmFtZSAoZ3ppcCkgKi9cbnZhciAgICBDT01NRU5UID0gODsgICAgLyogaTogd2FpdGluZyBmb3IgZW5kIG9mIGNvbW1lbnQgKGd6aXApICovXG52YXIgICAgSENSQyA9IDk7ICAgICAgIC8qIGk6IHdhaXRpbmcgZm9yIGhlYWRlciBjcmMgKGd6aXApICovXG52YXIgICAgRElDVElEID0gMTA7ICAgIC8qIGk6IHdhaXRpbmcgZm9yIGRpY3Rpb25hcnkgY2hlY2sgdmFsdWUgKi9cbnZhciAgICBESUNUID0gMTE7ICAgICAgLyogd2FpdGluZyBmb3IgaW5mbGF0ZVNldERpY3Rpb25hcnkoKSBjYWxsICovXG52YXIgICAgICAgIFRZUEUgPSAxMjsgICAgICAvKiBpOiB3YWl0aW5nIGZvciB0eXBlIGJpdHMsIGluY2x1ZGluZyBsYXN0LWZsYWcgYml0ICovXG52YXIgICAgICAgIFRZUEVETyA9IDEzOyAgICAvKiBpOiBzYW1lLCBidXQgc2tpcCBjaGVjayB0byBleGl0IGluZmxhdGUgb24gbmV3IGJsb2NrICovXG52YXIgICAgICAgIFNUT1JFRCA9IDE0OyAgICAvKiBpOiB3YWl0aW5nIGZvciBzdG9yZWQgc2l6ZSAobGVuZ3RoIGFuZCBjb21wbGVtZW50KSAqL1xudmFyICAgICAgICBDT1BZXyA9IDE1OyAgICAgLyogaS9vOiBzYW1lIGFzIENPUFkgYmVsb3csIGJ1dCBvbmx5IGZpcnN0IHRpbWUgaW4gKi9cbnZhciAgICAgICAgQ09QWSA9IDE2OyAgICAgIC8qIGkvbzogd2FpdGluZyBmb3IgaW5wdXQgb3Igb3V0cHV0IHRvIGNvcHkgc3RvcmVkIGJsb2NrICovXG52YXIgICAgICAgIFRBQkxFID0gMTc7ICAgICAvKiBpOiB3YWl0aW5nIGZvciBkeW5hbWljIGJsb2NrIHRhYmxlIGxlbmd0aHMgKi9cbnZhciAgICAgICAgTEVOTEVOUyA9IDE4OyAgIC8qIGk6IHdhaXRpbmcgZm9yIGNvZGUgbGVuZ3RoIGNvZGUgbGVuZ3RocyAqL1xudmFyICAgICAgICBDT0RFTEVOUyA9IDE5OyAgLyogaTogd2FpdGluZyBmb3IgbGVuZ3RoL2xpdCBhbmQgZGlzdGFuY2UgY29kZSBsZW5ndGhzICovXG52YXIgICAgICAgICAgICBMRU5fID0gMjA7ICAgICAgLyogaTogc2FtZSBhcyBMRU4gYmVsb3csIGJ1dCBvbmx5IGZpcnN0IHRpbWUgaW4gKi9cbnZhciAgICAgICAgICAgIExFTiA9IDIxOyAgICAgICAvKiBpOiB3YWl0aW5nIGZvciBsZW5ndGgvbGl0L2VvYiBjb2RlICovXG52YXIgICAgICAgICAgICBMRU5FWFQgPSAyMjsgICAgLyogaTogd2FpdGluZyBmb3IgbGVuZ3RoIGV4dHJhIGJpdHMgKi9cbnZhciAgICAgICAgICAgIERJU1QgPSAyMzsgICAgICAvKiBpOiB3YWl0aW5nIGZvciBkaXN0YW5jZSBjb2RlICovXG52YXIgICAgICAgICAgICBESVNURVhUID0gMjQ7ICAgLyogaTogd2FpdGluZyBmb3IgZGlzdGFuY2UgZXh0cmEgYml0cyAqL1xudmFyICAgICAgICAgICAgTUFUQ0ggPSAyNTsgICAgIC8qIG86IHdhaXRpbmcgZm9yIG91dHB1dCBzcGFjZSB0byBjb3B5IHN0cmluZyAqL1xudmFyICAgICAgICAgICAgTElUID0gMjY7ICAgICAgIC8qIG86IHdhaXRpbmcgZm9yIG91dHB1dCBzcGFjZSB0byB3cml0ZSBsaXRlcmFsICovXG52YXIgICAgQ0hFQ0sgPSAyNzsgICAgIC8qIGk6IHdhaXRpbmcgZm9yIDMyLWJpdCBjaGVjayB2YWx1ZSAqL1xudmFyICAgIExFTkdUSCA9IDI4OyAgICAvKiBpOiB3YWl0aW5nIGZvciAzMi1iaXQgbGVuZ3RoIChnemlwKSAqL1xudmFyICAgIERPTkUgPSAyOTsgICAgICAvKiBmaW5pc2hlZCBjaGVjaywgZG9uZSAtLSByZW1haW4gaGVyZSB1bnRpbCByZXNldCAqL1xudmFyICAgIEJBRCA9IDMwOyAgICAgICAvKiBnb3QgYSBkYXRhIGVycm9yIC0tIHJlbWFpbiBoZXJlIHVudGlsIHJlc2V0ICovXG52YXIgICAgTUVNID0gMzE7ICAgICAgIC8qIGdvdCBhbiBpbmZsYXRlKCkgbWVtb3J5IGVycm9yIC0tIHJlbWFpbiBoZXJlIHVudGlsIHJlc2V0ICovXG52YXIgICAgU1lOQyA9IDMyOyAgICAgIC8qIGxvb2tpbmcgZm9yIHN5bmNocm9uaXphdGlvbiBieXRlcyB0byByZXN0YXJ0IGluZmxhdGUoKSAqL1xuXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0qL1xuXG5cblxudmFyIEVOT1VHSF9MRU5TID0gODUyO1xudmFyIEVOT1VHSF9ESVNUUyA9IDU5Mjtcbi8vdmFyIEVOT1VHSCA9ICAoRU5PVUdIX0xFTlMrRU5PVUdIX0RJU1RTKTtcblxudmFyIE1BWF9XQklUUyA9IDE1O1xuLyogMzJLIExaNzcgd2luZG93ICovXG52YXIgREVGX1dCSVRTID0gTUFYX1dCSVRTO1xuXG5cbmZ1bmN0aW9uIFpTV0FQMzIocSkge1xuICByZXR1cm4gICgoKHEgPj4+IDI0KSAmIDB4ZmYpICtcbiAgICAgICAgICAoKHEgPj4+IDgpICYgMHhmZjAwKSArXG4gICAgICAgICAgKChxICYgMHhmZjAwKSA8PCA4KSArXG4gICAgICAgICAgKChxICYgMHhmZikgPDwgMjQpKTtcbn1cblxuXG5mdW5jdGlvbiBJbmZsYXRlU3RhdGUoKSB7XG4gIHRoaXMubW9kZSA9IDA7ICAgICAgICAgICAgIC8qIGN1cnJlbnQgaW5mbGF0ZSBtb2RlICovXG4gIHRoaXMubGFzdCA9IGZhbHNlOyAgICAgICAgICAvKiB0cnVlIGlmIHByb2Nlc3NpbmcgbGFzdCBibG9jayAqL1xuICB0aGlzLndyYXAgPSAwOyAgICAgICAgICAgICAgLyogYml0IDAgdHJ1ZSBmb3IgemxpYiwgYml0IDEgdHJ1ZSBmb3IgZ3ppcCAqL1xuICB0aGlzLmhhdmVkaWN0ID0gZmFsc2U7ICAgICAgLyogdHJ1ZSBpZiBkaWN0aW9uYXJ5IHByb3ZpZGVkICovXG4gIHRoaXMuZmxhZ3MgPSAwOyAgICAgICAgICAgICAvKiBnemlwIGhlYWRlciBtZXRob2QgYW5kIGZsYWdzICgwIGlmIHpsaWIpICovXG4gIHRoaXMuZG1heCA9IDA7ICAgICAgICAgICAgICAvKiB6bGliIGhlYWRlciBtYXggZGlzdGFuY2UgKElORkxBVEVfU1RSSUNUKSAqL1xuICB0aGlzLmNoZWNrID0gMDsgICAgICAgICAgICAgLyogcHJvdGVjdGVkIGNvcHkgb2YgY2hlY2sgdmFsdWUgKi9cbiAgdGhpcy50b3RhbCA9IDA7ICAgICAgICAgICAgIC8qIHByb3RlY3RlZCBjb3B5IG9mIG91dHB1dCBjb3VudCAqL1xuICAvLyBUT0RPOiBtYXkgYmUge31cbiAgdGhpcy5oZWFkID0gbnVsbDsgICAgICAgICAgIC8qIHdoZXJlIHRvIHNhdmUgZ3ppcCBoZWFkZXIgaW5mb3JtYXRpb24gKi9cblxuICAvKiBzbGlkaW5nIHdpbmRvdyAqL1xuICB0aGlzLndiaXRzID0gMDsgICAgICAgICAgICAgLyogbG9nIGJhc2UgMiBvZiByZXF1ZXN0ZWQgd2luZG93IHNpemUgKi9cbiAgdGhpcy53c2l6ZSA9IDA7ICAgICAgICAgICAgIC8qIHdpbmRvdyBzaXplIG9yIHplcm8gaWYgbm90IHVzaW5nIHdpbmRvdyAqL1xuICB0aGlzLndoYXZlID0gMDsgICAgICAgICAgICAgLyogdmFsaWQgYnl0ZXMgaW4gdGhlIHdpbmRvdyAqL1xuICB0aGlzLnduZXh0ID0gMDsgICAgICAgICAgICAgLyogd2luZG93IHdyaXRlIGluZGV4ICovXG4gIHRoaXMud2luZG93ID0gbnVsbDsgICAgICAgICAvKiBhbGxvY2F0ZWQgc2xpZGluZyB3aW5kb3csIGlmIG5lZWRlZCAqL1xuXG4gIC8qIGJpdCBhY2N1bXVsYXRvciAqL1xuICB0aGlzLmhvbGQgPSAwOyAgICAgICAgICAgICAgLyogaW5wdXQgYml0IGFjY3VtdWxhdG9yICovXG4gIHRoaXMuYml0cyA9IDA7ICAgICAgICAgICAgICAvKiBudW1iZXIgb2YgYml0cyBpbiBcImluXCIgKi9cblxuICAvKiBmb3Igc3RyaW5nIGFuZCBzdG9yZWQgYmxvY2sgY29weWluZyAqL1xuICB0aGlzLmxlbmd0aCA9IDA7ICAgICAgICAgICAgLyogbGl0ZXJhbCBvciBsZW5ndGggb2YgZGF0YSB0byBjb3B5ICovXG4gIHRoaXMub2Zmc2V0ID0gMDsgICAgICAgICAgICAvKiBkaXN0YW5jZSBiYWNrIHRvIGNvcHkgc3RyaW5nIGZyb20gKi9cblxuICAvKiBmb3IgdGFibGUgYW5kIGNvZGUgZGVjb2RpbmcgKi9cbiAgdGhpcy5leHRyYSA9IDA7ICAgICAgICAgICAgIC8qIGV4dHJhIGJpdHMgbmVlZGVkICovXG5cbiAgLyogZml4ZWQgYW5kIGR5bmFtaWMgY29kZSB0YWJsZXMgKi9cbiAgdGhpcy5sZW5jb2RlID0gbnVsbDsgICAgICAgICAgLyogc3RhcnRpbmcgdGFibGUgZm9yIGxlbmd0aC9saXRlcmFsIGNvZGVzICovXG4gIHRoaXMuZGlzdGNvZGUgPSBudWxsOyAgICAgICAgIC8qIHN0YXJ0aW5nIHRhYmxlIGZvciBkaXN0YW5jZSBjb2RlcyAqL1xuICB0aGlzLmxlbmJpdHMgPSAwOyAgICAgICAgICAgLyogaW5kZXggYml0cyBmb3IgbGVuY29kZSAqL1xuICB0aGlzLmRpc3RiaXRzID0gMDsgICAgICAgICAgLyogaW5kZXggYml0cyBmb3IgZGlzdGNvZGUgKi9cblxuICAvKiBkeW5hbWljIHRhYmxlIGJ1aWxkaW5nICovXG4gIHRoaXMubmNvZGUgPSAwOyAgICAgICAgICAgICAvKiBudW1iZXIgb2YgY29kZSBsZW5ndGggY29kZSBsZW5ndGhzICovXG4gIHRoaXMubmxlbiA9IDA7ICAgICAgICAgICAgICAvKiBudW1iZXIgb2YgbGVuZ3RoIGNvZGUgbGVuZ3RocyAqL1xuICB0aGlzLm5kaXN0ID0gMDsgICAgICAgICAgICAgLyogbnVtYmVyIG9mIGRpc3RhbmNlIGNvZGUgbGVuZ3RocyAqL1xuICB0aGlzLmhhdmUgPSAwOyAgICAgICAgICAgICAgLyogbnVtYmVyIG9mIGNvZGUgbGVuZ3RocyBpbiBsZW5zW10gKi9cbiAgdGhpcy5uZXh0ID0gbnVsbDsgICAgICAgICAgICAgIC8qIG5leHQgYXZhaWxhYmxlIHNwYWNlIGluIGNvZGVzW10gKi9cblxuICB0aGlzLmxlbnMgPSBuZXcgdXRpbHMuQnVmMTYoMzIwKTsgLyogdGVtcG9yYXJ5IHN0b3JhZ2UgZm9yIGNvZGUgbGVuZ3RocyAqL1xuICB0aGlzLndvcmsgPSBuZXcgdXRpbHMuQnVmMTYoMjg4KTsgLyogd29yayBhcmVhIGZvciBjb2RlIHRhYmxlIGJ1aWxkaW5nICovXG5cbiAgLypcbiAgIGJlY2F1c2Ugd2UgZG9uJ3QgaGF2ZSBwb2ludGVycyBpbiBqcywgd2UgdXNlIGxlbmNvZGUgYW5kIGRpc3Rjb2RlIGRpcmVjdGx5XG4gICBhcyBidWZmZXJzIHNvIHdlIGRvbid0IG5lZWQgY29kZXNcbiAgKi9cbiAgLy90aGlzLmNvZGVzID0gbmV3IHV0aWxzLkJ1ZjMyKEVOT1VHSCk7ICAgICAgIC8qIHNwYWNlIGZvciBjb2RlIHRhYmxlcyAqL1xuICB0aGlzLmxlbmR5biA9IG51bGw7ICAgICAgICAgICAgICAvKiBkeW5hbWljIHRhYmxlIGZvciBsZW5ndGgvbGl0ZXJhbCBjb2RlcyAoSlMgc3BlY2lmaWMpICovXG4gIHRoaXMuZGlzdGR5biA9IG51bGw7ICAgICAgICAgICAgIC8qIGR5bmFtaWMgdGFibGUgZm9yIGRpc3RhbmNlIGNvZGVzIChKUyBzcGVjaWZpYykgKi9cbiAgdGhpcy5zYW5lID0gMDsgICAgICAgICAgICAgICAgICAgLyogaWYgZmFsc2UsIGFsbG93IGludmFsaWQgZGlzdGFuY2UgdG9vIGZhciAqL1xuICB0aGlzLmJhY2sgPSAwOyAgICAgICAgICAgICAgICAgICAvKiBiaXRzIGJhY2sgb2YgbGFzdCB1bnByb2Nlc3NlZCBsZW5ndGgvbGl0ICovXG4gIHRoaXMud2FzID0gMDsgICAgICAgICAgICAgICAgICAgIC8qIGluaXRpYWwgbGVuZ3RoIG9mIG1hdGNoICovXG59XG5cbmZ1bmN0aW9uIGluZmxhdGVSZXNldEtlZXAoc3RybSkge1xuICB2YXIgc3RhdGU7XG5cbiAgaWYgKCFzdHJtIHx8ICFzdHJtLnN0YXRlKSB7IHJldHVybiBaX1NUUkVBTV9FUlJPUjsgfVxuICBzdGF0ZSA9IHN0cm0uc3RhdGU7XG4gIHN0cm0udG90YWxfaW4gPSBzdHJtLnRvdGFsX291dCA9IHN0YXRlLnRvdGFsID0gMDtcbiAgc3RybS5tc2cgPSAnJzsgLypaX05VTEwqL1xuICBpZiAoc3RhdGUud3JhcCkgeyAgICAgICAvKiB0byBzdXBwb3J0IGlsbC1jb25jZWl2ZWQgSmF2YSB0ZXN0IHN1aXRlICovXG4gICAgc3RybS5hZGxlciA9IHN0YXRlLndyYXAgJiAxO1xuICB9XG4gIHN0YXRlLm1vZGUgPSBIRUFEO1xuICBzdGF0ZS5sYXN0ID0gMDtcbiAgc3RhdGUuaGF2ZWRpY3QgPSAwO1xuICBzdGF0ZS5kbWF4ID0gMzI3Njg7XG4gIHN0YXRlLmhlYWQgPSBudWxsLypaX05VTEwqLztcbiAgc3RhdGUuaG9sZCA9IDA7XG4gIHN0YXRlLmJpdHMgPSAwO1xuICAvL3N0YXRlLmxlbmNvZGUgPSBzdGF0ZS5kaXN0Y29kZSA9IHN0YXRlLm5leHQgPSBzdGF0ZS5jb2RlcztcbiAgc3RhdGUubGVuY29kZSA9IHN0YXRlLmxlbmR5biA9IG5ldyB1dGlscy5CdWYzMihFTk9VR0hfTEVOUyk7XG4gIHN0YXRlLmRpc3Rjb2RlID0gc3RhdGUuZGlzdGR5biA9IG5ldyB1dGlscy5CdWYzMihFTk9VR0hfRElTVFMpO1xuXG4gIHN0YXRlLnNhbmUgPSAxO1xuICBzdGF0ZS5iYWNrID0gLTE7XG4gIC8vVHJhY2V2KChzdGRlcnIsIFwiaW5mbGF0ZTogcmVzZXRcXG5cIikpO1xuICByZXR1cm4gWl9PSztcbn1cblxuZnVuY3Rpb24gaW5mbGF0ZVJlc2V0KHN0cm0pIHtcbiAgdmFyIHN0YXRlO1xuXG4gIGlmICghc3RybSB8fCAhc3RybS5zdGF0ZSkgeyByZXR1cm4gWl9TVFJFQU1fRVJST1I7IH1cbiAgc3RhdGUgPSBzdHJtLnN0YXRlO1xuICBzdGF0ZS53c2l6ZSA9IDA7XG4gIHN0YXRlLndoYXZlID0gMDtcbiAgc3RhdGUud25leHQgPSAwO1xuICByZXR1cm4gaW5mbGF0ZVJlc2V0S2VlcChzdHJtKTtcblxufVxuXG5mdW5jdGlvbiBpbmZsYXRlUmVzZXQyKHN0cm0sIHdpbmRvd0JpdHMpIHtcbiAgdmFyIHdyYXA7XG4gIHZhciBzdGF0ZTtcblxuICAvKiBnZXQgdGhlIHN0YXRlICovXG4gIGlmICghc3RybSB8fCAhc3RybS5zdGF0ZSkgeyByZXR1cm4gWl9TVFJFQU1fRVJST1I7IH1cbiAgc3RhdGUgPSBzdHJtLnN0YXRlO1xuXG4gIC8qIGV4dHJhY3Qgd3JhcCByZXF1ZXN0IGZyb20gd2luZG93Qml0cyBwYXJhbWV0ZXIgKi9cbiAgaWYgKHdpbmRvd0JpdHMgPCAwKSB7XG4gICAgd3JhcCA9IDA7XG4gICAgd2luZG93Qml0cyA9IC13aW5kb3dCaXRzO1xuICB9XG4gIGVsc2Uge1xuICAgIHdyYXAgPSAod2luZG93Qml0cyA+PiA0KSArIDE7XG4gICAgaWYgKHdpbmRvd0JpdHMgPCA0OCkge1xuICAgICAgd2luZG93Qml0cyAmPSAxNTtcbiAgICB9XG4gIH1cblxuICAvKiBzZXQgbnVtYmVyIG9mIHdpbmRvdyBiaXRzLCBmcmVlIHdpbmRvdyBpZiBkaWZmZXJlbnQgKi9cbiAgaWYgKHdpbmRvd0JpdHMgJiYgKHdpbmRvd0JpdHMgPCA4IHx8IHdpbmRvd0JpdHMgPiAxNSkpIHtcbiAgICByZXR1cm4gWl9TVFJFQU1fRVJST1I7XG4gIH1cbiAgaWYgKHN0YXRlLndpbmRvdyAhPT0gbnVsbCAmJiBzdGF0ZS53Yml0cyAhPT0gd2luZG93Qml0cykge1xuICAgIHN0YXRlLndpbmRvdyA9IG51bGw7XG4gIH1cblxuICAvKiB1cGRhdGUgc3RhdGUgYW5kIHJlc2V0IHRoZSByZXN0IG9mIGl0ICovXG4gIHN0YXRlLndyYXAgPSB3cmFwO1xuICBzdGF0ZS53Yml0cyA9IHdpbmRvd0JpdHM7XG4gIHJldHVybiBpbmZsYXRlUmVzZXQoc3RybSk7XG59XG5cbmZ1bmN0aW9uIGluZmxhdGVJbml0MihzdHJtLCB3aW5kb3dCaXRzKSB7XG4gIHZhciByZXQ7XG4gIHZhciBzdGF0ZTtcblxuICBpZiAoIXN0cm0pIHsgcmV0dXJuIFpfU1RSRUFNX0VSUk9SOyB9XG4gIC8vc3RybS5tc2cgPSBaX05VTEw7ICAgICAgICAgICAgICAgICAvKiBpbiBjYXNlIHdlIHJldHVybiBhbiBlcnJvciAqL1xuXG4gIHN0YXRlID0gbmV3IEluZmxhdGVTdGF0ZSgpO1xuXG4gIC8vaWYgKHN0YXRlID09PSBaX05VTEwpIHJldHVybiBaX01FTV9FUlJPUjtcbiAgLy9UcmFjZXYoKHN0ZGVyciwgXCJpbmZsYXRlOiBhbGxvY2F0ZWRcXG5cIikpO1xuICBzdHJtLnN0YXRlID0gc3RhdGU7XG4gIHN0YXRlLndpbmRvdyA9IG51bGwvKlpfTlVMTCovO1xuICByZXQgPSBpbmZsYXRlUmVzZXQyKHN0cm0sIHdpbmRvd0JpdHMpO1xuICBpZiAocmV0ICE9PSBaX09LKSB7XG4gICAgc3RybS5zdGF0ZSA9IG51bGwvKlpfTlVMTCovO1xuICB9XG4gIHJldHVybiByZXQ7XG59XG5cbmZ1bmN0aW9uIGluZmxhdGVJbml0KHN0cm0pIHtcbiAgcmV0dXJuIGluZmxhdGVJbml0MihzdHJtLCBERUZfV0JJVFMpO1xufVxuXG5cbi8qXG4gUmV0dXJuIHN0YXRlIHdpdGggbGVuZ3RoIGFuZCBkaXN0YW5jZSBkZWNvZGluZyB0YWJsZXMgYW5kIGluZGV4IHNpemVzIHNldCB0b1xuIGZpeGVkIGNvZGUgZGVjb2RpbmcuICBOb3JtYWxseSB0aGlzIHJldHVybnMgZml4ZWQgdGFibGVzIGZyb20gaW5mZml4ZWQuaC5cbiBJZiBCVUlMREZJWEVEIGlzIGRlZmluZWQsIHRoZW4gaW5zdGVhZCB0aGlzIHJvdXRpbmUgYnVpbGRzIHRoZSB0YWJsZXMgdGhlXG4gZmlyc3QgdGltZSBpdCdzIGNhbGxlZCwgYW5kIHJldHVybnMgdGhvc2UgdGFibGVzIHRoZSBmaXJzdCB0aW1lIGFuZFxuIHRoZXJlYWZ0ZXIuICBUaGlzIHJlZHVjZXMgdGhlIHNpemUgb2YgdGhlIGNvZGUgYnkgYWJvdXQgMksgYnl0ZXMsIGluXG4gZXhjaGFuZ2UgZm9yIGEgbGl0dGxlIGV4ZWN1dGlvbiB0aW1lLiAgSG93ZXZlciwgQlVJTERGSVhFRCBzaG91bGQgbm90IGJlXG4gdXNlZCBmb3IgdGhyZWFkZWQgYXBwbGljYXRpb25zLCBzaW5jZSB0aGUgcmV3cml0aW5nIG9mIHRoZSB0YWJsZXMgYW5kIHZpcmdpblxuIG1heSBub3QgYmUgdGhyZWFkLXNhZmUuXG4gKi9cbnZhciB2aXJnaW4gPSB0cnVlO1xuXG52YXIgbGVuZml4LCBkaXN0Zml4OyAvLyBXZSBoYXZlIG5vIHBvaW50ZXJzIGluIEpTLCBzbyBrZWVwIHRhYmxlcyBzZXBhcmF0ZVxuXG5mdW5jdGlvbiBmaXhlZHRhYmxlcyhzdGF0ZSkge1xuICAvKiBidWlsZCBmaXhlZCBodWZmbWFuIHRhYmxlcyBpZiBmaXJzdCBjYWxsIChtYXkgbm90IGJlIHRocmVhZCBzYWZlKSAqL1xuICBpZiAodmlyZ2luKSB7XG4gICAgdmFyIHN5bTtcblxuICAgIGxlbmZpeCA9IG5ldyB1dGlscy5CdWYzMig1MTIpO1xuICAgIGRpc3RmaXggPSBuZXcgdXRpbHMuQnVmMzIoMzIpO1xuXG4gICAgLyogbGl0ZXJhbC9sZW5ndGggdGFibGUgKi9cbiAgICBzeW0gPSAwO1xuICAgIHdoaWxlIChzeW0gPCAxNDQpIHsgc3RhdGUubGVuc1tzeW0rK10gPSA4OyB9XG4gICAgd2hpbGUgKHN5bSA8IDI1NikgeyBzdGF0ZS5sZW5zW3N5bSsrXSA9IDk7IH1cbiAgICB3aGlsZSAoc3ltIDwgMjgwKSB7IHN0YXRlLmxlbnNbc3ltKytdID0gNzsgfVxuICAgIHdoaWxlIChzeW0gPCAyODgpIHsgc3RhdGUubGVuc1tzeW0rK10gPSA4OyB9XG5cbiAgICBpbmZsYXRlX3RhYmxlKExFTlMsICBzdGF0ZS5sZW5zLCAwLCAyODgsIGxlbmZpeCwgICAwLCBzdGF0ZS53b3JrLCB7Yml0czogOX0pO1xuXG4gICAgLyogZGlzdGFuY2UgdGFibGUgKi9cbiAgICBzeW0gPSAwO1xuICAgIHdoaWxlIChzeW0gPCAzMikgeyBzdGF0ZS5sZW5zW3N5bSsrXSA9IDU7IH1cblxuICAgIGluZmxhdGVfdGFibGUoRElTVFMsIHN0YXRlLmxlbnMsIDAsIDMyLCAgIGRpc3RmaXgsIDAsIHN0YXRlLndvcmssIHtiaXRzOiA1fSk7XG5cbiAgICAvKiBkbyB0aGlzIGp1c3Qgb25jZSAqL1xuICAgIHZpcmdpbiA9IGZhbHNlO1xuICB9XG5cbiAgc3RhdGUubGVuY29kZSA9IGxlbmZpeDtcbiAgc3RhdGUubGVuYml0cyA9IDk7XG4gIHN0YXRlLmRpc3Rjb2RlID0gZGlzdGZpeDtcbiAgc3RhdGUuZGlzdGJpdHMgPSA1O1xufVxuXG5cbi8qXG4gVXBkYXRlIHRoZSB3aW5kb3cgd2l0aCB0aGUgbGFzdCB3c2l6ZSAobm9ybWFsbHkgMzJLKSBieXRlcyB3cml0dGVuIGJlZm9yZVxuIHJldHVybmluZy4gIElmIHdpbmRvdyBkb2VzIG5vdCBleGlzdCB5ZXQsIGNyZWF0ZSBpdC4gIFRoaXMgaXMgb25seSBjYWxsZWRcbiB3aGVuIGEgd2luZG93IGlzIGFscmVhZHkgaW4gdXNlLCBvciB3aGVuIG91dHB1dCBoYXMgYmVlbiB3cml0dGVuIGR1cmluZyB0aGlzXG4gaW5mbGF0ZSBjYWxsLCBidXQgdGhlIGVuZCBvZiB0aGUgZGVmbGF0ZSBzdHJlYW0gaGFzIG5vdCBiZWVuIHJlYWNoZWQgeWV0LlxuIEl0IGlzIGFsc28gY2FsbGVkIHRvIGNyZWF0ZSBhIHdpbmRvdyBmb3IgZGljdGlvbmFyeSBkYXRhIHdoZW4gYSBkaWN0aW9uYXJ5XG4gaXMgbG9hZGVkLlxuXG4gUHJvdmlkaW5nIG91dHB1dCBidWZmZXJzIGxhcmdlciB0aGFuIDMySyB0byBpbmZsYXRlKCkgc2hvdWxkIHByb3ZpZGUgYSBzcGVlZFxuIGFkdmFudGFnZSwgc2luY2Ugb25seSB0aGUgbGFzdCAzMksgb2Ygb3V0cHV0IGlzIGNvcGllZCB0byB0aGUgc2xpZGluZyB3aW5kb3dcbiB1cG9uIHJldHVybiBmcm9tIGluZmxhdGUoKSwgYW5kIHNpbmNlIGFsbCBkaXN0YW5jZXMgYWZ0ZXIgdGhlIGZpcnN0IDMySyBvZlxuIG91dHB1dCB3aWxsIGZhbGwgaW4gdGhlIG91dHB1dCBkYXRhLCBtYWtpbmcgbWF0Y2ggY29waWVzIHNpbXBsZXIgYW5kIGZhc3Rlci5cbiBUaGUgYWR2YW50YWdlIG1heSBiZSBkZXBlbmRlbnQgb24gdGhlIHNpemUgb2YgdGhlIHByb2Nlc3NvcidzIGRhdGEgY2FjaGVzLlxuICovXG5mdW5jdGlvbiB1cGRhdGV3aW5kb3coc3RybSwgc3JjLCBlbmQsIGNvcHkpIHtcbiAgdmFyIGRpc3Q7XG4gIHZhciBzdGF0ZSA9IHN0cm0uc3RhdGU7XG5cbiAgLyogaWYgaXQgaGFzbid0IGJlZW4gZG9uZSBhbHJlYWR5LCBhbGxvY2F0ZSBzcGFjZSBmb3IgdGhlIHdpbmRvdyAqL1xuICBpZiAoc3RhdGUud2luZG93ID09PSBudWxsKSB7XG4gICAgc3RhdGUud3NpemUgPSAxIDw8IHN0YXRlLndiaXRzO1xuICAgIHN0YXRlLnduZXh0ID0gMDtcbiAgICBzdGF0ZS53aGF2ZSA9IDA7XG5cbiAgICBzdGF0ZS53aW5kb3cgPSBuZXcgdXRpbHMuQnVmOChzdGF0ZS53c2l6ZSk7XG4gIH1cblxuICAvKiBjb3B5IHN0YXRlLT53c2l6ZSBvciBsZXNzIG91dHB1dCBieXRlcyBpbnRvIHRoZSBjaXJjdWxhciB3aW5kb3cgKi9cbiAgaWYgKGNvcHkgPj0gc3RhdGUud3NpemUpIHtcbiAgICB1dGlscy5hcnJheVNldChzdGF0ZS53aW5kb3csc3JjLCBlbmQgLSBzdGF0ZS53c2l6ZSwgc3RhdGUud3NpemUsIDApO1xuICAgIHN0YXRlLnduZXh0ID0gMDtcbiAgICBzdGF0ZS53aGF2ZSA9IHN0YXRlLndzaXplO1xuICB9XG4gIGVsc2Uge1xuICAgIGRpc3QgPSBzdGF0ZS53c2l6ZSAtIHN0YXRlLnduZXh0O1xuICAgIGlmIChkaXN0ID4gY29weSkge1xuICAgICAgZGlzdCA9IGNvcHk7XG4gICAgfVxuICAgIC8vem1lbWNweShzdGF0ZS0+d2luZG93ICsgc3RhdGUtPnduZXh0LCBlbmQgLSBjb3B5LCBkaXN0KTtcbiAgICB1dGlscy5hcnJheVNldChzdGF0ZS53aW5kb3csc3JjLCBlbmQgLSBjb3B5LCBkaXN0LCBzdGF0ZS53bmV4dCk7XG4gICAgY29weSAtPSBkaXN0O1xuICAgIGlmIChjb3B5KSB7XG4gICAgICAvL3ptZW1jcHkoc3RhdGUtPndpbmRvdywgZW5kIC0gY29weSwgY29weSk7XG4gICAgICB1dGlscy5hcnJheVNldChzdGF0ZS53aW5kb3csc3JjLCBlbmQgLSBjb3B5LCBjb3B5LCAwKTtcbiAgICAgIHN0YXRlLnduZXh0ID0gY29weTtcbiAgICAgIHN0YXRlLndoYXZlID0gc3RhdGUud3NpemU7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgc3RhdGUud25leHQgKz0gZGlzdDtcbiAgICAgIGlmIChzdGF0ZS53bmV4dCA9PT0gc3RhdGUud3NpemUpIHsgc3RhdGUud25leHQgPSAwOyB9XG4gICAgICBpZiAoc3RhdGUud2hhdmUgPCBzdGF0ZS53c2l6ZSkgeyBzdGF0ZS53aGF2ZSArPSBkaXN0OyB9XG4gICAgfVxuICB9XG4gIHJldHVybiAwO1xufVxuXG5mdW5jdGlvbiBpbmZsYXRlKHN0cm0sIGZsdXNoKSB7XG4gIHZhciBzdGF0ZTtcbiAgdmFyIGlucHV0LCBvdXRwdXQ7ICAgICAgICAgIC8vIGlucHV0L291dHB1dCBidWZmZXJzXG4gIHZhciBuZXh0OyAgICAgICAgICAgICAgICAgICAvKiBuZXh0IGlucHV0IElOREVYICovXG4gIHZhciBwdXQ7ICAgICAgICAgICAgICAgICAgICAvKiBuZXh0IG91dHB1dCBJTkRFWCAqL1xuICB2YXIgaGF2ZSwgbGVmdDsgICAgICAgICAgICAgLyogYXZhaWxhYmxlIGlucHV0IGFuZCBvdXRwdXQgKi9cbiAgdmFyIGhvbGQ7ICAgICAgICAgICAgICAgICAgIC8qIGJpdCBidWZmZXIgKi9cbiAgdmFyIGJpdHM7ICAgICAgICAgICAgICAgICAgIC8qIGJpdHMgaW4gYml0IGJ1ZmZlciAqL1xuICB2YXIgX2luLCBfb3V0OyAgICAgICAgICAgICAgLyogc2F2ZSBzdGFydGluZyBhdmFpbGFibGUgaW5wdXQgYW5kIG91dHB1dCAqL1xuICB2YXIgY29weTsgICAgICAgICAgICAgICAgICAgLyogbnVtYmVyIG9mIHN0b3JlZCBvciBtYXRjaCBieXRlcyB0byBjb3B5ICovXG4gIHZhciBmcm9tOyAgICAgICAgICAgICAgICAgICAvKiB3aGVyZSB0byBjb3B5IG1hdGNoIGJ5dGVzIGZyb20gKi9cbiAgdmFyIGZyb21fc291cmNlO1xuICB2YXIgaGVyZSA9IDA7ICAgICAgICAgICAgICAgLyogY3VycmVudCBkZWNvZGluZyB0YWJsZSBlbnRyeSAqL1xuICB2YXIgaGVyZV9iaXRzLCBoZXJlX29wLCBoZXJlX3ZhbDsgLy8gcGFrZWQgXCJoZXJlXCIgZGVub3JtYWxpemVkIChKUyBzcGVjaWZpYylcbiAgLy92YXIgbGFzdDsgICAgICAgICAgICAgICAgICAgLyogcGFyZW50IHRhYmxlIGVudHJ5ICovXG4gIHZhciBsYXN0X2JpdHMsIGxhc3Rfb3AsIGxhc3RfdmFsOyAvLyBwYWtlZCBcImxhc3RcIiBkZW5vcm1hbGl6ZWQgKEpTIHNwZWNpZmljKVxuICB2YXIgbGVuOyAgICAgICAgICAgICAgICAgICAgLyogbGVuZ3RoIHRvIGNvcHkgZm9yIHJlcGVhdHMsIGJpdHMgdG8gZHJvcCAqL1xuICB2YXIgcmV0OyAgICAgICAgICAgICAgICAgICAgLyogcmV0dXJuIGNvZGUgKi9cbiAgdmFyIGhidWYgPSBuZXcgdXRpbHMuQnVmOCg0KTsgICAgLyogYnVmZmVyIGZvciBnemlwIGhlYWRlciBjcmMgY2FsY3VsYXRpb24gKi9cbiAgdmFyIG9wdHM7XG5cbiAgdmFyIG47IC8vIHRlbXBvcmFyeSB2YXIgZm9yIE5FRURfQklUU1xuXG4gIHZhciBvcmRlciA9IC8qIHBlcm11dGF0aW9uIG9mIGNvZGUgbGVuZ3RocyAqL1xuICAgIFsxNiwgMTcsIDE4LCAwLCA4LCA3LCA5LCA2LCAxMCwgNSwgMTEsIDQsIDEyLCAzLCAxMywgMiwgMTQsIDEsIDE1XTtcblxuXG4gIGlmICghc3RybSB8fCAhc3RybS5zdGF0ZSB8fCAhc3RybS5vdXRwdXQgfHxcbiAgICAgICghc3RybS5pbnB1dCAmJiBzdHJtLmF2YWlsX2luICE9PSAwKSkge1xuICAgIHJldHVybiBaX1NUUkVBTV9FUlJPUjtcbiAgfVxuXG4gIHN0YXRlID0gc3RybS5zdGF0ZTtcbiAgaWYgKHN0YXRlLm1vZGUgPT09IFRZUEUpIHsgc3RhdGUubW9kZSA9IFRZUEVETzsgfSAgICAvKiBza2lwIGNoZWNrICovXG5cblxuICAvLy0tLSBMT0FEKCkgLS0tXG4gIHB1dCA9IHN0cm0ubmV4dF9vdXQ7XG4gIG91dHB1dCA9IHN0cm0ub3V0cHV0O1xuICBsZWZ0ID0gc3RybS5hdmFpbF9vdXQ7XG4gIG5leHQgPSBzdHJtLm5leHRfaW47XG4gIGlucHV0ID0gc3RybS5pbnB1dDtcbiAgaGF2ZSA9IHN0cm0uYXZhaWxfaW47XG4gIGhvbGQgPSBzdGF0ZS5ob2xkO1xuICBiaXRzID0gc3RhdGUuYml0cztcbiAgLy8tLS1cblxuICBfaW4gPSBoYXZlO1xuICBfb3V0ID0gbGVmdDtcbiAgcmV0ID0gWl9PSztcblxuICBpbmZfbGVhdmU6IC8vIGdvdG8gZW11bGF0aW9uXG4gIGZvciAoOzspIHtcbiAgICBzd2l0Y2ggKHN0YXRlLm1vZGUpIHtcbiAgICBjYXNlIEhFQUQ6XG4gICAgICBpZiAoc3RhdGUud3JhcCA9PT0gMCkge1xuICAgICAgICBzdGF0ZS5tb2RlID0gVFlQRURPO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIC8vPT09IE5FRURCSVRTKDE2KTtcbiAgICAgIHdoaWxlIChiaXRzIDwgMTYpIHtcbiAgICAgICAgaWYgKGhhdmUgPT09IDApIHsgYnJlYWsgaW5mX2xlYXZlOyB9XG4gICAgICAgIGhhdmUtLTtcbiAgICAgICAgaG9sZCArPSBpbnB1dFtuZXh0KytdIDw8IGJpdHM7XG4gICAgICAgIGJpdHMgKz0gODtcbiAgICAgIH1cbiAgICAgIC8vPT09Ly9cbiAgICAgIGlmICgoc3RhdGUud3JhcCAmIDIpICYmIGhvbGQgPT09IDB4OGIxZikgeyAgLyogZ3ppcCBoZWFkZXIgKi9cbiAgICAgICAgc3RhdGUuY2hlY2sgPSAwLypjcmMzMigwTCwgWl9OVUxMLCAwKSovO1xuICAgICAgICAvLz09PSBDUkMyKHN0YXRlLmNoZWNrLCBob2xkKTtcbiAgICAgICAgaGJ1ZlswXSA9IGhvbGQgJiAweGZmO1xuICAgICAgICBoYnVmWzFdID0gKGhvbGQgPj4+IDgpICYgMHhmZjtcbiAgICAgICAgc3RhdGUuY2hlY2sgPSBjcmMzMihzdGF0ZS5jaGVjaywgaGJ1ZiwgMiwgMCk7XG4gICAgICAgIC8vPT09Ly9cblxuICAgICAgICAvLz09PSBJTklUQklUUygpO1xuICAgICAgICBob2xkID0gMDtcbiAgICAgICAgYml0cyA9IDA7XG4gICAgICAgIC8vPT09Ly9cbiAgICAgICAgc3RhdGUubW9kZSA9IEZMQUdTO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIHN0YXRlLmZsYWdzID0gMDsgICAgICAgICAgIC8qIGV4cGVjdCB6bGliIGhlYWRlciAqL1xuICAgICAgaWYgKHN0YXRlLmhlYWQpIHtcbiAgICAgICAgc3RhdGUuaGVhZC5kb25lID0gZmFsc2U7XG4gICAgICB9XG4gICAgICBpZiAoIShzdGF0ZS53cmFwICYgMSkgfHwgICAvKiBjaGVjayBpZiB6bGliIGhlYWRlciBhbGxvd2VkICovXG4gICAgICAgICgoKGhvbGQgJiAweGZmKS8qQklUUyg4KSovIDw8IDgpICsgKGhvbGQgPj4gOCkpICUgMzEpIHtcbiAgICAgICAgc3RybS5tc2cgPSAnaW5jb3JyZWN0IGhlYWRlciBjaGVjayc7XG4gICAgICAgIHN0YXRlLm1vZGUgPSBCQUQ7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgaWYgKChob2xkICYgMHgwZikvKkJJVFMoNCkqLyAhPT0gWl9ERUZMQVRFRCkge1xuICAgICAgICBzdHJtLm1zZyA9ICd1bmtub3duIGNvbXByZXNzaW9uIG1ldGhvZCc7XG4gICAgICAgIHN0YXRlLm1vZGUgPSBCQUQ7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgLy8tLS0gRFJPUEJJVFMoNCkgLS0tLy9cbiAgICAgIGhvbGQgPj4+PSA0O1xuICAgICAgYml0cyAtPSA0O1xuICAgICAgLy8tLS0vL1xuICAgICAgbGVuID0gKGhvbGQgJiAweDBmKS8qQklUUyg0KSovICsgODtcbiAgICAgIGlmIChzdGF0ZS53Yml0cyA9PT0gMCkge1xuICAgICAgICBzdGF0ZS53Yml0cyA9IGxlbjtcbiAgICAgIH1cbiAgICAgIGVsc2UgaWYgKGxlbiA+IHN0YXRlLndiaXRzKSB7XG4gICAgICAgIHN0cm0ubXNnID0gJ2ludmFsaWQgd2luZG93IHNpemUnO1xuICAgICAgICBzdGF0ZS5tb2RlID0gQkFEO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIHN0YXRlLmRtYXggPSAxIDw8IGxlbjtcbiAgICAgIC8vVHJhY2V2KChzdGRlcnIsIFwiaW5mbGF0ZTogICB6bGliIGhlYWRlciBva1xcblwiKSk7XG4gICAgICBzdHJtLmFkbGVyID0gc3RhdGUuY2hlY2sgPSAxLyphZGxlcjMyKDBMLCBaX05VTEwsIDApKi87XG4gICAgICBzdGF0ZS5tb2RlID0gaG9sZCAmIDB4MjAwID8gRElDVElEIDogVFlQRTtcbiAgICAgIC8vPT09IElOSVRCSVRTKCk7XG4gICAgICBob2xkID0gMDtcbiAgICAgIGJpdHMgPSAwO1xuICAgICAgLy89PT0vL1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBGTEFHUzpcbiAgICAgIC8vPT09IE5FRURCSVRTKDE2KTsgKi9cbiAgICAgIHdoaWxlIChiaXRzIDwgMTYpIHtcbiAgICAgICAgaWYgKGhhdmUgPT09IDApIHsgYnJlYWsgaW5mX2xlYXZlOyB9XG4gICAgICAgIGhhdmUtLTtcbiAgICAgICAgaG9sZCArPSBpbnB1dFtuZXh0KytdIDw8IGJpdHM7XG4gICAgICAgIGJpdHMgKz0gODtcbiAgICAgIH1cbiAgICAgIC8vPT09Ly9cbiAgICAgIHN0YXRlLmZsYWdzID0gaG9sZDtcbiAgICAgIGlmICgoc3RhdGUuZmxhZ3MgJiAweGZmKSAhPT0gWl9ERUZMQVRFRCkge1xuICAgICAgICBzdHJtLm1zZyA9ICd1bmtub3duIGNvbXByZXNzaW9uIG1ldGhvZCc7XG4gICAgICAgIHN0YXRlLm1vZGUgPSBCQUQ7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgaWYgKHN0YXRlLmZsYWdzICYgMHhlMDAwKSB7XG4gICAgICAgIHN0cm0ubXNnID0gJ3Vua25vd24gaGVhZGVyIGZsYWdzIHNldCc7XG4gICAgICAgIHN0YXRlLm1vZGUgPSBCQUQ7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgaWYgKHN0YXRlLmhlYWQpIHtcbiAgICAgICAgc3RhdGUuaGVhZC50ZXh0ID0gKChob2xkID4+IDgpICYgMSk7XG4gICAgICB9XG4gICAgICBpZiAoc3RhdGUuZmxhZ3MgJiAweDAyMDApIHtcbiAgICAgICAgLy89PT0gQ1JDMihzdGF0ZS5jaGVjaywgaG9sZCk7XG4gICAgICAgIGhidWZbMF0gPSBob2xkICYgMHhmZjtcbiAgICAgICAgaGJ1ZlsxXSA9IChob2xkID4+PiA4KSAmIDB4ZmY7XG4gICAgICAgIHN0YXRlLmNoZWNrID0gY3JjMzIoc3RhdGUuY2hlY2ssIGhidWYsIDIsIDApO1xuICAgICAgICAvLz09PS8vXG4gICAgICB9XG4gICAgICAvLz09PSBJTklUQklUUygpO1xuICAgICAgaG9sZCA9IDA7XG4gICAgICBiaXRzID0gMDtcbiAgICAgIC8vPT09Ly9cbiAgICAgIHN0YXRlLm1vZGUgPSBUSU1FO1xuICAgICAgLyogZmFsbHMgdGhyb3VnaCAqL1xuICAgIGNhc2UgVElNRTpcbiAgICAgIC8vPT09IE5FRURCSVRTKDMyKTsgKi9cbiAgICAgIHdoaWxlIChiaXRzIDwgMzIpIHtcbiAgICAgICAgaWYgKGhhdmUgPT09IDApIHsgYnJlYWsgaW5mX2xlYXZlOyB9XG4gICAgICAgIGhhdmUtLTtcbiAgICAgICAgaG9sZCArPSBpbnB1dFtuZXh0KytdIDw8IGJpdHM7XG4gICAgICAgIGJpdHMgKz0gODtcbiAgICAgIH1cbiAgICAgIC8vPT09Ly9cbiAgICAgIGlmIChzdGF0ZS5oZWFkKSB7XG4gICAgICAgIHN0YXRlLmhlYWQudGltZSA9IGhvbGQ7XG4gICAgICB9XG4gICAgICBpZiAoc3RhdGUuZmxhZ3MgJiAweDAyMDApIHtcbiAgICAgICAgLy89PT0gQ1JDNChzdGF0ZS5jaGVjaywgaG9sZClcbiAgICAgICAgaGJ1ZlswXSA9IGhvbGQgJiAweGZmO1xuICAgICAgICBoYnVmWzFdID0gKGhvbGQgPj4+IDgpICYgMHhmZjtcbiAgICAgICAgaGJ1ZlsyXSA9IChob2xkID4+PiAxNikgJiAweGZmO1xuICAgICAgICBoYnVmWzNdID0gKGhvbGQgPj4+IDI0KSAmIDB4ZmY7XG4gICAgICAgIHN0YXRlLmNoZWNrID0gY3JjMzIoc3RhdGUuY2hlY2ssIGhidWYsIDQsIDApO1xuICAgICAgICAvLz09PVxuICAgICAgfVxuICAgICAgLy89PT0gSU5JVEJJVFMoKTtcbiAgICAgIGhvbGQgPSAwO1xuICAgICAgYml0cyA9IDA7XG4gICAgICAvLz09PS8vXG4gICAgICBzdGF0ZS5tb2RlID0gT1M7XG4gICAgICAvKiBmYWxscyB0aHJvdWdoICovXG4gICAgY2FzZSBPUzpcbiAgICAgIC8vPT09IE5FRURCSVRTKDE2KTsgKi9cbiAgICAgIHdoaWxlIChiaXRzIDwgMTYpIHtcbiAgICAgICAgaWYgKGhhdmUgPT09IDApIHsgYnJlYWsgaW5mX2xlYXZlOyB9XG4gICAgICAgIGhhdmUtLTtcbiAgICAgICAgaG9sZCArPSBpbnB1dFtuZXh0KytdIDw8IGJpdHM7XG4gICAgICAgIGJpdHMgKz0gODtcbiAgICAgIH1cbiAgICAgIC8vPT09Ly9cbiAgICAgIGlmIChzdGF0ZS5oZWFkKSB7XG4gICAgICAgIHN0YXRlLmhlYWQueGZsYWdzID0gKGhvbGQgJiAweGZmKTtcbiAgICAgICAgc3RhdGUuaGVhZC5vcyA9IChob2xkID4+IDgpO1xuICAgICAgfVxuICAgICAgaWYgKHN0YXRlLmZsYWdzICYgMHgwMjAwKSB7XG4gICAgICAgIC8vPT09IENSQzIoc3RhdGUuY2hlY2ssIGhvbGQpO1xuICAgICAgICBoYnVmWzBdID0gaG9sZCAmIDB4ZmY7XG4gICAgICAgIGhidWZbMV0gPSAoaG9sZCA+Pj4gOCkgJiAweGZmO1xuICAgICAgICBzdGF0ZS5jaGVjayA9IGNyYzMyKHN0YXRlLmNoZWNrLCBoYnVmLCAyLCAwKTtcbiAgICAgICAgLy89PT0vL1xuICAgICAgfVxuICAgICAgLy89PT0gSU5JVEJJVFMoKTtcbiAgICAgIGhvbGQgPSAwO1xuICAgICAgYml0cyA9IDA7XG4gICAgICAvLz09PS8vXG4gICAgICBzdGF0ZS5tb2RlID0gRVhMRU47XG4gICAgICAvKiBmYWxscyB0aHJvdWdoICovXG4gICAgY2FzZSBFWExFTjpcbiAgICAgIGlmIChzdGF0ZS5mbGFncyAmIDB4MDQwMCkge1xuICAgICAgICAvLz09PSBORUVEQklUUygxNik7ICovXG4gICAgICAgIHdoaWxlIChiaXRzIDwgMTYpIHtcbiAgICAgICAgICBpZiAoaGF2ZSA9PT0gMCkgeyBicmVhayBpbmZfbGVhdmU7IH1cbiAgICAgICAgICBoYXZlLS07XG4gICAgICAgICAgaG9sZCArPSBpbnB1dFtuZXh0KytdIDw8IGJpdHM7XG4gICAgICAgICAgYml0cyArPSA4O1xuICAgICAgICB9XG4gICAgICAgIC8vPT09Ly9cbiAgICAgICAgc3RhdGUubGVuZ3RoID0gaG9sZDtcbiAgICAgICAgaWYgKHN0YXRlLmhlYWQpIHtcbiAgICAgICAgICBzdGF0ZS5oZWFkLmV4dHJhX2xlbiA9IGhvbGQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHN0YXRlLmZsYWdzICYgMHgwMjAwKSB7XG4gICAgICAgICAgLy89PT0gQ1JDMihzdGF0ZS5jaGVjaywgaG9sZCk7XG4gICAgICAgICAgaGJ1ZlswXSA9IGhvbGQgJiAweGZmO1xuICAgICAgICAgIGhidWZbMV0gPSAoaG9sZCA+Pj4gOCkgJiAweGZmO1xuICAgICAgICAgIHN0YXRlLmNoZWNrID0gY3JjMzIoc3RhdGUuY2hlY2ssIGhidWYsIDIsIDApO1xuICAgICAgICAgIC8vPT09Ly9cbiAgICAgICAgfVxuICAgICAgICAvLz09PSBJTklUQklUUygpO1xuICAgICAgICBob2xkID0gMDtcbiAgICAgICAgYml0cyA9IDA7XG4gICAgICAgIC8vPT09Ly9cbiAgICAgIH1cbiAgICAgIGVsc2UgaWYgKHN0YXRlLmhlYWQpIHtcbiAgICAgICAgc3RhdGUuaGVhZC5leHRyYSA9IG51bGwvKlpfTlVMTCovO1xuICAgICAgfVxuICAgICAgc3RhdGUubW9kZSA9IEVYVFJBO1xuICAgICAgLyogZmFsbHMgdGhyb3VnaCAqL1xuICAgIGNhc2UgRVhUUkE6XG4gICAgICBpZiAoc3RhdGUuZmxhZ3MgJiAweDA0MDApIHtcbiAgICAgICAgY29weSA9IHN0YXRlLmxlbmd0aDtcbiAgICAgICAgaWYgKGNvcHkgPiBoYXZlKSB7IGNvcHkgPSBoYXZlOyB9XG4gICAgICAgIGlmIChjb3B5KSB7XG4gICAgICAgICAgaWYgKHN0YXRlLmhlYWQpIHtcbiAgICAgICAgICAgIGxlbiA9IHN0YXRlLmhlYWQuZXh0cmFfbGVuIC0gc3RhdGUubGVuZ3RoO1xuICAgICAgICAgICAgaWYgKCFzdGF0ZS5oZWFkLmV4dHJhKSB7XG4gICAgICAgICAgICAgIC8vIFVzZSB1bnR5cGVkIGFycmF5IGZvciBtb3JlIGNvbnZlbmllbmQgcHJvY2Vzc2luZyBsYXRlclxuICAgICAgICAgICAgICBzdGF0ZS5oZWFkLmV4dHJhID0gbmV3IEFycmF5KHN0YXRlLmhlYWQuZXh0cmFfbGVuKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHV0aWxzLmFycmF5U2V0KFxuICAgICAgICAgICAgICBzdGF0ZS5oZWFkLmV4dHJhLFxuICAgICAgICAgICAgICBpbnB1dCxcbiAgICAgICAgICAgICAgbmV4dCxcbiAgICAgICAgICAgICAgLy8gZXh0cmEgZmllbGQgaXMgbGltaXRlZCB0byA2NTUzNiBieXRlc1xuICAgICAgICAgICAgICAvLyAtIG5vIG5lZWQgZm9yIGFkZGl0aW9uYWwgc2l6ZSBjaGVja1xuICAgICAgICAgICAgICBjb3B5LFxuICAgICAgICAgICAgICAvKmxlbiArIGNvcHkgPiBzdGF0ZS5oZWFkLmV4dHJhX21heCAtIGxlbiA/IHN0YXRlLmhlYWQuZXh0cmFfbWF4IDogY29weSwqL1xuICAgICAgICAgICAgICBsZW5cbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICAvL3ptZW1jcHkoc3RhdGUuaGVhZC5leHRyYSArIGxlbiwgbmV4dCxcbiAgICAgICAgICAgIC8vICAgICAgICBsZW4gKyBjb3B5ID4gc3RhdGUuaGVhZC5leHRyYV9tYXggP1xuICAgICAgICAgICAgLy8gICAgICAgIHN0YXRlLmhlYWQuZXh0cmFfbWF4IC0gbGVuIDogY29weSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChzdGF0ZS5mbGFncyAmIDB4MDIwMCkge1xuICAgICAgICAgICAgc3RhdGUuY2hlY2sgPSBjcmMzMihzdGF0ZS5jaGVjaywgaW5wdXQsIGNvcHksIG5leHQpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBoYXZlIC09IGNvcHk7XG4gICAgICAgICAgbmV4dCArPSBjb3B5O1xuICAgICAgICAgIHN0YXRlLmxlbmd0aCAtPSBjb3B5O1xuICAgICAgICB9XG4gICAgICAgIGlmIChzdGF0ZS5sZW5ndGgpIHsgYnJlYWsgaW5mX2xlYXZlOyB9XG4gICAgICB9XG4gICAgICBzdGF0ZS5sZW5ndGggPSAwO1xuICAgICAgc3RhdGUubW9kZSA9IE5BTUU7XG4gICAgICAvKiBmYWxscyB0aHJvdWdoICovXG4gICAgY2FzZSBOQU1FOlxuICAgICAgaWYgKHN0YXRlLmZsYWdzICYgMHgwODAwKSB7XG4gICAgICAgIGlmIChoYXZlID09PSAwKSB7IGJyZWFrIGluZl9sZWF2ZTsgfVxuICAgICAgICBjb3B5ID0gMDtcbiAgICAgICAgZG8ge1xuICAgICAgICAgIC8vIFRPRE86IDIgb3IgMSBieXRlcz9cbiAgICAgICAgICBsZW4gPSBpbnB1dFtuZXh0ICsgY29weSsrXTtcbiAgICAgICAgICAvKiB1c2UgY29uc3RhbnQgbGltaXQgYmVjYXVzZSBpbiBqcyB3ZSBzaG91bGQgbm90IHByZWFsbG9jYXRlIG1lbW9yeSAqL1xuICAgICAgICAgIGlmIChzdGF0ZS5oZWFkICYmIGxlbiAmJlxuICAgICAgICAgICAgICAoc3RhdGUubGVuZ3RoIDwgNjU1MzYgLypzdGF0ZS5oZWFkLm5hbWVfbWF4Ki8pKSB7XG4gICAgICAgICAgICBzdGF0ZS5oZWFkLm5hbWUgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShsZW4pO1xuICAgICAgICAgIH1cbiAgICAgICAgfSB3aGlsZSAobGVuICYmIGNvcHkgPCBoYXZlKTtcblxuICAgICAgICBpZiAoc3RhdGUuZmxhZ3MgJiAweDAyMDApIHtcbiAgICAgICAgICBzdGF0ZS5jaGVjayA9IGNyYzMyKHN0YXRlLmNoZWNrLCBpbnB1dCwgY29weSwgbmV4dCk7XG4gICAgICAgIH1cbiAgICAgICAgaGF2ZSAtPSBjb3B5O1xuICAgICAgICBuZXh0ICs9IGNvcHk7XG4gICAgICAgIGlmIChsZW4pIHsgYnJlYWsgaW5mX2xlYXZlOyB9XG4gICAgICB9XG4gICAgICBlbHNlIGlmIChzdGF0ZS5oZWFkKSB7XG4gICAgICAgIHN0YXRlLmhlYWQubmFtZSA9IG51bGw7XG4gICAgICB9XG4gICAgICBzdGF0ZS5sZW5ndGggPSAwO1xuICAgICAgc3RhdGUubW9kZSA9IENPTU1FTlQ7XG4gICAgICAvKiBmYWxscyB0aHJvdWdoICovXG4gICAgY2FzZSBDT01NRU5UOlxuICAgICAgaWYgKHN0YXRlLmZsYWdzICYgMHgxMDAwKSB7XG4gICAgICAgIGlmIChoYXZlID09PSAwKSB7IGJyZWFrIGluZl9sZWF2ZTsgfVxuICAgICAgICBjb3B5ID0gMDtcbiAgICAgICAgZG8ge1xuICAgICAgICAgIGxlbiA9IGlucHV0W25leHQgKyBjb3B5KytdO1xuICAgICAgICAgIC8qIHVzZSBjb25zdGFudCBsaW1pdCBiZWNhdXNlIGluIGpzIHdlIHNob3VsZCBub3QgcHJlYWxsb2NhdGUgbWVtb3J5ICovXG4gICAgICAgICAgaWYgKHN0YXRlLmhlYWQgJiYgbGVuICYmXG4gICAgICAgICAgICAgIChzdGF0ZS5sZW5ndGggPCA2NTUzNiAvKnN0YXRlLmhlYWQuY29tbV9tYXgqLykpIHtcbiAgICAgICAgICAgIHN0YXRlLmhlYWQuY29tbWVudCArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGxlbik7XG4gICAgICAgICAgfVxuICAgICAgICB9IHdoaWxlIChsZW4gJiYgY29weSA8IGhhdmUpO1xuICAgICAgICBpZiAoc3RhdGUuZmxhZ3MgJiAweDAyMDApIHtcbiAgICAgICAgICBzdGF0ZS5jaGVjayA9IGNyYzMyKHN0YXRlLmNoZWNrLCBpbnB1dCwgY29weSwgbmV4dCk7XG4gICAgICAgIH1cbiAgICAgICAgaGF2ZSAtPSBjb3B5O1xuICAgICAgICBuZXh0ICs9IGNvcHk7XG4gICAgICAgIGlmIChsZW4pIHsgYnJlYWsgaW5mX2xlYXZlOyB9XG4gICAgICB9XG4gICAgICBlbHNlIGlmIChzdGF0ZS5oZWFkKSB7XG4gICAgICAgIHN0YXRlLmhlYWQuY29tbWVudCA9IG51bGw7XG4gICAgICB9XG4gICAgICBzdGF0ZS5tb2RlID0gSENSQztcbiAgICAgIC8qIGZhbGxzIHRocm91Z2ggKi9cbiAgICBjYXNlIEhDUkM6XG4gICAgICBpZiAoc3RhdGUuZmxhZ3MgJiAweDAyMDApIHtcbiAgICAgICAgLy89PT0gTkVFREJJVFMoMTYpOyAqL1xuICAgICAgICB3aGlsZSAoYml0cyA8IDE2KSB7XG4gICAgICAgICAgaWYgKGhhdmUgPT09IDApIHsgYnJlYWsgaW5mX2xlYXZlOyB9XG4gICAgICAgICAgaGF2ZS0tO1xuICAgICAgICAgIGhvbGQgKz0gaW5wdXRbbmV4dCsrXSA8PCBiaXRzO1xuICAgICAgICAgIGJpdHMgKz0gODtcbiAgICAgICAgfVxuICAgICAgICAvLz09PS8vXG4gICAgICAgIGlmIChob2xkICE9PSAoc3RhdGUuY2hlY2sgJiAweGZmZmYpKSB7XG4gICAgICAgICAgc3RybS5tc2cgPSAnaGVhZGVyIGNyYyBtaXNtYXRjaCc7XG4gICAgICAgICAgc3RhdGUubW9kZSA9IEJBRDtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICAvLz09PSBJTklUQklUUygpO1xuICAgICAgICBob2xkID0gMDtcbiAgICAgICAgYml0cyA9IDA7XG4gICAgICAgIC8vPT09Ly9cbiAgICAgIH1cbiAgICAgIGlmIChzdGF0ZS5oZWFkKSB7XG4gICAgICAgIHN0YXRlLmhlYWQuaGNyYyA9ICgoc3RhdGUuZmxhZ3MgPj4gOSkgJiAxKTtcbiAgICAgICAgc3RhdGUuaGVhZC5kb25lID0gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIHN0cm0uYWRsZXIgPSBzdGF0ZS5jaGVjayA9IDAgLypjcmMzMigwTCwgWl9OVUxMLCAwKSovO1xuICAgICAgc3RhdGUubW9kZSA9IFRZUEU7XG4gICAgICBicmVhaztcbiAgICBjYXNlIERJQ1RJRDpcbiAgICAgIC8vPT09IE5FRURCSVRTKDMyKTsgKi9cbiAgICAgIHdoaWxlIChiaXRzIDwgMzIpIHtcbiAgICAgICAgaWYgKGhhdmUgPT09IDApIHsgYnJlYWsgaW5mX2xlYXZlOyB9XG4gICAgICAgIGhhdmUtLTtcbiAgICAgICAgaG9sZCArPSBpbnB1dFtuZXh0KytdIDw8IGJpdHM7XG4gICAgICAgIGJpdHMgKz0gODtcbiAgICAgIH1cbiAgICAgIC8vPT09Ly9cbiAgICAgIHN0cm0uYWRsZXIgPSBzdGF0ZS5jaGVjayA9IFpTV0FQMzIoaG9sZCk7XG4gICAgICAvLz09PSBJTklUQklUUygpO1xuICAgICAgaG9sZCA9IDA7XG4gICAgICBiaXRzID0gMDtcbiAgICAgIC8vPT09Ly9cbiAgICAgIHN0YXRlLm1vZGUgPSBESUNUO1xuICAgICAgLyogZmFsbHMgdGhyb3VnaCAqL1xuICAgIGNhc2UgRElDVDpcbiAgICAgIGlmIChzdGF0ZS5oYXZlZGljdCA9PT0gMCkge1xuICAgICAgICAvLy0tLSBSRVNUT1JFKCkgLS0tXG4gICAgICAgIHN0cm0ubmV4dF9vdXQgPSBwdXQ7XG4gICAgICAgIHN0cm0uYXZhaWxfb3V0ID0gbGVmdDtcbiAgICAgICAgc3RybS5uZXh0X2luID0gbmV4dDtcbiAgICAgICAgc3RybS5hdmFpbF9pbiA9IGhhdmU7XG4gICAgICAgIHN0YXRlLmhvbGQgPSBob2xkO1xuICAgICAgICBzdGF0ZS5iaXRzID0gYml0cztcbiAgICAgICAgLy8tLS1cbiAgICAgICAgcmV0dXJuIFpfTkVFRF9ESUNUO1xuICAgICAgfVxuICAgICAgc3RybS5hZGxlciA9IHN0YXRlLmNoZWNrID0gMS8qYWRsZXIzMigwTCwgWl9OVUxMLCAwKSovO1xuICAgICAgc3RhdGUubW9kZSA9IFRZUEU7XG4gICAgICAvKiBmYWxscyB0aHJvdWdoICovXG4gICAgY2FzZSBUWVBFOlxuICAgICAgaWYgKGZsdXNoID09PSBaX0JMT0NLIHx8IGZsdXNoID09PSBaX1RSRUVTKSB7IGJyZWFrIGluZl9sZWF2ZTsgfVxuICAgICAgLyogZmFsbHMgdGhyb3VnaCAqL1xuICAgIGNhc2UgVFlQRURPOlxuICAgICAgaWYgKHN0YXRlLmxhc3QpIHtcbiAgICAgICAgLy8tLS0gQllURUJJVFMoKSAtLS0vL1xuICAgICAgICBob2xkID4+Pj0gYml0cyAmIDc7XG4gICAgICAgIGJpdHMgLT0gYml0cyAmIDc7XG4gICAgICAgIC8vLS0tLy9cbiAgICAgICAgc3RhdGUubW9kZSA9IENIRUNLO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIC8vPT09IE5FRURCSVRTKDMpOyAqL1xuICAgICAgd2hpbGUgKGJpdHMgPCAzKSB7XG4gICAgICAgIGlmIChoYXZlID09PSAwKSB7IGJyZWFrIGluZl9sZWF2ZTsgfVxuICAgICAgICBoYXZlLS07XG4gICAgICAgIGhvbGQgKz0gaW5wdXRbbmV4dCsrXSA8PCBiaXRzO1xuICAgICAgICBiaXRzICs9IDg7XG4gICAgICB9XG4gICAgICAvLz09PS8vXG4gICAgICBzdGF0ZS5sYXN0ID0gKGhvbGQgJiAweDAxKS8qQklUUygxKSovO1xuICAgICAgLy8tLS0gRFJPUEJJVFMoMSkgLS0tLy9cbiAgICAgIGhvbGQgPj4+PSAxO1xuICAgICAgYml0cyAtPSAxO1xuICAgICAgLy8tLS0vL1xuXG4gICAgICBzd2l0Y2ggKChob2xkICYgMHgwMykvKkJJVFMoMikqLykge1xuICAgICAgY2FzZSAwOiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLyogc3RvcmVkIGJsb2NrICovXG4gICAgICAgIC8vVHJhY2V2KChzdGRlcnIsIFwiaW5mbGF0ZTogICAgIHN0b3JlZCBibG9jayVzXFxuXCIsXG4gICAgICAgIC8vICAgICAgICBzdGF0ZS5sYXN0ID8gXCIgKGxhc3QpXCIgOiBcIlwiKSk7XG4gICAgICAgIHN0YXRlLm1vZGUgPSBTVE9SRUQ7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAxOiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLyogZml4ZWQgYmxvY2sgKi9cbiAgICAgICAgZml4ZWR0YWJsZXMoc3RhdGUpO1xuICAgICAgICAvL1RyYWNldigoc3RkZXJyLCBcImluZmxhdGU6ICAgICBmaXhlZCBjb2RlcyBibG9jayVzXFxuXCIsXG4gICAgICAgIC8vICAgICAgICBzdGF0ZS5sYXN0ID8gXCIgKGxhc3QpXCIgOiBcIlwiKSk7XG4gICAgICAgIHN0YXRlLm1vZGUgPSBMRU5fOyAgICAgICAgICAgICAvKiBkZWNvZGUgY29kZXMgKi9cbiAgICAgICAgaWYgKGZsdXNoID09PSBaX1RSRUVTKSB7XG4gICAgICAgICAgLy8tLS0gRFJPUEJJVFMoMikgLS0tLy9cbiAgICAgICAgICBob2xkID4+Pj0gMjtcbiAgICAgICAgICBiaXRzIC09IDI7XG4gICAgICAgICAgLy8tLS0vL1xuICAgICAgICAgIGJyZWFrIGluZl9sZWF2ZTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgMjogICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8qIGR5bmFtaWMgYmxvY2sgKi9cbiAgICAgICAgLy9UcmFjZXYoKHN0ZGVyciwgXCJpbmZsYXRlOiAgICAgZHluYW1pYyBjb2RlcyBibG9jayVzXFxuXCIsXG4gICAgICAgIC8vICAgICAgICBzdGF0ZS5sYXN0ID8gXCIgKGxhc3QpXCIgOiBcIlwiKSk7XG4gICAgICAgIHN0YXRlLm1vZGUgPSBUQUJMRTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIDM6XG4gICAgICAgIHN0cm0ubXNnID0gJ2ludmFsaWQgYmxvY2sgdHlwZSc7XG4gICAgICAgIHN0YXRlLm1vZGUgPSBCQUQ7XG4gICAgICB9XG4gICAgICAvLy0tLSBEUk9QQklUUygyKSAtLS0vL1xuICAgICAgaG9sZCA+Pj49IDI7XG4gICAgICBiaXRzIC09IDI7XG4gICAgICAvLy0tLS8vXG4gICAgICBicmVhaztcbiAgICBjYXNlIFNUT1JFRDpcbiAgICAgIC8vLS0tIEJZVEVCSVRTKCkgLS0tLy8gLyogZ28gdG8gYnl0ZSBib3VuZGFyeSAqL1xuICAgICAgaG9sZCA+Pj49IGJpdHMgJiA3O1xuICAgICAgYml0cyAtPSBiaXRzICYgNztcbiAgICAgIC8vLS0tLy9cbiAgICAgIC8vPT09IE5FRURCSVRTKDMyKTsgKi9cbiAgICAgIHdoaWxlIChiaXRzIDwgMzIpIHtcbiAgICAgICAgaWYgKGhhdmUgPT09IDApIHsgYnJlYWsgaW5mX2xlYXZlOyB9XG4gICAgICAgIGhhdmUtLTtcbiAgICAgICAgaG9sZCArPSBpbnB1dFtuZXh0KytdIDw8IGJpdHM7XG4gICAgICAgIGJpdHMgKz0gODtcbiAgICAgIH1cbiAgICAgIC8vPT09Ly9cbiAgICAgIGlmICgoaG9sZCAmIDB4ZmZmZikgIT09ICgoaG9sZCA+Pj4gMTYpIF4gMHhmZmZmKSkge1xuICAgICAgICBzdHJtLm1zZyA9ICdpbnZhbGlkIHN0b3JlZCBibG9jayBsZW5ndGhzJztcbiAgICAgICAgc3RhdGUubW9kZSA9IEJBRDtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBzdGF0ZS5sZW5ndGggPSBob2xkICYgMHhmZmZmO1xuICAgICAgLy9UcmFjZXYoKHN0ZGVyciwgXCJpbmZsYXRlOiAgICAgICBzdG9yZWQgbGVuZ3RoICV1XFxuXCIsXG4gICAgICAvLyAgICAgICAgc3RhdGUubGVuZ3RoKSk7XG4gICAgICAvLz09PSBJTklUQklUUygpO1xuICAgICAgaG9sZCA9IDA7XG4gICAgICBiaXRzID0gMDtcbiAgICAgIC8vPT09Ly9cbiAgICAgIHN0YXRlLm1vZGUgPSBDT1BZXztcbiAgICAgIGlmIChmbHVzaCA9PT0gWl9UUkVFUykgeyBicmVhayBpbmZfbGVhdmU7IH1cbiAgICAgIC8qIGZhbGxzIHRocm91Z2ggKi9cbiAgICBjYXNlIENPUFlfOlxuICAgICAgc3RhdGUubW9kZSA9IENPUFk7XG4gICAgICAvKiBmYWxscyB0aHJvdWdoICovXG4gICAgY2FzZSBDT1BZOlxuICAgICAgY29weSA9IHN0YXRlLmxlbmd0aDtcbiAgICAgIGlmIChjb3B5KSB7XG4gICAgICAgIGlmIChjb3B5ID4gaGF2ZSkgeyBjb3B5ID0gaGF2ZTsgfVxuICAgICAgICBpZiAoY29weSA+IGxlZnQpIHsgY29weSA9IGxlZnQ7IH1cbiAgICAgICAgaWYgKGNvcHkgPT09IDApIHsgYnJlYWsgaW5mX2xlYXZlOyB9XG4gICAgICAgIC8vLS0tIHptZW1jcHkocHV0LCBuZXh0LCBjb3B5KTsgLS0tXG4gICAgICAgIHV0aWxzLmFycmF5U2V0KG91dHB1dCwgaW5wdXQsIG5leHQsIGNvcHksIHB1dCk7XG4gICAgICAgIC8vLS0tLy9cbiAgICAgICAgaGF2ZSAtPSBjb3B5O1xuICAgICAgICBuZXh0ICs9IGNvcHk7XG4gICAgICAgIGxlZnQgLT0gY29weTtcbiAgICAgICAgcHV0ICs9IGNvcHk7XG4gICAgICAgIHN0YXRlLmxlbmd0aCAtPSBjb3B5O1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIC8vVHJhY2V2KChzdGRlcnIsIFwiaW5mbGF0ZTogICAgICAgc3RvcmVkIGVuZFxcblwiKSk7XG4gICAgICBzdGF0ZS5tb2RlID0gVFlQRTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgVEFCTEU6XG4gICAgICAvLz09PSBORUVEQklUUygxNCk7ICovXG4gICAgICB3aGlsZSAoYml0cyA8IDE0KSB7XG4gICAgICAgIGlmIChoYXZlID09PSAwKSB7IGJyZWFrIGluZl9sZWF2ZTsgfVxuICAgICAgICBoYXZlLS07XG4gICAgICAgIGhvbGQgKz0gaW5wdXRbbmV4dCsrXSA8PCBiaXRzO1xuICAgICAgICBiaXRzICs9IDg7XG4gICAgICB9XG4gICAgICAvLz09PS8vXG4gICAgICBzdGF0ZS5ubGVuID0gKGhvbGQgJiAweDFmKS8qQklUUyg1KSovICsgMjU3O1xuICAgICAgLy8tLS0gRFJPUEJJVFMoNSkgLS0tLy9cbiAgICAgIGhvbGQgPj4+PSA1O1xuICAgICAgYml0cyAtPSA1O1xuICAgICAgLy8tLS0vL1xuICAgICAgc3RhdGUubmRpc3QgPSAoaG9sZCAmIDB4MWYpLypCSVRTKDUpKi8gKyAxO1xuICAgICAgLy8tLS0gRFJPUEJJVFMoNSkgLS0tLy9cbiAgICAgIGhvbGQgPj4+PSA1O1xuICAgICAgYml0cyAtPSA1O1xuICAgICAgLy8tLS0vL1xuICAgICAgc3RhdGUubmNvZGUgPSAoaG9sZCAmIDB4MGYpLypCSVRTKDQpKi8gKyA0O1xuICAgICAgLy8tLS0gRFJPUEJJVFMoNCkgLS0tLy9cbiAgICAgIGhvbGQgPj4+PSA0O1xuICAgICAgYml0cyAtPSA0O1xuICAgICAgLy8tLS0vL1xuLy8jaWZuZGVmIFBLWklQX0JVR19XT1JLQVJPVU5EXG4gICAgICBpZiAoc3RhdGUubmxlbiA+IDI4NiB8fCBzdGF0ZS5uZGlzdCA+IDMwKSB7XG4gICAgICAgIHN0cm0ubXNnID0gJ3RvbyBtYW55IGxlbmd0aCBvciBkaXN0YW5jZSBzeW1ib2xzJztcbiAgICAgICAgc3RhdGUubW9kZSA9IEJBRDtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4vLyNlbmRpZlxuICAgICAgLy9UcmFjZXYoKHN0ZGVyciwgXCJpbmZsYXRlOiAgICAgICB0YWJsZSBzaXplcyBva1xcblwiKSk7XG4gICAgICBzdGF0ZS5oYXZlID0gMDtcbiAgICAgIHN0YXRlLm1vZGUgPSBMRU5MRU5TO1xuICAgICAgLyogZmFsbHMgdGhyb3VnaCAqL1xuICAgIGNhc2UgTEVOTEVOUzpcbiAgICAgIHdoaWxlIChzdGF0ZS5oYXZlIDwgc3RhdGUubmNvZGUpIHtcbiAgICAgICAgLy89PT0gTkVFREJJVFMoMyk7XG4gICAgICAgIHdoaWxlIChiaXRzIDwgMykge1xuICAgICAgICAgIGlmIChoYXZlID09PSAwKSB7IGJyZWFrIGluZl9sZWF2ZTsgfVxuICAgICAgICAgIGhhdmUtLTtcbiAgICAgICAgICBob2xkICs9IGlucHV0W25leHQrK10gPDwgYml0cztcbiAgICAgICAgICBiaXRzICs9IDg7XG4gICAgICAgIH1cbiAgICAgICAgLy89PT0vL1xuICAgICAgICBzdGF0ZS5sZW5zW29yZGVyW3N0YXRlLmhhdmUrK11dID0gKGhvbGQgJiAweDA3KTsvL0JJVFMoMyk7XG4gICAgICAgIC8vLS0tIERST1BCSVRTKDMpIC0tLS8vXG4gICAgICAgIGhvbGQgPj4+PSAzO1xuICAgICAgICBiaXRzIC09IDM7XG4gICAgICAgIC8vLS0tLy9cbiAgICAgIH1cbiAgICAgIHdoaWxlIChzdGF0ZS5oYXZlIDwgMTkpIHtcbiAgICAgICAgc3RhdGUubGVuc1tvcmRlcltzdGF0ZS5oYXZlKytdXSA9IDA7XG4gICAgICB9XG4gICAgICAvLyBXZSBoYXZlIHNlcGFyYXRlIHRhYmxlcyAmIG5vIHBvaW50ZXJzLiAyIGNvbW1lbnRlZCBsaW5lcyBiZWxvdyBub3QgbmVlZGVkLlxuICAgICAgLy9zdGF0ZS5uZXh0ID0gc3RhdGUuY29kZXM7XG4gICAgICAvL3N0YXRlLmxlbmNvZGUgPSBzdGF0ZS5uZXh0O1xuICAgICAgLy8gU3dpdGNoIHRvIHVzZSBkeW5hbWljIHRhYmxlXG4gICAgICBzdGF0ZS5sZW5jb2RlID0gc3RhdGUubGVuZHluO1xuICAgICAgc3RhdGUubGVuYml0cyA9IDc7XG5cbiAgICAgIG9wdHMgPSB7Yml0czogc3RhdGUubGVuYml0c307XG4gICAgICByZXQgPSBpbmZsYXRlX3RhYmxlKENPREVTLCBzdGF0ZS5sZW5zLCAwLCAxOSwgc3RhdGUubGVuY29kZSwgMCwgc3RhdGUud29yaywgb3B0cyk7XG4gICAgICBzdGF0ZS5sZW5iaXRzID0gb3B0cy5iaXRzO1xuXG4gICAgICBpZiAocmV0KSB7XG4gICAgICAgIHN0cm0ubXNnID0gJ2ludmFsaWQgY29kZSBsZW5ndGhzIHNldCc7XG4gICAgICAgIHN0YXRlLm1vZGUgPSBCQUQ7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgLy9UcmFjZXYoKHN0ZGVyciwgXCJpbmZsYXRlOiAgICAgICBjb2RlIGxlbmd0aHMgb2tcXG5cIikpO1xuICAgICAgc3RhdGUuaGF2ZSA9IDA7XG4gICAgICBzdGF0ZS5tb2RlID0gQ09ERUxFTlM7XG4gICAgICAvKiBmYWxscyB0aHJvdWdoICovXG4gICAgY2FzZSBDT0RFTEVOUzpcbiAgICAgIHdoaWxlIChzdGF0ZS5oYXZlIDwgc3RhdGUubmxlbiArIHN0YXRlLm5kaXN0KSB7XG4gICAgICAgIGZvciAoOzspIHtcbiAgICAgICAgICBoZXJlID0gc3RhdGUubGVuY29kZVtob2xkICYgKCgxIDw8IHN0YXRlLmxlbmJpdHMpIC0gMSldOy8qQklUUyhzdGF0ZS5sZW5iaXRzKSovXG4gICAgICAgICAgaGVyZV9iaXRzID0gaGVyZSA+Pj4gMjQ7XG4gICAgICAgICAgaGVyZV9vcCA9IChoZXJlID4+PiAxNikgJiAweGZmO1xuICAgICAgICAgIGhlcmVfdmFsID0gaGVyZSAmIDB4ZmZmZjtcblxuICAgICAgICAgIGlmICgoaGVyZV9iaXRzKSA8PSBiaXRzKSB7IGJyZWFrOyB9XG4gICAgICAgICAgLy8tLS0gUFVMTEJZVEUoKSAtLS0vL1xuICAgICAgICAgIGlmIChoYXZlID09PSAwKSB7IGJyZWFrIGluZl9sZWF2ZTsgfVxuICAgICAgICAgIGhhdmUtLTtcbiAgICAgICAgICBob2xkICs9IGlucHV0W25leHQrK10gPDwgYml0cztcbiAgICAgICAgICBiaXRzICs9IDg7XG4gICAgICAgICAgLy8tLS0vL1xuICAgICAgICB9XG4gICAgICAgIGlmIChoZXJlX3ZhbCA8IDE2KSB7XG4gICAgICAgICAgLy8tLS0gRFJPUEJJVFMoaGVyZS5iaXRzKSAtLS0vL1xuICAgICAgICAgIGhvbGQgPj4+PSBoZXJlX2JpdHM7XG4gICAgICAgICAgYml0cyAtPSBoZXJlX2JpdHM7XG4gICAgICAgICAgLy8tLS0vL1xuICAgICAgICAgIHN0YXRlLmxlbnNbc3RhdGUuaGF2ZSsrXSA9IGhlcmVfdmFsO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIGlmIChoZXJlX3ZhbCA9PT0gMTYpIHtcbiAgICAgICAgICAgIC8vPT09IE5FRURCSVRTKGhlcmUuYml0cyArIDIpO1xuICAgICAgICAgICAgbiA9IGhlcmVfYml0cyArIDI7XG4gICAgICAgICAgICB3aGlsZSAoYml0cyA8IG4pIHtcbiAgICAgICAgICAgICAgaWYgKGhhdmUgPT09IDApIHsgYnJlYWsgaW5mX2xlYXZlOyB9XG4gICAgICAgICAgICAgIGhhdmUtLTtcbiAgICAgICAgICAgICAgaG9sZCArPSBpbnB1dFtuZXh0KytdIDw8IGJpdHM7XG4gICAgICAgICAgICAgIGJpdHMgKz0gODtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vPT09Ly9cbiAgICAgICAgICAgIC8vLS0tIERST1BCSVRTKGhlcmUuYml0cykgLS0tLy9cbiAgICAgICAgICAgIGhvbGQgPj4+PSBoZXJlX2JpdHM7XG4gICAgICAgICAgICBiaXRzIC09IGhlcmVfYml0cztcbiAgICAgICAgICAgIC8vLS0tLy9cbiAgICAgICAgICAgIGlmIChzdGF0ZS5oYXZlID09PSAwKSB7XG4gICAgICAgICAgICAgIHN0cm0ubXNnID0gJ2ludmFsaWQgYml0IGxlbmd0aCByZXBlYXQnO1xuICAgICAgICAgICAgICBzdGF0ZS5tb2RlID0gQkFEO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxlbiA9IHN0YXRlLmxlbnNbc3RhdGUuaGF2ZSAtIDFdO1xuICAgICAgICAgICAgY29weSA9IDMgKyAoaG9sZCAmIDB4MDMpOy8vQklUUygyKTtcbiAgICAgICAgICAgIC8vLS0tIERST1BCSVRTKDIpIC0tLS8vXG4gICAgICAgICAgICBob2xkID4+Pj0gMjtcbiAgICAgICAgICAgIGJpdHMgLT0gMjtcbiAgICAgICAgICAgIC8vLS0tLy9cbiAgICAgICAgICB9XG4gICAgICAgICAgZWxzZSBpZiAoaGVyZV92YWwgPT09IDE3KSB7XG4gICAgICAgICAgICAvLz09PSBORUVEQklUUyhoZXJlLmJpdHMgKyAzKTtcbiAgICAgICAgICAgIG4gPSBoZXJlX2JpdHMgKyAzO1xuICAgICAgICAgICAgd2hpbGUgKGJpdHMgPCBuKSB7XG4gICAgICAgICAgICAgIGlmIChoYXZlID09PSAwKSB7IGJyZWFrIGluZl9sZWF2ZTsgfVxuICAgICAgICAgICAgICBoYXZlLS07XG4gICAgICAgICAgICAgIGhvbGQgKz0gaW5wdXRbbmV4dCsrXSA8PCBiaXRzO1xuICAgICAgICAgICAgICBiaXRzICs9IDg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLz09PS8vXG4gICAgICAgICAgICAvLy0tLSBEUk9QQklUUyhoZXJlLmJpdHMpIC0tLS8vXG4gICAgICAgICAgICBob2xkID4+Pj0gaGVyZV9iaXRzO1xuICAgICAgICAgICAgYml0cyAtPSBoZXJlX2JpdHM7XG4gICAgICAgICAgICAvLy0tLS8vXG4gICAgICAgICAgICBsZW4gPSAwO1xuICAgICAgICAgICAgY29weSA9IDMgKyAoaG9sZCAmIDB4MDcpOy8vQklUUygzKTtcbiAgICAgICAgICAgIC8vLS0tIERST1BCSVRTKDMpIC0tLS8vXG4gICAgICAgICAgICBob2xkID4+Pj0gMztcbiAgICAgICAgICAgIGJpdHMgLT0gMztcbiAgICAgICAgICAgIC8vLS0tLy9cbiAgICAgICAgICB9XG4gICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLz09PSBORUVEQklUUyhoZXJlLmJpdHMgKyA3KTtcbiAgICAgICAgICAgIG4gPSBoZXJlX2JpdHMgKyA3O1xuICAgICAgICAgICAgd2hpbGUgKGJpdHMgPCBuKSB7XG4gICAgICAgICAgICAgIGlmIChoYXZlID09PSAwKSB7IGJyZWFrIGluZl9sZWF2ZTsgfVxuICAgICAgICAgICAgICBoYXZlLS07XG4gICAgICAgICAgICAgIGhvbGQgKz0gaW5wdXRbbmV4dCsrXSA8PCBiaXRzO1xuICAgICAgICAgICAgICBiaXRzICs9IDg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLz09PS8vXG4gICAgICAgICAgICAvLy0tLSBEUk9QQklUUyhoZXJlLmJpdHMpIC0tLS8vXG4gICAgICAgICAgICBob2xkID4+Pj0gaGVyZV9iaXRzO1xuICAgICAgICAgICAgYml0cyAtPSBoZXJlX2JpdHM7XG4gICAgICAgICAgICAvLy0tLS8vXG4gICAgICAgICAgICBsZW4gPSAwO1xuICAgICAgICAgICAgY29weSA9IDExICsgKGhvbGQgJiAweDdmKTsvL0JJVFMoNyk7XG4gICAgICAgICAgICAvLy0tLSBEUk9QQklUUyg3KSAtLS0vL1xuICAgICAgICAgICAgaG9sZCA+Pj49IDc7XG4gICAgICAgICAgICBiaXRzIC09IDc7XG4gICAgICAgICAgICAvLy0tLS8vXG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChzdGF0ZS5oYXZlICsgY29weSA+IHN0YXRlLm5sZW4gKyBzdGF0ZS5uZGlzdCkge1xuICAgICAgICAgICAgc3RybS5tc2cgPSAnaW52YWxpZCBiaXQgbGVuZ3RoIHJlcGVhdCc7XG4gICAgICAgICAgICBzdGF0ZS5tb2RlID0gQkFEO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIHdoaWxlIChjb3B5LS0pIHtcbiAgICAgICAgICAgIHN0YXRlLmxlbnNbc3RhdGUuaGF2ZSsrXSA9IGxlbjtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLyogaGFuZGxlIGVycm9yIGJyZWFrcyBpbiB3aGlsZSAqL1xuICAgICAgaWYgKHN0YXRlLm1vZGUgPT09IEJBRCkgeyBicmVhazsgfVxuXG4gICAgICAvKiBjaGVjayBmb3IgZW5kLW9mLWJsb2NrIGNvZGUgKGJldHRlciBoYXZlIG9uZSkgKi9cbiAgICAgIGlmIChzdGF0ZS5sZW5zWzI1Nl0gPT09IDApIHtcbiAgICAgICAgc3RybS5tc2cgPSAnaW52YWxpZCBjb2RlIC0tIG1pc3NpbmcgZW5kLW9mLWJsb2NrJztcbiAgICAgICAgc3RhdGUubW9kZSA9IEJBRDtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG5cbiAgICAgIC8qIGJ1aWxkIGNvZGUgdGFibGVzIC0tIG5vdGU6IGRvIG5vdCBjaGFuZ2UgdGhlIGxlbmJpdHMgb3IgZGlzdGJpdHNcbiAgICAgICAgIHZhbHVlcyBoZXJlICg5IGFuZCA2KSB3aXRob3V0IHJlYWRpbmcgdGhlIGNvbW1lbnRzIGluIGluZnRyZWVzLmhcbiAgICAgICAgIGNvbmNlcm5pbmcgdGhlIEVOT1VHSCBjb25zdGFudHMsIHdoaWNoIGRlcGVuZCBvbiB0aG9zZSB2YWx1ZXMgKi9cbiAgICAgIHN0YXRlLmxlbmJpdHMgPSA5O1xuXG4gICAgICBvcHRzID0ge2JpdHM6IHN0YXRlLmxlbmJpdHN9O1xuICAgICAgcmV0ID0gaW5mbGF0ZV90YWJsZShMRU5TLCBzdGF0ZS5sZW5zLCAwLCBzdGF0ZS5ubGVuLCBzdGF0ZS5sZW5jb2RlLCAwLCBzdGF0ZS53b3JrLCBvcHRzKTtcbiAgICAgIC8vIFdlIGhhdmUgc2VwYXJhdGUgdGFibGVzICYgbm8gcG9pbnRlcnMuIDIgY29tbWVudGVkIGxpbmVzIGJlbG93IG5vdCBuZWVkZWQuXG4gICAgICAvLyBzdGF0ZS5uZXh0X2luZGV4ID0gb3B0cy50YWJsZV9pbmRleDtcbiAgICAgIHN0YXRlLmxlbmJpdHMgPSBvcHRzLmJpdHM7XG4gICAgICAvLyBzdGF0ZS5sZW5jb2RlID0gc3RhdGUubmV4dDtcblxuICAgICAgaWYgKHJldCkge1xuICAgICAgICBzdHJtLm1zZyA9ICdpbnZhbGlkIGxpdGVyYWwvbGVuZ3RocyBzZXQnO1xuICAgICAgICBzdGF0ZS5tb2RlID0gQkFEO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cblxuICAgICAgc3RhdGUuZGlzdGJpdHMgPSA2O1xuICAgICAgLy9zdGF0ZS5kaXN0Y29kZS5jb3B5KHN0YXRlLmNvZGVzKTtcbiAgICAgIC8vIFN3aXRjaCB0byB1c2UgZHluYW1pYyB0YWJsZVxuICAgICAgc3RhdGUuZGlzdGNvZGUgPSBzdGF0ZS5kaXN0ZHluO1xuICAgICAgb3B0cyA9IHtiaXRzOiBzdGF0ZS5kaXN0Yml0c307XG4gICAgICByZXQgPSBpbmZsYXRlX3RhYmxlKERJU1RTLCBzdGF0ZS5sZW5zLCBzdGF0ZS5ubGVuLCBzdGF0ZS5uZGlzdCwgc3RhdGUuZGlzdGNvZGUsIDAsIHN0YXRlLndvcmssIG9wdHMpO1xuICAgICAgLy8gV2UgaGF2ZSBzZXBhcmF0ZSB0YWJsZXMgJiBubyBwb2ludGVycy4gMiBjb21tZW50ZWQgbGluZXMgYmVsb3cgbm90IG5lZWRlZC5cbiAgICAgIC8vIHN0YXRlLm5leHRfaW5kZXggPSBvcHRzLnRhYmxlX2luZGV4O1xuICAgICAgc3RhdGUuZGlzdGJpdHMgPSBvcHRzLmJpdHM7XG4gICAgICAvLyBzdGF0ZS5kaXN0Y29kZSA9IHN0YXRlLm5leHQ7XG5cbiAgICAgIGlmIChyZXQpIHtcbiAgICAgICAgc3RybS5tc2cgPSAnaW52YWxpZCBkaXN0YW5jZXMgc2V0JztcbiAgICAgICAgc3RhdGUubW9kZSA9IEJBRDtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICAvL1RyYWNldigoc3RkZXJyLCAnaW5mbGF0ZTogICAgICAgY29kZXMgb2tcXG4nKSk7XG4gICAgICBzdGF0ZS5tb2RlID0gTEVOXztcbiAgICAgIGlmIChmbHVzaCA9PT0gWl9UUkVFUykgeyBicmVhayBpbmZfbGVhdmU7IH1cbiAgICAgIC8qIGZhbGxzIHRocm91Z2ggKi9cbiAgICBjYXNlIExFTl86XG4gICAgICBzdGF0ZS5tb2RlID0gTEVOO1xuICAgICAgLyogZmFsbHMgdGhyb3VnaCAqL1xuICAgIGNhc2UgTEVOOlxuICAgICAgaWYgKGhhdmUgPj0gNiAmJiBsZWZ0ID49IDI1OCkge1xuICAgICAgICAvLy0tLSBSRVNUT1JFKCkgLS0tXG4gICAgICAgIHN0cm0ubmV4dF9vdXQgPSBwdXQ7XG4gICAgICAgIHN0cm0uYXZhaWxfb3V0ID0gbGVmdDtcbiAgICAgICAgc3RybS5uZXh0X2luID0gbmV4dDtcbiAgICAgICAgc3RybS5hdmFpbF9pbiA9IGhhdmU7XG4gICAgICAgIHN0YXRlLmhvbGQgPSBob2xkO1xuICAgICAgICBzdGF0ZS5iaXRzID0gYml0cztcbiAgICAgICAgLy8tLS1cbiAgICAgICAgaW5mbGF0ZV9mYXN0KHN0cm0sIF9vdXQpO1xuICAgICAgICAvLy0tLSBMT0FEKCkgLS0tXG4gICAgICAgIHB1dCA9IHN0cm0ubmV4dF9vdXQ7XG4gICAgICAgIG91dHB1dCA9IHN0cm0ub3V0cHV0O1xuICAgICAgICBsZWZ0ID0gc3RybS5hdmFpbF9vdXQ7XG4gICAgICAgIG5leHQgPSBzdHJtLm5leHRfaW47XG4gICAgICAgIGlucHV0ID0gc3RybS5pbnB1dDtcbiAgICAgICAgaGF2ZSA9IHN0cm0uYXZhaWxfaW47XG4gICAgICAgIGhvbGQgPSBzdGF0ZS5ob2xkO1xuICAgICAgICBiaXRzID0gc3RhdGUuYml0cztcbiAgICAgICAgLy8tLS1cblxuICAgICAgICBpZiAoc3RhdGUubW9kZSA9PT0gVFlQRSkge1xuICAgICAgICAgIHN0YXRlLmJhY2sgPSAtMTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIHN0YXRlLmJhY2sgPSAwO1xuICAgICAgZm9yICg7Oykge1xuICAgICAgICBoZXJlID0gc3RhdGUubGVuY29kZVtob2xkICYgKCgxIDw8IHN0YXRlLmxlbmJpdHMpIC0xKV07ICAvKkJJVFMoc3RhdGUubGVuYml0cykqL1xuICAgICAgICBoZXJlX2JpdHMgPSBoZXJlID4+PiAyNDtcbiAgICAgICAgaGVyZV9vcCA9IChoZXJlID4+PiAxNikgJiAweGZmO1xuICAgICAgICBoZXJlX3ZhbCA9IGhlcmUgJiAweGZmZmY7XG5cbiAgICAgICAgaWYgKGhlcmVfYml0cyA8PSBiaXRzKSB7IGJyZWFrOyB9XG4gICAgICAgIC8vLS0tIFBVTExCWVRFKCkgLS0tLy9cbiAgICAgICAgaWYgKGhhdmUgPT09IDApIHsgYnJlYWsgaW5mX2xlYXZlOyB9XG4gICAgICAgIGhhdmUtLTtcbiAgICAgICAgaG9sZCArPSBpbnB1dFtuZXh0KytdIDw8IGJpdHM7XG4gICAgICAgIGJpdHMgKz0gODtcbiAgICAgICAgLy8tLS0vL1xuICAgICAgfVxuICAgICAgaWYgKGhlcmVfb3AgJiYgKGhlcmVfb3AgJiAweGYwKSA9PT0gMCkge1xuICAgICAgICBsYXN0X2JpdHMgPSBoZXJlX2JpdHM7XG4gICAgICAgIGxhc3Rfb3AgPSBoZXJlX29wO1xuICAgICAgICBsYXN0X3ZhbCA9IGhlcmVfdmFsO1xuICAgICAgICBmb3IgKDs7KSB7XG4gICAgICAgICAgaGVyZSA9IHN0YXRlLmxlbmNvZGVbbGFzdF92YWwgK1xuICAgICAgICAgICAgICAgICAgKChob2xkICYgKCgxIDw8IChsYXN0X2JpdHMgKyBsYXN0X29wKSkgLTEpKS8qQklUUyhsYXN0LmJpdHMgKyBsYXN0Lm9wKSovID4+IGxhc3RfYml0cyldO1xuICAgICAgICAgIGhlcmVfYml0cyA9IGhlcmUgPj4+IDI0O1xuICAgICAgICAgIGhlcmVfb3AgPSAoaGVyZSA+Pj4gMTYpICYgMHhmZjtcbiAgICAgICAgICBoZXJlX3ZhbCA9IGhlcmUgJiAweGZmZmY7XG5cbiAgICAgICAgICBpZiAoKGxhc3RfYml0cyArIGhlcmVfYml0cykgPD0gYml0cykgeyBicmVhazsgfVxuICAgICAgICAgIC8vLS0tIFBVTExCWVRFKCkgLS0tLy9cbiAgICAgICAgICBpZiAoaGF2ZSA9PT0gMCkgeyBicmVhayBpbmZfbGVhdmU7IH1cbiAgICAgICAgICBoYXZlLS07XG4gICAgICAgICAgaG9sZCArPSBpbnB1dFtuZXh0KytdIDw8IGJpdHM7XG4gICAgICAgICAgYml0cyArPSA4O1xuICAgICAgICAgIC8vLS0tLy9cbiAgICAgICAgfVxuICAgICAgICAvLy0tLSBEUk9QQklUUyhsYXN0LmJpdHMpIC0tLS8vXG4gICAgICAgIGhvbGQgPj4+PSBsYXN0X2JpdHM7XG4gICAgICAgIGJpdHMgLT0gbGFzdF9iaXRzO1xuICAgICAgICAvLy0tLS8vXG4gICAgICAgIHN0YXRlLmJhY2sgKz0gbGFzdF9iaXRzO1xuICAgICAgfVxuICAgICAgLy8tLS0gRFJPUEJJVFMoaGVyZS5iaXRzKSAtLS0vL1xuICAgICAgaG9sZCA+Pj49IGhlcmVfYml0cztcbiAgICAgIGJpdHMgLT0gaGVyZV9iaXRzO1xuICAgICAgLy8tLS0vL1xuICAgICAgc3RhdGUuYmFjayArPSBoZXJlX2JpdHM7XG4gICAgICBzdGF0ZS5sZW5ndGggPSBoZXJlX3ZhbDtcbiAgICAgIGlmIChoZXJlX29wID09PSAwKSB7XG4gICAgICAgIC8vVHJhY2V2digoc3RkZXJyLCBoZXJlLnZhbCA+PSAweDIwICYmIGhlcmUudmFsIDwgMHg3ZiA/XG4gICAgICAgIC8vICAgICAgICBcImluZmxhdGU6ICAgICAgICAgbGl0ZXJhbCAnJWMnXFxuXCIgOlxuICAgICAgICAvLyAgICAgICAgXCJpbmZsYXRlOiAgICAgICAgIGxpdGVyYWwgMHglMDJ4XFxuXCIsIGhlcmUudmFsKSk7XG4gICAgICAgIHN0YXRlLm1vZGUgPSBMSVQ7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgaWYgKGhlcmVfb3AgJiAzMikge1xuICAgICAgICAvL1RyYWNldnYoKHN0ZGVyciwgXCJpbmZsYXRlOiAgICAgICAgIGVuZCBvZiBibG9ja1xcblwiKSk7XG4gICAgICAgIHN0YXRlLmJhY2sgPSAtMTtcbiAgICAgICAgc3RhdGUubW9kZSA9IFRZUEU7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgaWYgKGhlcmVfb3AgJiA2NCkge1xuICAgICAgICBzdHJtLm1zZyA9ICdpbnZhbGlkIGxpdGVyYWwvbGVuZ3RoIGNvZGUnO1xuICAgICAgICBzdGF0ZS5tb2RlID0gQkFEO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIHN0YXRlLmV4dHJhID0gaGVyZV9vcCAmIDE1O1xuICAgICAgc3RhdGUubW9kZSA9IExFTkVYVDtcbiAgICAgIC8qIGZhbGxzIHRocm91Z2ggKi9cbiAgICBjYXNlIExFTkVYVDpcbiAgICAgIGlmIChzdGF0ZS5leHRyYSkge1xuICAgICAgICAvLz09PSBORUVEQklUUyhzdGF0ZS5leHRyYSk7XG4gICAgICAgIG4gPSBzdGF0ZS5leHRyYTtcbiAgICAgICAgd2hpbGUgKGJpdHMgPCBuKSB7XG4gICAgICAgICAgaWYgKGhhdmUgPT09IDApIHsgYnJlYWsgaW5mX2xlYXZlOyB9XG4gICAgICAgICAgaGF2ZS0tO1xuICAgICAgICAgIGhvbGQgKz0gaW5wdXRbbmV4dCsrXSA8PCBiaXRzO1xuICAgICAgICAgIGJpdHMgKz0gODtcbiAgICAgICAgfVxuICAgICAgICAvLz09PS8vXG4gICAgICAgIHN0YXRlLmxlbmd0aCArPSBob2xkICYgKCgxIDw8IHN0YXRlLmV4dHJhKSAtMSkvKkJJVFMoc3RhdGUuZXh0cmEpKi87XG4gICAgICAgIC8vLS0tIERST1BCSVRTKHN0YXRlLmV4dHJhKSAtLS0vL1xuICAgICAgICBob2xkID4+Pj0gc3RhdGUuZXh0cmE7XG4gICAgICAgIGJpdHMgLT0gc3RhdGUuZXh0cmE7XG4gICAgICAgIC8vLS0tLy9cbiAgICAgICAgc3RhdGUuYmFjayArPSBzdGF0ZS5leHRyYTtcbiAgICAgIH1cbiAgICAgIC8vVHJhY2V2digoc3RkZXJyLCBcImluZmxhdGU6ICAgICAgICAgbGVuZ3RoICV1XFxuXCIsIHN0YXRlLmxlbmd0aCkpO1xuICAgICAgc3RhdGUud2FzID0gc3RhdGUubGVuZ3RoO1xuICAgICAgc3RhdGUubW9kZSA9IERJU1Q7XG4gICAgICAvKiBmYWxscyB0aHJvdWdoICovXG4gICAgY2FzZSBESVNUOlxuICAgICAgZm9yICg7Oykge1xuICAgICAgICBoZXJlID0gc3RhdGUuZGlzdGNvZGVbaG9sZCAmICgoMSA8PCBzdGF0ZS5kaXN0Yml0cykgLTEpXTsvKkJJVFMoc3RhdGUuZGlzdGJpdHMpKi9cbiAgICAgICAgaGVyZV9iaXRzID0gaGVyZSA+Pj4gMjQ7XG4gICAgICAgIGhlcmVfb3AgPSAoaGVyZSA+Pj4gMTYpICYgMHhmZjtcbiAgICAgICAgaGVyZV92YWwgPSBoZXJlICYgMHhmZmZmO1xuXG4gICAgICAgIGlmICgoaGVyZV9iaXRzKSA8PSBiaXRzKSB7IGJyZWFrOyB9XG4gICAgICAgIC8vLS0tIFBVTExCWVRFKCkgLS0tLy9cbiAgICAgICAgaWYgKGhhdmUgPT09IDApIHsgYnJlYWsgaW5mX2xlYXZlOyB9XG4gICAgICAgIGhhdmUtLTtcbiAgICAgICAgaG9sZCArPSBpbnB1dFtuZXh0KytdIDw8IGJpdHM7XG4gICAgICAgIGJpdHMgKz0gODtcbiAgICAgICAgLy8tLS0vL1xuICAgICAgfVxuICAgICAgaWYgKChoZXJlX29wICYgMHhmMCkgPT09IDApIHtcbiAgICAgICAgbGFzdF9iaXRzID0gaGVyZV9iaXRzO1xuICAgICAgICBsYXN0X29wID0gaGVyZV9vcDtcbiAgICAgICAgbGFzdF92YWwgPSBoZXJlX3ZhbDtcbiAgICAgICAgZm9yICg7Oykge1xuICAgICAgICAgIGhlcmUgPSBzdGF0ZS5kaXN0Y29kZVtsYXN0X3ZhbCArXG4gICAgICAgICAgICAgICAgICAoKGhvbGQgJiAoKDEgPDwgKGxhc3RfYml0cyArIGxhc3Rfb3ApKSAtMSkpLypCSVRTKGxhc3QuYml0cyArIGxhc3Qub3ApKi8gPj4gbGFzdF9iaXRzKV07XG4gICAgICAgICAgaGVyZV9iaXRzID0gaGVyZSA+Pj4gMjQ7XG4gICAgICAgICAgaGVyZV9vcCA9IChoZXJlID4+PiAxNikgJiAweGZmO1xuICAgICAgICAgIGhlcmVfdmFsID0gaGVyZSAmIDB4ZmZmZjtcblxuICAgICAgICAgIGlmICgobGFzdF9iaXRzICsgaGVyZV9iaXRzKSA8PSBiaXRzKSB7IGJyZWFrOyB9XG4gICAgICAgICAgLy8tLS0gUFVMTEJZVEUoKSAtLS0vL1xuICAgICAgICAgIGlmIChoYXZlID09PSAwKSB7IGJyZWFrIGluZl9sZWF2ZTsgfVxuICAgICAgICAgIGhhdmUtLTtcbiAgICAgICAgICBob2xkICs9IGlucHV0W25leHQrK10gPDwgYml0cztcbiAgICAgICAgICBiaXRzICs9IDg7XG4gICAgICAgICAgLy8tLS0vL1xuICAgICAgICB9XG4gICAgICAgIC8vLS0tIERST1BCSVRTKGxhc3QuYml0cykgLS0tLy9cbiAgICAgICAgaG9sZCA+Pj49IGxhc3RfYml0cztcbiAgICAgICAgYml0cyAtPSBsYXN0X2JpdHM7XG4gICAgICAgIC8vLS0tLy9cbiAgICAgICAgc3RhdGUuYmFjayArPSBsYXN0X2JpdHM7XG4gICAgICB9XG4gICAgICAvLy0tLSBEUk9QQklUUyhoZXJlLmJpdHMpIC0tLS8vXG4gICAgICBob2xkID4+Pj0gaGVyZV9iaXRzO1xuICAgICAgYml0cyAtPSBoZXJlX2JpdHM7XG4gICAgICAvLy0tLS8vXG4gICAgICBzdGF0ZS5iYWNrICs9IGhlcmVfYml0cztcbiAgICAgIGlmIChoZXJlX29wICYgNjQpIHtcbiAgICAgICAgc3RybS5tc2cgPSAnaW52YWxpZCBkaXN0YW5jZSBjb2RlJztcbiAgICAgICAgc3RhdGUubW9kZSA9IEJBRDtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBzdGF0ZS5vZmZzZXQgPSBoZXJlX3ZhbDtcbiAgICAgIHN0YXRlLmV4dHJhID0gKGhlcmVfb3ApICYgMTU7XG4gICAgICBzdGF0ZS5tb2RlID0gRElTVEVYVDtcbiAgICAgIC8qIGZhbGxzIHRocm91Z2ggKi9cbiAgICBjYXNlIERJU1RFWFQ6XG4gICAgICBpZiAoc3RhdGUuZXh0cmEpIHtcbiAgICAgICAgLy89PT0gTkVFREJJVFMoc3RhdGUuZXh0cmEpO1xuICAgICAgICBuID0gc3RhdGUuZXh0cmE7XG4gICAgICAgIHdoaWxlIChiaXRzIDwgbikge1xuICAgICAgICAgIGlmIChoYXZlID09PSAwKSB7IGJyZWFrIGluZl9sZWF2ZTsgfVxuICAgICAgICAgIGhhdmUtLTtcbiAgICAgICAgICBob2xkICs9IGlucHV0W25leHQrK10gPDwgYml0cztcbiAgICAgICAgICBiaXRzICs9IDg7XG4gICAgICAgIH1cbiAgICAgICAgLy89PT0vL1xuICAgICAgICBzdGF0ZS5vZmZzZXQgKz0gaG9sZCAmICgoMSA8PCBzdGF0ZS5leHRyYSkgLTEpLypCSVRTKHN0YXRlLmV4dHJhKSovO1xuICAgICAgICAvLy0tLSBEUk9QQklUUyhzdGF0ZS5leHRyYSkgLS0tLy9cbiAgICAgICAgaG9sZCA+Pj49IHN0YXRlLmV4dHJhO1xuICAgICAgICBiaXRzIC09IHN0YXRlLmV4dHJhO1xuICAgICAgICAvLy0tLS8vXG4gICAgICAgIHN0YXRlLmJhY2sgKz0gc3RhdGUuZXh0cmE7XG4gICAgICB9XG4vLyNpZmRlZiBJTkZMQVRFX1NUUklDVFxuICAgICAgaWYgKHN0YXRlLm9mZnNldCA+IHN0YXRlLmRtYXgpIHtcbiAgICAgICAgc3RybS5tc2cgPSAnaW52YWxpZCBkaXN0YW5jZSB0b28gZmFyIGJhY2snO1xuICAgICAgICBzdGF0ZS5tb2RlID0gQkFEO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbi8vI2VuZGlmXG4gICAgICAvL1RyYWNldnYoKHN0ZGVyciwgXCJpbmZsYXRlOiAgICAgICAgIGRpc3RhbmNlICV1XFxuXCIsIHN0YXRlLm9mZnNldCkpO1xuICAgICAgc3RhdGUubW9kZSA9IE1BVENIO1xuICAgICAgLyogZmFsbHMgdGhyb3VnaCAqL1xuICAgIGNhc2UgTUFUQ0g6XG4gICAgICBpZiAobGVmdCA9PT0gMCkgeyBicmVhayBpbmZfbGVhdmU7IH1cbiAgICAgIGNvcHkgPSBfb3V0IC0gbGVmdDtcbiAgICAgIGlmIChzdGF0ZS5vZmZzZXQgPiBjb3B5KSB7ICAgICAgICAgLyogY29weSBmcm9tIHdpbmRvdyAqL1xuICAgICAgICBjb3B5ID0gc3RhdGUub2Zmc2V0IC0gY29weTtcbiAgICAgICAgaWYgKGNvcHkgPiBzdGF0ZS53aGF2ZSkge1xuICAgICAgICAgIGlmIChzdGF0ZS5zYW5lKSB7XG4gICAgICAgICAgICBzdHJtLm1zZyA9ICdpbnZhbGlkIGRpc3RhbmNlIHRvbyBmYXIgYmFjayc7XG4gICAgICAgICAgICBzdGF0ZS5tb2RlID0gQkFEO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuLy8gKCEpIFRoaXMgYmxvY2sgaXMgZGlzYWJsZWQgaW4gemxpYiBkZWZhaWx0cyxcbi8vIGRvbid0IGVuYWJsZSBpdCBmb3IgYmluYXJ5IGNvbXBhdGliaWxpdHlcbi8vI2lmZGVmIElORkxBVEVfQUxMT1dfSU5WQUxJRF9ESVNUQU5DRV9UT09GQVJfQVJSUlxuLy8gICAgICAgICAgVHJhY2UoKHN0ZGVyciwgXCJpbmZsYXRlLmMgdG9vIGZhclxcblwiKSk7XG4vLyAgICAgICAgICBjb3B5IC09IHN0YXRlLndoYXZlO1xuLy8gICAgICAgICAgaWYgKGNvcHkgPiBzdGF0ZS5sZW5ndGgpIHsgY29weSA9IHN0YXRlLmxlbmd0aDsgfVxuLy8gICAgICAgICAgaWYgKGNvcHkgPiBsZWZ0KSB7IGNvcHkgPSBsZWZ0OyB9XG4vLyAgICAgICAgICBsZWZ0IC09IGNvcHk7XG4vLyAgICAgICAgICBzdGF0ZS5sZW5ndGggLT0gY29weTtcbi8vICAgICAgICAgIGRvIHtcbi8vICAgICAgICAgICAgb3V0cHV0W3B1dCsrXSA9IDA7XG4vLyAgICAgICAgICB9IHdoaWxlICgtLWNvcHkpO1xuLy8gICAgICAgICAgaWYgKHN0YXRlLmxlbmd0aCA9PT0gMCkgeyBzdGF0ZS5tb2RlID0gTEVOOyB9XG4vLyAgICAgICAgICBicmVhaztcbi8vI2VuZGlmXG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNvcHkgPiBzdGF0ZS53bmV4dCkge1xuICAgICAgICAgIGNvcHkgLT0gc3RhdGUud25leHQ7XG4gICAgICAgICAgZnJvbSA9IHN0YXRlLndzaXplIC0gY29weTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICBmcm9tID0gc3RhdGUud25leHQgLSBjb3B5O1xuICAgICAgICB9XG4gICAgICAgIGlmIChjb3B5ID4gc3RhdGUubGVuZ3RoKSB7IGNvcHkgPSBzdGF0ZS5sZW5ndGg7IH1cbiAgICAgICAgZnJvbV9zb3VyY2UgPSBzdGF0ZS53aW5kb3c7XG4gICAgICB9XG4gICAgICBlbHNlIHsgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvKiBjb3B5IGZyb20gb3V0cHV0ICovXG4gICAgICAgIGZyb21fc291cmNlID0gb3V0cHV0O1xuICAgICAgICBmcm9tID0gcHV0IC0gc3RhdGUub2Zmc2V0O1xuICAgICAgICBjb3B5ID0gc3RhdGUubGVuZ3RoO1xuICAgICAgfVxuICAgICAgaWYgKGNvcHkgPiBsZWZ0KSB7IGNvcHkgPSBsZWZ0OyB9XG4gICAgICBsZWZ0IC09IGNvcHk7XG4gICAgICBzdGF0ZS5sZW5ndGggLT0gY29weTtcbiAgICAgIGRvIHtcbiAgICAgICAgb3V0cHV0W3B1dCsrXSA9IGZyb21fc291cmNlW2Zyb20rK107XG4gICAgICB9IHdoaWxlICgtLWNvcHkpO1xuICAgICAgaWYgKHN0YXRlLmxlbmd0aCA9PT0gMCkgeyBzdGF0ZS5tb2RlID0gTEVOOyB9XG4gICAgICBicmVhaztcbiAgICBjYXNlIExJVDpcbiAgICAgIGlmIChsZWZ0ID09PSAwKSB7IGJyZWFrIGluZl9sZWF2ZTsgfVxuICAgICAgb3V0cHV0W3B1dCsrXSA9IHN0YXRlLmxlbmd0aDtcbiAgICAgIGxlZnQtLTtcbiAgICAgIHN0YXRlLm1vZGUgPSBMRU47XG4gICAgICBicmVhaztcbiAgICBjYXNlIENIRUNLOlxuICAgICAgaWYgKHN0YXRlLndyYXApIHtcbiAgICAgICAgLy89PT0gTkVFREJJVFMoMzIpO1xuICAgICAgICB3aGlsZSAoYml0cyA8IDMyKSB7XG4gICAgICAgICAgaWYgKGhhdmUgPT09IDApIHsgYnJlYWsgaW5mX2xlYXZlOyB9XG4gICAgICAgICAgaGF2ZS0tO1xuICAgICAgICAgIC8vIFVzZSAnfCcgaW5zZGVhZCBvZiAnKycgdG8gbWFrZSBzdXJlIHRoYXQgcmVzdWx0IGlzIHNpZ25lZFxuICAgICAgICAgIGhvbGQgfD0gaW5wdXRbbmV4dCsrXSA8PCBiaXRzO1xuICAgICAgICAgIGJpdHMgKz0gODtcbiAgICAgICAgfVxuICAgICAgICAvLz09PS8vXG4gICAgICAgIF9vdXQgLT0gbGVmdDtcbiAgICAgICAgc3RybS50b3RhbF9vdXQgKz0gX291dDtcbiAgICAgICAgc3RhdGUudG90YWwgKz0gX291dDtcbiAgICAgICAgaWYgKF9vdXQpIHtcbiAgICAgICAgICBzdHJtLmFkbGVyID0gc3RhdGUuY2hlY2sgPVxuICAgICAgICAgICAgICAvKlVQREFURShzdGF0ZS5jaGVjaywgcHV0IC0gX291dCwgX291dCk7Ki9cbiAgICAgICAgICAgICAgKHN0YXRlLmZsYWdzID8gY3JjMzIoc3RhdGUuY2hlY2ssIG91dHB1dCwgX291dCwgcHV0IC0gX291dCkgOiBhZGxlcjMyKHN0YXRlLmNoZWNrLCBvdXRwdXQsIF9vdXQsIHB1dCAtIF9vdXQpKTtcblxuICAgICAgICB9XG4gICAgICAgIF9vdXQgPSBsZWZ0O1xuICAgICAgICAvLyBOQjogY3JjMzIgc3RvcmVkIGFzIHNpZ25lZCAzMi1iaXQgaW50LCBaU1dBUDMyIHJldHVybnMgc2lnbmVkIHRvb1xuICAgICAgICBpZiAoKHN0YXRlLmZsYWdzID8gaG9sZCA6IFpTV0FQMzIoaG9sZCkpICE9PSBzdGF0ZS5jaGVjaykge1xuICAgICAgICAgIHN0cm0ubXNnID0gJ2luY29ycmVjdCBkYXRhIGNoZWNrJztcbiAgICAgICAgICBzdGF0ZS5tb2RlID0gQkFEO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIC8vPT09IElOSVRCSVRTKCk7XG4gICAgICAgIGhvbGQgPSAwO1xuICAgICAgICBiaXRzID0gMDtcbiAgICAgICAgLy89PT0vL1xuICAgICAgICAvL1RyYWNldigoc3RkZXJyLCBcImluZmxhdGU6ICAgY2hlY2sgbWF0Y2hlcyB0cmFpbGVyXFxuXCIpKTtcbiAgICAgIH1cbiAgICAgIHN0YXRlLm1vZGUgPSBMRU5HVEg7XG4gICAgICAvKiBmYWxscyB0aHJvdWdoICovXG4gICAgY2FzZSBMRU5HVEg6XG4gICAgICBpZiAoc3RhdGUud3JhcCAmJiBzdGF0ZS5mbGFncykge1xuICAgICAgICAvLz09PSBORUVEQklUUygzMik7XG4gICAgICAgIHdoaWxlIChiaXRzIDwgMzIpIHtcbiAgICAgICAgICBpZiAoaGF2ZSA9PT0gMCkgeyBicmVhayBpbmZfbGVhdmU7IH1cbiAgICAgICAgICBoYXZlLS07XG4gICAgICAgICAgaG9sZCArPSBpbnB1dFtuZXh0KytdIDw8IGJpdHM7XG4gICAgICAgICAgYml0cyArPSA4O1xuICAgICAgICB9XG4gICAgICAgIC8vPT09Ly9cbiAgICAgICAgaWYgKGhvbGQgIT09IChzdGF0ZS50b3RhbCAmIDB4ZmZmZmZmZmYpKSB7XG4gICAgICAgICAgc3RybS5tc2cgPSAnaW5jb3JyZWN0IGxlbmd0aCBjaGVjayc7XG4gICAgICAgICAgc3RhdGUubW9kZSA9IEJBRDtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICAvLz09PSBJTklUQklUUygpO1xuICAgICAgICBob2xkID0gMDtcbiAgICAgICAgYml0cyA9IDA7XG4gICAgICAgIC8vPT09Ly9cbiAgICAgICAgLy9UcmFjZXYoKHN0ZGVyciwgXCJpbmZsYXRlOiAgIGxlbmd0aCBtYXRjaGVzIHRyYWlsZXJcXG5cIikpO1xuICAgICAgfVxuICAgICAgc3RhdGUubW9kZSA9IERPTkU7XG4gICAgICAvKiBmYWxscyB0aHJvdWdoICovXG4gICAgY2FzZSBET05FOlxuICAgICAgcmV0ID0gWl9TVFJFQU1fRU5EO1xuICAgICAgYnJlYWsgaW5mX2xlYXZlO1xuICAgIGNhc2UgQkFEOlxuICAgICAgcmV0ID0gWl9EQVRBX0VSUk9SO1xuICAgICAgYnJlYWsgaW5mX2xlYXZlO1xuICAgIGNhc2UgTUVNOlxuICAgICAgcmV0dXJuIFpfTUVNX0VSUk9SO1xuICAgIGNhc2UgU1lOQzpcbiAgICAgIC8qIGZhbGxzIHRocm91Z2ggKi9cbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIFpfU1RSRUFNX0VSUk9SO1xuICAgIH1cbiAgfVxuXG4gIC8vIGluZl9sZWF2ZSA8LSBoZXJlIGlzIHJlYWwgcGxhY2UgZm9yIFwiZ290byBpbmZfbGVhdmVcIiwgZW11bGF0ZWQgdmlhIFwiYnJlYWsgaW5mX2xlYXZlXCJcblxuICAvKlxuICAgICBSZXR1cm4gZnJvbSBpbmZsYXRlKCksIHVwZGF0aW5nIHRoZSB0b3RhbCBjb3VudHMgYW5kIHRoZSBjaGVjayB2YWx1ZS5cbiAgICAgSWYgdGhlcmUgd2FzIG5vIHByb2dyZXNzIGR1cmluZyB0aGUgaW5mbGF0ZSgpIGNhbGwsIHJldHVybiBhIGJ1ZmZlclxuICAgICBlcnJvci4gIENhbGwgdXBkYXRld2luZG93KCkgdG8gY3JlYXRlIGFuZC9vciB1cGRhdGUgdGhlIHdpbmRvdyBzdGF0ZS5cbiAgICAgTm90ZTogYSBtZW1vcnkgZXJyb3IgZnJvbSBpbmZsYXRlKCkgaXMgbm9uLXJlY292ZXJhYmxlLlxuICAgKi9cblxuICAvLy0tLSBSRVNUT1JFKCkgLS0tXG4gIHN0cm0ubmV4dF9vdXQgPSBwdXQ7XG4gIHN0cm0uYXZhaWxfb3V0ID0gbGVmdDtcbiAgc3RybS5uZXh0X2luID0gbmV4dDtcbiAgc3RybS5hdmFpbF9pbiA9IGhhdmU7XG4gIHN0YXRlLmhvbGQgPSBob2xkO1xuICBzdGF0ZS5iaXRzID0gYml0cztcbiAgLy8tLS1cblxuICBpZiAoc3RhdGUud3NpemUgfHwgKF9vdXQgIT09IHN0cm0uYXZhaWxfb3V0ICYmIHN0YXRlLm1vZGUgPCBCQUQgJiZcbiAgICAgICAgICAgICAgICAgICAgICAoc3RhdGUubW9kZSA8IENIRUNLIHx8IGZsdXNoICE9PSBaX0ZJTklTSCkpKSB7XG4gICAgaWYgKHVwZGF0ZXdpbmRvdyhzdHJtLCBzdHJtLm91dHB1dCwgc3RybS5uZXh0X291dCwgX291dCAtIHN0cm0uYXZhaWxfb3V0KSkge1xuICAgICAgc3RhdGUubW9kZSA9IE1FTTtcbiAgICAgIHJldHVybiBaX01FTV9FUlJPUjtcbiAgICB9XG4gIH1cbiAgX2luIC09IHN0cm0uYXZhaWxfaW47XG4gIF9vdXQgLT0gc3RybS5hdmFpbF9vdXQ7XG4gIHN0cm0udG90YWxfaW4gKz0gX2luO1xuICBzdHJtLnRvdGFsX291dCArPSBfb3V0O1xuICBzdGF0ZS50b3RhbCArPSBfb3V0O1xuICBpZiAoc3RhdGUud3JhcCAmJiBfb3V0KSB7XG4gICAgc3RybS5hZGxlciA9IHN0YXRlLmNoZWNrID0gLypVUERBVEUoc3RhdGUuY2hlY2ssIHN0cm0ubmV4dF9vdXQgLSBfb3V0LCBfb3V0KTsqL1xuICAgICAgKHN0YXRlLmZsYWdzID8gY3JjMzIoc3RhdGUuY2hlY2ssIG91dHB1dCwgX291dCwgc3RybS5uZXh0X291dCAtIF9vdXQpIDogYWRsZXIzMihzdGF0ZS5jaGVjaywgb3V0cHV0LCBfb3V0LCBzdHJtLm5leHRfb3V0IC0gX291dCkpO1xuICB9XG4gIHN0cm0uZGF0YV90eXBlID0gc3RhdGUuYml0cyArIChzdGF0ZS5sYXN0ID8gNjQgOiAwKSArXG4gICAgICAgICAgICAgICAgICAgIChzdGF0ZS5tb2RlID09PSBUWVBFID8gMTI4IDogMCkgK1xuICAgICAgICAgICAgICAgICAgICAoc3RhdGUubW9kZSA9PT0gTEVOXyB8fCBzdGF0ZS5tb2RlID09PSBDT1BZXyA/IDI1NiA6IDApO1xuICBpZiAoKChfaW4gPT09IDAgJiYgX291dCA9PT0gMCkgfHwgZmx1c2ggPT09IFpfRklOSVNIKSAmJiByZXQgPT09IFpfT0spIHtcbiAgICByZXQgPSBaX0JVRl9FUlJPUjtcbiAgfVxuICByZXR1cm4gcmV0O1xufVxuXG5mdW5jdGlvbiBpbmZsYXRlRW5kKHN0cm0pIHtcblxuICBpZiAoIXN0cm0gfHwgIXN0cm0uc3RhdGUgLyp8fCBzdHJtLT56ZnJlZSA9PSAoZnJlZV9mdW5jKTAqLykge1xuICAgIHJldHVybiBaX1NUUkVBTV9FUlJPUjtcbiAgfVxuXG4gIHZhciBzdGF0ZSA9IHN0cm0uc3RhdGU7XG4gIGlmIChzdGF0ZS53aW5kb3cpIHtcbiAgICBzdGF0ZS53aW5kb3cgPSBudWxsO1xuICB9XG4gIHN0cm0uc3RhdGUgPSBudWxsO1xuICByZXR1cm4gWl9PSztcbn1cblxuZnVuY3Rpb24gaW5mbGF0ZUdldEhlYWRlcihzdHJtLCBoZWFkKSB7XG4gIHZhciBzdGF0ZTtcblxuICAvKiBjaGVjayBzdGF0ZSAqL1xuICBpZiAoIXN0cm0gfHwgIXN0cm0uc3RhdGUpIHsgcmV0dXJuIFpfU1RSRUFNX0VSUk9SOyB9XG4gIHN0YXRlID0gc3RybS5zdGF0ZTtcbiAgaWYgKChzdGF0ZS53cmFwICYgMikgPT09IDApIHsgcmV0dXJuIFpfU1RSRUFNX0VSUk9SOyB9XG5cbiAgLyogc2F2ZSBoZWFkZXIgc3RydWN0dXJlICovXG4gIHN0YXRlLmhlYWQgPSBoZWFkO1xuICBoZWFkLmRvbmUgPSBmYWxzZTtcbiAgcmV0dXJuIFpfT0s7XG59XG5cblxuZXhwb3J0cy5pbmZsYXRlUmVzZXQgPSBpbmZsYXRlUmVzZXQ7XG5leHBvcnRzLmluZmxhdGVSZXNldDIgPSBpbmZsYXRlUmVzZXQyO1xuZXhwb3J0cy5pbmZsYXRlUmVzZXRLZWVwID0gaW5mbGF0ZVJlc2V0S2VlcDtcbmV4cG9ydHMuaW5mbGF0ZUluaXQgPSBpbmZsYXRlSW5pdDtcbmV4cG9ydHMuaW5mbGF0ZUluaXQyID0gaW5mbGF0ZUluaXQyO1xuZXhwb3J0cy5pbmZsYXRlID0gaW5mbGF0ZTtcbmV4cG9ydHMuaW5mbGF0ZUVuZCA9IGluZmxhdGVFbmQ7XG5leHBvcnRzLmluZmxhdGVHZXRIZWFkZXIgPSBpbmZsYXRlR2V0SGVhZGVyO1xuZXhwb3J0cy5pbmZsYXRlSW5mbyA9ICdwYWtvIGluZmxhdGUgKGZyb20gTm9kZWNhIHByb2plY3QpJztcblxuLyogTm90IGltcGxlbWVudGVkXG5leHBvcnRzLmluZmxhdGVDb3B5ID0gaW5mbGF0ZUNvcHk7XG5leHBvcnRzLmluZmxhdGVHZXREaWN0aW9uYXJ5ID0gaW5mbGF0ZUdldERpY3Rpb25hcnk7XG5leHBvcnRzLmluZmxhdGVNYXJrID0gaW5mbGF0ZU1hcms7XG5leHBvcnRzLmluZmxhdGVQcmltZSA9IGluZmxhdGVQcmltZTtcbmV4cG9ydHMuaW5mbGF0ZVNldERpY3Rpb25hcnkgPSBpbmZsYXRlU2V0RGljdGlvbmFyeTtcbmV4cG9ydHMuaW5mbGF0ZVN5bmMgPSBpbmZsYXRlU3luYztcbmV4cG9ydHMuaW5mbGF0ZVN5bmNQb2ludCA9IGluZmxhdGVTeW5jUG9pbnQ7XG5leHBvcnRzLmluZmxhdGVVbmRlcm1pbmUgPSBpbmZsYXRlVW5kZXJtaW5lO1xuKi9cbiIsIid1c2Ugc3RyaWN0JztcblxuXG52YXIgdXRpbHMgPSByZXF1aXJlKCcuLi91dGlscy9jb21tb24nKTtcblxudmFyIE1BWEJJVFMgPSAxNTtcbnZhciBFTk9VR0hfTEVOUyA9IDg1MjtcbnZhciBFTk9VR0hfRElTVFMgPSA1OTI7XG4vL3ZhciBFTk9VR0ggPSAoRU5PVUdIX0xFTlMrRU5PVUdIX0RJU1RTKTtcblxudmFyIENPREVTID0gMDtcbnZhciBMRU5TID0gMTtcbnZhciBESVNUUyA9IDI7XG5cbnZhciBsYmFzZSA9IFsgLyogTGVuZ3RoIGNvZGVzIDI1Ny4uMjg1IGJhc2UgKi9cbiAgMywgNCwgNSwgNiwgNywgOCwgOSwgMTAsIDExLCAxMywgMTUsIDE3LCAxOSwgMjMsIDI3LCAzMSxcbiAgMzUsIDQzLCA1MSwgNTksIDY3LCA4MywgOTksIDExNSwgMTMxLCAxNjMsIDE5NSwgMjI3LCAyNTgsIDAsIDBcbl07XG5cbnZhciBsZXh0ID0gWyAvKiBMZW5ndGggY29kZXMgMjU3Li4yODUgZXh0cmEgKi9cbiAgMTYsIDE2LCAxNiwgMTYsIDE2LCAxNiwgMTYsIDE2LCAxNywgMTcsIDE3LCAxNywgMTgsIDE4LCAxOCwgMTgsXG4gIDE5LCAxOSwgMTksIDE5LCAyMCwgMjAsIDIwLCAyMCwgMjEsIDIxLCAyMSwgMjEsIDE2LCA3MiwgNzhcbl07XG5cbnZhciBkYmFzZSA9IFsgLyogRGlzdGFuY2UgY29kZXMgMC4uMjkgYmFzZSAqL1xuICAxLCAyLCAzLCA0LCA1LCA3LCA5LCAxMywgMTcsIDI1LCAzMywgNDksIDY1LCA5NywgMTI5LCAxOTMsXG4gIDI1NywgMzg1LCA1MTMsIDc2OSwgMTAyNSwgMTUzNywgMjA0OSwgMzA3MywgNDA5NywgNjE0NSxcbiAgODE5MywgMTIyODksIDE2Mzg1LCAyNDU3NywgMCwgMFxuXTtcblxudmFyIGRleHQgPSBbIC8qIERpc3RhbmNlIGNvZGVzIDAuLjI5IGV4dHJhICovXG4gIDE2LCAxNiwgMTYsIDE2LCAxNywgMTcsIDE4LCAxOCwgMTksIDE5LCAyMCwgMjAsIDIxLCAyMSwgMjIsIDIyLFxuICAyMywgMjMsIDI0LCAyNCwgMjUsIDI1LCAyNiwgMjYsIDI3LCAyNyxcbiAgMjgsIDI4LCAyOSwgMjksIDY0LCA2NFxuXTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBpbmZsYXRlX3RhYmxlKHR5cGUsIGxlbnMsIGxlbnNfaW5kZXgsIGNvZGVzLCB0YWJsZSwgdGFibGVfaW5kZXgsIHdvcmssIG9wdHMpXG57XG4gIHZhciBiaXRzID0gb3B0cy5iaXRzO1xuICAgICAgLy9oZXJlID0gb3B0cy5oZXJlOyAvKiB0YWJsZSBlbnRyeSBmb3IgZHVwbGljYXRpb24gKi9cblxuICB2YXIgbGVuID0gMDsgICAgICAgICAgICAgICAvKiBhIGNvZGUncyBsZW5ndGggaW4gYml0cyAqL1xuICB2YXIgc3ltID0gMDsgICAgICAgICAgICAgICAvKiBpbmRleCBvZiBjb2RlIHN5bWJvbHMgKi9cbiAgdmFyIG1pbiA9IDAsIG1heCA9IDA7ICAgICAgICAgIC8qIG1pbmltdW0gYW5kIG1heGltdW0gY29kZSBsZW5ndGhzICovXG4gIHZhciByb290ID0gMDsgICAgICAgICAgICAgIC8qIG51bWJlciBvZiBpbmRleCBiaXRzIGZvciByb290IHRhYmxlICovXG4gIHZhciBjdXJyID0gMDsgICAgICAgICAgICAgIC8qIG51bWJlciBvZiBpbmRleCBiaXRzIGZvciBjdXJyZW50IHRhYmxlICovXG4gIHZhciBkcm9wID0gMDsgICAgICAgICAgICAgIC8qIGNvZGUgYml0cyB0byBkcm9wIGZvciBzdWItdGFibGUgKi9cbiAgdmFyIGxlZnQgPSAwOyAgICAgICAgICAgICAgICAgICAvKiBudW1iZXIgb2YgcHJlZml4IGNvZGVzIGF2YWlsYWJsZSAqL1xuICB2YXIgdXNlZCA9IDA7ICAgICAgICAgICAgICAvKiBjb2RlIGVudHJpZXMgaW4gdGFibGUgdXNlZCAqL1xuICB2YXIgaHVmZiA9IDA7ICAgICAgICAgICAgICAvKiBIdWZmbWFuIGNvZGUgKi9cbiAgdmFyIGluY3I7ICAgICAgICAgICAgICAvKiBmb3IgaW5jcmVtZW50aW5nIGNvZGUsIGluZGV4ICovXG4gIHZhciBmaWxsOyAgICAgICAgICAgICAgLyogaW5kZXggZm9yIHJlcGxpY2F0aW5nIGVudHJpZXMgKi9cbiAgdmFyIGxvdzsgICAgICAgICAgICAgICAvKiBsb3cgYml0cyBmb3IgY3VycmVudCByb290IGVudHJ5ICovXG4gIHZhciBtYXNrOyAgICAgICAgICAgICAgLyogbWFzayBmb3IgbG93IHJvb3QgYml0cyAqL1xuICB2YXIgbmV4dDsgICAgICAgICAgICAgLyogbmV4dCBhdmFpbGFibGUgc3BhY2UgaW4gdGFibGUgKi9cbiAgdmFyIGJhc2UgPSBudWxsOyAgICAgLyogYmFzZSB2YWx1ZSB0YWJsZSB0byB1c2UgKi9cbiAgdmFyIGJhc2VfaW5kZXggPSAwO1xuLy8gIHZhciBzaG9leHRyYTsgICAgLyogZXh0cmEgYml0cyB0YWJsZSB0byB1c2UgKi9cbiAgdmFyIGVuZDsgICAgICAgICAgICAgICAgICAgIC8qIHVzZSBiYXNlIGFuZCBleHRyYSBmb3Igc3ltYm9sID4gZW5kICovXG4gIHZhciBjb3VudCA9IG5ldyB1dGlscy5CdWYxNihNQVhCSVRTKzEpOyAvL1tNQVhCSVRTKzFdOyAgICAvKiBudW1iZXIgb2YgY29kZXMgb2YgZWFjaCBsZW5ndGggKi9cbiAgdmFyIG9mZnMgPSBuZXcgdXRpbHMuQnVmMTYoTUFYQklUUysxKTsgLy9bTUFYQklUUysxXTsgICAgIC8qIG9mZnNldHMgaW4gdGFibGUgZm9yIGVhY2ggbGVuZ3RoICovXG4gIHZhciBleHRyYSA9IG51bGw7XG4gIHZhciBleHRyYV9pbmRleCA9IDA7XG5cbiAgdmFyIGhlcmVfYml0cywgaGVyZV9vcCwgaGVyZV92YWw7XG5cbiAgLypcbiAgIFByb2Nlc3MgYSBzZXQgb2YgY29kZSBsZW5ndGhzIHRvIGNyZWF0ZSBhIGNhbm9uaWNhbCBIdWZmbWFuIGNvZGUuICBUaGVcbiAgIGNvZGUgbGVuZ3RocyBhcmUgbGVuc1swLi5jb2Rlcy0xXS4gIEVhY2ggbGVuZ3RoIGNvcnJlc3BvbmRzIHRvIHRoZVxuICAgc3ltYm9scyAwLi5jb2Rlcy0xLiAgVGhlIEh1ZmZtYW4gY29kZSBpcyBnZW5lcmF0ZWQgYnkgZmlyc3Qgc29ydGluZyB0aGVcbiAgIHN5bWJvbHMgYnkgbGVuZ3RoIGZyb20gc2hvcnQgdG8gbG9uZywgYW5kIHJldGFpbmluZyB0aGUgc3ltYm9sIG9yZGVyXG4gICBmb3IgY29kZXMgd2l0aCBlcXVhbCBsZW5ndGhzLiAgVGhlbiB0aGUgY29kZSBzdGFydHMgd2l0aCBhbGwgemVybyBiaXRzXG4gICBmb3IgdGhlIGZpcnN0IGNvZGUgb2YgdGhlIHNob3J0ZXN0IGxlbmd0aCwgYW5kIHRoZSBjb2RlcyBhcmUgaW50ZWdlclxuICAgaW5jcmVtZW50cyBmb3IgdGhlIHNhbWUgbGVuZ3RoLCBhbmQgemVyb3MgYXJlIGFwcGVuZGVkIGFzIHRoZSBsZW5ndGhcbiAgIGluY3JlYXNlcy4gIEZvciB0aGUgZGVmbGF0ZSBmb3JtYXQsIHRoZXNlIGJpdHMgYXJlIHN0b3JlZCBiYWNrd2FyZHNcbiAgIGZyb20gdGhlaXIgbW9yZSBuYXR1cmFsIGludGVnZXIgaW5jcmVtZW50IG9yZGVyaW5nLCBhbmQgc28gd2hlbiB0aGVcbiAgIGRlY29kaW5nIHRhYmxlcyBhcmUgYnVpbHQgaW4gdGhlIGxhcmdlIGxvb3AgYmVsb3csIHRoZSBpbnRlZ2VyIGNvZGVzXG4gICBhcmUgaW5jcmVtZW50ZWQgYmFja3dhcmRzLlxuXG4gICBUaGlzIHJvdXRpbmUgYXNzdW1lcywgYnV0IGRvZXMgbm90IGNoZWNrLCB0aGF0IGFsbCBvZiB0aGUgZW50cmllcyBpblxuICAgbGVuc1tdIGFyZSBpbiB0aGUgcmFuZ2UgMC4uTUFYQklUUy4gIFRoZSBjYWxsZXIgbXVzdCBhc3N1cmUgdGhpcy5cbiAgIDEuLk1BWEJJVFMgaXMgaW50ZXJwcmV0ZWQgYXMgdGhhdCBjb2RlIGxlbmd0aC4gIHplcm8gbWVhbnMgdGhhdCB0aGF0XG4gICBzeW1ib2wgZG9lcyBub3Qgb2NjdXIgaW4gdGhpcyBjb2RlLlxuXG4gICBUaGUgY29kZXMgYXJlIHNvcnRlZCBieSBjb21wdXRpbmcgYSBjb3VudCBvZiBjb2RlcyBmb3IgZWFjaCBsZW5ndGgsXG4gICBjcmVhdGluZyBmcm9tIHRoYXQgYSB0YWJsZSBvZiBzdGFydGluZyBpbmRpY2VzIGZvciBlYWNoIGxlbmd0aCBpbiB0aGVcbiAgIHNvcnRlZCB0YWJsZSwgYW5kIHRoZW4gZW50ZXJpbmcgdGhlIHN5bWJvbHMgaW4gb3JkZXIgaW4gdGhlIHNvcnRlZFxuICAgdGFibGUuICBUaGUgc29ydGVkIHRhYmxlIGlzIHdvcmtbXSwgd2l0aCB0aGF0IHNwYWNlIGJlaW5nIHByb3ZpZGVkIGJ5XG4gICB0aGUgY2FsbGVyLlxuXG4gICBUaGUgbGVuZ3RoIGNvdW50cyBhcmUgdXNlZCBmb3Igb3RoZXIgcHVycG9zZXMgYXMgd2VsbCwgaS5lLiBmaW5kaW5nXG4gICB0aGUgbWluaW11bSBhbmQgbWF4aW11bSBsZW5ndGggY29kZXMsIGRldGVybWluaW5nIGlmIHRoZXJlIGFyZSBhbnlcbiAgIGNvZGVzIGF0IGFsbCwgY2hlY2tpbmcgZm9yIGEgdmFsaWQgc2V0IG9mIGxlbmd0aHMsIGFuZCBsb29raW5nIGFoZWFkXG4gICBhdCBsZW5ndGggY291bnRzIHRvIGRldGVybWluZSBzdWItdGFibGUgc2l6ZXMgd2hlbiBidWlsZGluZyB0aGVcbiAgIGRlY29kaW5nIHRhYmxlcy5cbiAgICovXG5cbiAgLyogYWNjdW11bGF0ZSBsZW5ndGhzIGZvciBjb2RlcyAoYXNzdW1lcyBsZW5zW10gYWxsIGluIDAuLk1BWEJJVFMpICovXG4gIGZvciAobGVuID0gMDsgbGVuIDw9IE1BWEJJVFM7IGxlbisrKSB7XG4gICAgY291bnRbbGVuXSA9IDA7XG4gIH1cbiAgZm9yIChzeW0gPSAwOyBzeW0gPCBjb2Rlczsgc3ltKyspIHtcbiAgICBjb3VudFtsZW5zW2xlbnNfaW5kZXggKyBzeW1dXSsrO1xuICB9XG5cbiAgLyogYm91bmQgY29kZSBsZW5ndGhzLCBmb3JjZSByb290IHRvIGJlIHdpdGhpbiBjb2RlIGxlbmd0aHMgKi9cbiAgcm9vdCA9IGJpdHM7XG4gIGZvciAobWF4ID0gTUFYQklUUzsgbWF4ID49IDE7IG1heC0tKSB7XG4gICAgaWYgKGNvdW50W21heF0gIT09IDApIHsgYnJlYWs7IH1cbiAgfVxuICBpZiAocm9vdCA+IG1heCkge1xuICAgIHJvb3QgPSBtYXg7XG4gIH1cbiAgaWYgKG1heCA9PT0gMCkgeyAgICAgICAgICAgICAgICAgICAgIC8qIG5vIHN5bWJvbHMgdG8gY29kZSBhdCBhbGwgKi9cbiAgICAvL3RhYmxlLm9wW29wdHMudGFibGVfaW5kZXhdID0gNjQ7ICAvL2hlcmUub3AgPSAodmFyIGNoYXIpNjQ7ICAgIC8qIGludmFsaWQgY29kZSBtYXJrZXIgKi9cbiAgICAvL3RhYmxlLmJpdHNbb3B0cy50YWJsZV9pbmRleF0gPSAxOyAgIC8vaGVyZS5iaXRzID0gKHZhciBjaGFyKTE7XG4gICAgLy90YWJsZS52YWxbb3B0cy50YWJsZV9pbmRleCsrXSA9IDA7ICAgLy9oZXJlLnZhbCA9ICh2YXIgc2hvcnQpMDtcbiAgICB0YWJsZVt0YWJsZV9pbmRleCsrXSA9ICgxIDw8IDI0KSB8ICg2NCA8PCAxNikgfCAwO1xuXG5cbiAgICAvL3RhYmxlLm9wW29wdHMudGFibGVfaW5kZXhdID0gNjQ7XG4gICAgLy90YWJsZS5iaXRzW29wdHMudGFibGVfaW5kZXhdID0gMTtcbiAgICAvL3RhYmxlLnZhbFtvcHRzLnRhYmxlX2luZGV4KytdID0gMDtcbiAgICB0YWJsZVt0YWJsZV9pbmRleCsrXSA9ICgxIDw8IDI0KSB8ICg2NCA8PCAxNikgfCAwO1xuXG4gICAgb3B0cy5iaXRzID0gMTtcbiAgICByZXR1cm4gMDsgICAgIC8qIG5vIHN5bWJvbHMsIGJ1dCB3YWl0IGZvciBkZWNvZGluZyB0byByZXBvcnQgZXJyb3IgKi9cbiAgfVxuICBmb3IgKG1pbiA9IDE7IG1pbiA8IG1heDsgbWluKyspIHtcbiAgICBpZiAoY291bnRbbWluXSAhPT0gMCkgeyBicmVhazsgfVxuICB9XG4gIGlmIChyb290IDwgbWluKSB7XG4gICAgcm9vdCA9IG1pbjtcbiAgfVxuXG4gIC8qIGNoZWNrIGZvciBhbiBvdmVyLXN1YnNjcmliZWQgb3IgaW5jb21wbGV0ZSBzZXQgb2YgbGVuZ3RocyAqL1xuICBsZWZ0ID0gMTtcbiAgZm9yIChsZW4gPSAxOyBsZW4gPD0gTUFYQklUUzsgbGVuKyspIHtcbiAgICBsZWZ0IDw8PSAxO1xuICAgIGxlZnQgLT0gY291bnRbbGVuXTtcbiAgICBpZiAobGVmdCA8IDApIHtcbiAgICAgIHJldHVybiAtMTtcbiAgICB9ICAgICAgICAvKiBvdmVyLXN1YnNjcmliZWQgKi9cbiAgfVxuICBpZiAobGVmdCA+IDAgJiYgKHR5cGUgPT09IENPREVTIHx8IG1heCAhPT0gMSkpIHtcbiAgICByZXR1cm4gLTE7ICAgICAgICAgICAgICAgICAgICAgIC8qIGluY29tcGxldGUgc2V0ICovXG4gIH1cblxuICAvKiBnZW5lcmF0ZSBvZmZzZXRzIGludG8gc3ltYm9sIHRhYmxlIGZvciBlYWNoIGxlbmd0aCBmb3Igc29ydGluZyAqL1xuICBvZmZzWzFdID0gMDtcbiAgZm9yIChsZW4gPSAxOyBsZW4gPCBNQVhCSVRTOyBsZW4rKykge1xuICAgIG9mZnNbbGVuICsgMV0gPSBvZmZzW2xlbl0gKyBjb3VudFtsZW5dO1xuICB9XG5cbiAgLyogc29ydCBzeW1ib2xzIGJ5IGxlbmd0aCwgYnkgc3ltYm9sIG9yZGVyIHdpdGhpbiBlYWNoIGxlbmd0aCAqL1xuICBmb3IgKHN5bSA9IDA7IHN5bSA8IGNvZGVzOyBzeW0rKykge1xuICAgIGlmIChsZW5zW2xlbnNfaW5kZXggKyBzeW1dICE9PSAwKSB7XG4gICAgICB3b3JrW29mZnNbbGVuc1tsZW5zX2luZGV4ICsgc3ltXV0rK10gPSBzeW07XG4gICAgfVxuICB9XG5cbiAgLypcbiAgIENyZWF0ZSBhbmQgZmlsbCBpbiBkZWNvZGluZyB0YWJsZXMuICBJbiB0aGlzIGxvb3AsIHRoZSB0YWJsZSBiZWluZ1xuICAgZmlsbGVkIGlzIGF0IG5leHQgYW5kIGhhcyBjdXJyIGluZGV4IGJpdHMuICBUaGUgY29kZSBiZWluZyB1c2VkIGlzIGh1ZmZcbiAgIHdpdGggbGVuZ3RoIGxlbi4gIFRoYXQgY29kZSBpcyBjb252ZXJ0ZWQgdG8gYW4gaW5kZXggYnkgZHJvcHBpbmcgZHJvcFxuICAgYml0cyBvZmYgb2YgdGhlIGJvdHRvbS4gIEZvciBjb2RlcyB3aGVyZSBsZW4gaXMgbGVzcyB0aGFuIGRyb3AgKyBjdXJyLFxuICAgdGhvc2UgdG9wIGRyb3AgKyBjdXJyIC0gbGVuIGJpdHMgYXJlIGluY3JlbWVudGVkIHRocm91Z2ggYWxsIHZhbHVlcyB0b1xuICAgZmlsbCB0aGUgdGFibGUgd2l0aCByZXBsaWNhdGVkIGVudHJpZXMuXG5cbiAgIHJvb3QgaXMgdGhlIG51bWJlciBvZiBpbmRleCBiaXRzIGZvciB0aGUgcm9vdCB0YWJsZS4gIFdoZW4gbGVuIGV4Y2VlZHNcbiAgIHJvb3QsIHN1Yi10YWJsZXMgYXJlIGNyZWF0ZWQgcG9pbnRlZCB0byBieSB0aGUgcm9vdCBlbnRyeSB3aXRoIGFuIGluZGV4XG4gICBvZiB0aGUgbG93IHJvb3QgYml0cyBvZiBodWZmLiAgVGhpcyBpcyBzYXZlZCBpbiBsb3cgdG8gY2hlY2sgZm9yIHdoZW4gYVxuICAgbmV3IHN1Yi10YWJsZSBzaG91bGQgYmUgc3RhcnRlZC4gIGRyb3AgaXMgemVybyB3aGVuIHRoZSByb290IHRhYmxlIGlzXG4gICBiZWluZyBmaWxsZWQsIGFuZCBkcm9wIGlzIHJvb3Qgd2hlbiBzdWItdGFibGVzIGFyZSBiZWluZyBmaWxsZWQuXG5cbiAgIFdoZW4gYSBuZXcgc3ViLXRhYmxlIGlzIG5lZWRlZCwgaXQgaXMgbmVjZXNzYXJ5IHRvIGxvb2sgYWhlYWQgaW4gdGhlXG4gICBjb2RlIGxlbmd0aHMgdG8gZGV0ZXJtaW5lIHdoYXQgc2l6ZSBzdWItdGFibGUgaXMgbmVlZGVkLiAgVGhlIGxlbmd0aFxuICAgY291bnRzIGFyZSB1c2VkIGZvciB0aGlzLCBhbmQgc28gY291bnRbXSBpcyBkZWNyZW1lbnRlZCBhcyBjb2RlcyBhcmVcbiAgIGVudGVyZWQgaW4gdGhlIHRhYmxlcy5cblxuICAgdXNlZCBrZWVwcyB0cmFjayBvZiBob3cgbWFueSB0YWJsZSBlbnRyaWVzIGhhdmUgYmVlbiBhbGxvY2F0ZWQgZnJvbSB0aGVcbiAgIHByb3ZpZGVkICp0YWJsZSBzcGFjZS4gIEl0IGlzIGNoZWNrZWQgZm9yIExFTlMgYW5kIERJU1QgdGFibGVzIGFnYWluc3RcbiAgIHRoZSBjb25zdGFudHMgRU5PVUdIX0xFTlMgYW5kIEVOT1VHSF9ESVNUUyB0byBndWFyZCBhZ2FpbnN0IGNoYW5nZXMgaW5cbiAgIHRoZSBpbml0aWFsIHJvb3QgdGFibGUgc2l6ZSBjb25zdGFudHMuICBTZWUgdGhlIGNvbW1lbnRzIGluIGluZnRyZWVzLmhcbiAgIGZvciBtb3JlIGluZm9ybWF0aW9uLlxuXG4gICBzeW0gaW5jcmVtZW50cyB0aHJvdWdoIGFsbCBzeW1ib2xzLCBhbmQgdGhlIGxvb3AgdGVybWluYXRlcyB3aGVuXG4gICBhbGwgY29kZXMgb2YgbGVuZ3RoIG1heCwgaS5lLiBhbGwgY29kZXMsIGhhdmUgYmVlbiBwcm9jZXNzZWQuICBUaGlzXG4gICByb3V0aW5lIHBlcm1pdHMgaW5jb21wbGV0ZSBjb2Rlcywgc28gYW5vdGhlciBsb29wIGFmdGVyIHRoaXMgb25lIGZpbGxzXG4gICBpbiB0aGUgcmVzdCBvZiB0aGUgZGVjb2RpbmcgdGFibGVzIHdpdGggaW52YWxpZCBjb2RlIG1hcmtlcnMuXG4gICAqL1xuXG4gIC8qIHNldCB1cCBmb3IgY29kZSB0eXBlICovXG4gIC8vIHBvb3IgbWFuIG9wdGltaXphdGlvbiAtIHVzZSBpZi1lbHNlIGluc3RlYWQgb2Ygc3dpdGNoLFxuICAvLyB0byBhdm9pZCBkZW9wdHMgaW4gb2xkIHY4XG4gIGlmICh0eXBlID09PSBDT0RFUykge1xuICAgIGJhc2UgPSBleHRyYSA9IHdvcms7ICAgIC8qIGR1bW15IHZhbHVlLS1ub3QgdXNlZCAqL1xuICAgIGVuZCA9IDE5O1xuXG4gIH0gZWxzZSBpZiAodHlwZSA9PT0gTEVOUykge1xuICAgIGJhc2UgPSBsYmFzZTtcbiAgICBiYXNlX2luZGV4IC09IDI1NztcbiAgICBleHRyYSA9IGxleHQ7XG4gICAgZXh0cmFfaW5kZXggLT0gMjU3O1xuICAgIGVuZCA9IDI1NjtcblxuICB9IGVsc2UgeyAgICAgICAgICAgICAgICAgICAgLyogRElTVFMgKi9cbiAgICBiYXNlID0gZGJhc2U7XG4gICAgZXh0cmEgPSBkZXh0O1xuICAgIGVuZCA9IC0xO1xuICB9XG5cbiAgLyogaW5pdGlhbGl6ZSBvcHRzIGZvciBsb29wICovXG4gIGh1ZmYgPSAwOyAgICAgICAgICAgICAgICAgICAvKiBzdGFydGluZyBjb2RlICovXG4gIHN5bSA9IDA7ICAgICAgICAgICAgICAgICAgICAvKiBzdGFydGluZyBjb2RlIHN5bWJvbCAqL1xuICBsZW4gPSBtaW47ICAgICAgICAgICAgICAgICAgLyogc3RhcnRpbmcgY29kZSBsZW5ndGggKi9cbiAgbmV4dCA9IHRhYmxlX2luZGV4OyAgICAgICAgICAgICAgLyogY3VycmVudCB0YWJsZSB0byBmaWxsIGluICovXG4gIGN1cnIgPSByb290OyAgICAgICAgICAgICAgICAvKiBjdXJyZW50IHRhYmxlIGluZGV4IGJpdHMgKi9cbiAgZHJvcCA9IDA7ICAgICAgICAgICAgICAgICAgIC8qIGN1cnJlbnQgYml0cyB0byBkcm9wIGZyb20gY29kZSBmb3IgaW5kZXggKi9cbiAgbG93ID0gLTE7ICAgICAgICAgICAgICAgICAgIC8qIHRyaWdnZXIgbmV3IHN1Yi10YWJsZSB3aGVuIGxlbiA+IHJvb3QgKi9cbiAgdXNlZCA9IDEgPDwgcm9vdDsgICAgICAgICAgLyogdXNlIHJvb3QgdGFibGUgZW50cmllcyAqL1xuICBtYXNrID0gdXNlZCAtIDE7ICAgICAgICAgICAgLyogbWFzayBmb3IgY29tcGFyaW5nIGxvdyAqL1xuXG4gIC8qIGNoZWNrIGF2YWlsYWJsZSB0YWJsZSBzcGFjZSAqL1xuICBpZiAoKHR5cGUgPT09IExFTlMgJiYgdXNlZCA+IEVOT1VHSF9MRU5TKSB8fFxuICAgICh0eXBlID09PSBESVNUUyAmJiB1c2VkID4gRU5PVUdIX0RJU1RTKSkge1xuICAgIHJldHVybiAxO1xuICB9XG5cbiAgdmFyIGk9MDtcbiAgLyogcHJvY2VzcyBhbGwgY29kZXMgYW5kIG1ha2UgdGFibGUgZW50cmllcyAqL1xuICBmb3IgKDs7KSB7XG4gICAgaSsrO1xuICAgIC8qIGNyZWF0ZSB0YWJsZSBlbnRyeSAqL1xuICAgIGhlcmVfYml0cyA9IGxlbiAtIGRyb3A7XG4gICAgaWYgKHdvcmtbc3ltXSA8IGVuZCkge1xuICAgICAgaGVyZV9vcCA9IDA7XG4gICAgICBoZXJlX3ZhbCA9IHdvcmtbc3ltXTtcbiAgICB9XG4gICAgZWxzZSBpZiAod29ya1tzeW1dID4gZW5kKSB7XG4gICAgICBoZXJlX29wID0gZXh0cmFbZXh0cmFfaW5kZXggKyB3b3JrW3N5bV1dO1xuICAgICAgaGVyZV92YWwgPSBiYXNlW2Jhc2VfaW5kZXggKyB3b3JrW3N5bV1dO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIGhlcmVfb3AgPSAzMiArIDY0OyAgICAgICAgIC8qIGVuZCBvZiBibG9jayAqL1xuICAgICAgaGVyZV92YWwgPSAwO1xuICAgIH1cblxuICAgIC8qIHJlcGxpY2F0ZSBmb3IgdGhvc2UgaW5kaWNlcyB3aXRoIGxvdyBsZW4gYml0cyBlcXVhbCB0byBodWZmICovXG4gICAgaW5jciA9IDEgPDwgKGxlbiAtIGRyb3ApO1xuICAgIGZpbGwgPSAxIDw8IGN1cnI7XG4gICAgbWluID0gZmlsbDsgICAgICAgICAgICAgICAgIC8qIHNhdmUgb2Zmc2V0IHRvIG5leHQgdGFibGUgKi9cbiAgICBkbyB7XG4gICAgICBmaWxsIC09IGluY3I7XG4gICAgICB0YWJsZVtuZXh0ICsgKGh1ZmYgPj4gZHJvcCkgKyBmaWxsXSA9IChoZXJlX2JpdHMgPDwgMjQpIHwgKGhlcmVfb3AgPDwgMTYpIHwgaGVyZV92YWwgfDA7XG4gICAgfSB3aGlsZSAoZmlsbCAhPT0gMCk7XG5cbiAgICAvKiBiYWNrd2FyZHMgaW5jcmVtZW50IHRoZSBsZW4tYml0IGNvZGUgaHVmZiAqL1xuICAgIGluY3IgPSAxIDw8IChsZW4gLSAxKTtcbiAgICB3aGlsZSAoaHVmZiAmIGluY3IpIHtcbiAgICAgIGluY3IgPj49IDE7XG4gICAgfVxuICAgIGlmIChpbmNyICE9PSAwKSB7XG4gICAgICBodWZmICY9IGluY3IgLSAxO1xuICAgICAgaHVmZiArPSBpbmNyO1xuICAgIH0gZWxzZSB7XG4gICAgICBodWZmID0gMDtcbiAgICB9XG5cbiAgICAvKiBnbyB0byBuZXh0IHN5bWJvbCwgdXBkYXRlIGNvdW50LCBsZW4gKi9cbiAgICBzeW0rKztcbiAgICBpZiAoLS1jb3VudFtsZW5dID09PSAwKSB7XG4gICAgICBpZiAobGVuID09PSBtYXgpIHsgYnJlYWs7IH1cbiAgICAgIGxlbiA9IGxlbnNbbGVuc19pbmRleCArIHdvcmtbc3ltXV07XG4gICAgfVxuXG4gICAgLyogY3JlYXRlIG5ldyBzdWItdGFibGUgaWYgbmVlZGVkICovXG4gICAgaWYgKGxlbiA+IHJvb3QgJiYgKGh1ZmYgJiBtYXNrKSAhPT0gbG93KSB7XG4gICAgICAvKiBpZiBmaXJzdCB0aW1lLCB0cmFuc2l0aW9uIHRvIHN1Yi10YWJsZXMgKi9cbiAgICAgIGlmIChkcm9wID09PSAwKSB7XG4gICAgICAgIGRyb3AgPSByb290O1xuICAgICAgfVxuXG4gICAgICAvKiBpbmNyZW1lbnQgcGFzdCBsYXN0IHRhYmxlICovXG4gICAgICBuZXh0ICs9IG1pbjsgICAgICAgICAgICAvKiBoZXJlIG1pbiBpcyAxIDw8IGN1cnIgKi9cblxuICAgICAgLyogZGV0ZXJtaW5lIGxlbmd0aCBvZiBuZXh0IHRhYmxlICovXG4gICAgICBjdXJyID0gbGVuIC0gZHJvcDtcbiAgICAgIGxlZnQgPSAxIDw8IGN1cnI7XG4gICAgICB3aGlsZSAoY3VyciArIGRyb3AgPCBtYXgpIHtcbiAgICAgICAgbGVmdCAtPSBjb3VudFtjdXJyICsgZHJvcF07XG4gICAgICAgIGlmIChsZWZ0IDw9IDApIHsgYnJlYWs7IH1cbiAgICAgICAgY3VycisrO1xuICAgICAgICBsZWZ0IDw8PSAxO1xuICAgICAgfVxuXG4gICAgICAvKiBjaGVjayBmb3IgZW5vdWdoIHNwYWNlICovXG4gICAgICB1c2VkICs9IDEgPDwgY3VycjtcbiAgICAgIGlmICgodHlwZSA9PT0gTEVOUyAmJiB1c2VkID4gRU5PVUdIX0xFTlMpIHx8XG4gICAgICAgICh0eXBlID09PSBESVNUUyAmJiB1c2VkID4gRU5PVUdIX0RJU1RTKSkge1xuICAgICAgICByZXR1cm4gMTtcbiAgICAgIH1cblxuICAgICAgLyogcG9pbnQgZW50cnkgaW4gcm9vdCB0YWJsZSB0byBzdWItdGFibGUgKi9cbiAgICAgIGxvdyA9IGh1ZmYgJiBtYXNrO1xuICAgICAgLyp0YWJsZS5vcFtsb3ddID0gY3VycjtcbiAgICAgIHRhYmxlLmJpdHNbbG93XSA9IHJvb3Q7XG4gICAgICB0YWJsZS52YWxbbG93XSA9IG5leHQgLSBvcHRzLnRhYmxlX2luZGV4OyovXG4gICAgICB0YWJsZVtsb3ddID0gKHJvb3QgPDwgMjQpIHwgKGN1cnIgPDwgMTYpIHwgKG5leHQgLSB0YWJsZV9pbmRleCkgfDA7XG4gICAgfVxuICB9XG5cbiAgLyogZmlsbCBpbiByZW1haW5pbmcgdGFibGUgZW50cnkgaWYgY29kZSBpcyBpbmNvbXBsZXRlIChndWFyYW50ZWVkIHRvIGhhdmVcbiAgIGF0IG1vc3Qgb25lIHJlbWFpbmluZyBlbnRyeSwgc2luY2UgaWYgdGhlIGNvZGUgaXMgaW5jb21wbGV0ZSwgdGhlXG4gICBtYXhpbXVtIGNvZGUgbGVuZ3RoIHRoYXQgd2FzIGFsbG93ZWQgdG8gZ2V0IHRoaXMgZmFyIGlzIG9uZSBiaXQpICovXG4gIGlmIChodWZmICE9PSAwKSB7XG4gICAgLy90YWJsZS5vcFtuZXh0ICsgaHVmZl0gPSA2NDsgICAgICAgICAgICAvKiBpbnZhbGlkIGNvZGUgbWFya2VyICovXG4gICAgLy90YWJsZS5iaXRzW25leHQgKyBodWZmXSA9IGxlbiAtIGRyb3A7XG4gICAgLy90YWJsZS52YWxbbmV4dCArIGh1ZmZdID0gMDtcbiAgICB0YWJsZVtuZXh0ICsgaHVmZl0gPSAoKGxlbiAtIGRyb3ApIDw8IDI0KSB8ICg2NCA8PCAxNikgfDA7XG4gIH1cblxuICAvKiBzZXQgcmV0dXJuIHBhcmFtZXRlcnMgKi9cbiAgLy9vcHRzLnRhYmxlX2luZGV4ICs9IHVzZWQ7XG4gIG9wdHMuYml0cyA9IHJvb3Q7XG4gIHJldHVybiAwO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gICcyJzogICAgJ25lZWQgZGljdGlvbmFyeScsICAgICAvKiBaX05FRURfRElDVCAgICAgICAyICAqL1xuICAnMSc6ICAgICdzdHJlYW0gZW5kJywgICAgICAgICAgLyogWl9TVFJFQU1fRU5EICAgICAgMSAgKi9cbiAgJzAnOiAgICAnJywgICAgICAgICAgICAgICAgICAgIC8qIFpfT0sgICAgICAgICAgICAgIDAgICovXG4gICctMSc6ICAgJ2ZpbGUgZXJyb3InLCAgICAgICAgICAvKiBaX0VSUk5PICAgICAgICAgKC0xKSAqL1xuICAnLTInOiAgICdzdHJlYW0gZXJyb3InLCAgICAgICAgLyogWl9TVFJFQU1fRVJST1IgICgtMikgKi9cbiAgJy0zJzogICAnZGF0YSBlcnJvcicsICAgICAgICAgIC8qIFpfREFUQV9FUlJPUiAgICAoLTMpICovXG4gICctNCc6ICAgJ2luc3VmZmljaWVudCBtZW1vcnknLCAvKiBaX01FTV9FUlJPUiAgICAgKC00KSAqL1xuICAnLTUnOiAgICdidWZmZXIgZXJyb3InLCAgICAgICAgLyogWl9CVUZfRVJST1IgICAgICgtNSkgKi9cbiAgJy02JzogICAnaW5jb21wYXRpYmxlIHZlcnNpb24nIC8qIFpfVkVSU0lPTl9FUlJPUiAoLTYpICovXG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5cbnZhciB1dGlscyA9IHJlcXVpcmUoJy4uL3V0aWxzL2NvbW1vbicpO1xuXG4vKiBQdWJsaWMgY29uc3RhbnRzID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0qL1xuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09Ki9cblxuXG4vL3ZhciBaX0ZJTFRFUkVEICAgICAgICAgID0gMTtcbi8vdmFyIFpfSFVGRk1BTl9PTkxZICAgICAgPSAyO1xuLy92YXIgWl9STEUgICAgICAgICAgICAgICA9IDM7XG52YXIgWl9GSVhFRCAgICAgICAgICAgICAgID0gNDtcbi8vdmFyIFpfREVGQVVMVF9TVFJBVEVHWSAgPSAwO1xuXG4vKiBQb3NzaWJsZSB2YWx1ZXMgb2YgdGhlIGRhdGFfdHlwZSBmaWVsZCAodGhvdWdoIHNlZSBpbmZsYXRlKCkpICovXG52YXIgWl9CSU5BUlkgICAgICAgICAgICAgID0gMDtcbnZhciBaX1RFWFQgICAgICAgICAgICAgICAgPSAxO1xuLy92YXIgWl9BU0NJSSAgICAgICAgICAgICA9IDE7IC8vID0gWl9URVhUXG52YXIgWl9VTktOT1dOICAgICAgICAgICAgID0gMjtcblxuLyo9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09Ki9cblxuXG5mdW5jdGlvbiB6ZXJvKGJ1ZikgeyB2YXIgbGVuID0gYnVmLmxlbmd0aDsgd2hpbGUgKC0tbGVuID49IDApIHsgYnVmW2xlbl0gPSAwOyB9IH1cblxuLy8gRnJvbSB6dXRpbC5oXG5cbnZhciBTVE9SRURfQkxPQ0sgPSAwO1xudmFyIFNUQVRJQ19UUkVFUyA9IDE7XG52YXIgRFlOX1RSRUVTICAgID0gMjtcbi8qIFRoZSB0aHJlZSBraW5kcyBvZiBibG9jayB0eXBlICovXG5cbnZhciBNSU5fTUFUQ0ggICAgPSAzO1xudmFyIE1BWF9NQVRDSCAgICA9IDI1ODtcbi8qIFRoZSBtaW5pbXVtIGFuZCBtYXhpbXVtIG1hdGNoIGxlbmd0aHMgKi9cblxuLy8gRnJvbSBkZWZsYXRlLmhcbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogSW50ZXJuYWwgY29tcHJlc3Npb24gc3RhdGUuXG4gKi9cblxudmFyIExFTkdUSF9DT0RFUyAgPSAyOTtcbi8qIG51bWJlciBvZiBsZW5ndGggY29kZXMsIG5vdCBjb3VudGluZyB0aGUgc3BlY2lhbCBFTkRfQkxPQ0sgY29kZSAqL1xuXG52YXIgTElURVJBTFMgICAgICA9IDI1Njtcbi8qIG51bWJlciBvZiBsaXRlcmFsIGJ5dGVzIDAuLjI1NSAqL1xuXG52YXIgTF9DT0RFUyAgICAgICA9IExJVEVSQUxTICsgMSArIExFTkdUSF9DT0RFUztcbi8qIG51bWJlciBvZiBMaXRlcmFsIG9yIExlbmd0aCBjb2RlcywgaW5jbHVkaW5nIHRoZSBFTkRfQkxPQ0sgY29kZSAqL1xuXG52YXIgRF9DT0RFUyAgICAgICA9IDMwO1xuLyogbnVtYmVyIG9mIGRpc3RhbmNlIGNvZGVzICovXG5cbnZhciBCTF9DT0RFUyAgICAgID0gMTk7XG4vKiBudW1iZXIgb2YgY29kZXMgdXNlZCB0byB0cmFuc2ZlciB0aGUgYml0IGxlbmd0aHMgKi9cblxudmFyIEhFQVBfU0laRSAgICAgPSAyKkxfQ09ERVMgKyAxO1xuLyogbWF4aW11bSBoZWFwIHNpemUgKi9cblxudmFyIE1BWF9CSVRTICAgICAgPSAxNTtcbi8qIEFsbCBjb2RlcyBtdXN0IG5vdCBleGNlZWQgTUFYX0JJVFMgYml0cyAqL1xuXG52YXIgQnVmX3NpemUgICAgICA9IDE2O1xuLyogc2l6ZSBvZiBiaXQgYnVmZmVyIGluIGJpX2J1ZiAqL1xuXG5cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogQ29uc3RhbnRzXG4gKi9cblxudmFyIE1BWF9CTF9CSVRTID0gNztcbi8qIEJpdCBsZW5ndGggY29kZXMgbXVzdCBub3QgZXhjZWVkIE1BWF9CTF9CSVRTIGJpdHMgKi9cblxudmFyIEVORF9CTE9DSyAgID0gMjU2O1xuLyogZW5kIG9mIGJsb2NrIGxpdGVyYWwgY29kZSAqL1xuXG52YXIgUkVQXzNfNiAgICAgPSAxNjtcbi8qIHJlcGVhdCBwcmV2aW91cyBiaXQgbGVuZ3RoIDMtNiB0aW1lcyAoMiBiaXRzIG9mIHJlcGVhdCBjb3VudCkgKi9cblxudmFyIFJFUFpfM18xMCAgID0gMTc7XG4vKiByZXBlYXQgYSB6ZXJvIGxlbmd0aCAzLTEwIHRpbWVzICAoMyBiaXRzIG9mIHJlcGVhdCBjb3VudCkgKi9cblxudmFyIFJFUFpfMTFfMTM4ID0gMTg7XG4vKiByZXBlYXQgYSB6ZXJvIGxlbmd0aCAxMS0xMzggdGltZXMgICg3IGJpdHMgb2YgcmVwZWF0IGNvdW50KSAqL1xuXG52YXIgZXh0cmFfbGJpdHMgPSAgIC8qIGV4dHJhIGJpdHMgZm9yIGVhY2ggbGVuZ3RoIGNvZGUgKi9cbiAgWzAsMCwwLDAsMCwwLDAsMCwxLDEsMSwxLDIsMiwyLDIsMywzLDMsMyw0LDQsNCw0LDUsNSw1LDUsMF07XG5cbnZhciBleHRyYV9kYml0cyA9ICAgLyogZXh0cmEgYml0cyBmb3IgZWFjaCBkaXN0YW5jZSBjb2RlICovXG4gIFswLDAsMCwwLDEsMSwyLDIsMywzLDQsNCw1LDUsNiw2LDcsNyw4LDgsOSw5LDEwLDEwLDExLDExLDEyLDEyLDEzLDEzXTtcblxudmFyIGV4dHJhX2JsYml0cyA9ICAvKiBleHRyYSBiaXRzIGZvciBlYWNoIGJpdCBsZW5ndGggY29kZSAqL1xuICBbMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwyLDMsN107XG5cbnZhciBibF9vcmRlciA9XG4gIFsxNiwxNywxOCwwLDgsNyw5LDYsMTAsNSwxMSw0LDEyLDMsMTMsMiwxNCwxLDE1XTtcbi8qIFRoZSBsZW5ndGhzIG9mIHRoZSBiaXQgbGVuZ3RoIGNvZGVzIGFyZSBzZW50IGluIG9yZGVyIG9mIGRlY3JlYXNpbmdcbiAqIHByb2JhYmlsaXR5LCB0byBhdm9pZCB0cmFuc21pdHRpbmcgdGhlIGxlbmd0aHMgZm9yIHVudXNlZCBiaXQgbGVuZ3RoIGNvZGVzLlxuICovXG5cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogTG9jYWwgZGF0YS4gVGhlc2UgYXJlIGluaXRpYWxpemVkIG9ubHkgb25jZS5cbiAqL1xuXG4vLyBXZSBwcmUtZmlsbCBhcnJheXMgd2l0aCAwIHRvIGF2b2lkIHVuaW5pdGlhbGl6ZWQgZ2Fwc1xuXG52YXIgRElTVF9DT0RFX0xFTiA9IDUxMjsgLyogc2VlIGRlZmluaXRpb24gb2YgYXJyYXkgZGlzdF9jb2RlIGJlbG93ICovXG5cbi8vICEhISEgVXNlIGZsYXQgYXJyYXkgaW5zZGVhZCBvZiBzdHJ1Y3R1cmUsIEZyZXEgPSBpKjIsIExlbiA9IGkqMisxXG52YXIgc3RhdGljX2x0cmVlICA9IG5ldyBBcnJheSgoTF9DT0RFUysyKSAqIDIpO1xuemVybyhzdGF0aWNfbHRyZWUpO1xuLyogVGhlIHN0YXRpYyBsaXRlcmFsIHRyZWUuIFNpbmNlIHRoZSBiaXQgbGVuZ3RocyBhcmUgaW1wb3NlZCwgdGhlcmUgaXMgbm9cbiAqIG5lZWQgZm9yIHRoZSBMX0NPREVTIGV4dHJhIGNvZGVzIHVzZWQgZHVyaW5nIGhlYXAgY29uc3RydWN0aW9uLiBIb3dldmVyXG4gKiBUaGUgY29kZXMgMjg2IGFuZCAyODcgYXJlIG5lZWRlZCB0byBidWlsZCBhIGNhbm9uaWNhbCB0cmVlIChzZWUgX3RyX2luaXRcbiAqIGJlbG93KS5cbiAqL1xuXG52YXIgc3RhdGljX2R0cmVlICA9IG5ldyBBcnJheShEX0NPREVTICogMik7XG56ZXJvKHN0YXRpY19kdHJlZSk7XG4vKiBUaGUgc3RhdGljIGRpc3RhbmNlIHRyZWUuIChBY3R1YWxseSBhIHRyaXZpYWwgdHJlZSBzaW5jZSBhbGwgY29kZXMgdXNlXG4gKiA1IGJpdHMuKVxuICovXG5cbnZhciBfZGlzdF9jb2RlICAgID0gbmV3IEFycmF5KERJU1RfQ09ERV9MRU4pO1xuemVybyhfZGlzdF9jb2RlKTtcbi8qIERpc3RhbmNlIGNvZGVzLiBUaGUgZmlyc3QgMjU2IHZhbHVlcyBjb3JyZXNwb25kIHRvIHRoZSBkaXN0YW5jZXNcbiAqIDMgLi4gMjU4LCB0aGUgbGFzdCAyNTYgdmFsdWVzIGNvcnJlc3BvbmQgdG8gdGhlIHRvcCA4IGJpdHMgb2ZcbiAqIHRoZSAxNSBiaXQgZGlzdGFuY2VzLlxuICovXG5cbnZhciBfbGVuZ3RoX2NvZGUgID0gbmV3IEFycmF5KE1BWF9NQVRDSC1NSU5fTUFUQ0grMSk7XG56ZXJvKF9sZW5ndGhfY29kZSk7XG4vKiBsZW5ndGggY29kZSBmb3IgZWFjaCBub3JtYWxpemVkIG1hdGNoIGxlbmd0aCAoMCA9PSBNSU5fTUFUQ0gpICovXG5cbnZhciBiYXNlX2xlbmd0aCAgID0gbmV3IEFycmF5KExFTkdUSF9DT0RFUyk7XG56ZXJvKGJhc2VfbGVuZ3RoKTtcbi8qIEZpcnN0IG5vcm1hbGl6ZWQgbGVuZ3RoIGZvciBlYWNoIGNvZGUgKDAgPSBNSU5fTUFUQ0gpICovXG5cbnZhciBiYXNlX2Rpc3QgICAgID0gbmV3IEFycmF5KERfQ09ERVMpO1xuemVybyhiYXNlX2Rpc3QpO1xuLyogRmlyc3Qgbm9ybWFsaXplZCBkaXN0YW5jZSBmb3IgZWFjaCBjb2RlICgwID0gZGlzdGFuY2Ugb2YgMSkgKi9cblxuXG52YXIgU3RhdGljVHJlZURlc2MgPSBmdW5jdGlvbiAoc3RhdGljX3RyZWUsIGV4dHJhX2JpdHMsIGV4dHJhX2Jhc2UsIGVsZW1zLCBtYXhfbGVuZ3RoKSB7XG5cbiAgdGhpcy5zdGF0aWNfdHJlZSAgPSBzdGF0aWNfdHJlZTsgIC8qIHN0YXRpYyB0cmVlIG9yIE5VTEwgKi9cbiAgdGhpcy5leHRyYV9iaXRzICAgPSBleHRyYV9iaXRzOyAgIC8qIGV4dHJhIGJpdHMgZm9yIGVhY2ggY29kZSBvciBOVUxMICovXG4gIHRoaXMuZXh0cmFfYmFzZSAgID0gZXh0cmFfYmFzZTsgICAvKiBiYXNlIGluZGV4IGZvciBleHRyYV9iaXRzICovXG4gIHRoaXMuZWxlbXMgICAgICAgID0gZWxlbXM7ICAgICAgICAvKiBtYXggbnVtYmVyIG9mIGVsZW1lbnRzIGluIHRoZSB0cmVlICovXG4gIHRoaXMubWF4X2xlbmd0aCAgID0gbWF4X2xlbmd0aDsgICAvKiBtYXggYml0IGxlbmd0aCBmb3IgdGhlIGNvZGVzICovXG5cbiAgLy8gc2hvdyBpZiBgc3RhdGljX3RyZWVgIGhhcyBkYXRhIG9yIGR1bW15IC0gbmVlZGVkIGZvciBtb25vbW9ycGhpYyBvYmplY3RzXG4gIHRoaXMuaGFzX3N0cmVlICAgID0gc3RhdGljX3RyZWUgJiYgc3RhdGljX3RyZWUubGVuZ3RoO1xufTtcblxuXG52YXIgc3RhdGljX2xfZGVzYztcbnZhciBzdGF0aWNfZF9kZXNjO1xudmFyIHN0YXRpY19ibF9kZXNjO1xuXG5cbnZhciBUcmVlRGVzYyA9IGZ1bmN0aW9uKGR5bl90cmVlLCBzdGF0X2Rlc2MpIHtcbiAgdGhpcy5keW5fdHJlZSA9IGR5bl90cmVlOyAgICAgLyogdGhlIGR5bmFtaWMgdHJlZSAqL1xuICB0aGlzLm1heF9jb2RlID0gMDsgICAgICAgICAgICAvKiBsYXJnZXN0IGNvZGUgd2l0aCBub24gemVybyBmcmVxdWVuY3kgKi9cbiAgdGhpcy5zdGF0X2Rlc2MgPSBzdGF0X2Rlc2M7ICAgLyogdGhlIGNvcnJlc3BvbmRpbmcgc3RhdGljIHRyZWUgKi9cbn07XG5cblxuXG5mdW5jdGlvbiBkX2NvZGUoZGlzdCkge1xuICByZXR1cm4gZGlzdCA8IDI1NiA/IF9kaXN0X2NvZGVbZGlzdF0gOiBfZGlzdF9jb2RlWzI1NiArIChkaXN0ID4+PiA3KV07XG59XG5cblxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBPdXRwdXQgYSBzaG9ydCBMU0IgZmlyc3Qgb24gdGhlIHN0cmVhbS5cbiAqIElOIGFzc2VydGlvbjogdGhlcmUgaXMgZW5vdWdoIHJvb20gaW4gcGVuZGluZ0J1Zi5cbiAqL1xuZnVuY3Rpb24gcHV0X3Nob3J0IChzLCB3KSB7XG4vLyAgICBwdXRfYnl0ZShzLCAodWNoKSgodykgJiAweGZmKSk7XG4vLyAgICBwdXRfYnl0ZShzLCAodWNoKSgodXNoKSh3KSA+PiA4KSk7XG4gIHMucGVuZGluZ19idWZbcy5wZW5kaW5nKytdID0gKHcpICYgMHhmZjtcbiAgcy5wZW5kaW5nX2J1ZltzLnBlbmRpbmcrK10gPSAodyA+Pj4gOCkgJiAweGZmO1xufVxuXG5cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogU2VuZCBhIHZhbHVlIG9uIGEgZ2l2ZW4gbnVtYmVyIG9mIGJpdHMuXG4gKiBJTiBhc3NlcnRpb246IGxlbmd0aCA8PSAxNiBhbmQgdmFsdWUgZml0cyBpbiBsZW5ndGggYml0cy5cbiAqL1xuZnVuY3Rpb24gc2VuZF9iaXRzKHMsIHZhbHVlLCBsZW5ndGgpIHtcbiAgaWYgKHMuYmlfdmFsaWQgPiAoQnVmX3NpemUgLSBsZW5ndGgpKSB7XG4gICAgcy5iaV9idWYgfD0gKHZhbHVlIDw8IHMuYmlfdmFsaWQpICYgMHhmZmZmO1xuICAgIHB1dF9zaG9ydChzLCBzLmJpX2J1Zik7XG4gICAgcy5iaV9idWYgPSB2YWx1ZSA+PiAoQnVmX3NpemUgLSBzLmJpX3ZhbGlkKTtcbiAgICBzLmJpX3ZhbGlkICs9IGxlbmd0aCAtIEJ1Zl9zaXplO1xuICB9IGVsc2Uge1xuICAgIHMuYmlfYnVmIHw9ICh2YWx1ZSA8PCBzLmJpX3ZhbGlkKSAmIDB4ZmZmZjtcbiAgICBzLmJpX3ZhbGlkICs9IGxlbmd0aDtcbiAgfVxufVxuXG5cbmZ1bmN0aW9uIHNlbmRfY29kZShzLCBjLCB0cmVlKSB7XG4gIHNlbmRfYml0cyhzLCB0cmVlW2MqMl0vKi5Db2RlKi8sIHRyZWVbYyoyICsgMV0vKi5MZW4qLyk7XG59XG5cblxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBSZXZlcnNlIHRoZSBmaXJzdCBsZW4gYml0cyBvZiBhIGNvZGUsIHVzaW5nIHN0cmFpZ2h0Zm9yd2FyZCBjb2RlIChhIGZhc3RlclxuICogbWV0aG9kIHdvdWxkIHVzZSBhIHRhYmxlKVxuICogSU4gYXNzZXJ0aW9uOiAxIDw9IGxlbiA8PSAxNVxuICovXG5mdW5jdGlvbiBiaV9yZXZlcnNlKGNvZGUsIGxlbikge1xuICB2YXIgcmVzID0gMDtcbiAgZG8ge1xuICAgIHJlcyB8PSBjb2RlICYgMTtcbiAgICBjb2RlID4+Pj0gMTtcbiAgICByZXMgPDw9IDE7XG4gIH0gd2hpbGUgKC0tbGVuID4gMCk7XG4gIHJldHVybiByZXMgPj4+IDE7XG59XG5cblxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBGbHVzaCB0aGUgYml0IGJ1ZmZlciwga2VlcGluZyBhdCBtb3N0IDcgYml0cyBpbiBpdC5cbiAqL1xuZnVuY3Rpb24gYmlfZmx1c2gocykge1xuICBpZiAocy5iaV92YWxpZCA9PT0gMTYpIHtcbiAgICBwdXRfc2hvcnQocywgcy5iaV9idWYpO1xuICAgIHMuYmlfYnVmID0gMDtcbiAgICBzLmJpX3ZhbGlkID0gMDtcblxuICB9IGVsc2UgaWYgKHMuYmlfdmFsaWQgPj0gOCkge1xuICAgIHMucGVuZGluZ19idWZbcy5wZW5kaW5nKytdID0gcy5iaV9idWYgJiAweGZmO1xuICAgIHMuYmlfYnVmID4+PSA4O1xuICAgIHMuYmlfdmFsaWQgLT0gODtcbiAgfVxufVxuXG5cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogQ29tcHV0ZSB0aGUgb3B0aW1hbCBiaXQgbGVuZ3RocyBmb3IgYSB0cmVlIGFuZCB1cGRhdGUgdGhlIHRvdGFsIGJpdCBsZW5ndGhcbiAqIGZvciB0aGUgY3VycmVudCBibG9jay5cbiAqIElOIGFzc2VydGlvbjogdGhlIGZpZWxkcyBmcmVxIGFuZCBkYWQgYXJlIHNldCwgaGVhcFtoZWFwX21heF0gYW5kXG4gKiAgICBhYm92ZSBhcmUgdGhlIHRyZWUgbm9kZXMgc29ydGVkIGJ5IGluY3JlYXNpbmcgZnJlcXVlbmN5LlxuICogT1VUIGFzc2VydGlvbnM6IHRoZSBmaWVsZCBsZW4gaXMgc2V0IHRvIHRoZSBvcHRpbWFsIGJpdCBsZW5ndGgsIHRoZVxuICogICAgIGFycmF5IGJsX2NvdW50IGNvbnRhaW5zIHRoZSBmcmVxdWVuY2llcyBmb3IgZWFjaCBiaXQgbGVuZ3RoLlxuICogICAgIFRoZSBsZW5ndGggb3B0X2xlbiBpcyB1cGRhdGVkOyBzdGF0aWNfbGVuIGlzIGFsc28gdXBkYXRlZCBpZiBzdHJlZSBpc1xuICogICAgIG5vdCBudWxsLlxuICovXG5mdW5jdGlvbiBnZW5fYml0bGVuKHMsIGRlc2MpXG4vLyAgICBkZWZsYXRlX3N0YXRlICpzO1xuLy8gICAgdHJlZV9kZXNjICpkZXNjOyAgICAvKiB0aGUgdHJlZSBkZXNjcmlwdG9yICovXG57XG4gIHZhciB0cmVlICAgICAgICAgICAgPSBkZXNjLmR5bl90cmVlO1xuICB2YXIgbWF4X2NvZGUgICAgICAgID0gZGVzYy5tYXhfY29kZTtcbiAgdmFyIHN0cmVlICAgICAgICAgICA9IGRlc2Muc3RhdF9kZXNjLnN0YXRpY190cmVlO1xuICB2YXIgaGFzX3N0cmVlICAgICAgID0gZGVzYy5zdGF0X2Rlc2MuaGFzX3N0cmVlO1xuICB2YXIgZXh0cmEgICAgICAgICAgID0gZGVzYy5zdGF0X2Rlc2MuZXh0cmFfYml0cztcbiAgdmFyIGJhc2UgICAgICAgICAgICA9IGRlc2Muc3RhdF9kZXNjLmV4dHJhX2Jhc2U7XG4gIHZhciBtYXhfbGVuZ3RoICAgICAgPSBkZXNjLnN0YXRfZGVzYy5tYXhfbGVuZ3RoO1xuICB2YXIgaDsgICAgICAgICAgICAgIC8qIGhlYXAgaW5kZXggKi9cbiAgdmFyIG4sIG07ICAgICAgICAgICAvKiBpdGVyYXRlIG92ZXIgdGhlIHRyZWUgZWxlbWVudHMgKi9cbiAgdmFyIGJpdHM7ICAgICAgICAgICAvKiBiaXQgbGVuZ3RoICovXG4gIHZhciB4Yml0czsgICAgICAgICAgLyogZXh0cmEgYml0cyAqL1xuICB2YXIgZjsgICAgICAgICAgICAgIC8qIGZyZXF1ZW5jeSAqL1xuICB2YXIgb3ZlcmZsb3cgPSAwOyAgIC8qIG51bWJlciBvZiBlbGVtZW50cyB3aXRoIGJpdCBsZW5ndGggdG9vIGxhcmdlICovXG5cbiAgZm9yIChiaXRzID0gMDsgYml0cyA8PSBNQVhfQklUUzsgYml0cysrKSB7XG4gICAgcy5ibF9jb3VudFtiaXRzXSA9IDA7XG4gIH1cblxuICAvKiBJbiBhIGZpcnN0IHBhc3MsIGNvbXB1dGUgdGhlIG9wdGltYWwgYml0IGxlbmd0aHMgKHdoaWNoIG1heVxuICAgKiBvdmVyZmxvdyBpbiB0aGUgY2FzZSBvZiB0aGUgYml0IGxlbmd0aCB0cmVlKS5cbiAgICovXG4gIHRyZWVbcy5oZWFwW3MuaGVhcF9tYXhdKjIgKyAxXS8qLkxlbiovID0gMDsgLyogcm9vdCBvZiB0aGUgaGVhcCAqL1xuXG4gIGZvciAoaCA9IHMuaGVhcF9tYXgrMTsgaCA8IEhFQVBfU0laRTsgaCsrKSB7XG4gICAgbiA9IHMuaGVhcFtoXTtcbiAgICBiaXRzID0gdHJlZVt0cmVlW24qMiArMV0vKi5EYWQqLyAqIDIgKyAxXS8qLkxlbiovICsgMTtcbiAgICBpZiAoYml0cyA+IG1heF9sZW5ndGgpIHtcbiAgICAgIGJpdHMgPSBtYXhfbGVuZ3RoO1xuICAgICAgb3ZlcmZsb3crKztcbiAgICB9XG4gICAgdHJlZVtuKjIgKyAxXS8qLkxlbiovID0gYml0cztcbiAgICAvKiBXZSBvdmVyd3JpdGUgdHJlZVtuXS5EYWQgd2hpY2ggaXMgbm8gbG9uZ2VyIG5lZWRlZCAqL1xuXG4gICAgaWYgKG4gPiBtYXhfY29kZSkgeyBjb250aW51ZTsgfSAvKiBub3QgYSBsZWFmIG5vZGUgKi9cblxuICAgIHMuYmxfY291bnRbYml0c10rKztcbiAgICB4Yml0cyA9IDA7XG4gICAgaWYgKG4gPj0gYmFzZSkge1xuICAgICAgeGJpdHMgPSBleHRyYVtuLWJhc2VdO1xuICAgIH1cbiAgICBmID0gdHJlZVtuICogMl0vKi5GcmVxKi87XG4gICAgcy5vcHRfbGVuICs9IGYgKiAoYml0cyArIHhiaXRzKTtcbiAgICBpZiAoaGFzX3N0cmVlKSB7XG4gICAgICBzLnN0YXRpY19sZW4gKz0gZiAqIChzdHJlZVtuKjIgKyAxXS8qLkxlbiovICsgeGJpdHMpO1xuICAgIH1cbiAgfVxuICBpZiAob3ZlcmZsb3cgPT09IDApIHsgcmV0dXJuOyB9XG5cbiAgLy8gVHJhY2UoKHN0ZGVycixcIlxcbmJpdCBsZW5ndGggb3ZlcmZsb3dcXG5cIikpO1xuICAvKiBUaGlzIGhhcHBlbnMgZm9yIGV4YW1wbGUgb24gb2JqMiBhbmQgcGljIG9mIHRoZSBDYWxnYXJ5IGNvcnB1cyAqL1xuXG4gIC8qIEZpbmQgdGhlIGZpcnN0IGJpdCBsZW5ndGggd2hpY2ggY291bGQgaW5jcmVhc2U6ICovXG4gIGRvIHtcbiAgICBiaXRzID0gbWF4X2xlbmd0aC0xO1xuICAgIHdoaWxlIChzLmJsX2NvdW50W2JpdHNdID09PSAwKSB7IGJpdHMtLTsgfVxuICAgIHMuYmxfY291bnRbYml0c10tLTsgICAgICAvKiBtb3ZlIG9uZSBsZWFmIGRvd24gdGhlIHRyZWUgKi9cbiAgICBzLmJsX2NvdW50W2JpdHMrMV0gKz0gMjsgLyogbW92ZSBvbmUgb3ZlcmZsb3cgaXRlbSBhcyBpdHMgYnJvdGhlciAqL1xuICAgIHMuYmxfY291bnRbbWF4X2xlbmd0aF0tLTtcbiAgICAvKiBUaGUgYnJvdGhlciBvZiB0aGUgb3ZlcmZsb3cgaXRlbSBhbHNvIG1vdmVzIG9uZSBzdGVwIHVwLFxuICAgICAqIGJ1dCB0aGlzIGRvZXMgbm90IGFmZmVjdCBibF9jb3VudFttYXhfbGVuZ3RoXVxuICAgICAqL1xuICAgIG92ZXJmbG93IC09IDI7XG4gIH0gd2hpbGUgKG92ZXJmbG93ID4gMCk7XG5cbiAgLyogTm93IHJlY29tcHV0ZSBhbGwgYml0IGxlbmd0aHMsIHNjYW5uaW5nIGluIGluY3JlYXNpbmcgZnJlcXVlbmN5LlxuICAgKiBoIGlzIHN0aWxsIGVxdWFsIHRvIEhFQVBfU0laRS4gKEl0IGlzIHNpbXBsZXIgdG8gcmVjb25zdHJ1Y3QgYWxsXG4gICAqIGxlbmd0aHMgaW5zdGVhZCBvZiBmaXhpbmcgb25seSB0aGUgd3Jvbmcgb25lcy4gVGhpcyBpZGVhIGlzIHRha2VuXG4gICAqIGZyb20gJ2FyJyB3cml0dGVuIGJ5IEhhcnVoaWtvIE9rdW11cmEuKVxuICAgKi9cbiAgZm9yIChiaXRzID0gbWF4X2xlbmd0aDsgYml0cyAhPT0gMDsgYml0cy0tKSB7XG4gICAgbiA9IHMuYmxfY291bnRbYml0c107XG4gICAgd2hpbGUgKG4gIT09IDApIHtcbiAgICAgIG0gPSBzLmhlYXBbLS1oXTtcbiAgICAgIGlmIChtID4gbWF4X2NvZGUpIHsgY29udGludWU7IH1cbiAgICAgIGlmICh0cmVlW20qMiArIDFdLyouTGVuKi8gIT09IGJpdHMpIHtcbiAgICAgICAgLy8gVHJhY2UoKHN0ZGVycixcImNvZGUgJWQgYml0cyAlZC0+JWRcXG5cIiwgbSwgdHJlZVttXS5MZW4sIGJpdHMpKTtcbiAgICAgICAgcy5vcHRfbGVuICs9IChiaXRzIC0gdHJlZVttKjIgKyAxXS8qLkxlbiovKSp0cmVlW20qMl0vKi5GcmVxKi87XG4gICAgICAgIHRyZWVbbSoyICsgMV0vKi5MZW4qLyA9IGJpdHM7XG4gICAgICB9XG4gICAgICBuLS07XG4gICAgfVxuICB9XG59XG5cblxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBHZW5lcmF0ZSB0aGUgY29kZXMgZm9yIGEgZ2l2ZW4gdHJlZSBhbmQgYml0IGNvdW50cyAod2hpY2ggbmVlZCBub3QgYmVcbiAqIG9wdGltYWwpLlxuICogSU4gYXNzZXJ0aW9uOiB0aGUgYXJyYXkgYmxfY291bnQgY29udGFpbnMgdGhlIGJpdCBsZW5ndGggc3RhdGlzdGljcyBmb3JcbiAqIHRoZSBnaXZlbiB0cmVlIGFuZCB0aGUgZmllbGQgbGVuIGlzIHNldCBmb3IgYWxsIHRyZWUgZWxlbWVudHMuXG4gKiBPVVQgYXNzZXJ0aW9uOiB0aGUgZmllbGQgY29kZSBpcyBzZXQgZm9yIGFsbCB0cmVlIGVsZW1lbnRzIG9mIG5vblxuICogICAgIHplcm8gY29kZSBsZW5ndGguXG4gKi9cbmZ1bmN0aW9uIGdlbl9jb2Rlcyh0cmVlLCBtYXhfY29kZSwgYmxfY291bnQpXG4vLyAgICBjdF9kYXRhICp0cmVlOyAgICAgICAgICAgICAvKiB0aGUgdHJlZSB0byBkZWNvcmF0ZSAqL1xuLy8gICAgaW50IG1heF9jb2RlOyAgICAgICAgICAgICAgLyogbGFyZ2VzdCBjb2RlIHdpdGggbm9uIHplcm8gZnJlcXVlbmN5ICovXG4vLyAgICB1c2hmICpibF9jb3VudDsgICAgICAgICAgICAvKiBudW1iZXIgb2YgY29kZXMgYXQgZWFjaCBiaXQgbGVuZ3RoICovXG57XG4gIHZhciBuZXh0X2NvZGUgPSBuZXcgQXJyYXkoTUFYX0JJVFMrMSk7IC8qIG5leHQgY29kZSB2YWx1ZSBmb3IgZWFjaCBiaXQgbGVuZ3RoICovXG4gIHZhciBjb2RlID0gMDsgICAgICAgICAgICAgIC8qIHJ1bm5pbmcgY29kZSB2YWx1ZSAqL1xuICB2YXIgYml0czsgICAgICAgICAgICAgICAgICAvKiBiaXQgaW5kZXggKi9cbiAgdmFyIG47ICAgICAgICAgICAgICAgICAgICAgLyogY29kZSBpbmRleCAqL1xuXG4gIC8qIFRoZSBkaXN0cmlidXRpb24gY291bnRzIGFyZSBmaXJzdCB1c2VkIHRvIGdlbmVyYXRlIHRoZSBjb2RlIHZhbHVlc1xuICAgKiB3aXRob3V0IGJpdCByZXZlcnNhbC5cbiAgICovXG4gIGZvciAoYml0cyA9IDE7IGJpdHMgPD0gTUFYX0JJVFM7IGJpdHMrKykge1xuICAgIG5leHRfY29kZVtiaXRzXSA9IGNvZGUgPSAoY29kZSArIGJsX2NvdW50W2JpdHMtMV0pIDw8IDE7XG4gIH1cbiAgLyogQ2hlY2sgdGhhdCB0aGUgYml0IGNvdW50cyBpbiBibF9jb3VudCBhcmUgY29uc2lzdGVudC4gVGhlIGxhc3QgY29kZVxuICAgKiBtdXN0IGJlIGFsbCBvbmVzLlxuICAgKi9cbiAgLy9Bc3NlcnQgKGNvZGUgKyBibF9jb3VudFtNQVhfQklUU10tMSA9PSAoMTw8TUFYX0JJVFMpLTEsXG4gIC8vICAgICAgICBcImluY29uc2lzdGVudCBiaXQgY291bnRzXCIpO1xuICAvL1RyYWNldigoc3RkZXJyLFwiXFxuZ2VuX2NvZGVzOiBtYXhfY29kZSAlZCBcIiwgbWF4X2NvZGUpKTtcblxuICBmb3IgKG4gPSAwOyAgbiA8PSBtYXhfY29kZTsgbisrKSB7XG4gICAgdmFyIGxlbiA9IHRyZWVbbioyICsgMV0vKi5MZW4qLztcbiAgICBpZiAobGVuID09PSAwKSB7IGNvbnRpbnVlOyB9XG4gICAgLyogTm93IHJldmVyc2UgdGhlIGJpdHMgKi9cbiAgICB0cmVlW24qMl0vKi5Db2RlKi8gPSBiaV9yZXZlcnNlKG5leHRfY29kZVtsZW5dKyssIGxlbik7XG5cbiAgICAvL1RyYWNlY3YodHJlZSAhPSBzdGF0aWNfbHRyZWUsIChzdGRlcnIsXCJcXG5uICUzZCAlYyBsICUyZCBjICU0eCAoJXgpIFwiLFxuICAgIC8vICAgICBuLCAoaXNncmFwaChuKSA/IG4gOiAnICcpLCBsZW4sIHRyZWVbbl0uQ29kZSwgbmV4dF9jb2RlW2xlbl0tMSkpO1xuICB9XG59XG5cblxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBJbml0aWFsaXplIHRoZSB2YXJpb3VzICdjb25zdGFudCcgdGFibGVzLlxuICovXG5mdW5jdGlvbiB0cl9zdGF0aWNfaW5pdCgpIHtcbiAgdmFyIG47ICAgICAgICAvKiBpdGVyYXRlcyBvdmVyIHRyZWUgZWxlbWVudHMgKi9cbiAgdmFyIGJpdHM7ICAgICAvKiBiaXQgY291bnRlciAqL1xuICB2YXIgbGVuZ3RoOyAgIC8qIGxlbmd0aCB2YWx1ZSAqL1xuICB2YXIgY29kZTsgICAgIC8qIGNvZGUgdmFsdWUgKi9cbiAgdmFyIGRpc3Q7ICAgICAvKiBkaXN0YW5jZSBpbmRleCAqL1xuICB2YXIgYmxfY291bnQgPSBuZXcgQXJyYXkoTUFYX0JJVFMrMSk7XG4gIC8qIG51bWJlciBvZiBjb2RlcyBhdCBlYWNoIGJpdCBsZW5ndGggZm9yIGFuIG9wdGltYWwgdHJlZSAqL1xuXG4gIC8vIGRvIGNoZWNrIGluIF90cl9pbml0KClcbiAgLy9pZiAoc3RhdGljX2luaXRfZG9uZSkgcmV0dXJuO1xuXG4gIC8qIEZvciBzb21lIGVtYmVkZGVkIHRhcmdldHMsIGdsb2JhbCB2YXJpYWJsZXMgYXJlIG5vdCBpbml0aWFsaXplZDogKi9cbi8qI2lmZGVmIE5PX0lOSVRfR0xPQkFMX1BPSU5URVJTXG4gIHN0YXRpY19sX2Rlc2Muc3RhdGljX3RyZWUgPSBzdGF0aWNfbHRyZWU7XG4gIHN0YXRpY19sX2Rlc2MuZXh0cmFfYml0cyA9IGV4dHJhX2xiaXRzO1xuICBzdGF0aWNfZF9kZXNjLnN0YXRpY190cmVlID0gc3RhdGljX2R0cmVlO1xuICBzdGF0aWNfZF9kZXNjLmV4dHJhX2JpdHMgPSBleHRyYV9kYml0cztcbiAgc3RhdGljX2JsX2Rlc2MuZXh0cmFfYml0cyA9IGV4dHJhX2JsYml0cztcbiNlbmRpZiovXG5cbiAgLyogSW5pdGlhbGl6ZSB0aGUgbWFwcGluZyBsZW5ndGggKDAuLjI1NSkgLT4gbGVuZ3RoIGNvZGUgKDAuLjI4KSAqL1xuICBsZW5ndGggPSAwO1xuICBmb3IgKGNvZGUgPSAwOyBjb2RlIDwgTEVOR1RIX0NPREVTLTE7IGNvZGUrKykge1xuICAgIGJhc2VfbGVuZ3RoW2NvZGVdID0gbGVuZ3RoO1xuICAgIGZvciAobiA9IDA7IG4gPCAoMTw8ZXh0cmFfbGJpdHNbY29kZV0pOyBuKyspIHtcbiAgICAgIF9sZW5ndGhfY29kZVtsZW5ndGgrK10gPSBjb2RlO1xuICAgIH1cbiAgfVxuICAvL0Fzc2VydCAobGVuZ3RoID09IDI1NiwgXCJ0cl9zdGF0aWNfaW5pdDogbGVuZ3RoICE9IDI1NlwiKTtcbiAgLyogTm90ZSB0aGF0IHRoZSBsZW5ndGggMjU1IChtYXRjaCBsZW5ndGggMjU4KSBjYW4gYmUgcmVwcmVzZW50ZWRcbiAgICogaW4gdHdvIGRpZmZlcmVudCB3YXlzOiBjb2RlIDI4NCArIDUgYml0cyBvciBjb2RlIDI4NSwgc28gd2VcbiAgICogb3ZlcndyaXRlIGxlbmd0aF9jb2RlWzI1NV0gdG8gdXNlIHRoZSBiZXN0IGVuY29kaW5nOlxuICAgKi9cbiAgX2xlbmd0aF9jb2RlW2xlbmd0aC0xXSA9IGNvZGU7XG5cbiAgLyogSW5pdGlhbGl6ZSB0aGUgbWFwcGluZyBkaXN0ICgwLi4zMkspIC0+IGRpc3QgY29kZSAoMC4uMjkpICovXG4gIGRpc3QgPSAwO1xuICBmb3IgKGNvZGUgPSAwIDsgY29kZSA8IDE2OyBjb2RlKyspIHtcbiAgICBiYXNlX2Rpc3RbY29kZV0gPSBkaXN0O1xuICAgIGZvciAobiA9IDA7IG4gPCAoMTw8ZXh0cmFfZGJpdHNbY29kZV0pOyBuKyspIHtcbiAgICAgIF9kaXN0X2NvZGVbZGlzdCsrXSA9IGNvZGU7XG4gICAgfVxuICB9XG4gIC8vQXNzZXJ0IChkaXN0ID09IDI1NiwgXCJ0cl9zdGF0aWNfaW5pdDogZGlzdCAhPSAyNTZcIik7XG4gIGRpc3QgPj49IDc7IC8qIGZyb20gbm93IG9uLCBhbGwgZGlzdGFuY2VzIGFyZSBkaXZpZGVkIGJ5IDEyOCAqL1xuICBmb3IgKDsgY29kZSA8IERfQ09ERVM7IGNvZGUrKykge1xuICAgIGJhc2VfZGlzdFtjb2RlXSA9IGRpc3QgPDwgNztcbiAgICBmb3IgKG4gPSAwOyBuIDwgKDE8PChleHRyYV9kYml0c1tjb2RlXS03KSk7IG4rKykge1xuICAgICAgX2Rpc3RfY29kZVsyNTYgKyBkaXN0KytdID0gY29kZTtcbiAgICB9XG4gIH1cbiAgLy9Bc3NlcnQgKGRpc3QgPT0gMjU2LCBcInRyX3N0YXRpY19pbml0OiAyNTYrZGlzdCAhPSA1MTJcIik7XG5cbiAgLyogQ29uc3RydWN0IHRoZSBjb2RlcyBvZiB0aGUgc3RhdGljIGxpdGVyYWwgdHJlZSAqL1xuICBmb3IgKGJpdHMgPSAwOyBiaXRzIDw9IE1BWF9CSVRTOyBiaXRzKyspIHtcbiAgICBibF9jb3VudFtiaXRzXSA9IDA7XG4gIH1cblxuICBuID0gMDtcbiAgd2hpbGUgKG4gPD0gMTQzKSB7XG4gICAgc3RhdGljX2x0cmVlW24qMiArIDFdLyouTGVuKi8gPSA4O1xuICAgIG4rKztcbiAgICBibF9jb3VudFs4XSsrO1xuICB9XG4gIHdoaWxlIChuIDw9IDI1NSkge1xuICAgIHN0YXRpY19sdHJlZVtuKjIgKyAxXS8qLkxlbiovID0gOTtcbiAgICBuKys7XG4gICAgYmxfY291bnRbOV0rKztcbiAgfVxuICB3aGlsZSAobiA8PSAyNzkpIHtcbiAgICBzdGF0aWNfbHRyZWVbbioyICsgMV0vKi5MZW4qLyA9IDc7XG4gICAgbisrO1xuICAgIGJsX2NvdW50WzddKys7XG4gIH1cbiAgd2hpbGUgKG4gPD0gMjg3KSB7XG4gICAgc3RhdGljX2x0cmVlW24qMiArIDFdLyouTGVuKi8gPSA4O1xuICAgIG4rKztcbiAgICBibF9jb3VudFs4XSsrO1xuICB9XG4gIC8qIENvZGVzIDI4NiBhbmQgMjg3IGRvIG5vdCBleGlzdCwgYnV0IHdlIG11c3QgaW5jbHVkZSB0aGVtIGluIHRoZVxuICAgKiB0cmVlIGNvbnN0cnVjdGlvbiB0byBnZXQgYSBjYW5vbmljYWwgSHVmZm1hbiB0cmVlIChsb25nZXN0IGNvZGVcbiAgICogYWxsIG9uZXMpXG4gICAqL1xuICBnZW5fY29kZXMoc3RhdGljX2x0cmVlLCBMX0NPREVTKzEsIGJsX2NvdW50KTtcblxuICAvKiBUaGUgc3RhdGljIGRpc3RhbmNlIHRyZWUgaXMgdHJpdmlhbDogKi9cbiAgZm9yIChuID0gMDsgbiA8IERfQ09ERVM7IG4rKykge1xuICAgIHN0YXRpY19kdHJlZVtuKjIgKyAxXS8qLkxlbiovID0gNTtcbiAgICBzdGF0aWNfZHRyZWVbbioyXS8qLkNvZGUqLyA9IGJpX3JldmVyc2UobiwgNSk7XG4gIH1cblxuICAvLyBOb3cgZGF0YSByZWFkeSBhbmQgd2UgY2FuIGluaXQgc3RhdGljIHRyZWVzXG4gIHN0YXRpY19sX2Rlc2MgPSBuZXcgU3RhdGljVHJlZURlc2Moc3RhdGljX2x0cmVlLCBleHRyYV9sYml0cywgTElURVJBTFMrMSwgTF9DT0RFUywgTUFYX0JJVFMpO1xuICBzdGF0aWNfZF9kZXNjID0gbmV3IFN0YXRpY1RyZWVEZXNjKHN0YXRpY19kdHJlZSwgZXh0cmFfZGJpdHMsIDAsICAgICAgICAgIERfQ09ERVMsIE1BWF9CSVRTKTtcbiAgc3RhdGljX2JsX2Rlc2MgPW5ldyBTdGF0aWNUcmVlRGVzYyhuZXcgQXJyYXkoMCksIGV4dHJhX2JsYml0cywgMCwgICAgICAgICBCTF9DT0RFUywgTUFYX0JMX0JJVFMpO1xuXG4gIC8vc3RhdGljX2luaXRfZG9uZSA9IHRydWU7XG59XG5cblxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBJbml0aWFsaXplIGEgbmV3IGJsb2NrLlxuICovXG5mdW5jdGlvbiBpbml0X2Jsb2NrKHMpIHtcbiAgdmFyIG47IC8qIGl0ZXJhdGVzIG92ZXIgdHJlZSBlbGVtZW50cyAqL1xuXG4gIC8qIEluaXRpYWxpemUgdGhlIHRyZWVzLiAqL1xuICBmb3IgKG4gPSAwOyBuIDwgTF9DT0RFUzsgIG4rKykgeyBzLmR5bl9sdHJlZVtuKjJdLyouRnJlcSovID0gMDsgfVxuICBmb3IgKG4gPSAwOyBuIDwgRF9DT0RFUzsgIG4rKykgeyBzLmR5bl9kdHJlZVtuKjJdLyouRnJlcSovID0gMDsgfVxuICBmb3IgKG4gPSAwOyBuIDwgQkxfQ09ERVM7IG4rKykgeyBzLmJsX3RyZWVbbioyXS8qLkZyZXEqLyA9IDA7IH1cblxuICBzLmR5bl9sdHJlZVtFTkRfQkxPQ0sqMl0vKi5GcmVxKi8gPSAxO1xuICBzLm9wdF9sZW4gPSBzLnN0YXRpY19sZW4gPSAwO1xuICBzLmxhc3RfbGl0ID0gcy5tYXRjaGVzID0gMDtcbn1cblxuXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIEZsdXNoIHRoZSBiaXQgYnVmZmVyIGFuZCBhbGlnbiB0aGUgb3V0cHV0IG9uIGEgYnl0ZSBib3VuZGFyeVxuICovXG5mdW5jdGlvbiBiaV93aW5kdXAocylcbntcbiAgaWYgKHMuYmlfdmFsaWQgPiA4KSB7XG4gICAgcHV0X3Nob3J0KHMsIHMuYmlfYnVmKTtcbiAgfSBlbHNlIGlmIChzLmJpX3ZhbGlkID4gMCkge1xuICAgIC8vcHV0X2J5dGUocywgKEJ5dGUpcy0+YmlfYnVmKTtcbiAgICBzLnBlbmRpbmdfYnVmW3MucGVuZGluZysrXSA9IHMuYmlfYnVmO1xuICB9XG4gIHMuYmlfYnVmID0gMDtcbiAgcy5iaV92YWxpZCA9IDA7XG59XG5cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogQ29weSBhIHN0b3JlZCBibG9jaywgc3RvcmluZyBmaXJzdCB0aGUgbGVuZ3RoIGFuZCBpdHNcbiAqIG9uZSdzIGNvbXBsZW1lbnQgaWYgcmVxdWVzdGVkLlxuICovXG5mdW5jdGlvbiBjb3B5X2Jsb2NrKHMsIGJ1ZiwgbGVuLCBoZWFkZXIpXG4vL0RlZmxhdGVTdGF0ZSAqcztcbi8vY2hhcmYgICAgKmJ1ZjsgICAgLyogdGhlIGlucHV0IGRhdGEgKi9cbi8vdW5zaWduZWQgbGVuOyAgICAgLyogaXRzIGxlbmd0aCAqL1xuLy9pbnQgICAgICBoZWFkZXI7ICAvKiB0cnVlIGlmIGJsb2NrIGhlYWRlciBtdXN0IGJlIHdyaXR0ZW4gKi9cbntcbiAgYmlfd2luZHVwKHMpOyAgICAgICAgLyogYWxpZ24gb24gYnl0ZSBib3VuZGFyeSAqL1xuXG4gIGlmIChoZWFkZXIpIHtcbiAgICBwdXRfc2hvcnQocywgbGVuKTtcbiAgICBwdXRfc2hvcnQocywgfmxlbik7XG4gIH1cbi8vICB3aGlsZSAobGVuLS0pIHtcbi8vICAgIHB1dF9ieXRlKHMsICpidWYrKyk7XG4vLyAgfVxuICB1dGlscy5hcnJheVNldChzLnBlbmRpbmdfYnVmLCBzLndpbmRvdywgYnVmLCBsZW4sIHMucGVuZGluZyk7XG4gIHMucGVuZGluZyArPSBsZW47XG59XG5cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogQ29tcGFyZXMgdG8gc3VidHJlZXMsIHVzaW5nIHRoZSB0cmVlIGRlcHRoIGFzIHRpZSBicmVha2VyIHdoZW5cbiAqIHRoZSBzdWJ0cmVlcyBoYXZlIGVxdWFsIGZyZXF1ZW5jeS4gVGhpcyBtaW5pbWl6ZXMgdGhlIHdvcnN0IGNhc2UgbGVuZ3RoLlxuICovXG5mdW5jdGlvbiBzbWFsbGVyKHRyZWUsIG4sIG0sIGRlcHRoKSB7XG4gIHZhciBfbjIgPSBuKjI7XG4gIHZhciBfbTIgPSBtKjI7XG4gIHJldHVybiAodHJlZVtfbjJdLyouRnJlcSovIDwgdHJlZVtfbTJdLyouRnJlcSovIHx8XG4gICAgICAgICAodHJlZVtfbjJdLyouRnJlcSovID09PSB0cmVlW19tMl0vKi5GcmVxKi8gJiYgZGVwdGhbbl0gPD0gZGVwdGhbbV0pKTtcbn1cblxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBSZXN0b3JlIHRoZSBoZWFwIHByb3BlcnR5IGJ5IG1vdmluZyBkb3duIHRoZSB0cmVlIHN0YXJ0aW5nIGF0IG5vZGUgayxcbiAqIGV4Y2hhbmdpbmcgYSBub2RlIHdpdGggdGhlIHNtYWxsZXN0IG9mIGl0cyB0d28gc29ucyBpZiBuZWNlc3NhcnksIHN0b3BwaW5nXG4gKiB3aGVuIHRoZSBoZWFwIHByb3BlcnR5IGlzIHJlLWVzdGFibGlzaGVkIChlYWNoIGZhdGhlciBzbWFsbGVyIHRoYW4gaXRzXG4gKiB0d28gc29ucykuXG4gKi9cbmZ1bmN0aW9uIHBxZG93bmhlYXAocywgdHJlZSwgaylcbi8vICAgIGRlZmxhdGVfc3RhdGUgKnM7XG4vLyAgICBjdF9kYXRhICp0cmVlOyAgLyogdGhlIHRyZWUgdG8gcmVzdG9yZSAqL1xuLy8gICAgaW50IGs7ICAgICAgICAgICAgICAgLyogbm9kZSB0byBtb3ZlIGRvd24gKi9cbntcbiAgdmFyIHYgPSBzLmhlYXBba107XG4gIHZhciBqID0gayA8PCAxOyAgLyogbGVmdCBzb24gb2YgayAqL1xuICB3aGlsZSAoaiA8PSBzLmhlYXBfbGVuKSB7XG4gICAgLyogU2V0IGogdG8gdGhlIHNtYWxsZXN0IG9mIHRoZSB0d28gc29uczogKi9cbiAgICBpZiAoaiA8IHMuaGVhcF9sZW4gJiZcbiAgICAgIHNtYWxsZXIodHJlZSwgcy5oZWFwW2orMV0sIHMuaGVhcFtqXSwgcy5kZXB0aCkpIHtcbiAgICAgIGorKztcbiAgICB9XG4gICAgLyogRXhpdCBpZiB2IGlzIHNtYWxsZXIgdGhhbiBib3RoIHNvbnMgKi9cbiAgICBpZiAoc21hbGxlcih0cmVlLCB2LCBzLmhlYXBbal0sIHMuZGVwdGgpKSB7IGJyZWFrOyB9XG5cbiAgICAvKiBFeGNoYW5nZSB2IHdpdGggdGhlIHNtYWxsZXN0IHNvbiAqL1xuICAgIHMuaGVhcFtrXSA9IHMuaGVhcFtqXTtcbiAgICBrID0gajtcblxuICAgIC8qIEFuZCBjb250aW51ZSBkb3duIHRoZSB0cmVlLCBzZXR0aW5nIGogdG8gdGhlIGxlZnQgc29uIG9mIGsgKi9cbiAgICBqIDw8PSAxO1xuICB9XG4gIHMuaGVhcFtrXSA9IHY7XG59XG5cblxuLy8gaW5saW5lZCBtYW51YWxseVxuLy8gdmFyIFNNQUxMRVNUID0gMTtcblxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBTZW5kIHRoZSBibG9jayBkYXRhIGNvbXByZXNzZWQgdXNpbmcgdGhlIGdpdmVuIEh1ZmZtYW4gdHJlZXNcbiAqL1xuZnVuY3Rpb24gY29tcHJlc3NfYmxvY2socywgbHRyZWUsIGR0cmVlKVxuLy8gICAgZGVmbGF0ZV9zdGF0ZSAqcztcbi8vICAgIGNvbnN0IGN0X2RhdGEgKmx0cmVlOyAvKiBsaXRlcmFsIHRyZWUgKi9cbi8vICAgIGNvbnN0IGN0X2RhdGEgKmR0cmVlOyAvKiBkaXN0YW5jZSB0cmVlICovXG57XG4gIHZhciBkaXN0OyAgICAgICAgICAgLyogZGlzdGFuY2Ugb2YgbWF0Y2hlZCBzdHJpbmcgKi9cbiAgdmFyIGxjOyAgICAgICAgICAgICAvKiBtYXRjaCBsZW5ndGggb3IgdW5tYXRjaGVkIGNoYXIgKGlmIGRpc3QgPT0gMCkgKi9cbiAgdmFyIGx4ID0gMDsgICAgICAgICAvKiBydW5uaW5nIGluZGV4IGluIGxfYnVmICovXG4gIHZhciBjb2RlOyAgICAgICAgICAgLyogdGhlIGNvZGUgdG8gc2VuZCAqL1xuICB2YXIgZXh0cmE7ICAgICAgICAgIC8qIG51bWJlciBvZiBleHRyYSBiaXRzIHRvIHNlbmQgKi9cblxuICBpZiAocy5sYXN0X2xpdCAhPT0gMCkge1xuICAgIGRvIHtcbiAgICAgIGRpc3QgPSAocy5wZW5kaW5nX2J1ZltzLmRfYnVmICsgbHgqMl0gPDwgOCkgfCAocy5wZW5kaW5nX2J1ZltzLmRfYnVmICsgbHgqMiArIDFdKTtcbiAgICAgIGxjID0gcy5wZW5kaW5nX2J1ZltzLmxfYnVmICsgbHhdO1xuICAgICAgbHgrKztcblxuICAgICAgaWYgKGRpc3QgPT09IDApIHtcbiAgICAgICAgc2VuZF9jb2RlKHMsIGxjLCBsdHJlZSk7IC8qIHNlbmQgYSBsaXRlcmFsIGJ5dGUgKi9cbiAgICAgICAgLy9UcmFjZWN2KGlzZ3JhcGgobGMpLCAoc3RkZXJyLFwiICclYycgXCIsIGxjKSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvKiBIZXJlLCBsYyBpcyB0aGUgbWF0Y2ggbGVuZ3RoIC0gTUlOX01BVENIICovXG4gICAgICAgIGNvZGUgPSBfbGVuZ3RoX2NvZGVbbGNdO1xuICAgICAgICBzZW5kX2NvZGUocywgY29kZStMSVRFUkFMUysxLCBsdHJlZSk7IC8qIHNlbmQgdGhlIGxlbmd0aCBjb2RlICovXG4gICAgICAgIGV4dHJhID0gZXh0cmFfbGJpdHNbY29kZV07XG4gICAgICAgIGlmIChleHRyYSAhPT0gMCkge1xuICAgICAgICAgIGxjIC09IGJhc2VfbGVuZ3RoW2NvZGVdO1xuICAgICAgICAgIHNlbmRfYml0cyhzLCBsYywgZXh0cmEpOyAgICAgICAvKiBzZW5kIHRoZSBleHRyYSBsZW5ndGggYml0cyAqL1xuICAgICAgICB9XG4gICAgICAgIGRpc3QtLTsgLyogZGlzdCBpcyBub3cgdGhlIG1hdGNoIGRpc3RhbmNlIC0gMSAqL1xuICAgICAgICBjb2RlID0gZF9jb2RlKGRpc3QpO1xuICAgICAgICAvL0Fzc2VydCAoY29kZSA8IERfQ09ERVMsIFwiYmFkIGRfY29kZVwiKTtcblxuICAgICAgICBzZW5kX2NvZGUocywgY29kZSwgZHRyZWUpOyAgICAgICAvKiBzZW5kIHRoZSBkaXN0YW5jZSBjb2RlICovXG4gICAgICAgIGV4dHJhID0gZXh0cmFfZGJpdHNbY29kZV07XG4gICAgICAgIGlmIChleHRyYSAhPT0gMCkge1xuICAgICAgICAgIGRpc3QgLT0gYmFzZV9kaXN0W2NvZGVdO1xuICAgICAgICAgIHNlbmRfYml0cyhzLCBkaXN0LCBleHRyYSk7ICAgLyogc2VuZCB0aGUgZXh0cmEgZGlzdGFuY2UgYml0cyAqL1xuICAgICAgICB9XG4gICAgICB9IC8qIGxpdGVyYWwgb3IgbWF0Y2ggcGFpciA/ICovXG5cbiAgICAgIC8qIENoZWNrIHRoYXQgdGhlIG92ZXJsYXkgYmV0d2VlbiBwZW5kaW5nX2J1ZiBhbmQgZF9idWYrbF9idWYgaXMgb2s6ICovXG4gICAgICAvL0Fzc2VydCgodUludCkocy0+cGVuZGluZykgPCBzLT5saXRfYnVmc2l6ZSArIDIqbHgsXG4gICAgICAvLyAgICAgICBcInBlbmRpbmdCdWYgb3ZlcmZsb3dcIik7XG5cbiAgICB9IHdoaWxlIChseCA8IHMubGFzdF9saXQpO1xuICB9XG5cbiAgc2VuZF9jb2RlKHMsIEVORF9CTE9DSywgbHRyZWUpO1xufVxuXG5cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogQ29uc3RydWN0IG9uZSBIdWZmbWFuIHRyZWUgYW5kIGFzc2lnbnMgdGhlIGNvZGUgYml0IHN0cmluZ3MgYW5kIGxlbmd0aHMuXG4gKiBVcGRhdGUgdGhlIHRvdGFsIGJpdCBsZW5ndGggZm9yIHRoZSBjdXJyZW50IGJsb2NrLlxuICogSU4gYXNzZXJ0aW9uOiB0aGUgZmllbGQgZnJlcSBpcyBzZXQgZm9yIGFsbCB0cmVlIGVsZW1lbnRzLlxuICogT1VUIGFzc2VydGlvbnM6IHRoZSBmaWVsZHMgbGVuIGFuZCBjb2RlIGFyZSBzZXQgdG8gdGhlIG9wdGltYWwgYml0IGxlbmd0aFxuICogICAgIGFuZCBjb3JyZXNwb25kaW5nIGNvZGUuIFRoZSBsZW5ndGggb3B0X2xlbiBpcyB1cGRhdGVkOyBzdGF0aWNfbGVuIGlzXG4gKiAgICAgYWxzbyB1cGRhdGVkIGlmIHN0cmVlIGlzIG5vdCBudWxsLiBUaGUgZmllbGQgbWF4X2NvZGUgaXMgc2V0LlxuICovXG5mdW5jdGlvbiBidWlsZF90cmVlKHMsIGRlc2MpXG4vLyAgICBkZWZsYXRlX3N0YXRlICpzO1xuLy8gICAgdHJlZV9kZXNjICpkZXNjOyAvKiB0aGUgdHJlZSBkZXNjcmlwdG9yICovXG57XG4gIHZhciB0cmVlICAgICA9IGRlc2MuZHluX3RyZWU7XG4gIHZhciBzdHJlZSAgICA9IGRlc2Muc3RhdF9kZXNjLnN0YXRpY190cmVlO1xuICB2YXIgaGFzX3N0cmVlID0gZGVzYy5zdGF0X2Rlc2MuaGFzX3N0cmVlO1xuICB2YXIgZWxlbXMgICAgPSBkZXNjLnN0YXRfZGVzYy5lbGVtcztcbiAgdmFyIG4sIG07ICAgICAgICAgIC8qIGl0ZXJhdGUgb3ZlciBoZWFwIGVsZW1lbnRzICovXG4gIHZhciBtYXhfY29kZSA9IC0xOyAvKiBsYXJnZXN0IGNvZGUgd2l0aCBub24gemVybyBmcmVxdWVuY3kgKi9cbiAgdmFyIG5vZGU7ICAgICAgICAgIC8qIG5ldyBub2RlIGJlaW5nIGNyZWF0ZWQgKi9cblxuICAvKiBDb25zdHJ1Y3QgdGhlIGluaXRpYWwgaGVhcCwgd2l0aCBsZWFzdCBmcmVxdWVudCBlbGVtZW50IGluXG4gICAqIGhlYXBbU01BTExFU1RdLiBUaGUgc29ucyBvZiBoZWFwW25dIGFyZSBoZWFwWzIqbl0gYW5kIGhlYXBbMipuKzFdLlxuICAgKiBoZWFwWzBdIGlzIG5vdCB1c2VkLlxuICAgKi9cbiAgcy5oZWFwX2xlbiA9IDA7XG4gIHMuaGVhcF9tYXggPSBIRUFQX1NJWkU7XG5cbiAgZm9yIChuID0gMDsgbiA8IGVsZW1zOyBuKyspIHtcbiAgICBpZiAodHJlZVtuICogMl0vKi5GcmVxKi8gIT09IDApIHtcbiAgICAgIHMuaGVhcFsrK3MuaGVhcF9sZW5dID0gbWF4X2NvZGUgPSBuO1xuICAgICAgcy5kZXB0aFtuXSA9IDA7XG5cbiAgICB9IGVsc2Uge1xuICAgICAgdHJlZVtuKjIgKyAxXS8qLkxlbiovID0gMDtcbiAgICB9XG4gIH1cblxuICAvKiBUaGUgcGt6aXAgZm9ybWF0IHJlcXVpcmVzIHRoYXQgYXQgbGVhc3Qgb25lIGRpc3RhbmNlIGNvZGUgZXhpc3RzLFxuICAgKiBhbmQgdGhhdCBhdCBsZWFzdCBvbmUgYml0IHNob3VsZCBiZSBzZW50IGV2ZW4gaWYgdGhlcmUgaXMgb25seSBvbmVcbiAgICogcG9zc2libGUgY29kZS4gU28gdG8gYXZvaWQgc3BlY2lhbCBjaGVja3MgbGF0ZXIgb24gd2UgZm9yY2UgYXQgbGVhc3RcbiAgICogdHdvIGNvZGVzIG9mIG5vbiB6ZXJvIGZyZXF1ZW5jeS5cbiAgICovXG4gIHdoaWxlIChzLmhlYXBfbGVuIDwgMikge1xuICAgIG5vZGUgPSBzLmhlYXBbKytzLmhlYXBfbGVuXSA9IChtYXhfY29kZSA8IDIgPyArK21heF9jb2RlIDogMCk7XG4gICAgdHJlZVtub2RlICogMl0vKi5GcmVxKi8gPSAxO1xuICAgIHMuZGVwdGhbbm9kZV0gPSAwO1xuICAgIHMub3B0X2xlbi0tO1xuXG4gICAgaWYgKGhhc19zdHJlZSkge1xuICAgICAgcy5zdGF0aWNfbGVuIC09IHN0cmVlW25vZGUqMiArIDFdLyouTGVuKi87XG4gICAgfVxuICAgIC8qIG5vZGUgaXMgMCBvciAxIHNvIGl0IGRvZXMgbm90IGhhdmUgZXh0cmEgYml0cyAqL1xuICB9XG4gIGRlc2MubWF4X2NvZGUgPSBtYXhfY29kZTtcblxuICAvKiBUaGUgZWxlbWVudHMgaGVhcFtoZWFwX2xlbi8yKzEgLi4gaGVhcF9sZW5dIGFyZSBsZWF2ZXMgb2YgdGhlIHRyZWUsXG4gICAqIGVzdGFibGlzaCBzdWItaGVhcHMgb2YgaW5jcmVhc2luZyBsZW5ndGhzOlxuICAgKi9cbiAgZm9yIChuID0gKHMuaGVhcF9sZW4gPj4gMS8qaW50IC8yKi8pOyBuID49IDE7IG4tLSkgeyBwcWRvd25oZWFwKHMsIHRyZWUsIG4pOyB9XG5cbiAgLyogQ29uc3RydWN0IHRoZSBIdWZmbWFuIHRyZWUgYnkgcmVwZWF0ZWRseSBjb21iaW5pbmcgdGhlIGxlYXN0IHR3b1xuICAgKiBmcmVxdWVudCBub2Rlcy5cbiAgICovXG4gIG5vZGUgPSBlbGVtczsgICAgICAgICAgICAgIC8qIG5leHQgaW50ZXJuYWwgbm9kZSBvZiB0aGUgdHJlZSAqL1xuICBkbyB7XG4gICAgLy9wcXJlbW92ZShzLCB0cmVlLCBuKTsgIC8qIG4gPSBub2RlIG9mIGxlYXN0IGZyZXF1ZW5jeSAqL1xuICAgIC8qKiogcHFyZW1vdmUgKioqL1xuICAgIG4gPSBzLmhlYXBbMS8qU01BTExFU1QqL107XG4gICAgcy5oZWFwWzEvKlNNQUxMRVNUKi9dID0gcy5oZWFwW3MuaGVhcF9sZW4tLV07XG4gICAgcHFkb3duaGVhcChzLCB0cmVlLCAxLypTTUFMTEVTVCovKTtcbiAgICAvKioqL1xuXG4gICAgbSA9IHMuaGVhcFsxLypTTUFMTEVTVCovXTsgLyogbSA9IG5vZGUgb2YgbmV4dCBsZWFzdCBmcmVxdWVuY3kgKi9cblxuICAgIHMuaGVhcFstLXMuaGVhcF9tYXhdID0gbjsgLyoga2VlcCB0aGUgbm9kZXMgc29ydGVkIGJ5IGZyZXF1ZW5jeSAqL1xuICAgIHMuaGVhcFstLXMuaGVhcF9tYXhdID0gbTtcblxuICAgIC8qIENyZWF0ZSBhIG5ldyBub2RlIGZhdGhlciBvZiBuIGFuZCBtICovXG4gICAgdHJlZVtub2RlICogMl0vKi5GcmVxKi8gPSB0cmVlW24gKiAyXS8qLkZyZXEqLyArIHRyZWVbbSAqIDJdLyouRnJlcSovO1xuICAgIHMuZGVwdGhbbm9kZV0gPSAocy5kZXB0aFtuXSA+PSBzLmRlcHRoW21dID8gcy5kZXB0aFtuXSA6IHMuZGVwdGhbbV0pICsgMTtcbiAgICB0cmVlW24qMiArIDFdLyouRGFkKi8gPSB0cmVlW20qMiArIDFdLyouRGFkKi8gPSBub2RlO1xuXG4gICAgLyogYW5kIGluc2VydCB0aGUgbmV3IG5vZGUgaW4gdGhlIGhlYXAgKi9cbiAgICBzLmhlYXBbMS8qU01BTExFU1QqL10gPSBub2RlKys7XG4gICAgcHFkb3duaGVhcChzLCB0cmVlLCAxLypTTUFMTEVTVCovKTtcblxuICB9IHdoaWxlIChzLmhlYXBfbGVuID49IDIpO1xuXG4gIHMuaGVhcFstLXMuaGVhcF9tYXhdID0gcy5oZWFwWzEvKlNNQUxMRVNUKi9dO1xuXG4gIC8qIEF0IHRoaXMgcG9pbnQsIHRoZSBmaWVsZHMgZnJlcSBhbmQgZGFkIGFyZSBzZXQuIFdlIGNhbiBub3dcbiAgICogZ2VuZXJhdGUgdGhlIGJpdCBsZW5ndGhzLlxuICAgKi9cbiAgZ2VuX2JpdGxlbihzLCBkZXNjKTtcblxuICAvKiBUaGUgZmllbGQgbGVuIGlzIG5vdyBzZXQsIHdlIGNhbiBnZW5lcmF0ZSB0aGUgYml0IGNvZGVzICovXG4gIGdlbl9jb2Rlcyh0cmVlLCBtYXhfY29kZSwgcy5ibF9jb3VudCk7XG59XG5cblxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBTY2FuIGEgbGl0ZXJhbCBvciBkaXN0YW5jZSB0cmVlIHRvIGRldGVybWluZSB0aGUgZnJlcXVlbmNpZXMgb2YgdGhlIGNvZGVzXG4gKiBpbiB0aGUgYml0IGxlbmd0aCB0cmVlLlxuICovXG5mdW5jdGlvbiBzY2FuX3RyZWUocywgdHJlZSwgbWF4X2NvZGUpXG4vLyAgICBkZWZsYXRlX3N0YXRlICpzO1xuLy8gICAgY3RfZGF0YSAqdHJlZTsgICAvKiB0aGUgdHJlZSB0byBiZSBzY2FubmVkICovXG4vLyAgICBpbnQgbWF4X2NvZGU7ICAgIC8qIGFuZCBpdHMgbGFyZ2VzdCBjb2RlIG9mIG5vbiB6ZXJvIGZyZXF1ZW5jeSAqL1xue1xuICB2YXIgbjsgICAgICAgICAgICAgICAgICAgICAvKiBpdGVyYXRlcyBvdmVyIGFsbCB0cmVlIGVsZW1lbnRzICovXG4gIHZhciBwcmV2bGVuID0gLTE7ICAgICAgICAgIC8qIGxhc3QgZW1pdHRlZCBsZW5ndGggKi9cbiAgdmFyIGN1cmxlbjsgICAgICAgICAgICAgICAgLyogbGVuZ3RoIG9mIGN1cnJlbnQgY29kZSAqL1xuXG4gIHZhciBuZXh0bGVuID0gdHJlZVswKjIgKyAxXS8qLkxlbiovOyAvKiBsZW5ndGggb2YgbmV4dCBjb2RlICovXG5cbiAgdmFyIGNvdW50ID0gMDsgICAgICAgICAgICAgLyogcmVwZWF0IGNvdW50IG9mIHRoZSBjdXJyZW50IGNvZGUgKi9cbiAgdmFyIG1heF9jb3VudCA9IDc7ICAgICAgICAgLyogbWF4IHJlcGVhdCBjb3VudCAqL1xuICB2YXIgbWluX2NvdW50ID0gNDsgICAgICAgICAvKiBtaW4gcmVwZWF0IGNvdW50ICovXG5cbiAgaWYgKG5leHRsZW4gPT09IDApIHtcbiAgICBtYXhfY291bnQgPSAxMzg7XG4gICAgbWluX2NvdW50ID0gMztcbiAgfVxuICB0cmVlWyhtYXhfY29kZSsxKSoyICsgMV0vKi5MZW4qLyA9IDB4ZmZmZjsgLyogZ3VhcmQgKi9cblxuICBmb3IgKG4gPSAwOyBuIDw9IG1heF9jb2RlOyBuKyspIHtcbiAgICBjdXJsZW4gPSBuZXh0bGVuO1xuICAgIG5leHRsZW4gPSB0cmVlWyhuKzEpKjIgKyAxXS8qLkxlbiovO1xuXG4gICAgaWYgKCsrY291bnQgPCBtYXhfY291bnQgJiYgY3VybGVuID09PSBuZXh0bGVuKSB7XG4gICAgICBjb250aW51ZTtcblxuICAgIH0gZWxzZSBpZiAoY291bnQgPCBtaW5fY291bnQpIHtcbiAgICAgIHMuYmxfdHJlZVtjdXJsZW4gKiAyXS8qLkZyZXEqLyArPSBjb3VudDtcblxuICAgIH0gZWxzZSBpZiAoY3VybGVuICE9PSAwKSB7XG5cbiAgICAgIGlmIChjdXJsZW4gIT09IHByZXZsZW4pIHsgcy5ibF90cmVlW2N1cmxlbiAqIDJdLyouRnJlcSovKys7IH1cbiAgICAgIHMuYmxfdHJlZVtSRVBfM182KjJdLyouRnJlcSovKys7XG5cbiAgICB9IGVsc2UgaWYgKGNvdW50IDw9IDEwKSB7XG4gICAgICBzLmJsX3RyZWVbUkVQWl8zXzEwKjJdLyouRnJlcSovKys7XG5cbiAgICB9IGVsc2Uge1xuICAgICAgcy5ibF90cmVlW1JFUFpfMTFfMTM4KjJdLyouRnJlcSovKys7XG4gICAgfVxuXG4gICAgY291bnQgPSAwO1xuICAgIHByZXZsZW4gPSBjdXJsZW47XG5cbiAgICBpZiAobmV4dGxlbiA9PT0gMCkge1xuICAgICAgbWF4X2NvdW50ID0gMTM4O1xuICAgICAgbWluX2NvdW50ID0gMztcblxuICAgIH0gZWxzZSBpZiAoY3VybGVuID09PSBuZXh0bGVuKSB7XG4gICAgICBtYXhfY291bnQgPSA2O1xuICAgICAgbWluX2NvdW50ID0gMztcblxuICAgIH0gZWxzZSB7XG4gICAgICBtYXhfY291bnQgPSA3O1xuICAgICAgbWluX2NvdW50ID0gNDtcbiAgICB9XG4gIH1cbn1cblxuXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIFNlbmQgYSBsaXRlcmFsIG9yIGRpc3RhbmNlIHRyZWUgaW4gY29tcHJlc3NlZCBmb3JtLCB1c2luZyB0aGUgY29kZXMgaW5cbiAqIGJsX3RyZWUuXG4gKi9cbmZ1bmN0aW9uIHNlbmRfdHJlZShzLCB0cmVlLCBtYXhfY29kZSlcbi8vICAgIGRlZmxhdGVfc3RhdGUgKnM7XG4vLyAgICBjdF9kYXRhICp0cmVlOyAvKiB0aGUgdHJlZSB0byBiZSBzY2FubmVkICovXG4vLyAgICBpbnQgbWF4X2NvZGU7ICAgICAgIC8qIGFuZCBpdHMgbGFyZ2VzdCBjb2RlIG9mIG5vbiB6ZXJvIGZyZXF1ZW5jeSAqL1xue1xuICB2YXIgbjsgICAgICAgICAgICAgICAgICAgICAvKiBpdGVyYXRlcyBvdmVyIGFsbCB0cmVlIGVsZW1lbnRzICovXG4gIHZhciBwcmV2bGVuID0gLTE7ICAgICAgICAgIC8qIGxhc3QgZW1pdHRlZCBsZW5ndGggKi9cbiAgdmFyIGN1cmxlbjsgICAgICAgICAgICAgICAgLyogbGVuZ3RoIG9mIGN1cnJlbnQgY29kZSAqL1xuXG4gIHZhciBuZXh0bGVuID0gdHJlZVswKjIgKyAxXS8qLkxlbiovOyAvKiBsZW5ndGggb2YgbmV4dCBjb2RlICovXG5cbiAgdmFyIGNvdW50ID0gMDsgICAgICAgICAgICAgLyogcmVwZWF0IGNvdW50IG9mIHRoZSBjdXJyZW50IGNvZGUgKi9cbiAgdmFyIG1heF9jb3VudCA9IDc7ICAgICAgICAgLyogbWF4IHJlcGVhdCBjb3VudCAqL1xuICB2YXIgbWluX2NvdW50ID0gNDsgICAgICAgICAvKiBtaW4gcmVwZWF0IGNvdW50ICovXG5cbiAgLyogdHJlZVttYXhfY29kZSsxXS5MZW4gPSAtMTsgKi8gIC8qIGd1YXJkIGFscmVhZHkgc2V0ICovXG4gIGlmIChuZXh0bGVuID09PSAwKSB7XG4gICAgbWF4X2NvdW50ID0gMTM4O1xuICAgIG1pbl9jb3VudCA9IDM7XG4gIH1cblxuICBmb3IgKG4gPSAwOyBuIDw9IG1heF9jb2RlOyBuKyspIHtcbiAgICBjdXJsZW4gPSBuZXh0bGVuO1xuICAgIG5leHRsZW4gPSB0cmVlWyhuKzEpKjIgKyAxXS8qLkxlbiovO1xuXG4gICAgaWYgKCsrY291bnQgPCBtYXhfY291bnQgJiYgY3VybGVuID09PSBuZXh0bGVuKSB7XG4gICAgICBjb250aW51ZTtcblxuICAgIH0gZWxzZSBpZiAoY291bnQgPCBtaW5fY291bnQpIHtcbiAgICAgIGRvIHsgc2VuZF9jb2RlKHMsIGN1cmxlbiwgcy5ibF90cmVlKTsgfSB3aGlsZSAoLS1jb3VudCAhPT0gMCk7XG5cbiAgICB9IGVsc2UgaWYgKGN1cmxlbiAhPT0gMCkge1xuICAgICAgaWYgKGN1cmxlbiAhPT0gcHJldmxlbikge1xuICAgICAgICBzZW5kX2NvZGUocywgY3VybGVuLCBzLmJsX3RyZWUpO1xuICAgICAgICBjb3VudC0tO1xuICAgICAgfVxuICAgICAgLy9Bc3NlcnQoY291bnQgPj0gMyAmJiBjb3VudCA8PSA2LCBcIiAzXzY/XCIpO1xuICAgICAgc2VuZF9jb2RlKHMsIFJFUF8zXzYsIHMuYmxfdHJlZSk7XG4gICAgICBzZW5kX2JpdHMocywgY291bnQtMywgMik7XG5cbiAgICB9IGVsc2UgaWYgKGNvdW50IDw9IDEwKSB7XG4gICAgICBzZW5kX2NvZGUocywgUkVQWl8zXzEwLCBzLmJsX3RyZWUpO1xuICAgICAgc2VuZF9iaXRzKHMsIGNvdW50LTMsIDMpO1xuXG4gICAgfSBlbHNlIHtcbiAgICAgIHNlbmRfY29kZShzLCBSRVBaXzExXzEzOCwgcy5ibF90cmVlKTtcbiAgICAgIHNlbmRfYml0cyhzLCBjb3VudC0xMSwgNyk7XG4gICAgfVxuXG4gICAgY291bnQgPSAwO1xuICAgIHByZXZsZW4gPSBjdXJsZW47XG4gICAgaWYgKG5leHRsZW4gPT09IDApIHtcbiAgICAgIG1heF9jb3VudCA9IDEzODtcbiAgICAgIG1pbl9jb3VudCA9IDM7XG5cbiAgICB9IGVsc2UgaWYgKGN1cmxlbiA9PT0gbmV4dGxlbikge1xuICAgICAgbWF4X2NvdW50ID0gNjtcbiAgICAgIG1pbl9jb3VudCA9IDM7XG5cbiAgICB9IGVsc2Uge1xuICAgICAgbWF4X2NvdW50ID0gNztcbiAgICAgIG1pbl9jb3VudCA9IDQ7XG4gICAgfVxuICB9XG59XG5cblxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBDb25zdHJ1Y3QgdGhlIEh1ZmZtYW4gdHJlZSBmb3IgdGhlIGJpdCBsZW5ndGhzIGFuZCByZXR1cm4gdGhlIGluZGV4IGluXG4gKiBibF9vcmRlciBvZiB0aGUgbGFzdCBiaXQgbGVuZ3RoIGNvZGUgdG8gc2VuZC5cbiAqL1xuZnVuY3Rpb24gYnVpbGRfYmxfdHJlZShzKSB7XG4gIHZhciBtYXhfYmxpbmRleDsgIC8qIGluZGV4IG9mIGxhc3QgYml0IGxlbmd0aCBjb2RlIG9mIG5vbiB6ZXJvIGZyZXEgKi9cblxuICAvKiBEZXRlcm1pbmUgdGhlIGJpdCBsZW5ndGggZnJlcXVlbmNpZXMgZm9yIGxpdGVyYWwgYW5kIGRpc3RhbmNlIHRyZWVzICovXG4gIHNjYW5fdHJlZShzLCBzLmR5bl9sdHJlZSwgcy5sX2Rlc2MubWF4X2NvZGUpO1xuICBzY2FuX3RyZWUocywgcy5keW5fZHRyZWUsIHMuZF9kZXNjLm1heF9jb2RlKTtcblxuICAvKiBCdWlsZCB0aGUgYml0IGxlbmd0aCB0cmVlOiAqL1xuICBidWlsZF90cmVlKHMsIHMuYmxfZGVzYyk7XG4gIC8qIG9wdF9sZW4gbm93IGluY2x1ZGVzIHRoZSBsZW5ndGggb2YgdGhlIHRyZWUgcmVwcmVzZW50YXRpb25zLCBleGNlcHRcbiAgICogdGhlIGxlbmd0aHMgb2YgdGhlIGJpdCBsZW5ndGhzIGNvZGVzIGFuZCB0aGUgNSs1KzQgYml0cyBmb3IgdGhlIGNvdW50cy5cbiAgICovXG5cbiAgLyogRGV0ZXJtaW5lIHRoZSBudW1iZXIgb2YgYml0IGxlbmd0aCBjb2RlcyB0byBzZW5kLiBUaGUgcGt6aXAgZm9ybWF0XG4gICAqIHJlcXVpcmVzIHRoYXQgYXQgbGVhc3QgNCBiaXQgbGVuZ3RoIGNvZGVzIGJlIHNlbnQuIChhcHBub3RlLnR4dCBzYXlzXG4gICAqIDMgYnV0IHRoZSBhY3R1YWwgdmFsdWUgdXNlZCBpcyA0LilcbiAgICovXG4gIGZvciAobWF4X2JsaW5kZXggPSBCTF9DT0RFUy0xOyBtYXhfYmxpbmRleCA+PSAzOyBtYXhfYmxpbmRleC0tKSB7XG4gICAgaWYgKHMuYmxfdHJlZVtibF9vcmRlclttYXhfYmxpbmRleF0qMiArIDFdLyouTGVuKi8gIT09IDApIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuICAvKiBVcGRhdGUgb3B0X2xlbiB0byBpbmNsdWRlIHRoZSBiaXQgbGVuZ3RoIHRyZWUgYW5kIGNvdW50cyAqL1xuICBzLm9wdF9sZW4gKz0gMyoobWF4X2JsaW5kZXgrMSkgKyA1KzUrNDtcbiAgLy9UcmFjZXYoKHN0ZGVyciwgXCJcXG5keW4gdHJlZXM6IGR5biAlbGQsIHN0YXQgJWxkXCIsXG4gIC8vICAgICAgICBzLT5vcHRfbGVuLCBzLT5zdGF0aWNfbGVuKSk7XG5cbiAgcmV0dXJuIG1heF9ibGluZGV4O1xufVxuXG5cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogU2VuZCB0aGUgaGVhZGVyIGZvciBhIGJsb2NrIHVzaW5nIGR5bmFtaWMgSHVmZm1hbiB0cmVlczogdGhlIGNvdW50cywgdGhlXG4gKiBsZW5ndGhzIG9mIHRoZSBiaXQgbGVuZ3RoIGNvZGVzLCB0aGUgbGl0ZXJhbCB0cmVlIGFuZCB0aGUgZGlzdGFuY2UgdHJlZS5cbiAqIElOIGFzc2VydGlvbjogbGNvZGVzID49IDI1NywgZGNvZGVzID49IDEsIGJsY29kZXMgPj0gNC5cbiAqL1xuZnVuY3Rpb24gc2VuZF9hbGxfdHJlZXMocywgbGNvZGVzLCBkY29kZXMsIGJsY29kZXMpXG4vLyAgICBkZWZsYXRlX3N0YXRlICpzO1xuLy8gICAgaW50IGxjb2RlcywgZGNvZGVzLCBibGNvZGVzOyAvKiBudW1iZXIgb2YgY29kZXMgZm9yIGVhY2ggdHJlZSAqL1xue1xuICB2YXIgcmFuazsgICAgICAgICAgICAgICAgICAgIC8qIGluZGV4IGluIGJsX29yZGVyICovXG5cbiAgLy9Bc3NlcnQgKGxjb2RlcyA+PSAyNTcgJiYgZGNvZGVzID49IDEgJiYgYmxjb2RlcyA+PSA0LCBcIm5vdCBlbm91Z2ggY29kZXNcIik7XG4gIC8vQXNzZXJ0IChsY29kZXMgPD0gTF9DT0RFUyAmJiBkY29kZXMgPD0gRF9DT0RFUyAmJiBibGNvZGVzIDw9IEJMX0NPREVTLFxuICAvLyAgICAgICAgXCJ0b28gbWFueSBjb2Rlc1wiKTtcbiAgLy9UcmFjZXYoKHN0ZGVyciwgXCJcXG5ibCBjb3VudHM6IFwiKSk7XG4gIHNlbmRfYml0cyhzLCBsY29kZXMtMjU3LCA1KTsgLyogbm90ICsyNTUgYXMgc3RhdGVkIGluIGFwcG5vdGUudHh0ICovXG4gIHNlbmRfYml0cyhzLCBkY29kZXMtMSwgICA1KTtcbiAgc2VuZF9iaXRzKHMsIGJsY29kZXMtNCwgIDQpOyAvKiBub3QgLTMgYXMgc3RhdGVkIGluIGFwcG5vdGUudHh0ICovXG4gIGZvciAocmFuayA9IDA7IHJhbmsgPCBibGNvZGVzOyByYW5rKyspIHtcbiAgICAvL1RyYWNldigoc3RkZXJyLCBcIlxcbmJsIGNvZGUgJTJkIFwiLCBibF9vcmRlcltyYW5rXSkpO1xuICAgIHNlbmRfYml0cyhzLCBzLmJsX3RyZWVbYmxfb3JkZXJbcmFua10qMiArIDFdLyouTGVuKi8sIDMpO1xuICB9XG4gIC8vVHJhY2V2KChzdGRlcnIsIFwiXFxuYmwgdHJlZTogc2VudCAlbGRcIiwgcy0+Yml0c19zZW50KSk7XG5cbiAgc2VuZF90cmVlKHMsIHMuZHluX2x0cmVlLCBsY29kZXMtMSk7IC8qIGxpdGVyYWwgdHJlZSAqL1xuICAvL1RyYWNldigoc3RkZXJyLCBcIlxcbmxpdCB0cmVlOiBzZW50ICVsZFwiLCBzLT5iaXRzX3NlbnQpKTtcblxuICBzZW5kX3RyZWUocywgcy5keW5fZHRyZWUsIGRjb2Rlcy0xKTsgLyogZGlzdGFuY2UgdHJlZSAqL1xuICAvL1RyYWNldigoc3RkZXJyLCBcIlxcbmRpc3QgdHJlZTogc2VudCAlbGRcIiwgcy0+Yml0c19zZW50KSk7XG59XG5cblxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBDaGVjayBpZiB0aGUgZGF0YSB0eXBlIGlzIFRFWFQgb3IgQklOQVJZLCB1c2luZyB0aGUgZm9sbG93aW5nIGFsZ29yaXRobTpcbiAqIC0gVEVYVCBpZiB0aGUgdHdvIGNvbmRpdGlvbnMgYmVsb3cgYXJlIHNhdGlzZmllZDpcbiAqICAgIGEpIFRoZXJlIGFyZSBubyBub24tcG9ydGFibGUgY29udHJvbCBjaGFyYWN0ZXJzIGJlbG9uZ2luZyB0byB0aGVcbiAqICAgICAgIFwiYmxhY2sgbGlzdFwiICgwLi42LCAxNC4uMjUsIDI4Li4zMSkuXG4gKiAgICBiKSBUaGVyZSBpcyBhdCBsZWFzdCBvbmUgcHJpbnRhYmxlIGNoYXJhY3RlciBiZWxvbmdpbmcgdG8gdGhlXG4gKiAgICAgICBcIndoaXRlIGxpc3RcIiAoOSB7VEFCfSwgMTAge0xGfSwgMTMge0NSfSwgMzIuLjI1NSkuXG4gKiAtIEJJTkFSWSBvdGhlcndpc2UuXG4gKiAtIFRoZSBmb2xsb3dpbmcgcGFydGlhbGx5LXBvcnRhYmxlIGNvbnRyb2wgY2hhcmFjdGVycyBmb3JtIGFcbiAqICAgXCJncmF5IGxpc3RcIiB0aGF0IGlzIGlnbm9yZWQgaW4gdGhpcyBkZXRlY3Rpb24gYWxnb3JpdGhtOlxuICogICAoNyB7QkVMfSwgOCB7QlN9LCAxMSB7VlR9LCAxMiB7RkZ9LCAyNiB7U1VCfSwgMjcge0VTQ30pLlxuICogSU4gYXNzZXJ0aW9uOiB0aGUgZmllbGRzIEZyZXEgb2YgZHluX2x0cmVlIGFyZSBzZXQuXG4gKi9cbmZ1bmN0aW9uIGRldGVjdF9kYXRhX3R5cGUocykge1xuICAvKiBibGFja19tYXNrIGlzIHRoZSBiaXQgbWFzayBvZiBibGFjay1saXN0ZWQgYnl0ZXNcbiAgICogc2V0IGJpdHMgMC4uNiwgMTQuLjI1LCBhbmQgMjguLjMxXG4gICAqIDB4ZjNmZmMwN2YgPSBiaW5hcnkgMTExMTAwMTExMTExMTExMTExMDAwMDAwMDExMTExMTFcbiAgICovXG4gIHZhciBibGFja19tYXNrID0gMHhmM2ZmYzA3ZjtcbiAgdmFyIG47XG5cbiAgLyogQ2hlY2sgZm9yIG5vbi10ZXh0dWFsIChcImJsYWNrLWxpc3RlZFwiKSBieXRlcy4gKi9cbiAgZm9yIChuID0gMDsgbiA8PSAzMTsgbisrLCBibGFja19tYXNrID4+Pj0gMSkge1xuICAgIGlmICgoYmxhY2tfbWFzayAmIDEpICYmIChzLmR5bl9sdHJlZVtuKjJdLyouRnJlcSovICE9PSAwKSkge1xuICAgICAgcmV0dXJuIFpfQklOQVJZO1xuICAgIH1cbiAgfVxuXG4gIC8qIENoZWNrIGZvciB0ZXh0dWFsIChcIndoaXRlLWxpc3RlZFwiKSBieXRlcy4gKi9cbiAgaWYgKHMuZHluX2x0cmVlWzkgKiAyXS8qLkZyZXEqLyAhPT0gMCB8fCBzLmR5bl9sdHJlZVsxMCAqIDJdLyouRnJlcSovICE9PSAwIHx8XG4gICAgICBzLmR5bl9sdHJlZVsxMyAqIDJdLyouRnJlcSovICE9PSAwKSB7XG4gICAgcmV0dXJuIFpfVEVYVDtcbiAgfVxuICBmb3IgKG4gPSAzMjsgbiA8IExJVEVSQUxTOyBuKyspIHtcbiAgICBpZiAocy5keW5fbHRyZWVbbiAqIDJdLyouRnJlcSovICE9PSAwKSB7XG4gICAgICByZXR1cm4gWl9URVhUO1xuICAgIH1cbiAgfVxuXG4gIC8qIFRoZXJlIGFyZSBubyBcImJsYWNrLWxpc3RlZFwiIG9yIFwid2hpdGUtbGlzdGVkXCIgYnl0ZXM6XG4gICAqIHRoaXMgc3RyZWFtIGVpdGhlciBpcyBlbXB0eSBvciBoYXMgdG9sZXJhdGVkIChcImdyYXktbGlzdGVkXCIpIGJ5dGVzIG9ubHkuXG4gICAqL1xuICByZXR1cm4gWl9CSU5BUlk7XG59XG5cblxudmFyIHN0YXRpY19pbml0X2RvbmUgPSBmYWxzZTtcblxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBJbml0aWFsaXplIHRoZSB0cmVlIGRhdGEgc3RydWN0dXJlcyBmb3IgYSBuZXcgemxpYiBzdHJlYW0uXG4gKi9cbmZ1bmN0aW9uIF90cl9pbml0KHMpXG57XG5cbiAgaWYgKCFzdGF0aWNfaW5pdF9kb25lKSB7XG4gICAgdHJfc3RhdGljX2luaXQoKTtcbiAgICBzdGF0aWNfaW5pdF9kb25lID0gdHJ1ZTtcbiAgfVxuXG4gIHMubF9kZXNjICA9IG5ldyBUcmVlRGVzYyhzLmR5bl9sdHJlZSwgc3RhdGljX2xfZGVzYyk7XG4gIHMuZF9kZXNjICA9IG5ldyBUcmVlRGVzYyhzLmR5bl9kdHJlZSwgc3RhdGljX2RfZGVzYyk7XG4gIHMuYmxfZGVzYyA9IG5ldyBUcmVlRGVzYyhzLmJsX3RyZWUsIHN0YXRpY19ibF9kZXNjKTtcblxuICBzLmJpX2J1ZiA9IDA7XG4gIHMuYmlfdmFsaWQgPSAwO1xuXG4gIC8qIEluaXRpYWxpemUgdGhlIGZpcnN0IGJsb2NrIG9mIHRoZSBmaXJzdCBmaWxlOiAqL1xuICBpbml0X2Jsb2NrKHMpO1xufVxuXG5cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogU2VuZCBhIHN0b3JlZCBibG9ja1xuICovXG5mdW5jdGlvbiBfdHJfc3RvcmVkX2Jsb2NrKHMsIGJ1Ziwgc3RvcmVkX2xlbiwgbGFzdClcbi8vRGVmbGF0ZVN0YXRlICpzO1xuLy9jaGFyZiAqYnVmOyAgICAgICAvKiBpbnB1dCBibG9jayAqL1xuLy91bGcgc3RvcmVkX2xlbjsgICAvKiBsZW5ndGggb2YgaW5wdXQgYmxvY2sgKi9cbi8vaW50IGxhc3Q7ICAgICAgICAgLyogb25lIGlmIHRoaXMgaXMgdGhlIGxhc3QgYmxvY2sgZm9yIGEgZmlsZSAqL1xue1xuICBzZW5kX2JpdHMocywgKFNUT1JFRF9CTE9DSzw8MSkrKGxhc3QgPyAxIDogMCksIDMpOyAgICAvKiBzZW5kIGJsb2NrIHR5cGUgKi9cbiAgY29weV9ibG9jayhzLCBidWYsIHN0b3JlZF9sZW4sIHRydWUpOyAvKiB3aXRoIGhlYWRlciAqL1xufVxuXG5cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogU2VuZCBvbmUgZW1wdHkgc3RhdGljIGJsb2NrIHRvIGdpdmUgZW5vdWdoIGxvb2thaGVhZCBmb3IgaW5mbGF0ZS5cbiAqIFRoaXMgdGFrZXMgMTAgYml0cywgb2Ygd2hpY2ggNyBtYXkgcmVtYWluIGluIHRoZSBiaXQgYnVmZmVyLlxuICovXG5mdW5jdGlvbiBfdHJfYWxpZ24ocykge1xuICBzZW5kX2JpdHMocywgU1RBVElDX1RSRUVTPDwxLCAzKTtcbiAgc2VuZF9jb2RlKHMsIEVORF9CTE9DSywgc3RhdGljX2x0cmVlKTtcbiAgYmlfZmx1c2gocyk7XG59XG5cblxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBEZXRlcm1pbmUgdGhlIGJlc3QgZW5jb2RpbmcgZm9yIHRoZSBjdXJyZW50IGJsb2NrOiBkeW5hbWljIHRyZWVzLCBzdGF0aWNcbiAqIHRyZWVzIG9yIHN0b3JlLCBhbmQgb3V0cHV0IHRoZSBlbmNvZGVkIGJsb2NrIHRvIHRoZSB6aXAgZmlsZS5cbiAqL1xuZnVuY3Rpb24gX3RyX2ZsdXNoX2Jsb2NrKHMsIGJ1Ziwgc3RvcmVkX2xlbiwgbGFzdClcbi8vRGVmbGF0ZVN0YXRlICpzO1xuLy9jaGFyZiAqYnVmOyAgICAgICAvKiBpbnB1dCBibG9jaywgb3IgTlVMTCBpZiB0b28gb2xkICovXG4vL3VsZyBzdG9yZWRfbGVuOyAgIC8qIGxlbmd0aCBvZiBpbnB1dCBibG9jayAqL1xuLy9pbnQgbGFzdDsgICAgICAgICAvKiBvbmUgaWYgdGhpcyBpcyB0aGUgbGFzdCBibG9jayBmb3IgYSBmaWxlICovXG57XG4gIHZhciBvcHRfbGVuYiwgc3RhdGljX2xlbmI7ICAvKiBvcHRfbGVuIGFuZCBzdGF0aWNfbGVuIGluIGJ5dGVzICovXG4gIHZhciBtYXhfYmxpbmRleCA9IDA7ICAgICAgICAvKiBpbmRleCBvZiBsYXN0IGJpdCBsZW5ndGggY29kZSBvZiBub24gemVybyBmcmVxICovXG5cbiAgLyogQnVpbGQgdGhlIEh1ZmZtYW4gdHJlZXMgdW5sZXNzIGEgc3RvcmVkIGJsb2NrIGlzIGZvcmNlZCAqL1xuICBpZiAocy5sZXZlbCA+IDApIHtcblxuICAgIC8qIENoZWNrIGlmIHRoZSBmaWxlIGlzIGJpbmFyeSBvciB0ZXh0ICovXG4gICAgaWYgKHMuc3RybS5kYXRhX3R5cGUgPT09IFpfVU5LTk9XTikge1xuICAgICAgcy5zdHJtLmRhdGFfdHlwZSA9IGRldGVjdF9kYXRhX3R5cGUocyk7XG4gICAgfVxuXG4gICAgLyogQ29uc3RydWN0IHRoZSBsaXRlcmFsIGFuZCBkaXN0YW5jZSB0cmVlcyAqL1xuICAgIGJ1aWxkX3RyZWUocywgcy5sX2Rlc2MpO1xuICAgIC8vIFRyYWNldigoc3RkZXJyLCBcIlxcbmxpdCBkYXRhOiBkeW4gJWxkLCBzdGF0ICVsZFwiLCBzLT5vcHRfbGVuLFxuICAgIC8vICAgICAgICBzLT5zdGF0aWNfbGVuKSk7XG5cbiAgICBidWlsZF90cmVlKHMsIHMuZF9kZXNjKTtcbiAgICAvLyBUcmFjZXYoKHN0ZGVyciwgXCJcXG5kaXN0IGRhdGE6IGR5biAlbGQsIHN0YXQgJWxkXCIsIHMtPm9wdF9sZW4sXG4gICAgLy8gICAgICAgIHMtPnN0YXRpY19sZW4pKTtcbiAgICAvKiBBdCB0aGlzIHBvaW50LCBvcHRfbGVuIGFuZCBzdGF0aWNfbGVuIGFyZSB0aGUgdG90YWwgYml0IGxlbmd0aHMgb2ZcbiAgICAgKiB0aGUgY29tcHJlc3NlZCBibG9jayBkYXRhLCBleGNsdWRpbmcgdGhlIHRyZWUgcmVwcmVzZW50YXRpb25zLlxuICAgICAqL1xuXG4gICAgLyogQnVpbGQgdGhlIGJpdCBsZW5ndGggdHJlZSBmb3IgdGhlIGFib3ZlIHR3byB0cmVlcywgYW5kIGdldCB0aGUgaW5kZXhcbiAgICAgKiBpbiBibF9vcmRlciBvZiB0aGUgbGFzdCBiaXQgbGVuZ3RoIGNvZGUgdG8gc2VuZC5cbiAgICAgKi9cbiAgICBtYXhfYmxpbmRleCA9IGJ1aWxkX2JsX3RyZWUocyk7XG5cbiAgICAvKiBEZXRlcm1pbmUgdGhlIGJlc3QgZW5jb2RpbmcuIENvbXB1dGUgdGhlIGJsb2NrIGxlbmd0aHMgaW4gYnl0ZXMuICovXG4gICAgb3B0X2xlbmIgPSAocy5vcHRfbGVuKzMrNykgPj4+IDM7XG4gICAgc3RhdGljX2xlbmIgPSAocy5zdGF0aWNfbGVuKzMrNykgPj4+IDM7XG5cbiAgICAvLyBUcmFjZXYoKHN0ZGVyciwgXCJcXG5vcHQgJWx1KCVsdSkgc3RhdCAlbHUoJWx1KSBzdG9yZWQgJWx1IGxpdCAldSBcIixcbiAgICAvLyAgICAgICAgb3B0X2xlbmIsIHMtPm9wdF9sZW4sIHN0YXRpY19sZW5iLCBzLT5zdGF0aWNfbGVuLCBzdG9yZWRfbGVuLFxuICAgIC8vICAgICAgICBzLT5sYXN0X2xpdCkpO1xuXG4gICAgaWYgKHN0YXRpY19sZW5iIDw9IG9wdF9sZW5iKSB7IG9wdF9sZW5iID0gc3RhdGljX2xlbmI7IH1cblxuICB9IGVsc2Uge1xuICAgIC8vIEFzc2VydChidWYgIT0gKGNoYXIqKTAsIFwibG9zdCBidWZcIik7XG4gICAgb3B0X2xlbmIgPSBzdGF0aWNfbGVuYiA9IHN0b3JlZF9sZW4gKyA1OyAvKiBmb3JjZSBhIHN0b3JlZCBibG9jayAqL1xuICB9XG5cbiAgaWYgKChzdG9yZWRfbGVuKzQgPD0gb3B0X2xlbmIpICYmIChidWYgIT09IC0xKSkge1xuICAgIC8qIDQ6IHR3byB3b3JkcyBmb3IgdGhlIGxlbmd0aHMgKi9cblxuICAgIC8qIFRoZSB0ZXN0IGJ1ZiAhPSBOVUxMIGlzIG9ubHkgbmVjZXNzYXJ5IGlmIExJVF9CVUZTSVpFID4gV1NJWkUuXG4gICAgICogT3RoZXJ3aXNlIHdlIGNhbid0IGhhdmUgcHJvY2Vzc2VkIG1vcmUgdGhhbiBXU0laRSBpbnB1dCBieXRlcyBzaW5jZVxuICAgICAqIHRoZSBsYXN0IGJsb2NrIGZsdXNoLCBiZWNhdXNlIGNvbXByZXNzaW9uIHdvdWxkIGhhdmUgYmVlblxuICAgICAqIHN1Y2Nlc3NmdWwuIElmIExJVF9CVUZTSVpFIDw9IFdTSVpFLCBpdCBpcyBuZXZlciB0b28gbGF0ZSB0b1xuICAgICAqIHRyYW5zZm9ybSBhIGJsb2NrIGludG8gYSBzdG9yZWQgYmxvY2suXG4gICAgICovXG4gICAgX3RyX3N0b3JlZF9ibG9jayhzLCBidWYsIHN0b3JlZF9sZW4sIGxhc3QpO1xuXG4gIH0gZWxzZSBpZiAocy5zdHJhdGVneSA9PT0gWl9GSVhFRCB8fCBzdGF0aWNfbGVuYiA9PT0gb3B0X2xlbmIpIHtcblxuICAgIHNlbmRfYml0cyhzLCAoU1RBVElDX1RSRUVTPDwxKSArIChsYXN0ID8gMSA6IDApLCAzKTtcbiAgICBjb21wcmVzc19ibG9jayhzLCBzdGF0aWNfbHRyZWUsIHN0YXRpY19kdHJlZSk7XG5cbiAgfSBlbHNlIHtcbiAgICBzZW5kX2JpdHMocywgKERZTl9UUkVFUzw8MSkgKyAobGFzdCA/IDEgOiAwKSwgMyk7XG4gICAgc2VuZF9hbGxfdHJlZXMocywgcy5sX2Rlc2MubWF4X2NvZGUrMSwgcy5kX2Rlc2MubWF4X2NvZGUrMSwgbWF4X2JsaW5kZXgrMSk7XG4gICAgY29tcHJlc3NfYmxvY2socywgcy5keW5fbHRyZWUsIHMuZHluX2R0cmVlKTtcbiAgfVxuICAvLyBBc3NlcnQgKHMtPmNvbXByZXNzZWRfbGVuID09IHMtPmJpdHNfc2VudCwgXCJiYWQgY29tcHJlc3NlZCBzaXplXCIpO1xuICAvKiBUaGUgYWJvdmUgY2hlY2sgaXMgbWFkZSBtb2QgMl4zMiwgZm9yIGZpbGVzIGxhcmdlciB0aGFuIDUxMiBNQlxuICAgKiBhbmQgdUxvbmcgaW1wbGVtZW50ZWQgb24gMzIgYml0cy5cbiAgICovXG4gIGluaXRfYmxvY2socyk7XG5cbiAgaWYgKGxhc3QpIHtcbiAgICBiaV93aW5kdXAocyk7XG4gIH1cbiAgLy8gVHJhY2V2KChzdGRlcnIsXCJcXG5jb21wcmxlbiAlbHUoJWx1KSBcIiwgcy0+Y29tcHJlc3NlZF9sZW4+PjMsXG4gIC8vICAgICAgIHMtPmNvbXByZXNzZWRfbGVuLTcqbGFzdCkpO1xufVxuXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIFNhdmUgdGhlIG1hdGNoIGluZm8gYW5kIHRhbGx5IHRoZSBmcmVxdWVuY3kgY291bnRzLiBSZXR1cm4gdHJ1ZSBpZlxuICogdGhlIGN1cnJlbnQgYmxvY2sgbXVzdCBiZSBmbHVzaGVkLlxuICovXG5mdW5jdGlvbiBfdHJfdGFsbHkocywgZGlzdCwgbGMpXG4vLyAgICBkZWZsYXRlX3N0YXRlICpzO1xuLy8gICAgdW5zaWduZWQgZGlzdDsgIC8qIGRpc3RhbmNlIG9mIG1hdGNoZWQgc3RyaW5nICovXG4vLyAgICB1bnNpZ25lZCBsYzsgICAgLyogbWF0Y2ggbGVuZ3RoLU1JTl9NQVRDSCBvciB1bm1hdGNoZWQgY2hhciAoaWYgZGlzdD09MCkgKi9cbntcbiAgLy92YXIgb3V0X2xlbmd0aCwgaW5fbGVuZ3RoLCBkY29kZTtcblxuICBzLnBlbmRpbmdfYnVmW3MuZF9idWYgKyBzLmxhc3RfbGl0ICogMl0gICAgID0gKGRpc3QgPj4+IDgpICYgMHhmZjtcbiAgcy5wZW5kaW5nX2J1ZltzLmRfYnVmICsgcy5sYXN0X2xpdCAqIDIgKyAxXSA9IGRpc3QgJiAweGZmO1xuXG4gIHMucGVuZGluZ19idWZbcy5sX2J1ZiArIHMubGFzdF9saXRdID0gbGMgJiAweGZmO1xuICBzLmxhc3RfbGl0Kys7XG5cbiAgaWYgKGRpc3QgPT09IDApIHtcbiAgICAvKiBsYyBpcyB0aGUgdW5tYXRjaGVkIGNoYXIgKi9cbiAgICBzLmR5bl9sdHJlZVtsYyoyXS8qLkZyZXEqLysrO1xuICB9IGVsc2Uge1xuICAgIHMubWF0Y2hlcysrO1xuICAgIC8qIEhlcmUsIGxjIGlzIHRoZSBtYXRjaCBsZW5ndGggLSBNSU5fTUFUQ0ggKi9cbiAgICBkaXN0LS07ICAgICAgICAgICAgIC8qIGRpc3QgPSBtYXRjaCBkaXN0YW5jZSAtIDEgKi9cbiAgICAvL0Fzc2VydCgodXNoKWRpc3QgPCAodXNoKU1BWF9ESVNUKHMpICYmXG4gICAgLy8gICAgICAgKHVzaClsYyA8PSAodXNoKShNQVhfTUFUQ0gtTUlOX01BVENIKSAmJlxuICAgIC8vICAgICAgICh1c2gpZF9jb2RlKGRpc3QpIDwgKHVzaClEX0NPREVTLCAgXCJfdHJfdGFsbHk6IGJhZCBtYXRjaFwiKTtcblxuICAgIHMuZHluX2x0cmVlWyhfbGVuZ3RoX2NvZGVbbGNdK0xJVEVSQUxTKzEpICogMl0vKi5GcmVxKi8rKztcbiAgICBzLmR5bl9kdHJlZVtkX2NvZGUoZGlzdCkgKiAyXS8qLkZyZXEqLysrO1xuICB9XG5cbi8vICghKSBUaGlzIGJsb2NrIGlzIGRpc2FibGVkIGluIHpsaWIgZGVmYWlsdHMsXG4vLyBkb24ndCBlbmFibGUgaXQgZm9yIGJpbmFyeSBjb21wYXRpYmlsaXR5XG5cbi8vI2lmZGVmIFRSVU5DQVRFX0JMT0NLXG4vLyAgLyogVHJ5IHRvIGd1ZXNzIGlmIGl0IGlzIHByb2ZpdGFibGUgdG8gc3RvcCB0aGUgY3VycmVudCBibG9jayBoZXJlICovXG4vLyAgaWYgKChzLmxhc3RfbGl0ICYgMHgxZmZmKSA9PT0gMCAmJiBzLmxldmVsID4gMikge1xuLy8gICAgLyogQ29tcHV0ZSBhbiB1cHBlciBib3VuZCBmb3IgdGhlIGNvbXByZXNzZWQgbGVuZ3RoICovXG4vLyAgICBvdXRfbGVuZ3RoID0gcy5sYXN0X2xpdCo4O1xuLy8gICAgaW5fbGVuZ3RoID0gcy5zdHJzdGFydCAtIHMuYmxvY2tfc3RhcnQ7XG4vL1xuLy8gICAgZm9yIChkY29kZSA9IDA7IGRjb2RlIDwgRF9DT0RFUzsgZGNvZGUrKykge1xuLy8gICAgICBvdXRfbGVuZ3RoICs9IHMuZHluX2R0cmVlW2Rjb2RlKjJdLyouRnJlcSovICogKDUgKyBleHRyYV9kYml0c1tkY29kZV0pO1xuLy8gICAgfVxuLy8gICAgb3V0X2xlbmd0aCA+Pj49IDM7XG4vLyAgICAvL1RyYWNldigoc3RkZXJyLFwiXFxubGFzdF9saXQgJXUsIGluICVsZCwgb3V0IH4lbGQoJWxkJSUpIFwiLFxuLy8gICAgLy8gICAgICAgcy0+bGFzdF9saXQsIGluX2xlbmd0aCwgb3V0X2xlbmd0aCxcbi8vICAgIC8vICAgICAgIDEwMEwgLSBvdXRfbGVuZ3RoKjEwMEwvaW5fbGVuZ3RoKSk7XG4vLyAgICBpZiAocy5tYXRjaGVzIDwgKHMubGFzdF9saXQ+PjEpLyppbnQgLzIqLyAmJiBvdXRfbGVuZ3RoIDwgKGluX2xlbmd0aD4+MSkvKmludCAvMiovKSB7XG4vLyAgICAgIHJldHVybiB0cnVlO1xuLy8gICAgfVxuLy8gIH1cbi8vI2VuZGlmXG5cbiAgcmV0dXJuIChzLmxhc3RfbGl0ID09PSBzLmxpdF9idWZzaXplLTEpO1xuICAvKiBXZSBhdm9pZCBlcXVhbGl0eSB3aXRoIGxpdF9idWZzaXplIGJlY2F1c2Ugb2Ygd3JhcGFyb3VuZCBhdCA2NEtcbiAgICogb24gMTYgYml0IG1hY2hpbmVzIGFuZCBiZWNhdXNlIHN0b3JlZCBibG9ja3MgYXJlIHJlc3RyaWN0ZWQgdG9cbiAgICogNjRLLTEgYnl0ZXMuXG4gICAqL1xufVxuXG5leHBvcnRzLl90cl9pbml0ICA9IF90cl9pbml0O1xuZXhwb3J0cy5fdHJfc3RvcmVkX2Jsb2NrID0gX3RyX3N0b3JlZF9ibG9jaztcbmV4cG9ydHMuX3RyX2ZsdXNoX2Jsb2NrICA9IF90cl9mbHVzaF9ibG9jaztcbmV4cG9ydHMuX3RyX3RhbGx5ID0gX3RyX3RhbGx5O1xuZXhwb3J0cy5fdHJfYWxpZ24gPSBfdHJfYWxpZ247XG4iLCIndXNlIHN0cmljdCc7XG5cblxuZnVuY3Rpb24gWlN0cmVhbSgpIHtcbiAgLyogbmV4dCBpbnB1dCBieXRlICovXG4gIHRoaXMuaW5wdXQgPSBudWxsOyAvLyBKUyBzcGVjaWZpYywgYmVjYXVzZSB3ZSBoYXZlIG5vIHBvaW50ZXJzXG4gIHRoaXMubmV4dF9pbiA9IDA7XG4gIC8qIG51bWJlciBvZiBieXRlcyBhdmFpbGFibGUgYXQgaW5wdXQgKi9cbiAgdGhpcy5hdmFpbF9pbiA9IDA7XG4gIC8qIHRvdGFsIG51bWJlciBvZiBpbnB1dCBieXRlcyByZWFkIHNvIGZhciAqL1xuICB0aGlzLnRvdGFsX2luID0gMDtcbiAgLyogbmV4dCBvdXRwdXQgYnl0ZSBzaG91bGQgYmUgcHV0IHRoZXJlICovXG4gIHRoaXMub3V0cHV0ID0gbnVsbDsgLy8gSlMgc3BlY2lmaWMsIGJlY2F1c2Ugd2UgaGF2ZSBubyBwb2ludGVyc1xuICB0aGlzLm5leHRfb3V0ID0gMDtcbiAgLyogcmVtYWluaW5nIGZyZWUgc3BhY2UgYXQgb3V0cHV0ICovXG4gIHRoaXMuYXZhaWxfb3V0ID0gMDtcbiAgLyogdG90YWwgbnVtYmVyIG9mIGJ5dGVzIG91dHB1dCBzbyBmYXIgKi9cbiAgdGhpcy50b3RhbF9vdXQgPSAwO1xuICAvKiBsYXN0IGVycm9yIG1lc3NhZ2UsIE5VTEwgaWYgbm8gZXJyb3IgKi9cbiAgdGhpcy5tc2cgPSAnJy8qWl9OVUxMKi87XG4gIC8qIG5vdCB2aXNpYmxlIGJ5IGFwcGxpY2F0aW9ucyAqL1xuICB0aGlzLnN0YXRlID0gbnVsbDtcbiAgLyogYmVzdCBndWVzcyBhYm91dCB0aGUgZGF0YSB0eXBlOiBiaW5hcnkgb3IgdGV4dCAqL1xuICB0aGlzLmRhdGFfdHlwZSA9IDIvKlpfVU5LTk9XTiovO1xuICAvKiBhZGxlcjMyIHZhbHVlIG9mIHRoZSB1bmNvbXByZXNzZWQgZGF0YSAqL1xuICB0aGlzLmFkbGVyID0gMDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBaU3RyZWFtO1xuIiwibW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBpc0J1ZmZlcihhcmcpIHtcbiAgcmV0dXJuIGFyZyAmJiB0eXBlb2YgYXJnID09PSAnb2JqZWN0J1xuICAgICYmIHR5cGVvZiBhcmcuY29weSA9PT0gJ2Z1bmN0aW9uJ1xuICAgICYmIHR5cGVvZiBhcmcuZmlsbCA9PT0gJ2Z1bmN0aW9uJ1xuICAgICYmIHR5cGVvZiBhcmcucmVhZFVJbnQ4ID09PSAnZnVuY3Rpb24nO1xufSIsIihmdW5jdGlvbiAocHJvY2VzcyxnbG9iYWwpe1xuLy8gQ29weXJpZ2h0IEpveWVudCwgSW5jLiBhbmQgb3RoZXIgTm9kZSBjb250cmlidXRvcnMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGFcbi8vIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcbi8vIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xuLy8gd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxuLy8gZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdFxuLy8gcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlXG4vLyBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZFxuLy8gaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTU1xuLy8gT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuLy8gTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTlxuLy8gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sXG4vLyBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1Jcbi8vIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEVcbi8vIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG5cbnZhciBmb3JtYXRSZWdFeHAgPSAvJVtzZGolXS9nO1xuZXhwb3J0cy5mb3JtYXQgPSBmdW5jdGlvbihmKSB7XG4gIGlmICghaXNTdHJpbmcoZikpIHtcbiAgICB2YXIgb2JqZWN0cyA9IFtdO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBvYmplY3RzLnB1c2goaW5zcGVjdChhcmd1bWVudHNbaV0pKTtcbiAgICB9XG4gICAgcmV0dXJuIG9iamVjdHMuam9pbignICcpO1xuICB9XG5cbiAgdmFyIGkgPSAxO1xuICB2YXIgYXJncyA9IGFyZ3VtZW50cztcbiAgdmFyIGxlbiA9IGFyZ3MubGVuZ3RoO1xuICB2YXIgc3RyID0gU3RyaW5nKGYpLnJlcGxhY2UoZm9ybWF0UmVnRXhwLCBmdW5jdGlvbih4KSB7XG4gICAgaWYgKHggPT09ICclJScpIHJldHVybiAnJSc7XG4gICAgaWYgKGkgPj0gbGVuKSByZXR1cm4geDtcbiAgICBzd2l0Y2ggKHgpIHtcbiAgICAgIGNhc2UgJyVzJzogcmV0dXJuIFN0cmluZyhhcmdzW2krK10pO1xuICAgICAgY2FzZSAnJWQnOiByZXR1cm4gTnVtYmVyKGFyZ3NbaSsrXSk7XG4gICAgICBjYXNlICclaic6XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KGFyZ3NbaSsrXSk7XG4gICAgICAgIH0gY2F0Y2ggKF8pIHtcbiAgICAgICAgICByZXR1cm4gJ1tDaXJjdWxhcl0nO1xuICAgICAgICB9XG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm4geDtcbiAgICB9XG4gIH0pO1xuICBmb3IgKHZhciB4ID0gYXJnc1tpXTsgaSA8IGxlbjsgeCA9IGFyZ3NbKytpXSkge1xuICAgIGlmIChpc051bGwoeCkgfHwgIWlzT2JqZWN0KHgpKSB7XG4gICAgICBzdHIgKz0gJyAnICsgeDtcbiAgICB9IGVsc2Uge1xuICAgICAgc3RyICs9ICcgJyArIGluc3BlY3QoeCk7XG4gICAgfVxuICB9XG4gIHJldHVybiBzdHI7XG59O1xuXG5cbi8vIE1hcmsgdGhhdCBhIG1ldGhvZCBzaG91bGQgbm90IGJlIHVzZWQuXG4vLyBSZXR1cm5zIGEgbW9kaWZpZWQgZnVuY3Rpb24gd2hpY2ggd2FybnMgb25jZSBieSBkZWZhdWx0LlxuLy8gSWYgLS1uby1kZXByZWNhdGlvbiBpcyBzZXQsIHRoZW4gaXQgaXMgYSBuby1vcC5cbmV4cG9ydHMuZGVwcmVjYXRlID0gZnVuY3Rpb24oZm4sIG1zZykge1xuICAvLyBBbGxvdyBmb3IgZGVwcmVjYXRpbmcgdGhpbmdzIGluIHRoZSBwcm9jZXNzIG9mIHN0YXJ0aW5nIHVwLlxuICBpZiAoaXNVbmRlZmluZWQoZ2xvYmFsLnByb2Nlc3MpKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIGV4cG9ydHMuZGVwcmVjYXRlKGZuLCBtc2cpLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfTtcbiAgfVxuXG4gIGlmIChwcm9jZXNzLm5vRGVwcmVjYXRpb24gPT09IHRydWUpIHtcbiAgICByZXR1cm4gZm47XG4gIH1cblxuICB2YXIgd2FybmVkID0gZmFsc2U7XG4gIGZ1bmN0aW9uIGRlcHJlY2F0ZWQoKSB7XG4gICAgaWYgKCF3YXJuZWQpIHtcbiAgICAgIGlmIChwcm9jZXNzLnRocm93RGVwcmVjYXRpb24pIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKG1zZyk7XG4gICAgICB9IGVsc2UgaWYgKHByb2Nlc3MudHJhY2VEZXByZWNhdGlvbikge1xuICAgICAgICBjb25zb2xlLnRyYWNlKG1zZyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zb2xlLmVycm9yKG1zZyk7XG4gICAgICB9XG4gICAgICB3YXJuZWQgPSB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gZm4uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgfVxuXG4gIHJldHVybiBkZXByZWNhdGVkO1xufTtcblxuXG52YXIgZGVidWdzID0ge307XG52YXIgZGVidWdFbnZpcm9uO1xuZXhwb3J0cy5kZWJ1Z2xvZyA9IGZ1bmN0aW9uKHNldCkge1xuICBpZiAoaXNVbmRlZmluZWQoZGVidWdFbnZpcm9uKSlcbiAgICBkZWJ1Z0Vudmlyb24gPSBwcm9jZXNzLmVudi5OT0RFX0RFQlVHIHx8ICcnO1xuICBzZXQgPSBzZXQudG9VcHBlckNhc2UoKTtcbiAgaWYgKCFkZWJ1Z3Nbc2V0XSkge1xuICAgIGlmIChuZXcgUmVnRXhwKCdcXFxcYicgKyBzZXQgKyAnXFxcXGInLCAnaScpLnRlc3QoZGVidWdFbnZpcm9uKSkge1xuICAgICAgdmFyIHBpZCA9IHByb2Nlc3MucGlkO1xuICAgICAgZGVidWdzW3NldF0gPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIG1zZyA9IGV4cG9ydHMuZm9ybWF0LmFwcGx5KGV4cG9ydHMsIGFyZ3VtZW50cyk7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJyVzICVkOiAlcycsIHNldCwgcGlkLCBtc2cpO1xuICAgICAgfTtcbiAgICB9IGVsc2Uge1xuICAgICAgZGVidWdzW3NldF0gPSBmdW5jdGlvbigpIHt9O1xuICAgIH1cbiAgfVxuICByZXR1cm4gZGVidWdzW3NldF07XG59O1xuXG5cbi8qKlxuICogRWNob3MgdGhlIHZhbHVlIG9mIGEgdmFsdWUuIFRyeXMgdG8gcHJpbnQgdGhlIHZhbHVlIG91dFxuICogaW4gdGhlIGJlc3Qgd2F5IHBvc3NpYmxlIGdpdmVuIHRoZSBkaWZmZXJlbnQgdHlwZXMuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IG9iaiBUaGUgb2JqZWN0IHRvIHByaW50IG91dC5cbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzIE9wdGlvbmFsIG9wdGlvbnMgb2JqZWN0IHRoYXQgYWx0ZXJzIHRoZSBvdXRwdXQuXG4gKi9cbi8qIGxlZ2FjeTogb2JqLCBzaG93SGlkZGVuLCBkZXB0aCwgY29sb3JzKi9cbmZ1bmN0aW9uIGluc3BlY3Qob2JqLCBvcHRzKSB7XG4gIC8vIGRlZmF1bHQgb3B0aW9uc1xuICB2YXIgY3R4ID0ge1xuICAgIHNlZW46IFtdLFxuICAgIHN0eWxpemU6IHN0eWxpemVOb0NvbG9yXG4gIH07XG4gIC8vIGxlZ2FjeS4uLlxuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+PSAzKSBjdHguZGVwdGggPSBhcmd1bWVudHNbMl07XG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID49IDQpIGN0eC5jb2xvcnMgPSBhcmd1bWVudHNbM107XG4gIGlmIChpc0Jvb2xlYW4ob3B0cykpIHtcbiAgICAvLyBsZWdhY3kuLi5cbiAgICBjdHguc2hvd0hpZGRlbiA9IG9wdHM7XG4gIH0gZWxzZSBpZiAob3B0cykge1xuICAgIC8vIGdvdCBhbiBcIm9wdGlvbnNcIiBvYmplY3RcbiAgICBleHBvcnRzLl9leHRlbmQoY3R4LCBvcHRzKTtcbiAgfVxuICAvLyBzZXQgZGVmYXVsdCBvcHRpb25zXG4gIGlmIChpc1VuZGVmaW5lZChjdHguc2hvd0hpZGRlbikpIGN0eC5zaG93SGlkZGVuID0gZmFsc2U7XG4gIGlmIChpc1VuZGVmaW5lZChjdHguZGVwdGgpKSBjdHguZGVwdGggPSAyO1xuICBpZiAoaXNVbmRlZmluZWQoY3R4LmNvbG9ycykpIGN0eC5jb2xvcnMgPSBmYWxzZTtcbiAgaWYgKGlzVW5kZWZpbmVkKGN0eC5jdXN0b21JbnNwZWN0KSkgY3R4LmN1c3RvbUluc3BlY3QgPSB0cnVlO1xuICBpZiAoY3R4LmNvbG9ycykgY3R4LnN0eWxpemUgPSBzdHlsaXplV2l0aENvbG9yO1xuICByZXR1cm4gZm9ybWF0VmFsdWUoY3R4LCBvYmosIGN0eC5kZXB0aCk7XG59XG5leHBvcnRzLmluc3BlY3QgPSBpbnNwZWN0O1xuXG5cbi8vIGh0dHA6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvQU5TSV9lc2NhcGVfY29kZSNncmFwaGljc1xuaW5zcGVjdC5jb2xvcnMgPSB7XG4gICdib2xkJyA6IFsxLCAyMl0sXG4gICdpdGFsaWMnIDogWzMsIDIzXSxcbiAgJ3VuZGVybGluZScgOiBbNCwgMjRdLFxuICAnaW52ZXJzZScgOiBbNywgMjddLFxuICAnd2hpdGUnIDogWzM3LCAzOV0sXG4gICdncmV5JyA6IFs5MCwgMzldLFxuICAnYmxhY2snIDogWzMwLCAzOV0sXG4gICdibHVlJyA6IFszNCwgMzldLFxuICAnY3lhbicgOiBbMzYsIDM5XSxcbiAgJ2dyZWVuJyA6IFszMiwgMzldLFxuICAnbWFnZW50YScgOiBbMzUsIDM5XSxcbiAgJ3JlZCcgOiBbMzEsIDM5XSxcbiAgJ3llbGxvdycgOiBbMzMsIDM5XVxufTtcblxuLy8gRG9uJ3QgdXNlICdibHVlJyBub3QgdmlzaWJsZSBvbiBjbWQuZXhlXG5pbnNwZWN0LnN0eWxlcyA9IHtcbiAgJ3NwZWNpYWwnOiAnY3lhbicsXG4gICdudW1iZXInOiAneWVsbG93JyxcbiAgJ2Jvb2xlYW4nOiAneWVsbG93JyxcbiAgJ3VuZGVmaW5lZCc6ICdncmV5JyxcbiAgJ251bGwnOiAnYm9sZCcsXG4gICdzdHJpbmcnOiAnZ3JlZW4nLFxuICAnZGF0ZSc6ICdtYWdlbnRhJyxcbiAgLy8gXCJuYW1lXCI6IGludGVudGlvbmFsbHkgbm90IHN0eWxpbmdcbiAgJ3JlZ2V4cCc6ICdyZWQnXG59O1xuXG5cbmZ1bmN0aW9uIHN0eWxpemVXaXRoQ29sb3Ioc3RyLCBzdHlsZVR5cGUpIHtcbiAgdmFyIHN0eWxlID0gaW5zcGVjdC5zdHlsZXNbc3R5bGVUeXBlXTtcblxuICBpZiAoc3R5bGUpIHtcbiAgICByZXR1cm4gJ1xcdTAwMWJbJyArIGluc3BlY3QuY29sb3JzW3N0eWxlXVswXSArICdtJyArIHN0ciArXG4gICAgICAgICAgICdcXHUwMDFiWycgKyBpbnNwZWN0LmNvbG9yc1tzdHlsZV1bMV0gKyAnbSc7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHN0cjtcbiAgfVxufVxuXG5cbmZ1bmN0aW9uIHN0eWxpemVOb0NvbG9yKHN0ciwgc3R5bGVUeXBlKSB7XG4gIHJldHVybiBzdHI7XG59XG5cblxuZnVuY3Rpb24gYXJyYXlUb0hhc2goYXJyYXkpIHtcbiAgdmFyIGhhc2ggPSB7fTtcblxuICBhcnJheS5mb3JFYWNoKGZ1bmN0aW9uKHZhbCwgaWR4KSB7XG4gICAgaGFzaFt2YWxdID0gdHJ1ZTtcbiAgfSk7XG5cbiAgcmV0dXJuIGhhc2g7XG59XG5cblxuZnVuY3Rpb24gZm9ybWF0VmFsdWUoY3R4LCB2YWx1ZSwgcmVjdXJzZVRpbWVzKSB7XG4gIC8vIFByb3ZpZGUgYSBob29rIGZvciB1c2VyLXNwZWNpZmllZCBpbnNwZWN0IGZ1bmN0aW9ucy5cbiAgLy8gQ2hlY2sgdGhhdCB2YWx1ZSBpcyBhbiBvYmplY3Qgd2l0aCBhbiBpbnNwZWN0IGZ1bmN0aW9uIG9uIGl0XG4gIGlmIChjdHguY3VzdG9tSW5zcGVjdCAmJlxuICAgICAgdmFsdWUgJiZcbiAgICAgIGlzRnVuY3Rpb24odmFsdWUuaW5zcGVjdCkgJiZcbiAgICAgIC8vIEZpbHRlciBvdXQgdGhlIHV0aWwgbW9kdWxlLCBpdCdzIGluc3BlY3QgZnVuY3Rpb24gaXMgc3BlY2lhbFxuICAgICAgdmFsdWUuaW5zcGVjdCAhPT0gZXhwb3J0cy5pbnNwZWN0ICYmXG4gICAgICAvLyBBbHNvIGZpbHRlciBvdXQgYW55IHByb3RvdHlwZSBvYmplY3RzIHVzaW5nIHRoZSBjaXJjdWxhciBjaGVjay5cbiAgICAgICEodmFsdWUuY29uc3RydWN0b3IgJiYgdmFsdWUuY29uc3RydWN0b3IucHJvdG90eXBlID09PSB2YWx1ZSkpIHtcbiAgICB2YXIgcmV0ID0gdmFsdWUuaW5zcGVjdChyZWN1cnNlVGltZXMsIGN0eCk7XG4gICAgaWYgKCFpc1N0cmluZyhyZXQpKSB7XG4gICAgICByZXQgPSBmb3JtYXRWYWx1ZShjdHgsIHJldCwgcmVjdXJzZVRpbWVzKTtcbiAgICB9XG4gICAgcmV0dXJuIHJldDtcbiAgfVxuXG4gIC8vIFByaW1pdGl2ZSB0eXBlcyBjYW5ub3QgaGF2ZSBwcm9wZXJ0aWVzXG4gIHZhciBwcmltaXRpdmUgPSBmb3JtYXRQcmltaXRpdmUoY3R4LCB2YWx1ZSk7XG4gIGlmIChwcmltaXRpdmUpIHtcbiAgICByZXR1cm4gcHJpbWl0aXZlO1xuICB9XG5cbiAgLy8gTG9vayB1cCB0aGUga2V5cyBvZiB0aGUgb2JqZWN0LlxuICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKHZhbHVlKTtcbiAgdmFyIHZpc2libGVLZXlzID0gYXJyYXlUb0hhc2goa2V5cyk7XG5cbiAgaWYgKGN0eC5zaG93SGlkZGVuKSB7XG4gICAga2V5cyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKHZhbHVlKTtcbiAgfVxuXG4gIC8vIElFIGRvZXNuJ3QgbWFrZSBlcnJvciBmaWVsZHMgbm9uLWVudW1lcmFibGVcbiAgLy8gaHR0cDovL21zZG4ubWljcm9zb2Z0LmNvbS9lbi11cy9saWJyYXJ5L2llL2R3dzUyc2J0KHY9dnMuOTQpLmFzcHhcbiAgaWYgKGlzRXJyb3IodmFsdWUpXG4gICAgICAmJiAoa2V5cy5pbmRleE9mKCdtZXNzYWdlJykgPj0gMCB8fCBrZXlzLmluZGV4T2YoJ2Rlc2NyaXB0aW9uJykgPj0gMCkpIHtcbiAgICByZXR1cm4gZm9ybWF0RXJyb3IodmFsdWUpO1xuICB9XG5cbiAgLy8gU29tZSB0eXBlIG9mIG9iamVjdCB3aXRob3V0IHByb3BlcnRpZXMgY2FuIGJlIHNob3J0Y3V0dGVkLlxuICBpZiAoa2V5cy5sZW5ndGggPT09IDApIHtcbiAgICBpZiAoaXNGdW5jdGlvbih2YWx1ZSkpIHtcbiAgICAgIHZhciBuYW1lID0gdmFsdWUubmFtZSA/ICc6ICcgKyB2YWx1ZS5uYW1lIDogJyc7XG4gICAgICByZXR1cm4gY3R4LnN0eWxpemUoJ1tGdW5jdGlvbicgKyBuYW1lICsgJ10nLCAnc3BlY2lhbCcpO1xuICAgIH1cbiAgICBpZiAoaXNSZWdFeHAodmFsdWUpKSB7XG4gICAgICByZXR1cm4gY3R4LnN0eWxpemUoUmVnRXhwLnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHZhbHVlKSwgJ3JlZ2V4cCcpO1xuICAgIH1cbiAgICBpZiAoaXNEYXRlKHZhbHVlKSkge1xuICAgICAgcmV0dXJuIGN0eC5zdHlsaXplKERhdGUucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodmFsdWUpLCAnZGF0ZScpO1xuICAgIH1cbiAgICBpZiAoaXNFcnJvcih2YWx1ZSkpIHtcbiAgICAgIHJldHVybiBmb3JtYXRFcnJvcih2YWx1ZSk7XG4gICAgfVxuICB9XG5cbiAgdmFyIGJhc2UgPSAnJywgYXJyYXkgPSBmYWxzZSwgYnJhY2VzID0gWyd7JywgJ30nXTtcblxuICAvLyBNYWtlIEFycmF5IHNheSB0aGF0IHRoZXkgYXJlIEFycmF5XG4gIGlmIChpc0FycmF5KHZhbHVlKSkge1xuICAgIGFycmF5ID0gdHJ1ZTtcbiAgICBicmFjZXMgPSBbJ1snLCAnXSddO1xuICB9XG5cbiAgLy8gTWFrZSBmdW5jdGlvbnMgc2F5IHRoYXQgdGhleSBhcmUgZnVuY3Rpb25zXG4gIGlmIChpc0Z1bmN0aW9uKHZhbHVlKSkge1xuICAgIHZhciBuID0gdmFsdWUubmFtZSA/ICc6ICcgKyB2YWx1ZS5uYW1lIDogJyc7XG4gICAgYmFzZSA9ICcgW0Z1bmN0aW9uJyArIG4gKyAnXSc7XG4gIH1cblxuICAvLyBNYWtlIFJlZ0V4cHMgc2F5IHRoYXQgdGhleSBhcmUgUmVnRXhwc1xuICBpZiAoaXNSZWdFeHAodmFsdWUpKSB7XG4gICAgYmFzZSA9ICcgJyArIFJlZ0V4cC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh2YWx1ZSk7XG4gIH1cblxuICAvLyBNYWtlIGRhdGVzIHdpdGggcHJvcGVydGllcyBmaXJzdCBzYXkgdGhlIGRhdGVcbiAgaWYgKGlzRGF0ZSh2YWx1ZSkpIHtcbiAgICBiYXNlID0gJyAnICsgRGF0ZS5wcm90b3R5cGUudG9VVENTdHJpbmcuY2FsbCh2YWx1ZSk7XG4gIH1cblxuICAvLyBNYWtlIGVycm9yIHdpdGggbWVzc2FnZSBmaXJzdCBzYXkgdGhlIGVycm9yXG4gIGlmIChpc0Vycm9yKHZhbHVlKSkge1xuICAgIGJhc2UgPSAnICcgKyBmb3JtYXRFcnJvcih2YWx1ZSk7XG4gIH1cblxuICBpZiAoa2V5cy5sZW5ndGggPT09IDAgJiYgKCFhcnJheSB8fCB2YWx1ZS5sZW5ndGggPT0gMCkpIHtcbiAgICByZXR1cm4gYnJhY2VzWzBdICsgYmFzZSArIGJyYWNlc1sxXTtcbiAgfVxuXG4gIGlmIChyZWN1cnNlVGltZXMgPCAwKSB7XG4gICAgaWYgKGlzUmVnRXhwKHZhbHVlKSkge1xuICAgICAgcmV0dXJuIGN0eC5zdHlsaXplKFJlZ0V4cC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh2YWx1ZSksICdyZWdleHAnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGN0eC5zdHlsaXplKCdbT2JqZWN0XScsICdzcGVjaWFsJyk7XG4gICAgfVxuICB9XG5cbiAgY3R4LnNlZW4ucHVzaCh2YWx1ZSk7XG5cbiAgdmFyIG91dHB1dDtcbiAgaWYgKGFycmF5KSB7XG4gICAgb3V0cHV0ID0gZm9ybWF0QXJyYXkoY3R4LCB2YWx1ZSwgcmVjdXJzZVRpbWVzLCB2aXNpYmxlS2V5cywga2V5cyk7XG4gIH0gZWxzZSB7XG4gICAgb3V0cHV0ID0ga2V5cy5tYXAoZnVuY3Rpb24oa2V5KSB7XG4gICAgICByZXR1cm4gZm9ybWF0UHJvcGVydHkoY3R4LCB2YWx1ZSwgcmVjdXJzZVRpbWVzLCB2aXNpYmxlS2V5cywga2V5LCBhcnJheSk7XG4gICAgfSk7XG4gIH1cblxuICBjdHguc2Vlbi5wb3AoKTtcblxuICByZXR1cm4gcmVkdWNlVG9TaW5nbGVTdHJpbmcob3V0cHV0LCBiYXNlLCBicmFjZXMpO1xufVxuXG5cbmZ1bmN0aW9uIGZvcm1hdFByaW1pdGl2ZShjdHgsIHZhbHVlKSB7XG4gIGlmIChpc1VuZGVmaW5lZCh2YWx1ZSkpXG4gICAgcmV0dXJuIGN0eC5zdHlsaXplKCd1bmRlZmluZWQnLCAndW5kZWZpbmVkJyk7XG4gIGlmIChpc1N0cmluZyh2YWx1ZSkpIHtcbiAgICB2YXIgc2ltcGxlID0gJ1xcJycgKyBKU09OLnN0cmluZ2lmeSh2YWx1ZSkucmVwbGFjZSgvXlwifFwiJC9nLCAnJylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5yZXBsYWNlKC8nL2csIFwiXFxcXCdcIilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5yZXBsYWNlKC9cXFxcXCIvZywgJ1wiJykgKyAnXFwnJztcbiAgICByZXR1cm4gY3R4LnN0eWxpemUoc2ltcGxlLCAnc3RyaW5nJyk7XG4gIH1cbiAgaWYgKGlzTnVtYmVyKHZhbHVlKSlcbiAgICByZXR1cm4gY3R4LnN0eWxpemUoJycgKyB2YWx1ZSwgJ251bWJlcicpO1xuICBpZiAoaXNCb29sZWFuKHZhbHVlKSlcbiAgICByZXR1cm4gY3R4LnN0eWxpemUoJycgKyB2YWx1ZSwgJ2Jvb2xlYW4nKTtcbiAgLy8gRm9yIHNvbWUgcmVhc29uIHR5cGVvZiBudWxsIGlzIFwib2JqZWN0XCIsIHNvIHNwZWNpYWwgY2FzZSBoZXJlLlxuICBpZiAoaXNOdWxsKHZhbHVlKSlcbiAgICByZXR1cm4gY3R4LnN0eWxpemUoJ251bGwnLCAnbnVsbCcpO1xufVxuXG5cbmZ1bmN0aW9uIGZvcm1hdEVycm9yKHZhbHVlKSB7XG4gIHJldHVybiAnWycgKyBFcnJvci5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh2YWx1ZSkgKyAnXSc7XG59XG5cblxuZnVuY3Rpb24gZm9ybWF0QXJyYXkoY3R4LCB2YWx1ZSwgcmVjdXJzZVRpbWVzLCB2aXNpYmxlS2V5cywga2V5cykge1xuICB2YXIgb3V0cHV0ID0gW107XG4gIGZvciAodmFyIGkgPSAwLCBsID0gdmFsdWUubGVuZ3RoOyBpIDwgbDsgKytpKSB7XG4gICAgaWYgKGhhc093blByb3BlcnR5KHZhbHVlLCBTdHJpbmcoaSkpKSB7XG4gICAgICBvdXRwdXQucHVzaChmb3JtYXRQcm9wZXJ0eShjdHgsIHZhbHVlLCByZWN1cnNlVGltZXMsIHZpc2libGVLZXlzLFxuICAgICAgICAgIFN0cmluZyhpKSwgdHJ1ZSkpO1xuICAgIH0gZWxzZSB7XG4gICAgICBvdXRwdXQucHVzaCgnJyk7XG4gICAgfVxuICB9XG4gIGtleXMuZm9yRWFjaChmdW5jdGlvbihrZXkpIHtcbiAgICBpZiAoIWtleS5tYXRjaCgvXlxcZCskLykpIHtcbiAgICAgIG91dHB1dC5wdXNoKGZvcm1hdFByb3BlcnR5KGN0eCwgdmFsdWUsIHJlY3Vyc2VUaW1lcywgdmlzaWJsZUtleXMsXG4gICAgICAgICAga2V5LCB0cnVlKSk7XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIG91dHB1dDtcbn1cblxuXG5mdW5jdGlvbiBmb3JtYXRQcm9wZXJ0eShjdHgsIHZhbHVlLCByZWN1cnNlVGltZXMsIHZpc2libGVLZXlzLCBrZXksIGFycmF5KSB7XG4gIHZhciBuYW1lLCBzdHIsIGRlc2M7XG4gIGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHZhbHVlLCBrZXkpIHx8IHsgdmFsdWU6IHZhbHVlW2tleV0gfTtcbiAgaWYgKGRlc2MuZ2V0KSB7XG4gICAgaWYgKGRlc2Muc2V0KSB7XG4gICAgICBzdHIgPSBjdHguc3R5bGl6ZSgnW0dldHRlci9TZXR0ZXJdJywgJ3NwZWNpYWwnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgc3RyID0gY3R4LnN0eWxpemUoJ1tHZXR0ZXJdJywgJ3NwZWNpYWwnKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgaWYgKGRlc2Muc2V0KSB7XG4gICAgICBzdHIgPSBjdHguc3R5bGl6ZSgnW1NldHRlcl0nLCAnc3BlY2lhbCcpO1xuICAgIH1cbiAgfVxuICBpZiAoIWhhc093blByb3BlcnR5KHZpc2libGVLZXlzLCBrZXkpKSB7XG4gICAgbmFtZSA9ICdbJyArIGtleSArICddJztcbiAgfVxuICBpZiAoIXN0cikge1xuICAgIGlmIChjdHguc2Vlbi5pbmRleE9mKGRlc2MudmFsdWUpIDwgMCkge1xuICAgICAgaWYgKGlzTnVsbChyZWN1cnNlVGltZXMpKSB7XG4gICAgICAgIHN0ciA9IGZvcm1hdFZhbHVlKGN0eCwgZGVzYy52YWx1ZSwgbnVsbCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzdHIgPSBmb3JtYXRWYWx1ZShjdHgsIGRlc2MudmFsdWUsIHJlY3Vyc2VUaW1lcyAtIDEpO1xuICAgICAgfVxuICAgICAgaWYgKHN0ci5pbmRleE9mKCdcXG4nKSA+IC0xKSB7XG4gICAgICAgIGlmIChhcnJheSkge1xuICAgICAgICAgIHN0ciA9IHN0ci5zcGxpdCgnXFxuJykubWFwKGZ1bmN0aW9uKGxpbmUpIHtcbiAgICAgICAgICAgIHJldHVybiAnICAnICsgbGluZTtcbiAgICAgICAgICB9KS5qb2luKCdcXG4nKS5zdWJzdHIoMik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgc3RyID0gJ1xcbicgKyBzdHIuc3BsaXQoJ1xcbicpLm1hcChmdW5jdGlvbihsaW5lKSB7XG4gICAgICAgICAgICByZXR1cm4gJyAgICcgKyBsaW5lO1xuICAgICAgICAgIH0pLmpvaW4oJ1xcbicpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHN0ciA9IGN0eC5zdHlsaXplKCdbQ2lyY3VsYXJdJywgJ3NwZWNpYWwnKTtcbiAgICB9XG4gIH1cbiAgaWYgKGlzVW5kZWZpbmVkKG5hbWUpKSB7XG4gICAgaWYgKGFycmF5ICYmIGtleS5tYXRjaCgvXlxcZCskLykpIHtcbiAgICAgIHJldHVybiBzdHI7XG4gICAgfVxuICAgIG5hbWUgPSBKU09OLnN0cmluZ2lmeSgnJyArIGtleSk7XG4gICAgaWYgKG5hbWUubWF0Y2goL15cIihbYS16QS1aX11bYS16QS1aXzAtOV0qKVwiJC8pKSB7XG4gICAgICBuYW1lID0gbmFtZS5zdWJzdHIoMSwgbmFtZS5sZW5ndGggLSAyKTtcbiAgICAgIG5hbWUgPSBjdHguc3R5bGl6ZShuYW1lLCAnbmFtZScpO1xuICAgIH0gZWxzZSB7XG4gICAgICBuYW1lID0gbmFtZS5yZXBsYWNlKC8nL2csIFwiXFxcXCdcIilcbiAgICAgICAgICAgICAgICAgLnJlcGxhY2UoL1xcXFxcIi9nLCAnXCInKVxuICAgICAgICAgICAgICAgICAucmVwbGFjZSgvKF5cInxcIiQpL2csIFwiJ1wiKTtcbiAgICAgIG5hbWUgPSBjdHguc3R5bGl6ZShuYW1lLCAnc3RyaW5nJyk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG5hbWUgKyAnOiAnICsgc3RyO1xufVxuXG5cbmZ1bmN0aW9uIHJlZHVjZVRvU2luZ2xlU3RyaW5nKG91dHB1dCwgYmFzZSwgYnJhY2VzKSB7XG4gIHZhciBudW1MaW5lc0VzdCA9IDA7XG4gIHZhciBsZW5ndGggPSBvdXRwdXQucmVkdWNlKGZ1bmN0aW9uKHByZXYsIGN1cikge1xuICAgIG51bUxpbmVzRXN0Kys7XG4gICAgaWYgKGN1ci5pbmRleE9mKCdcXG4nKSA+PSAwKSBudW1MaW5lc0VzdCsrO1xuICAgIHJldHVybiBwcmV2ICsgY3VyLnJlcGxhY2UoL1xcdTAwMWJcXFtcXGRcXGQ/bS9nLCAnJykubGVuZ3RoICsgMTtcbiAgfSwgMCk7XG5cbiAgaWYgKGxlbmd0aCA+IDYwKSB7XG4gICAgcmV0dXJuIGJyYWNlc1swXSArXG4gICAgICAgICAgIChiYXNlID09PSAnJyA/ICcnIDogYmFzZSArICdcXG4gJykgK1xuICAgICAgICAgICAnICcgK1xuICAgICAgICAgICBvdXRwdXQuam9pbignLFxcbiAgJykgK1xuICAgICAgICAgICAnICcgK1xuICAgICAgICAgICBicmFjZXNbMV07XG4gIH1cblxuICByZXR1cm4gYnJhY2VzWzBdICsgYmFzZSArICcgJyArIG91dHB1dC5qb2luKCcsICcpICsgJyAnICsgYnJhY2VzWzFdO1xufVxuXG5cbi8vIE5PVEU6IFRoZXNlIHR5cGUgY2hlY2tpbmcgZnVuY3Rpb25zIGludGVudGlvbmFsbHkgZG9uJ3QgdXNlIGBpbnN0YW5jZW9mYFxuLy8gYmVjYXVzZSBpdCBpcyBmcmFnaWxlIGFuZCBjYW4gYmUgZWFzaWx5IGZha2VkIHdpdGggYE9iamVjdC5jcmVhdGUoKWAuXG5mdW5jdGlvbiBpc0FycmF5KGFyKSB7XG4gIHJldHVybiBBcnJheS5pc0FycmF5KGFyKTtcbn1cbmV4cG9ydHMuaXNBcnJheSA9IGlzQXJyYXk7XG5cbmZ1bmN0aW9uIGlzQm9vbGVhbihhcmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdib29sZWFuJztcbn1cbmV4cG9ydHMuaXNCb29sZWFuID0gaXNCb29sZWFuO1xuXG5mdW5jdGlvbiBpc051bGwoYXJnKSB7XG4gIHJldHVybiBhcmcgPT09IG51bGw7XG59XG5leHBvcnRzLmlzTnVsbCA9IGlzTnVsbDtcblxuZnVuY3Rpb24gaXNOdWxsT3JVbmRlZmluZWQoYXJnKSB7XG4gIHJldHVybiBhcmcgPT0gbnVsbDtcbn1cbmV4cG9ydHMuaXNOdWxsT3JVbmRlZmluZWQgPSBpc051bGxPclVuZGVmaW5lZDtcblxuZnVuY3Rpb24gaXNOdW1iZXIoYXJnKSB7XG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnbnVtYmVyJztcbn1cbmV4cG9ydHMuaXNOdW1iZXIgPSBpc051bWJlcjtcblxuZnVuY3Rpb24gaXNTdHJpbmcoYXJnKSB7XG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnc3RyaW5nJztcbn1cbmV4cG9ydHMuaXNTdHJpbmcgPSBpc1N0cmluZztcblxuZnVuY3Rpb24gaXNTeW1ib2woYXJnKSB7XG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnc3ltYm9sJztcbn1cbmV4cG9ydHMuaXNTeW1ib2wgPSBpc1N5bWJvbDtcblxuZnVuY3Rpb24gaXNVbmRlZmluZWQoYXJnKSB7XG4gIHJldHVybiBhcmcgPT09IHZvaWQgMDtcbn1cbmV4cG9ydHMuaXNVbmRlZmluZWQgPSBpc1VuZGVmaW5lZDtcblxuZnVuY3Rpb24gaXNSZWdFeHAocmUpIHtcbiAgcmV0dXJuIGlzT2JqZWN0KHJlKSAmJiBvYmplY3RUb1N0cmluZyhyZSkgPT09ICdbb2JqZWN0IFJlZ0V4cF0nO1xufVxuZXhwb3J0cy5pc1JlZ0V4cCA9IGlzUmVnRXhwO1xuXG5mdW5jdGlvbiBpc09iamVjdChhcmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdvYmplY3QnICYmIGFyZyAhPT0gbnVsbDtcbn1cbmV4cG9ydHMuaXNPYmplY3QgPSBpc09iamVjdDtcblxuZnVuY3Rpb24gaXNEYXRlKGQpIHtcbiAgcmV0dXJuIGlzT2JqZWN0KGQpICYmIG9iamVjdFRvU3RyaW5nKGQpID09PSAnW29iamVjdCBEYXRlXSc7XG59XG5leHBvcnRzLmlzRGF0ZSA9IGlzRGF0ZTtcblxuZnVuY3Rpb24gaXNFcnJvcihlKSB7XG4gIHJldHVybiBpc09iamVjdChlKSAmJlxuICAgICAgKG9iamVjdFRvU3RyaW5nKGUpID09PSAnW29iamVjdCBFcnJvcl0nIHx8IGUgaW5zdGFuY2VvZiBFcnJvcik7XG59XG5leHBvcnRzLmlzRXJyb3IgPSBpc0Vycm9yO1xuXG5mdW5jdGlvbiBpc0Z1bmN0aW9uKGFyZykge1xuICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ2Z1bmN0aW9uJztcbn1cbmV4cG9ydHMuaXNGdW5jdGlvbiA9IGlzRnVuY3Rpb247XG5cbmZ1bmN0aW9uIGlzUHJpbWl0aXZlKGFyZykge1xuICByZXR1cm4gYXJnID09PSBudWxsIHx8XG4gICAgICAgICB0eXBlb2YgYXJnID09PSAnYm9vbGVhbicgfHxcbiAgICAgICAgIHR5cGVvZiBhcmcgPT09ICdudW1iZXInIHx8XG4gICAgICAgICB0eXBlb2YgYXJnID09PSAnc3RyaW5nJyB8fFxuICAgICAgICAgdHlwZW9mIGFyZyA9PT0gJ3N5bWJvbCcgfHwgIC8vIEVTNiBzeW1ib2xcbiAgICAgICAgIHR5cGVvZiBhcmcgPT09ICd1bmRlZmluZWQnO1xufVxuZXhwb3J0cy5pc1ByaW1pdGl2ZSA9IGlzUHJpbWl0aXZlO1xuXG5leHBvcnRzLmlzQnVmZmVyID0gcmVxdWlyZSgnLi9zdXBwb3J0L2lzQnVmZmVyJyk7XG5cbmZ1bmN0aW9uIG9iamVjdFRvU3RyaW5nKG8pIHtcbiAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvKTtcbn1cblxuXG5mdW5jdGlvbiBwYWQobikge1xuICByZXR1cm4gbiA8IDEwID8gJzAnICsgbi50b1N0cmluZygxMCkgOiBuLnRvU3RyaW5nKDEwKTtcbn1cblxuXG52YXIgbW9udGhzID0gWydKYW4nLCAnRmViJywgJ01hcicsICdBcHInLCAnTWF5JywgJ0p1bicsICdKdWwnLCAnQXVnJywgJ1NlcCcsXG4gICAgICAgICAgICAgICdPY3QnLCAnTm92JywgJ0RlYyddO1xuXG4vLyAyNiBGZWIgMTY6MTk6MzRcbmZ1bmN0aW9uIHRpbWVzdGFtcCgpIHtcbiAgdmFyIGQgPSBuZXcgRGF0ZSgpO1xuICB2YXIgdGltZSA9IFtwYWQoZC5nZXRIb3VycygpKSxcbiAgICAgICAgICAgICAgcGFkKGQuZ2V0TWludXRlcygpKSxcbiAgICAgICAgICAgICAgcGFkKGQuZ2V0U2Vjb25kcygpKV0uam9pbignOicpO1xuICByZXR1cm4gW2QuZ2V0RGF0ZSgpLCBtb250aHNbZC5nZXRNb250aCgpXSwgdGltZV0uam9pbignICcpO1xufVxuXG5cbi8vIGxvZyBpcyBqdXN0IGEgdGhpbiB3cmFwcGVyIHRvIGNvbnNvbGUubG9nIHRoYXQgcHJlcGVuZHMgYSB0aW1lc3RhbXBcbmV4cG9ydHMubG9nID0gZnVuY3Rpb24oKSB7XG4gIGNvbnNvbGUubG9nKCclcyAtICVzJywgdGltZXN0YW1wKCksIGV4cG9ydHMuZm9ybWF0LmFwcGx5KGV4cG9ydHMsIGFyZ3VtZW50cykpO1xufTtcblxuXG4vKipcbiAqIEluaGVyaXQgdGhlIHByb3RvdHlwZSBtZXRob2RzIGZyb20gb25lIGNvbnN0cnVjdG9yIGludG8gYW5vdGhlci5cbiAqXG4gKiBUaGUgRnVuY3Rpb24ucHJvdG90eXBlLmluaGVyaXRzIGZyb20gbGFuZy5qcyByZXdyaXR0ZW4gYXMgYSBzdGFuZGFsb25lXG4gKiBmdW5jdGlvbiAobm90IG9uIEZ1bmN0aW9uLnByb3RvdHlwZSkuIE5PVEU6IElmIHRoaXMgZmlsZSBpcyB0byBiZSBsb2FkZWRcbiAqIGR1cmluZyBib290c3RyYXBwaW5nIHRoaXMgZnVuY3Rpb24gbmVlZHMgdG8gYmUgcmV3cml0dGVuIHVzaW5nIHNvbWUgbmF0aXZlXG4gKiBmdW5jdGlvbnMgYXMgcHJvdG90eXBlIHNldHVwIHVzaW5nIG5vcm1hbCBKYXZhU2NyaXB0IGRvZXMgbm90IHdvcmsgYXNcbiAqIGV4cGVjdGVkIGR1cmluZyBib290c3RyYXBwaW5nIChzZWUgbWlycm9yLmpzIGluIHIxMTQ5MDMpLlxuICpcbiAqIEBwYXJhbSB7ZnVuY3Rpb259IGN0b3IgQ29uc3RydWN0b3IgZnVuY3Rpb24gd2hpY2ggbmVlZHMgdG8gaW5oZXJpdCB0aGVcbiAqICAgICBwcm90b3R5cGUuXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBzdXBlckN0b3IgQ29uc3RydWN0b3IgZnVuY3Rpb24gdG8gaW5oZXJpdCBwcm90b3R5cGUgZnJvbS5cbiAqL1xuZXhwb3J0cy5pbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJyk7XG5cbmV4cG9ydHMuX2V4dGVuZCA9IGZ1bmN0aW9uKG9yaWdpbiwgYWRkKSB7XG4gIC8vIERvbid0IGRvIGFueXRoaW5nIGlmIGFkZCBpc24ndCBhbiBvYmplY3RcbiAgaWYgKCFhZGQgfHwgIWlzT2JqZWN0KGFkZCkpIHJldHVybiBvcmlnaW47XG5cbiAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhhZGQpO1xuICB2YXIgaSA9IGtleXMubGVuZ3RoO1xuICB3aGlsZSAoaS0tKSB7XG4gICAgb3JpZ2luW2tleXNbaV1dID0gYWRkW2tleXNbaV1dO1xuICB9XG4gIHJldHVybiBvcmlnaW47XG59O1xuXG5mdW5jdGlvbiBoYXNPd25Qcm9wZXJ0eShvYmosIHByb3ApIHtcbiAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIHByb3ApO1xufVxuXG59KS5jYWxsKHRoaXMscmVxdWlyZShcIjdZS0lQZVwiKSx0eXBlb2Ygc2VsZiAhPT0gXCJ1bmRlZmluZWRcIiA/IHNlbGYgOiB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93IDoge30pIl19
